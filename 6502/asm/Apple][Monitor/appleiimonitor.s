; Port of Apple II monitor to Apple 1
;
; Original port by Winston Gayler with additional adaptations by
; Wendell Sander. Source code reverse-engineered and ported to CA65
; assembler by Jeff Tranter <tranter@pobox.com>.

; Define to get Apple 1 version, otherwise generates original Apple II
; code.
APPLE1 = 1

; Define if you want the Apple 1 Woz Monitor included in the build. Only
; works if start address is $F400.
;WOZMON = 1

; Macro to define a string in ASCII with high bit set on each character.
.macro Str Arg
    .repeat .strlen(Arg), I
    .byte   .strat(Arg, I) | $80
    .endrep
.endmacro

; ***********************
; *                     *
; * APPLE-II            *
; * MINI-ASSEMBLER      *
; *                     *
; * COPYRIGHT 1977 BY   *
; * APPLE COMPUTER INC. *
; *                     *
; * ALL RIGHTS RESERVED *
; *                     *
; * S. WOZNIAK          *
; * A. BAUM             *
; ***********************
; TITLE "APPLE-II MINI-ASSEMBLER"
FORMAT = $2E
LENGTH = $2F
MODE =   $31
PROMPT = $33
YSAV =   $34
L =      $35
PCL =    $3A
PCH =    $3B
A1H =    $3D
A2L =    $3E
A2H =    $3F
A4L =    $42
A4H =    $43
FMT =    $44
IN =     $200
; INSDS2 = $F88E
; INSTDSP = $F8D0
; PRBL2 =  $F94A
; PCADJ =  $F953
; CHAR1 =  $F9B4
; CHAR2 =  $F9BA
; MNEML =  $F9C0
; MNEMR =  $FA00
CURSUP = $FC1A
; GETLNZ = $FD67
; COUT =   $FDED
; BL1 =    $FE00
; A1PCLP = $FE78
; BELL =   $FF3A
; GETNUM = $FFA7
; TOSUB =  $FFBE
; ZMODE =  $FFC7
; CHRTBL = $FFCC

.ifdef APPLE1
;  .org $3500
;  .org $6500
  .org $7500
;  .org $B500
;  .org $F400
.else
  .org $F500
.endif

  .export MON
  .export REL

REL: SBC #$81 ; IS FMT COMPATIBLE
  LSR ; WITH RELATIVE MODE?
  BNE ERR3 ; NO.
  LDY A2H
  LDX A2L ; DOUBLE DECREMENT
  BNE REL2
  DEY
REL2: DEX
  TXA
  CLC
  SBC PCL ; FORM ADDR-PC-2
  STA A2L
  BPL REL3
  INY
REL3: TYA
  SBC PCH
ERR3: BNE ERR ; ERROR IF >1-BYTE BRANCH
FINDOP: LDY LENGTH
FNDOP2: LDA A1H,Y ; MOVE INST TO (PC)
  STA (PCL),Y
  DEY
  BPL FNDOP2
  NOP
  NOP
  NOP
  NOP
  NOP
  NOP
; JSR CURSUP
; JSR CURSUP ; RESTORE CURSOR
  JSR INSTDSP ; TYPE FORMATTED LINE
  JSR PCADJ ; UPDATE PC
  STY PCH
  STA PCL
  JMP NXTLINE ; GET NEXT LINE
FAKEMON3: JSR TOSUB ; GO TO DELIM HANDLER
  LDY YSAV ; RESTORE Y-INDEX
FAKEMON: JSR GETNUM ; READ PARAM
  STY YSAV ; SAVE Y-INDEX
  LDY #$17 ; INIT DELIMITER INDEX
FAKEMON2: DEY ; CHECK NEXT DELIM
  BMI RESETZ ; ERR IF UNRECOGNIZED DELIM
  CMP CHRTBL,Y ; COMPARE WITH DELIM TABLE
  BNE FAKEMON2 ; NO MATCH
  CPY #$15 ; MATCH, IS IT CR?
  BNE FAKEMON3 ; NO, HANDLE IT IN MONITOR
  LDA MODE
  LDY #$0
  DEC YSAV
  JSR BL1 ; HANDLE CR OUTSIDE MONITOR
  JMP NXTLINE
TRYNEXT: LDA A1H ; GET TRIAL OPCODE
.ifdef APPLE1
  JSR L6 ; GET FMT+LENGTH FOR OPCODE
.else
  JSR INSDS2 ; GET FMT+LENGTH FOR OPCODE
.endif
  TAX
  LDA MNEMR,X ; GET LOWER MNEMONIC BYTE
  CMP A4L ; MATCH?
  BNE NEXTOP ; NO, TRY NEXT OPCODE.
  LDA MNEML,X ; GET UPPER MNEMONIC BYTE
  CMP A4H ; MATCH?
  BNE NEXTOP ; NO, TRY NEXT OPCODE
  LDA FMT
  LDY FORMAT ; GET TRIAL FORMAT
  CPY #$9D ; TRIAL FORMAT RELATIVE?
  BEQ REL ; YES.
NREL: CMP FORMAT ; SAME FORMAT?
  BEQ FINDOP ; YES.
NEXTOP: DEC A1H ; NO, TRY NEXT OPCODE
  BNE TRYNEXT
  INC FMT ; NO MORE, TRY WITH LEN=2
  DEC L ; WAS L=2 ALREADY?
  BEQ TRYNEXT ; NO.
ERR: LDY YSAV ; YES, UNRECOGNIZED INST.
ERR2: TYA
  TAX
  JSR PRBL2 ; PRINT ^ UNDER LAST READ
  LDA #$DE ; CHAR TO INDICATE ERROR
  JSR COUT ; POSITION.
RESETZ: JSR BELL
NXTLINE: LDA #$A1 ; '!'
  STA PROMPT ; INITIALIZE PROMPT
  JSR GETLNZ ; GET LINE.
  JSR ZMODE ; INIT SCREEN STUFF
  LDA IN ; GET CHAR
  CMP #$A0 ; ASCII BLANK?
  BEQ SPACE ; YES
  INY
  CMP #$A4 ; ASCII '$' IN COL 1?
  BEQ FAKEMON ; YES, SIMULATE MONITOR
  DEY ; NO, BACKUP A CHAR
  JSR GETNUM ; GET A NUMBER
  CMP #$93 ; ':' TERMINATOR?
ERR4: BNE ERR2 ; NO, ERR.
  TXA
  BEQ ERR2 ; NO ADR PRECEDING COLON.
  JSR A1PCLP ; MOVE ADR TO PCL, PCH.
SPACE: LDA #$3 ; COUNT OF CHARS IN MNEMONIC
  STA A1H
NXTMN: JSR GETNSP ; GET FIRST MNEM CHAR.
NXTM: ASL A
  SBC #$BE ; SUBTRACT OFFSET
  CMP #$C2 ; LEGAL CHAR?
  BCC ERR2 ; NO.
  ASL A ; COMPRESS-LEFT JUSTIFY
  ASL A
  LDX #$4
NXTM2: ASL A ; DO 5 TRIPLE WORD SHIFTS
  ROL A4L
  ROL A4H
  DEX
  BPL NXTM2
  DEC A1H ; DONE WITH 3 CHARS?
  BEQ NXTM2 ; YES, BUT DO 1 MORE SHIFT
  BPL NXTMN ; NO
FORM1: LDX #$5 ; 5 CHARS IN ADDR MODE
FORM2: JSR GETNSP ; GET FIRST CHAR OF ADDR
  STY YSAV
  CMP CHAR1,X ; FIRST CHAR MATCH PATTERN?
  BNE FORM3 ; NO
  JSR GETNSP ; YES, GET SECOND CHAR
  CMP CHAR2,X ; MATCHES SECOND HALF?
  BEQ FORM5 ; YES.
  LDA CHAR2,X ; NO, IS SECOND HALF ZERO?
  BEQ FORM4 ; YES.
  CMP #$A4 ; NO,SECOND HALF OPTIONAL?
  BEQ FORM4 ; YES.
  LDY YSAV
FORM3: CLC ; CLEAR BIT-NO MATCH
FORM4: DEY ; BACK UP 1 CHAR
FORM5: ROL FMT ; FORM FORMAT BYTE
  CPX #$3 ; TIME TO CHECK FOR ADDR.
  BNE FORM7 ; NO
  JSR GETNUM ; YES
  LDA A2H
  BEQ FORM6 ; HIGH-ORDER BYTE ZERO
  INX ; NO, INCR FOR 2-BYTE
FORM6: STX L ; STORE LENGTH
  LDX #$3 ; RELOAD FORMAT INDEX
  DEY ; BACKUP A CHAR
FORM7: STX A1H ; SAVE INDEX
  DEX ; DONE WITH FORMAT CHECK?
  BPL FORM2 ; NO.
  LDA FMT ; YES, PUT LENGTH
  ASL A ; IN LOW BITS
  ASL A
  ORA L
  CMP #$20
  BCS FORM8 ; ADD "$" IF NONZERO LENGTH
  LDX L ; AND DON'T ALREADY HAVE IT
  BEQ FORM8
  ORA #$80
FORM8: STA FMT
  STY YSAV
  LDA IN,Y ; GET NEXT NONBLANK
  CMP #$BB ; '' START OF COMMENT?
  BEQ FORM9 ; YES
  CMP #$8D ; CARRIAGE RETURN?
  BNE ERR4 ; NO, ERR.
FORM9: JMP TRYNEXT
GETNSP: LDA IN,Y
  INY
  CMP #$A0 ; GET NEXT NON BLANK CHAR
  BEQ GETNSP
  RTS

; Add filler bytes so that the Mini-Assembler starts at the documented
; entry point at address $F666
.byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
.byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
.byte $FF

.ifndef APPLE1

.byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF

MINIASM:  JMP   RESETZ
.endif

; Apple 1 specific code
.ifdef APPLE1
  LDA   ($3A,X)
  TAY
  LSR
  BCC   L0+1
  LSR
  .BYTE $09 ; ORA #
MINIASM:  JMP   RESETZ
L0: LDA ($3A,X)
L6: TAY
  LSR A
  BCC L1
  LSR A
  ORA #$80
  JMP   INSDS2
L1: JMP   IEVEN
L8: LDA   #$7F ; Initialize 6820
  STA   $D012
  LDX   #$A7
  STX   $D011
  STX   $D013
  LDX   #$8B ; Initialize Serial Card 300 Baud
  STX   $D004
  LDX   #$96
  STX   $D005
  RTS
L3: BIT   $D012 ; Character Out
L2: BMI   L3
  STA   $D012
  RTS
L7: CMP   #$9B ; Use Esc for line kill
  BNE   L4
  LDA   #$98
L4: CMP   #$88 ; Use Control h for Backspace
  BNE   L5
  LDA   #$DF ; Underscore out
.ifdef WOZMON
  CMP #$91   ; Control-Q typed?
  BNE L5     ; If so, jump to WozMon
  JMP RESET
.endif
L5:  RTS
.ifdef WOZMON
  NOP
  NOP
  NOP
.endif

; 346 filler bytes in place of SWEET16 code

.ifndef WOZMON
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0

.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0

.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0

.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0

.else

; 336 filler bytes in place of SWEET16 code

.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0

.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0

.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0

.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0

.endif

.else

; Add filler bytes up to documented SWEET16 entry point at
; address $X689
.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

; ***********************
; *                     *
; * APPLE-II PSEUDO     *
; * MACHINE INTERPRETER *
; *                     *
; * COPYRIGHT 1977      *
; * APPLE COMPUTER INC  *
; *                     *
; * ALL RIGHTS RESERVED *
; * S. WOZNIAK          *
; *                     *
; ***********************
; TITLE "SWEET16 INTERPRETER"
R0L = $0
R0H = $1
R14H = $1D
R15L = $1E
R15H = $1F
SW16PAG = $F7
; SAVE = $FF4A
; RESTORE = $FF3F
;  .ORG $F689
SW16: JSR SAVE ; PRESERVE 6502 REG CONTENTS
  PLA
  STA R15L ; INIT SWEET16 PC
  PLA ; FROM RETURN
  STA R15H ; ADDRESS
SW16B: JSR SW16C ; INTERPRET AND EXECUTE
  JMP SW16B ; ONE SWEET16 INSTR.
SW16C: INC R15L
  BNE SW16D ; INCR SWEET16 PC FOR FETCH
  INC R15H
SW16D: LDA #SW16PAG
  PHA ; PUSH ON STACK FOR RTS
  LDY #$0
  LDA (R15L),Y ; FETCH INSTR
  AND #$F ; MASK REG SPECIFICATION
  ASL A ; DOUBLE FOR TWO BYTE REGISTERS
  TAX ; TO X REG FOR INDEXING
  LSR A
  EOR (R15L),Y ; NOW HAVE OPCODE
  BEQ TOBR ; IF ZERO THEN NON-REG OP
  STX R14H ; INDICATE'PRIOR RESULT REG'
  LSR A
  LSR A ; OPCODE*2 TO LSB'S
  LSR A
  TAY ; TO Y REG FOR INDEXING
  LDA OPTBL-2,Y ; LOW ORDER ADR BYTE
  PHA ; ONTO STACK
  RTS ; GOTO REG-OP ROUTINE
TOBR: INC R15L
  BNE TOBR2 ; INCR PC
  INC R15H
TOBR2: LDA BRTBL,X ; LOW ORDER ADR BYTE
  PHA ; ONTO STACK FOR NON-REG OP
  LDA R14H ; 'PRIOR RESULT REG' INDEX
  LSR A ; PREPARE CARRY FOR BC, BNC.
  RTS ; GOTO NON-REG OP ROUTINE
RTNZ: PLA ; POP RETURN ADDRESS
  PLA
  JSR RESTORE ; RESTORE 6502 REG CONTENTS
  JMP (R15L) ; RETURN TO 6502 CODE VIA PC
SETZ: LDA (R15L),Y ; HIGH-ORDER BYTE OF CONSTANT
  STA R0H,X
  DEY
  LDA (R15L),Y ; LOW-ORDER BYTE OF CONSTANT
  STA R0L,X
  TYA ; Y-REG CONTAINS 1
  SEC
  ADC R15L ; ADD 2 TO PC
  STA R15L
  BCC SET2
  INC R15H
SET2: RTS
OPTBL: .BYTE <SET-1 ; 1X
BRTBL: .BYTE <RTN-1 ; 0
  .BYTE <LD-1 ; 2X
  .BYTE <BR-1 ; 1
  .BYTE <ST-1 ; 3X
  .BYTE <BNC-1 ; 2
  .BYTE <LDAT-1 ; 4X
  .BYTE <BC-1 ; 3
  .BYTE <STAT-1 ; 5X
  .BYTE <BP-1 ; 4
  .BYTE <LDDAT-1 ; 6X
  .BYTE <BM-1 ; 5
  .BYTE <STDAT-1 ; 7X
  .BYTE <BZ-1 ; 6
  .BYTE <POP-1 ; 8X
  .BYTE <BNZ-1 ; 7
  .BYTE <STPAT-1 ; 9X
  .BYTE <BM1-1 ; 8
  .BYTE <ADD-1 ; AX
  .BYTE <BNM1-1 ; 9
  .BYTE <SUB-1 ; BX
  .BYTE <BK-1 ; A
  .BYTE <POPD-1 ; CX
  .BYTE <RS-1 ; B
  .BYTE <CPR-1 ; DX
  .BYTE <BS-1 ; C
  .BYTE <INR-1 ; EX
  .BYTE <NUL-1 ; D
  .BYTE <DCR-1 ; FX
  .BYTE <NUL-1 ; E
  .BYTE <NUL-1 ; UNUSED
  .BYTE <NUL-1 ; F
SET: BPL SETZ ; ALWAYS TAKEN
LD: LDA R0L,X
BK = LD+1
  STA R0L
  LDA R0H,X ; MOVE RX TO R0
  STA R0H
  RTS
ST: LDA R0L
  STA R0L,X ; MOVE R0 TO RX
  LDA R0H
  STA R0H,X
  RTS
STAT: LDA R0L
STAT2: STA (R0L,X) ; STORE BYTE INDIRECT
  LDY #$0
STAT3: STY R14H ; INDICATE R0 IS RESULT NEG
INR: INC R0L,X
  BNE INR2 ; INCR RX
  INC R0H,X
INR2: RTS
LDAT: LDA (R0L,X) ; LOAD INDIRECT (RX)
  STA R0L ; TO R0
  LDY #$0
  STY R0H ; ZERO HIGH-ORDER R0 BYTE
  BEQ STAT3 ; ALWAYS TAKEN
POP: LDY #$0 ; HIGH ORDER BYTE = 0
  BEQ POP2 ; ALWAYS TAKEN
POPD: JSR DCR ; DECR RX
  LDA (R0L,X) ; POP HIGH ORDER BYTE @RX
  TAY ; SAVE IN Y-REG
POP2: JSR DCR ; DECR RX
  LDA (R0L,X) ; LOW-ORDER BYTE
  STA R0L ; TO R0
  STY R0H
POP3: LDY #$0 ; INDICATE R0 AS LAST RESULT REG
  STY R14H
  RTS
LDDAT: JSR LDAT ; LOW-ORDER BYTE TO R0, INCR RX
  LDA (R0L,X) ; HIGH-ORDER BYTE TO R0
  STA R0H
  JMP INR ; INCR RX
STDAT: JSR STAT ; STORE INDIRECT LOW-ORDER
  LDA R0H ; BYTE AND INCR RX. THEN
  STA (R0L,X) ; STORE HIGH-ORDER BYTE.
  JMP INR ; INCR RX AND RETURN
STPAT: JSR DCR ; DECR RX
  LDA R0L
  STA (R0L,X) ; STORE R0 LOW BYTE @RX
  JMP POP3 ; INDICATE R0 AS LAST RSLT REG
DCR: LDA R0L,X
  BNE DCR2 ; DECR RX
  DEC R0H,X
DCR2: DEC R0L,X
  RTS
SUB: LDY #$0 ; RESULT TO R0
CPR: SEC ; NOTE Y-REG = 13*2 FOR CPR
  LDA R0L
  SBC R0L,X
  STA R0L,Y ; R0-RX TO RY
  LDA R0H
  SBC R0H,X
SUB2: STA R0H,Y
  TYA ; LAST RESULT REG*2
  ADC #$0 ; CARRY TO LSB
  STA R14H
  RTS
ADD: LDA R0L
  ADC R0L,X
  STA R0L ; R0+RX TO R0
  LDA R0H
  ADC R0H,X
  LDY #$0 ; R0 FOR RESULT
  BEQ SUB2 ; FINISH ADD
BS: LDA R15L ; NOTE X-REG IS 12*2!
  JSR STAT2 ; PUSH LOW PC BYTE VIA R12
  LDA R15H
  JSR STAT2 ; PUSH HIGH-ORDER PC BYTE
BR: CLC
BNC: BCS BNC2 ; NO CARRY TEST
BR1: LDA (R15L),Y ; DISPLACEMENT BYTE
  BPL BR2
  DEY
BR2: ADC R15L ; ADD TO PC
  STA R15L
  TYA
  ADC R15H
  STA R15H
BNC2: RTS
BC: BCS BR
  RTS
BP: ASL A ; DOUBLE RESULT-REG INDEX
  TAX ; TO X REG FOR INDEXING
  LDA R0H,X ; TEST FOR PLUS
  BPL BR1 ; BRANCH IF SO
  RTS
BM: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0H,X ; TEST FOR MINUS
  BMI BR1
  RTS
BZ: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X ; TEST FOR ZERO
  ORA R0H,X ; (BOTH BYTES)
  BEQ BR1 ; BRANCH IF SO
  RTS
BNZ: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X ; TEST FOR NON-ZERO
  ORA R0H,X ; (BOTH BYTES)
  BNE BR1 ; BRANCH IF SO
  RTS
BM1: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X ; CHECK BOTH BYTES
  AND R0H,X ; FOR $FF (MINUS 1)
  EOR #$FF
  BEQ BR1 ; BRANCH IF SO
  RTS
BNM1: ASL A ; DOUBLE RESULT-REG INDEX
  TAX
  LDA R0L,X
  AND R0H,X ; CHECK BOTH BYTES FOR NO $FF
  EOR #$FF
  BNE BR1 ; BRANCH IF NOT MINUS 1
NUL: RTS
RS: LDX #$18 ; 12*2 FOR R12 AS STACK POINTER
  JSR DCR ; DECR STACK POINTER
  LDA (R0L,X) ; POP HIGH RETURN ADDRESS TO PC
  STA R15H
  JSR DCR ; SAME FOR LOW-ORDER BYTE
  LDA (R0L,X)
  STA R15L
 RTS
RTN: JMP RTNZ

; Padding bytes to make System Monitor start at $F800
  .byte 0,0,0

.endif

; ***************************
; *                         *
; * APPLE II                *
; * SYSTEM MONITOR          *
; *                         *
; * COPYRIGHT 1977 BY       *
; * APPLE COMPUTER, INC.    *
; *                         *
; * ALL RIGHTS RESERVED     *
; *                         *
; * S. WOZNIAK              *
; * A. BAUM                 *
; *                         *
; ***************************
; TITLE "APPLE II SYSTEM MONITOR"
LOC0 = $00
LOC1 = $01
WNDLFT = $20
WNDWDTH = $21
WNDTOP = $22
WNDBTM = $23
CH = $24
CV = $25
GBASL = $26
GBASH = $27
BASL = $28
BASH = $29
BAS2L = $2A
BAS2H = $2B
H2 = $2C
LMNEM = $2C
RTNL = $2C
V2 = $2D
RMNEM = $2D
RTNH = $2D
MASK = $2E
CHKSUM = $2E
; FORMAT = $2E
LASTIN = $2F
; LENGTH = $2F
SIGN = $2F
COLOR = $30
; MODE = $31
INVFLG = $32
; PROMPT = $33
; YSAV = $34
YSAV1 = $35
CSWL = $36
CSWH = $37
KSWL = $38
KSWH = $39
; PCL = $3A
; PCH = $3B
XQT = $3C
A1L = $3C
; A1H = $3D
;A2L = $3E
;A2H = $3F
A3L = $40
A3H = $41
;A4L = $42
;A4H = $43
A5L = $44
A5H = $45
ACC = $45
XREG = $46
YREG = $47
STATUS = $48
SPNT = $49
RNDL = $4E
RNDH = $4F
ACL = $50
ACH = $51
XTNDL = $52
XTNDH = $53
AUXL = $54
AUXH = $55
PICK = $95
; IN = $0200
USRADR = $03F8
NMI = $03FB
IRQLOC = $03FE
IOADR = $C000
KBD = $C000
KBDSTRB = $C010
TAPEOUT = $C020
SPKR = $C030
TXTCLR = $C050
TXTSET = $C051
MIXCLR = $C052
MIXSET = $C053
LOWSCR = $C054
HISCR = $C055
LORES = $C056
HIRES = $C057
TAPEIN = $C060
PADDL0 = $C064
PTRIG = $C070
BASIC = $E000
.ifdef APPLE1
BASIC2 = $E2B3
.else
BASIC2 = $E003
.endif
; ORG $F800 ROM START ADDRESS
PLOT: LSR ; Y-COORD/2
  PHP ; SAVE LSB IN CARRY
  JSR GBASCALC ; CALC BASE ADR IN GBASL,H
  PLP ; RESTORE LSB FROM CARRY
  LDA #$0F ; MASK $0F IF EVEN
  BCC RTMASK
  ADC #$E0 ; MASK $F0 IF ODD
RTMASK: STA MASK
PLOT1: LDA (GBASL),Y ; DATA
  EOR COLOR ; EOR COLOR
  AND MASK ; AND MASK
  EOR (GBASL),Y ; XOR DATA
  STA (GBASL),Y ; TO DATA
  RTS
HLINE: JSR PLOT ; PLOT SQUARE
HLINE1: CPY H2 ; DONE?
  BCS RTS1 ; YES, RETURN
  INY ; NO, INCR INDEX (X-COORD)
  JSR PLOT1 ; PLOT NEXT SQUARE
  BCC HLINE1 ; ALWAYS TAKEN
VLINEZ: ADC #$01 ; NEXT Y-COORD
VLINE: PHA ; SAVE ON STACK
  JSR PLOT ; PLOT SQUARE
  PLA
  CMP V2 ; DONE?
  BCC VLINEZ ; NO, LOOP
RTS1: RTS
CLRSCR: LDY #$2F ; MAX Y, FULL SCRN CLR
  BNE CLRSC2 ; ALWAYS TAKEN
CLRTOP: LDY #$27 ; MAX Y, TOP SCREEN CLR
CLRSC2: STY V2 ; STORE AS BOTTOM COORD
; FOR VLINE CALLS
  LDY #$27 ; RIGHTMOST X-COORD (COLUMN)
CLRSC3: LDA #$00 ; TOP COORD FOR VLINE CALLS
  STA COLOR ; CLEAR COLOR (BLACK)
  JSR VLINE ; DRAW VLINE
  DEY ; NEXT LEFTMOST X-COORD
  BPL CLRSC3 ; LOOP UNTIL DONE
  RTS
GBASCALC: PHA ; FOR INPUT 000DEFGH
  LSR
  AND #$03
  ORA #$04 ; GENERATE GBASH=000001FG
  STA GBASH
  PLA ; AND GBASL=HDEDE000
  AND #$18
  BCC GBCALC
  ADC #$7F
GBCALC: STA GBASL
  ASL A
  ASL A
  ORA GBASL
  STA GBASL
  RTS
NXTCOL: LDA COLOR ; INCREMENT COLOR BY 3
  CLC
  ADC #$03
SETCOL: AND #$0F ; SETS COLOR=17*A MOD 16
  STA COLOR
  ASL A ; BOTH HALF BYTES OF COLOR EQUAL
  ASL A
  ASL A
  ASL A
  ORA COLOR
  STA COLOR
  RTS
SCRN: LSR A ; READ SCREEN Y-COORD/2
  PHP ; SAVE LSB (CARRY)
  JSR GBASCALC ; CALC BASE ADDRESS
  LDA (GBASL),Y ; GET BYTE
  PLP ; RESTORE LSB FROM CARRY
SCRN2: BCC RTMSKZ ; IF EVEN, USE LO H
  LSR A
  LSR A
  LSR A ; SHIFT HIGH HALF BYTE DOWN
  LSR A
RTMSKZ: AND #$0F ; MASK 4-BITS
  RTS
INSDS1: LDX PCL ; PRINT PCL,H
  LDY PCH
  JSR PRYX2
  JSR PRBLNK ; FOLLOWED BY A BLANK
.ifdef APPLE1
  JMP L0
  NOP
  NOP
  NOP
  NOP
INSDS2:
.else
  LDA (PCL,X) ; GET OP CODE
INSDS2: TAY
  LSR A ; EVEN/ODD TEST
  BCC IEVEN
  ROR ; BIT 1 TEST
.endif
  BCS ERR1 ; XXXXXX11 INVALID OP
  CMP #$A2
  BEQ ERR1 ; OPCODE $89 INVALID
  AND #$87 ; MASK BITS
IEVEN: LSR A ; LSB INTO CARRY FOR L/R TEST
  TAX
  LDA FMT1,X ; GET FORMAT INDEX BYTE
  JSR SCRN2 ; R/L H-BYTE ON CARRY
  BNE GETFMT
ERR1: LDY #$80 ; SUBSTITUTE $80 FOR INVALID OPS
  LDA #$00 ; SET PRINT FORMAT INDEX TO 0
GETFMT: TAX
  LDA FMT2,X ; INDEX INTO PRINT FORMAT TABLE
  STA FORMAT ; SAVE FOR ADR FIELD FORMATTING
  AND #$03 ; MASK FOR 2-BIT LENGTH (P=1 BYTE, 1=2 BYTE, 2=3 BYTE)
  STA LENGTH
  TYA ; OPCODE
  AND #$8F ; MASK FOR 1XXX1010 TEST
  TAX ; SAVE IT
  TYA ; OPCODE TO A AGAIN
  LDY #$03
  CPX #$8A
  BEQ MNNDX3
MNNDX1: LSR A
  BCC MNNDX3 ; FORM INDEX INTO MNEMONIC TABLE
  LSR A
MNNDX2: LSR A ; 1) 1XXX1010->00101XXX
  ORA #$20 ; 2) XXXYYY01->00111XXX
  DEY ; 3) XXXYYY10->00110XXX
  BNE MNNDX2 ; 4) XXXYY100->00100XXX
  INY ; 5) XXXXX000->000XXXXX
MNNDX3: DEY
  BNE MNNDX1
  RTS
  .BYTE $FF,$FF,$FF
INSTDSP: JSR INSDS1 ; GEN FMT, LEN BYTES
  PHA ; SAVE MNEMONIC TABLE INDEX
PRNTOP: LDA (PCL),Y
  JSR PRBYTE
  LDX #$01 ; PRINT 2 BLANKS
PRNTBL: JSR PRBL2
  CPY LENGTH ; PRINT INST (1-3 BYTES)
  INY ; IN A 12 CHR FIELD
  BCC PRNTOP
  LDX #$03 ; CHAR COUNT FOR MNEMONIC PRINT
  CPY #$04
  BCC PRNTBL
  PLA ; RECOVER MNEMONIC INDEX
  TAY
  LDA MNEML,Y
  STA LMNEM ; FETCH 3-CHAR MNEMONIC
  LDA MNEMR,Y ; (PACKED IN 2-BYTES)
  STA RMNEM
PRMN1: LDA #$00
  LDY #$05
PRMN2: ASL RMNEM ; SHIFT 5 BITS OF
  ROL LMNEM ; CHARACTER INTO A
  ROL ; (CLEARS CARRY)
  DEY
  BNE PRMN2
  ADC #$BF ; ADD "?" OFFSET
  JSR COUT ; OUTPUT A CHAR OF MNEM
  DEX
  BNE PRMN1
  JSR PRBLNK ; OUTPUT 3 BLANKS
  LDY LENGTH
  LDX #$06 ; CNT FOR 6 FORMAT BITS
PRADR1: CPX #$03
  BEQ PRADR5 ; IF X=3 THEN ADDR.
PRADR2: ASL FORMAT
  BCC PRADR3
  LDA CHAR1-1,X
  JSR COUT
  LDA CHAR2-1,X
  BEQ PRADR3
  JSR COUT
PRADR3: DEX
  BNE PRADR1
  RTS
PRADR4: DEY
  BMI PRADR2
  JSR PRBYTE
PRADR5: LDA FORMAT
  CMP #$E8 ; HANDLE REL ADR MODE
  LDA (PCL),Y ; SPECIAL (PRINT TARGET,
  BCC PRADR4 ; NOT OFFSET)
RELADR: JSR PCADJ3
  TAX ; PCL,PCH+OFFSET+1 TO A,Y
  INX
  BNE PRNTYX ; +1 TO Y,X
  INY
PRNTYX: TYA
PRNTAX: JSR PRBYTE ; OUTPUT TARGET ADR
PRNTX: TXA ; OF BRANCH AND RETURN
  JMP PRBYTE
PRBLNK: LDX #$03 ; BLANK COUNT
PRBL2: LDA #$A0 ; LOAD A SPACE
PRBL3: JSR COUT ; OUTPUT A BLANK
  DEX
  BNE PRBL2 ; LOOP UNTIL COUNT=0
  RTS
PCADJ: SEC ; 0=1-BYTE, 1=2-BYTE
PCADJ2: LDA LENGTH ; 2=3-BYTE
PCADJ3: LDY PCH
  TAX ; TEST DISPLACEMENT SIGN
  BPL PCADJ4 ; (FOR REL BRANCH)
  DEY ; EXTEND NEG BY DEC PCH
PCADJ4: ADC PCL
  BCC RTS2 ; PCL+LENGTH(OR DISPL)+1 TO A
  INY ; CARRY INTO Y (PCH)
RTS2: RTS
; FMT1 BYTES: XXXXXXY0 INSTRS
; IF Y=0 THEN LEFT HALF BYTE
; IF Y=1 THEN RIGHT HALF BYTE
; (X=INDEX)
FMT1: .BYTE $04,$20,$54,$30,$0D
  .BYTE $80,$04,$90,$03,$22
  .BYTE $54,$33,$0D,$80,$04
  .BYTE $90,$04,$20,$54,$33
  .BYTE $0D,$80,$04,$90,$04
  .BYTE $20,$54,$3B,$0D,$80
  .BYTE $04,$90,$00,$22,$44
  .BYTE $33,$0D,$C8,$44,$00
  .BYTE $11,$22,$44,$33,$0D
  .BYTE $C8,$44,$A9,$01,$22
  .BYTE $44,$33,$0D,$80,$04
  .BYTE $90,$01,$22,$44,$33
  .BYTE $0D,$80,$04,$90
  .BYTE $26,$31,$87,$9A ; $ZZXXXY01 INSTR'S
FMT2: .BYTE $00 ; ERR
  .BYTE $21 ; IMM
  .BYTE $81 ; Z-PAGE
  .BYTE $82 ; ABS
  .BYTE $00 ; IMPLIED
  .BYTE $00 ; ACCUMULATOR
  .BYTE $59 ; (ZPAG,X)
  .BYTE $4D ; (ZPAG),Y
  .BYTE $91 ; ZPAG,X
  .BYTE $92 ; ABS,X
  .BYTE $86 ; ABS,Y
  .BYTE $4A ; (ABS)
  .BYTE $85 ; ZPAG,Y
  .BYTE $9D ; RELATIVE
CHAR1: Str ",),#($"
CHAR2: .BYTE $D9,$00,$D8,$A4,$A4,$00
; CHAR2: "Y",0,"X$$",0
; MNEML IS OF FORM:
; (A) XXXXX000
; (B) XXXYY100
; (C) 1XXX1010
; (D) XXXYYY10
; (E) XXXYYY01
; (X=INDEX)
MNEML: .BYTE $1C,$8A,$1C,$23,$5D,$8B
  .BYTE $1B,$A1,$9D,$8A,$1D,$23
  .BYTE $9D,$8B,$1D,$A1,$00,$29
  .BYTE $19,$AE,$69,$A8,$19,$23
  .BYTE $24,$53,$1B,$23,$24,$53
  .BYTE $19,$A1 ; (A) FORMAT ABOVE
  .BYTE $00,$1A,$5B,$5B,$A5,$69
  .BYTE $24,$24 ; (B) FORMAT
  .BYTE $AE,$AE,$A8,$AD,$29,$00
  .BYTE $7C,$00 ; (C) FORMAT
  .BYTE $15,$9C,$6D,$9C,$A5,$69
  .BYTE $29,$53 ; (D) FORMAT
  .BYTE $84,$13,$34,$11,$A5,$69
  .BYTE $23,$A0 ; (E) FORMAT
MNEMR: .BYTE $D8,$62,$5A,$48,$26,$62
  .BYTE $94,$88,$54,$44,$C8,$54
  .BYTE $68,$44,$E8,$94,$00,$B4
  .BYTE $08,$84,$74,$B4,$28,$6E
  .BYTE $74,$F4,$CC,$4A,$72,$F2
  .BYTE $A4,$8A ; (A) FORMAT
  .BYTE $00,$AA,$A2,$A2,$74,$74
  .BYTE $74,$72 ; (B) FORMAT
  .BYTE $44,$68,$B2,$32,$B2,$00
  .BYTE $22,$00 ; (C) FORMAT
  .BYTE $1A,$1A,$26,$26,$72,$72
  .BYTE $88,$C8 ; (D) FORMAT
  .BYTE $C4,$CA,$26,$48,$44,$44
  .BYTE $A2,$C8 ; (E) FORMAT
  .BYTE $FF,$FF,$FF
STEP: JSR INSTDSP ; DISASSEMBLE ONE INST
  PLA ; AT (PCL,H)
  STA RTNL ; ADJUST TO USER
  PLA ; STACK. SAVE
  STA RTNH ; RTN ADR.
  LDX #$08
XQINIT: LDA INITBL-1,X ; INIT XEQ AREA
  STA XQT,X
  DEX
  BNE XQINIT
  LDA (PCL,X) ; USER OPCODE BYTE
  BEQ XBRK ; SPECIAL IF BREAK
  LDY LENGTH ; LEN FROM DISASSEMBLY
  CMP #$20
  BEQ XJSR ; HANDLE JSR, RTS, JMP,
  CMP #$60 ; JMP (), RTI SPECIAL
  BEQ XRTS
  CMP #$4C
  BEQ XJMP
  CMP #$6C
  BEQ XJMPAT
  CMP #$40
  BEQ XRTI
  AND #$1F
  EOR #$14
  CMP #$04 ; COPY USER INST TO XEQ AREA
  BEQ XQ2 ; WITH TRAILING NOPS
XQ1: LDA (PCL),Y ; CHANGE REL BRANCH
XQ2: STA XQT,Y ; DISP TO 4 FOR
  DEY ; JMP TO BRANCH OR
  BPL XQ1 ; NBRANCH FROM XEQ.
  JSR RESTORE ; RESTORE USER REG CONTENTS.
  JMP XQT ; XEQ USER OP FROM RAM
IRQ: STA ACC ; (RETURN TO NBRANCH)
  PLA
  PHA ; **IRQ HANDLER
  ASL A
  ASL A
  ASL A
  BMI BREAK ; TEST FOR BREAK
  JMP (IRQLOC) ; USER ROUTINE VECTOR IN RAM
BREAK: PLP
  JSR SAV1 ; SAVE REG'S ON BREAK
  PLA ; INCLUDING PC
  STA PCL
  PLA
  STA PCH
XBRK: JSR INSDS1 ; PRINT USER PC.
  JSR RGDSP1 ; AND REG'S
  JMP MON ; GO TO MONITOR
XRTI: CLC
  PLA ; SIMULATE RTI BY EXPECTING
  STA STATUS ; STATUS FROM STACK, THEN RTS
XRTS: PLA ; RTS SIMULATION
  STA PCL ; EXTRACT PC FROM STACK
  PLA ; AND UPDATE PC BY 1 (LEN=0)
PCINC2: STA PCH
PCINC3: LDA LENGTH ; UPDATE PC BY LEN
  JSR PCADJ3
  STY PCH
  CLC
  BCC NEWPCL
XJSR: CLC
  JSR PCADJ2 ; UPDATE PC AND PUSH
  TAX ; ONTO STACH FOR
  TYA ; JSR SIMULATE
  PHA
  TXA
  PHA
  LDY #$02
XJMP: CLC
XJMPAT: LDA (PCL),Y
  TAX ; LOAD PC FOR JMP,
  DEY ; (JMP) SIMULATE.
  LDA (PCL),Y
  STX PCH
NEWPCL: STA PCL
  BCS XJMP
RTNJMP: LDA RTNH
  PHA
  LDA RTNL
  PHA
REGDSP: JSR CROUT ; DISPLAY USER REG
RGDSP1: LDA #ACC ; CONTENTS WITH
  STA A3L ; LABELS
  LDA #ACC/256
  STA A3H
  LDX #$FB
RDSP1: LDA #$A0
  JSR COUT
  LDA RTBL-$FB,X
  JSR COUT
  LDA #$BD
  JSR COUT
  LDA ACC+5,X
  JSR PRBYTE
  INX
  BMI RDSP1
  RTS
BRANCH: CLC ; BRANCH TAKEN,
  LDY #$01 ; ADD LEN+2 TO PC
  LDA (PCL),Y
  JSR PCADJ3
  STA PCL
  TYA
  SEC
  BCS PCINC2
NBRNCH: JSR SAVE ; NORMAL RETURN AFTER
  SEC ; XEQ USER OF
  BCS PCINC3 ; GO UPDATE PC
INITBL: NOP
  NOP ; DUMMY FILL FOR
  JMP NBRNCH ; XEQ AREA
  JMP BRANCH
RTBL: .BYTE $C1
  .BYTE $D8
  .BYTE $D9
  .BYTE $D0
  .BYTE $D3
PREAD: LDA PTRIG ; TRIGGER PADDLES
  LDY #$00 ; INIT COUNT
  NOP ; COMPENSATE FOR 1ST COUNT
  NOP
PREAD2: LDA PADDL0,X ; COUNT Y-REG EVERY
  BPL RTS2D ; 12 USEC
  INY
  BNE PREAD2 ; EXIT AT 255 MAX
  DEY
RTS2D: RTS
INIT: LDA #$00 ; CLR STATUS FOR DEBUG
  STA STATUS ; SOFTWARE
  LDA LORES
  LDA LOWSCR ; INIT VIDEO MODE
SETTXT: LDA TXTSET ; SET FOR TEXT MODE
  LDA #$00 ; FULL SCREEN WINDOW
  BEQ SETWND
SETGR: LDA TXTCLR ; SET FOR GRAPHICS MODE
  LDA MIXSET ; LOWER 4 LINES AS
  JSR CLRTOP ; TEXT WINDOW
  LDA #$14
SETWND: STA WNDTOP ; SET FOR 40 COL WINDOW
  LDA #$00 ; TOP IN A-REG,
  STA WNDLFT ; BTTM AT LINE 24
  LDA #$28
  STA WNDWDTH
  LDA #$18
  STA WNDBTM ; VTAB TO ROW 23
  LDA #$17
TABV: STA CV ; VTABS TO ROW IN A-REG
  JMP VTAB
MULPM: JSR MD1 ; ABS VAL OF AC AUX
MUL: LDY #$10 ; INDEX FOR 16 BITS
MUL2: LDA ACL ; ACX * AUX + XTND
  LSR A ; TO AC, XTND
  BCC MUL4 ; IF NO CARRY,
  CLC ; NO PARTIAL PROD.
  LDX #$FE
MUL3: LDA XTNDL+2,X ; ADD MPLCND (AUX)
  ADC AUXL+2,X ; TO PARTIAL PROD
  STA XTNDL+2,X ; (XTND)
  INX
  BNE MUL3
MUL4: LDX #$03
MUL5: .BYTE $76
  .BYTE $50
  DEX
  BPL MUL5
  DEY
  BNE MUL2
  RTS
DIVPM: JSR MD1 ; ABS VAL OF AC, AUX.
DIV: LDY #$10 ; INDEX FOR 16 BITS
DIV2: ASL ACL
  ROL ACH
  ROL XTNDL ; XTND/AUX
  ROL XTNDH ; TO AC.
  SEC
  LDA XTNDL
  SBC AUXL ; MOD TO XTND.
  TAX
  LDA XTNDH
  SBC AUXH
  BCC DIV3
  STX XTNDL
  STA XTNDH
  INC ACL
DIV3: DEY
  BNE DIV2
  RTS
MD1: LDY #$00 ; ABS VAL OF AC, AUX
  STY SIGN ; WITH RESULT SIGN
  LDX #AUXL ; IN LSB OF SIGN.
  JSR MD3
  LDX #ACL
MD3: LDA LOC1,X ; X SPECIFIES AC OR AUX
  BPL MDRTS
  SEC
  TYA
  SBC LOC0,X ; COMPL SPECIFIED REG
  STA LOC0,X ; IF NEG.
  TYA
  SBC LOC1,X
  STA LOC1,X
  INC SIGN
MDRTS: RTS
BASCALC: PHA ; CALC BASE ADR IN BASL,H
  LSR A ; FOR GIVEN LINE NO
  AND #$03 ; 0<=LINE NO.<=$17
  ORA #$04 ; ARG=000ABCDE, GENERATE
  STA BASH ; BASH=000001CD
  PLA ; AND
  AND #$18 ; BASL=EABAB000
  BCC BSCLC2
  ADC #$7F
BSCLC2: STA BASL
  ASL
  ASL
  ORA BASL
  STA BASL
  RTS
BELL1: CMP #$87 ; BELL CHAR? (CNTRL-G)
  BNE RTS2B ; NO, RETURN
  LDA #$40 ; DELAY .01 SECONDS
  JSR WAIT
  LDY #$C0
BELL2: LDA #$0C ; TOGGLE SPEAKER AT
  JSR WAIT ; 1 KHZ FOR .1 SEC.
  LDA SPKR
  DEY
  BNE BELL2
RTS2B: RTS
STOADV: LDY CH ; CURSOR H INDEX TO Y-REG
.ifdef APPLE1
  NOP
  NOP
.else
  STA (BASL),Y ; STORE CHAR IN LINE
.endif
ADVANCE: INC CH ; INCREMENT CURSOR H INDEX
  LDA CH ; (MOVE RIGHT)
  CMP WNDWDTH ; BEYOND WINDOW WIDTH?
  BCS CR ; YES CR TO NEXT LINE
RTS3: RTS ; NO,RETURN
VIDOUT: CMP #$A0 ; CONTROL CHAR?
  BCS STOADV ; NO,OUTPUT IT.
  TAY ; INVERSE VIDEO?
  BPL STOADV ; YES, OUTPUT IT.
  CMP #$8D ; CR?
  BEQ CR ; YES.
  CMP #$8A ; LINE FEED?
  BEQ LF ; IF SO, DO IT.
  CMP #$88 ; BACK SPACE? (CNTRL-H)
  BNE BELL1 ; NO, CHECK FOR BELL.
BS1: DEC CH ; DECREMENT CURSOR H INDEX
  BPL RTS3 ; IF POS, OK. ELSE MOVE UP
  LDA WNDWDTH ; SET CH TO WNDWDTH-1
  STA CH
 DEC CH ; (RIGHTMOST SCREEN POS)
UP: LDA WNDTOP ; CURSOR V INDEX
  CMP CV
  BCS RTS4 ; IF TOP LINE THEN RETURN
  DEC CV ; DEC CURSOR V-INDEX
VTAB: LDA CV ; GET CURSOR V-INDEX
VTABZ: JSR BASCALC ; GENERATE BASE ADR
  ADC WNDLFT ; ADD WINDOW LEFT INDEX
  STA BASL ; TO BASL
RTS4: RTS
ESC1: EOR #$C0 ; ESC?
  BEQ HOME ; IF SO, DO HOME AND CLEAR
  ADC #$FD ; ESC-A OR B CHECK
  BCC ADVANCE ; A, ADVANCE
  BEQ BS1 ; B, BACKSPACE
  ADC #$FD ; ESC-C OR D CHECK
  BCC LF ; C, DOWN
  BEQ UP ; D, GO UP
  ADC #$FD ; ESC-E OR F CHECK
  BCC CLREOL ; E, CLEAR TO END OF LINE
  BNE RTS4 ; NOT F, RETURN
CLREOP: LDY CH ; CURSOR H TO Y INDEX
  LDA CV ; CURSOR V TO A-REGISTER
CLEOP1: PHA ; SAVE CURRENT LINE ON STK
  JSR VTABZ ; CALC BASE ADDRESS
  JSR CLEOLZ ; CLEAR TO EOL, SET CARRY
  LDY #$00 ; CLEAR FROM H INDEX=0 FOR REST
  PLA ; INCREMENT CURRENT LINE
  ADC #$00 ; (CARRY IS SET)
  CMP WNDBTM ; DONE TO BOTTOM OF WINDOW?
  BCC CLEOP1 ; NO, KEEP CLEARING LINES
  BCS VTAB ; YES, TAB TO CURRENT LINE
HOME: LDA WNDTOP ; INIT CURSOR V
  STA CV ; AND H-INDICES
  LDY #$00
  STY CH ; THEN CLEAR TO END OF PAGE
  BEQ CLEOP1
CR: LDA #$00 ; CURSOR TO LEFT OF INDEX
  STA CH ; (RET CURSOR H=0)
LF: INC CV ; INCR CURSOR V(DOWN 1 LINE)
  LDA CV
  CMP WNDBTM ; OFF SCREEN?
  BCC VTABZ ; NO, SET BASE ADDR
  DEC CV ; DECR CURSOR V (BACK TO BOTTOM)
SCROLL: LDA WNDTOP ; START AT TOP OF SCRL WNDW
  PHA
  JSR VTABZ ; GENERATE BASE ADR
SCRL1: LDA BASL ; COPY BASL,H
  STA BAS2L ; TO BAS2L,H
  LDA BASH
  STA BAS2H
  LDY WNDWDTH ; INIT Y TO RIGHTMOST INDEX
  DEY ; OF SCROLLING WINDOW
  PLA
  ADC #$01 ; INCR LINE NUMBER
  CMP WNDBTM ; DONE?
  BCS SCRL3 ; YES, FINISH
  PHA
  JSR VTABZ ; FORM BASL,H (BASE ADDR)
SCRL2: LDA (BASL),Y ; MOVE A CHR UP ON LINE
.ifdef APPLE1
  NOP
  NOP
.else
  STA (BAS2L),Y
.endif
  DEY ; NEXT CHAR OF LINE
  BPL SCRL2
  BMI SCRL1 ; NEXT LINE (ALWAYS TAKEN)
SCRL3: LDY #$00 ; CLEAR BOTTOM LINE
  JSR CLEOLZ ; GET BASE ADDR FOR BOTTOM LINE
  BCS VTAB ; CARRY IS SET
CLREOL: LDY CH ; CURSOR H INDEX
CLEOLZ: LDA #$A0
CLEOL2:
.ifdef APPLE1
  NOP
  NOP
.else
  STA (BASL),Y ; STORE BLANKS FROM 'HERE'
.endif
  INY ; TO END OF LINES (WNDWDTH)
  CPY WNDWDTH
  BCC CLEOL2
  RTS
WAIT: SEC
WAIT2: PHA
WAIT3: SBC #$01
  BNE WAIT3 ; 1.0204 USEC
  PLA ; (13+27/2*A+5/2*A*A)
  SBC #$01
  BNE WAIT2
  RTS
NXTA4: INC A4L ; INCR 2-BYTE A4
  BNE NXTA1 ; AND A1
  INC A4H
NXTA1: LDA A1L ; INCR 2-BYTE A1.
  CMP A2L
  LDA A1H ; AND COMPARE TO A2
  SBC A2H
  INC A1L ; (CARRY SET IF >=)
  BNE RTS4B
  INC A1H
RTS4B: RTS
.ifdef APPLE1
HEADR: LDY #$48 ; WRITE A*256 'LONG 1'
.else
HEADR: LDY #$4B ; WRITE A*256 'LONG 1'
.endif
  JSR ZERDLY ; HALF CYCLES
  BNE HEADR ; (650 USEC EACH)
  ADC #$FE
  BCS HEADR ; THEN A 'SHORT 0'
  LDY #$21 ; (400 USEC)
WRBIT: JSR ZERDLY ; WRITE TWO HALF CYCLES
  INY ; OF 250 USEC ('0')
  INY ; OR 500 USEC ('0')
ZERDLY: DEY
  BNE ZERDLY
  BCC WRTAPE ; Y IS COUNT FOR
  LDY #$32 ; TIMING LOOP
ONEDLY: DEY
  BNE ONEDLY
.ifdef APPLE1
WRTAPE: LDY IOADR,X
  LDY #$2C
  DEX
.else
WRTAPE: LDY TAPEOUT
  LDY  #$2C
  DEX
.endif
  RTS
RDBYTE: LDX #$08 ; 8 BITS TO READ
RDBYT2: PHA ; READ TWO TRANSITIONS
  JSR RD2BIT ; (FIND EDGE)
  PLA
  ROL ; NEXT BIT
  LDY #$3A ; COUNT FOR SAMPLES
  DEX
  BNE RDBYT2
  RTS
RD2BIT: JSR RDBIT
RDBIT: DEY ; DECR Y UNTIL
.ifdef APPLE1
  LDA $C081 ; TAPE TRANSITION
  CMP LASTIN
  BEQ RDBIT
  STA LASTIN
  CPY #$80 ; SET CARRY ON Y
  RTS
  NOP
  NOP
.else
  LDA TAPEIN ; TAPE TRANSITION
  EOR LASTIN
  BPL RDBIT
  EOR LASTIN
  STA LASTIN
  CPY #$80 ; SET CARRY ON Y
  RTS 
.endif
RDKEY: LDY CH
  LDA (BASL),Y ; SET SCREEN TO FLASH
  PHA
  AND #$3F
  ORA #$40
.ifdef APPLE1
  NOP
  NOP
.else
  STA (BASL),Y
.endif
  PLA
.ifdef APPLE1
  NOP
  NOP
  NOP
.else
  JMP (KSWL) ; GO TO USER KEY-IN
.endif
KEYIN: INC RNDL
  BNE KEYIN2 ; INCR RND NUMBER
  INC RNDH
KEYIN2:
.ifdef APPLE1
  LDA $D011
.else
  BIT KBD ; KEY DOWN?
.endif
  BPL KEYIN ; LOOP
.ifdef APPLE1
  NOP
  NOP
.else
  STA (BASL),Y ; REPLACE FLASHING SCREEN
.endif
.ifdef APPLE1
  LDA $D010 ; GET KEYCODE
  JMP L7
  NOP
.else
  LDA KBD
  BIT KBDSTRB ; CLR KEY STROBE
  RTS
.endif
ESC: JSR RDKEY ; GET KEYCODE
  JSR ESC1 ; HANDLE ESC FUNC.
RDCHAR: JSR RDKEY ; READ KEY
  CMP #$9B ; ESC?
  BEQ ESC ; YES, DON'T RETURN
  RTS
NOTCR: LDA INVFLG
  PHA
  LDA #$FF
  STA INVFLG ; ECHO USER LINE
  LDA IN,X ; NON INVERSE
  JSR COUT
  PLA
  STA INVFLG
  LDA IN,X
.ifdef APPLE1
  CMP #$DF ; CHECK FOR EDIT KEYS
.else
  CMP #$88 ; CHECK FOR EDIT KEYS
.endif
  BEQ BCKSPC ; BS, CTRL-X
  CMP #$98
  BEQ CANCEL
  CPX #$F8 ; MARGIN?
  BCC NOTCR1
  JSR BELL ; YES, SOUND BELL
NOTCR1: INX ; ADVANCE INPUT INDEX
  BNE NXTCHAR
CANCEL: LDA #$DC ; BACKSLASH AFTER CANCELLED LINE
  JSR COUT
GETLNZ: JSR CROUT ; OUTPUT CR
GETLN: LDA PROMPT
  JSR COUT ; OUTPUT PROMPT CHAR
  LDX #$01 ; INIT INPUT INDEX
BCKSPC: TXA ; WILL BACKSPACE TO 0
  BEQ GETLNZ
  DEX
NXTCHAR: JSR RDCHAR
  CMP #PICK ; USE SCREEN CHAR
  BNE CAPTST ; FOR CTRL-U
  LDA (BASL),Y
CAPTST: CMP #$E0
  BCC ADDINP ; CONVERT TO CAPS
  AND #$DF
ADDINP: STA IN,X ; ADD TO INPUT BUF
  CMP #$8D
  BNE NOTCR
  JSR CLREOL ; CLR TO EOL IF CR
CROUT: LDA #$8D
  BNE COUT
PRA1: LDY A1H ; PRINT CR,A1 IN HEX
  LDX A1L
PRYX2: JSR CROUT
  JSR PRNTYX
  LDY #$00
  LDA #$AD ; PRINT '-'
  JMP COUT
XAM8: LDA A1L
  ORA #$07 ; SET TO FINISH AT
  STA A2L ; MOD 8=7
  LDA A1H
  STA A2H
MODSCHK: LDA A1L
  AND #$07
  BNE DATAOUT
XAM: JSR PRA1
DATAOUT: LDA #$A0
  JSR COUT ; OUTPUT BLANK
  LDA (A1L),Y
  JSR PRBYTE ; OUTPUT BYTE IN HEX
  JSR NXTA1
  BCC MODSCHK ; CHECK IF TIME TO,
RTS4C: RTS ; PRINT ADDR
XAMPM: LSR A ; DETERMINE IF MON
  BCC XAM ; MODE IS XAM
  LSR A ; ADD, OR SUB
  LSR A
  LDA A2L
  BCC @ADD
  EOR #$FF ; SUB: FORM 2'S COMPLEMENT
@ADD: ADC A1L
  PHA
  LDA #$BD
  JSR COUT ; PRINT '=', THEN RESULT
  PLA
PRBYTE: PHA ; PRINT BYTE AS 2 HEX
  LSR A ; DIGITS, DESTROYS A-REG
  LSR A
  LSR A
  LSR A
  JSR PRHEXZ
  PLA
PRHEX: AND #$0F ; PRINT HEX DIG IN A-REG
PRHEXZ: ORA #$B0 ; LSB'S
  CMP #$BA
  BCC COUT
  ADC #$06
COUT:
.ifdef APPLE1
  JSR L3
.else
 JMP (CSWL) ; VECTOR TO USER OUTPUT ROUTINE
.endif
COUT1: CMP #$A0
  BCC COUTZ ; DON'T OUTPUT CTRL'S INVERSE
  AND INVFLG ; MASK WITH INVERSE FLAG
COUTZ: STY YSAV1 ; SAV Y-REG
  PHA ; SAV A-REG
  JSR VIDOUT ; OUTPUT A-REG AS ASCII
  PLA ; RESTORE A-REG
  LDY YSAV1 ; AND Y-REG
  RTS ; THEN RETURN
BL1: DEC YSAV
  BEQ XAM8
BLANK: DEX ; BLANK TO MON
  BNE SETMDZ ; AFTER BLANK
  CMP #$BA ; DATA STORE MODE?
  BNE XAMPM ; NO, XAM, ADD, OR SUB
STOR: STA MODE ; KEEP IN STORE MODE
  LDA A2L
  STA (A3L),Y ; STORE AS LOW BYTE AS (A3)
  INC A3L
  BNE RTS5 ; INCR A3, RETURN
  INC A3H
RTS5: RTS
SETMODE: LDY YSAV ; SAVE CONVERTED ':', '+',
  LDA IN-1,Y ; '-', '.' AS MODE.
SETMDZ: STA MODE
  RTS
LT: LDX #$01
LT2: LDA A2L,X ; COPY A2 (2 BYTES) TO
  STA A4L,X ; A4 AND A5
  STA A5L,X
  DEX
  BPL LT2
  RTS
MOVE: LDA (A1L),Y ; MOVE (A1 TO A2) TO
  STA (A4L),Y ; (A4)
  JSR NXTA4
  BCC MOVE
  RTS
VFY: LDA (A1L),Y ; VERIFY (A1 TO A2) WITH
  CMP (A4L),Y ; (A4)
  BEQ VFYOK
  JSR PRA1
  LDA (A1L),Y
  JSR PRBYTE
  LDA #$A0
  JSR COUT
  LDA #$A8
  JSR COUT
  LDA (A4L),Y
  JSR PRBYTE
  LDA #$A9
  JSR COUT
VFYOK: JSR NXTA4
  BCC VFY
  RTS
LIST: JSR A1PC ; MOVE A1 (2 BYTES) TO
  LDA #$14 ; PC IF SPEC'D AND
LIST2: PHA ; DISEMBLE 20 INSTRS
  JSR INSTDSP
  JSR PCADJ ; ADJUST PC EACH INSTR
  STA PCL
  STY PCH
  PLA
  SEC
  SBC #$01 ; NEXT OF 20 INSTRS
  BNE LIST2
  RTS
A1PC: TXA ; IF USER SPEC'D ADR
  BEQ A1PCRTS ; COPY FROM A1 TO PC
A1PCLP: LDA A1L,X
  STA PCL,X
  DEX
  BPL A1PCLP
A1PCRTS: RTS
SETINV: LDY #$3F ; SET FOR INVERSE VID
  BNE SETIFLG ; VIA COUT1
SETNORM: LDY #$FF ; SET FOR NORMAL VID
SETIFLG: STY INVFLG
  RTS
SETKBD: LDA #$00 ; SIMULATE PORT #0 INPUT
INPORT: STA A2L ; SPECIFIED (KEYIN ROUTINE)
INPRT: LDX #KSWL
  LDY #<KEYIN
  BNE IOPRT
SETVID: LDA #$00 ; SIMULATE PORT #0 OUTPUT
OUTPORT: STA A2L ; SPECIFIED (COUT1 ROUTINE)
OUTPRT: LDX #CSWL
  LDY #<COUT1
IOPRT: LDA A2L ; SET RAM IN/OUT VECTORS
  AND #$0F
  BEQ IOPRT1
  ORA #>IOADR
  LDY #$00
  BEQ IOPRT2
.ifdef APPLE1
IOPRT1: LDA #$FD
.else
IOPRT1: LDA #>COUT1
.endif
IOPRT2: STY LOC0,X
  STA LOC1,X
  RTS
  NOP
  NOP
XBASIC: JMP BASIC ; TO BASIC WITH SCRATCH
BASCONT: JMP BASIC2 ; CONTINUE BASIC
GO: JSR A1PC ; ADR TO PC IF SPEC'D
  JSR RESTORE ; RESTORE META REGS
  JMP (PCL) ; GO TO USER SUBR
REGZ: JMP REGDSP ; TO REG DISPLAY
TRACE: DEC YSAV
STEPZ: JSR A1PC ; ADR TO PC IF SPEC'D
  JMP STEP ; TAKE ONE STEP
USR: JMP USRADR ; TO USR SUBR AT USRADR
WRITE: LDA #$40
  JSR HEADR ; WRITE 10-SEC HEADER
  LDY #$27
WR1: LDX #$00
  EOR (A1L,X)
  PHA
  LDA (A1L,X)
  JSR WRBYTE
  JSR NXTA1
  LDY #$1D
  PLA
  BCC WR1
  LDY #$22
  JSR WRBYTE
  BEQ BELL
WRBYTE: LDX #$10
WRBYT2: ASL A
  JSR WRBIT
  BNE WRBYT2
  RTS
CRMON: JSR BL1 ; HANDLE A CR AS BLANK
  PLA ; THEN POP STACK
  PLA ; AND RTN TO MON
  BNE MONZ
READ: JSR RD2BIT ; FIND TAPEIN EDGE
  LDA #$16
  JSR HEADR ; DELAY 3.5 SECONDS
  STA CHKSUM ; INIT CHKSUM=$FF
  JSR RD2BIT ; FIND TAPEIN EDGE
RD2: LDY #$24 ; LOOK FOR SYNC BIT
  JSR RDBIT ; (SHORT 0)
  BCS RD2 ; LOOP UNTIL FOUND
  JSR RDBIT ; SKIP SECOND SYNC H-CYCLE
  LDY #$3B ; INDEX FOR 0/1 TEST
RD3: JSR RDBYTE ; READ A BYTE
  STA (A1L,X) ; STORE AT (A1)
  EOR CHKSUM
  STA CHKSUM ; UPDATE RUNNING CHKSUM
  JSR NXTA1 ; INC A1, COMPARE TO A2
  LDY #$35 ; COMPENSATE 0/1 INDEX
  BCC RD3 ; LOOP UNTIL DONE
  JSR RDBYTE ; READ CHKSUM BYTE
  CMP CHKSUM
  BEQ BELL ; GOOD, SOUND BELL AND RETURN
PRERR: LDA #$C5
  JSR COUT ; PRINT "ERR", THEN BELL
  LDA #$D2
  JSR COUT
  JSR COUT
BELL: LDA #$87 ; OUTPUT BELL AND RETURN
  JMP COUT
RESTORE: LDA STATUS ; RESTORE 6502 REG CONTENTS
  PHA ; USED BY DEBUG SOFTWARE
  LDA ACC
RESTR1: LDX XREG
  LDY YREG
  PLP
  RTS
SAVE: STA ACC ; SAVE 6502 REG CONTENTS
SAV1: STX XREG
  STY YREG
  PHP
  PLA
  STA STATUS
  TSX
  STX SPNT
  CLD
  RTS
.ifdef APPLE1
RESET: JSR L8 ; SET SCREEN MODE
.else
RESET: JSR SETNORM ; SET SCREEN MODE
.endif
  JSR INIT ; AND INIT KBD/SCREEN
.ifdef APPLE1
  JSR SETNORM ; AS I/O DEV'S
.else
  JSR SETVID ; AS I/O DEV'S
.endif
  JSR SETKBD
MON: CLD ; MUST SET HEX MODE!
  JSR BELL
MONZ: LDA #$AA ; '*' PROMPT FOR MON
  STA PROMPT
  JSR GETLNZ ; READ A LINE
  JSR ZMODE ; CLEAR MON MODE, SCAN IDX
NXTITM: JSR GETNUM ; GET ITEM, NON-HEX
  STY YSAV ; CHAR IN A-REG
  LDY #$17 ; X-REG=0 IF NO HEX INPUT
CHRSRCH: DEY
  BMI MON ; NOT FOUND, GO TO MON
  CMP CHRTBL,Y ; FIND CMND CHAR IN TEL
  BNE CHRSRCH
  JSR TOSUB ; FOUND, CALL CORRESPONDING
  LDY YSAV ; SUBROUTINE
  JMP NXTITM
DIG: LDX #$03
  ASL A
  ASL A ; GOT HEX DIG,
  ASL A ; SHIFT INTO A2
  ASL A
NXTBIT: ASL A
  ROL A2L
  ROL A2H
  DEX ; LEAVE X=$FF IF DIG
  BPL NXTBIT
NXTBAS: LDA MODE
  BNE NXTBS2 ; IF MODE IS ZERO
  LDA A2H,X ; THEN COPY A2 TO
  STA A1H,X ; A1 AND A3
  STA A3H,X
NXTBS2: INX
  BEQ NXTBAS
  BNE NXTCHR
GETNUM: LDX #$00 ; CLEAR A2
  STX A2L
  STX A2H
NXTCHR: LDA IN,Y ; GET CHAR
  INY
  EOR #$B0
  CMP #$0A
  BCC DIG ; IF HEX DIG, THEN
  ADC #$88
  CMP #$FA
  BCS DIG
  RTS
TOSUB: LDA #>GO ; PUSH HIGH-ORDER
  PHA ; SUBR ADR ON STK
  LDA SUBTBL,Y ; PUSH LOW-ORDER
  PHA ; SUBR ADR ON STK
  LDA MODE
ZMODE: LDY #$00 ; CLR MODE, OLD MODE
   STY MODE ; TO A-REG
   RTS ; GO TO SUBR VIA RTS
CHRTBL: .BYTE $BC ; F("CTRL-C")
  .BYTE $B2 ; F("CTRL-Y")
  .BYTE $BE ; F("CTRL-E")
  .BYTE $ED ; F("T")
  .BYTE $EF ; F("V")
  .BYTE $C4 ; F("CTRL-K")
  .BYTE $EC ; F("S")
  .BYTE $A9 ; F("CTRL-P")
  .BYTE $BB ; F("CTRL-B")
  .BYTE $A6 ; F("-")
  .BYTE $A4 ; F("+")
  .BYTE $06 ; F("M") (F=EX-OR $B0+$89)
  .BYTE $95 ; F("<")
  .BYTE $07 ; F("N")
  .BYTE $02 ; F("I")
  .BYTE $05 ; F("L")
  .BYTE $F0 ; F("W")
  .BYTE $00 ; F("G")
  .BYTE $EB ; F("R")
  .BYTE $93 ; F(":")
  .BYTE $A7 ; F(".")
  .BYTE $C6 ; F("CR")
  .BYTE $99 ; F(BLANK)

SUBTBL: .BYTE <BASCONT-1
  .BYTE <USR-1
  .BYTE <REGZ-1
  .BYTE <TRACE-1
  .BYTE <VFY-1
  .BYTE <INPRT-1
  .BYTE <STEPZ-1
  .BYTE <OUTPRT-1
  .BYTE <XBASIC-1
  .BYTE <SETMODE-1
  .BYTE <SETMODE-1
  .BYTE <MOVE-1
  .BYTE <LT-1
  .BYTE <SETNORM-1
  .BYTE <SETINV-1
  .BYTE <LIST-1
  .BYTE <WRITE-1
  .BYTE <GO-1
  .BYTE <READ-1
  .BYTE <SETMODE-1
  .BYTE <SETMODE-1
  .BYTE <CRMON-1
  .BYTE <BLANK-1
.ifndef APPLE1
  .WORD NMI        ;NMI VECTOR
  .WORD RESET      ;RESET VECTOR
  .WORD IRQ        ;IRQ VECTOR
.endif
.ifdef WOZMON
  .WORD NMI        ;NMI VECTOR
  .WORD RESET      ;RESET VECTOR
  .WORD IRQ        ;IRQ VECTOR
.endif
XQTNZ = $3C

.ifdef WOZMON
.proc WozMon

;  The WOZ Monitor for the Apple 1
;  Written by Steve Wozniak in 1976


; Page 0 Variables

XAML            = $24           ;  Last "opened" location Low
XAMH            = $25           ;  Last "opened" location High
STL             = $26           ;  Store address Low
STH             = $27           ;  Store address High
L               = $28           ;  Hex value parsing Low
H               = $29           ;  Hex value parsing High
YSAV            = $2A           ;  Used to see if hex value is given
MODE            = $2B           ;  $00=XAM, $7F=STOR, $AE=BLOCK XAM


; Other Variables

IN              = $0200         ;  Input buffer to $027F
KBD             = $D010         ;  PIA.A keyboard input
KBDCR           = $D011         ;  PIA.A keyboard control register
DSP             = $D012         ;  PIA.B display output register
DSPCR           = $D013         ;  PIA.B display control register

;               .org $FF00
               .export RESET

RESET:          CLD             ; Clear decimal arithmetic mode.
                CLI
                LDY #$7F        ; Mask for DSP data direction register.
                STY DSP         ; Set it up.
                LDA #$A7        ; KBD and DSP control register mask.
                STA KBDCR       ; Enable interrupts, set CA1, CB1, for
                STA DSPCR       ; positive edge sense/output mode.
NOTCR:          CMP #'_'+$80    ; "_"?
                BEQ BACKSPACE   ; Yes.
                CMP #$9B        ; ESC?
                BEQ ESCAPE      ; Yes.
                INY             ; Advance text index.
                BPL NEXTCHAR    ; Auto ESC if > 127.
ESCAPE:         LDA #'\'+$80    ; "\".
                JSR ECHO        ; Output it.
GETLINE:        LDA #$8D        ; CR.
                JSR ECHO        ; Output it.
                LDY #$01        ; Initialize text index.
BACKSPACE:      DEY             ; Back up text index.
                BMI GETLINE     ; Beyond start of line, reinitialize.
NEXTCHAR:       LDA KBDCR       ; Key ready?
                BPL NEXTCHAR    ; Loop until ready.
                LDA KBD         ; Load character. B7 should be ‘1’.
                STA IN,Y        ; Add to text buffer.
                JSR ECHO        ; Display character.
                CMP #$8D        ; CR?
                BNE NOTCR       ; No.
                LDY #$FF        ; Reset text index.
                LDA #$00        ; For XAM mode.
                TAX             ; 0->X.
SETSTOR:        ASL             ; Leaves $7B if setting STOR mode.
SETMODE:        STA MODE        ; $00=XAM $7B=STOR $AE=BLOK XAM
BLSKIP:         INY             ; Advance text index.
NEXTITEM:       LDA IN,Y        ; Get character.
                CMP #$8D        ; CR?
                BEQ GETLINE     ; Yes, done this line.
                CMP #'.'+$80    ; "."?
                BCC BLSKIP      ; Skip delimiter.
                BEQ SETMODE     ; Yes. Set STOR mode.
                CMP #':'+$80    ; ":"?
                BEQ SETSTOR     ; Yes. Set STOR mode.
                CMP #'R'+$80    ; "R"?
                BEQ RUN         ; Yes. Run user program.
                STX L           ; $00-> L.
                STX H           ; and H.
                STY YSAV        ; Save Y for comparison.
NEXTHEX:        LDA IN,Y        ; Get character for hex test.
                EOR #$B0        ; Map digits to $0-9.
                CMP #$0A        ; Digit?
                BCC DIG         ; Yes.
                ADC #$88        ; Map letter "A"-"F" to $FA-FF.
                CMP #$FA        ; Hex letter?
                BCC NOTHEX      ; No, character not hex.
DIG:            ASL
                ASL             ; Hex digit to MSD of A.
                ASL
                ASL
                LDX #$04        ; Shift count.
HEXSHIFT:       ASL             ; Hex digit left, MSB to carry.
                ROL L           ; Rotate into LSD.
                ROL H           ;  Rotate into MSD’s.
                DEX             ; Done 4 shifts?
                BNE HEXSHIFT    ; No, loop.
                INY             ; Advance text index.
                BNE NEXTHEX     ; Always taken. Check next char for hex.
NOTHEX:         CPY YSAV        ; Check if L, H empty (no hex digits).
                BEQ ESCAPE      ; Yes, generate ESC sequence.
                BIT MODE        ; Test MODE byte.
                BVC NOTSTOR     ;  B6=0 STOR 1 for XAM & BLOCK XAM
                LDA L           ; LSD’s of hex data.
                STA (STL,X)     ; Store at current ‘store index’.
                INC STL         ; Increment store index.
                BNE NEXTITEM    ; Get next item. (no carry).
                INC STH         ; Add carry to ‘store index’ high order.
TONEXTITEM:     JMP NEXTITEM    ; Get next command item.
RUN:            JMP (XAML)      ; Run at current XAM index.
NOTSTOR:        BMI XAMNEXT     ; B7=0 for XAM, 1 for BLOCK XAM.
                LDX #$02        ; Byte count.
SETADR:         LDA L-1,X       ; Copy hex data to
                STA STL-1,X     ; ‘store index’.
                STA XAML-1,X    ; And to ‘XAM index’.
                DEX             ; Next of 2 bytes.
                BNE SETADR      ; Loop unless X=0.
NXTPRNT:        BNE PRDATA      ; NE means no address to print.
                LDA #$8D        ; CR.
                JSR ECHO        ; Output it.
                LDA XAMH        ; ‘Examine index’ high-order byte.
                JSR PRBYTE      ; Output it in hex format.
                LDA XAML        ; Low-order ‘examine index’ byte.
                JSR PRBYTE      ; Output it in hex format.
                LDA #':'+$80    ; ":".
                JSR ECHO        ; Output it.
PRDATA:         LDA #$A0        ; Blank.
                JSR ECHO        ; Output it.
                LDA (XAML,X)    ; Get data byte at ‘examine index’.
                JSR PRBYTE      ; Output it in hex format.
XAMNEXT:        STX MODE        ; 0->MODE (XAM mode).
                LDA XAML
                CMP L           ; Compare ‘examine index’ to hex data.
                LDA XAMH
                SBC H
                BCS TONEXTITEM  ; Not less, so no more data to output.
                INC XAML
                BNE MOD8CHK     ; Increment ‘examine index’.
                INC XAMH
MOD8CHK:        LDA XAML        ; Check low-order ‘examine index’ byte
                AND #$07        ; For MOD 8=0
                BPL NXTPRNT     ; Always taken.
PRBYTE:         PHA             ; Save A for LSD.
                LSR
                LSR
                LSR             ; MSD to LSD position.
                LSR
                JSR PRHEX       ; Output hex digit.
                PLA             ; Restore A.
PRHEX:          AND #$0F        ; Mask LSD for hex print.
                ORA #'0'+$80    ; Add "0".
                CMP #$BA        ; Digit?
                BCC ECHO        ; Yes, output it.
                ADC #$06        ; Add offset for letter.
ECHO:           BIT DSP         ; bit (B7) cleared yet?
                BMI ECHO        ; No, wait for display.
                STA DSP         ; Output character. Sets DA.
                RTS             ; Return.
                BRK             ; unused
                BRK             ; unused

; Interrupt Vectors

                .WORD $0F00     ; NMI
                .WORD RESET     ; RESET
                .WORD $0000     ; BRK/IRQ
.endproc
.endif
