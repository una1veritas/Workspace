; Source for CEGMON monitor.
; Was generated by disassembling ROM image.
; Original content (c) 1980 George Chkintz, Richard Elen, Tom Graves
; DGG 2019-04-11 - Added labels from CEGMON users guide found at:
; http://uk101.sourceforge.net/docs/pdf/cegmon.pdf

        .org $F800

L0000           := $0000
L002E           := $002E
L00FD           := $00FD
L00FE           := $00FE        ; $00FE LOFROM store current address for most routines the from address in save move and tabular display
L0218           := $0218
L021A           := $021A
L021C           := $021C
L021E           := $021E
L0220           := $0220
L0227           := $0227
L022A           := $022A
L0233           := $0233        ; $0233 USERLO contains location of start of user routine called by machine code monitors U command
L2F44           := $2F44
L415A           := $415A
LA34B           := $A34B
LA374           := $A374
LA636           := $A636
LBF2D           := $BF2D
LD08C           := $D08C
LF800:  lda     $0E
        beq     LF80A
        dec     $0E
        beq     LF80A
        dec     $0E
LF80A:  lda     #$20
        sta     $0201           ; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor
        jsr     LFF8F
        bpl     LF82D
        sec
        lda     $022B
        sbc     #$40
        sta     $022B
        lda     $022C
        sbc     #$00
        sta     $022C
        jsr     ENDCHK
        bcs     LF82D
        jsr     CURHOM
LF82D:  stx     $0200           ; $0200 CURDIS cursor displacement on current line
        jsr     LFF88
        jmp     LF8D2
SCREEN: sta     $0202           ; $F836 - SCREEN - new screen handler
                                ; $0202 NEWCHR park for new char for SCREEN
        pha
        txa
        pha
        tya
        pha
        lda     $0202           ; $0202 NEWCHR park for new char for SCREEN
        bne     LF846
        jmp     LF8D2
LF846:  ldy     $0206           ; $0206 SDELAY print-delay value for SCREEN delay is delay-value times approx. 400 machine-cycles (ie times 400 micro-seconds at 1MHz)
        beq     LF84E
        jsr     DELAY2
LF84E:  cmp     #$5F
        beq     LF800
        cmp     #$0C
        bne     LF861
        jsr     SCOUT
        jsr     CURHOM
        stx     $0200           ; $0200 CURDIS cursor displacement on current line
        beq     LF8CF
LF861:  cmp     #$0A
        beq     LF88C
        cmp     #$1E
        beq     LF8E0
        cmp     #$0B
        beq     LF87D
        cmp     #$1A
        beq     LF8D8
        cmp     #$0D
        bne     LF87A
        jsr     LFF6D
        bne     LF8D2
LF87A:  sta     $0201           ; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor
LF87D:  jsr     SCOUT
        inc     $0200           ; $0200 CURDIS cursor displacement on current line
        inx
        cpx     $0222
        bmi     LF8CF
        jsr     LFF70
LF88C:  jsr     SCOUT
        ldy     #$02
        jsr     LFBD2
        bcs     LF89E
        ldx     #$03
        jsr     LFDEE
        jmp     LF8CF
LF89E:  jsr     LFE28
        jsr     CURHOM
        jsr     LFDEE
        ldx     $0222
LF8AA:  jsr     L0227
        bpl     LF8AA
        inx
        jsr     LFDEE
        ldx     #$03
        jsr     LFDEE
        jsr     ENDCHK
        bcc     LF8AA
        lda     #$20
LF8BF:  jsr     L022A
        bpl     LF8BF
        ldx     #$01
LF8C6:  lda     $0223,x
        sta     $0228,x
        dex
        bpl     LF8C6
LF8CF:  jsr     LFF75
LF8D2:  pla
        tay
        pla
        tax
        pla
        rts

LF8D8:  jsr     SCNCLR
        sta     $0201           ; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor
        beq     LF904
LF8E0:  lda     #$20
        jsr     LFF8F
        jsr     CURHOM
LF8E8:  ldx     $0222
        lda     #$20
LF8ED:  jsr     L022A
        bpl     LF8ED
        sta     $0201           ; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor
        ldy     #$02
        jsr     LFBD2
        bcs     LF904
        ldx     #$03
        jsr     LFDEE
        jmp     LF8E8
LF904:  jsr     CURHOM
        stx     $0200           ; $0200 CURDIS cursor displacement on current line
        beq     LF8D2
LF90C:  jsr     TWOQAD
LF90F:  jsr     CRLF
        jsr     QDDATD
        jsr     SPCOUT
        jsr     LFBE0
        ldx     #$08
        stx     L00FD
LF91F:  jsr     SPCOUT
        jsr     PRBYTE
        jsr     NOTEND
        bcs     LF97B
        jsr     BUMP
        dec     L00FD
        bne     LF91F
        beq     LF90F
LF933:  jsr     TRIQAD
        jsr     LFDE4
        bcs     MSTART
LF93B:  ldx     $E4             ; Break table K register - stack pointer
        txs
        lda     $E6             ; Break table PCH - high byte of program counter
        pha
        lda     $E5             ; Break table PCL - low byte of program counter
        pha
        lda     $E3             ; Break table P register - processor status flags, in hexadecimal form
        pha
        lda     $E0             ; Break table A register - accumulator
        ldx     $E1             ; Break table X register
        ldy     $E2             ; Break table Y register
        rti
LF94E:  ldx     #$03
LF950:  lda     LFA4B,x
        sta     $0234,x         ; $0233 USERHI contains location of start of user routine called by machine code monitors U command
        dex
        bne     LF950
        jsr     GETNEW
        jsr     GETQDE
        lda     (L00FE),y       ; $00FE LOFROM store current address for most routines the from address in save move
        sta     $E7
        tya
        sta     (L00FE),y       ; $00FE LOFROM store current address for most routines the from address in save move
        beq     MSTART
LF968:  jmp     SAVEMC
LF96B:  dec     $FB
        bne     LF9E8
LF96F:  beq     LF90C
LF971:  rts

LF972:  lda     $FB
        bne     LF971
        lda     #$3F
        jsr     OUTVEC
LF97B:  ldx     #$28
        txs
MSTART: jsr     CRLF            ; $F97E MSTART entry to command/address mode
        ldy     #$00
        sty     $FB
        jsr     LFBE0
LF988:  jsr     GETNEW
        cmp     #$4D
        beq     LF933
        cmp     #$52
        beq     LF93B
        cmp     #$5A
        beq     LF94E
        cmp     #$53
        beq     LF968
        cmp     #$4C
        beq     LF96B
        cmp     #$55
        bne     LF9D6
        jmp     (L0233)
TWOQAD: jsr     GETNEW          ; $F9A6 TWOQAD - collect two addresses first stored in (FE) pair, second in (F9)
        jsr     GETQDE
        jsr     LFBE3
        ldx     #$00
LF9B1:  jsr     GETNEW
        .byte   $2C
GETQDE: ldx     #$05            ; $F9B5 GETQDE - collect address, store in (FE). Note call GETNEW first!
        jsr     LF9C0
        jsr     GETNEW
        .byte   $2C
GETPRC: ldx     #$03            ; $F9BE GETPRC collect hex pair for data byte, store in FC: Note call GETNEW first!
LF9C0:  jsr     LF9C6
        jsr     GETNEW
LF9C6:  cmp     #$2E
        beq     LF988
        cmp     #$2F
        beq     LF9E8
        jsr     ASCHEX
        bmi     LF972
        jmp     ROLSTR
LF9D6:  cmp     #$54
        beq     LF96F
        jsr     GETQDE
LF9DD:  lda     #$2F
        jsr     OUTVEC
        jsr     PRBYTE
        jsr     SPCOUT
LF9E8:  jsr     GETNEW
        cmp     #$47
        bne     LF9F2
        jmp     (L00FE)         ; $00FE LOFROM store current address for most routines the from address in save move
LF9F2:  cmp     #$2C
        bne     LF9FC
        jsr     BUMP
        jmp     LF9E8
LF9FC:  cmp     #$0A
        beq     LFA16
        cmp     #$0D
        beq     LFA1B
        cmp     #$5E
        beq     LFA21
        cmp     #$27
        beq     LFA3A
        jsr     GETPRC
        lda     $FC
        sta     (L00FE),y       ; $00FE LOFROM store current address for most routines the from address in save move
LFA13:  jmp     LF9E8
LFA16:  lda     #$0D
        jsr     OUTVEC
LFA1B:  jsr     BUMP
        jmp     LFA31
LFA21:  sec
        lda     L00FE           ; $00FE LOFROM store current address for most routines the from address in save move
        sbc     #$01
        sta     L00FE           ; $00FE LOFROM store current address for most routines the from address in save move
        lda     $FF
        sbc     #$00
        sta     $FF
DATALN: jsr     CRLF            ; $FA2E - DATALN entry to data-mode loop - prints current address and its contents
LFA31:  jsr     QDDATD
        jmp     LF9DD
        jsr     LFEF7
LFA3A:  jsr     GETNEW
        cmp     #$27
        bne     LFA46
        jsr     LFBE3
        bne     LFA13
LFA46:  cmp     #$0D
        beq     DATALN
        .byte   $D0
LFA4B:  .byte   $EB
        jmp     LFA4F
LFA4F:  sta     $E0             ; Break table A register - accumulator
        pla
        pha
        and     #$10
        bne     LFA5A
        lda     $E0             ; Break table A register - accumulator
        rti
LFA5A:  stx     $E1             ; Break table X register
        sty     $E2             ; Break table Y register
        pla
        sta     $E3             ; Break table P register - processor status flags, in hexadecimal form
        cld
        sec
        pla
        sbc     #$02
        sta     $E5             ; Break table PCL - low byte of program counter
        pla
        sbc     #$00
        sta     $E6             ; Break table PCH - high byte of program counter
        tsx
        stx     $E4             ; Break table K register - stack pointer
        ldy     #$00
        lda     $E7
        sta     ($E5),y         ; Break table PCL - low byte of program counter
        lda     #$E0            ; Break table A register - accumulator
        sta     L00FE           ; $00FE LOFROM store current address for most routines the from address in save move
        sty     $FF
        bne     DATALN
SAVEMC: jsr     TRIQAD          ; $FA7E - SAVEMC
        jsr     SVVEC
        jsr     GETCHR
        jsr     OUTVEC
        jsr     LFFE3
        lda     #$2F
        jsr     OUTVEC
        bne     LFA97
LFA94:  jsr     BUMP
LFA97:  jsr     PRBYTE
        lda     #$0D
        jsr     TAPOUT
        jsr     NOTEND
        bcc     LFA94
        lda     $E4             ; Break table K register - stack pointer
        ldx     $E5             ; Break table PCL - low byte of program counter
        sta     L00FE           ; $00FE LOFROM store current address for most routines the from address in save move
        stx     $FF
        jsr     LFFE3
        lda     #$47
        jsr     OUTVEC
        jsr     LFFAC
        sty     $0205           ; $0205 SVFLAG BASIC save flag 0=skip save, 1=enable save to ACIA
        jmp     MSTART          ; entry to command/address mode
EDITOR: txa                     ; $FABD - entry to screen editor
        pha
        tya
        pha
        lda     $0204           ; $0204 EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor
        bpl     LFB1F
LFAC6:  ldy     $022F           ; $022F DISP edit-cursor displacement from start of editors current line
        lda     $0231           ; $0231 CURSLO contain start of edit cursors current line on screen
        sta     $E4             ; Break table K register - stack pointer
        lda     $0232           ; $0232 CURSHI contain start of edit cursors current line on screen
        sta     $E5             ; Break table PCL - low byte of program counter
        lda     ($E4),y         ; Break table K register - stack pointer
        sta     $0230           ; $0230 CURCHR store for char beneath edit cursor
        lda     #$A1
        sta     ($E4),y         ; Break table K register - stack pointer
        jsr     GETKEY
        lda     $0230           ; $0230 CURCHR store for char beneath edit cursor
        sta     ($E4),y         ; Break table K register - stack pointer
        lda     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        cmp     #$11
        beq     LFB13
        cmp     #$01
        beq     LFB0D
        cmp     #$04
        beq     LFB07
        cmp     #$13
        beq     LFB01
        cmp     #$06
        bne     LFB22
        jsr     LFB7C
        jmp     LFAC6
LFB01:  jsr     LFE28
        jmp     LFAC6
LFB07:  jsr     LFB6B
        jmp     LFAC6
LFB0D:  jsr     LFE19
        jmp     LFAC6
LFB13:  lda     $0230           ; $0230 CURCHR store for char beneath edit cursor
        sta     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        jsr     LFB6B
        jmp     LFB43
LFB1F:  jsr     GETKEY
LFB22:  cmp     #$05
        bne     LFB43
        lda     $0204           ; $0204 EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor
        eor     #$FF
        sta     $0204           ; $0204 EDFLAG Editor flag 00-disable edit cursor, ff-enabe edit cursor
        bpl     LFB1F
        lda     $022B
        sta     $0231           ; $0231 CURSLO contain start of edit cursors current line on screen
        lda     $022C
        sta     $0232           ; $0232 CURSHI contain start of edit cursors current line on screen
        ldx     #$00
        stx     $022F           ; $022F DISP edit-cursor displacement from start of editors current line
        beq     LFAC6
LFB43:  jmp     LFDD3
        bit     $0203           ; $FB46 - Input vector points to there??? - seems off???
                                ; $0203 LDFLAG BASIC load flag 00=no load, FF-load from ACIA
        bpl     LFB68
LFB4B:  lda     #$FD
        sta     $DF00
        lda     #$10
        bit     $DF00
        beq     LFB61
TAPIN:  lda     $F000           ; TAPIN - collects char from ACIA exits via EDITOR if SPACE hit.
        lsr     a
        bcc     LFB4B
        lda     $F001
        rts

LFB61:  lda     #$00
        sta     $FB
        sta     $0203           ; $0203 LDFLAG BASIC load flag 00=no load, FF-load from ACIA
LFB68:  jmp     EDITOR
LFB6B:  ldx     $0222
        cpx     $022F           ; $022F DISP edit-cursor displacement from start of editors current line
        beq     LFB77
        inc     $022F           ; $022F DISP edit-cursor displacement from start of editors current line
        rts

LFB77:  ldx     #$00
        stx     $022F           ; $022F DISP edit-cursor displacement from start of editors current line
LFB7C:  clc
        lda     $0231           ; $0231 CURSLO contain start of edit cursors current line on screen
        adc     #$40
        sta     $0231           ; $0231 CURSLO contain start of edit cursors current line on screen
        lda     $0232           ; $0232 CURSHI contain start of edit cursors current line on screen
        adc     #$00
        cmp     #$D8
        bne     LFB90
        lda     #$D0
LFB90:  sta     $0232           ; $0232 CURSHI contain start of edit cursors current line on screen
LFB93:  rts

        lda     $0212           ; $0212 CCFLAG BASIC CTRL-C flag 00-enables CTRL-C break, 01-disables CTRL-C break
        bne     LFB93
        lda     #$FE
        sta     $DF00
        bit     $DF00
        bvs     LFB93
        lda     #$FB
        sta     $DF00
        bit     $DF00
        bvs     LFB93
        lda     #$03
        jmp     LA636
LFBB2:  lsr     $FB
        .byte   $9B
        .byte   $FF
        sty     $FB,x
LFBB8:  bvs     LFBB8
        .byte   $7B
        inc     $803F,x
        bne     DISK            ; $FC00 is DISK
        .byte   $D7
        lda     LD08C,x
        sta     LD08C,x
        dex
        rts

        brk
        jsr     LD08C
        dey
        .byte   $F9
ENDCHK:  ldx     $0222          ; $FBCF ENDCHK - checks if top or base of screen overshot - it Y=0, carry clear if top overshot, if Y=2, carry set if base overshot
LFBD2:  sec
        lda     $022B
        sbc     $0223,y
        lda     $022C
        sbc     $0224,y
        rts

LFBE0:  lda     #$3E
        .byte   $2C
LFBE3:  lda     #$2C
        .byte   $2C
SPCOUT: lda     #$20            ; $FBE6 SPCOUT print ASCII space to display
        jmp     OUTVEC
NOTEND: sec                     ; $FBEB NOTEND compare (FE) with (F9) carry clear if (FE) is less
        lda     L00FE           ; $00FE LOFROM store current address for most routines the from address in save move
        sbc     $F9
        lda     $FF
        sbc     $FA
        rts

CRLF:   lda     #$0D            ; $FBF5 CRLF print carriage-return/line-feed to display
        jsr     OUTVEC
        lda     #$0A
        jmp     OUTVEC
        rti
DISK:   jsr     LFC0C           ; $FC00 DISK entry to disc bootstrap
        jmp     (L00FD)
        jsr     LFC0C
        jmp     NEWMON
LFC0C:  ldy     #$00
        sty     $C001
        sty     $C000
        ldx     #$04
        stx     $C001
        sty     $C003
        dey
        sty     $C002
        stx     $C003
        sty     $C002
        lda     #$FB
        bne     LFC33
LFC2A:  lda     #$02
        bit     $C000
        beq     LFC4D
        lda     #$FF
LFC33:  sta     $C002
        jsr     LFCA5
        and     #$F7
        sta     $C002
        jsr     LFCA5
        ora     #$08
        sta     $C002
        ldx     #$18
        jsr     LFC91
        beq     LFC2A
LFC4D:  ldx     #$7F
        stx     $C002
        jsr     LFC91
LFC55:  lda     $C000
        bmi     LFC55
LFC5A:  lda     $C000
        bpl     LFC5A
        lda     #$03
        sta     $C010
        lda     #$58
        sta     $C010
        jsr     LFC9C
        sta     L00FE           ; $00FE LOFROM store current address for most routines the from address in save move
        tax
        jsr     LFC9C
        sta     L00FD
        jsr     LFC9C
        sta     $FF
        ldy     #$00
LFC7B:  jsr     LFC9C
        sta     (L00FD),y
        iny
        bne     LFC7B
        inc     L00FE           ; $00FE LOFROM store current address for most routines the from address in save move
        dec     $FF
        bne     LFC7B
        stx     L00FE           ; $00FE LOFROM store current address for most routines the from address in save move
        lda     #$FF
        sta     $C002
        rts

LFC91:  ldy     #$F8
LFC93:  dey
        bne     LFC93
        eor     $FF,x
        dex
        bne     LFC91
        rts

LFC9C:  lda     $C010
        lsr     a
        bcc     LFC9C
        lda     $C011
LFCA5:  rts

RSACIA: lda     #$03            ; $FCA6 - RSACIA initialize ACIA
        sta     $F000
        lda     #$11
        sta     $F000
        rts

TAPOUT: pha                     ; $FCB1 - output to tape
LFCB2:  lda     $F000
        lsr     a
        lsr     a
        bcc     LFCB2
        pla
        sta     $F001
        rts

KEYWRT: eor     #$FF            ; $FCBE - KEYWRT write-to-keyboard invert for C1
        sta     $DF00
        eor     #$FF
        rts

KEY2XR: pha                     ; KEY2XR - read-X-from keyboard invert for C1
        jsr     KYREAD
        tax
        pla
        dex
        inx
        rts

KYREAD: lda     $DF00           ; $FCCF - KYREAD - read-A-from-keyboard invert for C1
        eor     #$FF
        rts

        cmp     #$5F
        beq     LFCDC
        jmp     LA374
LFCDC:  jmp     LA34B
KDELAY: ldy     #$10            ; $FCDF - KDELAY approx. 6500 cycle delayl exits with X and Y registers zero
DELAY2: ldx     #$40            ; $FCE1 - DELAY2 approx 400xY register cycles delay
LFCE3:  dex
        bne     LFCE3
        dey
        bne     DELAY2
        rts

LFCEA:  .byte "CEGMON(C)1980 D/C/W/M?"

GETKEY: txa                     ; $FD00 - GETKEY wait till key pressed, return with ASCII value in A register
        pha
        tya
        pha
LFD04:  lda     #$80
LFD06:  jsr     KEYWRT
        jsr     KEY2XR
        bne     LFD13
        lsr     a
        bne     LFD06
        beq     LFD3A
LFD13:  lsr     a
        bcc     LFD1F
        txa
        and     #$20
        beq     LFD3A
        lda     #$1B
        bne     LFD50
LFD1F:  jsr     LFE86
        tya
        sta     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        asl     a
        asl     a
        asl     a
        sec
        sbc     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        sta     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        txa
        lsr     a
        asl     a
        jsr     LFE86
        beq     LFD47
        lda     #$00
LFD3A:  sta     $0216           ; $0216 LSTCHR pre-shift value of last key left here by GETKEY to test auto-repeat
LFD3D:  sta     $0213
        lda     #$02
        sta     $0214           ; $0214 COUNTR auto-repeat counter for GETKEY
        bne     LFD04
LFD47:  clc
        tya
        adc     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        tay
        lda     LFF3B,y
LFD50:  cmp     $0213
        bne     LFD3D
        dec     $0214           ; $0214 COUNTR auto-repeat counter for GETKEY
        beq     LFD5F
        jsr     KDELAY
        beq     LFD04
LFD5F:  ldx     #$64
        cmp     $0216           ; $0216 LSTCHR pre-shift value of last key left here by GETKEY to test auto-repeat
        bne     LFD68
        ldx     #$0F
LFD68:  stx     $0214           ; $0214 COUNTR auto-repeat counter for GETKEY
        sta     $0216           ; $0216 LSTCHR pre-shift value of last key left here by GETKEY to test auto-repeat
        cmp     #$21
        bmi     LFDD0
        cmp     #$5F
        beq     LFDD0
        lda     #$01
        jsr     KEYWRT
        jsr     KYREAD
        sta     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        and     #$01
        tax
        lda     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        and     #$06
        bne     LFDA2
        bit     $0213
        bvc     LFDBB
        txa
        eor     #$01
        and     #$01
        beq     LFDBB
        lda     #$20
        bit     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        bvc     LFDC3
        lda     #$C0
        bne     LFDC3
LFDA2:  bit     $0213
        bvc     LFDAA
        txa
        beq     LFDBB
LFDAA:  ldy     $0213
        cpy     #$31
        bcc     LFDB9
        cpy     #$3C
        bcs     LFDB9
        lda     #$F0
        bne     LFDBB
LFDB9:  lda     #$10
LFDBB:  bit     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        bvc     LFDC3
        clc
        adc     #$C0
LFDC3:  clc
        adc     $0213
        and     #$7F
        bit     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        bpl     LFDD0
        ora     #$80
LFDD0:  sta     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
LFDD3:  pla
        tay
        pla
        tax
        lda     $0215           ; $0215 SCRTCH returns from GETKEY with final ASCII value of key
        rts

LFDDB:  jsr     BUMP
        inc     $E4             ; Break table K register - stack pointer
        bne     LFDE4
        inc     $E5             ; Break table PCL - low byte of program counter
LFDE4:  lda     (L00FE),y       ; $FDE4 SWAP memory block move. Expects start address in (FE), end address in (F9), new start of block in (E4) assumes Y=0
        sta     ($E4),y         ; Break table K register - stack pointer
        jsr     NOTEND
        bcc     LFDDB
        rts

LFDEE:  clc
        lda     #$40
        adc     $0228,x
        sta     $0228,x
        lda     #$00
        adc     $0229,x
        sta     $0229,x
        rts

NEWMON: ldx     #$28            ; $FE00 NEWMON entry to m/c monitor - reset stack, vectors/pointers, clear decimal mode. Recommended re-entry point for auto-load m/c tapes.
        txs
        cld
        jsr     RSACIA
        jsr     LFE40
        nop
        nop
MENTRY: jsr     SCNCLR          ; $FE0C MENTRY non-reset entry to m/c monitor - clear screen, zero 'current address'
        sta     $0201           ; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor
        sty     L00FE           ; $00FE LOFROM store current address for most routines the from address in save move
        sty     $FF
        jmp     MSTART
LFE19:  ldx     $022F           ; $022F DISP edit-cursor displacement from start of editors current line
        beq     LFE22
        dec     $022F           ; $022F DISP edit-cursor displacement from start of editors current line
        rts

LFE22:  ldx     $0222
        stx     $022F           ; $022F DISP edit-cursor displacement from start of editors current line
LFE28:  sec
        lda     $0231           ; $0231 CURSLO contain start of edit cursors current line on screen
        sbc     #$40
        sta     $0231           ; $0231 CURSLO contain start of edit cursors current line on screen
        lda     $0232           ; $0232 CURSHI contain start of edit cursors current line on screen
        sbc     #$00
        cmp     #$CF
        bne     LFE3C
        lda     #$D7
LFE3C:  sta     $0232           ; $0232 CURSHI contain start of edit cursors current line on screen
        rts

LFE40:  ldy     #$1C
LFE42:  lda     LFBB2,y
        sta     L0218,y
        dey
        bpl     LFE42
        ldy     #$07
        lda     #$00
        sta     $0212           ; $0212 CCFLAG BASIC CTRL-C flag 00-enables CTRL-C break, 01-disables CTRL-C break
LFE52:  sta     $01FF,y
        dey
        bne     LFE52
        rts

SCNCLR: ldy     #$00            ; SCNCLR $FE59 Clear entire screen; exits with X and Y registers zero.
        sty     $F9
        lda     #$D0
        sta     $FA
        ldx     #$08
        lda     #$20
LFE65:  sta     ($F9),y
        iny
        bne     LFE65
        inc     $FA
        dex
        bne     LFE65
        rts

        pha
        dec     $0203           ; $0203 LDFLAG BASIC load flag 00=no load, FF-load from ACIA
        lda     #$00
LFE76:  sta     $0205           ; $0205 SVFLAG BASIC save flag 0=skip save, 1=enable save to ACIA
        pla
        rts

        pha
        lda     #$01
        bne     LFE76
MCACIA: jsr     TAPIN           ; $FE80 MCACIA get char from ACIA, strip off top bit before returning
        and     #$7F
        rts

LFE86:  ldy     #$08
LFE88:  dey
        asl     a
        bcc     LFE88
        rts

GETNEW: jsr     GETCHR          ; $FE8D GETNEW get new char; print it to display before returning
        jmp     OUTVEC
ASCHEX: cmp     #$30            ; $FE93 - ASCHEX strip ASCII digit to hex set to 80(base16) if not hex
        bmi     LFEA9
        cmp     #$3A
        bmi     LFEA6
        cmp     #$41
        bmi     LFEA9
        cmp     #$47
        bpl     LFEA9
        sec
        sbc     #$07
LFEA6:  and     #$0F
        rts

LFEA9:  lda     #$80
        rts

ADVTOD: jsr     QDDATD          ; $FEAC ADVTOD print address in (FE), space, value in FC to display
        nop
        nop
        jsr     SPCOUT
        bne     PRDATD
QDDATD: ldx     #$03            ; $FEB6 QDDATD print address in (FE) to display
        jsr     LFEBF
        dex
        .byte   $2C
PRDATD: ldx     #$00            ; $FEBD PRDATD print data byte in FC to display
LFEBF:  lda     $FC,x
        lsr     a
        lsr     a
        lsr     a
        lsr     a
        jsr     HEXOUT
        lda     $FC,x
HEXOUT: and     #$0F            ; $FECA HEXOUT strip bute in A register to lower nibble; print nibble as ASCII hex to display
        ora     #$30
        cmp     #$3A
        bmi     LFED5
        clc
        adc     #$07
LFED5:  jmp     OUTVEC
        nop
        nop
ROLSTR: ldy     #$04            ; $FEDA ROLSRT roll new nibble into (FE) if X=2, or into FC if X=0
        asl     a
        asl     a
        asl     a
        asl     a
LFEE0:  rol     a
        rol     $F9,x
        rol     $FA,x
        dey
        bne     LFEE0
        rts

GETCHR:  lda     $FB            ; $FEE9 - GETCHR get char from keyboard or ACIA
        bne     MCACIA
        jmp     GETKEY
PRBYTE: lda     (L00FE),y       ; $FEF0 PRBYTE print data at current address pointed to by (FE) to display. Assumes Y=0!
        sta     $FC
        jmp     PRDATD
LFEF7:  sta     (L00FE),y       ; $00FE LOFROM store current address for most routines the from address in save move
BUMP:   inc     L00FE           ; $FEF9 BUMP increment current address at (FE)
                                ; $00FE LOFROM store current address for most routines the from address in save move
        bne     LFEFF
        inc     $FF
LFEFF:  rts

RESET:  cld                     ; $FF00 RESET start of BREAK/RESET routine.
        ldx     #$28
        txs
        jsr     RSACIA
        jsr     LFE40
        jsr     SCNCLR
        jsr     CURHOM
LFF10:  lda     LFCEA,y
        jsr     OUTVEC
        iny
        cpy     #$16
        bne     LFF10
        jsr     INVEC           ; Input vector
        and     #$DF
        cmp     #'D'
        bne     LFF27
        jmp     DISK
LFF27:  cmp     #$4D
        bne     LFF2E
        jmp     NEWMON
LFF2E:  cmp     #$57
        bne     LFF35
        jmp     L0000
LFF35:  cmp     #$43
        bne     RESET
        .byte   $4C
        .byte   $11
LFF3B:  .byte   $BD
        .byte   "P;/ ZAQ,MNBVCXKJHGFDSIUYTREW"
        .byte $00, $00, $0D, $0A, 'O'
        jmp     L002E
        .byte   "_-:0987654321"
LFF6D:  jsr     SCOUT
LFF70:  ldx     #$00
        stx     $0200           ; $0200 CURDIS cursor displacement on current line
LFF75:  ldx     $0200           ; $0200 CURDIS cursor displacement on current line
        lda     #$BD
        sta     L022A
        jsr     L022A
        sta     $0201           ; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor
        lda     #$9D
        sta     L022A
LFF88:  lda     #$5F
        bne     LFF8F
SCOUT:  lda     $0201           ; SCOUT - print chr at cursor location
                                ; $0201 OLDCHR stores current character during SCREEN; exits containing char beneath the cursor
LFF8F:  ldx     $0200           ; $0200 CURDIS cursor displacement on current line
        jmp     L022A
        jsr     LBF2D
        jmp     LFF9E
        jsr     SCREEN          ; $F836 is SCREEN - new screen handler
LFF9E:  pha
        lda     $0205           ; $0205 SVFLAG BASIC save flag 0=skip save, 1=enable save to ACIA
        beq     LFFBB
        pla
        jsr     TAPOUT
        cmp     #$0D
        bne     LFFBC
LFFAC:  pha
        txa
        pha
        ldx     #$0A
        lda     #$00
LFFB3:  jsr     TAPOUT
        dex
        bne     LFFB3
        pla
        tax
LFFBB:  pla
LFFBC:  rts

TRIQAD: jsr     TWOQAD          ; $FFBD - TRIQAD - Collect three address, first stored in (FE) pair, second in (F9), and third in (E4)
        jsr     LFBE0
        ldx     #$03
        jsr     LF9B1
        lda     $FC
        ldx     L00FD
        sta     $E4             ; Break table K register - stack pointer
        stx     $E5             ; Break table PCL - low byte of program counter
        rts

CURHOM: ldx     #$02            ; CURHOM - resets TEXT line pointer to TOP - do STX $0200 to reset cursor at top
LFFD3:  lda     $0222,x
        sta     L0227,x
        sta     L022A,x
        dex
        bne     LFFD3
        rts

        eor     $012F           ; This looks like a wrong disassembly
LFFE3:  lda     #$2E
        jsr     OUTVEC
        jmp     QDDATD
INVEC:  jmp     (L0218)         ; $FFEB = INVEC - normally points to INPUT $FB46
OUTVEC: jmp     (L021A)         ; $FFEE = OUTVEC - normally points to OUTPUT $FF9B
CCVEC:  jmp     (L021C)         ; $FFF1 = CCVEC - normally points to CTRLC $FB94
LDVEC:  jmp     (L021E)         ; $FFF4 = LDVEC - normally points to SETLOD $FE70
SVVEC:  jmp     (L0220)         ; $FFF7 = SVVEC - normally points to SETSAV $FE7B
        .word   $0237           ; NMI vector
        .word   RESET           ; Reset vector
        .word   $0235           ; BRK/IRQ vector
