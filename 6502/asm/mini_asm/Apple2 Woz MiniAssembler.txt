http://www.strotmann.de/twiki/bin/view/APG/AsmMiniAssembler 31 October 2004 Apple II Mini-Assembler The attached listing is a relocated version of the mini-assembler for the Apple II+ with instructions for the Apple II version. This version can be BRUN from the disk or BLOADed and start with CALL 2048 from Applesoft. To restart use CAll 2051. From machine language the start is 800G and the restart is 803G. Users who have Integer Basic available need only enter that language and use the instructions in part one of this note. Please note that the mini-assembler performs a NEW command, so it will wipe out any resident Applesoft program. Also note that the mini-assembler loads from $800 to $947. Don't try to assemble anything into those locations. This note covers the operation of the mini-assembler only. It is not a course in assembly language programming. For a reference on programming the 6502 microprocessor, refer to the Synertek Programming manual or any of the tutorials available. This note assumes the user has a working knowledge of 6502 programming and mnemonics. The mini-assembler is a programming aid aimed at reducing the amount of time required to convert a handwritten program to object code. The mini-assembler is basically a look-up table for opcodes. With it, you can type mnemonics with their absolute addresses, and the assembler will convert it to the correct object code and store it in memory. Typing "F666G" puts the user in mini-assembler mode. While in this mode, any line typed in will be interpreted as an assembly language instruction, assembled, and stored in binary form unless the first character on the command line is a "$". If the first character of a command line is a "$", the remainder of the line will be interpreted as a normal monitor command, executed, and control returned to the mini-assembler. To get out of the mini-assembler, press RESET. If the first character on the line is blank, the assembled instruction will be stored starting at the address immediately following the previously assembled instruction. If the first character is not a blank nor a "$", the line is assumed to contain an assembly language instruction preceded by the instruction address (a hex number followed by a ":"). In either case, the instruction will be retyped over the line just entered in dis-assembler format to provide a visual check of what has been assembled. The counter that keeps track of where the next instruction will be stored is the pseudo PC (Program Counter) and it can be changed by many monitor commands (eg. 'L', 'T', . . .). Therefore, it is advisable to use the explicit instruction address mode after every monitor command and, of course, when the mini-assembler is first entered. Errors (unrecognized mnemonic, illegal format, etc.) are signalled by a "beep" and a caret ("^") will be printed beneath the last character read from the input line by the mini-assembler. The mnemonics and formats accepted by the mini assembler are the same as those listed by the 6502 Programmers Manual, with the following exceptions and differences: 1. All imbedded blanks are ignored, except inside addresses. 2. All addresses typed in are assumed to be in hex (rather than decimal or symbolic). A preceding "$" (indicating hex rather than decimal or symbolic) is therefore optional, except that it should not precede the instruction address). 3. Instructions that operate on the accumulator have a blank operand field instead of "A". 4. When entering a branch instruction, the argument of the branch mnemonic should be the address of the target of the branch. If the destination address is not known at the time the instruction is entered, simply enter an address that is in the neighborhood, and later re-enter the branch instruction with the correct target address. NOTE: If a branch target is specified that is out of range, the mini-assembler will flag the address as being in error. 5. The operand field of an instruction can only be followed by a comment field, which starts with a semicolon (";"). Obviously, the mini-assembler ignores the field and in fact will type over it when the line is typed over in disassembler format. 6. Any page zero references will generate page zero instruction formats if such a mode exists. There is no way to force a page zero address to be two bytes, even if the address has leading zeroes. In general, to specify an addressing type, simply enter it as it would be listed in the disassembly. For information on the disassembler, see page 49 of the Apple II Reference Manual. 1 *********************** 2 * * 3 * APPLE-II * 4 * MINI-ASSEMBLER * 5 * * 6 * COPYRIGHT 1977 BY * 7 * APPLE COMPUTER INC. * 8 * * 9 * ALL RIGHTS RESERVED * 10 * * 11 * S. WOZNIAK * 12 * A. BAUM * 13 *********************** 14 ; TITLE "APPLE-II MINI-ASSEMBLER" 15 FORMAT EQU $2E 16 LENGTH EQU $2F 17 MODE EQU $31 18 PROMPT EQU $33 19 YSAV EQU $34 20 L EQU $35 21 PCL EQU $3A 22 PCH EQU $3B 23 A1H EQU $3D 24 A2L EQU $3E 25 A2H EQU $3F 26 A4L EQU $42 27 A4H EQU $43 28 FMT EQU $44 29 IN EQU $200 30 INSDS2 EQU $F88E INSTDSP EQU PRBL2 EQU PCADJ EQU CHAR1 EQU CHAR2 EQU MNEML EQU MNEMR EQU CURSUP EQU GETLNZ EQU COUT EQU BL1 EQU A1PCLP EQU BELL EQU GETNUM EQU TOSUB EQU ZMODE EQU CHRTBL EQU ORG F500: E9 81 REL SBC F502: 4A LSR F503: D0 14 BNE F505: A4 3F LDY F507: A6 3E LDX F509: D0 01 BNE F50B: 88 DEY F50C: CA REL2 DEX F50D: 8A TXA F50E: 18 CLC F50F: E5 3A SBC F511: 85 3E STA F513: 10 01 BPL F515: C8 INY F516: 98 REL3 TYA F517: E5 3B SBC F519: D0 6B ERR3 BNE F51B: A4 2F FINDOP LDY F51D: B9 3D 00 FNDOP2 LDA F520: 91 3A STA F522: 88 DEY F523: 10 F8 BPL F525: 20 1A FC JSR F528: 20 1A FC JSR F52B: 20 D0 F8 JSR F52E: 20 53 F9 JSR F531: 84 3B STY F533: 85 3A STA F535: 4C 95 F5 JMP F538: 20 BE FF FAKEMON3 JSR F53B: A4 34 LDY F53D: 20 A7 FF FAKEMON JSR F540: 84 34 STY F542: A0 17 LDY F544: 88 FAKEMON2 DEY F545: 30 4B BMI F547: D9 CC FF CMP F54A: D0 F8 BNE F54C: C0 15 CPY F54E: D0 E8 BNE F550: A5 31 LDA F552: A0 00 LDY F554: C6 34 DEC F556: 20 00 FE JSR F559: 4C 95 F5 JMP F55C: A5 3D TRYNEXT LDA $F8D0 $F94A $F953 $F9B4 $F9BA $F9C0 $FA00 $FC1A $FD67 $FDED $FE00 $FE78 $FF3A $FFA7 $FFBE $FFC7 $FFCC $F500 #$81 ERR3 A2H A2L REL2 PCL A2L REL3 PCH ERR LENGTH A1H,Y (PCL),Y FNDOP2 CURSUP CURSUP INSTDSP PCADJ PCH PCL NXTLINE TOSUB YSAV GETNUM YSAV #$17 RESETZ CHRTBL,Y FAKEMON2 #$15 FAKEMON3 MODE #$0 YSAV BL1 NXTLINE A1H ;IS FMT COMPATIBLE ;WITH RELATIVE MODE? ; NO. ;DOUBLE DECREMENT ;FORM ADDR-PC-2 ;ERROR IF >1-BYTE BRANCH ;MOVE INST TO (PC) ;RESTORE CURSOR ;TYPE FORMATTED LINE ;UPDATE PC ;GET NEXT LINE ;GO TO DELIM HANDLER ;RESTORE Y-INDEX ;READ PARAM ;SAVE Y-INDEX ;INIT DELIMITER INDEX ;CHECK NEXT DELIM ;ERR IF UNRECOGNIZED DELIM ;COMPARE WITH DELIM TABLE ;NO MATCH ;MATCH, IS IT CR? ;NO, HANDLE IT IN MONITOR ;HANDLE CR OUTSIDE MONITOR ;GET TRIAL OPCODE F55E: 20 8E F8 JSR INSDS2 ;GET FMT+LENGTH FOR OPCODE F561: AA TAX F562: BD 00 FA LDA MNEMR,X ;GET LOWER MNEMONIC BYTE F565: C5 42 CMP A4L ;MATCH? F567: D0 13 BNE NEXTOP ;NO, TRY NEXT OPCODE. F569: BD C0 F9 LDA MNEML,X ;GET UPPER MNEMONIC BYTE F56C: C5 43 CMP A4H ;MATCH? F56E: D0 0C BNE NEXTOP ;NO, TRY NEXT OPCODE F570: A5 44 LDA FMT F572: A4 2E LDY FORMAT ;GET TRIAL FORMAT F574: C0 9D CPY #$9D ;TRIAL FORMAT RELATIVE? F576: F0 88 BEQ REL ;YES. F578: C5 2E NREL CMP FORMAT ;SAME FORMAT? F57A: F0 9F BEQ FINDOP ;YES. F57C: C6 3D NEXTOP DEC A1H ;NO, TRY NEXT OPCODE F57E: D0 DC BNE TRYNEXT F580: E6 44 INC FMT ;NO MORE, TRY WITH LEN=2 F582: C6 35 DEC L ;WAS L=2 ALREADY? F584: F0 D6 BEQ TRYNEXT ;NO. F586: A4 34 ERR LDY YSAV ;YES, UNRECOGNIZED INST. F588: 98 ERR2 TYA F589: AA TAX F58A: 20 4A F9 JSR PRBL2 ;PRINT ^ UNDER LAST READ F58D: A9 DE LDA #$DE ;CHAR TO INDICATE ERROR F58F: 20 ED FD JSR COUT ;POSITION. F592: 20 3A FF RESETZ JSR BELL F595: A9 A1 NXTLINE LDA #$A1 ;'!' F597: 85 33 STA PROMPT ;INITIALIZE PROMPT F599: 20 67 FD JSR GETLNZ ;GET LINE. F59C: 20 C7 FF JSR ZMODE ;INIT SCREEN STUFF F59F: AD 00 02 LDA IN ;GET CHAR F5A2: C9 A0 CMP #$A0 ;ASCII BLANK? F5A4: F0 13 BEQ SPACE ;YES F5A6: C8 INY F5A7: C9 A4 CMP #$A4 ;ASCII '$' IN COL 1? F5A9: F0 92 BEQ FAKEMON ;YES, SIMULATE MONITOR F5AB: 88 DEY ;NO, BACKUP A CHAR F5AC: 20 A7 FF JSR GETNUM ;GET A NUMBER F5AF: C9 93 CMP #$93 ;':' TERMINATOR? F5B1: D0 D5 ERR4 BNE ERR2 ;NO, ERR. F5B3: 8A TXA F5B4: F0 D2 BEQ ERR2 ;NO ADR PRECEDING COLON. F5B6: 20 78 FE JSR A1PCLP ;MOVE ADR TO PCL, PCH. F5B9: A9 03 SPACE LDA #$3 ;COUNT OF CHARS IN MNEMONIC F5BB: 85 3D STA A1H F5BD: 20 34 F6 NXTMN JSR GETNSP ;GET FIRST MNEM CHAR. F5C0: 0A NXTM ASL F5C1: E9 BE SBC #$BE ;SUBTRACT OFFSET F5C3: C9 C2 CMP #$C2 ;LEGAL CHAR? F5C5: 90 C1 BCC ERR2 ;NO. F5C7: 0A ASL ;COMPRESS-LEFT JUSTIFY F5C8: 0A ASL F5C9: A2 04 LDX #$4 F5CB: 0A NXTM2 ASL ;DO 5 TRIPLE WORD SHIFTS F5CC: 26 42 ROL A4L F5CE: 26 43 ROL A4H F5D0: CA DEX F5D1: 10 F8 BPL NXTM2 F5D3: C6 3D DEC A1H ;DONE WITH 3 CHARS? F5D5: F0 F4 BEQ NXTM2 ;YES, BUT DO 1 MORE SHIFT F5D7: 10 E4 BPL NXTMN ;NO F5D9: A2 05 FORM1 LDX #$5 ;5 CHARS IN ADDR MODE F5DB: 20 34 F6 FORM2 JSR GETNSP ;GET FIRST CHAR OF ADDR F5DE: 84 34 STY YSAV F5E0: DD B4 F9 CMP CHAR1,X ;FIRST CHAR MATCH PATTERN? F5E3: D0 13 BNE FORM3 ;NO F5E5: 20 34 F6 JSR GETNSP ;YES, GET SECOND CHAR F5E8: DD BA F9 CMP CHAR2,X ;MATCHES SECOND HALF? F5EB: F0 0D BEQ FORM5 ;YES. F5ED: BD BA F9 LDA CHAR2,X ;NO, IS SECOND HALF ZERO? F5F0: F0 07 BEQ FORM4 ;YES. F5F2: C9 A4 CMP #$A4 ;NO,SECOND HALF OPTIONAL? F5F4: F0 03 BEQ FORM4 ;YES. F5F6: A4 34 LDY YSAV F5F8: 18 FORM3 CLC ;CLEAR BIT-NO MATCH F5F9: 88 FORM4 DEY ;BACK UP 1 CHAR F5FA: 26 44 FORM5 ROL FMT ;FORM FORMAT BYTE F5FC: E0 03 CPX #$3 ;TIME TO CHECK FOR ADDR. F5FE: D0 0D BNE FORM7 ;NO F600: 20 A7 FF JSR GETNUM ;YES F603: A5 3F LDA A2H F605: F0 01 BEQ FORM6 ;HIGH-ORDER BYTE ZERO F607: E8 INX ;NO, INCR FOR 2-BYTE F608: 86 35 FORM6 STX L ;STORE LENGTH F60A: A2 03 LDX #$3 ;RELOAD FORMAT INDEX F60C: 88 DEY ;BACKUP A CHAR F60D: 86 3D FORM7 STX A1H ;SAVE INDEX F60F: CA DEX ;DONE WITH FORMAT CHECK? F610: 10 C9 BPL FORM2 ;NO. F612: A5 44 LDA FMT ;YES, PUT LENGTH F614: 0A ASL ;IN LOW BITS F615: 0A ASL F616: 05 35 ORA L F618: C9 20 CMP #$20 F61A: B0 06 BCS FORM8 ;ADD "$" IF NONZERO LENGTH F61C: A6 35 LDX L ;AND DON'T ALREADY HAVE IT F61E: F0 02 BEQ FORM8 F620: 09 80 ORA #$80 F622: 85 44 FORM8 STA FMT F624: 84 34 STY YSAV F626: B9 00 02 LDA IN,Y ;GET NEXT NONBLANK F629: C9 BB CMP #$BB ;';' START OF COMMENT? F62B: F0 04 BEQ FORM9 ;YES F62D: C9 8D CMP #$8D ;CARRIAGE RETURN? F62F: D0 80 BNE ERR4 ;NO, ERR. F631: 4C 5C F5 FORM9 JMP TRYNEXT F634: B9 00 02 GETNSP LDA IN,Y F637: C8 INY F638: C9 A0 CMP #$A0 ;GET NEXT NON BLANK CHAR F63A: F0 F8 BEQ GETNSP F63C: 60 RTS ORG $F666 F666: 4C 92 F5 MINIASM JMP RESETZ -- CarstenStrotmann - 26 Mar 2003 