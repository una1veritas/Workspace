;******************************************************************************
;******************************************************************************
;		BIOS21I				VERSION 820505/1200|RACIII/JCM
;------------------------------------------------------------------------------
;				SUPPORTING
;	DRIVE NAME	DENSITY		CONTROLLER	BASE ADDRESS
;	----------	-------		----------	------------
;	A:, B:, C:, D:	DOUBLE		202		78H
;	E:, F:		SINGLE		201		88H
;	I:, J:, K:, L:	HARD DISK	206		68H
;------------------------------------------------------------------------------
;	COPYRIGHT (C) 1978, 1979	|	COPYRIGHT (C) 1982
;	DIGITAL RESEARCH		|	INTEL CORP.
;	BOX 579, PACIFIC GROVE		|	3065 BOWERS AVENUE
;	CALIFORNIA, 93950		|	SANTA CLARA, CALIFORNIA 95051
;******************************************************************************
;	MODIFIED JUN-2024 BY THOMAS EBERHARDT
;	REMOVED IOC SUPPORT, ADDED 206 SUPPORT, SOME CODE SIZE REDUCTION
;	SAVE BOOT CONSOLE AND SETUP READER AND PUNCH
;******************************************************************************


;******************** EQUATES *************************************************

	MACLIB	diskdef.lib

VERS	EQU	22		; CP/M VERSION 2.2
FALSE	EQU	0
TRUE	EQU	NOT FALSE

RELOC	EQU	FALSE

	IF NOT RELOC
MSIZE	EQU	62		; MEMORY SIZE IN KILOBYTES
RAM$TOP	EQU	MSIZE*1024	; TOP ADDRESS+1
BIOS	EQU	RAM$TOP-700H	; BASIC INPUT/OUTPUT SYSTEM
BDOS	EQU	BIOS-0E00H	; BASE OF THE BDOS
CCP	EQU	BDOS-0800H	; THE CONSOLE COMMAND PROCESSOR
	ORG	BIOS
	ENDIF

	IF RELOC
	ORG	0		; OR 0100H FOR REL-1
CCP	EQU	$
BDOS	EQU	CCP+0800H
BIOS	EQU	BDOS+0E00H
MSIZE	EQU	0		; DUMMY FOR SIGN-ON MESSAGE
	ORG	0800H+0E00H	; PLUS ANOTHER 0100H FOR REL-1
	ENDIF


CPML	EQU	BIOS-CCP
NSECTS	EQU	CPML/128	; NUMBER OF SECTORS TO LOAD

CDISK	EQU	0004H		; ADDRESS OF LAST LOGGED DISK ON WARM START
BUFF	EQU	0080H		; DEFAULT BUFFER ADDRESS

IOBYTE	EQU	0003H		; ADDRESS OF IO BYTE FOR MONITOR
RMSK	EQU	11110011B	; MASK FOR READER INPUT
PMSK	EQU	11001111B	; MASK FOR PUNCH OUTPUT
LMSK	EQU	00111111B	; MASK FOR LIST OUTPUT
RPTR	EQU	00000100B	; READER = PTR
PPTP	EQU	00010000B	; PUNCH = PTP
LLPT	EQU	10000000B	; LIST = LPT

INT$CONT$1	EQU	0FDH	; INTERRUPT PRIORITY RESTORE PORT
INT$CONT$0	EQU	0FCH	; INTERRUPT MASK PORT
MON$INT		EQU	0F3H	; INTERRUPT CONTROL PORT
INT$MASK	EQU	0111$1110B	; ENABLE RST 0(WBOOT), RST 7 (MONITOR)

;	MDS MONITOR EQUATES

MON80	EQU	0F800H
RMON80	EQU	0FF0FH		; RESTART MON80 (BOOT ERROR)
CI	EQU	0F803H
CO	EQU	0F809H
CSTS	EQU	0F812H
RI	EQU	0F806H
PO	EQU	0F80CH
LO	EQU	0F80FH

CR	EQU	0DH		; CARRIAGE RETURN
LF	EQU	0AH		; LINE FEED

;*************** DISK EQUATES *************************************************

RETRY	EQU	10		; MAX RETRIES ON DISK I/O BEFORE ERROR
NUM$DISKS	EQU	10	; NUMBER OF DRIVES AVAILABLE

READF	EQU	4H		; READ FUNCTION
WRITF	EQU	6H		; WRITE FUNCTION
IORDY	EQU	4H		; I/O FINISHED MASK

;*************** 202 CONTROLLER EQUATES ***************************************

BASE2	EQU	78H		; BASE OF DISK COMMAND IO PORTS
DSTAT2	EQU	BASE2		; DISK STATUS (INPUT)
RTYPE2	EQU	BASE2+1		; RESULT TYPE (INPUT)
RBYTE2	EQU	BASE2+3		; RESULT BYTE (INPUT)

ILOW2	EQU	BASE2+1		; IOPB LOW ADDRESS (OUTPUT)
IHIGH2	EQU	BASE2+2		; IOPB HIGH ADDRESS (OUTPUT)

;*************** 201 CONTROLLER EQUATES ***************************************

BASE	EQU	88H		; BASE OF DISK COMMAND IO PORTS
DSTAT	EQU	BASE		; DISK STATUS (INPUT)
RTYPE	EQU	BASE+1		; RESULT TYPE (INPUT)
RBYTE	EQU	BASE+3		; RESULT BYTE (INPUT)

ILOW	EQU	BASE+1		; IOPB LOW ADDRESS (OUTPUT)
IHIGH	EQU	BASE+2		; IOPB HIGH ADDRESS (OUTPUT)

;*************** 206 CONTROLLER EQUATES ***************************************

BASE6	EQU	68H		; BASE OF DISK COMMAND IO PORTS
DSTAT6	EQU	BASE6		; DISK STATUS (INPUT)
RTYPE6	EQU	BASE6+1		; RESULT TYPE (INPUT)
RBYTE6	EQU	BASE6+3		; RESULT BYTE (INPUT)

ILOW6	EQU	BASE6+1		; IOPB LOW ADDRESS (OUTPUT)
IHIGH6	EQU	BASE6+2		; IOPB HIGH ADDRESS (OUTPUT)


;******************************************************************************
;		JUMP VECTOR FOR INDIVIUAL ROUTINES
;******************************************************************************

	JMP	BOOT
WBOOTE:	JMP	WBOOT
	JMP	CONSTAT
	JMP	CONIN
	JMP	CONOUT
	JMP	LIST
	JMP	PUNCH
	JMP	READER
	JMP	HOME
	JMP	SELDSK
	JMP	SETTRK
	JMP	SETSEC
	JMP	SETDMA
	JMP	READ
	JMP	WRITE
	JMP	LIST$ST		; LIST STATUS POLL
	JMP	SECT$TRAN	; SECTOR TRANSLATION

;******************************************************************************
;		CODE SECTION
;******************************************************************************

BOOT:	LXI	SP,BUFF+80H	; TEMPORARY STACK POINTER
				; SET UP INTERRUPTS FOR 0 AND 7 ENABLED
	DI
	MVI	A,12H		; GIVE NON-EXISTANT I8259 INTERRUPT CONTROLLER
	OUT	INT$CONT$1	; IT'S INTIALIZATION SEQUENCE
	XRA	A
	OUT	INT$CONT$0	; THIS ACTUALLY ALLOWS PENDING INTERRUPTS
				;  ON TO HAPPEN, BUT INTEL SEZ
				;  DO IT TO IT FOR THE I8259 COMPATIBILITY

	MVI	A,INT$MASK	; RST0 AND RST7 BITS ON
	OUT	INT$CONT$0
	XRA	A
	OUT	MON$INT		; MASK ALL MONITOR BOARD INTERRUPTS

;	PLUG ALL UNUSED INTERRUPT VECTORS WITH RST 7
;	SO UNEXPECTED INTERRUPTS WILL BREAKPOINT TO MDSMON


	LXI	H,00008H	; POINT TO RESTART 1 LOCATION
	MOV	D,H		; KEEP VALUE 8 FOR INCREMENT
	MOV	E,L
	MVI	C,6		; WE WANT TO INIT. SIX RESTARTS
FILL$LOOP:
	MVI	M,0FFH		; PLUG IN A RESTART 7 INSTR.
	DAD	D		; POINT TO NEXT RESTART LOCATION
	DCR	C		; DROP COUNT
	JNZ	FILL$LOOP	; AND ITERATE

	LDA	5		; GET MDSMON'S LOCATION 5 TO SAVE
	STA	HOLD$5		; FOR COMPATIBILITY WITH MDS230

; SET UP INITIAL IOBYTE AND SAVE IT
; LIST = LPT, PUNCH = PTP, READER = PTR, CONSOLE = BOOT CONSOLE
	LXI	H,IOBYTE
	MOV	A,M
	ANI	LMSK AND PMSK AND RMSK
	ORI	LLPT OR PPTP OR RPTR
	MOV	M,A
	STA	IOINIT

	XRA	A		; CLEAR ACCUMULATOR
	STA	CDISK		; SET INITIALLY TO DISK A/USER 0

	LXI	H,SIGNON
	CALL	PRMSG
	JMP	GOCPM		; GO TO CP/M


WBOOT:
	LXI	SP,0100H	; TEMP STACK POINTER
WBOOT0:
	LXI	B,CCP		; SET DMA ADDRESS TO START OF DISK SYSTEM
	CALL	SETDMA

	MVI	C,0		; BOOT FROM DRIVE 0
	CALL	SELDSK
	CALL	HOME

	MVI	C,2		; START READING SECTOR 2
	CALL	SETSEC
;	READ MULTIPLE SECTORS, COUNT NSECTS TO ZERO
;	IF NSECTS EVER GETS LARGER THAN 51 THAN THIS BOOT NEEDS TO
;	BE MODIFIED.
	MVI	A,NSECTS
	STA	ION		; SAVE IN IOPB
	CALL	READ		; DO READ
	ORA	A
	JNZ	WBOOT		; REPEAT IF ERROR
	INR	A		; SET NUMBER OF SECTORS TO 1
	STA	ION		; FOR REST OF WORLD


GOCPM:				; (ENTER HERE FROM COLD START BOOT)

;	SET UP PAGE ZERO JUMPS TO WARM BOOT, BDOS, AND MDSMON BREAKPOINT

	MVI	A,0C3H		; JMP
	STA	0
	LXI	H,WBOOTE
	SHLD	1		; JMP WBOOT AT LOCATION 00
	STA	5
	LXI	H,BDOS+6
	SHLD	6		; JMP BDOS AT LOCATION 5
	STA	7*8		; JMP TO MON80 (MAY HAVE BEEN CHANGED BY DDT)
	LXI	H,RMON80
	SHLD	7*8+1

;	SET I/O BYTE

	LDA	IOINIT		; RESTORE INITIAL IOBYTE
	STA	IOBYTE		; ***

	LDA	CDISK		; LAST LOGGED DISK NUMBER
	MOV	C,A		; SEND TO CCP TO LOG IT IN

	EI
	JMP	CCP

CONIN:
	CALL	CI1
	ANI	7FH
	RET
CI1:
	CALL	MON
	DB	0FFH AND CI
CONOUT:
	CALL	MON
	DB	0FFH AND CO
CONSTAT:
	CALL	MON
	DB	0FFH AND CSTS
LIST:
	CALL	MON
	DB	0FFH AND LO
READER:
	CALL	MON
	DB	0FFH AND RI
PUNCH:
	CALL	MON
	DB	0FFH AND PO
MON:				; PATCH FOR LOC. 5
	LXI	H,00005H	; RESTORE MDS LOC. 5
	LDA	HOLD$5
	MOV	M,A
	XTHL			; FETCH & BUILD MON CALL ADDRESS
	MOV	L,M
	MVI	H,0F8H
	CALL	CALLER		; VECTOR TO APPROPRITIATE MDSMON ENTRY
	POP	H		; RESTORE CP/M'S BDOS VECTOR OPCODE
	MVI	M,0C3H
	RET

CALLER:	PCHL

LIST$ST:			; NOT IMPLEMENTED
	XRA	A
	RET

SELDSK:				; SELECT DISK GIVEN BY REGISTER C
	LXI	H,0000		; FIRST, INSURE GOOD SELECT
	MOV	A,C
	CPI	6		; NO DRIVE G:
	RZ
	CPI	7		; NO DRIVE H:
	RZ
	JC	SELD2
	SUI	2		; SUBTRACT 2 FOR DRIVE >= I:
SELD2:	CPI	NUM$DISKS
	RNC
	LXI	H,SEL$TABLE
	MVI	B,0
	MOV	C,A
	DAD	B
	MOV	A,M
	STA	IOFSV		; SAVE DRIVE ADDRESS
	ANI	0111$0000B	; MASK UNIT NUMBER
	STA	IOF
	MOV	H,B		; GET DRIVE CODE TO [HL]
	MOV	L,C
	DAD	H		; MULTIPLY BY 16
	DAD	H
	DAD	H
	DAD	H
	LXI	D,DPBASE	; AND MAKE ADDRESS OF DRIVE TABLE
	DAD	D
	RET

HOME:				; MOVE TO HOME POSITION
	MVI	C,0
SETTRK:				; SET TRACK ADDRESS GIVEN BY C
	LXI	H,IOT
	MOV	M,C
	RET

SETSEC:				; SET SECTOR NUMBER GIVEN BY C
	LXI	H,IOS
	MOV	M,C
	RET

SETDMA:				; SET DMA ADDRESS GIVEN BY REGS B,C
	MOV	L,C
	MOV	H,B
	SHLD	IOD
	RET

SECT$TRAN:			; TRANSLATE THE SECTOR # IN <C> IF NEEDED
	MOV	H,B		; IN CASE OF NO TRANSLATION
	MOV	L,C
	INX	H
	MOV	A,D		; (TRANTAB) = 0 , AND RETURN
	ORA	E
	RZ
	XCHG			; ELSE, OFFSET TABLE LOGICAL SECTOR
	DAD	B
	MOV	L,M		; THEN FETCH THE PHYSICAL SECTOR
	MVI	H,0
	RET

;******************************************************************************
;		DISK DRIVERS
;******************************************************************************

READ:				; READ NEXT DISK RECORD ( DISK/TRK/SEC/DMA SET)
	MVI	C,READF		; SET TO READ FUNCTION
	JMP	SETFUNC

WRITE:				; DISK WRITE FUNCTION
	MVI	C,WRITF

SETFUNC:
;	SET FUNCTION FOR NEXT I/O (COMMAND IN REG-C)

	LXI	H,IOPB		; IO PARAMETER BLOCK ADDRESS
	MVI	A,80H		; INITIALIZE IOPB
	MOV	M,A		;	*
	INX	H		; MOVE TO IO FUNCTION
	MOV	A,M		; GET IT TO ACCUMULATOR FOR MASKING
	ANI	1111$0000B	; REMOVE PREVIOUS COMMAND
	ORA	C		; SET TO NEW COMMAND
	MOV	M,A		; REPLACE IO FUNCTION IN IOPB
	MOV	B,A		; SAVE IN B

	MVI	C,RETRY		; MAX RETRIES BEFORE PERM ERROR

	LDA	IOFSV		; CHOOSE WHICH DRIVER CODE TO USE
	RAR			; TEST IF 201 SELECTED
	JC	RDWR2		; YES - USE 201 DRIVER
	RAR			; TEST IF 206 SELECTED
	JC	RDWR6		; YES - USE 206 DRIVER
	JMP	RDWR2		; IF NONE OF THE ABOVE - USE 202 DRIVER

;*************** 202 CONTROLLER DRIVER CODE ***********************************

RDWR2:

REWAIT2:
;	START THE I/O FUNCTION AND WAIT FOR COMPLETION
	IN	RTYPE2		; IN RTYPE
	IN	RBYTE2		; CLEARS THE CONTROLLER

	MVI	A,IOPB AND 0FFH	; LOW ADDRESS FOR IOPB
	OUT	ILOW2		; LOW ADDRESS TO CONTROLLER
	MVI	A,IOPB SHR 8	; HIGH ADDRESS FOR IOPB
	OUT	IHIGH2		; HIGH ADDRESS

WAIT02:	IN	DSTAT2		; WAIT FOR COMPLETION
	ANI	IORDY		; READY?
	JZ	WAIT02

;	CHECK IO COMPLETION OK
	IN	RTYPE2		; MUST BE IO COMPLETE (00) UNLINKED
;	00 UNLINKED I/O COMPLETE,    01 LINKED I/O COMPLETE (NOT USED)
;	10 DISK STATUS CHANGED       11 (NOT USED)

	CPI	10B		; READY STATUS CHANGE?
	JZ	WREADY2

;	MUST BE 00 IN THE ACCUMULATOR
	ORA	A
	JNZ	WERROR2		; SOME OTHER CONDITION, RETRY

;	CHECK I/O ERROR BITS
	IN	RBYTE2
	RAL
	JC	WREADY2		; UNIT NOT READY
	RAR
	ANI	11111110B	; ANY OTHER ERRORS?  (DELETED DATA OK)
	JNZ	WERROR2

;	READ OR WRITE IS OK, ACCUMULATOR CONTAINS ZERO
	RET

WREADY2:				; NOT READY, TREAT AS ERROR FOR NOW
	IN	RBYTE2		; CLEAR RESULT BYTE
	JMP	TRYCOUNT2

WERROR2:			; RETURN MALFUNCTION (CRC, TRACK, SEEK, ETC.)
;	THE MDS CONTROLLER HAS RETURNED A BIT IN EACH POSITION
;	OF THE ACCUMULATOR, CORRESPONDING TO THE CONDITIONS:
;	0	- DELETED DATA (ACCEPTED AS OK ABOVE)
;	1	- CRC ERROR
;	2	- SEEK ERROR
;	3	- ADDRESS ERROR (HARDWARE MALFUNCTION)
;	4	- DATA OVER/UNDER FLOW (HARDWARE MALFUNCTION)
;	5	- WRITE PROTECT (TREATED AS NOT READY)
;	6	- WRITE ERROR (HARDWARE MALFUNCTION)
;	7	- NOT READY
;	(ACCUMULATOR BITS ARE NUMBERED 7 6 5 4 3 2 1 0)

TRYCOUNT2:
;	REGISTER C CONTAINS RETRY COUNT, DECREMENT 'TIL ZERO
	DCR	C
	JNZ	REWAIT2		; FOR ANOTHER TRY

;	CANNOT RECOVER FROM ERROR
	MVI	A,1		; ERROR CODE
	RET
;*************** END 202 CODE ***

;*************** 201 CONTROLLER DRIVER ****************************************

RDWR:
;	SINGLE DENSITY DRIVE 1 REQUIRES BIT 5 ON IN SECTOR #
;	MASK THE BIT FROM THE CURRENT I/O FUNCTION
	MOV	A,B		; LOAD IO FUNCTION FROM B
	ANI	0010$0000B	; MASK THE DISK SELECT BIT
	INX	H		; MOVE TO SECTOR ADDRESS
	INX	H
	INX	H
	ORA	M		; SELECT PROPER DISK BANK
	MOV	M,A		; SET DISK SELECT BIT ON/OFF

REWAIT:
;	START THE I/O FUNCTION AND WAIT FOR COMPLETION
	IN	RTYPE		; IN RTYPE
	IN	RBYTE		; CLEARS THE CONTROLLER

	MVI	A,IOPB AND 0FFH	; LOW ADDRESS FOR IOPB
	OUT	ILOW		; LOW ADDRESS TO CONTROLLER
	MVI	A,IOPB SHR 8	; HIGH ADDRESS FOR IOPB
	OUT	IHIGH		; HIGH ADDRESS

WAIT0:	IN	DSTAT		; WAIT FOR COMPLETION
	ANI	IORDY		; READY?
	JZ	WAIT0

;	CHECK IO COMPLETION OK
	IN	RTYPE		; MUST BE IO COMPLETE (00) UNLINKED
;	00 UNLINKED I/O COMPLETE,    01 LINKED I/O COMPLETE (NOT USED)
;	10 DISK STATUS CHANGED       11 (NOT USED)
	CPI	10B		; READY STATUS CHANGE?
	JZ	WREADY

;	MUST BE 00 IN THE ACCUMULATOR
	ORA	A
	JNZ	WERROR		; SOME OTHER CONDITION, RETRY

;	CHECK I/O ERROR BITS
	IN	RBYTE
	RAL
	JC	WREADY		; UNIT NOT READY
	RAR
	ANI	11111110B	; ANY OTHER ERRORS?  (DELETED DATA OK)
	JNZ	WERROR

;	READ OR WRITE IS OK, ACCUMULATOR CONTAINS ZERO
	RET

WREADY:				; NOT READY, TREAT AS ERROR FOR NOW
	IN	RBYTE		; CLEAR RESULT BYTE
	JMP	TRYCOUNT

WERROR:				; RETURN MALFUNCTION (CRC, TRACK, SEEK, ETC.)
;	THE MDS CONTROLLER HAS RETURNED A BIT IN EACH POSITION
;	OF THE ACCUMULATOR, CORRESPONDING TO THE CONDITIONS:
;	0	- DELETED DATA (ACCEPTED AS OK ABOVE)
;	1	- CRC ERROR
;	2	- SEEK ERROR
;	3	- ADDRESS ERROR (HARDWARE MALFUNCTION)
;	4	- DATA OVER/UNDER FLOW (HARDWARE MALFUNCTION)
;	5	- WRITE PROTECT (TREATED AS NOT READY)
;	6	- WRITE ERROR (HARDWARE MALFUNCTION)
;	7	- NOT READY
;	(ACCUMULATOR BITS ARE NUMBERED 7 6 5 4 3 2 1 0)

TRYCOUNT:
;	REGISTER C CONTAINS RETRY COUNT, DECREMENT 'TIL ZERO
	DCR	C
	JNZ	REWAIT		; FOR ANOTHER TRY

;	CANNOT RECOVER FROM ERROR
	MVI	A,1		; ERROR CODE
	RET
;*************** END 201 CODE ***

;*************** 206 CONTROLLER DRIVER CODE ***********************************

RDWR6:

;	MAP LOGICAL TRACK/SECTOR TO PHYSICAL (LIKE ISIS II)
MAP6:	INX	H		; MOVE TO TRACK NUMBER
	INX	H
	XRA	A		; DE = IOPB TRACK NUMBER
	MOV	D,A
	MOV	E,M
	INX	H		; MOVE TO SECTOR NUMBER
	MOV	A,M		; A = IOPB SECTOR NUMBER
	XCHG			; DE *= 2
	DAD	H
	XCHG
	CPI	49H		; IF (A >= 73) DE++, A -= 72
	JC	MAP6A
	INX	D
	SUI	48H
MAP6A:	CPI	25H		; IF (A < 37) IOF |= 0000$1000B
	JNC	MAP6B
	MOV	C,A		; SAVE A
	MOV	A,B		; LOAD IO FUNCTION FROM B
	ORI	0000$1000B	; SELECT OTHER HEAD
	MOV	B,A
	JMP	MAP6C
MAP6B:	SUI	24H		; ELSE A -= 36
	MOV	C,A		; SAVE A
MAP6C:	MOV	A,D		; IF (DE > 255) A |= 1000$0000B
	ORA	A
	MOV	A,C		; RESTORE A
	JZ	MAP6D
	ORI	1000$0000B	; TRACK EXTENSION BIT
MAP6D:	MOV	M,A		; IOPB SECTOR NUMBER = A
	DCX	H		; MOVE TO TRACK NUMBER
	MOV	M,E		; IOPB TRACK NUMBER = DE & 0FFH
	DCX	H		; MOVE TO IO FUNCTION
	DCX	H
	MOV	M,B		; REPLACE IO FUNCTION IN IOPB

	MVI	C,RETRY		; MAX RETRIES BEFORE PERM ERROR

REWAIT6:
;	START THE I/O FUNCTION AND WAIT FOR COMPLETION
	IN	RTYPE6		; IN RTYPE
	IN	RBYTE6		; CLEARS THE CONTROLLER

	MVI	A,IOPB AND 0FFH	; LOW ADDRESS FOR IOPB
	OUT	ILOW6		; LOW ADDRESS TO CONTROLLER
	MVI	A,IOPB SHR 8	; HIGH ADDRESS FOR IOPB
	OUT	IHIGH6		; HIGH ADDRESS

WAIT06:	IN	DSTAT6		; WAIT FOR COMPLETION
	ANI	IORDY		; READY?
	JZ	WAIT06

;	CHECK IO COMPLETION OK
	IN	RTYPE6		; MUST BE IO COMPLETE (00) UNLINKED
;	00 I/O COMPLETE,             01 DISK STATUS CHANGED
;	10 (NOT USED)                11 (NOT USED)

	CPI	01B		; READY STATUS CHANGE?
	JZ	WREADY6

;	MUST BE 00 IN THE ACCUMULATOR
	ORA	A
	JNZ	WERROR6		; SOME OTHER CONDITION, RETRY

;	CHECK I/O ERROR BITS
	IN	RBYTE6
	RAL
	JC	WREADY6		; UNIT NOT READY
	RAR
	ANI	11111111B	; ANY OTHER ERRORS?
	JNZ	WERROR6

;	READ OR WRITE IS OK, ACCUMULATOR CONTAINS ZERO
	RET

WREADY6:			; NOT READY, TREAT AS ERROR FOR NOW
	IN	RBYTE6		; CLEAR RESULT BYTE
	JMP	TRYCOUNT6

WERROR6:			; RETURN MALFUNCTION (CRC, TRACK, SEEK, ETC.)
;	THE MDS CONTROLLER HAS RETURNED A BIT IN EACH POSITION
;	OF THE ACCUMULATOR, CORRESPONDING TO THE CONDITIONS:
;	0	- ID FIELD MISCOMPARE
;	1	- CRC ERROR
;	2	- SEEK ERROR
;	3	- ADDRESS ERROR (HARDWARE MALFUNCTION)
;	4	- DATA OVER/UNDER FLOW (HARDWARE MALFUNCTION)
;	5	- WRITE PROTECT (TREATED AS NOT READY)
;	6	- WRITE ERROR (HARDWARE MALFUNCTION)
;	7	- NOT READY
;	(ACCUMULATOR BITS ARE NUMBERED 7 6 5 4 3 2 1 0)

TRYCOUNT6:
;	REGISTER C CONTAINS RETRY COUNT, DECREMENT 'TIL ZERO
	DCR	C
	JNZ	REWAIT6		; FOR ANOTHER TRY

;	CANNOT RECOVER FROM ERROR
	MVI	A,1		; ERROR CODE
	RET
;*************** END 206 CODE ***

;******************************************************************************
;		UTILITY SUBROUTINES

PRMSG:				; PRINT MESSAGE AT H,L TO 0
	MOV	A,M
	ORA	A		; END OF STRING?
	RZ			; YES
	PUSH	H		; NO - PRINT THIS CHARACTER
	MOV	C,A
	CALL	CONOUT
	POP	H
	INX	H
	JMP	PRMSG

;******************************************************************************
;		DATA AREA
;******************************************************************************

SIGNON:				; SIGNON MESSAGE: XXK CP/M VERS X.Y
	DB	CR,LF
	DB	MSIZE/10+'0',MSIZE MOD 10 + '0'
	DB	'K CP/M VERS '
	DB	VERS/10+'0','.',VERS MOD 10+'0',CR,LF
	DB	0		; END OF SIGNON MESSAGE

IOPB:				; IO PARAMETER BLOCK
	DB	80H		; NORMAL I/O OPERATION
IOF:	DB	READF		; IO FUNCTION, INITIAL READ
ION:	DB	1		; NUMBER OF SECTORS TO READ
IOT:	DB	2		; TRACK NUMBER
IOS:	DB	1		; SECTOR NUMBER
IOD:	DW	BUFF		; IO ADDRESS

SEL$TABLE:			; * DRIVE SELECT BITS *
	DB	00H,10H,20H,30H,01H,31H,42H,02H,52H,12H
	DISKS	NUM$DISKS	; GENERATE DRIVE TABLES

	DISKDEF 0,1,52,,2048,243,128,128,2

	DISKDEF	1,0

	DISKDEF	2,0

	DISKDEF	3,0

	DISKDEF 4,1,26,6,1024,243,64,64,2

	DISKDEF	5,4

	DISKDEF 6,1,144,,4096,900,1024,0,0

	DISKDEF	7,6

	DISKDEF	8,6

	DISKDEF	9,6

	ENDEF

IOFSV	DS	1		; SAVE AREA FOR DRIVE ADDRESS
HOLD$5	DS	1
	IF	RELOC		; FORCE OUT LAST ADDRESS FOR RELOCATION
IOINIT	DB	0		; INITIAL IOBYTE
	ELSE
IOINIT	DS	1		; INITIAL IOBYTE
	ENDIF

	END
