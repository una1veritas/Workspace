<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ChibiOS/RT: ChibiOS RTOS libraries</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ChibiOS/RT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ChibiOS RTOS libraries </div>  </div>
</div>
<div class="contents">
<div class="textblock"><center>William Greiman</center> <center>January 12, 2013</center><h2><a class="anchor" id="Intro"></a>
Introduction</h2>
<p>This package contains versions of the ChbiOS/RT RTOS for AVR Arduinos, the Due Arduino, and Teensy 3.0.</p>
<p>Information about Teensy 3.0 can be found here:</p>
<p><a href="http://www.pjrc.com/teensy/">http://www.pjrc.com/teensy/</a></p>
<p>These systems are packaged as the Arduino libraries ChibiOS_ARM and ChibiOS_AVR. In addition the SdFat library for ARM/AVR is included.</p>
<p>SdFat is a FAT16/FAT32 file system for SD cards. More information is available here:</p>
<p><a href="http://code.google.com/p/sdfatlib/">http://code.google.com/p/sdfatlib/</a></p>
<p>And beta versions are here:</p>
<p><a href="http://code.google.com/p/beta-lib/">http://code.google.com/p/beta-lib/</a></p>
<p>The documentation for ChibiOS/RT is located here:</p>
<p><a href="http://www.chibios.org/dokuwiki/doku.php?id=start">http://www.chibios.org/dokuwiki/doku.php?id=start</a></p>
<p>Also please explore the above tabs.</p>
<h2><a class="anchor" id="multithread"></a>
Threadsafe and reentrant functions</h2>
<p>If this is your first exposure to a RTOS you will likely feel some pain.</p>
<p>You may want to start using ChibiOS in cooperative mode. See the chCoop.ino example below. In this mode preemptive context switches are disabled for threads of the same priority.</p>
<p>The normal Arduino environment is single-threaded so code does not need to be reentrant or threadsafe. With a preemptive RTOS, the same resources may be accessed concurrently by several threads.</p>
<p>Many arduino libraries and functions are not reentrant or threadsafe.</p>
<p>To protect resource integrity, code written for multithreaded programs must be reentrant and threadsafe.</p>
<p>Reentrance and thread safety are both related to the way that functions handle resources. Reentrance and thread safety are separate concepts: a function can be either reentrant, threadsafe, both, or neither.</p>
<p>A reentrant function does not hold static data over successive calls, nor does it return a pointer to static data. A reentrant function must not call non-reentrant functions.</p>
<p>A threadsafe function protects shared resources from concurrent access by locks. Only one thread can be executing at a time.</p>
<p>The dynamic memory functions malloc and free are not threadsafe. This means that libraries like String and SD.h are not thread safe since they use malloc/free.</p>
<p>SdFat does not use malloc but is not threadsafe. Notice that I put all access to the SD in the low priority loop thread to avoid problems.</p>
<h2><a class="anchor" id="rtosprobs"></a>
Blocking, deadlocks and priority</h2>
<p>You must not use Arduino delay() in other than the lowest priority task. delay() will block all lower priority threads.</p>
<p>Two of the most common design problems for embedded developers are the deadlock and the priority inversion problem. You should start with very simple designs to avoid these subtle problems.</p>
<h2><a class="anchor" id="errorcodes"></a>
Crash error codes</h2>
<p>I have installed simple exception error handlers for three ISR vectors. If an execution fault causes one of these exception, I blink the pin 13 LED. The codes are:</p>
<p>Hard fault - blink one short flash every two seconds</p>
<p>Bus fault - blink two short flashes every two seconds</p>
<p>Usage fault - blink three short flashes every two seconds</p>
<h2><a class="anchor" id="Examples"></a>
Examples</h2>
<p>There are a number examples in each RTOS library.</p>
<h3><a class="anchor" id="blink_print"></a>
Blink print example</h3>
<p>You should first look at the blink/print example in each library. This example is chBlinkPrint.ino.</p>
<p>Each of the blink/print examples has three threads. A high priority thread blinks an LED, a medium priority thread prints a counter every second, and a low priority thread increments the counter.</p>
<p>The print thread also checks Serial for input. If the input is available, the print thread will display stack usage information for each thread and stop the blink thread.</p>
<p>An interesting experiment is to observe the nonatomic behavior of incrementing count in <a class="el" href="_chibi_o_s___a_v_r_8c.html#afe461d27b9c48d5921c00d521181f12f">loop()</a>.</p>
<p>Comment out noInterrupts() and interrupts() like this:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//  noInterrupts();</span>
  count++;
<span class="comment">//  interrupts();</span>
</pre></div><p>You will then see occasional large counts when the print thread tries to zero count while the <a class="el" href="_chibi_o_s___a_v_r_8c.html#afe461d27b9c48d5921c00d521181f12f">loop()</a> thread is incrementing count.</p>
<h3><a class="anchor" id="context_switch"></a>
Semaphore context switch time</h3>
<p>You need an oscilloscope to run this example. This example is chContextTime.ino.</p>
<p>To run this example, connect the scope to pin 13. You will see two pulses. Measure difference in time between first pulse with no context switch and the second pulse started in ledControl and ended in ledOffTask.</p>
<p>The difference is the time for the semaphore and a context switch.</p>
<h3><a class="anchor" id="coop_schedule"></a>
Cooperative scheduling example</h3>
<p>ChibiOS/RT uses cooperative scheduling when CH_TIME_QUANTUM is set to zero. This disables preemption for threads with equal priority and the round robin becomes cooperative. Note that higher priority threads can still preempt, the kernel is always preemptive.</p>
<p>The chCoop.ino example illustrates this feature.</p>
<p>Note that is is not necessary to protect count or maxDelay in this example since a context switch can not happen while these variables are accessed.</p>
<h3><a class="anchor" id="fifo_logger"></a>
FIFO data logger</h3>
<p>The fast data logger example is chFifoDataLogger.ino. This example require connection to an SD socket.</p>
<p>Two semaphores are used to implement a FIFO for data records. This uncouples the data acquisition task from the SD write task. SD card have unpredictable write latencies that can be over 100 milliseconds.</p>
<p>You need a quality SD card to avoid data overrun errors. Overruns could be avoided by allocating more memory to the buffer queue.</p>
<p>This example logs a counter as dummy data. You can replace this with data from an analog pin or your sensor.</p>
<p>Type any character to terminate the example. Memory usage information will be printed.</p>
<h3><a class="anchor" id="delay_jitter"></a>
Delay jitter time</h3>
<p>The chJitter.ino example delays for one tick and measures the time difference in micros between delay calls.</p>
<p>The min and max times are printed by a lower priority task.</p>
<h3><a class="anchor" id="isr_semaphore"></a>
Task Scheduling from an Interrupt Service Routine</h3>
<p>The chIsrSemaphore.ino example demonstrates how a handler task can be triggered from an ISR by using a binary semaphore.</p>
<h3><a class="anchor" id="liu_leyland"></a>
Liu Leyland Rate Monotonic Scheduling</h3>
<p>This example is an illustration of Rate Monotonic Scheduling from the 1973 Liu and Layland paper.</p>
<p>The chLiuLayland.ino example offers four choices for the set of tasks to run. Choice 1 and 3 require too much CPU time and can't be scheduled. choice 2 and 4 require slightily less CPU time and can be successfully scheduled. This demonstrates cases near the CPU bound derived by Liu and Layland for Rate Monotonic Scheduling.</p>
<p>Rate Monotonic Scheduling for a set of repeating tasks gives higher priority to a task with a smaller period.</p>
<p>Theorem Liu and Layland 1973. Given a preemptive, fixed priority scheduler and a finite set of repeating tasks T = {T1; T2; ...; Tn} with associated periods {p1; p2 ...; pn} and no precedence constraints, if any priority assignment yields a feasible schedule, then the rate monotonic priority assignment yields a feasible schedule.</p>
<p>Liu and Layland also derived a bound on CPU utilization that guarantees there will be a feasible Rate Monotonic Schedule when a set of n tasks have CPU utilization less than the bound.</p>
<p>The Liu Layland bound = 100*n*(2^(1/n) - 1) in percent. For large n this approaches ln(2) or 69.3%. The extra CPU time can be used by lower priority tasks that do not have hard deadlines.</p>
<p>Note that it may be possible to run a given set of tasks with higher CPU utilization, depending on task parameters. The Liu Layland bound works for every set of tasks independent of task parameters.</p>
<h3><a class="anchor" id="mail_pool"></a>
Mail and Memory Pool</h3>
<p>The chMailPool.ino example demonstrates use of a memory pool and mailboxes with two senders and one receiver.</p>
<h3><a class="anchor" id="mutex_print"></a>
Mutex Protecting Serial</h3>
<p>The chMutex.ino example shows how to protect a shared resource. In this case the mutex is used to share Serial between three threads. The mutex prevents print calls from the three threads from being scrambled.</p>
<h3><a class="anchor" id="round_robin"></a>
Round Robin Scheduling</h3>
<p>chRoundRobin.ino is a very simple demonstration of two tasks running in round robin mode.</p>
<h3><a class="anchor" id="counting_Semaphore"></a>
Counting Semaphore</h3>
<p>chSemaphore.ino demonstrates use of a counting semaphore by three tasks. Execution is restrict execution of at most two tasks in one region of code. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Jan 12 2013 13:16:10 for ChibiOS/RT by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
