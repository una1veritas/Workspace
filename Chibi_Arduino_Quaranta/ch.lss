
ch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000008f0  00800100  0000689e  00006932  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000689e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000054d  008009f0  008009f0  00007222  2**0
                  ALLOC
  3 .stab         00000d68  00000000  00000000  00007224  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001fa  00000000  00000000  00007f8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000004e0  00000000  00000000  00008186  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00001068  00000000  00000000  00008666  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000f900  00000000  00000000  000096ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00004055  00000000  00000000  00018fce  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000087ce  00000000  00000000  0001d023  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000012e0  00000000  00000000  000257f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001bd0  00000000  00000000  00026ad4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00004101  00000000  00000000  000286a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000230  00000000  00000000  0002c7a5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 57 00 	jmp	0xae	; 0xae <__ctors_end>
       4:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
       8:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
       c:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      10:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      14:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      18:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      1c:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      20:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      24:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      28:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      2c:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      30:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      34:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      38:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      3c:	0c 94 b4 2e 	jmp	0x5d68	; 0x5d68 <__vector_15>
      40:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      44:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      48:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      4c:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      50:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      54:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      58:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      5c:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      60:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      64:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      68:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      6c:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      70:	0c 94 61 2e 	jmp	0x5cc2	; 0x5cc2 <__vector_28>
      74:	0c 94 27 2e 	jmp	0x5c4e	; 0x5c4e <__vector_29>
      78:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      7c:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      80:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      84:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>
      88:	0c 94 76 00 	jmp	0xec	; 0xec <__bad_interrupt>

0000008c <__c.1776>:
      8c:	45 46 47 65 66 67 00                                EFGefg.

00000093 <__c.1770>:
      93:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

000000a3 <__c.1935>:
      a3:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

000000ae <__ctors_end>:
      ae:	11 24       	eor	r1, r1
      b0:	1f be       	out	0x3f, r1	; 63
      b2:	cf ef       	ldi	r28, 0xFF	; 255
      b4:	d0 e4       	ldi	r29, 0x40	; 64
      b6:	de bf       	out	0x3e, r29	; 62
      b8:	cd bf       	out	0x3d, r28	; 61

000000ba <__do_copy_data>:
      ba:	19 e0       	ldi	r17, 0x09	; 9
      bc:	a0 e0       	ldi	r26, 0x00	; 0
      be:	b1 e0       	ldi	r27, 0x01	; 1
      c0:	ee e9       	ldi	r30, 0x9E	; 158
      c2:	f8 e6       	ldi	r31, 0x68	; 104
      c4:	00 e0       	ldi	r16, 0x00	; 0
      c6:	0b bf       	out	0x3b, r16	; 59
      c8:	02 c0       	rjmp	.+4      	; 0xce <__do_copy_data+0x14>
      ca:	07 90       	elpm	r0, Z+
      cc:	0d 92       	st	X+, r0
      ce:	a0 3f       	cpi	r26, 0xF0	; 240
      d0:	b1 07       	cpc	r27, r17
      d2:	d9 f7       	brne	.-10     	; 0xca <__do_copy_data+0x10>

000000d4 <__do_clear_bss>:
      d4:	1f e0       	ldi	r17, 0x0F	; 15
      d6:	a0 ef       	ldi	r26, 0xF0	; 240
      d8:	b9 e0       	ldi	r27, 0x09	; 9
      da:	01 c0       	rjmp	.+2      	; 0xde <.do_clear_bss_start>

000000dc <.do_clear_bss_loop>:
      dc:	1d 92       	st	X+, r1

000000de <.do_clear_bss_start>:
      de:	ad 33       	cpi	r26, 0x3D	; 61
      e0:	b1 07       	cpc	r27, r17
      e2:	e1 f7       	brne	.-8      	; 0xdc <.do_clear_bss_loop>
      e4:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <main>
      e8:	0c 94 4d 34 	jmp	0x689a	; 0x689a <_exit>

000000ec <__bad_interrupt>:
      ec:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f0 <port_switch>:
#if !defined(__DOXYGEN__)
__attribute__((naked, weak))
#endif
void port_switch(Thread *ntp, Thread *otp) {

  asm volatile ("push    r2");
      f0:	2f 92       	push	r2
  asm volatile ("push    r3");
      f2:	3f 92       	push	r3
  asm volatile ("push    r4");
      f4:	4f 92       	push	r4
  asm volatile ("push    r5");
      f6:	5f 92       	push	r5
  asm volatile ("push    r6");
      f8:	6f 92       	push	r6
  asm volatile ("push    r7");
      fa:	7f 92       	push	r7
  asm volatile ("push    r8");
      fc:	8f 92       	push	r8
  asm volatile ("push    r9");
      fe:	9f 92       	push	r9
  asm volatile ("push    r10");
     100:	af 92       	push	r10
  asm volatile ("push    r11");
     102:	bf 92       	push	r11
  asm volatile ("push    r12");
     104:	cf 92       	push	r12
  asm volatile ("push    r13");
     106:	df 92       	push	r13
  asm volatile ("push    r14");
     108:	ef 92       	push	r14
  asm volatile ("push    r15");
     10a:	ff 92       	push	r15
  asm volatile ("push    r16");
     10c:	0f 93       	push	r16
  asm volatile ("push    r17");
     10e:	1f 93       	push	r17
  asm volatile ("push    r28");
     110:	cf 93       	push	r28
  asm volatile ("push    r29");
     112:	df 93       	push	r29

  asm volatile ("movw    r30, r22");
     114:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
     116:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
     118:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
     11a:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
     11c:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
     11e:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
     120:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
     122:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
     124:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
     126:	0e be       	out	0x3e, r0	; 62

  asm volatile ("pop     r29");
     128:	df 91       	pop	r29
  asm volatile ("pop     r28");
     12a:	cf 91       	pop	r28
  asm volatile ("pop     r17");
     12c:	1f 91       	pop	r17
  asm volatile ("pop     r16");
     12e:	0f 91       	pop	r16
  asm volatile ("pop     r15");
     130:	ff 90       	pop	r15
  asm volatile ("pop     r14");
     132:	ef 90       	pop	r14
  asm volatile ("pop     r13");
     134:	df 90       	pop	r13
  asm volatile ("pop     r12");
     136:	cf 90       	pop	r12
  asm volatile ("pop     r11");
     138:	bf 90       	pop	r11
  asm volatile ("pop     r10");
     13a:	af 90       	pop	r10
  asm volatile ("pop     r9");
     13c:	9f 90       	pop	r9
  asm volatile ("pop     r8");
     13e:	8f 90       	pop	r8
  asm volatile ("pop     r7");
     140:	7f 90       	pop	r7
  asm volatile ("pop     r6");
     142:	6f 90       	pop	r6
  asm volatile ("pop     r5");
     144:	5f 90       	pop	r5
  asm volatile ("pop     r4");
     146:	4f 90       	pop	r4
  asm volatile ("pop     r3");
     148:	3f 90       	pop	r3
  asm volatile ("pop     r2");
     14a:	2f 90       	pop	r2
  asm volatile ("ret");
     14c:	08 95       	ret

0000014e <port_halt>:
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void port_halt(void) {

  port_disable();
     14e:	f8 94       	cli
     150:	ff cf       	rjmp	.-2      	; 0x150 <port_halt+0x2>

00000152 <_port_thread_start>:
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
     152:	78 94       	sei
  asm volatile ("movw    r24, r4");
     154:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
     156:	f1 01       	movw	r30, r2
  asm volatile ("icall");
     158:	09 95       	icall
  asm volatile ("call    chThdExit");
     15a:	0e 94 1f 04 	call	0x83e	; 0x83e <chThdExit>
}
     15e:	08 95       	ret

00000160 <_idle_thread>:
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
     160:	e0 91 fe 0b 	lds	r30, 0x0BFE
     164:	f0 91 ff 0b 	lds	r31, 0x0BFF
     168:	80 e0       	ldi	r24, 0x00	; 0
     16a:	91 e0       	ldi	r25, 0x01	; 1
     16c:	94 87       	std	Z+12, r25	; 0x0c
     16e:	83 87       	std	Z+11, r24	; 0x0b
     170:	ff cf       	rjmp	.-2      	; 0x170 <_idle_thread+0x10>

00000172 <chSysTimerHandlerI>:
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     172:	cf 93       	push	r28
     174:	df 93       	push	r29

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
     176:	e0 91 fe 0b 	lds	r30, 0x0BFE
     17a:	f0 91 ff 0b 	lds	r31, 0x0BFF
     17e:	87 85       	ldd	r24, Z+15	; 0x0f
     180:	88 23       	and	r24, r24
     182:	11 f0       	breq	.+4      	; 0x188 <chSysTimerHandlerI+0x16>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
     184:	81 50       	subi	r24, 0x01	; 1
     186:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
     188:	80 89       	ldd	r24, Z+16	; 0x10
     18a:	91 89       	ldd	r25, Z+17	; 0x11
     18c:	01 96       	adiw	r24, 0x01	; 1
     18e:	91 8b       	std	Z+17, r25	; 0x11
     190:	80 8b       	std	Z+16, r24	; 0x10
#endif
  chVTDoTickI();
     192:	80 91 f1 0b 	lds	r24, 0x0BF1
     196:	90 91 f2 0b 	lds	r25, 0x0BF2
     19a:	01 96       	adiw	r24, 0x01	; 1
     19c:	90 93 f2 0b 	sts	0x0BF2, r25
     1a0:	80 93 f1 0b 	sts	0x0BF1, r24
     1a4:	a0 91 eb 0b 	lds	r26, 0x0BEB
     1a8:	b0 91 ec 0b 	lds	r27, 0x0BEC
     1ac:	8b e0       	ldi	r24, 0x0B	; 11
     1ae:	ab 3e       	cpi	r26, 0xEB	; 235
     1b0:	b8 07       	cpc	r27, r24
     1b2:	71 f1       	breq	.+92     	; 0x210 <chSysTimerHandlerI+0x9e>
     1b4:	14 96       	adiw	r26, 0x04	; 4
     1b6:	8d 91       	ld	r24, X+
     1b8:	9c 91       	ld	r25, X
     1ba:	15 97       	sbiw	r26, 0x05	; 5
     1bc:	01 97       	sbiw	r24, 0x01	; 1
     1be:	15 96       	adiw	r26, 0x05	; 5
     1c0:	9c 93       	st	X, r25
     1c2:	8e 93       	st	-X, r24
     1c4:	14 97       	sbiw	r26, 0x04	; 4
     1c6:	89 2b       	or	r24, r25
     1c8:	19 f5       	brne	.+70     	; 0x210 <chSysTimerHandlerI+0x9e>
     1ca:	cb ee       	ldi	r28, 0xEB	; 235
     1cc:	db e0       	ldi	r29, 0x0B	; 11
     1ce:	16 96       	adiw	r26, 0x06	; 6
     1d0:	2d 91       	ld	r18, X+
     1d2:	3c 91       	ld	r19, X
     1d4:	17 97       	sbiw	r26, 0x07	; 7
     1d6:	17 96       	adiw	r26, 0x07	; 7
     1d8:	1c 92       	st	X, r1
     1da:	1e 92       	st	-X, r1
     1dc:	16 97       	sbiw	r26, 0x06	; 6
     1de:	ed 91       	ld	r30, X+
     1e0:	fc 91       	ld	r31, X
     1e2:	11 97       	sbiw	r26, 0x01	; 1
     1e4:	d3 83       	std	Z+3, r29	; 0x03
     1e6:	c2 83       	std	Z+2, r28	; 0x02
     1e8:	f0 93 ec 0b 	sts	0x0BEC, r31
     1ec:	e0 93 eb 0b 	sts	0x0BEB, r30
     1f0:	18 96       	adiw	r26, 0x08	; 8
     1f2:	8d 91       	ld	r24, X+
     1f4:	9c 91       	ld	r25, X
     1f6:	19 97       	sbiw	r26, 0x09	; 9
     1f8:	f9 01       	movw	r30, r18
     1fa:	09 95       	icall
     1fc:	a0 91 eb 0b 	lds	r26, 0x0BEB
     200:	b0 91 ec 0b 	lds	r27, 0x0BEC
     204:	14 96       	adiw	r26, 0x04	; 4
     206:	8d 91       	ld	r24, X+
     208:	9c 91       	ld	r25, X
     20a:	15 97       	sbiw	r26, 0x05	; 5
     20c:	89 2b       	or	r24, r25
     20e:	f9 f2       	breq	.-66     	; 0x1ce <chSysTimerHandlerI+0x5c>
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
     210:	df 91       	pop	r29
     212:	cf 91       	pop	r28
     214:	08 95       	ret

00000216 <chSysInit>:
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
     216:	0f 93       	push	r16
     218:	1f 93       	push	r17
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
     21a:	0e 94 ce 01 	call	0x39c	; 0x39c <_scheduler_init>
  _vt_init();
     21e:	0e 94 36 01 	call	0x26c	; 0x26c <_vt_init>
#if CH_USE_MEMCORE
  _core_init();
     222:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <_core_init>
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
     226:	80 ef       	ldi	r24, 0xF0	; 240
     228:	99 e0       	ldi	r25, 0x09	; 9
     22a:	60 e4       	ldi	r22, 0x40	; 64
     22c:	0e 94 5f 03 	call	0x6be	; 0x6be <_thread_init>
     230:	fc 01       	movw	r30, r24
     232:	90 93 ff 0b 	sts	0x0BFF, r25
     236:	80 93 fe 0b 	sts	0x0BFE, r24
  currp->p_state = THD_STATE_CURRENT;
     23a:	81 e0       	ldi	r24, 0x01	; 1
     23c:	85 87       	std	Z+13, r24	; 0x0d
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
     23e:	78 94       	sei

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
     240:	e0 91 fe 0b 	lds	r30, 0x0BFE
     244:	f0 91 ff 0b 	lds	r31, 0x0BFF
     248:	85 e0       	ldi	r24, 0x05	; 5
     24a:	91 e0       	ldi	r25, 0x01	; 1
     24c:	94 87       	std	Z+12, r25	; 0x0c
     24e:	83 87       	std	Z+11, r24	; 0x0b

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
     250:	8e e7       	ldi	r24, 0x7E	; 126
     252:	9b e0       	ldi	r25, 0x0B	; 11
     254:	6d e6       	ldi	r22, 0x6D	; 109
     256:	70 e0       	ldi	r23, 0x00	; 0
     258:	41 e0       	ldi	r20, 0x01	; 1
     25a:	20 eb       	ldi	r18, 0xB0	; 176
     25c:	30 e0       	ldi	r19, 0x00	; 0
     25e:	00 e0       	ldi	r16, 0x00	; 0
     260:	10 e0       	ldi	r17, 0x00	; 0
     262:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
     266:	1f 91       	pop	r17
     268:	0f 91       	pop	r16
     26a:	08 95       	ret

0000026c <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
     26c:	8b ee       	ldi	r24, 0xEB	; 235
     26e:	9b e0       	ldi	r25, 0x0B	; 11
     270:	90 93 ee 0b 	sts	0x0BEE, r25
     274:	80 93 ed 0b 	sts	0x0BED, r24
     278:	90 93 ec 0b 	sts	0x0BEC, r25
     27c:	80 93 eb 0b 	sts	0x0BEB, r24
  vtlist.vt_time = (systime_t)-1;
     280:	8f ef       	ldi	r24, 0xFF	; 255
     282:	9f ef       	ldi	r25, 0xFF	; 255
     284:	90 93 f0 0b 	sts	0x0BF0, r25
     288:	80 93 ef 0b 	sts	0x0BEF, r24
  vtlist.vt_systime = 0;
     28c:	10 92 f2 0b 	sts	0x0BF2, r1
     290:	10 92 f1 0b 	sts	0x0BF1, r1
}
     294:	08 95       	ret

00000296 <chVTSetI>:
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
     296:	cf 93       	push	r28
     298:	df 93       	push	r29
     29a:	ec 01       	movw	r28, r24

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
     29c:	39 87       	std	Y+9, r19	; 0x09
     29e:	28 87       	std	Y+8, r18	; 0x08
  vtp->vt_func = vtfunc;
     2a0:	5f 83       	std	Y+7, r21	; 0x07
     2a2:	4e 83       	std	Y+6, r20	; 0x06
  p = vtlist.vt_next;
     2a4:	a0 91 eb 0b 	lds	r26, 0x0BEB
     2a8:	b0 91 ec 0b 	lds	r27, 0x0BEC
  while (p->vt_time < time) {
     2ac:	14 96       	adiw	r26, 0x04	; 4
     2ae:	8d 91       	ld	r24, X+
     2b0:	9c 91       	ld	r25, X
     2b2:	15 97       	sbiw	r26, 0x05	; 5
     2b4:	86 17       	cp	r24, r22
     2b6:	97 07       	cpc	r25, r23
     2b8:	60 f4       	brcc	.+24     	; 0x2d2 <chVTSetI+0x3c>
    time -= p->vt_time;
     2ba:	68 1b       	sub	r22, r24
     2bc:	79 0b       	sbc	r23, r25
    p = p->vt_next;
     2be:	0d 90       	ld	r0, X+
     2c0:	bc 91       	ld	r27, X
     2c2:	a0 2d       	mov	r26, r0
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
     2c4:	14 96       	adiw	r26, 0x04	; 4
     2c6:	8d 91       	ld	r24, X+
     2c8:	9c 91       	ld	r25, X
     2ca:	15 97       	sbiw	r26, 0x05	; 5
     2cc:	86 17       	cp	r24, r22
     2ce:	97 07       	cpc	r25, r23
     2d0:	a0 f3       	brcs	.-24     	; 0x2ba <chVTSetI+0x24>
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
     2d2:	b9 83       	std	Y+1, r27	; 0x01
     2d4:	a8 83       	st	Y, r26
     2d6:	12 96       	adiw	r26, 0x02	; 2
     2d8:	ed 91       	ld	r30, X+
     2da:	fc 91       	ld	r31, X
     2dc:	13 97       	sbiw	r26, 0x03	; 3
     2de:	fb 83       	std	Y+3, r31	; 0x03
     2e0:	ea 83       	std	Y+2, r30	; 0x02
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
     2e2:	13 96       	adiw	r26, 0x03	; 3
     2e4:	dc 93       	st	X, r29
     2e6:	ce 93       	st	-X, r28
     2e8:	12 97       	sbiw	r26, 0x02	; 2
     2ea:	d1 83       	std	Z+1, r29	; 0x01
     2ec:	c0 83       	st	Z, r28
  vtp->vt_time = time;
     2ee:	7d 83       	std	Y+5, r23	; 0x05
     2f0:	6c 83       	std	Y+4, r22	; 0x04
  if (p != (void *)&vtlist)
     2f2:	8b e0       	ldi	r24, 0x0B	; 11
     2f4:	ab 3e       	cpi	r26, 0xEB	; 235
     2f6:	b8 07       	cpc	r27, r24
     2f8:	51 f0       	breq	.+20     	; 0x30e <chVTSetI+0x78>
    p->vt_time -= time;
     2fa:	14 96       	adiw	r26, 0x04	; 4
     2fc:	8d 91       	ld	r24, X+
     2fe:	9c 91       	ld	r25, X
     300:	15 97       	sbiw	r26, 0x05	; 5
     302:	86 1b       	sub	r24, r22
     304:	97 0b       	sbc	r25, r23
     306:	15 96       	adiw	r26, 0x05	; 5
     308:	9c 93       	st	X, r25
     30a:	8e 93       	st	-X, r24
     30c:	14 97       	sbiw	r26, 0x04	; 4
}
     30e:	df 91       	pop	r29
     310:	cf 91       	pop	r28
     312:	08 95       	ret

00000314 <chVTResetI>:
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
     314:	cf 93       	push	r28
     316:	df 93       	push	r29
     318:	ec 01       	movw	r28, r24
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
     31a:	e8 81       	ld	r30, Y
     31c:	f9 81       	ldd	r31, Y+1	; 0x01
     31e:	8b e0       	ldi	r24, 0x0B	; 11
     320:	eb 3e       	cpi	r30, 0xEB	; 235
     322:	f8 07       	cpc	r31, r24
     324:	41 f0       	breq	.+16     	; 0x336 <chVTResetI+0x22>
    vtp->vt_next->vt_time += vtp->vt_time;
     326:	84 81       	ldd	r24, Z+4	; 0x04
     328:	95 81       	ldd	r25, Z+5	; 0x05
     32a:	2c 81       	ldd	r18, Y+4	; 0x04
     32c:	3d 81       	ldd	r19, Y+5	; 0x05
     32e:	82 0f       	add	r24, r18
     330:	93 1f       	adc	r25, r19
     332:	95 83       	std	Z+5, r25	; 0x05
     334:	84 83       	std	Z+4, r24	; 0x04
  vtp->vt_prev->vt_next = vtp->vt_next;
     336:	aa 81       	ldd	r26, Y+2	; 0x02
     338:	bb 81       	ldd	r27, Y+3	; 0x03
     33a:	11 96       	adiw	r26, 0x01	; 1
     33c:	fc 93       	st	X, r31
     33e:	ee 93       	st	-X, r30
  vtp->vt_next->vt_prev = vtp->vt_prev;
     340:	e8 81       	ld	r30, Y
     342:	f9 81       	ldd	r31, Y+1	; 0x01
     344:	b3 83       	std	Z+3, r27	; 0x03
     346:	a2 83       	std	Z+2, r26	; 0x02
  vtp->vt_func = (vtfunc_t)NULL;
     348:	1f 82       	std	Y+7, r1	; 0x07
     34a:	1e 82       	std	Y+6, r1	; 0x06
}
     34c:	df 91       	pop	r29
     34e:	cf 91       	pop	r28
     350:	08 95       	ret

00000352 <chTimeIsWithin>:
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
     352:	20 91 f1 0b 	lds	r18, 0x0BF1
     356:	30 91 f2 0b 	lds	r19, 0x0BF2
  return end > start ? (time >= start) && (time < end) :
     35a:	86 17       	cp	r24, r22
     35c:	97 07       	cpc	r25, r23
     35e:	30 f4       	brcc	.+12     	; 0x36c <chTimeIsWithin+0x1a>
     360:	28 17       	cp	r18, r24
     362:	39 07       	cpc	r19, r25
     364:	48 f4       	brcc	.+18     	; 0x378 <chTimeIsWithin+0x26>
     366:	90 e0       	ldi	r25, 0x00	; 0
                       (time >= start) || (time < end);
}
     368:	89 2f       	mov	r24, r25
     36a:	08 95       	ret
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
     36c:	28 17       	cp	r18, r24
     36e:	39 07       	cpc	r19, r25
     370:	58 f0       	brcs	.+22     	; 0x388 <chTimeIsWithin+0x36>
     372:	91 e0       	ldi	r25, 0x01	; 1
                       (time >= start) || (time < end);
}
     374:	89 2f       	mov	r24, r25
     376:	08 95       	ret
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
     378:	90 e0       	ldi	r25, 0x00	; 0
     37a:	26 17       	cp	r18, r22
     37c:	37 07       	cpc	r19, r23
     37e:	50 f4       	brcc	.+20     	; 0x394 <chTimeIsWithin+0x42>
     380:	81 e0       	ldi	r24, 0x01	; 1
     382:	98 27       	eor	r25, r24
                       (time >= start) || (time < end);
}
     384:	89 2f       	mov	r24, r25
     386:	08 95       	ret
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	26 17       	cp	r18, r22
     38c:	37 07       	cpc	r19, r23
     38e:	88 f3       	brcs	.-30     	; 0x372 <chTimeIsWithin+0x20>
                       (time >= start) || (time < end);
}
     390:	89 2f       	mov	r24, r25
     392:	08 95       	ret
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
     394:	91 e0       	ldi	r25, 0x01	; 1
     396:	81 e0       	ldi	r24, 0x01	; 1
     398:	98 27       	eor	r25, r24
     39a:	f4 cf       	rjmp	.-24     	; 0x384 <chTimeIsWithin+0x32>

0000039c <_scheduler_init>:
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
     39c:	83 ef       	ldi	r24, 0xF3	; 243
     39e:	9b e0       	ldi	r25, 0x0B	; 11
     3a0:	90 93 f6 0b 	sts	0x0BF6, r25
     3a4:	80 93 f5 0b 	sts	0x0BF5, r24
     3a8:	90 93 f4 0b 	sts	0x0BF4, r25
     3ac:	80 93 f3 0b 	sts	0x0BF3, r24
  rlist.r_prio = NOPRIO;
     3b0:	10 92 f7 0b 	sts	0x0BF7, r1
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
     3b4:	90 93 fd 0b 	sts	0x0BFD, r25
     3b8:	80 93 fc 0b 	sts	0x0BFC, r24
     3bc:	90 93 fb 0b 	sts	0x0BFB, r25
     3c0:	80 93 fa 0b 	sts	0x0BFA, r24
#endif
}
     3c4:	08 95       	ret

000003c6 <chSchReadyI>:
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
     3c6:	cf 93       	push	r28
     3c8:	df 93       	push	r29
     3ca:	ec 01       	movw	r28, r24
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     3cc:	1d 86       	std	Y+13, r1	; 0x0d
  cp = (Thread *)&rlist.r_queue;
     3ce:	a3 ef       	ldi	r26, 0xF3	; 243
     3d0:	bb e0       	ldi	r27, 0x0B	; 11
     3d2:	9c 81       	ldd	r25, Y+4	; 0x04
  do {
    cp = cp->p_next;
     3d4:	0d 90       	ld	r0, X+
     3d6:	bc 91       	ld	r27, X
     3d8:	a0 2d       	mov	r26, r0
  } while (cp->p_prio >= tp->p_prio);
     3da:	14 96       	adiw	r26, 0x04	; 4
     3dc:	8c 91       	ld	r24, X
     3de:	14 97       	sbiw	r26, 0x04	; 4
     3e0:	89 17       	cp	r24, r25
     3e2:	c0 f7       	brcc	.-16     	; 0x3d4 <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     3e4:	b9 83       	std	Y+1, r27	; 0x01
     3e6:	a8 83       	st	Y, r26
  tp->p_prev = cp->p_prev;
     3e8:	12 96       	adiw	r26, 0x02	; 2
     3ea:	ed 91       	ld	r30, X+
     3ec:	fc 91       	ld	r31, X
     3ee:	13 97       	sbiw	r26, 0x03	; 3
     3f0:	fb 83       	std	Y+3, r31	; 0x03
     3f2:	ea 83       	std	Y+2, r30	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     3f4:	13 96       	adiw	r26, 0x03	; 3
     3f6:	dc 93       	st	X, r29
     3f8:	ce 93       	st	-X, r28
     3fa:	12 97       	sbiw	r26, 0x02	; 2
     3fc:	d1 83       	std	Z+1, r29	; 0x01
     3fe:	c0 83       	st	Z, r28
  return tp;
}
     400:	ce 01       	movw	r24, r28
     402:	df 91       	pop	r29
     404:	cf 91       	pop	r28
     406:	08 95       	ret

00000408 <wakeup>:

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
     408:	cf 93       	push	r28
     40a:	df 93       	push	r29
  Thread *tp = (Thread *)p;
     40c:	ec 01       	movw	r28, r24

  chSysLockFromIsr();
  switch (tp->p_state) {
     40e:	8d 85       	ldd	r24, Y+13	; 0x0d
     410:	83 30       	cpi	r24, 0x03	; 3
     412:	a9 f0       	breq	.+42     	; 0x43e <wakeup+0x36>
     414:	84 30       	cpi	r24, 0x04	; 4
     416:	70 f0       	brcs	.+28     	; 0x434 <wakeup+0x2c>
     418:	85 30       	cpi	r24, 0x05	; 5
     41a:	b1 f0       	breq	.+44     	; 0x448 <wakeup+0x40>
     41c:	8d 30       	cpi	r24, 0x0D	; 13
     41e:	a1 f0       	breq	.+40     	; 0x448 <wakeup+0x40>
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
     420:	8f ef       	ldi	r24, 0xFF	; 255
     422:	9f ef       	ldi	r25, 0xFF	; 255
     424:	9b 8b       	std	Y+19, r25	; 0x13
     426:	8a 8b       	std	Y+18, r24	; 0x12
  chSchReadyI(tp);
     428:	ce 01       	movw	r24, r28
     42a:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
  chSysUnlockFromIsr();
}
     42e:	df 91       	pop	r29
     430:	cf 91       	pop	r28
     432:	08 95       	ret
 */
static void wakeup(void *p) {
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
  switch (tp->p_state) {
     434:	88 23       	and	r24, r24
     436:	a1 f7       	brne	.-24     	; 0x420 <wakeup+0x18>
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromIsr();
}
     438:	df 91       	pop	r29
     43a:	cf 91       	pop	r28
     43c:	08 95       	ret
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
     43e:	ea 89       	ldd	r30, Y+18	; 0x12
     440:	fb 89       	ldd	r31, Y+19	; 0x13
     442:	84 81       	ldd	r24, Z+4	; 0x04
     444:	8f 5f       	subi	r24, 0xFF	; 255
     446:	84 83       	std	Z+4, r24	; 0x04
     448:	ea 81       	ldd	r30, Y+2	; 0x02
     44a:	fb 81       	ldd	r31, Y+3	; 0x03
     44c:	88 81       	ld	r24, Y
     44e:	99 81       	ldd	r25, Y+1	; 0x01
     450:	91 83       	std	Z+1, r25	; 0x01
     452:	80 83       	st	Z, r24
     454:	a8 81       	ld	r26, Y
     456:	b9 81       	ldd	r27, Y+1	; 0x01
     458:	13 96       	adiw	r26, 0x03	; 3
     45a:	fc 93       	st	X, r31
     45c:	ee 93       	st	-X, r30
     45e:	12 97       	sbiw	r26, 0x02	; 2
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
     460:	8f ef       	ldi	r24, 0xFF	; 255
     462:	9f ef       	ldi	r25, 0xFF	; 255
     464:	9b 8b       	std	Y+19, r25	; 0x13
     466:	8a 8b       	std	Y+18, r24	; 0x12
  chSchReadyI(tp);
     468:	ce 01       	movw	r24, r28
     46a:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
     46e:	df cf       	rjmp	.-66     	; 0x42e <wakeup+0x26>

00000470 <chSchIsPreemptionRequired>:
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_ISPREEMPTIONREQUIRED) || defined(__DOXYGEN__)
bool_t chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&rlist.r_queue);
     470:	e0 91 f3 0b 	lds	r30, 0x0BF3
     474:	f0 91 f4 0b 	lds	r31, 0x0BF4
     478:	24 81       	ldd	r18, Z+4	; 0x04
  tprio_t p2 = currp->p_prio;
     47a:	e0 91 fe 0b 	lds	r30, 0x0BFE
     47e:	f0 91 ff 0b 	lds	r31, 0x0BFF
     482:	94 81       	ldd	r25, Z+4	; 0x04
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
     484:	87 85       	ldd	r24, Z+15	; 0x0f
     486:	88 23       	and	r24, r24
     488:	31 f4       	brne	.+12     	; 0x496 <chSchIsPreemptionRequired+0x26>
     48a:	80 e0       	ldi	r24, 0x00	; 0
     48c:	29 17       	cp	r18, r25
     48e:	08 f4       	brcc	.+2      	; 0x492 <chSchIsPreemptionRequired+0x22>
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
     490:	08 95       	ret
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
     492:	81 e0       	ldi	r24, 0x01	; 1
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
     494:	08 95       	ret
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
     496:	80 e0       	ldi	r24, 0x00	; 0
     498:	92 17       	cp	r25, r18
     49a:	d0 f7       	brcc	.-12     	; 0x490 <chSchIsPreemptionRequired+0x20>
     49c:	81 e0       	ldi	r24, 0x01	; 1
     49e:	08 95       	ret

000004a0 <chSchDoRescheduleAhead>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
     4a0:	cf 93       	push	r28
     4a2:	df 93       	push	r29
  Thread *otp, *cp;

  otp = currp;
     4a4:	20 91 fe 0b 	lds	r18, 0x0BFE
     4a8:	30 91 ff 0b 	lds	r19, 0x0BFF
     4ac:	e0 91 f3 0b 	lds	r30, 0x0BF3
     4b0:	f0 91 f4 0b 	lds	r31, 0x0BF4
     4b4:	a0 81       	ld	r26, Z
     4b6:	b1 81       	ldd	r27, Z+1	; 0x01
     4b8:	b0 93 f4 0b 	sts	0x0BF4, r27
     4bc:	a0 93 f3 0b 	sts	0x0BF3, r26
     4c0:	c3 ef       	ldi	r28, 0xF3	; 243
     4c2:	db e0       	ldi	r29, 0x0B	; 11
     4c4:	13 96       	adiw	r26, 0x03	; 3
     4c6:	dc 93       	st	X, r29
     4c8:	ce 93       	st	-X, r28
     4ca:	12 97       	sbiw	r26, 0x02	; 2
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
     4cc:	f0 93 ff 0b 	sts	0x0BFF, r31
     4d0:	e0 93 fe 0b 	sts	0x0BFE, r30
  currp->p_state = THD_STATE_CURRENT;
     4d4:	81 e0       	ldi	r24, 0x01	; 1
     4d6:	85 87       	std	Z+13, r24	; 0x0d

  otp->p_state = THD_STATE_READY;
     4d8:	d9 01       	movw	r26, r18
     4da:	1d 96       	adiw	r26, 0x0d	; 13
     4dc:	1c 92       	st	X, r1
     4de:	1d 97       	sbiw	r26, 0x0d	; 13
     4e0:	14 96       	adiw	r26, 0x04	; 4
     4e2:	9c 91       	ld	r25, X
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
     4e4:	09 90       	ld	r0, Y+
     4e6:	d8 81       	ld	r29, Y
     4e8:	c0 2d       	mov	r28, r0
  } while (cp->p_prio > otp->p_prio);
     4ea:	8c 81       	ldd	r24, Y+4	; 0x04
     4ec:	98 17       	cp	r25, r24
     4ee:	d0 f3       	brcs	.-12     	; 0x4e4 <chSchDoRescheduleAhead+0x44>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
     4f0:	f9 01       	movw	r30, r18
     4f2:	d1 83       	std	Z+1, r29	; 0x01
     4f4:	c0 83       	st	Z, r28
  otp->p_prev = cp->p_prev;
     4f6:	ea 81       	ldd	r30, Y+2	; 0x02
     4f8:	fb 81       	ldd	r31, Y+3	; 0x03
     4fa:	d9 01       	movw	r26, r18
     4fc:	13 96       	adiw	r26, 0x03	; 3
     4fe:	fc 93       	st	X, r31
     500:	ee 93       	st	-X, r30
     502:	12 97       	sbiw	r26, 0x02	; 2
  otp->p_prev->p_next = cp->p_prev = otp;
     504:	3b 83       	std	Y+3, r19	; 0x03
     506:	2a 83       	std	Y+2, r18	; 0x02
     508:	31 83       	std	Z+1, r19	; 0x01
     50a:	20 83       	st	Z, r18

  chSysSwitch(currp, otp);
     50c:	80 91 fe 0b 	lds	r24, 0x0BFE
     510:	90 91 ff 0b 	lds	r25, 0x0BFF
     514:	b9 01       	movw	r22, r18
     516:	0e 94 78 00 	call	0xf0	; 0xf0 <port_switch>
}
     51a:	df 91       	pop	r29
     51c:	cf 91       	pop	r28
     51e:	08 95       	ret

00000520 <chSchRescheduleS>:
#if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI())
     520:	e0 91 f3 0b 	lds	r30, 0x0BF3
     524:	f0 91 f4 0b 	lds	r31, 0x0BF4
     528:	a0 91 fe 0b 	lds	r26, 0x0BFE
     52c:	b0 91 ff 0b 	lds	r27, 0x0BFF
     530:	94 81       	ldd	r25, Z+4	; 0x04
     532:	14 96       	adiw	r26, 0x04	; 4
     534:	8c 91       	ld	r24, X
     536:	89 17       	cp	r24, r25
     538:	08 f0       	brcs	.+2      	; 0x53c <chSchRescheduleS+0x1c>
     53a:	08 95       	ret
    chSchDoRescheduleAhead();
     53c:	0e 94 50 02 	call	0x4a0	; 0x4a0 <chSchDoRescheduleAhead>
     540:	08 95       	ret

00000542 <chSchDoRescheduleBehind>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
     542:	0f 93       	push	r16
     544:	1f 93       	push	r17
     546:	cf 93       	push	r28
     548:	df 93       	push	r29
  Thread *otp;

  otp = currp;
     54a:	00 91 fe 0b 	lds	r16, 0x0BFE
     54e:	10 91 ff 0b 	lds	r17, 0x0BFF
     552:	e3 ef       	ldi	r30, 0xF3	; 243
     554:	fb e0       	ldi	r31, 0x0B	; 11
     556:	80 81       	ld	r24, Z
     558:	91 81       	ldd	r25, Z+1	; 0x01
     55a:	ec 01       	movw	r28, r24
     55c:	a8 81       	ld	r26, Y
     55e:	b9 81       	ldd	r27, Y+1	; 0x01
     560:	b1 83       	std	Z+1, r27	; 0x01
     562:	a0 83       	st	Z, r26
     564:	13 96       	adiw	r26, 0x03	; 3
     566:	fc 93       	st	X, r31
     568:	ee 93       	st	-X, r30
     56a:	12 97       	sbiw	r26, 0x02	; 2
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
     56c:	90 93 ff 0b 	sts	0x0BFF, r25
     570:	80 93 fe 0b 	sts	0x0BFE, r24
  currp->p_state = THD_STATE_CURRENT;
     574:	21 e0       	ldi	r18, 0x01	; 1
     576:	2d 87       	std	Y+13, r18	; 0x0d
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
     578:	84 e1       	ldi	r24, 0x14	; 20
     57a:	f8 01       	movw	r30, r16
     57c:	87 87       	std	Z+15, r24	; 0x0f
#endif
  chSchReadyI(otp);
     57e:	c8 01       	movw	r24, r16
     580:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
  chSysSwitch(currp, otp);
     584:	80 91 fe 0b 	lds	r24, 0x0BFE
     588:	90 91 ff 0b 	lds	r25, 0x0BFF
     58c:	b8 01       	movw	r22, r16
     58e:	0e 94 78 00 	call	0xf0	; 0xf0 <port_switch>
}
     592:	df 91       	pop	r29
     594:	cf 91       	pop	r28
     596:	1f 91       	pop	r17
     598:	0f 91       	pop	r16
     59a:	08 95       	ret

0000059c <chSchDoReschedule>:
void chSchDoReschedule(void) {

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
     59c:	e0 91 fe 0b 	lds	r30, 0x0BFE
     5a0:	f0 91 ff 0b 	lds	r31, 0x0BFF
     5a4:	87 85       	ldd	r24, Z+15	; 0x0f
     5a6:	88 23       	and	r24, r24
     5a8:	19 f0       	breq	.+6      	; 0x5b0 <chSchDoReschedule+0x14>
    chSchDoRescheduleBehind();
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
     5aa:	0e 94 50 02 	call	0x4a0	; 0x4a0 <chSchDoRescheduleAhead>
     5ae:	08 95       	ret
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
     5b0:	0e 94 a1 02 	call	0x542	; 0x542 <chSchDoRescheduleBehind>
     5b4:	08 95       	ret

000005b6 <chSchWakeupS>:
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
     5b6:	cf 93       	push	r28
     5b8:	df 93       	push	r29
     5ba:	ec 01       	movw	r28, r24

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
     5bc:	7b 8b       	std	Y+19, r23	; 0x13
     5be:	6a 8b       	std	Y+18, r22	; 0x12
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
     5c0:	e0 91 fe 0b 	lds	r30, 0x0BFE
     5c4:	f0 91 ff 0b 	lds	r31, 0x0BFF
     5c8:	9c 81       	ldd	r25, Y+4	; 0x04
     5ca:	84 81       	ldd	r24, Z+4	; 0x04
     5cc:	89 17       	cp	r24, r25
     5ce:	80 f4       	brcc	.+32     	; 0x5f0 <chSchWakeupS+0x3a>
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
     5d0:	cf 01       	movw	r24, r30
     5d2:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
     5d6:	bc 01       	movw	r22, r24
    setcurrp(ntp);
     5d8:	d0 93 ff 0b 	sts	0x0BFF, r29
     5dc:	c0 93 fe 0b 	sts	0x0BFE, r28
    ntp->p_state = THD_STATE_CURRENT;
     5e0:	81 e0       	ldi	r24, 0x01	; 1
     5e2:	8d 87       	std	Y+13, r24	; 0x0d
    chSysSwitch(ntp, otp);
     5e4:	ce 01       	movw	r24, r28
     5e6:	0e 94 78 00 	call	0xf0	; 0xf0 <port_switch>
  }
}
     5ea:	df 91       	pop	r29
     5ec:	cf 91       	pop	r28
     5ee:	08 95       	ret
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
     5f0:	ce 01       	movw	r24, r28
     5f2:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
     5f6:	df 91       	pop	r29
     5f8:	cf 91       	pop	r28
     5fa:	08 95       	ret

000005fc <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
     5fc:	cf 93       	push	r28
     5fe:	df 93       	push	r29
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
     600:	40 91 fe 0b 	lds	r20, 0x0BFE
     604:	50 91 ff 0b 	lds	r21, 0x0BFF
     608:	ea 01       	movw	r28, r20
     60a:	8d 87       	std	Y+13, r24	; 0x0d
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
     60c:	84 e1       	ldi	r24, 0x14	; 20
     60e:	8f 87       	std	Y+15, r24	; 0x0f
     610:	e3 ef       	ldi	r30, 0xF3	; 243
     612:	fb e0       	ldi	r31, 0x0B	; 11
     614:	80 81       	ld	r24, Z
     616:	91 81       	ldd	r25, Z+1	; 0x01
     618:	ec 01       	movw	r28, r24
     61a:	a8 81       	ld	r26, Y
     61c:	b9 81       	ldd	r27, Y+1	; 0x01
     61e:	b1 83       	std	Z+1, r27	; 0x01
     620:	a0 83       	st	Z, r26
     622:	13 96       	adiw	r26, 0x03	; 3
     624:	fc 93       	st	X, r31
     626:	ee 93       	st	-X, r30
     628:	12 97       	sbiw	r26, 0x02	; 2
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
     62a:	90 93 ff 0b 	sts	0x0BFF, r25
     62e:	80 93 fe 0b 	sts	0x0BFE, r24
  currp->p_state = THD_STATE_CURRENT;
     632:	21 e0       	ldi	r18, 0x01	; 1
     634:	2d 87       	std	Y+13, r18	; 0x0d
  chSysSwitch(currp, otp);
     636:	ba 01       	movw	r22, r20
     638:	0e 94 78 00 	call	0xf0	; 0xf0 <port_switch>
}
     63c:	df 91       	pop	r29
     63e:	cf 91       	pop	r28
     640:	08 95       	ret

00000642 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
     642:	ff 92       	push	r15
     644:	0f 93       	push	r16
     646:	1f 93       	push	r17
     648:	df 93       	push	r29
     64a:	cf 93       	push	r28
     64c:	cd b7       	in	r28, 0x3d	; 61
     64e:	de b7       	in	r29, 0x3e	; 62
     650:	2a 97       	sbiw	r28, 0x0a	; 10
     652:	0f b6       	in	r0, 0x3f	; 63
     654:	f8 94       	cli
     656:	de bf       	out	0x3e, r29	; 62
     658:	0f be       	out	0x3f, r0	; 63
     65a:	cd bf       	out	0x3d, r28	; 61
     65c:	f8 2e       	mov	r15, r24

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
     65e:	8f ef       	ldi	r24, 0xFF	; 255
     660:	6f 3f       	cpi	r22, 0xFF	; 255
     662:	78 07       	cpc	r23, r24
     664:	41 f1       	breq	.+80     	; 0x6b6 <chSchGoSleepTimeoutS+0x74>
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
     666:	20 91 fe 0b 	lds	r18, 0x0BFE
     66a:	30 91 ff 0b 	lds	r19, 0x0BFF
     66e:	8e 01       	movw	r16, r28
     670:	0f 5f       	subi	r16, 0xFF	; 255
     672:	1f 4f       	sbci	r17, 0xFF	; 255
     674:	c8 01       	movw	r24, r16
     676:	44 e0       	ldi	r20, 0x04	; 4
     678:	52 e0       	ldi	r21, 0x02	; 2
     67a:	0e 94 4b 01 	call	0x296	; 0x296 <chVTSetI>
    chSchGoSleepS(newstate);
     67e:	8f 2d       	mov	r24, r15
     680:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
     684:	8f 81       	ldd	r24, Y+7	; 0x07
     686:	98 85       	ldd	r25, Y+8	; 0x08
     688:	89 2b       	or	r24, r25
     68a:	19 f0       	breq	.+6      	; 0x692 <chSchGoSleepTimeoutS+0x50>
      chVTResetI(&vt);
     68c:	c8 01       	movw	r24, r16
     68e:	0e 94 8a 01 	call	0x314	; 0x314 <chVTResetI>
  }
  else
    chSchGoSleepS(newstate);
     692:	e0 91 fe 0b 	lds	r30, 0x0BFE
     696:	f0 91 ff 0b 	lds	r31, 0x0BFF
  return currp->p_u.rdymsg;
}
     69a:	82 89       	ldd	r24, Z+18	; 0x12
     69c:	93 89       	ldd	r25, Z+19	; 0x13
     69e:	2a 96       	adiw	r28, 0x0a	; 10
     6a0:	0f b6       	in	r0, 0x3f	; 63
     6a2:	f8 94       	cli
     6a4:	de bf       	out	0x3e, r29	; 62
     6a6:	0f be       	out	0x3f, r0	; 63
     6a8:	cd bf       	out	0x3d, r28	; 61
     6aa:	cf 91       	pop	r28
     6ac:	df 91       	pop	r29
     6ae:	1f 91       	pop	r17
     6b0:	0f 91       	pop	r16
     6b2:	ff 90       	pop	r15
     6b4:	08 95       	ret
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt))
      chVTResetI(&vt);
  }
  else
    chSchGoSleepS(newstate);
     6b6:	8f 2d       	mov	r24, r15
     6b8:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
     6bc:	ea cf       	rjmp	.-44     	; 0x692 <chSchGoSleepTimeoutS+0x50>

000006be <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {
     6be:	fc 01       	movw	r30, r24

  tp->p_prio = prio;
     6c0:	64 83       	std	Z+4, r22	; 0x04
  tp->p_state = THD_STATE_SUSPENDED;
     6c2:	82 e0       	ldi	r24, 0x02	; 2
     6c4:	85 87       	std	Z+13, r24	; 0x0d
  tp->p_flags = THD_MEM_MODE_STATIC;
     6c6:	16 86       	std	Z+14, r1	; 0x0e
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
     6c8:	84 e1       	ldi	r24, 0x14	; 20
     6ca:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
     6cc:	67 8f       	std	Z+31, r22	; 0x1f
  tp->p_mtxlist = NULL;
     6ce:	16 8e       	std	Z+30, r1	; 0x1e
     6d0:	15 8e       	std	Z+29, r1	; 0x1d
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
     6d2:	14 8e       	std	Z+28, r1	; 0x1c
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
     6d4:	11 8a       	std	Z+17, r1	; 0x11
     6d6:	10 8a       	std	Z+16, r1	; 0x10
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
     6d8:	14 86       	std	Z+12, r1	; 0x0c
     6da:	13 86       	std	Z+11, r1	; 0x0b
  REG_INSERT(tp);
     6dc:	83 ef       	ldi	r24, 0xF3	; 243
     6de:	9b e0       	ldi	r25, 0x0B	; 11
     6e0:	90 87       	std	Z+8, r25	; 0x08
     6e2:	87 83       	std	Z+7, r24	; 0x07
     6e4:	a0 91 fc 0b 	lds	r26, 0x0BFC
     6e8:	b0 91 fd 0b 	lds	r27, 0x0BFD
     6ec:	b2 87       	std	Z+10, r27	; 0x0a
     6ee:	a1 87       	std	Z+9, r26	; 0x09
     6f0:	f0 93 fd 0b 	sts	0x0BFD, r31
     6f4:	e0 93 fc 0b 	sts	0x0BFC, r30
     6f8:	18 96       	adiw	r26, 0x08	; 8
     6fa:	fc 93       	st	X, r31
     6fc:	ee 93       	st	-X, r30
     6fe:	17 97       	sbiw	r26, 0x07	; 7
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
     700:	cf 01       	movw	r24, r30
     702:	44 96       	adiw	r24, 0x14	; 20
     704:	95 8b       	std	Z+21, r25	; 0x15
     706:	84 8b       	std	Z+20, r24	; 0x14
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
     708:	cf 01       	movw	r24, r30
     70a:	46 96       	adiw	r24, 0x16	; 22
     70c:	91 8f       	std	Z+25, r25	; 0x19
     70e:	80 8f       	std	Z+24, r24	; 0x18
     710:	97 8b       	std	Z+23, r25	; 0x17
     712:	86 8b       	std	Z+22, r24	; 0x16
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
}
     714:	cf 01       	movw	r24, r30
     716:	08 95       	ret

00000718 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
     718:	0f 93       	push	r16
     71a:	1f 93       	push	r17
     71c:	dc 01       	movw	r26, r24
     71e:	fb 01       	movw	r30, r22
  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
     720:	75 97       	sbiw	r30, 0x15	; 21
     722:	e8 0f       	add	r30, r24
     724:	f9 1f       	adc	r31, r25
     726:	16 96       	adiw	r26, 0x06	; 6
     728:	fc 93       	st	X, r31
     72a:	ee 93       	st	-X, r30
     72c:	15 97       	sbiw	r26, 0x05	; 5
     72e:	c9 01       	movw	r24, r18
     730:	22 8b       	std	Z+18, r18	; 0x12
     732:	15 96       	adiw	r26, 0x05	; 5
     734:	ed 91       	ld	r30, X+
     736:	fc 91       	ld	r31, X
     738:	16 97       	sbiw	r26, 0x06	; 6
     73a:	89 2f       	mov	r24, r25
     73c:	99 0f       	add	r25, r25
     73e:	99 0b       	sbc	r25, r25
     740:	81 8b       	std	Z+17, r24	; 0x11
     742:	15 96       	adiw	r26, 0x05	; 5
     744:	ed 91       	ld	r30, X+
     746:	fc 91       	ld	r31, X
     748:	16 97       	sbiw	r26, 0x06	; 6
     74a:	00 8b       	std	Z+16, r16	; 0x10
     74c:	15 96       	adiw	r26, 0x05	; 5
     74e:	ed 91       	ld	r30, X+
     750:	fc 91       	ld	r31, X
     752:	16 97       	sbiw	r26, 0x06	; 6
     754:	81 2f       	mov	r24, r17
     756:	99 27       	eor	r25, r25
     758:	87 fd       	sbrc	r24, 7
     75a:	9a 95       	dec	r25
     75c:	87 87       	std	Z+15, r24	; 0x0f
     75e:	29 ea       	ldi	r18, 0xA9	; 169
     760:	30 e0       	ldi	r19, 0x00	; 0
     762:	15 96       	adiw	r26, 0x05	; 5
     764:	ed 91       	ld	r30, X+
     766:	fc 91       	ld	r31, X
     768:	16 97       	sbiw	r26, 0x06	; 6
     76a:	83 2f       	mov	r24, r19
     76c:	99 27       	eor	r25, r25
     76e:	87 fd       	sbrc	r24, 7
     770:	9a 95       	dec	r25
     772:	83 8b       	std	Z+19, r24	; 0x13
     774:	15 96       	adiw	r26, 0x05	; 5
     776:	ed 91       	ld	r30, X+
     778:	fc 91       	ld	r31, X
     77a:	16 97       	sbiw	r26, 0x06	; 6
     77c:	24 8b       	std	Z+20, r18	; 0x14
  return _thread_init(tp, prio);
     77e:	cd 01       	movw	r24, r26
     780:	64 2f       	mov	r22, r20
     782:	0e 94 5f 03 	call	0x6be	; 0x6be <_thread_init>
}
     786:	1f 91       	pop	r17
     788:	0f 91       	pop	r16
     78a:	08 95       	ret

0000078c <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(Thread *tp) {
     78c:	fc 01       	movw	r30, r24

  chSysLock();
     78e:	f8 94       	cli
  tp->p_flags |= THD_TERMINATE;
     790:	86 85       	ldd	r24, Z+14	; 0x0e
     792:	84 60       	ori	r24, 0x04	; 4
     794:	86 87       	std	Z+14, r24	; 0x0e
  chSysUnlock();
     796:	78 94       	sei
}
     798:	08 95       	ret

0000079a <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(Thread *tp) {
     79a:	cf 93       	push	r28
     79c:	df 93       	push	r29
     79e:	ec 01       	movw	r28, r24
  msg_t msg;

  chDbgCheck(tp != NULL, "chThdWait");

  chSysLock();
     7a0:	f8 94       	cli
  chDbgAssert(tp != currp, "chThdWait(), #1", "waiting self");
#if CH_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "chThdWait(), #2", "not referenced");
#endif
  if (tp->p_state != THD_STATE_FINAL) {
     7a2:	8d 85       	ldd	r24, Y+13	; 0x0d
     7a4:	8e 30       	cpi	r24, 0x0E	; 14
     7a6:	69 f0       	breq	.+26     	; 0x7c2 <chThdWait+0x28>
    list_insert(currp, &tp->p_waiting);
     7a8:	e0 91 fe 0b 	lds	r30, 0x0BFE
     7ac:	f0 91 ff 0b 	lds	r31, 0x0BFF
     7b0:	8c 89       	ldd	r24, Y+20	; 0x14
     7b2:	9d 89       	ldd	r25, Y+21	; 0x15
     7b4:	91 83       	std	Z+1, r25	; 0x01
     7b6:	80 83       	st	Z, r24
     7b8:	fd 8b       	std	Y+21, r31	; 0x15
     7ba:	ec 8b       	std	Y+20, r30	; 0x14
    chSchGoSleepS(THD_STATE_WTEXIT);
     7bc:	87 e0       	ldi	r24, 0x07	; 7
     7be:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
     7c2:	8a 89       	ldd	r24, Y+18	; 0x12
     7c4:	9b 89       	ldd	r25, Y+19	; 0x13
  chSysUnlock();
     7c6:	78 94       	sei
#if CH_USE_DYNAMIC
  chThdRelease(tp);
#endif
  return msg;
}
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	08 95       	ret

000007ce <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
     7ce:	0f 93       	push	r16
     7d0:	1f 93       	push	r17
     7d2:	cf 93       	push	r28
     7d4:	df 93       	push	r29
  Thread *tp = currp;
     7d6:	c0 91 fe 0b 	lds	r28, 0x0BFE
     7da:	d0 91 ff 0b 	lds	r29, 0x0BFF

  tp->p_u.exitcode = msg;
     7de:	9b 8b       	std	Y+19, r25	; 0x13
     7e0:	8a 8b       	std	Y+18, r24	; 0x12
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
     7e2:	ec 89       	ldd	r30, Y+20	; 0x14
     7e4:	fd 89       	ldd	r31, Y+21	; 0x15
     7e6:	8e 01       	movw	r16, r28
     7e8:	0c 5e       	subi	r16, 0xEC	; 236
     7ea:	1f 4f       	sbci	r17, 0xFF	; 255
     7ec:	e0 17       	cp	r30, r16
     7ee:	f1 07       	cpc	r31, r17
     7f0:	61 f0       	breq	.+24     	; 0x80a <chThdExitS+0x3c>
     7f2:	80 81       	ld	r24, Z
     7f4:	91 81       	ldd	r25, Z+1	; 0x01
     7f6:	9d 8b       	std	Y+21, r25	; 0x15
     7f8:	8c 8b       	std	Y+20, r24	; 0x14
    chSchReadyI(list_remove(&tp->p_waiting));
     7fa:	cf 01       	movw	r24, r30
     7fc:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
     800:	ec 89       	ldd	r30, Y+20	; 0x14
     802:	fd 89       	ldd	r31, Y+21	; 0x15
     804:	e0 17       	cp	r30, r16
     806:	f1 07       	cpc	r31, r17
     808:	a1 f7       	brne	.-24     	; 0x7f2 <chThdExitS+0x24>
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
     80a:	8e 85       	ldd	r24, Y+14	; 0x0e
     80c:	90 e0       	ldi	r25, 0x00	; 0
     80e:	83 70       	andi	r24, 0x03	; 3
     810:	90 70       	andi	r25, 0x00	; 0
     812:	89 2b       	or	r24, r25
     814:	61 f4       	brne	.+24     	; 0x82e <chThdExitS+0x60>
    REG_REMOVE(tp);
     816:	e9 85       	ldd	r30, Y+9	; 0x09
     818:	fa 85       	ldd	r31, Y+10	; 0x0a
     81a:	8f 81       	ldd	r24, Y+7	; 0x07
     81c:	98 85       	ldd	r25, Y+8	; 0x08
     81e:	90 87       	std	Z+8, r25	; 0x08
     820:	87 83       	std	Z+7, r24	; 0x07
     822:	af 81       	ldd	r26, Y+7	; 0x07
     824:	b8 85       	ldd	r27, Y+8	; 0x08
     826:	1a 96       	adiw	r26, 0x0a	; 10
     828:	fc 93       	st	X, r31
     82a:	ee 93       	st	-X, r30
     82c:	19 97       	sbiw	r26, 0x09	; 9
#endif
  chSchGoSleepS(THD_STATE_FINAL);
     82e:	8e e0       	ldi	r24, 0x0E	; 14
     830:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
     834:	df 91       	pop	r29
     836:	cf 91       	pop	r28
     838:	1f 91       	pop	r17
     83a:	0f 91       	pop	r16
     83c:	08 95       	ret

0000083e <chThdExit>:
 *
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
     83e:	f8 94       	cli
  chThdExitS(msg);
     840:	0e 94 e7 03 	call	0x7ce	; 0x7ce <chThdExitS>
  /* The thread never returns here.*/
}
     844:	08 95       	ret

00000846 <chThdYield>:
 *
 * @api
 */
void chThdYield(void) {

  chSysLock();
     846:	f8 94       	cli
  chSchDoYieldS();
     848:	e0 91 f3 0b 	lds	r30, 0x0BF3
     84c:	f0 91 f4 0b 	lds	r31, 0x0BF4
     850:	a0 91 fe 0b 	lds	r26, 0x0BFE
     854:	b0 91 ff 0b 	lds	r27, 0x0BFF
     858:	94 81       	ldd	r25, Z+4	; 0x04
     85a:	14 96       	adiw	r26, 0x04	; 4
     85c:	8c 91       	ld	r24, X
     85e:	98 17       	cp	r25, r24
     860:	10 f0       	brcs	.+4      	; 0x866 <chThdYield+0x20>
     862:	0e 94 a1 02 	call	0x542	; 0x542 <chSchDoRescheduleBehind>
  chSysUnlock();
     866:	78 94       	sei
}
     868:	08 95       	ret

0000086a <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
     86a:	bc 01       	movw	r22, r24

  chSysLock();
     86c:	f8 94       	cli
  if ((time -= chTimeNow()) > 0)
     86e:	80 91 f1 0b 	lds	r24, 0x0BF1
     872:	90 91 f2 0b 	lds	r25, 0x0BF2
     876:	68 1b       	sub	r22, r24
     878:	79 0b       	sbc	r23, r25
     87a:	19 f0       	breq	.+6      	; 0x882 <chThdSleepUntil+0x18>
    chThdSleepS(time);
     87c:	86 e0       	ldi	r24, 0x06	; 6
     87e:	0e 94 21 03 	call	0x642	; 0x642 <chSchGoSleepTimeoutS>
  chSysUnlock();
     882:	78 94       	sei
}
     884:	08 95       	ret

00000886 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
     886:	bc 01       	movw	r22, r24

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
     888:	f8 94       	cli
  chThdSleepS(time);
     88a:	86 e0       	ldi	r24, 0x06	; 6
     88c:	0e 94 21 03 	call	0x642	; 0x642 <chSchGoSleepTimeoutS>
  chSysUnlock();
     890:	78 94       	sei
}
     892:	08 95       	ret

00000894 <chThdResume>:
 * @param[in] tp        pointer to the thread
 * @return              The pointer to the thread.
 *
 * @api
 */
Thread *chThdResume(Thread *tp) {
     894:	0f 93       	push	r16
     896:	1f 93       	push	r17
     898:	18 2f       	mov	r17, r24
     89a:	09 2f       	mov	r16, r25

  chSysLock();
     89c:	f8 94       	cli
  chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
              "chThdResume(), #1",
              "thread not in THD_STATE_SUSPENDED state");
  chSchWakeupS(tp, RDY_OK);
     89e:	60 e0       	ldi	r22, 0x00	; 0
     8a0:	70 e0       	ldi	r23, 0x00	; 0
     8a2:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
  chSysUnlock();
     8a6:	78 94       	sei
  return tp;
}
     8a8:	81 2f       	mov	r24, r17
     8aa:	90 2f       	mov	r25, r16
     8ac:	1f 91       	pop	r17
     8ae:	0f 91       	pop	r16
     8b0:	08 95       	ret

000008b2 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
     8b2:	0f 93       	push	r16
     8b4:	1f 93       	push	r17
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
     8b6:	f8 94       	cli
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
     8b8:	0e 94 8c 03 	call	0x718	; 0x718 <chThdCreateI>
     8bc:	18 2f       	mov	r17, r24
     8be:	09 2f       	mov	r16, r25
     8c0:	60 e0       	ldi	r22, 0x00	; 0
     8c2:	70 e0       	ldi	r23, 0x00	; 0
     8c4:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
  chSysUnlock();
     8c8:	78 94       	sei
  return tp;
}
     8ca:	81 2f       	mov	r24, r17
     8cc:	90 2f       	mov	r25, r16
     8ce:	1f 91       	pop	r17
     8d0:	0f 91       	pop	r16
     8d2:	08 95       	ret

000008d4 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
     8d4:	1f 93       	push	r17
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");

  chSysLock();
     8d6:	f8 94       	cli
#if CH_USE_MUTEXES
  oldprio = currp->p_realprio;
     8d8:	e0 91 fe 0b 	lds	r30, 0x0BFE
     8dc:	f0 91 ff 0b 	lds	r31, 0x0BFF
     8e0:	17 8d       	ldd	r17, Z+31	; 0x1f
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
     8e2:	94 81       	ldd	r25, Z+4	; 0x04
     8e4:	19 17       	cp	r17, r25
     8e6:	11 f0       	breq	.+4      	; 0x8ec <chThdSetPriority+0x18>
     8e8:	98 17       	cp	r25, r24
     8ea:	08 f4       	brcc	.+2      	; 0x8ee <chThdSetPriority+0x1a>
    currp->p_prio = newprio;
     8ec:	84 83       	std	Z+4, r24	; 0x04
  currp->p_realprio = newprio;
     8ee:	87 8f       	std	Z+31, r24	; 0x1f
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
     8f0:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  chSysUnlock();
     8f4:	78 94       	sei
  return oldprio;
}
     8f6:	81 2f       	mov	r24, r17
     8f8:	1f 91       	pop	r17
     8fa:	08 95       	ret

000008fc <chRegFirstThread>:
 * @api
 */
Thread *chRegFirstThread(void) {
  Thread *tp;

  chSysLock();
     8fc:	f8 94       	cli
  tp = rlist.r_newer;
     8fe:	80 91 fa 0b 	lds	r24, 0x0BFA
     902:	90 91 fb 0b 	lds	r25, 0x0BFB
#if CH_USE_DYNAMIC
  tp->p_refs++;
#endif
  chSysUnlock();
     906:	78 94       	sei
  return tp;
}
     908:	08 95       	ret

0000090a <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
Thread *chRegNextThread(Thread *tp) {
     90a:	fc 01       	movw	r30, r24
  Thread *ntp;

  chSysLock();
     90c:	f8 94       	cli
  ntp = tp->p_newer;
     90e:	27 81       	ldd	r18, Z+7	; 0x07
     910:	30 85       	ldd	r19, Z+8	; 0x08
  if (ntp == (Thread *)&rlist)
     912:	8b e0       	ldi	r24, 0x0B	; 11
     914:	23 3f       	cpi	r18, 0xF3	; 243
     916:	38 07       	cpc	r19, r24
     918:	19 f0       	breq	.+6      	; 0x920 <chRegNextThread+0x16>
    chDbgAssert(ntp->p_refs < 255, "chRegNextThread(), #1",
                "too many references");
    ntp->p_refs++;
  }
#endif
  chSysUnlock();
     91a:	78 94       	sei
#if CH_USE_DYNAMIC
  chThdRelease(tp);
#endif
  return ntp;
}
     91c:	c9 01       	movw	r24, r18
     91e:	08 95       	ret
Thread *chRegNextThread(Thread *tp) {
  Thread *ntp;

  chSysLock();
  ntp = tp->p_newer;
  if (ntp == (Thread *)&rlist)
     920:	20 e0       	ldi	r18, 0x00	; 0
     922:	30 e0       	ldi	r19, 0x00	; 0
     924:	fa cf       	rjmp	.-12     	; 0x91a <chRegNextThread+0x10>

00000926 <chSemInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemInit(Semaphore *sp, cnt_t n) {
     926:	fc 01       	movw	r30, r24

  chDbgCheck((sp != NULL) && (n >= 0), "chSemInit");

  queue_init(&sp->s_queue);
     928:	82 83       	std	Z+2, r24	; 0x02
     92a:	f3 83       	std	Z+3, r31	; 0x03
     92c:	80 83       	st	Z, r24
     92e:	f1 83       	std	Z+1, r31	; 0x01
  sp->s_cnt = n;
     930:	64 83       	std	Z+4, r22	; 0x04
}
     932:	08 95       	ret

00000934 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(Semaphore *sp, cnt_t n) {
     934:	ff 92       	push	r15
     936:	0f 93       	push	r16
     938:	1f 93       	push	r17
     93a:	cf 93       	push	r28
     93c:	df 93       	push	r29
     93e:	ec 01       	movw	r28, r24
     940:	16 2f       	mov	r17, r22

  chDbgCheckClassI();
  chDbgCheck((sp != NULL) && (n > 0), "chSemAddCounterI");
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
     942:	8c 81       	ldd	r24, Y+4	; 0x04
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     944:	16 16       	cp	r1, r22
     946:	ec f4       	brge	.+58     	; 0x982 <chSemAddCounterI+0x4e>
     948:	fc 2e       	mov	r15, r28
     94a:	0d 2f       	mov	r16, r29
     94c:	04 c0       	rjmp	.+8      	; 0x956 <chSemAddCounterI+0x22>
    if (++sp->s_cnt <= 0)
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
    n--;
     94e:	11 50       	subi	r17, 0x01	; 1
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     950:	11 16       	cp	r1, r17
     952:	bc f4       	brge	.+46     	; 0x982 <chSemAddCounterI+0x4e>
     954:	8c 81       	ldd	r24, Y+4	; 0x04
    if (++sp->s_cnt <= 0)
     956:	8f 5f       	subi	r24, 0xFF	; 255
     958:	8c 83       	std	Y+4, r24	; 0x04
     95a:	18 16       	cp	r1, r24
     95c:	c4 f3       	brlt	.-16     	; 0x94e <chSemAddCounterI+0x1a>
     95e:	a8 81       	ld	r26, Y
     960:	b9 81       	ldd	r27, Y+1	; 0x01
     962:	ed 91       	ld	r30, X+
     964:	fc 91       	ld	r31, X
     966:	11 97       	sbiw	r26, 0x01	; 1
     968:	f9 83       	std	Y+1, r31	; 0x01
     96a:	e8 83       	st	Y, r30
     96c:	f2 82       	std	Z+2, r15	; 0x02
     96e:	03 83       	std	Z+3, r16	; 0x03
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
     970:	cd 01       	movw	r24, r26
     972:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
     976:	fc 01       	movw	r30, r24
     978:	13 8a       	std	Z+19, r1	; 0x13
     97a:	12 8a       	std	Z+18, r1	; 0x12
    n--;
     97c:	11 50       	subi	r17, 0x01	; 1
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     97e:	11 16       	cp	r1, r17
     980:	4c f3       	brlt	.-46     	; 0x954 <chSemAddCounterI+0x20>
    if (++sp->s_cnt <= 0)
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
    n--;
  }
}
     982:	df 91       	pop	r29
     984:	cf 91       	pop	r28
     986:	1f 91       	pop	r17
     988:	0f 91       	pop	r16
     98a:	ff 90       	pop	r15
     98c:	08 95       	ret

0000098e <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p Semaphore structure
 *
 * @iclass
 */
void chSemSignalI(Semaphore *sp) {
     98e:	cf 93       	push	r28
     990:	df 93       	push	r29
     992:	ec 01       	movw	r28, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemSignalI(), #1",
              "inconsistent semaphore");

  if (++sp->s_cnt <= 0) {
     994:	8c 81       	ldd	r24, Y+4	; 0x04
     996:	8f 5f       	subi	r24, 0xFF	; 255
     998:	8c 83       	std	Y+4, r24	; 0x04
     99a:	18 16       	cp	r1, r24
     99c:	1c f4       	brge	.+6      	; 0x9a4 <chSemSignalI+0x16>
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
    chSchReadyI(tp);
  }
}
     99e:	df 91       	pop	r29
     9a0:	cf 91       	pop	r28
     9a2:	08 95       	ret
     9a4:	e8 81       	ld	r30, Y
     9a6:	f9 81       	ldd	r31, Y+1	; 0x01
     9a8:	a0 81       	ld	r26, Z
     9aa:	b1 81       	ldd	r27, Z+1	; 0x01
     9ac:	b9 83       	std	Y+1, r27	; 0x01
     9ae:	a8 83       	st	Y, r26
     9b0:	13 96       	adiw	r26, 0x03	; 3
     9b2:	dc 93       	st	X, r29
     9b4:	ce 93       	st	-X, r28
     9b6:	12 97       	sbiw	r26, 0x02	; 2

  if (++sp->s_cnt <= 0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
     9b8:	13 8a       	std	Z+19, r1	; 0x13
     9ba:	12 8a       	std	Z+18, r1	; 0x12
    chSchReadyI(tp);
     9bc:	cf 01       	movw	r24, r30
     9be:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
  }
}
     9c2:	df 91       	pop	r29
     9c4:	cf 91       	pop	r28
     9c6:	08 95       	ret

000009c8 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(Semaphore *sp, cnt_t n) {
     9c8:	df 92       	push	r13
     9ca:	ef 92       	push	r14
     9cc:	ff 92       	push	r15
     9ce:	0f 93       	push	r16
     9d0:	1f 93       	push	r17
     9d2:	cf 93       	push	r28
     9d4:	df 93       	push	r29
     9d6:	ec 01       	movw	r28, r24
  cnt_t cnt;

  chDbgCheckClassI();
  chDbgCheck((sp != NULL) && (n >= 0), "chSemResetI");
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
     9d8:	1c 81       	ldd	r17, Y+4	; 0x04
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemResetI(), #1",
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
     9da:	6c 83       	std	Y+4, r22	; 0x04
  while (++cnt <= 0)
     9dc:	1f 5f       	subi	r17, 0xFF	; 255
     9de:	11 16       	cp	r1, r17
     9e0:	cc f0       	brlt	.+50     	; 0xa14 <chSemResetI+0x4c>
     9e2:	d8 2e       	mov	r13, r24
     9e4:	0d 2f       	mov	r16, r29
    chSchReadyI(lifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_RESET;
     9e6:	8e ef       	ldi	r24, 0xFE	; 254
     9e8:	e8 2e       	mov	r14, r24
     9ea:	8f ef       	ldi	r24, 0xFF	; 255
     9ec:	f8 2e       	mov	r15, r24
     9ee:	aa 81       	ldd	r26, Y+2	; 0x02
     9f0:	bb 81       	ldd	r27, Y+3	; 0x03
     9f2:	12 96       	adiw	r26, 0x02	; 2
     9f4:	ed 91       	ld	r30, X+
     9f6:	fc 91       	ld	r31, X
     9f8:	13 97       	sbiw	r26, 0x03	; 3
     9fa:	fb 83       	std	Y+3, r31	; 0x03
     9fc:	ea 83       	std	Y+2, r30	; 0x02
     9fe:	d0 82       	st	Z, r13
     a00:	01 83       	std	Z+1, r16	; 0x01
     a02:	cd 01       	movw	r24, r26
     a04:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
     a08:	fc 01       	movw	r30, r24
     a0a:	f3 8a       	std	Z+19, r15	; 0x13
     a0c:	e2 8a       	std	Z+18, r14	; 0x12
              "chSemResetI(), #1",
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= 0)
     a0e:	1f 5f       	subi	r17, 0xFF	; 255
     a10:	11 16       	cp	r1, r17
     a12:	6c f7       	brge	.-38     	; 0x9ee <chSemResetI+0x26>
    chSchReadyI(lifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_RESET;
}
     a14:	df 91       	pop	r29
     a16:	cf 91       	pop	r28
     a18:	1f 91       	pop	r17
     a1a:	0f 91       	pop	r16
     a1c:	ff 90       	pop	r15
     a1e:	ef 90       	pop	r14
     a20:	df 90       	pop	r13
     a22:	08 95       	ret

00000a24 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(Semaphore *sp) {
     a24:	cf 93       	push	r28
     a26:	df 93       	push	r29
     a28:	ec 01       	movw	r28, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
     a2a:	8c 81       	ldd	r24, Y+4	; 0x04
     a2c:	81 50       	subi	r24, 0x01	; 1
     a2e:	8c 83       	std	Y+4, r24	; 0x04
     a30:	87 fd       	sbrc	r24, 7
     a32:	06 c0       	rjmp	.+12     	; 0xa40 <chSemWaitS+0x1c>
     a34:	20 e0       	ldi	r18, 0x00	; 0
     a36:	30 e0       	ldi	r19, 0x00	; 0
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
    return currp->p_u.rdymsg;
  }
  return RDY_OK;
}
     a38:	c9 01       	movw	r24, r18
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	08 95       	ret
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    currp->p_u.wtobjp = sp;
     a40:	e0 91 fe 0b 	lds	r30, 0x0BFE
     a44:	f0 91 ff 0b 	lds	r31, 0x0BFF
     a48:	d3 8b       	std	Z+19, r29	; 0x13
     a4a:	c2 8b       	std	Z+18, r28	; 0x12
     a4c:	d1 83       	std	Z+1, r29	; 0x01
     a4e:	c0 83       	st	Z, r28
     a50:	aa 81       	ldd	r26, Y+2	; 0x02
     a52:	bb 81       	ldd	r27, Y+3	; 0x03
     a54:	b3 83       	std	Z+3, r27	; 0x03
     a56:	a2 83       	std	Z+2, r26	; 0x02
     a58:	fb 83       	std	Y+3, r31	; 0x03
     a5a:	ea 83       	std	Y+2, r30	; 0x02
     a5c:	ed 93       	st	X+, r30
     a5e:	fc 93       	st	X, r31
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
     a60:	83 e0       	ldi	r24, 0x03	; 3
     a62:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
    return currp->p_u.rdymsg;
     a66:	e0 91 fe 0b 	lds	r30, 0x0BFE
     a6a:	f0 91 ff 0b 	lds	r31, 0x0BFF
     a6e:	22 89       	ldd	r18, Z+18	; 0x12
     a70:	33 89       	ldd	r19, Z+19	; 0x13
  }
  return RDY_OK;
}
     a72:	c9 01       	movw	r24, r18
     a74:	df 91       	pop	r29
     a76:	cf 91       	pop	r28
     a78:	08 95       	ret

00000a7a <chSemWait>:
 * @api
 */
msg_t chSemWait(Semaphore *sp) {
  msg_t msg;

  chSysLock();
     a7a:	f8 94       	cli
  msg = chSemWaitS(sp);
     a7c:	0e 94 12 05 	call	0xa24	; 0xa24 <chSemWaitS>
  chSysUnlock();
     a80:	78 94       	sei
  return msg;
}
     a82:	08 95       	ret

00000a84 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(Semaphore *sps, Semaphore *spw) {
     a84:	ef 92       	push	r14
     a86:	ff 92       	push	r15
     a88:	0f 93       	push	r16
     a8a:	1f 93       	push	r17
     a8c:	cf 93       	push	r28
     a8e:	df 93       	push	r29
     a90:	ec 01       	movw	r28, r24
     a92:	7b 01       	movw	r14, r22
  chDbgAssert(((spw->s_cnt >= 0) && isempty(&spw->s_queue)) ||
              ((spw->s_cnt < 0) && notempty(&spw->s_queue)),
              "chSemSignalWait(), #2",
              "inconsistent semaphore");

  chSysLock();
     a94:	f8 94       	cli
  if (++sps->s_cnt <= 0)
     a96:	8c 81       	ldd	r24, Y+4	; 0x04
     a98:	8f 5f       	subi	r24, 0xFF	; 255
     a9a:	8c 83       	std	Y+4, r24	; 0x04
     a9c:	18 16       	cp	r1, r24
     a9e:	ac f5       	brge	.+106    	; 0xb0a <chSemSignalWait+0x86>
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
  if (--spw->s_cnt < 0) {
     aa0:	f7 01       	movw	r30, r14
     aa2:	84 81       	ldd	r24, Z+4	; 0x04
     aa4:	81 50       	subi	r24, 0x01	; 1
     aa6:	84 83       	std	Z+4, r24	; 0x04
     aa8:	87 fd       	sbrc	r24, 7
     aaa:	0d c0       	rjmp	.+26     	; 0xac6 <chSemSignalWait+0x42>
    ctp->p_u.wtobjp = spw;
    chSchGoSleepS(THD_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
     aac:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
     ab0:	20 e0       	ldi	r18, 0x00	; 0
     ab2:	30 e0       	ldi	r19, 0x00	; 0
    msg = RDY_OK;
  }
  chSysUnlock();
     ab4:	78 94       	sei
  return msg;
}
     ab6:	c9 01       	movw	r24, r18
     ab8:	df 91       	pop	r29
     aba:	cf 91       	pop	r28
     abc:	1f 91       	pop	r17
     abe:	0f 91       	pop	r16
     ac0:	ff 90       	pop	r15
     ac2:	ef 90       	pop	r14
     ac4:	08 95       	ret

  chSysLock();
  if (++sps->s_cnt <= 0)
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
  if (--spw->s_cnt < 0) {
    Thread *ctp = currp;
     ac6:	00 91 fe 0b 	lds	r16, 0x0BFE
     aca:	10 91 ff 0b 	lds	r17, 0x0BFF
     ace:	d8 01       	movw	r26, r16
     ad0:	11 96       	adiw	r26, 0x01	; 1
     ad2:	fc 92       	st	X, r15
     ad4:	ee 92       	st	-X, r14
     ad6:	02 80       	ldd	r0, Z+2	; 0x02
     ad8:	f3 81       	ldd	r31, Z+3	; 0x03
     ada:	e0 2d       	mov	r30, r0
     adc:	13 96       	adiw	r26, 0x03	; 3
     ade:	fc 93       	st	X, r31
     ae0:	ee 93       	st	-X, r30
     ae2:	12 97       	sbiw	r26, 0x02	; 2
     ae4:	d7 01       	movw	r26, r14
     ae6:	13 96       	adiw	r26, 0x03	; 3
     ae8:	1c 93       	st	X, r17
     aea:	0e 93       	st	-X, r16
     aec:	12 97       	sbiw	r26, 0x02	; 2
     aee:	11 83       	std	Z+1, r17	; 0x01
     af0:	00 83       	st	Z, r16
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtobjp = spw;
     af2:	f8 01       	movw	r30, r16
     af4:	f3 8a       	std	Z+19, r15	; 0x13
     af6:	e2 8a       	std	Z+18, r14	; 0x12
    chSchGoSleepS(THD_STATE_WTSEM);
     af8:	83 e0       	ldi	r24, 0x03	; 3
     afa:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
     afe:	d8 01       	movw	r26, r16
     b00:	52 96       	adiw	r26, 0x12	; 18
     b02:	2d 91       	ld	r18, X+
     b04:	3c 91       	ld	r19, X
     b06:	53 97       	sbiw	r26, 0x13	; 19
     b08:	d5 cf       	rjmp	.-86     	; 0xab4 <chSemSignalWait+0x30>
     b0a:	a8 81       	ld	r26, Y
     b0c:	b9 81       	ldd	r27, Y+1	; 0x01
     b0e:	ed 91       	ld	r30, X+
     b10:	fc 91       	ld	r31, X
     b12:	11 97       	sbiw	r26, 0x01	; 1
     b14:	f9 83       	std	Y+1, r31	; 0x01
     b16:	e8 83       	st	Y, r30
     b18:	d3 83       	std	Z+3, r29	; 0x03
     b1a:	c2 83       	std	Z+2, r28	; 0x02
              "chSemSignalWait(), #2",
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= 0)
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
     b1c:	cd 01       	movw	r24, r26
     b1e:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
     b22:	dc 01       	movw	r26, r24
     b24:	53 96       	adiw	r26, 0x13	; 19
     b26:	1c 92       	st	X, r1
     b28:	1e 92       	st	-X, r1
     b2a:	52 97       	sbiw	r26, 0x12	; 18
     b2c:	b9 cf       	rjmp	.-142    	; 0xaa0 <chSemSignalWait+0x1c>

00000b2e <chSemReset>:
 *
 * @api
 */
void chSemReset(Semaphore *sp, cnt_t n) {

  chSysLock();
     b2e:	f8 94       	cli
  chSemResetI(sp, n);
     b30:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <chSemResetI>
  chSchRescheduleS();
     b34:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  chSysUnlock();
     b38:	78 94       	sei
}
     b3a:	08 95       	ret

00000b3c <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p Semaphore structure
 *
 * @api
 */
void chSemSignal(Semaphore *sp) {
     b3c:	cf 93       	push	r28
     b3e:	df 93       	push	r29
     b40:	ec 01       	movw	r28, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemSignal(), #1",
              "inconsistent semaphore");

  chSysLock();
     b42:	f8 94       	cli
  if (++sp->s_cnt <= 0)
     b44:	8c 81       	ldd	r24, Y+4	; 0x04
     b46:	8f 5f       	subi	r24, 0xFF	; 255
     b48:	8c 83       	std	Y+4, r24	; 0x04
     b4a:	18 16       	cp	r1, r24
     b4c:	24 f4       	brge	.+8      	; 0xb56 <chSemSignal+0x1a>
    chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
  chSysUnlock();
     b4e:	78 94       	sei
}
     b50:	df 91       	pop	r29
     b52:	cf 91       	pop	r28
     b54:	08 95       	ret
     b56:	a8 81       	ld	r26, Y
     b58:	b9 81       	ldd	r27, Y+1	; 0x01
     b5a:	ed 91       	ld	r30, X+
     b5c:	fc 91       	ld	r31, X
     b5e:	11 97       	sbiw	r26, 0x01	; 1
     b60:	f9 83       	std	Y+1, r31	; 0x01
     b62:	e8 83       	st	Y, r30
     b64:	d3 83       	std	Z+3, r29	; 0x03
     b66:	c2 83       	std	Z+2, r28	; 0x02
              "chSemSignal(), #1",
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= 0)
    chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
     b68:	cd 01       	movw	r24, r26
     b6a:	60 e0       	ldi	r22, 0x00	; 0
     b6c:	70 e0       	ldi	r23, 0x00	; 0
     b6e:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
  chSysUnlock();
     b72:	78 94       	sei
}
     b74:	df 91       	pop	r29
     b76:	cf 91       	pop	r28
     b78:	08 95       	ret

00000b7a <chSemWaitTimeoutS>:
 * @retval RDY_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(Semaphore *sp, systime_t time) {
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	ec 01       	movw	r28, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
     b80:	9c 81       	ldd	r25, Y+4	; 0x04
     b82:	89 2f       	mov	r24, r25
     b84:	81 50       	subi	r24, 0x01	; 1
     b86:	8c 83       	std	Y+4, r24	; 0x04
     b88:	87 fd       	sbrc	r24, 7
     b8a:	06 c0       	rjmp	.+12     	; 0xb98 <chSemWaitTimeoutS+0x1e>
     b8c:	20 e0       	ldi	r18, 0x00	; 0
     b8e:	30 e0       	ldi	r19, 0x00	; 0
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
  }
  return RDY_OK;
}
     b90:	c9 01       	movw	r24, r18
     b92:	df 91       	pop	r29
     b94:	cf 91       	pop	r28
     b96:	08 95       	ret
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
     b98:	61 15       	cp	r22, r1
     b9a:	71 05       	cpc	r23, r1
     b9c:	c1 f0       	breq	.+48     	; 0xbce <chSemWaitTimeoutS+0x54>
      sp->s_cnt++;
      return RDY_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
     b9e:	e0 91 fe 0b 	lds	r30, 0x0BFE
     ba2:	f0 91 ff 0b 	lds	r31, 0x0BFF
     ba6:	d3 8b       	std	Z+19, r29	; 0x13
     ba8:	c2 8b       	std	Z+18, r28	; 0x12
     baa:	d1 83       	std	Z+1, r29	; 0x01
     bac:	c0 83       	st	Z, r28
     bae:	aa 81       	ldd	r26, Y+2	; 0x02
     bb0:	bb 81       	ldd	r27, Y+3	; 0x03
     bb2:	b3 83       	std	Z+3, r27	; 0x03
     bb4:	a2 83       	std	Z+2, r26	; 0x02
     bb6:	fb 83       	std	Y+3, r31	; 0x03
     bb8:	ea 83       	std	Y+2, r30	; 0x02
     bba:	ed 93       	st	X+, r30
     bbc:	fc 93       	st	X, r31
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
     bbe:	83 e0       	ldi	r24, 0x03	; 3
     bc0:	0e 94 21 03 	call	0x642	; 0x642 <chSchGoSleepTimeoutS>
     bc4:	9c 01       	movw	r18, r24
  }
  return RDY_OK;
}
     bc6:	c9 01       	movw	r24, r18
     bc8:	df 91       	pop	r29
     bca:	cf 91       	pop	r28
     bcc:	08 95       	ret
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
     bce:	9c 83       	std	Y+4, r25	; 0x04
     bd0:	2f ef       	ldi	r18, 0xFF	; 255
     bd2:	3f ef       	ldi	r19, 0xFF	; 255
     bd4:	dd cf       	rjmp	.-70     	; 0xb90 <chSemWaitTimeoutS+0x16>

00000bd6 <chSemWaitTimeout>:
 * @api
 */
msg_t chSemWaitTimeout(Semaphore *sp, systime_t time) {
  msg_t msg;

  chSysLock();
     bd6:	f8 94       	cli
  msg = chSemWaitTimeoutS(sp, time);
     bd8:	0e 94 bd 05 	call	0xb7a	; 0xb7a <chSemWaitTimeoutS>
  chSysUnlock();
     bdc:	78 94       	sei
  return msg;
}
     bde:	08 95       	ret

00000be0 <chMtxInit>:
 *
 * @param[out] mp       pointer to a @p Mutex structure
 *
 * @init
 */
void chMtxInit(Mutex *mp) {
     be0:	fc 01       	movw	r30, r24

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
     be2:	82 83       	std	Z+2, r24	; 0x02
     be4:	f3 83       	std	Z+3, r31	; 0x03
     be6:	80 83       	st	Z, r24
     be8:	f1 83       	std	Z+1, r31	; 0x01
  mp->m_owner = NULL;
     bea:	15 82       	std	Z+5, r1	; 0x05
     bec:	14 82       	std	Z+4, r1	; 0x04
}
     bee:	08 95       	ret

00000bf0 <chMtxTryLock>:
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @api
 */
bool_t chMtxTryLock(Mutex *mp) {
     bf0:	dc 01       	movw	r26, r24
  bool_t b;

  chSysLock();
     bf2:	f8 94       	cli
bool_t chMtxTryLockS(Mutex *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
     bf4:	14 96       	adiw	r26, 0x04	; 4
     bf6:	8d 91       	ld	r24, X+
     bf8:	9c 91       	ld	r25, X
     bfa:	15 97       	sbiw	r26, 0x05	; 5
     bfc:	89 2b       	or	r24, r25
     bfe:	19 f0       	breq	.+6      	; 0xc06 <chMtxTryLock+0x16>
     c00:	80 e0       	ldi	r24, 0x00	; 0

  chSysLock();

  b = chMtxTryLockS(mp);

  chSysUnlock();
     c02:	78 94       	sei
  return b;
}
     c04:	08 95       	ret
  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
    return FALSE;
  mp->m_owner = currp;
     c06:	e0 91 fe 0b 	lds	r30, 0x0BFE
     c0a:	f0 91 ff 0b 	lds	r31, 0x0BFF
     c0e:	15 96       	adiw	r26, 0x05	; 5
     c10:	fc 93       	st	X, r31
     c12:	ee 93       	st	-X, r30
     c14:	14 97       	sbiw	r26, 0x04	; 4
  mp->m_next = currp->p_mtxlist;
     c16:	85 8d       	ldd	r24, Z+29	; 0x1d
     c18:	96 8d       	ldd	r25, Z+30	; 0x1e
     c1a:	17 96       	adiw	r26, 0x07	; 7
     c1c:	9c 93       	st	X, r25
     c1e:	8e 93       	st	-X, r24
     c20:	16 97       	sbiw	r26, 0x06	; 6
  currp->p_mtxlist = mp;
     c22:	b6 8f       	std	Z+30, r27	; 0x1e
     c24:	a5 8f       	std	Z+29, r26	; 0x1d
     c26:	81 e0       	ldi	r24, 0x01	; 1

  chSysLock();

  b = chMtxTryLockS(mp);

  chSysUnlock();
     c28:	78 94       	sei
  return b;
}
     c2a:	08 95       	ret

00000c2c <chMtxTryLockS>:
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @sclass
 */
bool_t chMtxTryLockS(Mutex *mp) {
     c2c:	dc 01       	movw	r26, r24

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
     c2e:	14 96       	adiw	r26, 0x04	; 4
     c30:	8d 91       	ld	r24, X+
     c32:	9c 91       	ld	r25, X
     c34:	15 97       	sbiw	r26, 0x05	; 5
     c36:	89 2b       	or	r24, r25
     c38:	11 f0       	breq	.+4      	; 0xc3e <chMtxTryLockS+0x12>
     c3a:	80 e0       	ldi	r24, 0x00	; 0
     c3c:	08 95       	ret
    return FALSE;
  mp->m_owner = currp;
     c3e:	e0 91 fe 0b 	lds	r30, 0x0BFE
     c42:	f0 91 ff 0b 	lds	r31, 0x0BFF
     c46:	15 96       	adiw	r26, 0x05	; 5
     c48:	fc 93       	st	X, r31
     c4a:	ee 93       	st	-X, r30
     c4c:	14 97       	sbiw	r26, 0x04	; 4
  mp->m_next = currp->p_mtxlist;
     c4e:	85 8d       	ldd	r24, Z+29	; 0x1d
     c50:	96 8d       	ldd	r25, Z+30	; 0x1e
     c52:	17 96       	adiw	r26, 0x07	; 7
     c54:	9c 93       	st	X, r25
     c56:	8e 93       	st	-X, r24
     c58:	16 97       	sbiw	r26, 0x06	; 6
  currp->p_mtxlist = mp;
     c5a:	b6 8f       	std	Z+30, r27	; 0x1e
     c5c:	a5 8f       	std	Z+29, r26	; 0x1d
     c5e:	81 e0       	ldi	r24, 0x01	; 1
  return TRUE;
}
     c60:	08 95       	ret

00000c62 <chMtxUnlockS>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @sclass
 */
Mutex *chMtxUnlockS(void) {
     c62:	cf 93       	push	r28
     c64:	df 93       	push	r29
  Thread *ctp = currp;
     c66:	40 91 fe 0b 	lds	r20, 0x0BFE
     c6a:	50 91 ff 0b 	lds	r21, 0x0BFF
              "chMtxUnlockS(), #2",
              "ownership failure");

  /* Removes the top Mutex from the owned mutexes list and marks it as not
     owned.*/
  ump = ctp->p_mtxlist;
     c6e:	da 01       	movw	r26, r20
     c70:	5d 96       	adiw	r26, 0x1d	; 29
     c72:	cd 91       	ld	r28, X+
     c74:	dc 91       	ld	r29, X
     c76:	5e 97       	sbiw	r26, 0x1e	; 30
  ctp->p_mtxlist = ump->m_next;
     c78:	ee 81       	ldd	r30, Y+6	; 0x06
     c7a:	ff 81       	ldd	r31, Y+7	; 0x07
     c7c:	5e 96       	adiw	r26, 0x1e	; 30
     c7e:	fc 93       	st	X, r31
     c80:	ee 93       	st	-X, r30
     c82:	5d 97       	sbiw	r26, 0x1d	; 29
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
     c84:	28 81       	ld	r18, Y
     c86:	39 81       	ldd	r19, Y+1	; 0x01
     c88:	2c 17       	cp	r18, r28
     c8a:	3d 07       	cpc	r19, r29
     c8c:	81 f1       	breq	.+96     	; 0xcee <chMtxUnlockS+0x8c>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
     c8e:	5f 96       	adiw	r26, 0x1f	; 31
     c90:	9c 91       	ld	r25, X
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     c92:	30 97       	sbiw	r30, 0x00	; 0
     c94:	79 f0       	breq	.+30     	; 0xcb4 <chMtxUnlockS+0x52>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
     c96:	a0 81       	ld	r26, Z
     c98:	b1 81       	ldd	r27, Z+1	; 0x01
     c9a:	ae 17       	cp	r26, r30
     c9c:	bf 07       	cpc	r27, r31
     c9e:	29 f0       	breq	.+10     	; 0xcaa <chMtxUnlockS+0x48>
     ca0:	14 96       	adiw	r26, 0x04	; 4
     ca2:	8c 91       	ld	r24, X
     ca4:	98 17       	cp	r25, r24
     ca6:	08 f4       	brcc	.+2      	; 0xcaa <chMtxUnlockS+0x48>
     ca8:	98 2f       	mov	r25, r24
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
     caa:	06 80       	ldd	r0, Z+6	; 0x06
     cac:	f7 81       	ldd	r31, Z+7	; 0x07
     cae:	e0 2d       	mov	r30, r0

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     cb0:	30 97       	sbiw	r30, 0x00	; 0
     cb2:	89 f7       	brne	.-30     	; 0xc96 <chMtxUnlockS+0x34>
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    ctp->p_prio = newprio;
     cb4:	fa 01       	movw	r30, r20
     cb6:	94 83       	std	Z+4, r25	; 0x04
     cb8:	d9 01       	movw	r26, r18
     cba:	ed 91       	ld	r30, X+
     cbc:	fc 91       	ld	r31, X
     cbe:	11 97       	sbiw	r26, 0x01	; 1
     cc0:	f9 83       	std	Y+1, r31	; 0x01
     cc2:	e8 83       	st	Y, r30
     cc4:	d3 83       	std	Z+3, r29	; 0x03
     cc6:	c2 83       	std	Z+2, r28	; 0x02
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    ump->m_owner = tp;
     cc8:	3d 83       	std	Y+5, r19	; 0x05
     cca:	2c 83       	std	Y+4, r18	; 0x04
    ump->m_next = tp->p_mtxlist;
     ccc:	5d 96       	adiw	r26, 0x1d	; 29
     cce:	8d 91       	ld	r24, X+
     cd0:	9c 91       	ld	r25, X
     cd2:	5e 97       	sbiw	r26, 0x1e	; 30
     cd4:	9f 83       	std	Y+7, r25	; 0x07
     cd6:	8e 83       	std	Y+6, r24	; 0x06
    tp->p_mtxlist = ump;
     cd8:	5e 96       	adiw	r26, 0x1e	; 30
     cda:	dc 93       	st	X, r29
     cdc:	ce 93       	st	-X, r28
     cde:	5d 97       	sbiw	r26, 0x1d	; 29
    chSchReadyI(tp);
     ce0:	c9 01       	movw	r24, r18
     ce2:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
  }
  else
    ump->m_owner = NULL;
  return ump;
}
     ce6:	ce 01       	movw	r24, r28
     ce8:	df 91       	pop	r29
     cea:	cf 91       	pop	r28
     cec:	08 95       	ret
    ump->m_next = tp->p_mtxlist;
    tp->p_mtxlist = ump;
    chSchReadyI(tp);
  }
  else
    ump->m_owner = NULL;
     cee:	1d 82       	std	Y+5, r1	; 0x05
     cf0:	1c 82       	std	Y+4, r1	; 0x04
  return ump;
}
     cf2:	ce 01       	movw	r24, r28
     cf4:	df 91       	pop	r29
     cf6:	cf 91       	pop	r28
     cf8:	08 95       	ret

00000cfa <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
     cfa:	0f 93       	push	r16
     cfc:	1f 93       	push	r17
     cfe:	cf 93       	push	r28
     d00:	df 93       	push	r29
  Thread *ctp = currp;
     d02:	00 91 fe 0b 	lds	r16, 0x0BFE
     d06:	10 91 ff 0b 	lds	r17, 0x0BFF

  chSysLock();
     d0a:	f8 94       	cli
  if (ctp->p_mtxlist != NULL) {
     d0c:	f8 01       	movw	r30, r16
     d0e:	a5 8d       	ldd	r26, Z+29	; 0x1d
     d10:	b6 8d       	ldd	r27, Z+30	; 0x1e
     d12:	10 97       	sbiw	r26, 0x00	; 0
     d14:	e1 f4       	brne	.+56     	; 0xd4e <chMtxUnlockAll+0x54>
     d16:	35 c0       	rjmp	.+106    	; 0xd82 <chMtxUnlockAll+0x88>
     d18:	e8 81       	ld	r30, Y
     d1a:	f9 81       	ldd	r31, Y+1	; 0x01
     d1c:	11 96       	adiw	r26, 0x01	; 1
     d1e:	fc 93       	st	X, r31
     d20:	ee 93       	st	-X, r30
     d22:	b3 83       	std	Z+3, r27	; 0x03
     d24:	a2 83       	std	Z+2, r26	; 0x02
    do {
      Mutex *ump = ctp->p_mtxlist;
      ctp->p_mtxlist = ump->m_next;
      if (chMtxQueueNotEmptyS(ump)) {
        Thread *tp = fifo_remove(&ump->m_queue);
        ump->m_owner = tp;
     d26:	15 96       	adiw	r26, 0x05	; 5
     d28:	dc 93       	st	X, r29
     d2a:	ce 93       	st	-X, r28
     d2c:	14 97       	sbiw	r26, 0x04	; 4
        ump->m_next = tp->p_mtxlist;
     d2e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d30:	9e 8d       	ldd	r25, Y+30	; 0x1e
     d32:	17 96       	adiw	r26, 0x07	; 7
     d34:	9c 93       	st	X, r25
     d36:	8e 93       	st	-X, r24
     d38:	16 97       	sbiw	r26, 0x06	; 6
        tp->p_mtxlist = ump;
     d3a:	be 8f       	std	Y+30, r27	; 0x1e
     d3c:	ad 8f       	std	Y+29, r26	; 0x1d
        chSchReadyI(tp);
     d3e:	ce 01       	movw	r24, r28
     d40:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
      }
      else
        ump->m_owner = NULL;
    } while (ctp->p_mtxlist != NULL);
     d44:	f8 01       	movw	r30, r16
     d46:	a5 8d       	ldd	r26, Z+29	; 0x1d
     d48:	b6 8d       	ldd	r27, Z+30	; 0x1e
     d4a:	10 97       	sbiw	r26, 0x00	; 0
     d4c:	b1 f0       	breq	.+44     	; 0xd7a <chMtxUnlockAll+0x80>

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      Mutex *ump = ctp->p_mtxlist;
      ctp->p_mtxlist = ump->m_next;
     d4e:	16 96       	adiw	r26, 0x06	; 6
     d50:	8d 91       	ld	r24, X+
     d52:	9c 91       	ld	r25, X
     d54:	17 97       	sbiw	r26, 0x07	; 7
     d56:	f8 01       	movw	r30, r16
     d58:	96 8f       	std	Z+30, r25	; 0x1e
     d5a:	85 8f       	std	Z+29, r24	; 0x1d
      if (chMtxQueueNotEmptyS(ump)) {
     d5c:	cd 91       	ld	r28, X+
     d5e:	dc 91       	ld	r29, X
     d60:	11 97       	sbiw	r26, 0x01	; 1
     d62:	ca 17       	cp	r28, r26
     d64:	db 07       	cpc	r29, r27
     d66:	c1 f6       	brne	.-80     	; 0xd18 <chMtxUnlockAll+0x1e>
        ump->m_next = tp->p_mtxlist;
        tp->p_mtxlist = ump;
        chSchReadyI(tp);
      }
      else
        ump->m_owner = NULL;
     d68:	15 96       	adiw	r26, 0x05	; 5
     d6a:	1c 92       	st	X, r1
     d6c:	1e 92       	st	-X, r1
     d6e:	14 97       	sbiw	r26, 0x04	; 4
    } while (ctp->p_mtxlist != NULL);
     d70:	f8 01       	movw	r30, r16
     d72:	a5 8d       	ldd	r26, Z+29	; 0x1d
     d74:	b6 8d       	ldd	r27, Z+30	; 0x1e
     d76:	10 97       	sbiw	r26, 0x00	; 0
     d78:	51 f7       	brne	.-44     	; 0xd4e <chMtxUnlockAll+0x54>
    ctp->p_prio = ctp->p_realprio;
     d7a:	87 8d       	ldd	r24, Z+31	; 0x1f
     d7c:	84 83       	std	Z+4, r24	; 0x04
    chSchRescheduleS();
     d7e:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  }
  chSysUnlock();
     d82:	78 94       	sei
}
     d84:	df 91       	pop	r29
     d86:	cf 91       	pop	r28
     d88:	1f 91       	pop	r17
     d8a:	0f 91       	pop	r16
     d8c:	08 95       	ret

00000d8e <chMtxUnlock>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @api
 */
Mutex *chMtxUnlock(void) {
     d8e:	cf 93       	push	r28
     d90:	df 93       	push	r29
  Thread *ctp = currp;
     d92:	40 91 fe 0b 	lds	r20, 0x0BFE
     d96:	50 91 ff 0b 	lds	r21, 0x0BFF
  Mutex *ump, *mp;

  chSysLock();
     d9a:	f8 94       	cli
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
              "chMtxUnlock(), #2",
              "ownership failure");
  /* Removes the top Mutex from the Thread's owned mutexes list and marks it
     as not owned.*/
  ump = ctp->p_mtxlist;
     d9c:	da 01       	movw	r26, r20
     d9e:	5d 96       	adiw	r26, 0x1d	; 29
     da0:	cd 91       	ld	r28, X+
     da2:	dc 91       	ld	r29, X
     da4:	5e 97       	sbiw	r26, 0x1e	; 30
  ctp->p_mtxlist = ump->m_next;
     da6:	ee 81       	ldd	r30, Y+6	; 0x06
     da8:	ff 81       	ldd	r31, Y+7	; 0x07
     daa:	5e 96       	adiw	r26, 0x1e	; 30
     dac:	fc 93       	st	X, r31
     dae:	ee 93       	st	-X, r30
     db0:	5d 97       	sbiw	r26, 0x1d	; 29
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
     db2:	28 81       	ld	r18, Y
     db4:	39 81       	ldd	r19, Y+1	; 0x01
     db6:	2c 17       	cp	r18, r28
     db8:	3d 07       	cpc	r19, r29
     dba:	99 f1       	breq	.+102    	; 0xe22 <chMtxUnlock+0x94>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
     dbc:	5f 96       	adiw	r26, 0x1f	; 31
     dbe:	9c 91       	ld	r25, X
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     dc0:	30 97       	sbiw	r30, 0x00	; 0
     dc2:	79 f0       	breq	.+30     	; 0xde2 <chMtxUnlock+0x54>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
     dc4:	a0 81       	ld	r26, Z
     dc6:	b1 81       	ldd	r27, Z+1	; 0x01
     dc8:	ae 17       	cp	r26, r30
     dca:	bf 07       	cpc	r27, r31
     dcc:	29 f0       	breq	.+10     	; 0xdd8 <chMtxUnlock+0x4a>
     dce:	14 96       	adiw	r26, 0x04	; 4
     dd0:	8c 91       	ld	r24, X
     dd2:	98 17       	cp	r25, r24
     dd4:	08 f4       	brcc	.+2      	; 0xdd8 <chMtxUnlock+0x4a>
     dd6:	98 2f       	mov	r25, r24
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
     dd8:	06 80       	ldd	r0, Z+6	; 0x06
     dda:	f7 81       	ldd	r31, Z+7	; 0x07
     ddc:	e0 2d       	mov	r30, r0

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     dde:	30 97       	sbiw	r30, 0x00	; 0
     de0:	89 f7       	brne	.-30     	; 0xdc4 <chMtxUnlock+0x36>
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    /* Assigns to the current thread the highest priority among all the
       waiting threads.*/
    ctp->p_prio = newprio;
     de2:	fa 01       	movw	r30, r20
     de4:	94 83       	std	Z+4, r25	; 0x04
     de6:	d9 01       	movw	r26, r18
     de8:	ed 91       	ld	r30, X+
     dea:	fc 91       	ld	r31, X
     dec:	11 97       	sbiw	r26, 0x01	; 1
     dee:	f9 83       	std	Y+1, r31	; 0x01
     df0:	e8 83       	st	Y, r30
     df2:	d3 83       	std	Z+3, r29	; 0x03
     df4:	c2 83       	std	Z+2, r28	; 0x02
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    ump->m_owner = tp;
     df6:	3d 83       	std	Y+5, r19	; 0x05
     df8:	2c 83       	std	Y+4, r18	; 0x04
    ump->m_next = tp->p_mtxlist;
     dfa:	5d 96       	adiw	r26, 0x1d	; 29
     dfc:	8d 91       	ld	r24, X+
     dfe:	9c 91       	ld	r25, X
     e00:	5e 97       	sbiw	r26, 0x1e	; 30
     e02:	9f 83       	std	Y+7, r25	; 0x07
     e04:	8e 83       	std	Y+6, r24	; 0x06
    tp->p_mtxlist = ump;
     e06:	5e 96       	adiw	r26, 0x1e	; 30
     e08:	dc 93       	st	X, r29
     e0a:	ce 93       	st	-X, r28
     e0c:	5d 97       	sbiw	r26, 0x1d	; 29
    chSchWakeupS(tp, RDY_OK);
     e0e:	c9 01       	movw	r24, r18
     e10:	60 e0       	ldi	r22, 0x00	; 0
     e12:	70 e0       	ldi	r23, 0x00	; 0
     e14:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
  }
  else
    ump->m_owner = NULL;
  chSysUnlock();
     e18:	78 94       	sei
  return ump;
}
     e1a:	ce 01       	movw	r24, r28
     e1c:	df 91       	pop	r29
     e1e:	cf 91       	pop	r28
     e20:	08 95       	ret
    ump->m_next = tp->p_mtxlist;
    tp->p_mtxlist = ump;
    chSchWakeupS(tp, RDY_OK);
  }
  else
    ump->m_owner = NULL;
     e22:	1d 82       	std	Y+5, r1	; 0x05
     e24:	1c 82       	std	Y+4, r1	; 0x04
  chSysUnlock();
     e26:	78 94       	sei
  return ump;
}
     e28:	ce 01       	movw	r24, r28
     e2a:	df 91       	pop	r29
     e2c:	cf 91       	pop	r28
     e2e:	08 95       	ret

00000e30 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @sclass
 */
void chMtxLockS(Mutex *mp) {
     e30:	ef 92       	push	r14
     e32:	ff 92       	push	r15
     e34:	0f 93       	push	r16
     e36:	1f 93       	push	r17
     e38:	cf 93       	push	r28
     e3a:	df 93       	push	r29
     e3c:	7c 01       	movw	r14, r24
  Thread *ctp = currp;
     e3e:	00 91 fe 0b 	lds	r16, 0x0BFE
     e42:	10 91 ff 0b 	lds	r17, 0x0BFF

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxLockS");

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
     e46:	fc 01       	movw	r30, r24
     e48:	c4 81       	ldd	r28, Z+4	; 0x04
     e4a:	d5 81       	ldd	r29, Z+5	; 0x05
     e4c:	20 97       	sbiw	r28, 0x00	; 0
     e4e:	09 f4       	brne	.+2      	; 0xe52 <chMtxLockS+0x22>
     e50:	a3 c0       	rjmp	.+326    	; 0xf98 <chMtxLockS+0x168>
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
     e52:	f8 01       	movw	r30, r16
     e54:	94 81       	ldd	r25, Z+4	; 0x04
     e56:	8c 81       	ldd	r24, Y+4	; 0x04
     e58:	89 17       	cp	r24, r25
     e5a:	48 f4       	brcc	.+18     	; 0xe6e <chMtxLockS+0x3e>
      /* Make priority of thread tp match the running thread's priority.*/
      tp->p_prio = ctp->p_prio;
     e5c:	9c 83       	std	Y+4, r25	; 0x04
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
     e5e:	8d 85       	ldd	r24, Y+13	; 0x0d
     e60:	84 30       	cpi	r24, 0x04	; 4
     e62:	09 f4       	brne	.+2      	; 0xe66 <chMtxLockS+0x36>
     e64:	67 c0       	rjmp	.+206    	; 0xf34 <chMtxLockS+0x104>
     e66:	85 30       	cpi	r24, 0x05	; 5
     e68:	e1 f1       	breq	.+120    	; 0xee2 <chMtxLockS+0xb2>
     e6a:	88 23       	and	r24, r24
     e6c:	51 f1       	breq	.+84     	; 0xec2 <chMtxLockS+0x92>
     e6e:	d7 01       	movw	r26, r14
     e70:	f7 01       	movw	r30, r14
     e72:	01 90       	ld	r0, Z+
     e74:	f0 81       	ld	r31, Z
     e76:	e0 2d       	mov	r30, r0
     e78:	ee 16       	cp	r14, r30
     e7a:	ff 06       	cpc	r15, r31
     e7c:	31 f0       	breq	.+12     	; 0xe8a <chMtxLockS+0x5a>
     e7e:	94 81       	ldd	r25, Z+4	; 0x04
     e80:	e8 01       	movw	r28, r16
     e82:	8c 81       	ldd	r24, Y+4	; 0x04
     e84:	98 17       	cp	r25, r24
     e86:	a8 f7       	brcc	.-22     	; 0xe72 <chMtxLockS+0x42>
     e88:	df 01       	movw	r26, r30
     e8a:	f8 01       	movw	r30, r16
     e8c:	b1 83       	std	Z+1, r27	; 0x01
     e8e:	a0 83       	st	Z, r26
     e90:	12 96       	adiw	r26, 0x02	; 2
     e92:	ed 91       	ld	r30, X+
     e94:	fc 91       	ld	r31, X
     e96:	13 97       	sbiw	r26, 0x03	; 3
     e98:	e8 01       	movw	r28, r16
     e9a:	fb 83       	std	Y+3, r31	; 0x03
     e9c:	ea 83       	std	Y+2, r30	; 0x02
     e9e:	13 96       	adiw	r26, 0x03	; 3
     ea0:	1c 93       	st	X, r17
     ea2:	0e 93       	st	-X, r16
     ea4:	12 97       	sbiw	r26, 0x02	; 2
     ea6:	11 83       	std	Z+1, r17	; 0x01
     ea8:	00 83       	st	Z, r16
      }
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
    ctp->p_u.wtobjp = mp;
     eaa:	fb 8a       	std	Y+19, r15	; 0x13
     eac:	ea 8a       	std	Y+18, r14	; 0x12
    chSchGoSleepS(THD_STATE_WTMTX);
     eae:	84 e0       	ldi	r24, 0x04	; 4
     eb0:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
     eb4:	df 91       	pop	r29
     eb6:	cf 91       	pop	r28
     eb8:	1f 91       	pop	r17
     eba:	0f 91       	pop	r16
     ebc:	ff 90       	pop	r15
     ebe:	ef 90       	pop	r14
     ec0:	08 95       	ret
     ec2:	ea 81       	ldd	r30, Y+2	; 0x02
     ec4:	fb 81       	ldd	r31, Y+3	; 0x03
     ec6:	88 81       	ld	r24, Y
     ec8:	99 81       	ldd	r25, Y+1	; 0x01
     eca:	91 83       	std	Z+1, r25	; 0x01
     ecc:	80 83       	st	Z, r24
     ece:	a8 81       	ld	r26, Y
     ed0:	b9 81       	ldd	r27, Y+1	; 0x01
     ed2:	13 96       	adiw	r26, 0x03	; 3
     ed4:	fc 93       	st	X, r31
     ed6:	ee 93       	st	-X, r30
     ed8:	12 97       	sbiw	r26, 0x02	; 2
#if CH_DBG_ENABLE_ASSERTS
        /* Prevents an assertion in chSchReadyI().*/
        tp->p_state = THD_STATE_CURRENT;
#endif
        /* Re-enqueues tp with its new priority on the ready list.*/
        chSchReadyI(dequeue(tp));
     eda:	ce 01       	movw	r24, r28
     edc:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
     ee0:	c6 cf       	rjmp	.-116    	; 0xe6e <chMtxLockS+0x3e>
     ee2:	ea 81       	ldd	r30, Y+2	; 0x02
     ee4:	fb 81       	ldd	r31, Y+3	; 0x03
     ee6:	88 81       	ld	r24, Y
     ee8:	99 81       	ldd	r25, Y+1	; 0x01
     eea:	91 83       	std	Z+1, r25	; 0x01
     eec:	80 83       	st	Z, r24
     eee:	a8 81       	ld	r26, Y
     ef0:	b9 81       	ldd	r27, Y+1	; 0x01
     ef2:	13 96       	adiw	r26, 0x03	; 3
     ef4:	fc 93       	st	X, r31
     ef6:	ee 93       	st	-X, r30
     ef8:	12 97       	sbiw	r26, 0x02	; 2
     efa:	aa 89       	ldd	r26, Y+18	; 0x12
     efc:	bb 89       	ldd	r27, Y+19	; 0x13
     efe:	fd 01       	movw	r30, r26
     f00:	01 90       	ld	r0, Z+
     f02:	f0 81       	ld	r31, Z
     f04:	e0 2d       	mov	r30, r0
     f06:	ae 17       	cp	r26, r30
     f08:	bf 07       	cpc	r27, r31
     f0a:	29 f0       	breq	.+10     	; 0xf16 <chMtxLockS+0xe6>
     f0c:	94 81       	ldd	r25, Z+4	; 0x04
     f0e:	8c 81       	ldd	r24, Y+4	; 0x04
     f10:	98 17       	cp	r25, r24
     f12:	b0 f7       	brcc	.-20     	; 0xf00 <chMtxLockS+0xd0>
     f14:	df 01       	movw	r26, r30
     f16:	b9 83       	std	Y+1, r27	; 0x01
     f18:	a8 83       	st	Y, r26
     f1a:	12 96       	adiw	r26, 0x02	; 2
     f1c:	ed 91       	ld	r30, X+
     f1e:	fc 91       	ld	r31, X
     f20:	13 97       	sbiw	r26, 0x03	; 3
     f22:	fb 83       	std	Y+3, r31	; 0x03
     f24:	ea 83       	std	Y+2, r30	; 0x02
     f26:	13 96       	adiw	r26, 0x03	; 3
     f28:	dc 93       	st	X, r29
     f2a:	ce 93       	st	-X, r28
     f2c:	12 97       	sbiw	r26, 0x02	; 2
     f2e:	d1 83       	std	Z+1, r29	; 0x01
     f30:	c0 83       	st	Z, r28
     f32:	9d cf       	rjmp	.-198    	; 0xe6e <chMtxLockS+0x3e>
     f34:	ea 81       	ldd	r30, Y+2	; 0x02
     f36:	fb 81       	ldd	r31, Y+3	; 0x03
     f38:	88 81       	ld	r24, Y
     f3a:	99 81       	ldd	r25, Y+1	; 0x01
     f3c:	91 83       	std	Z+1, r25	; 0x01
     f3e:	80 83       	st	Z, r24
     f40:	a8 81       	ld	r26, Y
     f42:	b9 81       	ldd	r27, Y+1	; 0x01
     f44:	13 96       	adiw	r26, 0x03	; 3
     f46:	fc 93       	st	X, r31
     f48:	ee 93       	st	-X, r30
     f4a:	12 97       	sbiw	r26, 0x02	; 2
     f4c:	aa 89       	ldd	r26, Y+18	; 0x12
     f4e:	bb 89       	ldd	r27, Y+19	; 0x13
     f50:	9d 01       	movw	r18, r26
     f52:	fd 01       	movw	r30, r26
     f54:	01 90       	ld	r0, Z+
     f56:	f0 81       	ld	r31, Z
     f58:	e0 2d       	mov	r30, r0
     f5a:	ae 17       	cp	r26, r30
     f5c:	bf 07       	cpc	r27, r31
     f5e:	29 f0       	breq	.+10     	; 0xf6a <chMtxLockS+0x13a>
     f60:	94 81       	ldd	r25, Z+4	; 0x04
     f62:	8c 81       	ldd	r24, Y+4	; 0x04
     f64:	98 17       	cp	r25, r24
     f66:	b0 f7       	brcc	.-20     	; 0xf54 <chMtxLockS+0x124>
     f68:	9f 01       	movw	r18, r30
     f6a:	39 83       	std	Y+1, r19	; 0x01
     f6c:	28 83       	st	Y, r18
     f6e:	f9 01       	movw	r30, r18
     f70:	82 81       	ldd	r24, Z+2	; 0x02
     f72:	93 81       	ldd	r25, Z+3	; 0x03
     f74:	9b 83       	std	Y+3, r25	; 0x03
     f76:	8a 83       	std	Y+2, r24	; 0x02
     f78:	d3 83       	std	Z+3, r29	; 0x03
     f7a:	c2 83       	std	Z+2, r28	; 0x02
     f7c:	fc 01       	movw	r30, r24
     f7e:	d1 83       	std	Z+1, r29	; 0x01
     f80:	c0 83       	st	Z, r28
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
      case THD_STATE_WTMTX:
        /* Re-enqueues the mutex owner with its new priority.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
        tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
     f82:	14 96       	adiw	r26, 0x04	; 4
     f84:	cd 91       	ld	r28, X+
     f86:	dc 91       	ld	r29, X
     f88:	15 97       	sbiw	r26, 0x05	; 5
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
     f8a:	f8 01       	movw	r30, r16
     f8c:	94 81       	ldd	r25, Z+4	; 0x04
     f8e:	8c 81       	ldd	r24, Y+4	; 0x04
     f90:	89 17       	cp	r24, r25
     f92:	08 f4       	brcc	.+2      	; 0xf96 <chMtxLockS+0x166>
     f94:	63 cf       	rjmp	.-314    	; 0xe5c <chMtxLockS+0x2c>
     f96:	6b cf       	rjmp	.-298    	; 0xe6e <chMtxLockS+0x3e>
    chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
    chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
  }
  else {
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
     f98:	fc 01       	movw	r30, r24
     f9a:	15 83       	std	Z+5, r17	; 0x05
     f9c:	04 83       	std	Z+4, r16	; 0x04
    mp->m_next = ctp->p_mtxlist;
     f9e:	e8 01       	movw	r28, r16
     fa0:	8d 8d       	ldd	r24, Y+29	; 0x1d
     fa2:	9e 8d       	ldd	r25, Y+30	; 0x1e
     fa4:	97 83       	std	Z+7, r25	; 0x07
     fa6:	86 83       	std	Z+6, r24	; 0x06
    ctp->p_mtxlist = mp;
     fa8:	fe 8e       	std	Y+30, r15	; 0x1e
     faa:	ed 8e       	std	Y+29, r14	; 0x1d
  }
}
     fac:	df 91       	pop	r29
     fae:	cf 91       	pop	r28
     fb0:	1f 91       	pop	r17
     fb2:	0f 91       	pop	r16
     fb4:	ff 90       	pop	r15
     fb6:	ef 90       	pop	r14
     fb8:	08 95       	ret

00000fba <chMtxLock>:
 *
 * @api
 */
void chMtxLock(Mutex *mp) {

  chSysLock();
     fba:	f8 94       	cli

  chMtxLockS(mp);
     fbc:	0e 94 18 07 	call	0xe30	; 0xe30 <chMtxLockS>

  chSysUnlock();
     fc0:	78 94       	sei
}
     fc2:	08 95       	ret

00000fc4 <chCondInit>:
 *
 * @param[out] cp       pointer to a @p CondVar structure
 *
 * @init
 */
void chCondInit(CondVar *cp) {
     fc4:	fc 01       	movw	r30, r24

  chDbgCheck(cp != NULL, "chCondInit");

  queue_init(&cp->c_queue);
     fc6:	82 83       	std	Z+2, r24	; 0x02
     fc8:	f3 83       	std	Z+3, r31	; 0x03
     fca:	80 83       	st	Z, r24
     fcc:	f1 83       	std	Z+1, r31	; 0x01
}
     fce:	08 95       	ret

00000fd0 <chCondWaitTimeoutS>:
 * @retval RDY_TIMEOUT  if the condvar has not been signaled within the
 *                      specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(CondVar *cp, systime_t time) {
     fd0:	cf 92       	push	r12
     fd2:	df 92       	push	r13
     fd4:	ef 92       	push	r14
     fd6:	ff 92       	push	r15
     fd8:	0f 93       	push	r16
     fda:	1f 93       	push	r17
     fdc:	cf 93       	push	r28
     fde:	df 93       	push	r29
     fe0:	18 2f       	mov	r17, r24
     fe2:	09 2f       	mov	r16, r25
     fe4:	7b 01       	movw	r14, r22
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE), "chCondWaitTimeoutS");
  chDbgAssert(currp->p_mtxlist != NULL,
              "chCondWaitTimeoutS(), #1",
              "not owning a mutex");

  mp = chMtxUnlockS();
     fe6:	0e 94 31 06 	call	0xc62	; 0xc62 <chMtxUnlockS>
     fea:	6c 01       	movw	r12, r24
  currp->p_u.wtobjp = cp;
     fec:	a0 91 fe 0b 	lds	r26, 0x0BFE
     ff0:	b0 91 ff 0b 	lds	r27, 0x0BFF
     ff4:	52 96       	adiw	r26, 0x12	; 18
     ff6:	1c 93       	st	X, r17
     ff8:	52 97       	sbiw	r26, 0x12	; 18
     ffa:	53 96       	adiw	r26, 0x13	; 19
     ffc:	0c 93       	st	X, r16
     ffe:	53 97       	sbiw	r26, 0x13	; 19
    1000:	21 2f       	mov	r18, r17
    1002:	30 2f       	mov	r19, r16
    1004:	e9 01       	movw	r28, r18
    1006:	f9 01       	movw	r30, r18
    1008:	01 90       	ld	r0, Z+
    100a:	f0 81       	ld	r31, Z
    100c:	e0 2d       	mov	r30, r0
    100e:	2e 17       	cp	r18, r30
    1010:	3f 07       	cpc	r19, r31
    1012:	39 f0       	breq	.+14     	; 0x1022 <chCondWaitTimeoutS+0x52>
    1014:	94 81       	ldd	r25, Z+4	; 0x04
    1016:	14 96       	adiw	r26, 0x04	; 4
    1018:	8c 91       	ld	r24, X
    101a:	14 97       	sbiw	r26, 0x04	; 4
    101c:	98 17       	cp	r25, r24
    101e:	a0 f7       	brcc	.-24     	; 0x1008 <chCondWaitTimeoutS+0x38>
    1020:	ef 01       	movw	r28, r30
    1022:	11 96       	adiw	r26, 0x01	; 1
    1024:	dc 93       	st	X, r29
    1026:	ce 93       	st	-X, r28
    1028:	ea 81       	ldd	r30, Y+2	; 0x02
    102a:	fb 81       	ldd	r31, Y+3	; 0x03
    102c:	13 96       	adiw	r26, 0x03	; 3
    102e:	fc 93       	st	X, r31
    1030:	ee 93       	st	-X, r30
    1032:	12 97       	sbiw	r26, 0x02	; 2
    1034:	bb 83       	std	Y+3, r27	; 0x03
    1036:	aa 83       	std	Y+2, r26	; 0x02
    1038:	b1 83       	std	Z+1, r27	; 0x01
    103a:	a0 83       	st	Z, r26
  prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(THD_STATE_WTCOND, time);
    103c:	85 e0       	ldi	r24, 0x05	; 5
    103e:	b7 01       	movw	r22, r14
    1040:	0e 94 21 03 	call	0x642	; 0x642 <chSchGoSleepTimeoutS>
    1044:	8c 01       	movw	r16, r24
  if (msg != RDY_TIMEOUT)
    1046:	8f ef       	ldi	r24, 0xFF	; 255
    1048:	0f 3f       	cpi	r16, 0xFF	; 255
    104a:	18 07       	cpc	r17, r24
    104c:	19 f0       	breq	.+6      	; 0x1054 <chCondWaitTimeoutS+0x84>
    chMtxLockS(mp);
    104e:	c6 01       	movw	r24, r12
    1050:	0e 94 18 07 	call	0xe30	; 0xe30 <chMtxLockS>
  return msg;
}
    1054:	c8 01       	movw	r24, r16
    1056:	df 91       	pop	r29
    1058:	cf 91       	pop	r28
    105a:	1f 91       	pop	r17
    105c:	0f 91       	pop	r16
    105e:	ff 90       	pop	r15
    1060:	ef 90       	pop	r14
    1062:	df 90       	pop	r13
    1064:	cf 90       	pop	r12
    1066:	08 95       	ret

00001068 <chCondWaitTimeout>:
 * @api
 */
msg_t chCondWaitTimeout(CondVar *cp, systime_t time) {
  msg_t msg;

  chSysLock();
    1068:	f8 94       	cli
  msg = chCondWaitTimeoutS(cp, time);
    106a:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <chCondWaitTimeoutS>
  chSysUnlock();
    106e:	78 94       	sei
  return msg;
}
    1070:	08 95       	ret

00001072 <chCondWaitS>:
 * @retval RDY_RESET    if the condvar has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(CondVar *cp) {
    1072:	ef 92       	push	r14
    1074:	ff 92       	push	r15
    1076:	0f 93       	push	r16
    1078:	1f 93       	push	r17
    107a:	cf 93       	push	r28
    107c:	df 93       	push	r29
    107e:	18 2f       	mov	r17, r24
    1080:	09 2f       	mov	r16, r25
  Thread *ctp = currp;
    1082:	c0 91 fe 0b 	lds	r28, 0x0BFE
    1086:	d0 91 ff 0b 	lds	r29, 0x0BFF
  chDbgCheck(cp != NULL, "chCondWaitS");
  chDbgAssert(ctp->p_mtxlist != NULL,
              "chCondWaitS(), #1",
              "not owning a mutex");

  mp = chMtxUnlockS();
    108a:	0e 94 31 06 	call	0xc62	; 0xc62 <chMtxUnlockS>
    108e:	7c 01       	movw	r14, r24
  ctp->p_u.wtobjp = cp;
    1090:	1a 8b       	std	Y+18, r17	; 0x12
    1092:	0b 8b       	std	Y+19, r16	; 0x13
    1094:	21 2f       	mov	r18, r17
    1096:	30 2f       	mov	r19, r16
    1098:	d9 01       	movw	r26, r18
    109a:	f9 01       	movw	r30, r18
    109c:	01 90       	ld	r0, Z+
    109e:	f0 81       	ld	r31, Z
    10a0:	e0 2d       	mov	r30, r0
    10a2:	2e 17       	cp	r18, r30
    10a4:	3f 07       	cpc	r19, r31
    10a6:	29 f0       	breq	.+10     	; 0x10b2 <chCondWaitS+0x40>
    10a8:	94 81       	ldd	r25, Z+4	; 0x04
    10aa:	8c 81       	ldd	r24, Y+4	; 0x04
    10ac:	98 17       	cp	r25, r24
    10ae:	b0 f7       	brcc	.-20     	; 0x109c <chCondWaitS+0x2a>
    10b0:	df 01       	movw	r26, r30
    10b2:	b9 83       	std	Y+1, r27	; 0x01
    10b4:	a8 83       	st	Y, r26
    10b6:	12 96       	adiw	r26, 0x02	; 2
    10b8:	ed 91       	ld	r30, X+
    10ba:	fc 91       	ld	r31, X
    10bc:	13 97       	sbiw	r26, 0x03	; 3
    10be:	fb 83       	std	Y+3, r31	; 0x03
    10c0:	ea 83       	std	Y+2, r30	; 0x02
    10c2:	13 96       	adiw	r26, 0x03	; 3
    10c4:	dc 93       	st	X, r29
    10c6:	ce 93       	st	-X, r28
    10c8:	12 97       	sbiw	r26, 0x02	; 2
    10ca:	d1 83       	std	Z+1, r29	; 0x01
    10cc:	c0 83       	st	Z, r28
  prio_insert(ctp, &cp->c_queue);
  chSchGoSleepS(THD_STATE_WTCOND);
    10ce:	85 e0       	ldi	r24, 0x05	; 5
    10d0:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
    10d4:	1a 89       	ldd	r17, Y+18	; 0x12
    10d6:	0b 89       	ldd	r16, Y+19	; 0x13
  chMtxLockS(mp);
    10d8:	c7 01       	movw	r24, r14
    10da:	0e 94 18 07 	call	0xe30	; 0xe30 <chMtxLockS>
  return msg;
}
    10de:	81 2f       	mov	r24, r17
    10e0:	90 2f       	mov	r25, r16
    10e2:	df 91       	pop	r29
    10e4:	cf 91       	pop	r28
    10e6:	1f 91       	pop	r17
    10e8:	0f 91       	pop	r16
    10ea:	ff 90       	pop	r15
    10ec:	ef 90       	pop	r14
    10ee:	08 95       	ret

000010f0 <chCondWait>:
 * @api
 */
msg_t chCondWait(CondVar *cp) {
  msg_t msg;

  chSysLock();
    10f0:	f8 94       	cli
  msg = chCondWaitS(cp);
    10f2:	0e 94 39 08 	call	0x1072	; 0x1072 <chCondWaitS>
  chSysUnlock();
    10f6:	78 94       	sei
  return msg;
}
    10f8:	08 95       	ret

000010fa <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @iclass
 */
void chCondBroadcastI(CondVar *cp) {
    10fa:	ef 92       	push	r14
    10fc:	ff 92       	push	r15
    10fe:	0f 93       	push	r16
    1100:	1f 93       	push	r17
    1102:	cf 93       	push	r28
    1104:	df 93       	push	r29
    1106:	ec 01       	movw	r28, r24
  chDbgCheck(cp != NULL, "chCondBroadcastI");

  /* Empties the condition variable queue and inserts all the Threads into the
     ready list in FIFO order. The wakeup message is set to @p RDY_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (cp->c_queue.p_next != (void *)&cp->c_queue)
    1108:	a8 81       	ld	r26, Y
    110a:	b9 81       	ldd	r27, Y+1	; 0x01
    110c:	a8 17       	cp	r26, r24
    110e:	b9 07       	cpc	r27, r25
    1110:	a9 f0       	breq	.+42     	; 0x113c <chCondBroadcastI+0x42>
    1112:	7c 01       	movw	r14, r24
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_RESET;
    1114:	0e ef       	ldi	r16, 0xFE	; 254
    1116:	1f ef       	ldi	r17, 0xFF	; 255
    1118:	ed 91       	ld	r30, X+
    111a:	fc 91       	ld	r31, X
    111c:	11 97       	sbiw	r26, 0x01	; 1
    111e:	f9 83       	std	Y+1, r31	; 0x01
    1120:	e8 83       	st	Y, r30
    1122:	e2 82       	std	Z+2, r14	; 0x02
    1124:	f3 82       	std	Z+3, r15	; 0x03
    1126:	cd 01       	movw	r24, r26
    1128:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
    112c:	fc 01       	movw	r30, r24
    112e:	13 8b       	std	Z+19, r17	; 0x13
    1130:	02 8b       	std	Z+18, r16	; 0x12
  chDbgCheck(cp != NULL, "chCondBroadcastI");

  /* Empties the condition variable queue and inserts all the Threads into the
     ready list in FIFO order. The wakeup message is set to @p RDY_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (cp->c_queue.p_next != (void *)&cp->c_queue)
    1132:	a8 81       	ld	r26, Y
    1134:	b9 81       	ldd	r27, Y+1	; 0x01
    1136:	ac 17       	cp	r26, r28
    1138:	bd 07       	cpc	r27, r29
    113a:	71 f7       	brne	.-36     	; 0x1118 <chCondBroadcastI+0x1e>
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_RESET;
}
    113c:	df 91       	pop	r29
    113e:	cf 91       	pop	r28
    1140:	1f 91       	pop	r17
    1142:	0f 91       	pop	r16
    1144:	ff 90       	pop	r15
    1146:	ef 90       	pop	r14
    1148:	08 95       	ret

0000114a <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @iclass
 */
void chCondSignalI(CondVar *cp) {
    114a:	cf 93       	push	r28
    114c:	df 93       	push	r29
    114e:	dc 01       	movw	r26, r24

  chDbgCheckClassI();
  chDbgCheck(cp != NULL, "chCondSignalI");

  if (notempty(&cp->c_queue))
    1150:	cd 91       	ld	r28, X+
    1152:	dc 91       	ld	r29, X
    1154:	11 97       	sbiw	r26, 0x01	; 1
    1156:	c8 17       	cp	r28, r24
    1158:	d9 07       	cpc	r29, r25
    115a:	61 f0       	breq	.+24     	; 0x1174 <chCondSignalI+0x2a>
    115c:	e8 81       	ld	r30, Y
    115e:	f9 81       	ldd	r31, Y+1	; 0x01
    1160:	ed 93       	st	X+, r30
    1162:	fc 93       	st	X, r31
    1164:	93 83       	std	Z+3, r25	; 0x03
    1166:	82 83       	std	Z+2, r24	; 0x02
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_OK;
    1168:	ce 01       	movw	r24, r28
    116a:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
    116e:	fc 01       	movw	r30, r24
    1170:	13 8a       	std	Z+19, r1	; 0x13
    1172:	12 8a       	std	Z+18, r1	; 0x12
}
    1174:	df 91       	pop	r29
    1176:	cf 91       	pop	r28
    1178:	08 95       	ret

0000117a <chCondBroadcast>:
 *
 * @api
 */
void chCondBroadcast(CondVar *cp) {

  chSysLock();
    117a:	f8 94       	cli
  chCondBroadcastI(cp);
    117c:	0e 94 7d 08 	call	0x10fa	; 0x10fa <chCondBroadcastI>
  chSchRescheduleS();
    1180:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  chSysUnlock();
    1184:	78 94       	sei
}
    1186:	08 95       	ret

00001188 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @api
 */
void chCondSignal(CondVar *cp) {
    1188:	cf 93       	push	r28
    118a:	df 93       	push	r29
    118c:	dc 01       	movw	r26, r24

  chDbgCheck(cp != NULL, "chCondSignal");

  chSysLock();
    118e:	f8 94       	cli
  if (notempty(&cp->c_queue))
    1190:	cd 91       	ld	r28, X+
    1192:	dc 91       	ld	r29, X
    1194:	11 97       	sbiw	r26, 0x01	; 1
    1196:	c8 17       	cp	r28, r24
    1198:	d9 07       	cpc	r29, r25
    119a:	59 f0       	breq	.+22     	; 0x11b2 <chCondSignal+0x2a>
    119c:	e8 81       	ld	r30, Y
    119e:	f9 81       	ldd	r31, Y+1	; 0x01
    11a0:	ed 93       	st	X+, r30
    11a2:	fc 93       	st	X, r31
    11a4:	93 83       	std	Z+3, r25	; 0x03
    11a6:	82 83       	std	Z+2, r24	; 0x02
    chSchWakeupS(fifo_remove(&cp->c_queue), RDY_OK);
    11a8:	ce 01       	movw	r24, r28
    11aa:	60 e0       	ldi	r22, 0x00	; 0
    11ac:	70 e0       	ldi	r23, 0x00	; 0
    11ae:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
  chSysUnlock();
    11b2:	78 94       	sei
}
    11b4:	df 91       	pop	r29
    11b6:	cf 91       	pop	r28
    11b8:	08 95       	ret

000011ba <chEvtRegisterMask>:
 * @param[in] mask      the mask of event flags to be ORed to the thread when
 *                      the event source is broadcasted
 *
 * @api
 */
void chEvtRegisterMask(EventSource *esp, EventListener *elp, eventmask_t mask) {
    11ba:	dc 01       	movw	r26, r24
    11bc:	fb 01       	movw	r30, r22

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtRegisterMask");

  chSysLock();
    11be:	f8 94       	cli
  elp->el_next     = esp->es_next;
    11c0:	8d 91       	ld	r24, X+
    11c2:	9c 91       	ld	r25, X
    11c4:	11 97       	sbiw	r26, 0x01	; 1
    11c6:	91 83       	std	Z+1, r25	; 0x01
    11c8:	80 83       	st	Z, r24
  esp->es_next     = elp;
    11ca:	6d 93       	st	X+, r22
    11cc:	7c 93       	st	X, r23
  elp->el_listener = currp;
    11ce:	80 91 fe 0b 	lds	r24, 0x0BFE
    11d2:	90 91 ff 0b 	lds	r25, 0x0BFF
    11d6:	93 83       	std	Z+3, r25	; 0x03
    11d8:	82 83       	std	Z+2, r24	; 0x02
  elp->el_mask     = mask;
    11da:	44 83       	std	Z+4, r20	; 0x04
  elp->el_flags    = 0;
    11dc:	15 82       	std	Z+5, r1	; 0x05
  chSysUnlock();
    11de:	78 94       	sei
}
    11e0:	08 95       	ret

000011e2 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p EventSource structure
 * @param[in] elp       pointer to the @p EventListener structure
 *
 * @api
 */
void chEvtUnregister(EventSource *esp, EventListener *elp) {
    11e2:	db 01       	movw	r26, r22
  EventListener *p;

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
    11e4:	9c 01       	movw	r18, r24
  chSysLock();
    11e6:	f8 94       	cli
    11e8:	fc 01       	movw	r30, r24
    11ea:	04 c0       	rjmp	.+8      	; 0x11f4 <chEvtUnregister+0x12>
  while (p->el_next != (EventListener *)esp) {
    if (p->el_next == elp) {
    11ec:	a8 17       	cp	r26, r24
    11ee:	b9 07       	cpc	r27, r25
    11f0:	41 f0       	breq	.+16     	; 0x1202 <chEvtUnregister+0x20>
      p->el_next = elp->el_next;
      break;
    11f2:	fc 01       	movw	r30, r24

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
  chSysLock();
  while (p->el_next != (EventListener *)esp) {
    11f4:	80 81       	ld	r24, Z
    11f6:	91 81       	ldd	r25, Z+1	; 0x01
    11f8:	28 17       	cp	r18, r24
    11fa:	39 07       	cpc	r19, r25
    11fc:	b9 f7       	brne	.-18     	; 0x11ec <chEvtUnregister+0xa>
      p->el_next = elp->el_next;
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
    11fe:	78 94       	sei
}
    1200:	08 95       	ret

  p = (EventListener *)esp;
  chSysLock();
  while (p->el_next != (EventListener *)esp) {
    if (p->el_next == elp) {
      p->el_next = elp->el_next;
    1202:	8d 91       	ld	r24, X+
    1204:	9c 91       	ld	r25, X
    1206:	91 83       	std	Z+1, r25	; 0x01
    1208:	80 83       	st	Z, r24
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
    120a:	78 94       	sei
}
    120c:	08 95       	ret

0000120e <chEvtGetAndClearEvents>:
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t mask) {
  eventmask_t m;

  chSysLock();
    120e:	f8 94       	cli

  m = currp->p_epending & mask;
    1210:	e0 91 fe 0b 	lds	r30, 0x0BFE
    1214:	f0 91 ff 0b 	lds	r31, 0x0BFF
    1218:	24 8d       	ldd	r18, Z+28	; 0x1c
  currp->p_epending &= ~mask;
    121a:	98 2f       	mov	r25, r24
    121c:	90 95       	com	r25
    121e:	92 23       	and	r25, r18
    1220:	94 8f       	std	Z+28, r25	; 0x1c

  chSysUnlock();
    1222:	78 94       	sei
  return m;
}
    1224:	82 23       	and	r24, r18
    1226:	08 95       	ret

00001228 <chEvtAddEvents>:
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t mask) {

  chSysLock();
    1228:	f8 94       	cli

  mask = (currp->p_epending |= mask);
    122a:	e0 91 fe 0b 	lds	r30, 0x0BFE
    122e:	f0 91 ff 0b 	lds	r31, 0x0BFF
    1232:	94 8d       	ldd	r25, Z+28	; 0x1c
    1234:	89 2b       	or	r24, r25
    1236:	84 8f       	std	Z+28, r24	; 0x1c

  chSysUnlock();
    1238:	78 94       	sei
  return mask;
}
    123a:	08 95       	ret

0000123c <chEvtGetAndClearFlags>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
flagsmask_t chEvtGetAndClearFlags(EventListener *elp) {
    123c:	fc 01       	movw	r30, r24
  flagsmask_t flags;

  chSysLock();
    123e:	f8 94       	cli

  flags = elp->el_flags;
    1240:	85 81       	ldd	r24, Z+5	; 0x05
  elp->el_flags = 0;
    1242:	15 82       	std	Z+5, r1	; 0x05

  chSysUnlock();
    1244:	78 94       	sei
  return flags;
}
    1246:	08 95       	ret

00001248 <chEvtGetAndClearFlagsI>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
flagsmask_t chEvtGetAndClearFlagsI(EventListener *elp) {
    1248:	fc 01       	movw	r30, r24
  flagsmask_t flags;

  flags = elp->el_flags;
    124a:	85 81       	ldd	r24, Z+5	; 0x05
  elp->el_flags = 0;
    124c:	15 82       	std	Z+5, r1	; 0x05

  return flags;
}
    124e:	08 95       	ret

00001250 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t mask) {
    1250:	ef 92       	push	r14
    1252:	ff 92       	push	r15
    1254:	0f 93       	push	r16
    1256:	1f 93       	push	r17
    1258:	cf 93       	push	r28
    125a:	df 93       	push	r29
    125c:	7c 01       	movw	r14, r24
    125e:	06 2f       	mov	r16, r22
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    1260:	66 23       	and	r22, r22
    1262:	09 f1       	breq	.+66     	; 0x12a6 <chEvtDispatch+0x56>
    1264:	10 e0       	ldi	r17, 0x00	; 0
    if (mask & EVENT_MASK(eid)) {
    1266:	c1 e0       	ldi	r28, 0x01	; 1
    1268:	d0 e0       	ldi	r29, 0x00	; 0
    126a:	03 c0       	rjmp	.+6      	; 0x1272 <chEvtDispatch+0x22>
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    126c:	00 23       	and	r16, r16
    126e:	d9 f0       	breq	.+54     	; 0x12a6 <chEvtDispatch+0x56>
                  "chEvtDispatch(), #1",
                  "null handler");
      mask &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
    1270:	1f 5f       	subi	r17, 0xFF	; 255

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    if (mask & EVENT_MASK(eid)) {
    1272:	9e 01       	movw	r18, r28
    1274:	01 2e       	mov	r0, r17
    1276:	02 c0       	rjmp	.+4      	; 0x127c <chEvtDispatch+0x2c>
    1278:	22 0f       	add	r18, r18
    127a:	33 1f       	adc	r19, r19
    127c:	0a 94       	dec	r0
    127e:	e2 f7       	brpl	.-8      	; 0x1278 <chEvtDispatch+0x28>
    1280:	80 2f       	mov	r24, r16
    1282:	82 23       	and	r24, r18
    1284:	99 f3       	breq	.-26     	; 0x126c <chEvtDispatch+0x1c>
      chDbgAssert(handlers[eid] != NULL,
                  "chEvtDispatch(), #1",
                  "null handler");
      mask &= ~EVENT_MASK(eid);
    1286:	82 2f       	mov	r24, r18
    1288:	80 95       	com	r24
    128a:	08 23       	and	r16, r24
      handlers[eid](eid);
    128c:	e1 2f       	mov	r30, r17
    128e:	f0 e0       	ldi	r31, 0x00	; 0
    1290:	ee 0f       	add	r30, r30
    1292:	ff 1f       	adc	r31, r31
    1294:	ee 0d       	add	r30, r14
    1296:	ff 1d       	adc	r31, r15
    1298:	01 90       	ld	r0, Z+
    129a:	f0 81       	ld	r31, Z
    129c:	e0 2d       	mov	r30, r0
    129e:	81 2f       	mov	r24, r17
    12a0:	09 95       	icall
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    12a2:	00 23       	and	r16, r16
    12a4:	29 f7       	brne	.-54     	; 0x1270 <chEvtDispatch+0x20>
      mask &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
    12a6:	df 91       	pop	r29
    12a8:	cf 91       	pop	r28
    12aa:	1f 91       	pop	r17
    12ac:	0f 91       	pop	r16
    12ae:	ff 90       	pop	r15
    12b0:	ef 90       	pop	r14
    12b2:	08 95       	ret

000012b4 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t mask, systime_t time) {
    12b4:	1f 93       	push	r17
    12b6:	cf 93       	push	r28
    12b8:	df 93       	push	r29
    12ba:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    12bc:	c0 91 fe 0b 	lds	r28, 0x0BFE
    12c0:	d0 91 ff 0b 	lds	r29, 0x0BFF

  chSysLock();
    12c4:	f8 94       	cli

  if ((ctp->p_epending & mask) != mask) {
    12c6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    12c8:	89 23       	and	r24, r25
    12ca:	81 17       	cp	r24, r17
    12cc:	89 f0       	breq	.+34     	; 0x12f0 <chEvtWaitAllTimeout+0x3c>
    if (TIME_IMMEDIATE == time) {
    12ce:	61 15       	cp	r22, r1
    12d0:	71 05       	cpc	r23, r1
    12d2:	39 f4       	brne	.+14     	; 0x12e2 <chEvtWaitAllTimeout+0x2e>
      chSysUnlock();
    12d4:	78 94       	sei
    12d6:	10 e0       	ldi	r17, 0x00	; 0
  }
  ctp->p_epending &= ~mask;

  chSysUnlock();
  return mask;
}
    12d8:	81 2f       	mov	r24, r17
    12da:	df 91       	pop	r29
    12dc:	cf 91       	pop	r28
    12de:	1f 91       	pop	r17
    12e0:	08 95       	ret
  if ((ctp->p_epending & mask) != mask) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    12e2:	1a 8b       	std	Y+18, r17	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTANDEVT, time) < RDY_OK) {
    12e4:	89 e0       	ldi	r24, 0x09	; 9
    12e6:	0e 94 21 03 	call	0x642	; 0x642 <chSchGoSleepTimeoutS>
    12ea:	97 fd       	sbrc	r25, 7
    12ec:	0b c0       	rjmp	.+22     	; 0x1304 <chEvtWaitAllTimeout+0x50>
    12ee:	9c 8d       	ldd	r25, Y+28	; 0x1c
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~mask;
    12f0:	81 2f       	mov	r24, r17
    12f2:	80 95       	com	r24
    12f4:	98 23       	and	r25, r24
    12f6:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    12f8:	78 94       	sei
  return mask;
}
    12fa:	81 2f       	mov	r24, r17
    12fc:	df 91       	pop	r29
    12fe:	cf 91       	pop	r28
    1300:	1f 91       	pop	r17
    1302:	08 95       	ret
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    if (chSchGoSleepTimeoutS(THD_STATE_WTANDEVT, time) < RDY_OK) {
      chSysUnlock();
    1304:	78 94       	sei
    1306:	10 e0       	ldi	r17, 0x00	; 0
    1308:	e7 cf       	rjmp	.-50     	; 0x12d8 <chEvtWaitAllTimeout+0x24>

0000130a <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t time) {
    130a:	0f 93       	push	r16
    130c:	1f 93       	push	r17
    130e:	cf 93       	push	r28
    1310:	df 93       	push	r29
    1312:	08 2f       	mov	r16, r24
  Thread *ctp = currp;
    1314:	c0 91 fe 0b 	lds	r28, 0x0BFE
    1318:	d0 91 ff 0b 	lds	r29, 0x0BFF
  eventmask_t m;

  chSysLock();
    131c:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    131e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1320:	18 2f       	mov	r17, r24
    1322:	19 23       	and	r17, r25
    1324:	99 f4       	brne	.+38     	; 0x134c <chEvtWaitAnyTimeout+0x42>
    if (TIME_IMMEDIATE == time) {
    1326:	61 15       	cp	r22, r1
    1328:	71 05       	cpc	r23, r1
    132a:	39 f4       	brne	.+14     	; 0x133a <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
    132c:	78 94       	sei
  }
  ctp->p_epending &= ~m;

  chSysUnlock();
  return m;
}
    132e:	81 2f       	mov	r24, r17
    1330:	df 91       	pop	r29
    1332:	cf 91       	pop	r28
    1334:	1f 91       	pop	r17
    1336:	0f 91       	pop	r16
    1338:	08 95       	ret
  if ((m = (ctp->p_epending & mask)) == 0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    133a:	8a 8b       	std	Y+18, r24	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
    133c:	88 e0       	ldi	r24, 0x08	; 8
    133e:	0e 94 21 03 	call	0x642	; 0x642 <chSchGoSleepTimeoutS>
    1342:	97 fd       	sbrc	r25, 7
    1344:	0e c0       	rjmp	.+28     	; 0x1362 <chEvtWaitAnyTimeout+0x58>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & mask;
    1346:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1348:	10 2f       	mov	r17, r16
    134a:	19 23       	and	r17, r25
  }
  ctp->p_epending &= ~m;
    134c:	81 2f       	mov	r24, r17
    134e:	80 95       	com	r24
    1350:	89 23       	and	r24, r25
    1352:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    1354:	78 94       	sei
  return m;
}
    1356:	81 2f       	mov	r24, r17
    1358:	df 91       	pop	r29
    135a:	cf 91       	pop	r28
    135c:	1f 91       	pop	r17
    135e:	0f 91       	pop	r16
    1360:	08 95       	ret
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
      chSysUnlock();
    1362:	78 94       	sei
    1364:	f8 cf       	rjmp	.-16     	; 0x1356 <chEvtWaitAnyTimeout+0x4c>

00001366 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest id served and cleared event.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t mask, systime_t time) {
    1366:	0f 93       	push	r16
    1368:	1f 93       	push	r17
    136a:	cf 93       	push	r28
    136c:	df 93       	push	r29
    136e:	08 2f       	mov	r16, r24
  Thread *ctp = currp;
    1370:	c0 91 fe 0b 	lds	r28, 0x0BFE
    1374:	d0 91 ff 0b 	lds	r29, 0x0BFF
  eventmask_t m;

  chSysLock();
    1378:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    137a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    137c:	18 2f       	mov	r17, r24
    137e:	19 23       	and	r17, r25
    1380:	99 f4       	brne	.+38     	; 0x13a8 <chEvtWaitOneTimeout+0x42>
    if (TIME_IMMEDIATE == time) {
    1382:	61 15       	cp	r22, r1
    1384:	71 05       	cpc	r23, r1
    1386:	39 f4       	brne	.+14     	; 0x1396 <chEvtWaitOneTimeout+0x30>
      chSysUnlock();
    1388:	78 94       	sei
  m &= -m;
  ctp->p_epending &= ~m;

  chSysUnlock();
  return m;
}
    138a:	81 2f       	mov	r24, r17
    138c:	df 91       	pop	r29
    138e:	cf 91       	pop	r28
    1390:	1f 91       	pop	r17
    1392:	0f 91       	pop	r16
    1394:	08 95       	ret
  if ((m = (ctp->p_epending & mask)) == 0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    1396:	8a 8b       	std	Y+18, r24	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
    1398:	88 e0       	ldi	r24, 0x08	; 8
    139a:	0e 94 21 03 	call	0x642	; 0x642 <chSchGoSleepTimeoutS>
    139e:	97 fd       	sbrc	r25, 7
    13a0:	11 c0       	rjmp	.+34     	; 0x13c4 <chEvtWaitOneTimeout+0x5e>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & mask;
    13a2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    13a4:	10 2f       	mov	r17, r16
    13a6:	19 23       	and	r17, r25
  }
  m &= -m;
    13a8:	81 2f       	mov	r24, r17
    13aa:	81 95       	neg	r24
    13ac:	18 23       	and	r17, r24
  ctp->p_epending &= ~m;
    13ae:	81 2f       	mov	r24, r17
    13b0:	80 95       	com	r24
    13b2:	89 23       	and	r24, r25
    13b4:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    13b6:	78 94       	sei
  return m;
}
    13b8:	81 2f       	mov	r24, r17
    13ba:	df 91       	pop	r29
    13bc:	cf 91       	pop	r28
    13be:	1f 91       	pop	r17
    13c0:	0f 91       	pop	r16
    13c2:	08 95       	ret
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
      chSysUnlock();
    13c4:	78 94       	sei
    13c6:	f8 cf       	rjmp	.-16     	; 0x13b8 <chEvtWaitOneTimeout+0x52>

000013c8 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t mask) {
    13c8:	1f 93       	push	r17
    13ca:	cf 93       	push	r28
    13cc:	df 93       	push	r29
    13ce:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    13d0:	c0 91 fe 0b 	lds	r28, 0x0BFE
    13d4:	d0 91 ff 0b 	lds	r29, 0x0BFF

  chSysLock();
    13d8:	f8 94       	cli

  if ((ctp->p_epending & mask) != mask) {
    13da:	9c 8d       	ldd	r25, Y+28	; 0x1c
    13dc:	89 23       	and	r24, r25
    13de:	81 17       	cp	r24, r17
    13e0:	29 f0       	breq	.+10     	; 0x13ec <chEvtWaitAll+0x24>
    ctp->p_u.ewmask = mask;
    13e2:	1a 8b       	std	Y+18, r17	; 0x12
    chSchGoSleepS(THD_STATE_WTANDEVT);
    13e4:	89 e0       	ldi	r24, 0x09	; 9
    13e6:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
    13ea:	9c 8d       	ldd	r25, Y+28	; 0x1c
  }
  ctp->p_epending &= ~mask;
    13ec:	81 2f       	mov	r24, r17
    13ee:	80 95       	com	r24
    13f0:	98 23       	and	r25, r24
    13f2:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    13f4:	78 94       	sei
  return mask;
}
    13f6:	81 2f       	mov	r24, r17
    13f8:	df 91       	pop	r29
    13fa:	cf 91       	pop	r28
    13fc:	1f 91       	pop	r17
    13fe:	08 95       	ret

00001400 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
    1400:	1f 93       	push	r17
    1402:	cf 93       	push	r28
    1404:	df 93       	push	r29
    1406:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    1408:	c0 91 fe 0b 	lds	r28, 0x0BFE
    140c:	d0 91 ff 0b 	lds	r29, 0x0BFF
  eventmask_t m;

  chSysLock();
    1410:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    1412:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1414:	98 2f       	mov	r25, r24
    1416:	92 23       	and	r25, r18
    1418:	39 f4       	brne	.+14     	; 0x1428 <chEvtWaitAny+0x28>
    ctp->p_u.ewmask = mask;
    141a:	8a 8b       	std	Y+18, r24	; 0x12
    chSchGoSleepS(THD_STATE_WTOREVT);
    141c:	88 e0       	ldi	r24, 0x08	; 8
    141e:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
    m = ctp->p_epending & mask;
    1422:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1424:	91 2f       	mov	r25, r17
    1426:	92 23       	and	r25, r18
  }
  ctp->p_epending &= ~m;
    1428:	89 2f       	mov	r24, r25
    142a:	80 95       	com	r24
    142c:	82 23       	and	r24, r18
    142e:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    1430:	78 94       	sei
  return m;
}
    1432:	89 2f       	mov	r24, r25
    1434:	df 91       	pop	r29
    1436:	cf 91       	pop	r28
    1438:	1f 91       	pop	r17
    143a:	08 95       	ret

0000143c <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest id served and cleared event.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t mask) {
    143c:	1f 93       	push	r17
    143e:	cf 93       	push	r28
    1440:	df 93       	push	r29
    1442:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    1444:	c0 91 fe 0b 	lds	r28, 0x0BFE
    1448:	d0 91 ff 0b 	lds	r29, 0x0BFF
  eventmask_t m;

  chSysLock();
    144c:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    144e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1450:	98 2f       	mov	r25, r24
    1452:	92 23       	and	r25, r18
    1454:	39 f4       	brne	.+14     	; 0x1464 <chEvtWaitOne+0x28>
    ctp->p_u.ewmask = mask;
    1456:	8a 8b       	std	Y+18, r24	; 0x12
    chSchGoSleepS(THD_STATE_WTOREVT);
    1458:	88 e0       	ldi	r24, 0x08	; 8
    145a:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
    m = ctp->p_epending & mask;
    145e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1460:	91 2f       	mov	r25, r17
    1462:	92 23       	and	r25, r18
  }
  m &= -m;
    1464:	89 2f       	mov	r24, r25
    1466:	81 95       	neg	r24
    1468:	89 23       	and	r24, r25
  ctp->p_epending &= ~m;
    146a:	98 2f       	mov	r25, r24
    146c:	90 95       	com	r25
    146e:	92 23       	and	r25, r18
    1470:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    1472:	78 94       	sei
  return m;
}
    1474:	df 91       	pop	r29
    1476:	cf 91       	pop	r28
    1478:	1f 91       	pop	r17
    147a:	08 95       	ret

0000147c <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(Thread *tp, eventmask_t mask) {
    147c:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
    147e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1480:	68 2b       	or	r22, r24
    1482:	64 8f       	std	Z+28, r22	; 0x1c
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
    1484:	85 85       	ldd	r24, Z+13	; 0x0d
    1486:	88 30       	cpi	r24, 0x08	; 8
    1488:	71 f0       	breq	.+28     	; 0x14a6 <chEvtSignalI+0x2a>
    148a:	89 30       	cpi	r24, 0x09	; 9
    148c:	09 f0       	breq	.+2      	; 0x1490 <chEvtSignalI+0x14>
    148e:	08 95       	ret
    1490:	82 89       	ldd	r24, Z+18	; 0x12
    1492:	68 23       	and	r22, r24
    1494:	86 17       	cp	r24, r22
    1496:	d9 f7       	brne	.-10     	; 0x148e <chEvtSignalI+0x12>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
    1498:	cf 01       	movw	r24, r30
    149a:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
    149e:	fc 01       	movw	r30, r24
    14a0:	13 8a       	std	Z+19, r1	; 0x13
    14a2:	12 8a       	std	Z+18, r1	; 0x12
    14a4:	08 95       	ret
  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
    14a6:	82 89       	ldd	r24, Z+18	; 0x12
    14a8:	68 23       	and	r22, r24
    14aa:	b1 f7       	brne	.-20     	; 0x1498 <chEvtSignalI+0x1c>
    14ac:	08 95       	ret

000014ae <chEvtSignal>:
 */
void chEvtSignal(Thread *tp, eventmask_t mask) {

  chDbgCheck(tp != NULL, "chEvtSignal");

  chSysLock();
    14ae:	f8 94       	cli
  chEvtSignalI(tp, mask);
    14b0:	0e 94 3e 0a 	call	0x147c	; 0x147c <chEvtSignalI>
  chSchRescheduleS();
    14b4:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  chSysUnlock();
    14b8:	78 94       	sei
}
    14ba:	08 95       	ret

000014bc <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p EventSource structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(EventSource *esp, flagsmask_t flags) {
    14bc:	ff 92       	push	r15
    14be:	0f 93       	push	r16
    14c0:	1f 93       	push	r17
    14c2:	cf 93       	push	r28
    14c4:	df 93       	push	r29
    14c6:	8c 01       	movw	r16, r24
    14c8:	f6 2e       	mov	r15, r22
  EventListener *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
    14ca:	fc 01       	movw	r30, r24
    14cc:	c0 81       	ld	r28, Z
    14ce:	d1 81       	ldd	r29, Z+1	; 0x01
  while (elp != (EventListener *)esp) {
    14d0:	c8 17       	cp	r28, r24
    14d2:	d9 07       	cpc	r29, r25
    14d4:	71 f0       	breq	.+28     	; 0x14f2 <chEvtBroadcastFlagsI+0x36>
    elp->el_flags |= flags;
    14d6:	8d 81       	ldd	r24, Y+5	; 0x05
    14d8:	8f 29       	or	r24, r15
    14da:	8d 83       	std	Y+5, r24	; 0x05
    chEvtSignalI(elp->el_listener, elp->el_mask);
    14dc:	8a 81       	ldd	r24, Y+2	; 0x02
    14de:	9b 81       	ldd	r25, Y+3	; 0x03
    14e0:	6c 81       	ldd	r22, Y+4	; 0x04
    14e2:	0e 94 3e 0a 	call	0x147c	; 0x147c <chEvtSignalI>
    elp = elp->el_next;
    14e6:	09 90       	ld	r0, Y+
    14e8:	d8 81       	ld	r29, Y
    14ea:	c0 2d       	mov	r28, r0

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
  while (elp != (EventListener *)esp) {
    14ec:	c0 17       	cp	r28, r16
    14ee:	d1 07       	cpc	r29, r17
    14f0:	91 f7       	brne	.-28     	; 0x14d6 <chEvtBroadcastFlagsI+0x1a>
    elp->el_flags |= flags;
    chEvtSignalI(elp->el_listener, elp->el_mask);
    elp = elp->el_next;
  }
}
    14f2:	df 91       	pop	r29
    14f4:	cf 91       	pop	r28
    14f6:	1f 91       	pop	r17
    14f8:	0f 91       	pop	r16
    14fa:	ff 90       	pop	r15
    14fc:	08 95       	ret

000014fe <chEvtBroadcastFlags>:
 *
 * @api
 */
void chEvtBroadcastFlags(EventSource *esp, flagsmask_t flags) {

  chSysLock();
    14fe:	f8 94       	cli
  chEvtBroadcastFlagsI(esp, flags);
    1500:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <chEvtBroadcastFlagsI>
  chSchRescheduleS();
    1504:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  chSysUnlock();
    1508:	78 94       	sei
}
    150a:	08 95       	ret

0000150c <chMsgRelease>:
 *
 * @api
 */
void chMsgRelease(Thread *tp, msg_t msg) {

  chSysLock();
    150c:	f8 94       	cli
  chDbgAssert(tp->p_state == THD_STATE_SNDMSG,
              "chMsgRelease(), #1", "invalid state");
  chMsgReleaseS(tp, msg);
    150e:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
  chSysUnlock();
    1512:	78 94       	sei
}
    1514:	08 95       	ret

00001516 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
Thread *chMsgWait(void) {
    1516:	cf 93       	push	r28
    1518:	df 93       	push	r29
  Thread *tp;

  chSysLock();
    151a:	f8 94       	cli
  if (!chMsgIsPendingI(currp))
    151c:	c0 91 fe 0b 	lds	r28, 0x0BFE
    1520:	d0 91 ff 0b 	lds	r29, 0x0BFF
    1524:	ae 89       	ldd	r26, Y+22	; 0x16
    1526:	bf 89       	ldd	r27, Y+23	; 0x17
    1528:	ce 01       	movw	r24, r28
    152a:	46 96       	adiw	r24, 0x16	; 22
    152c:	a8 17       	cp	r26, r24
    152e:	b9 07       	cpc	r27, r25
    1530:	81 f0       	breq	.+32     	; 0x1552 <chMsgWait+0x3c>
    1532:	ed 91       	ld	r30, X+
    1534:	fc 91       	ld	r31, X
    1536:	11 97       	sbiw	r26, 0x01	; 1
    1538:	ff 8b       	std	Y+23, r31	; 0x17
    153a:	ee 8b       	std	Y+22, r30	; 0x16
    153c:	93 83       	std	Z+3, r25	; 0x03
    153e:	82 83       	std	Z+2, r24	; 0x02
    chSchGoSleepS(THD_STATE_WTMSG);
  tp = fifo_remove(&currp->p_msgqueue);
  tp->p_state = THD_STATE_SNDMSG;
    1540:	8b e0       	ldi	r24, 0x0B	; 11
    1542:	1d 96       	adiw	r26, 0x0d	; 13
    1544:	8c 93       	st	X, r24
    1546:	1d 97       	sbiw	r26, 0x0d	; 13
  chSysUnlock();
    1548:	78 94       	sei
  return tp;
}
    154a:	cd 01       	movw	r24, r26
    154c:	df 91       	pop	r29
    154e:	cf 91       	pop	r28
    1550:	08 95       	ret
Thread *chMsgWait(void) {
  Thread *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp))
    chSchGoSleepS(THD_STATE_WTMSG);
    1552:	8c e0       	ldi	r24, 0x0C	; 12
    1554:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
    1558:	c0 91 fe 0b 	lds	r28, 0x0BFE
    155c:	d0 91 ff 0b 	lds	r29, 0x0BFF
    1560:	ae 89       	ldd	r26, Y+22	; 0x16
    1562:	bf 89       	ldd	r27, Y+23	; 0x17
    1564:	ce 01       	movw	r24, r28
    1566:	46 96       	adiw	r24, 0x16	; 22
    1568:	e4 cf       	rjmp	.-56     	; 0x1532 <chMsgWait+0x1c>

0000156a <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(Thread *tp, msg_t msg) {
    156a:	cf 93       	push	r28
    156c:	df 93       	push	r29
    156e:	dc 01       	movw	r26, r24
  Thread *ctp = currp;
    1570:	c0 91 fe 0b 	lds	r28, 0x0BFE
    1574:	d0 91 ff 0b 	lds	r29, 0x0BFF

  chDbgCheck(tp != NULL, "chMsgSend");

  chSysLock();
    1578:	f8 94       	cli
  ctp->p_msg = msg;
    157a:	7b 8f       	std	Y+27, r23	; 0x1b
    157c:	6a 8f       	std	Y+26, r22	; 0x1a
  ctp->p_u.wtobjp = &tp->p_msgqueue;
    157e:	46 96       	adiw	r24, 0x16	; 22
    1580:	9b 8b       	std	Y+19, r25	; 0x13
    1582:	8a 8b       	std	Y+18, r24	; 0x12
    1584:	99 83       	std	Y+1, r25	; 0x01
    1586:	88 83       	st	Y, r24
    1588:	58 96       	adiw	r26, 0x18	; 24
    158a:	ed 91       	ld	r30, X+
    158c:	fc 91       	ld	r31, X
    158e:	59 97       	sbiw	r26, 0x19	; 25
    1590:	fb 83       	std	Y+3, r31	; 0x03
    1592:	ea 83       	std	Y+2, r30	; 0x02
    1594:	59 96       	adiw	r26, 0x19	; 25
    1596:	dc 93       	st	X, r29
    1598:	ce 93       	st	-X, r28
    159a:	58 97       	sbiw	r26, 0x18	; 24
    159c:	d1 83       	std	Z+1, r29	; 0x01
    159e:	c0 83       	st	Z, r28
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == THD_STATE_WTMSG)
    15a0:	1d 96       	adiw	r26, 0x0d	; 13
    15a2:	8c 91       	ld	r24, X
    15a4:	1d 97       	sbiw	r26, 0x0d	; 13
    15a6:	8c 30       	cpi	r24, 0x0C	; 12
    15a8:	49 f0       	breq	.+18     	; 0x15bc <chMsgSend+0x52>
    chSchReadyI(tp);
  chSchGoSleepS(THD_STATE_SNDMSGQ);
    15aa:	8a e0       	ldi	r24, 0x0A	; 10
    15ac:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
    15b0:	8a 89       	ldd	r24, Y+18	; 0x12
    15b2:	9b 89       	ldd	r25, Y+19	; 0x13
  chSysUnlock();
    15b4:	78 94       	sei
  return msg;
}
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	08 95       	ret
  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == THD_STATE_WTMSG)
    chSchReadyI(tp);
    15bc:	cd 01       	movw	r24, r26
    15be:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
    15c2:	f3 cf       	rjmp	.-26     	; 0x15aa <chMsgSend+0x40>

000015c4 <chMBFetchI>:
 * @retval RDY_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(Mailbox *mbp, msg_t *msgp) {
    15c4:	cf 93       	push	r28
    15c6:	df 93       	push	r29
    15c8:	dc 01       	movw	r26, r24
    15ca:	eb 01       	movw	r28, r22

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchI");

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    15cc:	1c 96       	adiw	r26, 0x0c	; 12
    15ce:	8c 91       	ld	r24, X
    15d0:	1c 97       	sbiw	r26, 0x0c	; 12
    15d2:	18 16       	cp	r1, r24
    15d4:	4c f5       	brge	.+82     	; 0x1628 <chMBFetchI+0x64>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_fullsem);
    15d6:	81 50       	subi	r24, 0x01	; 1
    15d8:	1c 96       	adiw	r26, 0x0c	; 12
    15da:	8c 93       	st	X, r24
    15dc:	1c 97       	sbiw	r26, 0x0c	; 12
  *msgp = *mbp->mb_rdptr++;
    15de:	16 96       	adiw	r26, 0x06	; 6
    15e0:	ed 91       	ld	r30, X+
    15e2:	fc 91       	ld	r31, X
    15e4:	17 97       	sbiw	r26, 0x07	; 7
    15e6:	81 91       	ld	r24, Z+
    15e8:	91 91       	ld	r25, Z+
    15ea:	99 83       	std	Y+1, r25	; 0x01
    15ec:	88 83       	st	Y, r24
    15ee:	17 96       	adiw	r26, 0x07	; 7
    15f0:	fc 93       	st	X, r31
    15f2:	ee 93       	st	-X, r30
    15f4:	16 97       	sbiw	r26, 0x06	; 6
  if (mbp->mb_rdptr >= mbp->mb_top)
    15f6:	12 96       	adiw	r26, 0x02	; 2
    15f8:	8d 91       	ld	r24, X+
    15fa:	9c 91       	ld	r25, X
    15fc:	13 97       	sbiw	r26, 0x03	; 3
    15fe:	e8 17       	cp	r30, r24
    1600:	f9 07       	cpc	r31, r25
    1602:	50 f4       	brcc	.+20     	; 0x1618 <chMBFetchI+0x54>
    mbp->mb_rdptr = mbp->mb_buffer;
  chSemSignalI(&mbp->mb_emptysem);
    1604:	cd 01       	movw	r24, r26
    1606:	0d 96       	adiw	r24, 0x0d	; 13
    1608:	0e 94 c7 04 	call	0x98e	; 0x98e <chSemSignalI>
    160c:	20 e0       	ldi	r18, 0x00	; 0
    160e:	30 e0       	ldi	r19, 0x00	; 0
  return RDY_OK;
}
    1610:	c9 01       	movw	r24, r18
    1612:	df 91       	pop	r29
    1614:	cf 91       	pop	r28
    1616:	08 95       	ret
  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top)
    mbp->mb_rdptr = mbp->mb_buffer;
    1618:	8d 91       	ld	r24, X+
    161a:	9c 91       	ld	r25, X
    161c:	11 97       	sbiw	r26, 0x01	; 1
    161e:	17 96       	adiw	r26, 0x07	; 7
    1620:	9c 93       	st	X, r25
    1622:	8e 93       	st	-X, r24
    1624:	16 97       	sbiw	r26, 0x06	; 6
    1626:	ee cf       	rjmp	.-36     	; 0x1604 <chMBFetchI+0x40>
msg_t chMBFetchI(Mailbox *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchI");

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    1628:	2f ef       	ldi	r18, 0xFF	; 255
    162a:	3f ef       	ldi	r19, 0xFF	; 255
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top)
    mbp->mb_rdptr = mbp->mb_buffer;
  chSemSignalI(&mbp->mb_emptysem);
  return RDY_OK;
}
    162c:	c9 01       	movw	r24, r18
    162e:	df 91       	pop	r29
    1630:	cf 91       	pop	r28
    1632:	08 95       	ret

00001634 <chMBPostAheadI>:
 * @retval RDY_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(Mailbox *mbp, msg_t msg) {
    1634:	dc 01       	movw	r26, r24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostAheadI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    1636:	51 96       	adiw	r26, 0x11	; 17
    1638:	8c 91       	ld	r24, X
    163a:	51 97       	sbiw	r26, 0x11	; 17
    163c:	18 16       	cp	r1, r24
    163e:	44 f5       	brge	.+80     	; 0x1690 <chMBPostAheadI+0x5c>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
    1640:	81 50       	subi	r24, 0x01	; 1
    1642:	51 96       	adiw	r26, 0x11	; 17
    1644:	8c 93       	st	X, r24
    1646:	51 97       	sbiw	r26, 0x11	; 17
  if (--mbp->mb_rdptr < mbp->mb_buffer)
    1648:	16 96       	adiw	r26, 0x06	; 6
    164a:	ed 91       	ld	r30, X+
    164c:	fc 91       	ld	r31, X
    164e:	17 97       	sbiw	r26, 0x07	; 7
    1650:	32 97       	sbiw	r30, 0x02	; 2
    1652:	17 96       	adiw	r26, 0x07	; 7
    1654:	fc 93       	st	X, r31
    1656:	ee 93       	st	-X, r30
    1658:	16 97       	sbiw	r26, 0x06	; 6
    165a:	8d 91       	ld	r24, X+
    165c:	9c 91       	ld	r25, X
    165e:	11 97       	sbiw	r26, 0x01	; 1
    1660:	e8 17       	cp	r30, r24
    1662:	f9 07       	cpc	r31, r25
    1664:	50 f0       	brcs	.+20     	; 0x167a <chMBPostAheadI+0x46>
    mbp->mb_rdptr = mbp->mb_top - 1;
  *mbp->mb_rdptr = msg;
    1666:	71 83       	std	Z+1, r23	; 0x01
    1668:	60 83       	st	Z, r22
  chSemSignalI(&mbp->mb_fullsem);
    166a:	cd 01       	movw	r24, r26
    166c:	08 96       	adiw	r24, 0x08	; 8
    166e:	0e 94 c7 04 	call	0x98e	; 0x98e <chSemSignalI>
    1672:	20 e0       	ldi	r18, 0x00	; 0
    1674:	30 e0       	ldi	r19, 0x00	; 0
  return RDY_OK;
}
    1676:	c9 01       	movw	r24, r18
    1678:	08 95       	ret

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer)
    mbp->mb_rdptr = mbp->mb_top - 1;
    167a:	12 96       	adiw	r26, 0x02	; 2
    167c:	8d 91       	ld	r24, X+
    167e:	9c 91       	ld	r25, X
    1680:	13 97       	sbiw	r26, 0x03	; 3
    1682:	02 97       	sbiw	r24, 0x02	; 2
    1684:	17 96       	adiw	r26, 0x07	; 7
    1686:	9c 93       	st	X, r25
    1688:	8e 93       	st	-X, r24
    168a:	16 97       	sbiw	r26, 0x06	; 6
    168c:	fc 01       	movw	r30, r24
    168e:	eb cf       	rjmp	.-42     	; 0x1666 <chMBPostAheadI+0x32>
msg_t chMBPostAheadI(Mailbox *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostAheadI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    1690:	2f ef       	ldi	r18, 0xFF	; 255
    1692:	3f ef       	ldi	r19, 0xFF	; 255
  if (--mbp->mb_rdptr < mbp->mb_buffer)
    mbp->mb_rdptr = mbp->mb_top - 1;
  *mbp->mb_rdptr = msg;
  chSemSignalI(&mbp->mb_fullsem);
  return RDY_OK;
}
    1694:	c9 01       	movw	r24, r18
    1696:	08 95       	ret

00001698 <chMBPostI>:
 * @retval RDY_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(Mailbox *mbp, msg_t msg) {
    1698:	dc 01       	movw	r26, r24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    169a:	51 96       	adiw	r26, 0x11	; 17
    169c:	8c 91       	ld	r24, X
    169e:	51 97       	sbiw	r26, 0x11	; 17
    16a0:	18 16       	cp	r1, r24
    16a2:	2c f5       	brge	.+74     	; 0x16ee <chMBPostI+0x56>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
    16a4:	81 50       	subi	r24, 0x01	; 1
    16a6:	51 96       	adiw	r26, 0x11	; 17
    16a8:	8c 93       	st	X, r24
    16aa:	51 97       	sbiw	r26, 0x11	; 17
  *mbp->mb_wrptr++ = msg;
    16ac:	14 96       	adiw	r26, 0x04	; 4
    16ae:	ed 91       	ld	r30, X+
    16b0:	fc 91       	ld	r31, X
    16b2:	15 97       	sbiw	r26, 0x05	; 5
    16b4:	61 93       	st	Z+, r22
    16b6:	71 93       	st	Z+, r23
    16b8:	15 96       	adiw	r26, 0x05	; 5
    16ba:	fc 93       	st	X, r31
    16bc:	ee 93       	st	-X, r30
    16be:	14 97       	sbiw	r26, 0x04	; 4
  if (mbp->mb_wrptr >= mbp->mb_top)
    16c0:	12 96       	adiw	r26, 0x02	; 2
    16c2:	8d 91       	ld	r24, X+
    16c4:	9c 91       	ld	r25, X
    16c6:	13 97       	sbiw	r26, 0x03	; 3
    16c8:	e8 17       	cp	r30, r24
    16ca:	f9 07       	cpc	r31, r25
    16cc:	40 f4       	brcc	.+16     	; 0x16de <chMBPostI+0x46>
    mbp->mb_wrptr = mbp->mb_buffer;
  chSemSignalI(&mbp->mb_fullsem);
    16ce:	cd 01       	movw	r24, r26
    16d0:	08 96       	adiw	r24, 0x08	; 8
    16d2:	0e 94 c7 04 	call	0x98e	; 0x98e <chSemSignalI>
    16d6:	20 e0       	ldi	r18, 0x00	; 0
    16d8:	30 e0       	ldi	r19, 0x00	; 0
  return RDY_OK;
}
    16da:	c9 01       	movw	r24, r18
    16dc:	08 95       	ret
  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top)
    mbp->mb_wrptr = mbp->mb_buffer;
    16de:	8d 91       	ld	r24, X+
    16e0:	9c 91       	ld	r25, X
    16e2:	11 97       	sbiw	r26, 0x01	; 1
    16e4:	15 96       	adiw	r26, 0x05	; 5
    16e6:	9c 93       	st	X, r25
    16e8:	8e 93       	st	-X, r24
    16ea:	14 97       	sbiw	r26, 0x04	; 4
    16ec:	f0 cf       	rjmp	.-32     	; 0x16ce <chMBPostI+0x36>
msg_t chMBPostI(Mailbox *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    16ee:	2f ef       	ldi	r18, 0xFF	; 255
    16f0:	3f ef       	ldi	r19, 0xFF	; 255
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top)
    mbp->mb_wrptr = mbp->mb_buffer;
  chSemSignalI(&mbp->mb_fullsem);
  return RDY_OK;
}
    16f2:	c9 01       	movw	r24, r18
    16f4:	08 95       	ret

000016f6 <chMBFetchS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(Mailbox *mbp, msg_t *msgp, systime_t time) {
    16f6:	ef 92       	push	r14
    16f8:	ff 92       	push	r15
    16fa:	0f 93       	push	r16
    16fc:	1f 93       	push	r17
    16fe:	cf 93       	push	r28
    1700:	df 93       	push	r29
    1702:	ec 01       	movw	r28, r24
    1704:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
    1706:	08 96       	adiw	r24, 0x08	; 8
    1708:	ba 01       	movw	r22, r20
    170a:	0e 94 bd 05 	call	0xb7a	; 0xb7a <chSemWaitTimeoutS>
    170e:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    1710:	00 97       	sbiw	r24, 0x00	; 0
    1712:	a1 f4       	brne	.+40     	; 0x173c <chMBFetchS+0x46>
    *msgp = *mbp->mb_rdptr++;
    1714:	ee 81       	ldd	r30, Y+6	; 0x06
    1716:	ff 81       	ldd	r31, Y+7	; 0x07
    1718:	81 91       	ld	r24, Z+
    171a:	91 91       	ld	r25, Z+
    171c:	d7 01       	movw	r26, r14
    171e:	8d 93       	st	X+, r24
    1720:	9c 93       	st	X, r25
    1722:	ff 83       	std	Y+7, r31	; 0x07
    1724:	ee 83       	std	Y+6, r30	; 0x06
    if (mbp->mb_rdptr >= mbp->mb_top)
    1726:	8a 81       	ldd	r24, Y+2	; 0x02
    1728:	9b 81       	ldd	r25, Y+3	; 0x03
    172a:	e8 17       	cp	r30, r24
    172c:	f9 07       	cpc	r31, r25
    172e:	70 f4       	brcc	.+28     	; 0x174c <chMBFetchS+0x56>
      mbp->mb_rdptr = mbp->mb_buffer;
    chSemSignalI(&mbp->mb_emptysem);
    1730:	ce 01       	movw	r24, r28
    1732:	0d 96       	adiw	r24, 0x0d	; 13
    1734:	0e 94 c7 04 	call	0x98e	; 0x98e <chSemSignalI>
    chSchRescheduleS();
    1738:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  }
  return rdymsg;
}
    173c:	c8 01       	movw	r24, r16
    173e:	df 91       	pop	r29
    1740:	cf 91       	pop	r28
    1742:	1f 91       	pop	r17
    1744:	0f 91       	pop	r16
    1746:	ff 90       	pop	r15
    1748:	ef 90       	pop	r14
    174a:	08 95       	ret

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == RDY_OK) {
    *msgp = *mbp->mb_rdptr++;
    if (mbp->mb_rdptr >= mbp->mb_top)
      mbp->mb_rdptr = mbp->mb_buffer;
    174c:	88 81       	ld	r24, Y
    174e:	99 81       	ldd	r25, Y+1	; 0x01
    1750:	9f 83       	std	Y+7, r25	; 0x07
    1752:	8e 83       	std	Y+6, r24	; 0x06
    1754:	ed cf       	rjmp	.-38     	; 0x1730 <chMBFetchS+0x3a>

00001756 <chMBFetch>:
 * @api
 */
msg_t chMBFetch(Mailbox *mbp, msg_t *msgp, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    1756:	f8 94       	cli
  rdymsg = chMBFetchS(mbp, msgp, time);
    1758:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <chMBFetchS>
  chSysUnlock();
    175c:	78 94       	sei
  return rdymsg;
}
    175e:	08 95       	ret

00001760 <chMBPostAheadS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(Mailbox *mbp, msg_t msg, systime_t time) {
    1760:	ef 92       	push	r14
    1762:	ff 92       	push	r15
    1764:	0f 93       	push	r16
    1766:	1f 93       	push	r17
    1768:	cf 93       	push	r28
    176a:	df 93       	push	r29
    176c:	ec 01       	movw	r28, r24
    176e:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL, "chMBPostAheadS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
    1770:	0d 96       	adiw	r24, 0x0d	; 13
    1772:	ba 01       	movw	r22, r20
    1774:	0e 94 bd 05 	call	0xb7a	; 0xb7a <chSemWaitTimeoutS>
    1778:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    177a:	00 97       	sbiw	r24, 0x00	; 0
    177c:	91 f4       	brne	.+36     	; 0x17a2 <chMBPostAheadS+0x42>
    if (--mbp->mb_rdptr < mbp->mb_buffer)
    177e:	ee 81       	ldd	r30, Y+6	; 0x06
    1780:	ff 81       	ldd	r31, Y+7	; 0x07
    1782:	32 97       	sbiw	r30, 0x02	; 2
    1784:	ff 83       	std	Y+7, r31	; 0x07
    1786:	ee 83       	std	Y+6, r30	; 0x06
    1788:	88 81       	ld	r24, Y
    178a:	99 81       	ldd	r25, Y+1	; 0x01
    178c:	e8 17       	cp	r30, r24
    178e:	f9 07       	cpc	r31, r25
    1790:	80 f0       	brcs	.+32     	; 0x17b2 <chMBPostAheadS+0x52>
      mbp->mb_rdptr = mbp->mb_top - 1;
    *mbp->mb_rdptr = msg;
    1792:	f1 82       	std	Z+1, r15	; 0x01
    1794:	e0 82       	st	Z, r14
    chSemSignalI(&mbp->mb_fullsem);
    1796:	ce 01       	movw	r24, r28
    1798:	08 96       	adiw	r24, 0x08	; 8
    179a:	0e 94 c7 04 	call	0x98e	; 0x98e <chSemSignalI>
    chSchRescheduleS();
    179e:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  }
  return rdymsg;
}
    17a2:	c8 01       	movw	r24, r16
    17a4:	df 91       	pop	r29
    17a6:	cf 91       	pop	r28
    17a8:	1f 91       	pop	r17
    17aa:	0f 91       	pop	r16
    17ac:	ff 90       	pop	r15
    17ae:	ef 90       	pop	r14
    17b0:	08 95       	ret
  chDbgCheck(mbp != NULL, "chMBPostAheadS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == RDY_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer)
      mbp->mb_rdptr = mbp->mb_top - 1;
    17b2:	8a 81       	ldd	r24, Y+2	; 0x02
    17b4:	9b 81       	ldd	r25, Y+3	; 0x03
    17b6:	02 97       	sbiw	r24, 0x02	; 2
    17b8:	9f 83       	std	Y+7, r25	; 0x07
    17ba:	8e 83       	std	Y+6, r24	; 0x06
    17bc:	fc 01       	movw	r30, r24
    17be:	e9 cf       	rjmp	.-46     	; 0x1792 <chMBPostAheadS+0x32>

000017c0 <chMBPostAhead>:
 * @api
 */
msg_t chMBPostAhead(Mailbox *mbp, msg_t msg, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    17c0:	f8 94       	cli
  rdymsg = chMBPostAheadS(mbp, msg, time);
    17c2:	0e 94 b0 0b 	call	0x1760	; 0x1760 <chMBPostAheadS>
  chSysUnlock();
    17c6:	78 94       	sei
  return rdymsg;
}
    17c8:	08 95       	ret

000017ca <chMBPostS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(Mailbox *mbp, msg_t msg, systime_t time) {
    17ca:	ef 92       	push	r14
    17cc:	ff 92       	push	r15
    17ce:	0f 93       	push	r16
    17d0:	1f 93       	push	r17
    17d2:	cf 93       	push	r28
    17d4:	df 93       	push	r29
    17d6:	ec 01       	movw	r28, r24
    17d8:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL, "chMBPostS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
    17da:	0d 96       	adiw	r24, 0x0d	; 13
    17dc:	ba 01       	movw	r22, r20
    17de:	0e 94 bd 05 	call	0xb7a	; 0xb7a <chSemWaitTimeoutS>
    17e2:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    17e4:	00 97       	sbiw	r24, 0x00	; 0
    17e6:	89 f4       	brne	.+34     	; 0x180a <chMBPostS+0x40>
    *mbp->mb_wrptr++ = msg;
    17e8:	ec 81       	ldd	r30, Y+4	; 0x04
    17ea:	fd 81       	ldd	r31, Y+5	; 0x05
    17ec:	e1 92       	st	Z+, r14
    17ee:	f1 92       	st	Z+, r15
    17f0:	fd 83       	std	Y+5, r31	; 0x05
    17f2:	ec 83       	std	Y+4, r30	; 0x04
    if (mbp->mb_wrptr >= mbp->mb_top)
    17f4:	8a 81       	ldd	r24, Y+2	; 0x02
    17f6:	9b 81       	ldd	r25, Y+3	; 0x03
    17f8:	e8 17       	cp	r30, r24
    17fa:	f9 07       	cpc	r31, r25
    17fc:	70 f4       	brcc	.+28     	; 0x181a <chMBPostS+0x50>
      mbp->mb_wrptr = mbp->mb_buffer;
    chSemSignalI(&mbp->mb_fullsem);
    17fe:	ce 01       	movw	r24, r28
    1800:	08 96       	adiw	r24, 0x08	; 8
    1802:	0e 94 c7 04 	call	0x98e	; 0x98e <chSemSignalI>
    chSchRescheduleS();
    1806:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  }
  return rdymsg;
}
    180a:	c8 01       	movw	r24, r16
    180c:	df 91       	pop	r29
    180e:	cf 91       	pop	r28
    1810:	1f 91       	pop	r17
    1812:	0f 91       	pop	r16
    1814:	ff 90       	pop	r15
    1816:	ef 90       	pop	r14
    1818:	08 95       	ret

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == RDY_OK) {
    *mbp->mb_wrptr++ = msg;
    if (mbp->mb_wrptr >= mbp->mb_top)
      mbp->mb_wrptr = mbp->mb_buffer;
    181a:	88 81       	ld	r24, Y
    181c:	99 81       	ldd	r25, Y+1	; 0x01
    181e:	9d 83       	std	Y+5, r25	; 0x05
    1820:	8c 83       	std	Y+4, r24	; 0x04
    1822:	ed cf       	rjmp	.-38     	; 0x17fe <chMBPostS+0x34>

00001824 <chMBPost>:
 * @api
 */
msg_t chMBPost(Mailbox *mbp, msg_t msg, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    1824:	f8 94       	cli
  rdymsg = chMBPostS(mbp, msg, time);
    1826:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chMBPostS>
  chSysUnlock();
    182a:	78 94       	sei
  return rdymsg;
}
    182c:	08 95       	ret

0000182e <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized Mailbox object
 *
 * @api
 */
void chMBReset(Mailbox *mbp) {
    182e:	0f 93       	push	r16
    1830:	1f 93       	push	r17
    1832:	8c 01       	movw	r16, r24

  chDbgCheck(mbp != NULL, "chMBReset");

  chSysLock();
    1834:	f8 94       	cli
  mbp->mb_wrptr = mbp->mb_rdptr = mbp->mb_buffer;
    1836:	fc 01       	movw	r30, r24
    1838:	80 81       	ld	r24, Z
    183a:	91 81       	ldd	r25, Z+1	; 0x01
    183c:	97 83       	std	Z+7, r25	; 0x07
    183e:	86 83       	std	Z+6, r24	; 0x06
    1840:	95 83       	std	Z+5, r25	; 0x05
    1842:	84 83       	std	Z+4, r24	; 0x04
  chSemResetI(&mbp->mb_emptysem, mbp->mb_top - mbp->mb_buffer);
    1844:	62 81       	ldd	r22, Z+2	; 0x02
    1846:	73 81       	ldd	r23, Z+3	; 0x03
    1848:	68 1b       	sub	r22, r24
    184a:	79 0b       	sbc	r23, r25
    184c:	75 95       	asr	r23
    184e:	67 95       	ror	r22
    1850:	c8 01       	movw	r24, r16
    1852:	0d 96       	adiw	r24, 0x0d	; 13
    1854:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, 0);
    1858:	c8 01       	movw	r24, r16
    185a:	08 96       	adiw	r24, 0x08	; 8
    185c:	60 e0       	ldi	r22, 0x00	; 0
    185e:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <chSemResetI>
  chSchRescheduleS();
    1862:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  chSysUnlock();
    1866:	78 94       	sei
}
    1868:	1f 91       	pop	r17
    186a:	0f 91       	pop	r16
    186c:	08 95       	ret

0000186e <chMBInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBInit(Mailbox *mbp, msg_t *buf, cnt_t n) {
    186e:	0f 93       	push	r16
    1870:	1f 93       	push	r17
    1872:	8c 01       	movw	r16, r24

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0), "chMBInit");

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
    1874:	fc 01       	movw	r30, r24
    1876:	77 83       	std	Z+7, r23	; 0x07
    1878:	66 83       	std	Z+6, r22	; 0x06
    187a:	75 83       	std	Z+5, r23	; 0x05
    187c:	64 83       	std	Z+4, r22	; 0x04
    187e:	71 83       	std	Z+1, r23	; 0x01
    1880:	60 83       	st	Z, r22
  mbp->mb_top = &buf[n];
    1882:	84 2f       	mov	r24, r20
    1884:	99 27       	eor	r25, r25
    1886:	87 fd       	sbrc	r24, 7
    1888:	90 95       	com	r25
    188a:	88 0f       	add	r24, r24
    188c:	99 1f       	adc	r25, r25
    188e:	86 0f       	add	r24, r22
    1890:	97 1f       	adc	r25, r23
    1892:	93 83       	std	Z+3, r25	; 0x03
    1894:	82 83       	std	Z+2, r24	; 0x02
  chSemInit(&mbp->mb_emptysem, n);
    1896:	c8 01       	movw	r24, r16
    1898:	0d 96       	adiw	r24, 0x0d	; 13
    189a:	64 2f       	mov	r22, r20
    189c:	0e 94 93 04 	call	0x926	; 0x926 <chSemInit>
  chSemInit(&mbp->mb_fullsem, 0);
    18a0:	c8 01       	movw	r24, r16
    18a2:	08 96       	adiw	r24, 0x08	; 8
    18a4:	60 e0       	ldi	r22, 0x00	; 0
    18a6:	0e 94 93 04 	call	0x926	; 0x926 <chSemInit>
}
    18aa:	1f 91       	pop	r17
    18ac:	0f 91       	pop	r16
    18ae:	08 95       	ret

000018b0 <chIQInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQInit(InputQueue *iqp, uint8_t *bp, size_t size, qnotify_t infy,
              void *link) {
    18b0:	0f 93       	push	r16
    18b2:	1f 93       	push	r17
    18b4:	fc 01       	movw	r30, r24

  queue_init(&iqp->q_waiting);
    18b6:	82 83       	std	Z+2, r24	; 0x02
    18b8:	f3 83       	std	Z+3, r31	; 0x03
    18ba:	80 83       	st	Z, r24
    18bc:	f1 83       	std	Z+1, r31	; 0x01
  iqp->q_counter = 0;
    18be:	15 82       	std	Z+5, r1	; 0x05
    18c0:	14 82       	std	Z+4, r1	; 0x04
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
    18c2:	73 87       	std	Z+11, r23	; 0x0b
    18c4:	62 87       	std	Z+10, r22	; 0x0a
    18c6:	75 87       	std	Z+13, r23	; 0x0d
    18c8:	64 87       	std	Z+12, r22	; 0x0c
    18ca:	77 83       	std	Z+7, r23	; 0x07
    18cc:	66 83       	std	Z+6, r22	; 0x06
  iqp->q_top = bp + size;
    18ce:	64 0f       	add	r22, r20
    18d0:	75 1f       	adc	r23, r21
    18d2:	71 87       	std	Z+9, r23	; 0x09
    18d4:	60 87       	std	Z+8, r22	; 0x08
  iqp->q_notify = infy;
    18d6:	37 87       	std	Z+15, r19	; 0x0f
    18d8:	26 87       	std	Z+14, r18	; 0x0e
  iqp->q_link = link;
    18da:	11 8b       	std	Z+17, r17	; 0x11
    18dc:	00 8b       	std	Z+16, r16	; 0x10
}
    18de:	1f 91       	pop	r17
    18e0:	0f 91       	pop	r16
    18e2:	08 95       	ret

000018e4 <chOQInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQInit(OutputQueue *oqp, uint8_t *bp, size_t size, qnotify_t onfy,
              void *link) {
    18e4:	0f 93       	push	r16
    18e6:	1f 93       	push	r17
    18e8:	fc 01       	movw	r30, r24

  queue_init(&oqp->q_waiting);
    18ea:	82 83       	std	Z+2, r24	; 0x02
    18ec:	f3 83       	std	Z+3, r31	; 0x03
    18ee:	80 83       	st	Z, r24
    18f0:	f1 83       	std	Z+1, r31	; 0x01
  oqp->q_counter = size;
    18f2:	55 83       	std	Z+5, r21	; 0x05
    18f4:	44 83       	std	Z+4, r20	; 0x04
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
    18f6:	73 87       	std	Z+11, r23	; 0x0b
    18f8:	62 87       	std	Z+10, r22	; 0x0a
    18fa:	75 87       	std	Z+13, r23	; 0x0d
    18fc:	64 87       	std	Z+12, r22	; 0x0c
    18fe:	77 83       	std	Z+7, r23	; 0x07
    1900:	66 83       	std	Z+6, r22	; 0x06
  oqp->q_top = bp + size;
    1902:	64 0f       	add	r22, r20
    1904:	75 1f       	adc	r23, r21
    1906:	71 87       	std	Z+9, r23	; 0x09
    1908:	60 87       	std	Z+8, r22	; 0x08
  oqp->q_notify = onfy;
    190a:	37 87       	std	Z+15, r19	; 0x0f
    190c:	26 87       	std	Z+14, r18	; 0x0e
  oqp->q_link = link;
    190e:	11 8b       	std	Z+17, r17	; 0x11
    1910:	00 8b       	std	Z+16, r16	; 0x10
}
    1912:	1f 91       	pop	r17
    1914:	0f 91       	pop	r16
    1916:	08 95       	ret

00001918 <qwait>:
 *                      released from threads queue.
 * @retval Q_OK         is the normal exit, thread signaled.
 * @retval Q_RESET      if the queue has been reset.
 * @retval Q_TIMEOUT    if the queue operation timed out.
 */
static msg_t qwait(GenericQueue *qp, systime_t time) {
    1918:	cf 93       	push	r28
    191a:	df 93       	push	r29
    191c:	ec 01       	movw	r28, r24

  if (TIME_IMMEDIATE == time)
    191e:	61 15       	cp	r22, r1
    1920:	71 05       	cpc	r23, r1
    1922:	31 f4       	brne	.+12     	; 0x1930 <qwait+0x18>
    1924:	2f ef       	ldi	r18, 0xFF	; 255
    1926:	3f ef       	ldi	r19, 0xFF	; 255
    return Q_TIMEOUT;
  currp->p_u.wtobjp = qp;
  queue_insert(currp, &qp->q_waiting);
  return chSchGoSleepTimeoutS(THD_STATE_WTQUEUE, time);
}
    1928:	c9 01       	movw	r24, r18
    192a:	df 91       	pop	r29
    192c:	cf 91       	pop	r28
    192e:	08 95       	ret
 */
static msg_t qwait(GenericQueue *qp, systime_t time) {

  if (TIME_IMMEDIATE == time)
    return Q_TIMEOUT;
  currp->p_u.wtobjp = qp;
    1930:	e0 91 fe 0b 	lds	r30, 0x0BFE
    1934:	f0 91 ff 0b 	lds	r31, 0x0BFF
    1938:	93 8b       	std	Z+19, r25	; 0x13
    193a:	82 8b       	std	Z+18, r24	; 0x12
    193c:	91 83       	std	Z+1, r25	; 0x01
    193e:	80 83       	st	Z, r24
    1940:	aa 81       	ldd	r26, Y+2	; 0x02
    1942:	bb 81       	ldd	r27, Y+3	; 0x03
    1944:	b3 83       	std	Z+3, r27	; 0x03
    1946:	a2 83       	std	Z+2, r26	; 0x02
    1948:	fb 83       	std	Y+3, r31	; 0x03
    194a:	ea 83       	std	Y+2, r30	; 0x02
    194c:	ed 93       	st	X+, r30
    194e:	fc 93       	st	X, r31
  queue_insert(currp, &qp->q_waiting);
  return chSchGoSleepTimeoutS(THD_STATE_WTQUEUE, time);
    1950:	8d e0       	ldi	r24, 0x0D	; 13
    1952:	0e 94 21 03 	call	0x642	; 0x642 <chSchGoSleepTimeoutS>
    1956:	9c 01       	movw	r18, r24
}
    1958:	c9 01       	movw	r24, r18
    195a:	df 91       	pop	r29
    195c:	cf 91       	pop	r28
    195e:	08 95       	ret

00001960 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
    1960:	8f 92       	push	r8
    1962:	9f 92       	push	r9
    1964:	af 92       	push	r10
    1966:	bf 92       	push	r11
    1968:	cf 92       	push	r12
    196a:	df 92       	push	r13
    196c:	ef 92       	push	r14
    196e:	ff 92       	push	r15
    1970:	0f 93       	push	r16
    1972:	1f 93       	push	r17
    1974:	cf 93       	push	r28
    1976:	df 93       	push	r29
    1978:	ec 01       	movw	r28, r24
    197a:	7b 01       	movw	r14, r22
    197c:	8a 01       	movw	r16, r20
    197e:	49 01       	movw	r8, r18
  qnotify_t nfy = oqp->q_notify;
    1980:	ae 84       	ldd	r10, Y+14	; 0x0e
    1982:	bf 84       	ldd	r11, Y+15	; 0x0f
  size_t w = 0;

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
    1984:	f8 94       	cli
    1986:	cc 24       	eor	r12, r12
    1988:	dd 24       	eor	r13, r13
  while (TRUE) {
    while (chOQIsFullI(oqp)) {
    198a:	8c 81       	ldd	r24, Y+4	; 0x04
    198c:	9d 81       	ldd	r25, Y+5	; 0x05
    198e:	00 97       	sbiw	r24, 0x00	; 0
    1990:	41 f1       	breq	.+80     	; 0x19e2 <chOQWriteTimeout+0x82>
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    1992:	01 97       	sbiw	r24, 0x01	; 1
    1994:	9d 83       	std	Y+5, r25	; 0x05
    1996:	8c 83       	std	Y+4, r24	; 0x04
    *oqp->q_wrptr++ = *bp++;
    1998:	f7 01       	movw	r30, r14
    199a:	80 81       	ld	r24, Z
    199c:	ea 85       	ldd	r30, Y+10	; 0x0a
    199e:	fb 85       	ldd	r31, Y+11	; 0x0b
    19a0:	81 93       	st	Z+, r24
    19a2:	fb 87       	std	Y+11, r31	; 0x0b
    19a4:	ea 87       	std	Y+10, r30	; 0x0a
    if (oqp->q_wrptr >= oqp->q_top)
    19a6:	88 85       	ldd	r24, Y+8	; 0x08
    19a8:	99 85       	ldd	r25, Y+9	; 0x09
    19aa:	e8 17       	cp	r30, r24
    19ac:	f9 07       	cpc	r31, r25
    19ae:	20 f0       	brcs	.+8      	; 0x19b8 <chOQWriteTimeout+0x58>
      oqp->q_wrptr = oqp->q_buffer;
    19b0:	8e 81       	ldd	r24, Y+6	; 0x06
    19b2:	9f 81       	ldd	r25, Y+7	; 0x07
    19b4:	9b 87       	std	Y+11, r25	; 0x0b
    19b6:	8a 87       	std	Y+10, r24	; 0x0a

    if (nfy)
    19b8:	a1 14       	cp	r10, r1
    19ba:	b1 04       	cpc	r11, r1
    19bc:	19 f0       	breq	.+6      	; 0x19c4 <chOQWriteTimeout+0x64>
      nfy(oqp);
    19be:	ce 01       	movw	r24, r28
    19c0:	f5 01       	movw	r30, r10
    19c2:	09 95       	icall

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    19c4:	78 94       	sei
    w++;
    19c6:	08 94       	sec
    19c8:	c1 1c       	adc	r12, r1
    19ca:	d1 1c       	adc	r13, r1
    if (--n == 0)
    19cc:	01 50       	subi	r16, 0x01	; 1
    19ce:	10 40       	sbci	r17, 0x00	; 0
    19d0:	79 f0       	breq	.+30     	; 0x19f0 <chOQWriteTimeout+0x90>
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
    19d2:	08 94       	sec
    19d4:	e1 1c       	adc	r14, r1
    19d6:	f1 1c       	adc	r15, r1

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
    if (--n == 0)
      return w;
    chSysLock();
    19d8:	f8 94       	cli

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
  while (TRUE) {
    while (chOQIsFullI(oqp)) {
    19da:	8c 81       	ldd	r24, Y+4	; 0x04
    19dc:	9d 81       	ldd	r25, Y+5	; 0x05
    19de:	00 97       	sbiw	r24, 0x00	; 0
    19e0:	c1 f6       	brne	.-80     	; 0x1992 <chOQWriteTimeout+0x32>
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
    19e2:	ce 01       	movw	r24, r28
    19e4:	b4 01       	movw	r22, r8
    19e6:	0e 94 8c 0c 	call	0x1918	; 0x1918 <qwait>
    19ea:	89 2b       	or	r24, r25
    19ec:	71 f2       	breq	.-100    	; 0x198a <chOQWriteTimeout+0x2a>
        chSysUnlock();
    19ee:	78 94       	sei
    w++;
    if (--n == 0)
      return w;
    chSysLock();
  }
}
    19f0:	c6 01       	movw	r24, r12
    19f2:	df 91       	pop	r29
    19f4:	cf 91       	pop	r28
    19f6:	1f 91       	pop	r17
    19f8:	0f 91       	pop	r16
    19fa:	ff 90       	pop	r15
    19fc:	ef 90       	pop	r14
    19fe:	df 90       	pop	r13
    1a00:	cf 90       	pop	r12
    1a02:	bf 90       	pop	r11
    1a04:	af 90       	pop	r10
    1a06:	9f 90       	pop	r9
    1a08:	8f 90       	pop	r8
    1a0a:	08 95       	ret

00001a0c <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(OutputQueue *oqp, uint8_t b, systime_t time) {
    1a0c:	ff 92       	push	r15
    1a0e:	0f 93       	push	r16
    1a10:	1f 93       	push	r17
    1a12:	cf 93       	push	r28
    1a14:	df 93       	push	r29
    1a16:	ec 01       	movw	r28, r24
    1a18:	f6 2e       	mov	r15, r22
    1a1a:	8a 01       	movw	r16, r20

  chSysLock();
    1a1c:	f8 94       	cli
  while (chOQIsFullI(oqp)) {
    1a1e:	8c 81       	ldd	r24, Y+4	; 0x04
    1a20:	9d 81       	ldd	r25, Y+5	; 0x05
    1a22:	00 97       	sbiw	r24, 0x00	; 0
    1a24:	79 f4       	brne	.+30     	; 0x1a44 <chOQPutTimeout+0x38>
    msg_t msg;

    if ((msg = qwait((GenericQueue *)oqp, time)) < Q_OK) {
    1a26:	ce 01       	movw	r24, r28
    1a28:	b8 01       	movw	r22, r16
    1a2a:	0e 94 8c 0c 	call	0x1918	; 0x1918 <qwait>
    1a2e:	9c 01       	movw	r18, r24
    1a30:	97 ff       	sbrs	r25, 7
    1a32:	f5 cf       	rjmp	.-22     	; 0x1a1e <chOQPutTimeout+0x12>
      chSysUnlock();
    1a34:	78 94       	sei
  if (oqp->q_notify)
    oqp->q_notify(oqp);

  chSysUnlock();
  return Q_OK;
}
    1a36:	c9 01       	movw	r24, r18
    1a38:	df 91       	pop	r29
    1a3a:	cf 91       	pop	r28
    1a3c:	1f 91       	pop	r17
    1a3e:	0f 91       	pop	r16
    1a40:	ff 90       	pop	r15
    1a42:	08 95       	ret
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
    1a44:	01 97       	sbiw	r24, 0x01	; 1
    1a46:	9d 83       	std	Y+5, r25	; 0x05
    1a48:	8c 83       	std	Y+4, r24	; 0x04
  *oqp->q_wrptr++ = b;
    1a4a:	ea 85       	ldd	r30, Y+10	; 0x0a
    1a4c:	fb 85       	ldd	r31, Y+11	; 0x0b
    1a4e:	f1 92       	st	Z+, r15
    1a50:	fb 87       	std	Y+11, r31	; 0x0b
    1a52:	ea 87       	std	Y+10, r30	; 0x0a
  if (oqp->q_wrptr >= oqp->q_top)
    1a54:	88 85       	ldd	r24, Y+8	; 0x08
    1a56:	99 85       	ldd	r25, Y+9	; 0x09
    1a58:	e8 17       	cp	r30, r24
    1a5a:	f9 07       	cpc	r31, r25
    1a5c:	20 f0       	brcs	.+8      	; 0x1a66 <chOQPutTimeout+0x5a>
    oqp->q_wrptr = oqp->q_buffer;
    1a5e:	8e 81       	ldd	r24, Y+6	; 0x06
    1a60:	9f 81       	ldd	r25, Y+7	; 0x07
    1a62:	9b 87       	std	Y+11, r25	; 0x0b
    1a64:	8a 87       	std	Y+10, r24	; 0x0a

  if (oqp->q_notify)
    1a66:	ee 85       	ldd	r30, Y+14	; 0x0e
    1a68:	ff 85       	ldd	r31, Y+15	; 0x0f
    1a6a:	30 97       	sbiw	r30, 0x00	; 0
    1a6c:	11 f0       	breq	.+4      	; 0x1a72 <chOQPutTimeout+0x66>
    oqp->q_notify(oqp);
    1a6e:	ce 01       	movw	r24, r28
    1a70:	09 95       	icall

  chSysUnlock();
    1a72:	78 94       	sei
    1a74:	20 e0       	ldi	r18, 0x00	; 0
    1a76:	30 e0       	ldi	r19, 0x00	; 0
  return Q_OK;
}
    1a78:	c9 01       	movw	r24, r18
    1a7a:	df 91       	pop	r29
    1a7c:	cf 91       	pop	r28
    1a7e:	1f 91       	pop	r17
    1a80:	0f 91       	pop	r16
    1a82:	ff 90       	pop	r15
    1a84:	08 95       	ret

00001a86 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
    1a86:	8f 92       	push	r8
    1a88:	9f 92       	push	r9
    1a8a:	af 92       	push	r10
    1a8c:	bf 92       	push	r11
    1a8e:	cf 92       	push	r12
    1a90:	df 92       	push	r13
    1a92:	ef 92       	push	r14
    1a94:	ff 92       	push	r15
    1a96:	0f 93       	push	r16
    1a98:	1f 93       	push	r17
    1a9a:	cf 93       	push	r28
    1a9c:	df 93       	push	r29
    1a9e:	ec 01       	movw	r28, r24
    1aa0:	6b 01       	movw	r12, r22
    1aa2:	4a 01       	movw	r8, r20
    1aa4:	89 01       	movw	r16, r18
  qnotify_t nfy = iqp->q_notify;
    1aa6:	ae 84       	ldd	r10, Y+14	; 0x0e
    1aa8:	bf 84       	ldd	r11, Y+15	; 0x0f
  size_t r = 0;

  chDbgCheck(n > 0, "chIQReadTimeout");

  chSysLock();
    1aaa:	f8 94       	cli
    1aac:	ee 24       	eor	r14, r14
    1aae:	ff 24       	eor	r15, r15
  while (TRUE) {
    if (nfy)
    1ab0:	a1 14       	cp	r10, r1
    1ab2:	b1 04       	cpc	r11, r1
    1ab4:	19 f0       	breq	.+6      	; 0x1abc <chIQReadTimeout+0x36>
      nfy(iqp);
    1ab6:	ce 01       	movw	r24, r28
    1ab8:	f5 01       	movw	r30, r10
    1aba:	09 95       	icall

    while (chIQIsEmptyI(iqp)) {
    1abc:	8c 81       	ldd	r24, Y+4	; 0x04
    1abe:	9d 81       	ldd	r25, Y+5	; 0x05
    1ac0:	00 97       	sbiw	r24, 0x00	; 0
    1ac2:	a9 f4       	brne	.+42     	; 0x1aee <chIQReadTimeout+0x68>
      if (qwait((GenericQueue *)iqp, time) != Q_OK) {
    1ac4:	ce 01       	movw	r24, r28
    1ac6:	b8 01       	movw	r22, r16
    1ac8:	0e 94 8c 0c 	call	0x1918	; 0x1918 <qwait>
    1acc:	89 2b       	or	r24, r25
    1ace:	b1 f3       	breq	.-20     	; 0x1abc <chIQReadTimeout+0x36>
        chSysUnlock();
    1ad0:	78 94       	sei
    if (--n == 0)
      return r;

    chSysLock();
  }
}
    1ad2:	c7 01       	movw	r24, r14
    1ad4:	df 91       	pop	r29
    1ad6:	cf 91       	pop	r28
    1ad8:	1f 91       	pop	r17
    1ada:	0f 91       	pop	r16
    1adc:	ff 90       	pop	r15
    1ade:	ef 90       	pop	r14
    1ae0:	df 90       	pop	r13
    1ae2:	cf 90       	pop	r12
    1ae4:	bf 90       	pop	r11
    1ae6:	af 90       	pop	r10
    1ae8:	9f 90       	pop	r9
    1aea:	8f 90       	pop	r8
    1aec:	08 95       	ret
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
    1aee:	01 97       	sbiw	r24, 0x01	; 1
    1af0:	9d 83       	std	Y+5, r25	; 0x05
    1af2:	8c 83       	std	Y+4, r24	; 0x04
    *bp++ = *iqp->q_rdptr++;
    1af4:	ec 85       	ldd	r30, Y+12	; 0x0c
    1af6:	fd 85       	ldd	r31, Y+13	; 0x0d
    1af8:	81 91       	ld	r24, Z+
    1afa:	d6 01       	movw	r26, r12
    1afc:	8c 93       	st	X, r24
    1afe:	fd 87       	std	Y+13, r31	; 0x0d
    1b00:	ec 87       	std	Y+12, r30	; 0x0c
    if (iqp->q_rdptr >= iqp->q_top)
    1b02:	88 85       	ldd	r24, Y+8	; 0x08
    1b04:	99 85       	ldd	r25, Y+9	; 0x09
    1b06:	e8 17       	cp	r30, r24
    1b08:	f9 07       	cpc	r31, r25
    1b0a:	60 f4       	brcc	.+24     	; 0x1b24 <chIQReadTimeout+0x9e>
      iqp->q_rdptr = iqp->q_buffer;

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    1b0c:	78 94       	sei
    r++;
    1b0e:	08 94       	sec
    1b10:	e1 1c       	adc	r14, r1
    1b12:	f1 1c       	adc	r15, r1
    if (--n == 0)
    1b14:	8e 14       	cp	r8, r14
    1b16:	9f 04       	cpc	r9, r15
    1b18:	e1 f2       	breq	.-72     	; 0x1ad2 <chIQReadTimeout+0x4c>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
    1b1a:	08 94       	sec
    1b1c:	c1 1c       	adc	r12, r1
    1b1e:	d1 1c       	adc	r13, r1
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    r++;
    if (--n == 0)
      return r;

    chSysLock();
    1b20:	f8 94       	cli
    1b22:	c6 cf       	rjmp	.-116    	; 0x1ab0 <chIQReadTimeout+0x2a>
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
    if (iqp->q_rdptr >= iqp->q_top)
      iqp->q_rdptr = iqp->q_buffer;
    1b24:	8e 81       	ldd	r24, Y+6	; 0x06
    1b26:	9f 81       	ldd	r25, Y+7	; 0x07
    1b28:	9d 87       	std	Y+13, r25	; 0x0d
    1b2a:	8c 87       	std	Y+12, r24	; 0x0c
    1b2c:	ef cf       	rjmp	.-34     	; 0x1b0c <chIQReadTimeout+0x86>

00001b2e <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(InputQueue *iqp, systime_t time) {
    1b2e:	0f 93       	push	r16
    1b30:	1f 93       	push	r17
    1b32:	cf 93       	push	r28
    1b34:	df 93       	push	r29
    1b36:	ec 01       	movw	r28, r24
    1b38:	8b 01       	movw	r16, r22
  uint8_t b;

  chSysLock();
    1b3a:	f8 94       	cli
  if (iqp->q_notify)
    1b3c:	ee 85       	ldd	r30, Y+14	; 0x0e
    1b3e:	ff 85       	ldd	r31, Y+15	; 0x0f
    1b40:	30 97       	sbiw	r30, 0x00	; 0
    1b42:	09 f0       	breq	.+2      	; 0x1b46 <chIQGetTimeout+0x18>
    iqp->q_notify(iqp);
    1b44:	09 95       	icall

  while (chIQIsEmptyI(iqp)) {
    1b46:	8c 81       	ldd	r24, Y+4	; 0x04
    1b48:	9d 81       	ldd	r25, Y+5	; 0x05
    1b4a:	00 97       	sbiw	r24, 0x00	; 0
    1b4c:	71 f4       	brne	.+28     	; 0x1b6a <chIQGetTimeout+0x3c>
    msg_t msg;
    if ((msg = qwait((GenericQueue *)iqp, time)) < Q_OK) {
    1b4e:	ce 01       	movw	r24, r28
    1b50:	b8 01       	movw	r22, r16
    1b52:	0e 94 8c 0c 	call	0x1918	; 0x1918 <qwait>
    1b56:	9c 01       	movw	r18, r24
    1b58:	97 ff       	sbrs	r25, 7
    1b5a:	f5 cf       	rjmp	.-22     	; 0x1b46 <chIQGetTimeout+0x18>
      chSysUnlock();
    1b5c:	78 94       	sei
  if (iqp->q_rdptr >= iqp->q_top)
    iqp->q_rdptr = iqp->q_buffer;

  chSysUnlock();
  return b;
}
    1b5e:	c9 01       	movw	r24, r18
    1b60:	df 91       	pop	r29
    1b62:	cf 91       	pop	r28
    1b64:	1f 91       	pop	r17
    1b66:	0f 91       	pop	r16
    1b68:	08 95       	ret
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
    1b6a:	01 97       	sbiw	r24, 0x01	; 1
    1b6c:	9d 83       	std	Y+5, r25	; 0x05
    1b6e:	8c 83       	std	Y+4, r24	; 0x04
  b = *iqp->q_rdptr++;
    1b70:	ec 85       	ldd	r30, Y+12	; 0x0c
    1b72:	fd 85       	ldd	r31, Y+13	; 0x0d
    1b74:	21 91       	ld	r18, Z+
    1b76:	fd 87       	std	Y+13, r31	; 0x0d
    1b78:	ec 87       	std	Y+12, r30	; 0x0c
  if (iqp->q_rdptr >= iqp->q_top)
    1b7a:	88 85       	ldd	r24, Y+8	; 0x08
    1b7c:	99 85       	ldd	r25, Y+9	; 0x09
    1b7e:	e8 17       	cp	r30, r24
    1b80:	f9 07       	cpc	r31, r25
    1b82:	20 f0       	brcs	.+8      	; 0x1b8c <chIQGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
    1b84:	8e 81       	ldd	r24, Y+6	; 0x06
    1b86:	9f 81       	ldd	r25, Y+7	; 0x07
    1b88:	9d 87       	std	Y+13, r25	; 0x0d
    1b8a:	8c 87       	std	Y+12, r24	; 0x0c

  chSysUnlock();
    1b8c:	78 94       	sei
  return b;
    1b8e:	30 e0       	ldi	r19, 0x00	; 0
}
    1b90:	c9 01       	movw	r24, r18
    1b92:	df 91       	pop	r29
    1b94:	cf 91       	pop	r28
    1b96:	1f 91       	pop	r17
    1b98:	0f 91       	pop	r16
    1b9a:	08 95       	ret

00001b9c <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(OutputQueue *oqp) {
    1b9c:	1f 93       	push	r17
    1b9e:	cf 93       	push	r28
    1ba0:	df 93       	push	r29
    1ba2:	dc 01       	movw	r26, r24
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
    1ba4:	1a 96       	adiw	r26, 0x0a	; 10
    1ba6:	8d 91       	ld	r24, X+
    1ba8:	9c 91       	ld	r25, X
    1baa:	1b 97       	sbiw	r26, 0x0b	; 11
    1bac:	1c 96       	adiw	r26, 0x0c	; 12
    1bae:	ed 91       	ld	r30, X+
    1bb0:	fc 91       	ld	r31, X
    1bb2:	1d 97       	sbiw	r26, 0x0d	; 13
    1bb4:	8e 17       	cp	r24, r30
    1bb6:	9f 07       	cpc	r25, r31
    1bb8:	b9 f1       	breq	.+110    	; 0x1c28 <chOQGetI+0x8c>
    oqp->q_rdptr = oqp->q_buffer;

  if (notempty(&oqp->q_waiting))
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_OK;

  return b;
    1bba:	14 96       	adiw	r26, 0x04	; 4
    1bbc:	8d 91       	ld	r24, X+
    1bbe:	9c 91       	ld	r25, X
    1bc0:	15 97       	sbiw	r26, 0x05	; 5
  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
    return Q_EMPTY;

  oqp->q_counter++;
    1bc2:	01 96       	adiw	r24, 0x01	; 1
    1bc4:	15 96       	adiw	r26, 0x05	; 5
    1bc6:	9c 93       	st	X, r25
    1bc8:	8e 93       	st	-X, r24
    1bca:	14 97       	sbiw	r26, 0x04	; 4
  b = *oqp->q_rdptr++;
    1bcc:	11 91       	ld	r17, Z+
    1bce:	1d 96       	adiw	r26, 0x0d	; 13
    1bd0:	fc 93       	st	X, r31
    1bd2:	ee 93       	st	-X, r30
    1bd4:	1c 97       	sbiw	r26, 0x0c	; 12
  if (oqp->q_rdptr >= oqp->q_top)
    1bd6:	18 96       	adiw	r26, 0x08	; 8
    1bd8:	8d 91       	ld	r24, X+
    1bda:	9c 91       	ld	r25, X
    1bdc:	19 97       	sbiw	r26, 0x09	; 9
    1bde:	e8 17       	cp	r30, r24
    1be0:	f9 07       	cpc	r31, r25
    1be2:	40 f0       	brcs	.+16     	; 0x1bf4 <chOQGetI+0x58>
    oqp->q_rdptr = oqp->q_buffer;
    1be4:	16 96       	adiw	r26, 0x06	; 6
    1be6:	8d 91       	ld	r24, X+
    1be8:	9c 91       	ld	r25, X
    1bea:	17 97       	sbiw	r26, 0x07	; 7
    1bec:	1d 96       	adiw	r26, 0x0d	; 13
    1bee:	9c 93       	st	X, r25
    1bf0:	8e 93       	st	-X, r24
    1bf2:	1c 97       	sbiw	r26, 0x0c	; 12

  if (notempty(&oqp->q_waiting))
    1bf4:	cd 91       	ld	r28, X+
    1bf6:	dc 91       	ld	r29, X
    1bf8:	11 97       	sbiw	r26, 0x01	; 1
    1bfa:	ca 17       	cp	r28, r26
    1bfc:	db 07       	cpc	r29, r27
    1bfe:	69 f0       	breq	.+26     	; 0x1c1a <chOQGetI+0x7e>
    1c00:	e8 81       	ld	r30, Y
    1c02:	f9 81       	ldd	r31, Y+1	; 0x01
    1c04:	11 96       	adiw	r26, 0x01	; 1
    1c06:	fc 93       	st	X, r31
    1c08:	ee 93       	st	-X, r30
    1c0a:	b3 83       	std	Z+3, r27	; 0x03
    1c0c:	a2 83       	std	Z+2, r26	; 0x02
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_OK;
    1c0e:	ce 01       	movw	r24, r28
    1c10:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
    1c14:	fc 01       	movw	r30, r24
    1c16:	13 8a       	std	Z+19, r1	; 0x13
    1c18:	12 8a       	std	Z+18, r1	; 0x12

  return b;
    1c1a:	21 2f       	mov	r18, r17
    1c1c:	30 e0       	ldi	r19, 0x00	; 0
}
    1c1e:	c9 01       	movw	r24, r18
    1c20:	df 91       	pop	r29
    1c22:	cf 91       	pop	r28
    1c24:	1f 91       	pop	r17
    1c26:	08 95       	ret
msg_t chOQGetI(OutputQueue *oqp) {
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
    1c28:	14 96       	adiw	r26, 0x04	; 4
    1c2a:	8d 91       	ld	r24, X+
    1c2c:	9c 91       	ld	r25, X
    1c2e:	15 97       	sbiw	r26, 0x05	; 5
    1c30:	89 2b       	or	r24, r25
    1c32:	19 f4       	brne	.+6      	; 0x1c3a <chOQGetI+0x9e>
    1c34:	80 e0       	ldi	r24, 0x00	; 0
    1c36:	90 e0       	ldi	r25, 0x00	; 0
    1c38:	c4 cf       	rjmp	.-120    	; 0x1bc2 <chOQGetI+0x26>
    1c3a:	2d ef       	ldi	r18, 0xFD	; 253
    1c3c:	3f ef       	ldi	r19, 0xFF	; 255
    1c3e:	ef cf       	rjmp	.-34     	; 0x1c1e <chOQGetI+0x82>

00001c40 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p OutputQueue structure
 *
 * @iclass
 */
void chOQResetI(OutputQueue *oqp) {
    1c40:	0f 93       	push	r16
    1c42:	1f 93       	push	r17
    1c44:	cf 93       	push	r28
    1c46:	df 93       	push	r29
    1c48:	ec 01       	movw	r28, r24

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
    1c4a:	2e 81       	ldd	r18, Y+6	; 0x06
    1c4c:	3f 81       	ldd	r19, Y+7	; 0x07
    1c4e:	3b 87       	std	Y+11, r19	; 0x0b
    1c50:	2a 87       	std	Y+10, r18	; 0x0a
    1c52:	3d 87       	std	Y+13, r19	; 0x0d
    1c54:	2c 87       	std	Y+12, r18	; 0x0c
  oqp->q_counter = chQSizeI(oqp);
    1c56:	88 85       	ldd	r24, Y+8	; 0x08
    1c58:	99 85       	ldd	r25, Y+9	; 0x09
    1c5a:	82 1b       	sub	r24, r18
    1c5c:	93 0b       	sbc	r25, r19
    1c5e:	9d 83       	std	Y+5, r25	; 0x05
    1c60:	8c 83       	std	Y+4, r24	; 0x04
  while (notempty(&oqp->q_waiting))
    1c62:	a8 81       	ld	r26, Y
    1c64:	b9 81       	ldd	r27, Y+1	; 0x01
    1c66:	ac 17       	cp	r26, r28
    1c68:	bd 07       	cpc	r27, r29
    1c6a:	a1 f0       	breq	.+40     	; 0x1c94 <chOQResetI+0x54>
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_RESET;
    1c6c:	0e ef       	ldi	r16, 0xFE	; 254
    1c6e:	1f ef       	ldi	r17, 0xFF	; 255
    1c70:	ed 91       	ld	r30, X+
    1c72:	fc 91       	ld	r31, X
    1c74:	11 97       	sbiw	r26, 0x01	; 1
    1c76:	f9 83       	std	Y+1, r31	; 0x01
    1c78:	e8 83       	st	Y, r30
    1c7a:	d3 83       	std	Z+3, r29	; 0x03
    1c7c:	c2 83       	std	Z+2, r28	; 0x02
    1c7e:	cd 01       	movw	r24, r26
    1c80:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
    1c84:	fc 01       	movw	r30, r24
    1c86:	13 8b       	std	Z+19, r17	; 0x13
    1c88:	02 8b       	std	Z+18, r16	; 0x12

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeI(oqp);
  while (notempty(&oqp->q_waiting))
    1c8a:	a8 81       	ld	r26, Y
    1c8c:	b9 81       	ldd	r27, Y+1	; 0x01
    1c8e:	ac 17       	cp	r26, r28
    1c90:	bd 07       	cpc	r27, r29
    1c92:	71 f7       	brne	.-36     	; 0x1c70 <chOQResetI+0x30>
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_RESET;
}
    1c94:	df 91       	pop	r29
    1c96:	cf 91       	pop	r28
    1c98:	1f 91       	pop	r17
    1c9a:	0f 91       	pop	r16
    1c9c:	08 95       	ret

00001c9e <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(InputQueue *iqp, uint8_t b) {
    1c9e:	cf 93       	push	r28
    1ca0:	df 93       	push	r29
    1ca2:	dc 01       	movw	r26, r24

  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
    1ca4:	1a 96       	adiw	r26, 0x0a	; 10
    1ca6:	ed 91       	ld	r30, X+
    1ca8:	fc 91       	ld	r31, X
    1caa:	1b 97       	sbiw	r26, 0x0b	; 11
    1cac:	1c 96       	adiw	r26, 0x0c	; 12
    1cae:	8d 91       	ld	r24, X+
    1cb0:	9c 91       	ld	r25, X
    1cb2:	1d 97       	sbiw	r26, 0x0d	; 13
    1cb4:	e8 17       	cp	r30, r24
    1cb6:	f9 07       	cpc	r31, r25
    1cb8:	b1 f1       	breq	.+108    	; 0x1d26 <chIQPutI+0x88>
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top)
    iqp->q_wrptr = iqp->q_buffer;

  if (notempty(&iqp->q_waiting))
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;
    1cba:	14 96       	adiw	r26, 0x04	; 4
    1cbc:	8d 91       	ld	r24, X+
    1cbe:	9c 91       	ld	r25, X
    1cc0:	15 97       	sbiw	r26, 0x05	; 5
  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
    return Q_FULL;

  iqp->q_counter++;
    1cc2:	01 96       	adiw	r24, 0x01	; 1
    1cc4:	15 96       	adiw	r26, 0x05	; 5
    1cc6:	9c 93       	st	X, r25
    1cc8:	8e 93       	st	-X, r24
    1cca:	14 97       	sbiw	r26, 0x04	; 4
  *iqp->q_wrptr++ = b;
    1ccc:	61 93       	st	Z+, r22
    1cce:	1b 96       	adiw	r26, 0x0b	; 11
    1cd0:	fc 93       	st	X, r31
    1cd2:	ee 93       	st	-X, r30
    1cd4:	1a 97       	sbiw	r26, 0x0a	; 10
  if (iqp->q_wrptr >= iqp->q_top)
    1cd6:	18 96       	adiw	r26, 0x08	; 8
    1cd8:	8d 91       	ld	r24, X+
    1cda:	9c 91       	ld	r25, X
    1cdc:	19 97       	sbiw	r26, 0x09	; 9
    1cde:	e8 17       	cp	r30, r24
    1ce0:	f9 07       	cpc	r31, r25
    1ce2:	40 f0       	brcs	.+16     	; 0x1cf4 <chIQPutI+0x56>
    iqp->q_wrptr = iqp->q_buffer;
    1ce4:	16 96       	adiw	r26, 0x06	; 6
    1ce6:	8d 91       	ld	r24, X+
    1ce8:	9c 91       	ld	r25, X
    1cea:	17 97       	sbiw	r26, 0x07	; 7
    1cec:	1b 96       	adiw	r26, 0x0b	; 11
    1cee:	9c 93       	st	X, r25
    1cf0:	8e 93       	st	-X, r24
    1cf2:	1a 97       	sbiw	r26, 0x0a	; 10

  if (notempty(&iqp->q_waiting))
    1cf4:	cd 91       	ld	r28, X+
    1cf6:	dc 91       	ld	r29, X
    1cf8:	11 97       	sbiw	r26, 0x01	; 1
    1cfa:	ca 17       	cp	r28, r26
    1cfc:	db 07       	cpc	r29, r27
    1cfe:	69 f0       	breq	.+26     	; 0x1d1a <chIQPutI+0x7c>
    1d00:	e8 81       	ld	r30, Y
    1d02:	f9 81       	ldd	r31, Y+1	; 0x01
    1d04:	11 96       	adiw	r26, 0x01	; 1
    1d06:	fc 93       	st	X, r31
    1d08:	ee 93       	st	-X, r30
    1d0a:	b3 83       	std	Z+3, r27	; 0x03
    1d0c:	a2 83       	std	Z+2, r26	; 0x02
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;
    1d0e:	ce 01       	movw	r24, r28
    1d10:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
    1d14:	fc 01       	movw	r30, r24
    1d16:	13 8a       	std	Z+19, r1	; 0x13
    1d18:	12 8a       	std	Z+18, r1	; 0x12
    1d1a:	20 e0       	ldi	r18, 0x00	; 0
    1d1c:	30 e0       	ldi	r19, 0x00	; 0

  return Q_OK;
}
    1d1e:	c9 01       	movw	r24, r18
    1d20:	df 91       	pop	r29
    1d22:	cf 91       	pop	r28
    1d24:	08 95       	ret
 */
msg_t chIQPutI(InputQueue *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
    1d26:	14 96       	adiw	r26, 0x04	; 4
    1d28:	8d 91       	ld	r24, X+
    1d2a:	9c 91       	ld	r25, X
    1d2c:	15 97       	sbiw	r26, 0x05	; 5
    1d2e:	89 2b       	or	r24, r25
    1d30:	19 f4       	brne	.+6      	; 0x1d38 <chIQPutI+0x9a>
    1d32:	80 e0       	ldi	r24, 0x00	; 0
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	c5 cf       	rjmp	.-118    	; 0x1cc2 <chIQPutI+0x24>
    1d38:	2c ef       	ldi	r18, 0xFC	; 252
    1d3a:	3f ef       	ldi	r19, 0xFF	; 255
    1d3c:	f0 cf       	rjmp	.-32     	; 0x1d1e <chIQPutI+0x80>

00001d3e <chIQResetI>:
 *
 * @param[in] iqp       pointer to an @p InputQueue structure
 *
 * @iclass
 */
void chIQResetI(InputQueue *iqp) {
    1d3e:	0f 93       	push	r16
    1d40:	1f 93       	push	r17
    1d42:	cf 93       	push	r28
    1d44:	df 93       	push	r29
    1d46:	ec 01       	movw	r28, r24

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
    1d48:	8e 81       	ldd	r24, Y+6	; 0x06
    1d4a:	9f 81       	ldd	r25, Y+7	; 0x07
    1d4c:	9b 87       	std	Y+11, r25	; 0x0b
    1d4e:	8a 87       	std	Y+10, r24	; 0x0a
    1d50:	9d 87       	std	Y+13, r25	; 0x0d
    1d52:	8c 87       	std	Y+12, r24	; 0x0c
  iqp->q_counter = 0;
    1d54:	1d 82       	std	Y+5, r1	; 0x05
    1d56:	1c 82       	std	Y+4, r1	; 0x04
  while (notempty(&iqp->q_waiting))
    1d58:	a8 81       	ld	r26, Y
    1d5a:	b9 81       	ldd	r27, Y+1	; 0x01
    1d5c:	ac 17       	cp	r26, r28
    1d5e:	bd 07       	cpc	r27, r29
    1d60:	a1 f0       	breq	.+40     	; 0x1d8a <chIQResetI+0x4c>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_RESET;
    1d62:	0e ef       	ldi	r16, 0xFE	; 254
    1d64:	1f ef       	ldi	r17, 0xFF	; 255
    1d66:	ed 91       	ld	r30, X+
    1d68:	fc 91       	ld	r31, X
    1d6a:	11 97       	sbiw	r26, 0x01	; 1
    1d6c:	f9 83       	std	Y+1, r31	; 0x01
    1d6e:	e8 83       	st	Y, r30
    1d70:	d3 83       	std	Z+3, r29	; 0x03
    1d72:	c2 83       	std	Z+2, r28	; 0x02
    1d74:	cd 01       	movw	r24, r26
    1d76:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <chSchReadyI>
    1d7a:	fc 01       	movw	r30, r24
    1d7c:	13 8b       	std	Z+19, r17	; 0x13
    1d7e:	02 8b       	std	Z+18, r16	; 0x12

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
  while (notempty(&iqp->q_waiting))
    1d80:	a8 81       	ld	r26, Y
    1d82:	b9 81       	ldd	r27, Y+1	; 0x01
    1d84:	ac 17       	cp	r26, r28
    1d86:	bd 07       	cpc	r27, r29
    1d88:	71 f7       	brne	.-36     	; 0x1d66 <chIQResetI+0x28>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_RESET;
}
    1d8a:	df 91       	pop	r29
    1d8c:	cf 91       	pop	r28
    1d8e:	1f 91       	pop	r17
    1d90:	0f 91       	pop	r16
    1d92:	08 95       	ret

00001d94 <_core_init>:
  extern uint8_t __heap_end__[];
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
#else
  static stkalign_t buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
  nextmem = (uint8_t *)&buffer[0];
    1d94:	80 e1       	ldi	r24, 0x10	; 16
    1d96:	9a e0       	ldi	r25, 0x0A	; 10
    1d98:	90 93 91 0a 	sts	0x0A91, r25
    1d9c:	80 93 90 0a 	sts	0x0A90, r24
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
    1da0:	80 e9       	ldi	r24, 0x90	; 144
    1da2:	9a e0       	ldi	r25, 0x0A	; 10
    1da4:	90 93 93 0a 	sts	0x0A93, r25
    1da8:	80 93 92 0a 	sts	0x0A92, r24
#endif
}
    1dac:	08 95       	ret

00001dae <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
    1dae:	ac 01       	movw	r20, r24
  void *p;

  chSysLock();
    1db0:	f8 94       	cli
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size)
    1db2:	20 91 90 0a 	lds	r18, 0x0A90
    1db6:	30 91 91 0a 	lds	r19, 0x0A91
    1dba:	80 91 92 0a 	lds	r24, 0x0A92
    1dbe:	90 91 93 0a 	lds	r25, 0x0A93
    1dc2:	82 1b       	sub	r24, r18
    1dc4:	93 0b       	sbc	r25, r19
    1dc6:	84 17       	cp	r24, r20
    1dc8:	95 07       	cpc	r25, r21
    1dca:	48 f0       	brcs	.+18     	; 0x1dde <chCoreAlloc+0x30>
    return NULL;
  p = nextmem;
  nextmem += size;
    1dcc:	42 0f       	add	r20, r18
    1dce:	53 1f       	adc	r21, r19
    1dd0:	50 93 91 0a 	sts	0x0A91, r21
    1dd4:	40 93 90 0a 	sts	0x0A90, r20
void *chCoreAlloc(size_t size) {
  void *p;

  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();
    1dd8:	78 94       	sei
  return p;
}
    1dda:	c9 01       	movw	r24, r18
    1ddc:	08 95       	ret
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size)
    1dde:	20 e0       	ldi	r18, 0x00	; 0
    1de0:	30 e0       	ldi	r19, 0x00	; 0
void *chCoreAlloc(size_t size) {
  void *p;

  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();
    1de2:	78 94       	sei
  return p;
}
    1de4:	c9 01       	movw	r24, r18
    1de6:	08 95       	ret

00001de8 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
    1de8:	9c 01       	movw	r18, r24
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size)
    1dea:	40 91 90 0a 	lds	r20, 0x0A90
    1dee:	50 91 91 0a 	lds	r21, 0x0A91
    1df2:	80 91 92 0a 	lds	r24, 0x0A92
    1df6:	90 91 93 0a 	lds	r25, 0x0A93
    1dfa:	84 1b       	sub	r24, r20
    1dfc:	95 0b       	sbc	r25, r21
    1dfe:	82 17       	cp	r24, r18
    1e00:	93 07       	cpc	r25, r19
    1e02:	48 f0       	brcs	.+18     	; 0x1e16 <chCoreAllocI+0x2e>
    return NULL;
  p = nextmem;
  nextmem += size;
    1e04:	24 0f       	add	r18, r20
    1e06:	35 1f       	adc	r19, r21
    1e08:	30 93 91 0a 	sts	0x0A91, r19
    1e0c:	20 93 90 0a 	sts	0x0A90, r18
    1e10:	9a 01       	movw	r18, r20
  return p;
}
    1e12:	c9 01       	movw	r24, r18
    1e14:	08 95       	ret
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size)
    1e16:	20 e0       	ldi	r18, 0x00	; 0
    1e18:	30 e0       	ldi	r19, 0x00	; 0
    return NULL;
  p = nextmem;
  nextmem += size;
  return p;
}
    1e1a:	c9 01       	movw	r24, r18
    1e1c:	08 95       	ret

00001e1e <chCoreStatus>:
 *
 * @return              The size, in bytes, of the free core memory.
 *
 * @api
 */
size_t chCoreStatus(void) {
    1e1e:	20 91 92 0a 	lds	r18, 0x0A92
    1e22:	30 91 93 0a 	lds	r19, 0x0A93
    1e26:	80 91 90 0a 	lds	r24, 0x0A90
    1e2a:	90 91 91 0a 	lds	r25, 0x0A91
    1e2e:	28 1b       	sub	r18, r24
    1e30:	39 0b       	sbc	r19, r25

  return (size_t)(endmem - nextmem);
}
    1e32:	c9 01       	movw	r24, r18
    1e34:	08 95       	ret

00001e36 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
    1e36:	af 92       	push	r10
    1e38:	bf 92       	push	r11
    1e3a:	cf 92       	push	r12
    1e3c:	df 92       	push	r13
    1e3e:	ef 92       	push	r14
    1e40:	ff 92       	push	r15
    1e42:	0f 93       	push	r16
    1e44:	1f 93       	push	r17
    1e46:	df 93       	push	r29
    1e48:	cf 93       	push	r28
    1e4a:	cd b7       	in	r28, 0x3d	; 61
    1e4c:	de b7       	in	r29, 0x3e	; 62
    1e4e:	60 97       	sbiw	r28, 0x10	; 16
    1e50:	0f b6       	in	r0, 0x3f	; 63
    1e52:	f8 94       	cli
    1e54:	de bf       	out	0x3e, r29	; 62
    1e56:	0f be       	out	0x3f, r0	; 63
    1e58:	cd bf       	out	0x3d, r28	; 61
    1e5a:	7b 01       	movw	r14, r22
    1e5c:	8c 01       	movw	r16, r24
  char buf[16], *p;

  if (!n)
    1e5e:	61 15       	cp	r22, r1
    1e60:	71 05       	cpc	r23, r1
    1e62:	81 05       	cpc	r24, r1
    1e64:	91 05       	cpc	r25, r1
    1e66:	09 f4       	brne	.+2      	; 0x1e6a <test_printn+0x34>
    1e68:	49 c0       	rjmp	.+146    	; 0x1efc <test_printn+0xc6>
    chSequentialStreamPut(chp, '0');
    1e6a:	5e 01       	movw	r10, r28
    1e6c:	08 94       	sec
    1e6e:	a1 1c       	adc	r10, r1
    1e70:	b1 1c       	adc	r11, r1
    1e72:	65 01       	movw	r12, r10
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    1e74:	c8 01       	movw	r24, r16
    1e76:	b7 01       	movw	r22, r14
    1e78:	2a e0       	ldi	r18, 0x0A	; 10
    1e7a:	30 e0       	ldi	r19, 0x00	; 0
    1e7c:	40 e0       	ldi	r20, 0x00	; 0
    1e7e:	50 e0       	ldi	r21, 0x00	; 0
    1e80:	0e 94 2f 33 	call	0x665e	; 0x665e <__udivmodsi4>
    1e84:	60 5d       	subi	r22, 0xD0	; 208
    1e86:	f6 01       	movw	r30, r12
    1e88:	61 93       	st	Z+, r22
    1e8a:	6f 01       	movw	r12, r30
    1e8c:	c8 01       	movw	r24, r16
    1e8e:	b7 01       	movw	r22, r14
    1e90:	2a e0       	ldi	r18, 0x0A	; 10
    1e92:	30 e0       	ldi	r19, 0x00	; 0
    1e94:	40 e0       	ldi	r20, 0x00	; 0
    1e96:	50 e0       	ldi	r21, 0x00	; 0
    1e98:	0e 94 2f 33 	call	0x665e	; 0x665e <__udivmodsi4>
    1e9c:	c9 01       	movw	r24, r18
    1e9e:	da 01       	movw	r26, r20
    1ea0:	7c 01       	movw	r14, r24
    1ea2:	8d 01       	movw	r16, r26

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
    1ea4:	e1 14       	cp	r14, r1
    1ea6:	f1 04       	cpc	r15, r1
    1ea8:	01 05       	cpc	r16, r1
    1eaa:	11 05       	cpc	r17, r1
    1eac:	19 f7       	brne	.-58     	; 0x1e74 <test_printn+0x3e>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
    1eae:	ac 14       	cp	r10, r12
    1eb0:	bd 04       	cpc	r11, r13
    1eb2:	98 f4       	brcc	.+38     	; 0x1eda <test_printn+0xa4>
      chSequentialStreamPut(chp, *--p);
    1eb4:	e0 91 aa 0a 	lds	r30, 0x0AAA
    1eb8:	f0 91 ab 0a 	lds	r31, 0x0AAB
    1ebc:	a0 81       	ld	r26, Z
    1ebe:	b1 81       	ldd	r27, Z+1	; 0x01
    1ec0:	14 96       	adiw	r26, 0x04	; 4
    1ec2:	2d 91       	ld	r18, X+
    1ec4:	3c 91       	ld	r19, X
    1ec6:	15 97       	sbiw	r26, 0x05	; 5
    1ec8:	cf 01       	movw	r24, r30
    1eca:	f6 01       	movw	r30, r12
    1ecc:	62 91       	ld	r22, -Z
    1ece:	6f 01       	movw	r12, r30
    1ed0:	f9 01       	movw	r30, r18
    1ed2:	09 95       	icall
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
    1ed4:	ac 14       	cp	r10, r12
    1ed6:	bd 04       	cpc	r11, r13
    1ed8:	68 f3       	brcs	.-38     	; 0x1eb4 <test_printn+0x7e>
      chSequentialStreamPut(chp, *--p);
  }
}
    1eda:	60 96       	adiw	r28, 0x10	; 16
    1edc:	0f b6       	in	r0, 0x3f	; 63
    1ede:	f8 94       	cli
    1ee0:	de bf       	out	0x3e, r29	; 62
    1ee2:	0f be       	out	0x3f, r0	; 63
    1ee4:	cd bf       	out	0x3d, r28	; 61
    1ee6:	cf 91       	pop	r28
    1ee8:	df 91       	pop	r29
    1eea:	1f 91       	pop	r17
    1eec:	0f 91       	pop	r16
    1eee:	ff 90       	pop	r15
    1ef0:	ef 90       	pop	r14
    1ef2:	df 90       	pop	r13
    1ef4:	cf 90       	pop	r12
    1ef6:	bf 90       	pop	r11
    1ef8:	af 90       	pop	r10
    1efa:	08 95       	ret
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
    1efc:	e0 91 aa 0a 	lds	r30, 0x0AAA
    1f00:	f0 91 ab 0a 	lds	r31, 0x0AAB
    1f04:	a0 81       	ld	r26, Z
    1f06:	b1 81       	ldd	r27, Z+1	; 0x01
    1f08:	14 96       	adiw	r26, 0x04	; 4
    1f0a:	2d 91       	ld	r18, X+
    1f0c:	3c 91       	ld	r19, X
    1f0e:	15 97       	sbiw	r26, 0x05	; 5
    1f10:	cf 01       	movw	r24, r30
    1f12:	60 e3       	ldi	r22, 0x30	; 48
    1f14:	f9 01       	movw	r30, r18
    1f16:	09 95       	icall
    1f18:	e0 cf       	rjmp	.-64     	; 0x1eda <test_printn+0xa4>

00001f1a <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
    1f1a:	cf 93       	push	r28
    1f1c:	df 93       	push	r29
    1f1e:	ec 01       	movw	r28, r24

  while (*msgp)
    1f20:	68 81       	ld	r22, Y
    1f22:	66 23       	and	r22, r22
    1f24:	89 f0       	breq	.+34     	; 0x1f48 <test_print+0x2e>
    chSequentialStreamPut(chp, *msgp++);
    1f26:	e0 91 aa 0a 	lds	r30, 0x0AAA
    1f2a:	f0 91 ab 0a 	lds	r31, 0x0AAB
    1f2e:	21 96       	adiw	r28, 0x01	; 1
    1f30:	a0 81       	ld	r26, Z
    1f32:	b1 81       	ldd	r27, Z+1	; 0x01
    1f34:	14 96       	adiw	r26, 0x04	; 4
    1f36:	2d 91       	ld	r18, X+
    1f38:	3c 91       	ld	r19, X
    1f3a:	15 97       	sbiw	r26, 0x05	; 5
    1f3c:	cf 01       	movw	r24, r30
    1f3e:	f9 01       	movw	r30, r18
    1f40:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    1f42:	68 81       	ld	r22, Y
    1f44:	66 23       	and	r22, r22
    1f46:	79 f7       	brne	.-34     	; 0x1f26 <test_print+0xc>
    chSequentialStreamPut(chp, *msgp++);
}
    1f48:	df 91       	pop	r29
    1f4a:	cf 91       	pop	r28
    1f4c:	08 95       	ret

00001f4e <test_println>:
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
    1f4e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
    1f52:	e0 91 aa 0a 	lds	r30, 0x0AAA
    1f56:	f0 91 ab 0a 	lds	r31, 0x0AAB
    1f5a:	a0 81       	ld	r26, Z
    1f5c:	b1 81       	ldd	r27, Z+1	; 0x01
    1f5e:	2d 91       	ld	r18, X+
    1f60:	3c 91       	ld	r19, X
    1f62:	cf 01       	movw	r24, r30
    1f64:	6b e1       	ldi	r22, 0x1B	; 27
    1f66:	71 e0       	ldi	r23, 0x01	; 1
    1f68:	42 e0       	ldi	r20, 0x02	; 2
    1f6a:	50 e0       	ldi	r21, 0x00	; 0
    1f6c:	f9 01       	movw	r30, r18
    1f6e:	09 95       	icall
}
    1f70:	08 95       	ret

00001f72 <test_emit_token>:
 *
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {

  chSysLock();
    1f72:	f8 94       	cli
  *tokp++ = token;
    1f74:	e0 91 a8 0a 	lds	r30, 0x0AA8
    1f78:	f0 91 a9 0a 	lds	r31, 0x0AA9
    1f7c:	81 93       	st	Z+, r24
    1f7e:	f0 93 a9 0a 	sts	0x0AA9, r31
    1f82:	e0 93 a8 0a 	sts	0x0AA8, r30
  chSysUnlock();
    1f86:	78 94       	sei
}
    1f88:	08 95       	ret

00001f8a <_test_fail>:
/*
 * Assertions.
 */
bool_t _test_fail(unsigned point) {

  local_fail = TRUE;
    1f8a:	21 e0       	ldi	r18, 0x01	; 1
    1f8c:	20 93 94 0a 	sts	0x0A94, r18
  global_fail = TRUE;
    1f90:	20 93 95 0a 	sts	0x0A95, r18
  failpoint = point;
    1f94:	90 93 97 0a 	sts	0x0A97, r25
    1f98:	80 93 96 0a 	sts	0x0A96, r24
  return TRUE;
}
    1f9c:	81 e0       	ldi	r24, 0x01	; 1
    1f9e:	08 95       	ret

00001fa0 <_test_assert>:

bool_t _test_assert(unsigned point, bool_t condition) {
    1fa0:	9c 01       	movw	r18, r24

  if (!condition)
    1fa2:	66 23       	and	r22, r22
    1fa4:	51 f4       	brne	.+20     	; 0x1fba <_test_assert+0x1a>
/*
 * Assertions.
 */
bool_t _test_fail(unsigned point) {

  local_fail = TRUE;
    1fa6:	81 e0       	ldi	r24, 0x01	; 1
    1fa8:	80 93 94 0a 	sts	0x0A94, r24
  global_fail = TRUE;
    1fac:	80 93 95 0a 	sts	0x0A95, r24
  failpoint = point;
    1fb0:	30 93 97 0a 	sts	0x0A97, r19
    1fb4:	20 93 96 0a 	sts	0x0A96, r18
bool_t _test_assert(unsigned point, bool_t condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
}
    1fb8:	08 95       	ret
  return TRUE;
}

bool_t _test_assert(unsigned point, bool_t condition) {

  if (!condition)
    1fba:	80 e0       	ldi	r24, 0x00	; 0
    1fbc:	08 95       	ret

00001fbe <_test_assert_sequence>:
    return _test_fail(point);
  return FALSE;
}

bool_t _test_assert_sequence(unsigned point, char *expected) {
    1fbe:	ac 01       	movw	r20, r24
    1fc0:	db 01       	movw	r26, r22
  char *cp = tokens_buffer;
  while (cp < tokp) {
    1fc2:	20 91 a8 0a 	lds	r18, 0x0AA8
    1fc6:	30 91 a9 0a 	lds	r19, 0x0AA9
    1fca:	68 e9       	ldi	r22, 0x98	; 152
    1fcc:	7a e0       	ldi	r23, 0x0A	; 10
    1fce:	fb 01       	movw	r30, r22
    1fd0:	02 c0       	rjmp	.+4      	; 0x1fd6 <_test_assert_sequence+0x18>
    if (*cp++ != *expected++)
    1fd2:	31 96       	adiw	r30, 0x01	; 1
    1fd4:	11 96       	adiw	r26, 0x01	; 1
  return FALSE;
}

bool_t _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
    1fd6:	e2 17       	cp	r30, r18
    1fd8:	f3 07       	cpc	r31, r19
    1fda:	70 f4       	brcc	.+28     	; 0x1ff8 <_test_assert_sequence+0x3a>
    if (*cp++ != *expected++)
    1fdc:	90 81       	ld	r25, Z
    1fde:	8c 91       	ld	r24, X
    1fe0:	98 17       	cp	r25, r24
    1fe2:	b9 f3       	breq	.-18     	; 0x1fd2 <_test_assert_sequence+0x14>
/*
 * Assertions.
 */
bool_t _test_fail(unsigned point) {

  local_fail = TRUE;
    1fe4:	81 e0       	ldi	r24, 0x01	; 1
    1fe6:	80 93 94 0a 	sts	0x0A94, r24
  global_fail = TRUE;
    1fea:	80 93 95 0a 	sts	0x0A95, r24
  failpoint = point;
    1fee:	50 93 97 0a 	sts	0x0A97, r21
    1ff2:	40 93 96 0a 	sts	0x0A96, r20
    1ff6:	08 95       	ret
  char *cp = tokens_buffer;
  while (cp < tokp) {
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
    1ff8:	8c 91       	ld	r24, X
    1ffa:	88 23       	and	r24, r24
    1ffc:	99 f7       	brne	.-26     	; 0x1fe4 <_test_assert_sequence+0x26>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
    1ffe:	70 93 a9 0a 	sts	0x0AA9, r23
    2002:	60 93 a8 0a 	sts	0x0AA8, r22
    2006:	80 e0       	ldi	r24, 0x00	; 0
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
    2008:	08 95       	ret

0000200a <test_cpu_pulse>:
 * @param[in] duration      CPU pulse duration in milliseconds
 */
void test_cpu_pulse(unsigned duration) {
  systime_t start, end, now;

  start = chThdSelf()->p_time;
    200a:	e0 91 fe 0b 	lds	r30, 0x0BFE
    200e:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2012:	40 89       	ldd	r20, Z+16	; 0x10
    2014:	51 89       	ldd	r21, Z+17	; 0x11
  end = start + MS2ST(duration);
    2016:	84 0f       	add	r24, r20
    2018:	95 1f       	adc	r25, r21
  do {
    now = chThdSelf()->p_time;
    201a:	20 89       	ldd	r18, Z+16	; 0x10
    201c:	31 89       	ldd	r19, Z+17	; 0x11
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  }
  while (end > start ? (now >= start) && (now < end) :
                       (now >= start) || (now < end));
    201e:	48 17       	cp	r20, r24
    2020:	59 07       	cpc	r21, r25
    2022:	20 f4       	brcc	.+8      	; 0x202c <test_cpu_pulse+0x22>
    2024:	24 17       	cp	r18, r20
    2026:	35 07       	cpc	r19, r21
    2028:	20 f4       	brcc	.+8      	; 0x2032 <test_cpu_pulse+0x28>
    202a:	08 95       	ret
    202c:	24 17       	cp	r18, r20
    202e:	35 07       	cpc	r19, r21
    2030:	a0 f7       	brcc	.-24     	; 0x201a <test_cpu_pulse+0x10>
    2032:	28 17       	cp	r18, r24
    2034:	39 07       	cpc	r19, r25
    2036:	88 f3       	brcs	.-30     	; 0x201a <test_cpu_pulse+0x10>
    2038:	08 95       	ret

0000203a <tmr>:

static VirtualTimer vt;
static void tmr(void *p) {
  (void)p;

  test_timer_done = TRUE;
    203a:	81 e0       	ldi	r24, 0x01	; 1
    203c:	80 93 00 0c 	sts	0x0C00, r24
}
    2040:	08 95       	ret

00002042 <print_line>:
    tcp->teardown();

  test_wait_threads();
}

static void print_line(void) {
    2042:	cf 93       	push	r28
    2044:	df 93       	push	r29
    2046:	c0 e0       	ldi	r28, 0x00	; 0
    2048:	d0 e0       	ldi	r29, 0x00	; 0
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
    204a:	e0 91 aa 0a 	lds	r30, 0x0AAA
    204e:	f0 91 ab 0a 	lds	r31, 0x0AAB
    2052:	a0 81       	ld	r26, Z
    2054:	b1 81       	ldd	r27, Z+1	; 0x01
    2056:	14 96       	adiw	r26, 0x04	; 4
    2058:	2d 91       	ld	r18, X+
    205a:	3c 91       	ld	r19, X
    205c:	15 97       	sbiw	r26, 0x05	; 5
    205e:	cf 01       	movw	r24, r30
    2060:	6d e2       	ldi	r22, 0x2D	; 45
    2062:	f9 01       	movw	r30, r18
    2064:	09 95       	icall
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
    2066:	21 96       	adiw	r28, 0x01	; 1
    2068:	cc 34       	cpi	r28, 0x4C	; 76
    206a:	d1 05       	cpc	r29, r1
    206c:	71 f7       	brne	.-36     	; 0x204a <print_line+0x8>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
    206e:	e0 91 aa 0a 	lds	r30, 0x0AAA
    2072:	f0 91 ab 0a 	lds	r31, 0x0AAB
    2076:	a0 81       	ld	r26, Z
    2078:	b1 81       	ldd	r27, Z+1	; 0x01
    207a:	2d 91       	ld	r18, X+
    207c:	3c 91       	ld	r19, X
    207e:	cf 01       	movw	r24, r30
    2080:	6b e1       	ldi	r22, 0x1B	; 27
    2082:	71 e0       	ldi	r23, 0x01	; 1
    2084:	42 e0       	ldi	r20, 0x02	; 2
    2086:	50 e0       	ldi	r21, 0x00	; 0
    2088:	f9 01       	movw	r30, r18
    208a:	09 95       	icall
}
    208c:	df 91       	pop	r29
    208e:	cf 91       	pop	r28
    2090:	08 95       	ret

00002092 <test_wait_tick>:
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {

  chThdSleep(1);
    2092:	81 e0       	ldi	r24, 0x01	; 1
    2094:	90 e0       	ldi	r25, 0x00	; 0
    2096:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  return chTimeNow();
    209a:	20 91 f1 0b 	lds	r18, 0x0BF1
    209e:	30 91 f2 0b 	lds	r19, 0x0BF2
}
    20a2:	c9 01       	movw	r24, r18
    20a4:	08 95       	ret

000020a6 <test_start_timer>:
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
    20a6:	bc 01       	movw	r22, r24

  systime_t duration = MS2ST(ms);
  test_timer_done = FALSE;
    20a8:	10 92 00 0c 	sts	0x0C00, r1
  chVTSet(&vt, duration, tmr, NULL);
    20ac:	f8 94       	cli
    20ae:	8c ea       	ldi	r24, 0xAC	; 172
    20b0:	9a e0       	ldi	r25, 0x0A	; 10
    20b2:	4d e1       	ldi	r20, 0x1D	; 29
    20b4:	50 e1       	ldi	r21, 0x10	; 16
    20b6:	20 e0       	ldi	r18, 0x00	; 0
    20b8:	30 e0       	ldi	r19, 0x00	; 0
    20ba:	0e 94 4b 01 	call	0x296	; 0x296 <chVTSetI>
    20be:	78 94       	sei
}
    20c0:	08 95       	ret

000020c2 <test_wait_threads>:
}

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
    20c2:	cf 93       	push	r28
    20c4:	df 93       	push	r29
    20c6:	c1 e0       	ldi	r28, 0x01	; 1
    20c8:	dc e0       	ldi	r29, 0x0C	; 12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
    20ca:	88 81       	ld	r24, Y
    20cc:	99 81       	ldd	r25, Y+1	; 0x01
    20ce:	00 97       	sbiw	r24, 0x00	; 0
    20d0:	21 f0       	breq	.+8      	; 0x20da <test_wait_threads+0x18>
      chThdWait(threads[i]);
    20d2:	0e 94 cd 03 	call	0x79a	; 0x79a <chThdWait>
      threads[i] = NULL;
    20d6:	19 82       	std	Y+1, r1	; 0x01
    20d8:	18 82       	st	Y, r1
    20da:	22 96       	adiw	r28, 0x02	; 2
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    20dc:	8c e0       	ldi	r24, 0x0C	; 12
    20de:	cb 30       	cpi	r28, 0x0B	; 11
    20e0:	d8 07       	cpc	r29, r24
    20e2:	99 f7       	brne	.-26     	; 0x20ca <test_wait_threads+0x8>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
    20e4:	df 91       	pop	r29
    20e6:	cf 91       	pop	r28
    20e8:	08 95       	ret

000020ea <TestThread>:
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 * @return              A failure boolean value.
 */
msg_t TestThread(void *p) {
    20ea:	4f 92       	push	r4
    20ec:	5f 92       	push	r5
    20ee:	6f 92       	push	r6
    20f0:	7f 92       	push	r7
    20f2:	8f 92       	push	r8
    20f4:	9f 92       	push	r9
    20f6:	af 92       	push	r10
    20f8:	bf 92       	push	r11
    20fa:	cf 92       	push	r12
    20fc:	df 92       	push	r13
    20fe:	ef 92       	push	r14
    2100:	ff 92       	push	r15
    2102:	0f 93       	push	r16
    2104:	1f 93       	push	r17
    2106:	cf 93       	push	r28
    2108:	df 93       	push	r29
  int i, j;

  chp = p;
    210a:	90 93 ab 0a 	sts	0x0AAB, r25
    210e:	80 93 aa 0a 	sts	0x0AAA, r24
  test_println("");
    2112:	8e e1       	ldi	r24, 0x1E	; 30
    2114:	91 e0       	ldi	r25, 0x01	; 1
    2116:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
  test_println("*** ChibiOS/RT test suite");
    211a:	8f e1       	ldi	r24, 0x1F	; 31
    211c:	91 e0       	ldi	r25, 0x01	; 1
    211e:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
  test_println("***");
    2122:	89 e3       	ldi	r24, 0x39	; 57
    2124:	91 e0       	ldi	r25, 0x01	; 1
    2126:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
  test_print("*** Kernel:       ");
    212a:	8d e3       	ldi	r24, 0x3D	; 61
    212c:	91 e0       	ldi	r25, 0x01	; 1
    212e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_println(CH_KERNEL_VERSION);
    2132:	80 e5       	ldi	r24, 0x50	; 80
    2134:	91 e0       	ldi	r25, 0x01	; 1
    2136:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
  test_print("*** Compiled:     ");
    213a:	8e e5       	ldi	r24, 0x5E	; 94
    213c:	91 e0       	ldi	r25, 0x01	; 1
    213e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_println(__DATE__ " - " __TIME__);
    2142:	81 e7       	ldi	r24, 0x71	; 113
    2144:	91 e0       	ldi	r25, 0x01	; 1
    2146:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#ifdef CH_COMPILER_NAME
  test_print("*** Compiler:     ");
    214a:	88 e8       	ldi	r24, 0x88	; 136
    214c:	91 e0       	ldi	r25, 0x01	; 1
    214e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_println(CH_COMPILER_NAME);
    2152:	8b e9       	ldi	r24, 0x9B	; 155
    2154:	91 e0       	ldi	r25, 0x01	; 1
    2156:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#endif
  test_print("*** Architecture: ");
    215a:	85 ea       	ldi	r24, 0xA5	; 165
    215c:	91 e0       	ldi	r25, 0x01	; 1
    215e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_println(CH_ARCHITECTURE_NAME);
    2162:	88 eb       	ldi	r24, 0xB8	; 184
    2164:	91 e0       	ldi	r25, 0x01	; 1
    2166:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#ifdef CH_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
    216a:	8c eb       	ldi	r24, 0xBC	; 188
    216c:	91 e0       	ldi	r25, 0x01	; 1
    216e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_println(CH_CORE_VARIANT_NAME);
    2172:	8f ec       	ldi	r24, 0xCF	; 207
    2174:	91 e0       	ldi	r25, 0x01	; 1
    2176:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#endif
#ifdef CH_PORT_INFO
  test_print("*** Port Info:    ");
    217a:	87 ed       	ldi	r24, 0xD7	; 215
    217c:	91 e0       	ldi	r25, 0x01	; 1
    217e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_println(CH_PORT_INFO);
    2182:	8a ee       	ldi	r24, 0xEA	; 234
    2184:	91 e0       	ldi	r25, 0x01	; 1
    2186:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
    218a:	8f ee       	ldi	r24, 0xEF	; 239
    218c:	91 e0       	ldi	r25, 0x01	; 1
    218e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_println(PLATFORM_NAME);
    2192:	82 e0       	ldi	r24, 0x02	; 2
    2194:	92 e0       	ldi	r25, 0x02	; 2
    2196:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
    219a:	8c e0       	ldi	r24, 0x0C	; 12
    219c:	92 e0       	ldi	r25, 0x02	; 2
    219e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_println(BOARD_NAME);
    21a2:	8f e1       	ldi	r24, 0x1F	; 31
    21a4:	92 e0       	ldi	r25, 0x02	; 2
    21a6:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#endif
  test_println("");
    21aa:	8e e1       	ldi	r24, 0x1E	; 30
    21ac:	91 e0       	ldi	r25, 0x01	; 1
    21ae:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>

  global_fail = FALSE;
    21b2:	10 92 95 0a 	sts	0x0A95, r1
    21b6:	41 ea       	ldi	r20, 0xA1	; 161
    21b8:	44 2e       	mov	r4, r20
    21ba:	42 e0       	ldi	r20, 0x02	; 2
    21bc:	54 2e       	mov	r5, r20
    21be:	86 e4       	ldi	r24, 0x46	; 70
    21c0:	93 e0       	ldi	r25, 0x03	; 3
    21c2:	31 e0       	ldi	r19, 0x01	; 1
    21c4:	83 2e       	mov	r8, r19
    21c6:	91 2c       	mov	r9, r1
    21c8:	a1 2c       	mov	r10, r1
    21ca:	b1 2c       	mov	r11, r1
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
    21cc:	28 e9       	ldi	r18, 0x98	; 152
    21ce:	62 2e       	mov	r6, r18
    21d0:	2a e0       	ldi	r18, 0x0A	; 10
    21d2:	72 2e       	mov	r7, r18
#endif
  test_println("");

  global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    21d4:	6c 01       	movw	r12, r24
    21d6:	81 e0       	ldi	r24, 0x01	; 1
    21d8:	e8 2e       	mov	r14, r24
    21da:	f1 2c       	mov	r15, r1
    21dc:	01 2d       	mov	r16, r1
    21de:	11 2d       	mov	r17, r1
    j = 0;
    while (patterns[i][j]) {
    21e0:	d6 01       	movw	r26, r12
    21e2:	8d 91       	ld	r24, X+
    21e4:	9c 91       	ld	r25, X
    21e6:	89 2b       	or	r24, r25
    21e8:	09 f4       	brne	.+2      	; 0x21ec <TestThread+0x102>
    21ea:	97 c0       	rjmp	.+302    	; 0x231a <TestThread+0x230>
      print_line();
    21ec:	0e 94 21 10 	call	0x2042	; 0x2042 <print_line>
      test_print("--- Test Case ");
    21f0:	8f e2       	ldi	r24, 0x2F	; 47
    21f2:	92 e0       	ldi	r25, 0x02	; 2
    21f4:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
      test_printn(i + 1);
    21f8:	c5 01       	movw	r24, r10
    21fa:	b4 01       	movw	r22, r8
    21fc:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
      test_print(".");
    2200:	8e e3       	ldi	r24, 0x3E	; 62
    2202:	92 e0       	ldi	r25, 0x02	; 2
    2204:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
      test_printn(j + 1);
    2208:	c8 01       	movw	r24, r16
    220a:	b7 01       	movw	r22, r14
    220c:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
      test_print(" (");
    2210:	80 e4       	ldi	r24, 0x40	; 64
    2212:	92 e0       	ldi	r25, 0x02	; 2
    2214:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
      test_print(patterns[i][j]->name);
    2218:	d6 01       	movw	r26, r12
    221a:	ed 91       	ld	r30, X+
    221c:	fc 91       	ld	r31, X
    221e:	80 81       	ld	r24, Z
    2220:	91 81       	ldd	r25, Z+1	; 0x01
    2222:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
      test_println(")");
    2226:	83 e4       	ldi	r24, 0x43	; 67
    2228:	92 e0       	ldi	r25, 0x02	; 2
    222a:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
    222e:	88 ec       	ldi	r24, 0xC8	; 200
    2230:	90 e0       	ldi	r25, 0x00	; 0
    2232:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
#endif
      execute_test(patterns[i][j]);
    2236:	f6 01       	movw	r30, r12
    2238:	c0 81       	ld	r28, Z
    223a:	d1 81       	ldd	r29, Z+1	; 0x01
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
    223c:	70 92 a9 0a 	sts	0x0AA9, r7
    2240:	60 92 a8 0a 	sts	0x0AA8, r6
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
    2244:	10 92 94 0a 	sts	0x0A94, r1
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
    2248:	10 92 02 0c 	sts	0x0C02, r1
    224c:	10 92 01 0c 	sts	0x0C01, r1
    2250:	10 92 04 0c 	sts	0x0C04, r1
    2254:	10 92 03 0c 	sts	0x0C03, r1
    2258:	10 92 06 0c 	sts	0x0C06, r1
    225c:	10 92 05 0c 	sts	0x0C05, r1
    2260:	10 92 08 0c 	sts	0x0C08, r1
    2264:	10 92 07 0c 	sts	0x0C07, r1
    2268:	10 92 0a 0c 	sts	0x0C0A, r1
    226c:	10 92 09 0c 	sts	0x0C09, r1

  if (tcp->setup != NULL)
    2270:	ea 81       	ldd	r30, Y+2	; 0x02
    2272:	fb 81       	ldd	r31, Y+3	; 0x03
    2274:	30 97       	sbiw	r30, 0x00	; 0
    2276:	09 f0       	breq	.+2      	; 0x227a <TestThread+0x190>
    tcp->setup();
    2278:	09 95       	icall
  tcp->execute();
    227a:	ee 81       	ldd	r30, Y+6	; 0x06
    227c:	ff 81       	ldd	r31, Y+7	; 0x07
    227e:	09 95       	icall
  if (tcp->teardown != NULL)
    2280:	ec 81       	ldd	r30, Y+4	; 0x04
    2282:	fd 81       	ldd	r31, Y+5	; 0x05
    2284:	30 97       	sbiw	r30, 0x00	; 0
    2286:	09 f0       	breq	.+2      	; 0x228a <TestThread+0x1a0>
    tcp->teardown();
    2288:	09 95       	icall

  test_wait_threads();
    228a:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
    228e:	80 91 94 0a 	lds	r24, 0x0A94
    2292:	88 23       	and	r24, r24
    2294:	09 f4       	brne	.+2      	; 0x2298 <TestThread+0x1ae>
    2296:	76 c0       	rjmp	.+236    	; 0x2384 <TestThread+0x29a>
        test_print("--- Result: FAILURE (#");
    2298:	85 e4       	ldi	r24, 0x45	; 69
    229a:	92 e0       	ldi	r25, 0x02	; 2
    229c:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
        test_printn(failpoint);
    22a0:	60 91 96 0a 	lds	r22, 0x0A96
    22a4:	70 91 97 0a 	lds	r23, 0x0A97
    22a8:	80 e0       	ldi	r24, 0x00	; 0
    22aa:	90 e0       	ldi	r25, 0x00	; 0
    22ac:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
        test_print(" [");
    22b0:	8c e5       	ldi	r24, 0x5C	; 92
    22b2:	92 e0       	ldi	r25, 0x02	; 2
    22b4:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
    22b8:	80 91 a8 0a 	lds	r24, 0x0AA8
    22bc:	90 91 a9 0a 	lds	r25, 0x0AA9
    22c0:	88 59       	subi	r24, 0x98	; 152
    22c2:	9a 40       	sbci	r25, 0x0A	; 10
    22c4:	b9 f0       	breq	.+46     	; 0x22f4 <TestThread+0x20a>
    22c6:	b0 f0       	brcs	.+44     	; 0x22f4 <TestThread+0x20a>
    22c8:	c8 e9       	ldi	r28, 0x98	; 152
    22ca:	da e0       	ldi	r29, 0x0A	; 10
    chSequentialStreamPut(chp, *cp++);
    22cc:	a0 91 aa 0a 	lds	r26, 0x0AAA
    22d0:	b0 91 ab 0a 	lds	r27, 0x0AAB
    22d4:	69 91       	ld	r22, Y+
    22d6:	ed 91       	ld	r30, X+
    22d8:	fc 91       	ld	r31, X
    22da:	11 97       	sbiw	r26, 0x01	; 1
    22dc:	04 80       	ldd	r0, Z+4	; 0x04
    22de:	f5 81       	ldd	r31, Z+5	; 0x05
    22e0:	e0 2d       	mov	r30, r0
    22e2:	cd 01       	movw	r24, r26
    22e4:	09 95       	icall
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
    22e6:	80 91 a8 0a 	lds	r24, 0x0AA8
    22ea:	90 91 a9 0a 	lds	r25, 0x0AA9
    22ee:	c8 17       	cp	r28, r24
    22f0:	d9 07       	cpc	r29, r25
    22f2:	60 f3       	brcs	.-40     	; 0x22cc <TestThread+0x1e2>
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
        test_print(" [");
        print_tokens();
        test_println("])");
    22f4:	8f e5       	ldi	r24, 0x5F	; 95
    22f6:	92 e0       	ldi	r25, 0x02	; 2
    22f8:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
      }
      else
        test_println("--- Result: SUCCESS");
    22fc:	82 e0       	ldi	r24, 0x02	; 2
    22fe:	90 e0       	ldi	r25, 0x00	; 0
    2300:	c8 0e       	add	r12, r24
    2302:	d9 1e       	adc	r13, r25
    2304:	08 94       	sec
    2306:	e1 1c       	adc	r14, r1
    2308:	f1 1c       	adc	r15, r1
    230a:	01 1d       	adc	r16, r1
    230c:	11 1d       	adc	r17, r1

  global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
    230e:	d6 01       	movw	r26, r12
    2310:	8d 91       	ld	r24, X+
    2312:	9c 91       	ld	r25, X
    2314:	89 2b       	or	r24, r25
    2316:	09 f0       	breq	.+2      	; 0x231a <TestThread+0x230>
    2318:	69 cf       	rjmp	.-302    	; 0x21ec <TestThread+0x102>
#endif
  test_println("");

  global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    231a:	f2 01       	movw	r30, r4
    231c:	81 91       	ld	r24, Z+
    231e:	91 91       	ld	r25, Z+
    2320:	2f 01       	movw	r4, r30
    2322:	08 94       	sec
    2324:	81 1c       	adc	r8, r1
    2326:	91 1c       	adc	r9, r1
    2328:	a1 1c       	adc	r10, r1
    232a:	b1 1c       	adc	r11, r1
    232c:	00 97       	sbiw	r24, 0x00	; 0
    232e:	09 f0       	breq	.+2      	; 0x2332 <TestThread+0x248>
    2330:	51 cf       	rjmp	.-350    	; 0x21d4 <TestThread+0xea>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
    2332:	0e 94 21 10 	call	0x2042	; 0x2042 <print_line>
  test_println("");
    2336:	8e e1       	ldi	r24, 0x1E	; 30
    2338:	91 e0       	ldi	r25, 0x01	; 1
    233a:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
  test_print("Final result: ");
    233e:	86 e7       	ldi	r24, 0x76	; 118
    2340:	92 e0       	ldi	r25, 0x02	; 2
    2342:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  if (global_fail)
    2346:	80 91 95 0a 	lds	r24, 0x0A95
    234a:	88 23       	and	r24, r24
    234c:	01 f5       	brne	.+64     	; 0x238e <TestThread+0x2a4>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
    234e:	8d e8       	ldi	r24, 0x8D	; 141
    2350:	92 e0       	ldi	r25, 0x02	; 2
    2352:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
    2356:	20 91 95 0a 	lds	r18, 0x0A95
    235a:	33 27       	eor	r19, r19
    235c:	27 fd       	sbrc	r18, 7
    235e:	30 95       	com	r19

  return (msg_t)global_fail;
}
    2360:	c9 01       	movw	r24, r18
    2362:	df 91       	pop	r29
    2364:	cf 91       	pop	r28
    2366:	1f 91       	pop	r17
    2368:	0f 91       	pop	r16
    236a:	ff 90       	pop	r15
    236c:	ef 90       	pop	r14
    236e:	df 90       	pop	r13
    2370:	cf 90       	pop	r12
    2372:	bf 90       	pop	r11
    2374:	af 90       	pop	r10
    2376:	9f 90       	pop	r9
    2378:	8f 90       	pop	r8
    237a:	7f 90       	pop	r7
    237c:	6f 90       	pop	r6
    237e:	5f 90       	pop	r5
    2380:	4f 90       	pop	r4
    2382:	08 95       	ret
        test_print(" [");
        print_tokens();
        test_println("])");
      }
      else
        test_println("--- Result: SUCCESS");
    2384:	82 e6       	ldi	r24, 0x62	; 98
    2386:	92 e0       	ldi	r25, 0x02	; 2
    2388:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
    238c:	b7 cf       	rjmp	.-146    	; 0x22fc <TestThread+0x212>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (global_fail)
    test_println("FAILURE");
    238e:	85 e8       	ldi	r24, 0x85	; 133
    2390:	92 e0       	ldi	r25, 0x02	; 2
    2392:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
    2396:	df cf       	rjmp	.-66     	; 0x2356 <TestThread+0x26c>

00002398 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
    2398:	cf 93       	push	r28
    239a:	df 93       	push	r29
    239c:	c1 e0       	ldi	r28, 0x01	; 1
    239e:	dc e0       	ldi	r29, 0x0C	; 12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
    23a0:	88 81       	ld	r24, Y
    23a2:	99 81       	ldd	r25, Y+1	; 0x01
    23a4:	00 97       	sbiw	r24, 0x00	; 0
    23a6:	11 f0       	breq	.+4      	; 0x23ac <test_terminate_threads+0x14>
      chThdTerminate(threads[i]);
    23a8:	0e 94 c6 03 	call	0x78c	; 0x78c <chThdTerminate>
    23ac:	22 96       	adiw	r28, 0x02	; 2
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    23ae:	8c e0       	ldi	r24, 0x0C	; 12
    23b0:	cb 30       	cpi	r28, 0x0B	; 11
    23b2:	d8 07       	cpc	r29, r24
    23b4:	a9 f7       	brne	.-22     	; 0x23a0 <test_terminate_threads+0x8>
    if (threads[i])
      chThdTerminate(threads[i]);
}
    23b6:	df 91       	pop	r29
    23b8:	cf 91       	pop	r28
    23ba:	08 95       	ret

000023bc <_test_assert_time_window>:
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}

bool_t _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
    23bc:	cf 93       	push	r28
    23be:	df 93       	push	r29
    23c0:	ec 01       	movw	r28, r24
    23c2:	cb 01       	movw	r24, r22

  return _test_assert(point, chTimeIsWithin(start, end));
    23c4:	ba 01       	movw	r22, r20
    23c6:	0e 94 a9 01 	call	0x352	; 0x352 <chTimeIsWithin>
  return TRUE;
}

bool_t _test_assert(unsigned point, bool_t condition) {

  if (!condition)
    23ca:	88 23       	and	r24, r24
    23cc:	61 f4       	brne	.+24     	; 0x23e6 <_test_assert_time_window+0x2a>
/*
 * Assertions.
 */
bool_t _test_fail(unsigned point) {

  local_fail = TRUE;
    23ce:	81 e0       	ldi	r24, 0x01	; 1
    23d0:	80 93 94 0a 	sts	0x0A94, r24
  global_fail = TRUE;
    23d4:	80 93 95 0a 	sts	0x0A95, r24
  failpoint = point;
    23d8:	d0 93 97 0a 	sts	0x0A97, r29
    23dc:	c0 93 96 0a 	sts	0x0A96, r28
}

bool_t _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chTimeIsWithin(start, end));
}
    23e0:	df 91       	pop	r29
    23e2:	cf 91       	pop	r28
    23e4:	08 95       	ret
  return TRUE;
}

bool_t _test_assert(unsigned point, bool_t condition) {

  if (!condition)
    23e6:	80 e0       	ldi	r24, 0x00	; 0
}

bool_t _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chTimeIsWithin(start, end));
}
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	08 95       	ret

000023ee <thd4_execute>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
    23ee:	0f 93       	push	r16
    23f0:	1f 93       	push	r17
  systime_t time;

  test_wait_tick();
    23f2:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>

  /* Timeouts in microseconds.*/
  time = chTimeNow();
    23f6:	00 91 f1 0b 	lds	r16, 0x0BF1
    23fa:	10 91 f2 0b 	lds	r17, 0x0BF2
  chThdSleepMicroseconds(100000);
    23fe:	84 e6       	ldi	r24, 0x64	; 100
    2400:	90 e0       	ldi	r25, 0x00	; 0
    2402:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_assert_time_window(1, time + US2ST(100000), time + US2ST(100000) + 1);
    2406:	a8 01       	movw	r20, r16
    2408:	4b 59       	subi	r20, 0x9B	; 155
    240a:	5f 4f       	sbci	r21, 0xFF	; 255
    240c:	81 e0       	ldi	r24, 0x01	; 1
    240e:	90 e0       	ldi	r25, 0x00	; 0
    2410:	0c 59       	subi	r16, 0x9C	; 156
    2412:	1f 4f       	sbci	r17, 0xFF	; 255
    2414:	b8 01       	movw	r22, r16
    2416:	0e 94 de 11 	call	0x23bc	; 0x23bc <_test_assert_time_window>
    241a:	88 23       	and	r24, r24
    241c:	19 f0       	breq	.+6      	; 0x2424 <thd4_execute+0x36>

  /* Absolute timelines.*/
  time = chTimeNow() + MS2ST(100);
  chThdSleepUntil(time);
  test_assert_time_window(4, time, time + 1);
}
    241e:	1f 91       	pop	r17
    2420:	0f 91       	pop	r16
    2422:	08 95       	ret
  time = chTimeNow();
  chThdSleepMicroseconds(100000);
  test_assert_time_window(1, time + US2ST(100000), time + US2ST(100000) + 1);

  /* Timeouts in milliseconds.*/
  time = chTimeNow();
    2424:	00 91 f1 0b 	lds	r16, 0x0BF1
    2428:	10 91 f2 0b 	lds	r17, 0x0BF2
  chThdSleepMilliseconds(100);
    242c:	84 e6       	ldi	r24, 0x64	; 100
    242e:	90 e0       	ldi	r25, 0x00	; 0
    2430:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_assert_time_window(2, time + MS2ST(100), time + MS2ST(100) + 1);
    2434:	a8 01       	movw	r20, r16
    2436:	4b 59       	subi	r20, 0x9B	; 155
    2438:	5f 4f       	sbci	r21, 0xFF	; 255
    243a:	82 e0       	ldi	r24, 0x02	; 2
    243c:	90 e0       	ldi	r25, 0x00	; 0
    243e:	0c 59       	subi	r16, 0x9C	; 156
    2440:	1f 4f       	sbci	r17, 0xFF	; 255
    2442:	b8 01       	movw	r22, r16
    2444:	0e 94 de 11 	call	0x23bc	; 0x23bc <_test_assert_time_window>
    2448:	88 23       	and	r24, r24
    244a:	49 f7       	brne	.-46     	; 0x241e <thd4_execute+0x30>

  /* Timeouts in seconds.*/
  time = chTimeNow();
    244c:	00 91 f1 0b 	lds	r16, 0x0BF1
    2450:	10 91 f2 0b 	lds	r17, 0x0BF2
  chThdSleepSeconds(1);
    2454:	88 ee       	ldi	r24, 0xE8	; 232
    2456:	93 e0       	ldi	r25, 0x03	; 3
    2458:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_assert_time_window(3, time + S2ST(1), time + S2ST(1) + 1);
    245c:	a8 01       	movw	r20, r16
    245e:	47 51       	subi	r20, 0x17	; 23
    2460:	5c 4f       	sbci	r21, 0xFC	; 252
    2462:	83 e0       	ldi	r24, 0x03	; 3
    2464:	90 e0       	ldi	r25, 0x00	; 0
    2466:	08 51       	subi	r16, 0x18	; 24
    2468:	1c 4f       	sbci	r17, 0xFC	; 252
    246a:	b8 01       	movw	r22, r16
    246c:	0e 94 de 11 	call	0x23bc	; 0x23bc <_test_assert_time_window>
    2470:	88 23       	and	r24, r24
    2472:	a9 f6       	brne	.-86     	; 0x241e <thd4_execute+0x30>

  /* Absolute timelines.*/
  time = chTimeNow() + MS2ST(100);
    2474:	00 91 f1 0b 	lds	r16, 0x0BF1
    2478:	10 91 f2 0b 	lds	r17, 0x0BF2
    247c:	0c 59       	subi	r16, 0x9C	; 156
    247e:	1f 4f       	sbci	r17, 0xFF	; 255
  chThdSleepUntil(time);
    2480:	c8 01       	movw	r24, r16
    2482:	0e 94 35 04 	call	0x86a	; 0x86a <chThdSleepUntil>
  test_assert_time_window(4, time, time + 1);
    2486:	84 e0       	ldi	r24, 0x04	; 4
    2488:	90 e0       	ldi	r25, 0x00	; 0
    248a:	b8 01       	movw	r22, r16
    248c:	0f 5f       	subi	r16, 0xFF	; 255
    248e:	1f 4f       	sbci	r17, 0xFF	; 255
    2490:	a8 01       	movw	r20, r16
    2492:	0e 94 de 11 	call	0x23bc	; 0x23bc <_test_assert_time_window>
    2496:	c3 cf       	rjmp	.-122    	; 0x241e <thd4_execute+0x30>

00002498 <thd3_execute>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
    2498:	af 92       	push	r10
    249a:	bf 92       	push	r11
    249c:	cf 92       	push	r12
    249e:	df 92       	push	r13
    24a0:	ff 92       	push	r15
    24a2:	0f 93       	push	r16
    24a4:	1f 93       	push	r17
    24a6:	cf 93       	push	r28
    24a8:	df 93       	push	r29
  tprio_t prio, p1;

  prio = chThdGetPriority();
    24aa:	e0 91 fe 0b 	lds	r30, 0x0BFE
    24ae:	f0 91 ff 0b 	lds	r31, 0x0BFF
    24b2:	04 81       	ldd	r16, Z+4	; 0x04
  p1 = chThdSetPriority(prio + 1);
    24b4:	f0 2e       	mov	r15, r16
    24b6:	f3 94       	inc	r15
    24b8:	8f 2d       	mov	r24, r15
    24ba:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <chThdSetPriority>
    24be:	18 2f       	mov	r17, r24
  test_assert(1, p1 == prio,
    24c0:	60 e0       	ldi	r22, 0x00	; 0
    24c2:	08 17       	cp	r16, r24
    24c4:	09 f4       	brne	.+2      	; 0x24c8 <thd3_execute+0x30>
    24c6:	d4 c0       	rjmp	.+424    	; 0x2670 <thd3_execute+0x1d8>
    24c8:	81 e0       	ldi	r24, 0x01	; 1
    24ca:	90 e0       	ldi	r25, 0x00	; 0
    24cc:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    24d0:	88 23       	and	r24, r24
    24d2:	51 f0       	breq	.+20     	; 0x24e8 <thd3_execute+0x50>
  chSysLock();
  chThdSelf()->p_prio = prio;
  chThdSelf()->p_realprio = prio;
  chSysUnlock();
#endif
}
    24d4:	df 91       	pop	r29
    24d6:	cf 91       	pop	r28
    24d8:	1f 91       	pop	r17
    24da:	0f 91       	pop	r16
    24dc:	ff 90       	pop	r15
    24de:	df 90       	pop	r13
    24e0:	cf 90       	pop	r12
    24e2:	bf 90       	pop	r11
    24e4:	af 90       	pop	r10
    24e6:	08 95       	ret

  prio = chThdGetPriority();
  p1 = chThdSetPriority(prio + 1);
  test_assert(1, p1 == prio,
              "unexpected returned priority level");
  test_assert(2, chThdGetPriority() == prio + 1,
    24e8:	c0 2e       	mov	r12, r16
    24ea:	dd 24       	eor	r13, r13
    24ec:	e6 01       	movw	r28, r12
    24ee:	21 96       	adiw	r28, 0x01	; 1
    24f0:	60 e0       	ldi	r22, 0x00	; 0
    24f2:	e0 91 fe 0b 	lds	r30, 0x0BFE
    24f6:	f0 91 ff 0b 	lds	r31, 0x0BFF
    24fa:	84 81       	ldd	r24, Z+4	; 0x04
    24fc:	90 e0       	ldi	r25, 0x00	; 0
    24fe:	8c 17       	cp	r24, r28
    2500:	9d 07       	cpc	r25, r29
    2502:	09 f4       	brne	.+2      	; 0x2506 <thd3_execute+0x6e>
    2504:	b7 c0       	rjmp	.+366    	; 0x2674 <thd3_execute+0x1dc>
    2506:	82 e0       	ldi	r24, 0x02	; 2
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    250e:	88 23       	and	r24, r24
    2510:	09 f7       	brne	.-62     	; 0x24d4 <thd3_execute+0x3c>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
    2512:	81 2f       	mov	r24, r17
    2514:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <chThdSetPriority>
  test_assert(3, p1 == prio + 1,
    2518:	60 e0       	ldi	r22, 0x00	; 0
    251a:	90 e0       	ldi	r25, 0x00	; 0
    251c:	c8 17       	cp	r28, r24
    251e:	d9 07       	cpc	r29, r25
    2520:	09 f4       	brne	.+2      	; 0x2524 <thd3_execute+0x8c>
    2522:	aa c0       	rjmp	.+340    	; 0x2678 <thd3_execute+0x1e0>
    2524:	83 e0       	ldi	r24, 0x03	; 3
    2526:	90 e0       	ldi	r25, 0x00	; 0
    2528:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    252c:	88 23       	and	r24, r24
    252e:	91 f6       	brne	.-92     	; 0x24d4 <thd3_execute+0x3c>
              "unexpected returned priority level");
  test_assert(4, chThdGetPriority() == prio,
    2530:	60 e0       	ldi	r22, 0x00	; 0
    2532:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2536:	f0 91 ff 0b 	lds	r31, 0x0BFF
    253a:	84 81       	ldd	r24, Z+4	; 0x04
    253c:	80 17       	cp	r24, r16
    253e:	09 f4       	brne	.+2      	; 0x2542 <thd3_execute+0xaa>
    2540:	9d c0       	rjmp	.+314    	; 0x267c <thd3_execute+0x1e4>
    2542:	84 e0       	ldi	r24, 0x04	; 4
    2544:	90 e0       	ldi	r25, 0x00	; 0
    2546:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    254a:	88 23       	and	r24, r24
    254c:	19 f6       	brne	.-122    	; 0x24d4 <thd3_execute+0x3c>
              "unexpected priority level");

#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
    254e:	f8 94       	cli
  chThdSelf()->p_prio += 2;
    2550:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2554:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2558:	84 81       	ldd	r24, Z+4	; 0x04
    255a:	8e 5f       	subi	r24, 0xFE	; 254
    255c:	84 83       	std	Z+4, r24	; 0x04
  chSysUnlock();
    255e:	78 94       	sei
  test_assert(5, chThdGetPriority() == prio + 2,
    2560:	82 e0       	ldi	r24, 0x02	; 2
    2562:	a8 2e       	mov	r10, r24
    2564:	b1 2c       	mov	r11, r1
    2566:	ac 0c       	add	r10, r12
    2568:	bd 1c       	adc	r11, r13
    256a:	60 e0       	ldi	r22, 0x00	; 0
    256c:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2570:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2574:	84 81       	ldd	r24, Z+4	; 0x04
    2576:	90 e0       	ldi	r25, 0x00	; 0
    2578:	8a 15       	cp	r24, r10
    257a:	9b 05       	cpc	r25, r11
    257c:	09 f4       	brne	.+2      	; 0x2580 <thd3_execute+0xe8>
    257e:	80 c0       	rjmp	.+256    	; 0x2680 <thd3_execute+0x1e8>
    2580:	85 e0       	ldi	r24, 0x05	; 5
    2582:	90 e0       	ldi	r25, 0x00	; 0
    2584:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2588:	88 23       	and	r24, r24
    258a:	09 f0       	breq	.+2      	; 0x258e <thd3_execute+0xf6>
    258c:	a3 cf       	rjmp	.-186    	; 0x24d4 <thd3_execute+0x3c>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
    258e:	8f 2d       	mov	r24, r15
    2590:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <chThdSetPriority>
  test_assert(6, p1 == prio,
    2594:	60 e0       	ldi	r22, 0x00	; 0
    2596:	08 17       	cp	r16, r24
    2598:	09 f4       	brne	.+2      	; 0x259c <thd3_execute+0x104>
    259a:	74 c0       	rjmp	.+232    	; 0x2684 <thd3_execute+0x1ec>
    259c:	86 e0       	ldi	r24, 0x06	; 6
    259e:	90 e0       	ldi	r25, 0x00	; 0
    25a0:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    25a4:	88 23       	and	r24, r24
    25a6:	09 f0       	breq	.+2      	; 0x25aa <thd3_execute+0x112>
    25a8:	95 cf       	rjmp	.-214    	; 0x24d4 <thd3_execute+0x3c>
              "unexpected returned priority level");
  test_assert(7, chThdSelf()->p_prio == prio + 2,
    25aa:	60 e0       	ldi	r22, 0x00	; 0
    25ac:	e0 91 fe 0b 	lds	r30, 0x0BFE
    25b0:	f0 91 ff 0b 	lds	r31, 0x0BFF
    25b4:	84 81       	ldd	r24, Z+4	; 0x04
    25b6:	90 e0       	ldi	r25, 0x00	; 0
    25b8:	a8 16       	cp	r10, r24
    25ba:	b9 06       	cpc	r11, r25
    25bc:	09 f4       	brne	.+2      	; 0x25c0 <thd3_execute+0x128>
    25be:	64 c0       	rjmp	.+200    	; 0x2688 <thd3_execute+0x1f0>
    25c0:	87 e0       	ldi	r24, 0x07	; 7
    25c2:	90 e0       	ldi	r25, 0x00	; 0
    25c4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    25c8:	88 23       	and	r24, r24
    25ca:	09 f0       	breq	.+2      	; 0x25ce <thd3_execute+0x136>
    25cc:	83 cf       	rjmp	.-250    	; 0x24d4 <thd3_execute+0x3c>
              "unexpected priority level");
  test_assert(8, chThdSelf()->p_realprio == prio + 1,
    25ce:	60 e0       	ldi	r22, 0x00	; 0
    25d0:	e0 91 fe 0b 	lds	r30, 0x0BFE
    25d4:	f0 91 ff 0b 	lds	r31, 0x0BFF
    25d8:	87 8d       	ldd	r24, Z+31	; 0x1f
    25da:	90 e0       	ldi	r25, 0x00	; 0
    25dc:	c8 17       	cp	r28, r24
    25de:	d9 07       	cpc	r29, r25
    25e0:	09 f4       	brne	.+2      	; 0x25e4 <thd3_execute+0x14c>
    25e2:	61 e0       	ldi	r22, 0x01	; 1
    25e4:	88 e0       	ldi	r24, 0x08	; 8
    25e6:	90 e0       	ldi	r25, 0x00	; 0
    25e8:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    25ec:	88 23       	and	r24, r24
    25ee:	09 f0       	breq	.+2      	; 0x25f2 <thd3_execute+0x15a>
    25f0:	71 cf       	rjmp	.-286    	; 0x24d4 <thd3_execute+0x3c>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
    25f2:	80 2f       	mov	r24, r16
    25f4:	8d 5f       	subi	r24, 0xFD	; 253
    25f6:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <chThdSetPriority>
  test_assert(9, p1 == prio + 1,
    25fa:	60 e0       	ldi	r22, 0x00	; 0
    25fc:	90 e0       	ldi	r25, 0x00	; 0
    25fe:	c8 17       	cp	r28, r24
    2600:	d9 07       	cpc	r29, r25
    2602:	09 f4       	brne	.+2      	; 0x2606 <thd3_execute+0x16e>
    2604:	61 e0       	ldi	r22, 0x01	; 1
    2606:	89 e0       	ldi	r24, 0x09	; 9
    2608:	90 e0       	ldi	r25, 0x00	; 0
    260a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    260e:	88 23       	and	r24, r24
    2610:	09 f0       	breq	.+2      	; 0x2614 <thd3_execute+0x17c>
    2612:	60 cf       	rjmp	.-320    	; 0x24d4 <thd3_execute+0x3c>
              "unexpected returned priority level");
  test_assert(10, chThdSelf()->p_prio == prio + 3,
    2614:	e6 01       	movw	r28, r12
    2616:	23 96       	adiw	r28, 0x03	; 3
    2618:	60 e0       	ldi	r22, 0x00	; 0
    261a:	e0 91 fe 0b 	lds	r30, 0x0BFE
    261e:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2622:	84 81       	ldd	r24, Z+4	; 0x04
    2624:	90 e0       	ldi	r25, 0x00	; 0
    2626:	8c 17       	cp	r24, r28
    2628:	9d 07       	cpc	r25, r29
    262a:	81 f1       	breq	.+96     	; 0x268c <thd3_execute+0x1f4>
    262c:	8a e0       	ldi	r24, 0x0A	; 10
    262e:	90 e0       	ldi	r25, 0x00	; 0
    2630:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2634:	88 23       	and	r24, r24
    2636:	09 f0       	breq	.+2      	; 0x263a <thd3_execute+0x1a2>
    2638:	4d cf       	rjmp	.-358    	; 0x24d4 <thd3_execute+0x3c>
              "unexpected priority level");
  test_assert(11, chThdSelf()->p_realprio == prio + 3,
    263a:	60 e0       	ldi	r22, 0x00	; 0
    263c:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2640:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2644:	87 8d       	ldd	r24, Z+31	; 0x1f
    2646:	90 e0       	ldi	r25, 0x00	; 0
    2648:	c8 17       	cp	r28, r24
    264a:	d9 07       	cpc	r29, r25
    264c:	09 f4       	brne	.+2      	; 0x2650 <thd3_execute+0x1b8>
    264e:	61 e0       	ldi	r22, 0x01	; 1
    2650:	8b e0       	ldi	r24, 0x0B	; 11
    2652:	90 e0       	ldi	r25, 0x00	; 0
    2654:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2658:	88 23       	and	r24, r24
    265a:	09 f0       	breq	.+2      	; 0x265e <thd3_execute+0x1c6>
    265c:	3b cf       	rjmp	.-394    	; 0x24d4 <thd3_execute+0x3c>
              "unexpected real priority level");

  chSysLock();
    265e:	f8 94       	cli
  chThdSelf()->p_prio = prio;
    2660:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2664:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2668:	04 83       	std	Z+4, r16	; 0x04
  chThdSelf()->p_realprio = prio;
    266a:	07 8f       	std	Z+31, r16	; 0x1f
  chSysUnlock();
    266c:	78 94       	sei
    266e:	32 cf       	rjmp	.-412    	; 0x24d4 <thd3_execute+0x3c>
static void thd3_execute(void) {
  tprio_t prio, p1;

  prio = chThdGetPriority();
  p1 = chThdSetPriority(prio + 1);
  test_assert(1, p1 == prio,
    2670:	61 e0       	ldi	r22, 0x01	; 1
    2672:	2a cf       	rjmp	.-428    	; 0x24c8 <thd3_execute+0x30>
              "unexpected returned priority level");
  test_assert(2, chThdGetPriority() == prio + 1,
    2674:	61 e0       	ldi	r22, 0x01	; 1
    2676:	47 cf       	rjmp	.-370    	; 0x2506 <thd3_execute+0x6e>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
  test_assert(3, p1 == prio + 1,
    2678:	61 e0       	ldi	r22, 0x01	; 1
    267a:	54 cf       	rjmp	.-344    	; 0x2524 <thd3_execute+0x8c>
              "unexpected returned priority level");
  test_assert(4, chThdGetPriority() == prio,
    267c:	61 e0       	ldi	r22, 0x01	; 1
    267e:	61 cf       	rjmp	.-318    	; 0x2542 <thd3_execute+0xaa>
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
  chThdSelf()->p_prio += 2;
  chSysUnlock();
  test_assert(5, chThdGetPriority() == prio + 2,
    2680:	61 e0       	ldi	r22, 0x01	; 1
    2682:	7e cf       	rjmp	.-260    	; 0x2580 <thd3_execute+0xe8>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
  test_assert(6, p1 == prio,
    2684:	61 e0       	ldi	r22, 0x01	; 1
    2686:	8a cf       	rjmp	.-236    	; 0x259c <thd3_execute+0x104>
              "unexpected returned priority level");
  test_assert(7, chThdSelf()->p_prio == prio + 2,
    2688:	61 e0       	ldi	r22, 0x01	; 1
    268a:	9a cf       	rjmp	.-204    	; 0x25c0 <thd3_execute+0x128>

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
  test_assert(9, p1 == prio + 1,
              "unexpected returned priority level");
  test_assert(10, chThdSelf()->p_prio == prio + 3,
    268c:	61 e0       	ldi	r22, 0x01	; 1
    268e:	ce cf       	rjmp	.-100    	; 0x262c <thd3_execute+0x194>

00002690 <thd2_execute>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
    2690:	ef 92       	push	r14
    2692:	ff 92       	push	r15
    2694:	0f 93       	push	r16
    2696:	1f 93       	push	r17

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-4, thread, "D");
    2698:	e0 91 fe 0b 	lds	r30, 0x0BFE
    269c:	f0 91 ff 0b 	lds	r31, 0x0BFF
    26a0:	44 81       	ldd	r20, Z+4	; 0x04
    26a2:	44 50       	subi	r20, 0x04	; 4
    26a4:	9c e4       	ldi	r25, 0x4C	; 76
    26a6:	e9 2e       	mov	r14, r25
    26a8:	94 e1       	ldi	r25, 0x14	; 20
    26aa:	f9 2e       	mov	r15, r25
    26ac:	80 91 97 02 	lds	r24, 0x0297
    26b0:	90 91 98 02 	lds	r25, 0x0298
    26b4:	65 e9       	ldi	r22, 0x95	; 149
    26b6:	70 e0       	ldi	r23, 0x00	; 0
    26b8:	97 01       	movw	r18, r14
    26ba:	07 eb       	ldi	r16, 0xB7	; 183
    26bc:	12 e0       	ldi	r17, 0x02	; 2
    26be:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    26c2:	90 93 04 0c 	sts	0x0C04, r25
    26c6:	80 93 03 0c 	sts	0x0C03, r24
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-5, thread, "E");
    26ca:	e0 91 fe 0b 	lds	r30, 0x0BFE
    26ce:	f0 91 ff 0b 	lds	r31, 0x0BFF
    26d2:	44 81       	ldd	r20, Z+4	; 0x04
    26d4:	45 50       	subi	r20, 0x05	; 5
    26d6:	80 91 95 02 	lds	r24, 0x0295
    26da:	90 91 96 02 	lds	r25, 0x0296
    26de:	65 e9       	ldi	r22, 0x95	; 149
    26e0:	70 e0       	ldi	r23, 0x00	; 0
    26e2:	97 01       	movw	r18, r14
    26e4:	09 eb       	ldi	r16, 0xB9	; 185
    26e6:	12 e0       	ldi	r17, 0x02	; 2
    26e8:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    26ec:	90 93 02 0c 	sts	0x0C02, r25
    26f0:	80 93 01 0c 	sts	0x0C01, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread, "A");
    26f4:	e0 91 fe 0b 	lds	r30, 0x0BFE
    26f8:	f0 91 ff 0b 	lds	r31, 0x0BFF
    26fc:	44 81       	ldd	r20, Z+4	; 0x04
    26fe:	41 50       	subi	r20, 0x01	; 1
    2700:	80 91 9d 02 	lds	r24, 0x029D
    2704:	90 91 9e 02 	lds	r25, 0x029E
    2708:	65 e9       	ldi	r22, 0x95	; 149
    270a:	70 e0       	ldi	r23, 0x00	; 0
    270c:	97 01       	movw	r18, r14
    270e:	0b eb       	ldi	r16, 0xBB	; 187
    2710:	12 e0       	ldi	r17, 0x02	; 2
    2712:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2716:	90 93 0a 0c 	sts	0x0C0A, r25
    271a:	80 93 09 0c 	sts	0x0C09, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-2, thread, "B");
    271e:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2722:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2726:	44 81       	ldd	r20, Z+4	; 0x04
    2728:	42 50       	subi	r20, 0x02	; 2
    272a:	80 91 9b 02 	lds	r24, 0x029B
    272e:	90 91 9c 02 	lds	r25, 0x029C
    2732:	65 e9       	ldi	r22, 0x95	; 149
    2734:	70 e0       	ldi	r23, 0x00	; 0
    2736:	97 01       	movw	r18, r14
    2738:	0d eb       	ldi	r16, 0xBD	; 189
    273a:	12 e0       	ldi	r17, 0x02	; 2
    273c:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2740:	90 93 08 0c 	sts	0x0C08, r25
    2744:	80 93 07 0c 	sts	0x0C07, r24
  /* Done this way for coverage of chThdCreateI() and chThdResume().*/
  chSysLock();
    2748:	f8 94       	cli
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriority()-3, thread, "C");
    274a:	e0 91 fe 0b 	lds	r30, 0x0BFE
    274e:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2752:	44 81       	ldd	r20, Z+4	; 0x04
    2754:	43 50       	subi	r20, 0x03	; 3
    2756:	80 91 99 02 	lds	r24, 0x0299
    275a:	90 91 9a 02 	lds	r25, 0x029A
    275e:	65 e9       	ldi	r22, 0x95	; 149
    2760:	70 e0       	ldi	r23, 0x00	; 0
    2762:	97 01       	movw	r18, r14
    2764:	0f eb       	ldi	r16, 0xBF	; 191
    2766:	12 e0       	ldi	r17, 0x02	; 2
    2768:	0e 94 8c 03 	call	0x718	; 0x718 <chThdCreateI>
    276c:	90 93 06 0c 	sts	0x0C06, r25
    2770:	80 93 05 0c 	sts	0x0C05, r24
  chSysUnlock();
    2774:	78 94       	sei
  chThdResume(threads[2]);
    2776:	80 91 05 0c 	lds	r24, 0x0C05
    277a:	90 91 06 0c 	lds	r25, 0x0C06
    277e:	0e 94 4a 04 	call	0x894	; 0x894 <chThdResume>
  test_wait_threads();
    2782:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    2786:	81 e0       	ldi	r24, 0x01	; 1
    2788:	90 e0       	ldi	r25, 0x00	; 0
    278a:	61 ec       	ldi	r22, 0xC1	; 193
    278c:	72 e0       	ldi	r23, 0x02	; 2
    278e:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
}
    2792:	1f 91       	pop	r17
    2794:	0f 91       	pop	r16
    2796:	ff 90       	pop	r15
    2798:	ef 90       	pop	r14
    279a:	08 95       	ret

0000279c <thd1_execute>:

  test_emit_token(*(char *)p);
  return 0;
}

static void thd1_execute(void) {
    279c:	ef 92       	push	r14
    279e:	ff 92       	push	r15
    27a0:	0f 93       	push	r16
    27a2:	1f 93       	push	r17

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-5, thread, "E");
    27a4:	e0 91 fe 0b 	lds	r30, 0x0BFE
    27a8:	f0 91 ff 0b 	lds	r31, 0x0BFF
    27ac:	44 81       	ldd	r20, Z+4	; 0x04
    27ae:	45 50       	subi	r20, 0x05	; 5
    27b0:	2c e4       	ldi	r18, 0x4C	; 76
    27b2:	e2 2e       	mov	r14, r18
    27b4:	24 e1       	ldi	r18, 0x14	; 20
    27b6:	f2 2e       	mov	r15, r18
    27b8:	80 91 95 02 	lds	r24, 0x0295
    27bc:	90 91 96 02 	lds	r25, 0x0296
    27c0:	65 e9       	ldi	r22, 0x95	; 149
    27c2:	70 e0       	ldi	r23, 0x00	; 0
    27c4:	97 01       	movw	r18, r14
    27c6:	09 eb       	ldi	r16, 0xB9	; 185
    27c8:	12 e0       	ldi	r17, 0x02	; 2
    27ca:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    27ce:	90 93 02 0c 	sts	0x0C02, r25
    27d2:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-4, thread, "D");
    27d6:	e0 91 fe 0b 	lds	r30, 0x0BFE
    27da:	f0 91 ff 0b 	lds	r31, 0x0BFF
    27de:	44 81       	ldd	r20, Z+4	; 0x04
    27e0:	44 50       	subi	r20, 0x04	; 4
    27e2:	80 91 97 02 	lds	r24, 0x0297
    27e6:	90 91 98 02 	lds	r25, 0x0298
    27ea:	65 e9       	ldi	r22, 0x95	; 149
    27ec:	70 e0       	ldi	r23, 0x00	; 0
    27ee:	97 01       	movw	r18, r14
    27f0:	07 eb       	ldi	r16, 0xB7	; 183
    27f2:	12 e0       	ldi	r17, 0x02	; 2
    27f4:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    27f8:	90 93 04 0c 	sts	0x0C04, r25
    27fc:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread, "C");
    2800:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2804:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2808:	44 81       	ldd	r20, Z+4	; 0x04
    280a:	43 50       	subi	r20, 0x03	; 3
    280c:	80 91 99 02 	lds	r24, 0x0299
    2810:	90 91 9a 02 	lds	r25, 0x029A
    2814:	65 e9       	ldi	r22, 0x95	; 149
    2816:	70 e0       	ldi	r23, 0x00	; 0
    2818:	97 01       	movw	r18, r14
    281a:	0f eb       	ldi	r16, 0xBF	; 191
    281c:	12 e0       	ldi	r17, 0x02	; 2
    281e:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2822:	90 93 06 0c 	sts	0x0C06, r25
    2826:	80 93 05 0c 	sts	0x0C05, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-2, thread, "B");
    282a:	e0 91 fe 0b 	lds	r30, 0x0BFE
    282e:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2832:	44 81       	ldd	r20, Z+4	; 0x04
    2834:	42 50       	subi	r20, 0x02	; 2
    2836:	80 91 9b 02 	lds	r24, 0x029B
    283a:	90 91 9c 02 	lds	r25, 0x029C
    283e:	65 e9       	ldi	r22, 0x95	; 149
    2840:	70 e0       	ldi	r23, 0x00	; 0
    2842:	97 01       	movw	r18, r14
    2844:	0d eb       	ldi	r16, 0xBD	; 189
    2846:	12 e0       	ldi	r17, 0x02	; 2
    2848:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    284c:	90 93 08 0c 	sts	0x0C08, r25
    2850:	80 93 07 0c 	sts	0x0C07, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread, "A");
    2854:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2858:	f0 91 ff 0b 	lds	r31, 0x0BFF
    285c:	44 81       	ldd	r20, Z+4	; 0x04
    285e:	41 50       	subi	r20, 0x01	; 1
    2860:	80 91 9d 02 	lds	r24, 0x029D
    2864:	90 91 9e 02 	lds	r25, 0x029E
    2868:	65 e9       	ldi	r22, 0x95	; 149
    286a:	70 e0       	ldi	r23, 0x00	; 0
    286c:	97 01       	movw	r18, r14
    286e:	0b eb       	ldi	r16, 0xBB	; 187
    2870:	12 e0       	ldi	r17, 0x02	; 2
    2872:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2876:	90 93 0a 0c 	sts	0x0C0A, r25
    287a:	80 93 09 0c 	sts	0x0C09, r24
  test_wait_threads();
    287e:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    2882:	81 e0       	ldi	r24, 0x01	; 1
    2884:	90 e0       	ldi	r25, 0x00	; 0
    2886:	61 ec       	ldi	r22, 0xC1	; 193
    2888:	72 e0       	ldi	r23, 0x02	; 2
    288a:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
}
    288e:	1f 91       	pop	r17
    2890:	0f 91       	pop	r16
    2892:	ff 90       	pop	r15
    2894:	ef 90       	pop	r14
    2896:	08 95       	ret

00002898 <thread>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static msg_t thread(void *p) {
    2898:	fc 01       	movw	r30, r24

  test_emit_token(*(char *)p);
    289a:	80 81       	ld	r24, Z
    289c:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  return 0;
}
    28a0:	80 e0       	ldi	r24, 0x00	; 0
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	08 95       	ret

000028a6 <sem3_setup>:
 * correct after each operation.
 */

static void sem3_setup(void) {

  chSemInit(&sem1, 0);
    28a6:	84 ef       	ldi	r24, 0xF4	; 244
    28a8:	93 e0       	ldi	r25, 0x03	; 3
    28aa:	60 e0       	ldi	r22, 0x00	; 0
    28ac:	0e 94 93 04 	call	0x926	; 0x926 <chSemInit>
}
    28b0:	08 95       	ret

000028b2 <sem2_setup>:
 * correct after each operation.
 */

static void sem2_setup(void) {

  chSemInit(&sem1, 0);
    28b2:	84 ef       	ldi	r24, 0xF4	; 244
    28b4:	93 e0       	ldi	r25, 0x03	; 3
    28b6:	60 e0       	ldi	r22, 0x00	; 0
    28b8:	0e 94 93 04 	call	0x926	; 0x926 <chSemInit>
}
    28bc:	08 95       	ret

000028be <sem1_setup>:
 * setting.
 */

static void sem1_setup(void) {

  chSemInit(&sem1, 0);
    28be:	84 ef       	ldi	r24, 0xF4	; 244
    28c0:	93 e0       	ldi	r25, 0x03	; 3
    28c2:	60 e0       	ldi	r22, 0x00	; 0
    28c4:	0e 94 93 04 	call	0x926	; 0x926 <chSemInit>
}
    28c8:	08 95       	ret

000028ca <sem4_execute>:

  chBSemSignal((BinarySemaphore *)p);
  return 0;
}

static void sem4_execute(void) {
    28ca:	ef 92       	push	r14
    28cc:	ff 92       	push	r15
    28ce:	0f 93       	push	r16
    28d0:	1f 93       	push	r17
    28d2:	df 93       	push	r29
    28d4:	cf 93       	push	r28
    28d6:	00 d0       	rcall	.+0      	; 0x28d8 <sem4_execute+0xe>
    28d8:	00 d0       	rcall	.+0      	; 0x28da <sem4_execute+0x10>
    28da:	0f 92       	push	r0
    28dc:	cd b7       	in	r28, 0x3d	; 61
    28de:	de b7       	in	r29, 0x3e	; 62
  BinarySemaphore bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemInit(&bsem, TRUE);
    28e0:	7e 01       	movw	r14, r28
    28e2:	08 94       	sec
    28e4:	e1 1c       	adc	r14, r1
    28e6:	f1 1c       	adc	r15, r1
    28e8:	c7 01       	movw	r24, r14
    28ea:	60 e0       	ldi	r22, 0x00	; 0
    28ec:	0e 94 93 04 	call	0x926	; 0x926 <chSemInit>
  chBSemReset(&bsem, TRUE);
    28f0:	c7 01       	movw	r24, r14
    28f2:	60 e0       	ldi	r22, 0x00	; 0
    28f4:	0e 94 97 05 	call	0xb2e	; 0xb2e <chSemReset>
  test_assert(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
    28f8:	60 e0       	ldi	r22, 0x00	; 0
    28fa:	8d 81       	ldd	r24, Y+5	; 0x05
    28fc:	18 16       	cp	r1, r24
    28fe:	0c f0       	brlt	.+2      	; 0x2902 <sem4_execute+0x38>
    2900:	70 c0       	rjmp	.+224    	; 0x29e2 <sem4_execute+0x118>
    2902:	81 e0       	ldi	r24, 0x01	; 1
    2904:	90 e0       	ldi	r25, 0x00	; 0
    2906:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    290a:	88 23       	and	r24, r24
    290c:	61 f0       	breq	.+24     	; 0x2926 <sem4_execute+0x5c>
  
  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
    290e:	0f 90       	pop	r0
    2910:	0f 90       	pop	r0
    2912:	0f 90       	pop	r0
    2914:	0f 90       	pop	r0
    2916:	0f 90       	pop	r0
    2918:	cf 91       	pop	r28
    291a:	df 91       	pop	r29
    291c:	1f 91       	pop	r17
    291e:	0f 91       	pop	r16
    2920:	ff 90       	pop	r15
    2922:	ef 90       	pop	r14
    2924:	08 95       	ret
  chBSemInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
    2926:	e0 91 fe 0b 	lds	r30, 0x0BFE
    292a:	f0 91 ff 0b 	lds	r31, 0x0BFF
    292e:	44 81       	ldd	r20, Z+4	; 0x04
    2930:	41 50       	subi	r20, 0x01	; 1
    2932:	80 91 95 02 	lds	r24, 0x0295
    2936:	90 91 96 02 	lds	r25, 0x0296
    293a:	65 e9       	ldi	r22, 0x95	; 149
    293c:	70 e0       	ldi	r23, 0x00	; 0
    293e:	21 e0       	ldi	r18, 0x01	; 1
    2940:	35 e1       	ldi	r19, 0x15	; 21
    2942:	87 01       	movw	r16, r14
    2944:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2948:	90 93 02 0c 	sts	0x0C02, r25
    294c:	80 93 01 0c 	sts	0x0C01, r24
                                 chThdGetPriority()-1, thread4, &bsem);
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
    2950:	c7 01       	movw	r24, r14
    2952:	0e 94 3d 05 	call	0xa7a	; 0xa7a <chSemWait>
  
  /* The binary semaphore is expected to be taken.*/
  test_assert(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
    2956:	60 e0       	ldi	r22, 0x00	; 0
    2958:	8d 81       	ldd	r24, Y+5	; 0x05
    295a:	18 16       	cp	r1, r24
    295c:	0c f0       	brlt	.+2      	; 0x2960 <sem4_execute+0x96>
    295e:	43 c0       	rjmp	.+134    	; 0x29e6 <sem4_execute+0x11c>
    2960:	82 e0       	ldi	r24, 0x02	; 2
    2962:	90 e0       	ldi	r25, 0x00	; 0
    2964:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2968:	88 23       	and	r24, r24
    296a:	89 f6       	brne	.-94     	; 0x290e <sem4_execute+0x44>
  
  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
    296c:	f8 94       	cli
    296e:	8d 81       	ldd	r24, Y+5	; 0x05
    2970:	18 16       	cp	r1, r24
    2972:	0c f0       	brlt	.+2      	; 0x2976 <sem4_execute+0xac>
    2974:	3c c0       	rjmp	.+120    	; 0x29ee <sem4_execute+0x124>
    2976:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
    297a:	78 94       	sei
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
    297c:	60 e0       	ldi	r22, 0x00	; 0
    297e:	8d 81       	ldd	r24, Y+5	; 0x05
    2980:	18 16       	cp	r1, r24
    2982:	0c f4       	brge	.+2      	; 0x2986 <sem4_execute+0xbc>
    2984:	61 e0       	ldi	r22, 0x01	; 1
    2986:	83 e0       	ldi	r24, 0x03	; 3
    2988:	90 e0       	ldi	r25, 0x00	; 0
    298a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    298e:	88 23       	and	r24, r24
    2990:	09 f0       	breq	.+2      	; 0x2994 <sem4_execute+0xca>
    2992:	bd cf       	rjmp	.-134    	; 0x290e <sem4_execute+0x44>
  test_assert(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
    2994:	60 e0       	ldi	r22, 0x00	; 0
    2996:	8d 81       	ldd	r24, Y+5	; 0x05
    2998:	81 30       	cpi	r24, 0x01	; 1
    299a:	39 f1       	breq	.+78     	; 0x29ea <sem4_execute+0x120>
    299c:	84 e0       	ldi	r24, 0x04	; 4
    299e:	90 e0       	ldi	r25, 0x00	; 0
    29a0:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    29a4:	88 23       	and	r24, r24
    29a6:	09 f0       	breq	.+2      	; 0x29aa <sem4_execute+0xe0>
    29a8:	b2 cf       	rjmp	.-156    	; 0x290e <sem4_execute+0x44>
  
  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
    29aa:	f8 94       	cli
    29ac:	8d 81       	ldd	r24, Y+5	; 0x05
    29ae:	18 16       	cp	r1, r24
    29b0:	14 f5       	brge	.+68     	; 0x29f6 <sem4_execute+0x12c>
    29b2:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
    29b6:	78 94       	sei
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "taken");
    29b8:	60 e0       	ldi	r22, 0x00	; 0
    29ba:	8d 81       	ldd	r24, Y+5	; 0x05
    29bc:	18 16       	cp	r1, r24
    29be:	0c f4       	brge	.+2      	; 0x29c2 <sem4_execute+0xf8>
    29c0:	61 e0       	ldi	r22, 0x01	; 1
    29c2:	83 e0       	ldi	r24, 0x03	; 3
    29c4:	90 e0       	ldi	r25, 0x00	; 0
    29c6:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    29ca:	88 23       	and	r24, r24
    29cc:	09 f0       	breq	.+2      	; 0x29d0 <sem4_execute+0x106>
    29ce:	9f cf       	rjmp	.-194    	; 0x290e <sem4_execute+0x44>
  test_assert(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
    29d0:	60 e0       	ldi	r22, 0x00	; 0
    29d2:	8d 81       	ldd	r24, Y+5	; 0x05
    29d4:	81 30       	cpi	r24, 0x01	; 1
    29d6:	99 f0       	breq	.+38     	; 0x29fe <sem4_execute+0x134>
    29d8:	85 e0       	ldi	r24, 0x05	; 5
    29da:	90 e0       	ldi	r25, 0x00	; 0
    29dc:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    29e0:	96 cf       	rjmp	.-212    	; 0x290e <sem4_execute+0x44>
  BinarySemaphore bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
    29e2:	61 e0       	ldi	r22, 0x01	; 1
    29e4:	8e cf       	rjmp	.-228    	; 0x2902 <sem4_execute+0x38>
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
  
  /* The binary semaphore is expected to be taken.*/
  test_assert(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
    29e6:	61 e0       	ldi	r22, 0x01	; 1
    29e8:	bb cf       	rjmp	.-138    	; 0x2960 <sem4_execute+0x96>
  
  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
  test_assert(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
    29ea:	61 e0       	ldi	r22, 0x01	; 1
    29ec:	d7 cf       	rjmp	.-82     	; 0x299c <sem4_execute+0xd2>
  /* The binary semaphore is expected to be taken.*/
  test_assert(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
  
  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
    29ee:	c7 01       	movw	r24, r14
    29f0:	0e 94 c7 04 	call	0x98e	; 0x98e <chSemSignalI>
    29f4:	c0 cf       	rjmp	.-128    	; 0x2976 <sem4_execute+0xac>
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
  test_assert(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
  
  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
    29f6:	c7 01       	movw	r24, r14
    29f8:	0e 94 c7 04 	call	0x98e	; 0x98e <chSemSignalI>
    29fc:	da cf       	rjmp	.-76     	; 0x29b2 <sem4_execute+0xe8>
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
    29fe:	61 e0       	ldi	r22, 0x01	; 1
    2a00:	eb cf       	rjmp	.-42     	; 0x29d8 <sem4_execute+0x10e>

00002a02 <thread4>:
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static msg_t thread4(void *p) {

  chBSemSignal((BinarySemaphore *)p);
    2a02:	f8 94       	cli
    2a04:	fc 01       	movw	r30, r24
    2a06:	84 81       	ldd	r24, Z+4	; 0x04
    2a08:	18 16       	cp	r1, r24
    2a0a:	34 f4       	brge	.+12     	; 0x2a18 <thread4+0x16>
    2a0c:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
    2a10:	78 94       	sei
  return 0;
}
    2a12:	80 e0       	ldi	r24, 0x00	; 0
    2a14:	90 e0       	ldi	r25, 0x00	; 0
    2a16:	08 95       	ret
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static msg_t thread4(void *p) {

  chBSemSignal((BinarySemaphore *)p);
    2a18:	cf 01       	movw	r24, r30
    2a1a:	0e 94 c7 04 	call	0x98e	; 0x98e <chSemSignalI>
    2a1e:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
    2a22:	78 94       	sei
  return 0;
}
    2a24:	80 e0       	ldi	r24, 0x00	; 0
    2a26:	90 e0       	ldi	r25, 0x00	; 0
    2a28:	08 95       	ret

00002a2a <sem3_execute>:
  chSemWait(&sem1);
  chSemSignal(&sem1);
  return 0;
}

static void sem3_execute(void) {
    2a2a:	0f 93       	push	r16
    2a2c:	1f 93       	push	r17

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread3, 0);
    2a2e:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2a32:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2a36:	44 81       	ldd	r20, Z+4	; 0x04
    2a38:	4f 5f       	subi	r20, 0xFF	; 255
    2a3a:	80 91 95 02 	lds	r24, 0x0295
    2a3e:	90 91 96 02 	lds	r25, 0x0296
    2a42:	65 e9       	ldi	r22, 0x95	; 149
    2a44:	70 e0       	ldi	r23, 0x00	; 0
    2a46:	2a e7       	ldi	r18, 0x7A	; 122
    2a48:	35 e1       	ldi	r19, 0x15	; 21
    2a4a:	00 e0       	ldi	r16, 0x00	; 0
    2a4c:	10 e0       	ldi	r17, 0x00	; 0
    2a4e:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2a52:	90 93 02 0c 	sts	0x0C02, r25
    2a56:	80 93 01 0c 	sts	0x0C01, r24
  chSemSignalWait(&sem1, &sem1);
    2a5a:	84 ef       	ldi	r24, 0xF4	; 244
    2a5c:	93 e0       	ldi	r25, 0x03	; 3
    2a5e:	bc 01       	movw	r22, r24
    2a60:	0e 94 42 05 	call	0xa84	; 0xa84 <chSemSignalWait>
  test_assert(1, isempty(&sem1.s_queue), "queue not empty");
    2a64:	60 e0       	ldi	r22, 0x00	; 0
    2a66:	80 91 f4 03 	lds	r24, 0x03F4
    2a6a:	90 91 f5 03 	lds	r25, 0x03F5
    2a6e:	84 5f       	subi	r24, 0xF4	; 244
    2a70:	93 40       	sbci	r25, 0x03	; 3
    2a72:	e1 f1       	breq	.+120    	; 0x2aec <sem3_execute+0xc2>
    2a74:	81 e0       	ldi	r24, 0x01	; 1
    2a76:	90 e0       	ldi	r25, 0x00	; 0
    2a78:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2a7c:	88 23       	and	r24, r24
    2a7e:	19 f0       	breq	.+6      	; 0x2a86 <sem3_execute+0x5c>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
}
    2a80:	1f 91       	pop	r17
    2a82:	0f 91       	pop	r16
    2a84:	08 95       	ret
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
    2a86:	60 e0       	ldi	r22, 0x00	; 0
    2a88:	80 91 f8 03 	lds	r24, 0x03F8
    2a8c:	88 23       	and	r24, r24
    2a8e:	31 f1       	breq	.+76     	; 0x2adc <sem3_execute+0xb2>
    2a90:	82 e0       	ldi	r24, 0x02	; 2
    2a92:	90 e0       	ldi	r25, 0x00	; 0
    2a94:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2a98:	88 23       	and	r24, r24
    2a9a:	91 f7       	brne	.-28     	; 0x2a80 <sem3_execute+0x56>

  chSemSignalWait(&sem1, &sem1);
    2a9c:	84 ef       	ldi	r24, 0xF4	; 244
    2a9e:	93 e0       	ldi	r25, 0x03	; 3
    2aa0:	bc 01       	movw	r22, r24
    2aa2:	0e 94 42 05 	call	0xa84	; 0xa84 <chSemSignalWait>
  test_assert(3, isempty(&sem1.s_queue), "queue not empty");
    2aa6:	60 e0       	ldi	r22, 0x00	; 0
    2aa8:	20 91 f4 03 	lds	r18, 0x03F4
    2aac:	30 91 f5 03 	lds	r19, 0x03F5
    2ab0:	84 ef       	ldi	r24, 0xF4	; 244
    2ab2:	93 e0       	ldi	r25, 0x03	; 3
    2ab4:	82 17       	cp	r24, r18
    2ab6:	93 07       	cpc	r25, r19
    2ab8:	d9 f0       	breq	.+54     	; 0x2af0 <sem3_execute+0xc6>
    2aba:	83 e0       	ldi	r24, 0x03	; 3
    2abc:	90 e0       	ldi	r25, 0x00	; 0
    2abe:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2ac2:	88 23       	and	r24, r24
    2ac4:	e9 f6       	brne	.-70     	; 0x2a80 <sem3_execute+0x56>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
    2ac6:	60 e0       	ldi	r22, 0x00	; 0
    2ac8:	80 91 f8 03 	lds	r24, 0x03F8
    2acc:	88 23       	and	r24, r24
    2ace:	09 f4       	brne	.+2      	; 0x2ad2 <sem3_execute+0xa8>
    2ad0:	61 e0       	ldi	r22, 0x01	; 1
    2ad2:	84 e0       	ldi	r24, 0x04	; 4
    2ad4:	90 e0       	ldi	r25, 0x00	; 0
    2ad6:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2ada:	d2 cf       	rjmp	.-92     	; 0x2a80 <sem3_execute+0x56>
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
    2adc:	61 e0       	ldi	r22, 0x01	; 1
    2ade:	82 e0       	ldi	r24, 0x02	; 2
    2ae0:	90 e0       	ldi	r25, 0x00	; 0
    2ae2:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2ae6:	88 23       	and	r24, r24
    2ae8:	59 f6       	brne	.-106    	; 0x2a80 <sem3_execute+0x56>
    2aea:	d8 cf       	rjmp	.-80     	; 0x2a9c <sem3_execute+0x72>

static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, isempty(&sem1.s_queue), "queue not empty");
    2aec:	61 e0       	ldi	r22, 0x01	; 1
    2aee:	c2 cf       	rjmp	.-124    	; 0x2a74 <sem3_execute+0x4a>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, isempty(&sem1.s_queue), "queue not empty");
    2af0:	61 e0       	ldi	r22, 0x01	; 1
    2af2:	e3 cf       	rjmp	.-58     	; 0x2aba <sem3_execute+0x90>

00002af4 <thread3>:
static void sem3_setup(void) {

  chSemInit(&sem1, 0);
}

static msg_t thread3(void *p) {
    2af4:	0f 93       	push	r16
    2af6:	1f 93       	push	r17

  (void)p;
  chSemWait(&sem1);
    2af8:	04 ef       	ldi	r16, 0xF4	; 244
    2afa:	13 e0       	ldi	r17, 0x03	; 3
    2afc:	c8 01       	movw	r24, r16
    2afe:	0e 94 3d 05 	call	0xa7a	; 0xa7a <chSemWait>
  chSemSignal(&sem1);
    2b02:	c8 01       	movw	r24, r16
    2b04:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chSemSignal>
  return 0;
}
    2b08:	80 e0       	ldi	r24, 0x00	; 0
    2b0a:	90 e0       	ldi	r25, 0x00	; 0
    2b0c:	1f 91       	pop	r17
    2b0e:	0f 91       	pop	r16
    2b10:	08 95       	ret

00002b12 <thread1>:
static void sem1_setup(void) {

  chSemInit(&sem1, 0);
}

static msg_t thread1(void *p) {
    2b12:	0f 93       	push	r16
    2b14:	1f 93       	push	r17
    2b16:	8c 01       	movw	r16, r24

  chSemWait(&sem1);
    2b18:	84 ef       	ldi	r24, 0xF4	; 244
    2b1a:	93 e0       	ldi	r25, 0x03	; 3
    2b1c:	0e 94 3d 05 	call	0xa7a	; 0xa7a <chSemWait>
  test_emit_token(*(char *)p);
    2b20:	f8 01       	movw	r30, r16
    2b22:	80 81       	ld	r24, Z
    2b24:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  return 0;
}
    2b28:	80 e0       	ldi	r24, 0x00	; 0
    2b2a:	90 e0       	ldi	r25, 0x00	; 0
    2b2c:	1f 91       	pop	r17
    2b2e:	0f 91       	pop	r16
    2b30:	08 95       	ret

00002b32 <sem2_execute>:
  chSchRescheduleS();
  chSysUnlock();
  return 0;
}

static void sem2_execute(void) {
    2b32:	ef 92       	push	r14
    2b34:	ff 92       	push	r15
    2b36:	0f 93       	push	r16
    2b38:	1f 93       	push	r17
    2b3a:	cf 93       	push	r28
    2b3c:	df 93       	push	r29
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
    2b3e:	84 ef       	ldi	r24, 0xF4	; 244
    2b40:	93 e0       	ldi	r25, 0x03	; 3
    2b42:	60 e0       	ldi	r22, 0x00	; 0
    2b44:	70 e0       	ldi	r23, 0x00	; 0
    2b46:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <chSemWaitTimeout>
  test_assert(1, msg == RDY_TIMEOUT, "wrong wake-up message");
    2b4a:	60 e0       	ldi	r22, 0x00	; 0
    2b4c:	8f 5f       	subi	r24, 0xFF	; 255
    2b4e:	9f 4f       	sbci	r25, 0xFF	; 255
    2b50:	09 f4       	brne	.+2      	; 0x2b54 <sem2_execute+0x22>
    2b52:	c0 c0       	rjmp	.+384    	; 0x2cd4 <sem2_execute+0x1a2>
    2b54:	81 e0       	ldi	r24, 0x01	; 1
    2b56:	90 e0       	ldi	r25, 0x00	; 0
    2b58:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2b5c:	88 23       	and	r24, r24
    2b5e:	39 f0       	breq	.+14     	; 0x2b6e <sem2_execute+0x3c>
    test_assert(8, isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
}
    2b60:	df 91       	pop	r29
    2b62:	cf 91       	pop	r28
    2b64:	1f 91       	pop	r17
    2b66:	0f 91       	pop	r16
    2b68:	ff 90       	pop	r15
    2b6a:	ef 90       	pop	r14
    2b6c:	08 95       	ret
  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == RDY_TIMEOUT, "wrong wake-up message");
  test_assert(2, isempty(&sem1.s_queue), "queue not empty");
    2b6e:	c4 ef       	ldi	r28, 0xF4	; 244
    2b70:	d3 e0       	ldi	r29, 0x03	; 3
    2b72:	60 e0       	ldi	r22, 0x00	; 0
    2b74:	80 91 f4 03 	lds	r24, 0x03F4
    2b78:	90 91 f5 03 	lds	r25, 0x03F5
    2b7c:	8c 17       	cp	r24, r28
    2b7e:	9d 07       	cpc	r25, r29
    2b80:	09 f4       	brne	.+2      	; 0x2b84 <sem2_execute+0x52>
    2b82:	aa c0       	rjmp	.+340    	; 0x2cd8 <sem2_execute+0x1a6>
    2b84:	82 e0       	ldi	r24, 0x02	; 2
    2b86:	90 e0       	ldi	r25, 0x00	; 0
    2b88:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2b8c:	88 23       	and	r24, r24
    2b8e:	41 f7       	brne	.-48     	; 0x2b60 <sem2_execute+0x2e>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
    2b90:	60 e0       	ldi	r22, 0x00	; 0
    2b92:	80 91 f8 03 	lds	r24, 0x03F8
    2b96:	88 23       	and	r24, r24
    2b98:	09 f4       	brne	.+2      	; 0x2b9c <sem2_execute+0x6a>
    2b9a:	61 e0       	ldi	r22, 0x01	; 1
    2b9c:	83 e0       	ldi	r24, 0x03	; 3
    2b9e:	90 e0       	ldi	r25, 0x00	; 0
    2ba0:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2ba4:	88 23       	and	r24, r24
    2ba6:	e1 f6       	brne	.-72     	; 0x2b60 <sem2_execute+0x2e>

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
    2ba8:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2bac:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2bb0:	44 81       	ldd	r20, Z+4	; 0x04
    2bb2:	41 50       	subi	r20, 0x01	; 1
    2bb4:	80 91 95 02 	lds	r24, 0x0295
    2bb8:	90 91 96 02 	lds	r25, 0x0296
    2bbc:	65 e9       	ldi	r22, 0x95	; 149
    2bbe:	70 e0       	ldi	r23, 0x00	; 0
    2bc0:	24 e7       	ldi	r18, 0x74	; 116
    2bc2:	36 e1       	ldi	r19, 0x16	; 22
    2bc4:	00 e0       	ldi	r16, 0x00	; 0
    2bc6:	10 e0       	ldi	r17, 0x00	; 0
    2bc8:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2bcc:	90 93 02 0c 	sts	0x0C02, r25
    2bd0:	80 93 01 0c 	sts	0x0C01, r24
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
    2bd4:	84 ef       	ldi	r24, 0xF4	; 244
    2bd6:	93 e0       	ldi	r25, 0x03	; 3
    2bd8:	64 ef       	ldi	r22, 0xF4	; 244
    2bda:	71 e0       	ldi	r23, 0x01	; 1
    2bdc:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <chSemWaitTimeout>
    2be0:	8c 01       	movw	r16, r24
  test_wait_threads();
    2be2:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_assert(4, msg == RDY_OK, "wrong wake-up message");
    2be6:	60 e0       	ldi	r22, 0x00	; 0
    2be8:	01 2b       	or	r16, r17
    2bea:	09 f4       	brne	.+2      	; 0x2bee <sem2_execute+0xbc>
    2bec:	61 e0       	ldi	r22, 0x01	; 1
    2bee:	84 e0       	ldi	r24, 0x04	; 4
    2bf0:	90 e0       	ldi	r25, 0x00	; 0
    2bf2:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2bf6:	88 23       	and	r24, r24
    2bf8:	09 f0       	breq	.+2      	; 0x2bfc <sem2_execute+0xca>
    2bfa:	b2 cf       	rjmp	.-156    	; 0x2b60 <sem2_execute+0x2e>
  test_assert(5, isempty(&sem1.s_queue), "queue not empty");
    2bfc:	60 e0       	ldi	r22, 0x00	; 0
    2bfe:	80 91 f4 03 	lds	r24, 0x03F4
    2c02:	90 91 f5 03 	lds	r25, 0x03F5
    2c06:	c8 17       	cp	r28, r24
    2c08:	d9 07       	cpc	r29, r25
    2c0a:	09 f4       	brne	.+2      	; 0x2c0e <sem2_execute+0xdc>
    2c0c:	67 c0       	rjmp	.+206    	; 0x2cdc <sem2_execute+0x1aa>
    2c0e:	85 e0       	ldi	r24, 0x05	; 5
    2c10:	90 e0       	ldi	r25, 0x00	; 0
    2c12:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2c16:	88 23       	and	r24, r24
    2c18:	09 f0       	breq	.+2      	; 0x2c1c <sem2_execute+0xea>
    2c1a:	a2 cf       	rjmp	.-188    	; 0x2b60 <sem2_execute+0x2e>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
    2c1c:	60 e0       	ldi	r22, 0x00	; 0
    2c1e:	80 91 f8 03 	lds	r24, 0x03F8
    2c22:	88 23       	and	r24, r24
    2c24:	09 f4       	brne	.+2      	; 0x2c28 <sem2_execute+0xf6>
    2c26:	61 e0       	ldi	r22, 0x01	; 1
    2c28:	86 e0       	ldi	r24, 0x06	; 6
    2c2a:	90 e0       	ldi	r25, 0x00	; 0
    2c2c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2c30:	88 23       	and	r24, r24
    2c32:	09 f0       	breq	.+2      	; 0x2c36 <sem2_execute+0x104>
    2c34:	95 cf       	rjmp	.-214    	; 0x2b60 <sem2_execute+0x2e>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
    2c36:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  target_time = chTimeNow() + MS2ST(5 * 500);
    2c3a:	e0 90 f1 0b 	lds	r14, 0x0BF1
    2c3e:	f0 90 f2 0b 	lds	r15, 0x0BF2
    2c42:	11 e4       	ldi	r17, 0x41	; 65
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
    2c44:	81 2f       	mov	r24, r17
    2c46:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(500));
    2c4a:	84 ef       	ldi	r24, 0xF4	; 244
    2c4c:	93 e0       	ldi	r25, 0x03	; 3
    2c4e:	64 ef       	ldi	r22, 0xF4	; 244
    2c50:	71 e0       	ldi	r23, 0x01	; 1
    2c52:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <chSemWaitTimeout>
    test_assert(7, msg == RDY_TIMEOUT, "wrong wake-up message");
    2c56:	60 e0       	ldi	r22, 0x00	; 0
    2c58:	8f 5f       	subi	r24, 0xFF	; 255
    2c5a:	9f 4f       	sbci	r25, 0xFF	; 255
    2c5c:	09 f4       	brne	.+2      	; 0x2c60 <sem2_execute+0x12e>
    2c5e:	40 c0       	rjmp	.+128    	; 0x2ce0 <sem2_execute+0x1ae>
    2c60:	87 e0       	ldi	r24, 0x07	; 7
    2c62:	90 e0       	ldi	r25, 0x00	; 0
    2c64:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2c68:	88 23       	and	r24, r24
    2c6a:	09 f0       	breq	.+2      	; 0x2c6e <sem2_execute+0x13c>
    2c6c:	79 cf       	rjmp	.-270    	; 0x2b60 <sem2_execute+0x2e>
    test_assert(8, isempty(&sem1.s_queue), "queue not empty");
    2c6e:	60 e0       	ldi	r22, 0x00	; 0
    2c70:	80 91 f4 03 	lds	r24, 0x03F4
    2c74:	90 91 f5 03 	lds	r25, 0x03F5
    2c78:	c8 17       	cp	r28, r24
    2c7a:	d9 07       	cpc	r29, r25
    2c7c:	99 f1       	breq	.+102    	; 0x2ce4 <sem2_execute+0x1b2>
    2c7e:	88 e0       	ldi	r24, 0x08	; 8
    2c80:	90 e0       	ldi	r25, 0x00	; 0
    2c82:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2c86:	88 23       	and	r24, r24
    2c88:	09 f0       	breq	.+2      	; 0x2c8c <sem2_execute+0x15a>
    2c8a:	6a cf       	rjmp	.-300    	; 0x2b60 <sem2_execute+0x2e>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
    2c8c:	60 e0       	ldi	r22, 0x00	; 0
    2c8e:	80 91 f8 03 	lds	r24, 0x03F8
    2c92:	88 23       	and	r24, r24
    2c94:	09 f4       	brne	.+2      	; 0x2c98 <sem2_execute+0x166>
    2c96:	61 e0       	ldi	r22, 0x01	; 1
    2c98:	89 e0       	ldi	r24, 0x09	; 9
    2c9a:	90 e0       	ldi	r25, 0x00	; 0
    2c9c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    2ca0:	88 23       	and	r24, r24
    2ca2:	09 f0       	breq	.+2      	; 0x2ca6 <sem2_execute+0x174>
    2ca4:	5d cf       	rjmp	.-326    	; 0x2b60 <sem2_execute+0x2e>
    2ca6:	1f 5f       	subi	r17, 0xFF	; 255
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(5 * 500);
  for (i = 0; i < 5; i++) {
    2ca8:	16 34       	cpi	r17, 0x46	; 70
    2caa:	61 f6       	brne	.-104    	; 0x2c44 <sem2_execute+0x112>
    msg = chSemWaitTimeout(&sem1, MS2ST(500));
    test_assert(7, msg == RDY_TIMEOUT, "wrong wake-up message");
    test_assert(8, isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
    2cac:	8a e0       	ldi	r24, 0x0A	; 10
    2cae:	90 e0       	ldi	r25, 0x00	; 0
    2cb0:	60 e5       	ldi	r22, 0x50	; 80
    2cb2:	73 e0       	ldi	r23, 0x03	; 3
    2cb4:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
    2cb8:	88 23       	and	r24, r24
    2cba:	09 f0       	breq	.+2      	; 0x2cbe <sem2_execute+0x18c>
    2cbc:	51 cf       	rjmp	.-350    	; 0x2b60 <sem2_execute+0x2e>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(5 * 500);
    2cbe:	a7 01       	movw	r20, r14
    2cc0:	4c 53       	subi	r20, 0x3C	; 60
    2cc2:	56 4f       	sbci	r21, 0xF6	; 246
    test_assert(7, msg == RDY_TIMEOUT, "wrong wake-up message");
    test_assert(8, isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
    2cc4:	8b e0       	ldi	r24, 0x0B	; 11
    2cc6:	90 e0       	ldi	r25, 0x00	; 0
    2cc8:	ba 01       	movw	r22, r20
    2cca:	4b 5f       	subi	r20, 0xFB	; 251
    2ccc:	5f 4f       	sbci	r21, 0xFF	; 255
    2cce:	0e 94 de 11 	call	0x23bc	; 0x23bc <_test_assert_time_window>
    2cd2:	46 cf       	rjmp	.-372    	; 0x2b60 <sem2_execute+0x2e>

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == RDY_TIMEOUT, "wrong wake-up message");
    2cd4:	61 e0       	ldi	r22, 0x01	; 1
    2cd6:	3e cf       	rjmp	.-388    	; 0x2b54 <sem2_execute+0x22>
  test_assert(2, isempty(&sem1.s_queue), "queue not empty");
    2cd8:	61 e0       	ldi	r22, 0x01	; 1
    2cda:	54 cf       	rjmp	.-344    	; 0x2b84 <sem2_execute+0x52>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
  test_wait_threads();
  test_assert(4, msg == RDY_OK, "wrong wake-up message");
  test_assert(5, isempty(&sem1.s_queue), "queue not empty");
    2cdc:	61 e0       	ldi	r22, 0x01	; 1
    2cde:	97 cf       	rjmp	.-210    	; 0x2c0e <sem2_execute+0xdc>
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(5 * 500);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
    msg = chSemWaitTimeout(&sem1, MS2ST(500));
    test_assert(7, msg == RDY_TIMEOUT, "wrong wake-up message");
    2ce0:	61 e0       	ldi	r22, 0x01	; 1
    2ce2:	be cf       	rjmp	.-132    	; 0x2c60 <sem2_execute+0x12e>
    test_assert(8, isempty(&sem1.s_queue), "queue not empty");
    2ce4:	61 e0       	ldi	r22, 0x01	; 1
    2ce6:	cb cf       	rjmp	.-106    	; 0x2c7e <sem2_execute+0x14c>

00002ce8 <thread2>:
}

static msg_t thread2(void *p) {

  (void)p;
  chThdSleepMilliseconds(50);
    2ce8:	82 e3       	ldi	r24, 0x32	; 50
    2cea:	90 e0       	ldi	r25, 0x00	; 0
    2cec:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  chSysLock();
    2cf0:	f8 94       	cli
  chSemSignalI(&sem1); /* For coverage reasons */
    2cf2:	84 ef       	ldi	r24, 0xF4	; 244
    2cf4:	93 e0       	ldi	r25, 0x03	; 3
    2cf6:	0e 94 c7 04 	call	0x98e	; 0x98e <chSemSignalI>
  chSchRescheduleS();
    2cfa:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  chSysUnlock();
    2cfe:	78 94       	sei
  return 0;
}
    2d00:	80 e0       	ldi	r24, 0x00	; 0
    2d02:	90 e0       	ldi	r25, 0x00	; 0
    2d04:	08 95       	ret

00002d06 <sem1_execute>:
  chSemWait(&sem1);
  test_emit_token(*(char *)p);
  return 0;
}

static void sem1_execute(void) {
    2d06:	0f 93       	push	r16
    2d08:	1f 93       	push	r17
    2d0a:	cf 93       	push	r28
    2d0c:	df 93       	push	r29

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+5, thread1, "A");
    2d0e:	c0 91 95 02 	lds	r28, 0x0295
    2d12:	d0 91 96 02 	lds	r29, 0x0296
    2d16:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2d1a:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2d1e:	44 81       	ldd	r20, Z+4	; 0x04
    2d20:	4b 5f       	subi	r20, 0xFB	; 251
    2d22:	ce 01       	movw	r24, r28
    2d24:	65 e9       	ldi	r22, 0x95	; 149
    2d26:	70 e0       	ldi	r23, 0x00	; 0
    2d28:	29 e8       	ldi	r18, 0x89	; 137
    2d2a:	35 e1       	ldi	r19, 0x15	; 21
    2d2c:	06 e5       	ldi	r16, 0x56	; 86
    2d2e:	13 e0       	ldi	r17, 0x03	; 3
    2d30:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2d34:	90 93 02 0c 	sts	0x0C02, r25
    2d38:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()+1, thread1, "B");
    2d3c:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2d40:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2d44:	44 81       	ldd	r20, Z+4	; 0x04
    2d46:	4f 5f       	subi	r20, 0xFF	; 255
    2d48:	80 91 97 02 	lds	r24, 0x0297
    2d4c:	90 91 98 02 	lds	r25, 0x0298
    2d50:	65 e9       	ldi	r22, 0x95	; 149
    2d52:	70 e0       	ldi	r23, 0x00	; 0
    2d54:	29 e8       	ldi	r18, 0x89	; 137
    2d56:	35 e1       	ldi	r19, 0x15	; 21
    2d58:	08 e5       	ldi	r16, 0x58	; 88
    2d5a:	13 e0       	ldi	r17, 0x03	; 3
    2d5c:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2d60:	90 93 04 0c 	sts	0x0C04, r25
    2d64:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()+3, thread1, "C");
    2d68:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2d6c:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2d70:	44 81       	ldd	r20, Z+4	; 0x04
    2d72:	4d 5f       	subi	r20, 0xFD	; 253
    2d74:	80 91 99 02 	lds	r24, 0x0299
    2d78:	90 91 9a 02 	lds	r25, 0x029A
    2d7c:	65 e9       	ldi	r22, 0x95	; 149
    2d7e:	70 e0       	ldi	r23, 0x00	; 0
    2d80:	29 e8       	ldi	r18, 0x89	; 137
    2d82:	35 e1       	ldi	r19, 0x15	; 21
    2d84:	0a e5       	ldi	r16, 0x5A	; 90
    2d86:	13 e0       	ldi	r17, 0x03	; 3
    2d88:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2d8c:	90 93 06 0c 	sts	0x0C06, r25
    2d90:	80 93 05 0c 	sts	0x0C05, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()+4, thread1, "D");
    2d94:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2d98:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2d9c:	44 81       	ldd	r20, Z+4	; 0x04
    2d9e:	4c 5f       	subi	r20, 0xFC	; 252
    2da0:	80 91 9b 02 	lds	r24, 0x029B
    2da4:	90 91 9c 02 	lds	r25, 0x029C
    2da8:	65 e9       	ldi	r22, 0x95	; 149
    2daa:	70 e0       	ldi	r23, 0x00	; 0
    2dac:	29 e8       	ldi	r18, 0x89	; 137
    2dae:	35 e1       	ldi	r19, 0x15	; 21
    2db0:	0c e5       	ldi	r16, 0x5C	; 92
    2db2:	13 e0       	ldi	r17, 0x03	; 3
    2db4:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2db8:	90 93 08 0c 	sts	0x0C08, r25
    2dbc:	80 93 07 0c 	sts	0x0C07, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()+2, thread1, "E");
    2dc0:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2dc4:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2dc8:	44 81       	ldd	r20, Z+4	; 0x04
    2dca:	4e 5f       	subi	r20, 0xFE	; 254
    2dcc:	80 91 9d 02 	lds	r24, 0x029D
    2dd0:	90 91 9e 02 	lds	r25, 0x029E
    2dd4:	65 e9       	ldi	r22, 0x95	; 149
    2dd6:	70 e0       	ldi	r23, 0x00	; 0
    2dd8:	29 e8       	ldi	r18, 0x89	; 137
    2dda:	35 e1       	ldi	r19, 0x15	; 21
    2ddc:	0e e5       	ldi	r16, 0x5E	; 94
    2dde:	13 e0       	ldi	r17, 0x03	; 3
    2de0:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2de4:	90 93 0a 0c 	sts	0x0C0A, r25
    2de8:	80 93 09 0c 	sts	0x0C09, r24
  chSemSignal(&sem1);
    2dec:	84 ef       	ldi	r24, 0xF4	; 244
    2dee:	93 e0       	ldi	r25, 0x03	; 3
    2df0:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chSemSignal>
  chSemSignal(&sem1);
    2df4:	84 ef       	ldi	r24, 0xF4	; 244
    2df6:	93 e0       	ldi	r25, 0x03	; 3
    2df8:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chSemSignal>
  chSemSignal(&sem1);
    2dfc:	84 ef       	ldi	r24, 0xF4	; 244
    2dfe:	93 e0       	ldi	r25, 0x03	; 3
    2e00:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chSemSignal>
  chSemSignal(&sem1);
    2e04:	84 ef       	ldi	r24, 0xF4	; 244
    2e06:	93 e0       	ldi	r25, 0x03	; 3
    2e08:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chSemSignal>
  chSemSignal(&sem1);
    2e0c:	84 ef       	ldi	r24, 0xF4	; 244
    2e0e:	93 e0       	ldi	r25, 0x03	; 3
    2e10:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chSemSignal>
  test_wait_threads();
    2e14:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
#if CH_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
    2e18:	81 e0       	ldi	r24, 0x01	; 1
    2e1a:	90 e0       	ldi	r25, 0x00	; 0
    2e1c:	60 e5       	ldi	r22, 0x50	; 80
    2e1e:	73 e0       	ldi	r23, 0x03	; 3
    2e20:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
    2e24:	88 23       	and	r24, r24
    2e26:	29 f0       	breq	.+10     	; 0x2e32 <sem1_execute+0x12c>
  chSysLock();
  chSemAddCounterI(&sem1, 2);
  chSysUnlock();
  test_wait_threads();
  test_assert(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
}
    2e28:	df 91       	pop	r29
    2e2a:	cf 91       	pop	r28
    2e2c:	1f 91       	pop	r17
    2e2e:	0f 91       	pop	r16
    2e30:	08 95       	ret
#if CH_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+5, thread1, "A");
    2e32:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2e36:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2e3a:	44 81       	ldd	r20, Z+4	; 0x04
    2e3c:	4b 5f       	subi	r20, 0xFB	; 251
    2e3e:	ce 01       	movw	r24, r28
    2e40:	65 e9       	ldi	r22, 0x95	; 149
    2e42:	70 e0       	ldi	r23, 0x00	; 0
    2e44:	29 e8       	ldi	r18, 0x89	; 137
    2e46:	35 e1       	ldi	r19, 0x15	; 21
    2e48:	06 e5       	ldi	r16, 0x56	; 86
    2e4a:	13 e0       	ldi	r17, 0x03	; 3
    2e4c:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2e50:	90 93 02 0c 	sts	0x0C02, r25
    2e54:	80 93 01 0c 	sts	0x0C01, r24
  chSysLock();
    2e58:	f8 94       	cli
  chSemAddCounterI(&sem1, 2);
    2e5a:	84 ef       	ldi	r24, 0xF4	; 244
    2e5c:	93 e0       	ldi	r25, 0x03	; 3
    2e5e:	62 e0       	ldi	r22, 0x02	; 2
    2e60:	0e 94 9a 04 	call	0x934	; 0x934 <chSemAddCounterI>
  chSysUnlock();
    2e64:	78 94       	sei
  test_wait_threads();
    2e66:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_assert(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
    2e6a:	60 e0       	ldi	r22, 0x00	; 0
    2e6c:	80 91 f8 03 	lds	r24, 0x03F8
    2e70:	81 30       	cpi	r24, 0x01	; 1
    2e72:	49 f0       	breq	.+18     	; 0x2e86 <sem1_execute+0x180>
    2e74:	82 e0       	ldi	r24, 0x02	; 2
    2e76:	90 e0       	ldi	r25, 0x00	; 0
    2e78:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
}
    2e7c:	df 91       	pop	r29
    2e7e:	cf 91       	pop	r28
    2e80:	1f 91       	pop	r17
    2e82:	0f 91       	pop	r16
    2e84:	08 95       	ret
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+5, thread1, "A");
  chSysLock();
  chSemAddCounterI(&sem1, 2);
  chSysUnlock();
  test_wait_threads();
  test_assert(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
    2e86:	61 e0       	ldi	r22, 0x01	; 1
    2e88:	f5 cf       	rjmp	.-22     	; 0x2e74 <sem1_execute+0x16e>

00002e8a <mtx8_execute>:
  test_emit_token(*(char *)p);
  chMtxUnlock();
  return 0;
}

static void mtx8_execute(void) {
    2e8a:	ff 92       	push	r15
    2e8c:	0f 93       	push	r16
    2e8e:	1f 93       	push	r17

  tprio_t prio = chThdGetPriority();
    2e90:	e0 91 fe 0b 	lds	r30, 0x0BFE
    2e94:	f0 91 ff 0b 	lds	r31, 0x0BFF
    2e98:	f4 80       	ldd	r15, Z+4	; 0x04
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
    2e9a:	f3 94       	inc	r15
    2e9c:	80 91 95 02 	lds	r24, 0x0295
    2ea0:	90 91 96 02 	lds	r25, 0x0296
    2ea4:	65 e9       	ldi	r22, 0x95	; 149
    2ea6:	70 e0       	ldi	r23, 0x00	; 0
    2ea8:	4f 2d       	mov	r20, r15
    2eaa:	21 ed       	ldi	r18, 0xD1	; 209
    2eac:	37 e1       	ldi	r19, 0x17	; 23
    2eae:	09 ef       	ldi	r16, 0xF9	; 249
    2eb0:	13 e0       	ldi	r17, 0x03	; 3
    2eb2:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2eb6:	90 93 02 0c 	sts	0x0C02, r25
    2eba:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
    2ebe:	f3 94       	inc	r15
    2ec0:	80 91 97 02 	lds	r24, 0x0297
    2ec4:	90 91 98 02 	lds	r25, 0x0298
    2ec8:	65 e9       	ldi	r22, 0x95	; 149
    2eca:	70 e0       	ldi	r23, 0x00	; 0
    2ecc:	4f 2d       	mov	r20, r15
    2ece:	2b eb       	ldi	r18, 0xBB	; 187
    2ed0:	37 e1       	ldi	r19, 0x17	; 23
    2ed2:	0b ef       	ldi	r16, 0xFB	; 251
    2ed4:	13 e0       	ldi	r17, 0x03	; 3
    2ed6:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2eda:	90 93 04 0c 	sts	0x0C04, r25
    2ede:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
    2ee2:	f3 94       	inc	r15
    2ee4:	80 91 99 02 	lds	r24, 0x0299
    2ee8:	90 91 9a 02 	lds	r25, 0x029A
    2eec:	65 e9       	ldi	r22, 0x95	; 149
    2eee:	70 e0       	ldi	r23, 0x00	; 0
    2ef0:	4f 2d       	mov	r20, r15
    2ef2:	27 e9       	ldi	r18, 0x97	; 151
    2ef4:	37 e1       	ldi	r19, 0x17	; 23
    2ef6:	0d ef       	ldi	r16, 0xFD	; 253
    2ef8:	13 e0       	ldi	r17, 0x03	; 3
    2efa:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    2efe:	90 93 06 0c 	sts	0x0C06, r25
    2f02:	80 93 05 0c 	sts	0x0C05, r24
  chCondSignal(&c1);
    2f06:	01 e4       	ldi	r16, 0x41	; 65
    2f08:	15 e0       	ldi	r17, 0x05	; 5
    2f0a:	c8 01       	movw	r24, r16
    2f0c:	0e 94 c4 08 	call	0x1188	; 0x1188 <chCondSignal>
  chCondSignal(&c1);
    2f10:	c8 01       	movw	r24, r16
    2f12:	0e 94 c4 08 	call	0x1188	; 0x1188 <chCondSignal>
  test_wait_threads();
    2f16:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_assert_sequence(1, "ABC");
    2f1a:	81 e0       	ldi	r24, 0x01	; 1
    2f1c:	90 e0       	ldi	r25, 0x00	; 0
    2f1e:	6f ef       	ldi	r22, 0xFF	; 255
    2f20:	73 e0       	ldi	r23, 0x03	; 3
    2f22:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
}
    2f26:	1f 91       	pop	r17
    2f28:	0f 91       	pop	r16
    2f2a:	ff 90       	pop	r15
    2f2c:	08 95       	ret

00002f2e <thread12>:
  chMtxUnlock();
  chMtxUnlock();
  return 0;
}

static msg_t thread12(void *p) {
    2f2e:	0f 93       	push	r16
    2f30:	1f 93       	push	r17
    2f32:	8c 01       	movw	r16, r24

  chMtxLock(&m2);
    2f34:	85 e4       	ldi	r24, 0x45	; 69
    2f36:	95 e0       	ldi	r25, 0x05	; 5
    2f38:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_emit_token(*(char *)p);
    2f3c:	f8 01       	movw	r30, r16
    2f3e:	80 81       	ld	r24, Z
    2f40:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  chMtxUnlock();
    2f44:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  return 0;
}
    2f48:	80 e0       	ldi	r24, 0x00	; 0
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	1f 91       	pop	r17
    2f4e:	0f 91       	pop	r16
    2f50:	08 95       	ret

00002f52 <thread1>:
static void mtx1_setup(void) {

  chMtxInit(&m1);
}

static msg_t thread1(void *p) {
    2f52:	0f 93       	push	r16
    2f54:	1f 93       	push	r17
    2f56:	8c 01       	movw	r16, r24

  chMtxLock(&m1);
    2f58:	8d e4       	ldi	r24, 0x4D	; 77
    2f5a:	95 e0       	ldi	r25, 0x05	; 5
    2f5c:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_emit_token(*(char *)p);
    2f60:	f8 01       	movw	r30, r16
    2f62:	80 81       	ld	r24, Z
    2f64:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  chMtxUnlock();
    2f68:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  return 0;
}
    2f6c:	80 e0       	ldi	r24, 0x00	; 0
    2f6e:	90 e0       	ldi	r25, 0x00	; 0
    2f70:	1f 91       	pop	r17
    2f72:	0f 91       	pop	r16
    2f74:	08 95       	ret

00002f76 <thread10>:

  chCondInit(&c1);
  chMtxInit(&m1);
}

static msg_t thread10(void *p) {
    2f76:	0f 93       	push	r16
    2f78:	1f 93       	push	r17
    2f7a:	8c 01       	movw	r16, r24

  chMtxLock(&m1);
    2f7c:	8d e4       	ldi	r24, 0x4D	; 77
    2f7e:	95 e0       	ldi	r25, 0x05	; 5
    2f80:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  chCondWait(&c1);
    2f84:	81 e4       	ldi	r24, 0x41	; 65
    2f86:	95 e0       	ldi	r25, 0x05	; 5
    2f88:	0e 94 78 08 	call	0x10f0	; 0x10f0 <chCondWait>
  test_emit_token(*(char *)p);
    2f8c:	f8 01       	movw	r30, r16
    2f8e:	80 81       	ld	r24, Z
    2f90:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  chMtxUnlock();
    2f94:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  return 0;
}
    2f98:	80 e0       	ldi	r24, 0x00	; 0
    2f9a:	90 e0       	ldi	r25, 0x00	; 0
    2f9c:	1f 91       	pop	r17
    2f9e:	0f 91       	pop	r16
    2fa0:	08 95       	ret

00002fa2 <thread11>:
  chCondInit(&c1);
  chMtxInit(&m1);
  chMtxInit(&m2);
}

static msg_t thread11(void *p) {
    2fa2:	0f 93       	push	r16
    2fa4:	1f 93       	push	r17
    2fa6:	8c 01       	movw	r16, r24

  chMtxLock(&m2);
    2fa8:	85 e4       	ldi	r24, 0x45	; 69
    2faa:	95 e0       	ldi	r25, 0x05	; 5
    2fac:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  chMtxLock(&m1);
    2fb0:	8d e4       	ldi	r24, 0x4D	; 77
    2fb2:	95 e0       	ldi	r25, 0x05	; 5
    2fb4:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
#if CH_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
    2fb8:	81 e4       	ldi	r24, 0x41	; 65
    2fba:	95 e0       	ldi	r25, 0x05	; 5
    2fbc:	6f ef       	ldi	r22, 0xFF	; 255
    2fbe:	7f ef       	ldi	r23, 0xFF	; 255
    2fc0:	0e 94 34 08 	call	0x1068	; 0x1068 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
    2fc4:	f8 01       	movw	r30, r16
    2fc6:	80 81       	ld	r24, Z
    2fc8:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  chMtxUnlock();
    2fcc:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  chMtxUnlock();
    2fd0:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  return 0;
}
    2fd4:	80 e0       	ldi	r24, 0x00	; 0
    2fd6:	90 e0       	ldi	r25, 0x00	; 0
    2fd8:	1f 91       	pop	r17
    2fda:	0f 91       	pop	r16
    2fdc:	08 95       	ret

00002fde <mtx8_setup>:
 * to complete the code coverage.
 */

static void mtx8_setup(void) {

  chCondInit(&c1);
    2fde:	81 e4       	ldi	r24, 0x41	; 65
    2fe0:	95 e0       	ldi	r25, 0x05	; 5
    2fe2:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <chCondInit>
  chMtxInit(&m1);
    2fe6:	8d e4       	ldi	r24, 0x4D	; 77
    2fe8:	95 e0       	ldi	r25, 0x05	; 5
    2fea:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
  chMtxInit(&m2);
    2fee:	85 e4       	ldi	r24, 0x45	; 69
    2ff0:	95 e0       	ldi	r25, 0x05	; 5
    2ff2:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
}
    2ff6:	08 95       	ret

00002ff8 <mtx7_setup>:
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {

  chCondInit(&c1);
    2ff8:	81 e4       	ldi	r24, 0x41	; 65
    2ffa:	95 e0       	ldi	r25, 0x05	; 5
    2ffc:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <chCondInit>
  chMtxInit(&m1);
    3000:	8d e4       	ldi	r24, 0x4D	; 77
    3002:	95 e0       	ldi	r25, 0x05	; 5
    3004:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
}
    3008:	08 95       	ret

0000300a <mtx6_setup>:
 * order regardless of the initial order.
 */

static void mtx6_setup(void) {

  chCondInit(&c1);
    300a:	81 e4       	ldi	r24, 0x41	; 65
    300c:	95 e0       	ldi	r25, 0x05	; 5
    300e:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <chCondInit>
  chMtxInit(&m1);
    3012:	8d e4       	ldi	r24, 0x4D	; 77
    3014:	95 e0       	ldi	r25, 0x05	; 5
    3016:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
}
    301a:	08 95       	ret

0000301c <mtx5_setup>:
 * operation.
 */

static void mtx5_setup(void) {

  chMtxInit(&m1);
    301c:	8d e4       	ldi	r24, 0x4D	; 77
    301e:	95 e0       	ldi	r25, 0x05	; 5
    3020:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
}
    3024:	08 95       	ret

00003026 <mtx4_setup>:
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {

  chMtxInit(&m1);
    3026:	8d e4       	ldi	r24, 0x4D	; 77
    3028:	95 e0       	ldi	r25, 0x05	; 5
    302a:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
  chMtxInit(&m2);
    302e:	85 e4       	ldi	r24, 0x45	; 69
    3030:	95 e0       	ldi	r25, 0x05	; 5
    3032:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
}
    3036:	08 95       	ret

00003038 <mtx3_setup>:
 * @endcode
 */

static void mtx3_setup(void) {

  chMtxInit(&m1); /* Mutex B.*/
    3038:	8d e4       	ldi	r24, 0x4D	; 77
    303a:	95 e0       	ldi	r25, 0x05	; 5
    303c:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
  chMtxInit(&m2); /* Mutex A.*/
    3040:	85 e4       	ldi	r24, 0x45	; 69
    3042:	95 e0       	ldi	r25, 0x05	; 5
    3044:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
}
    3048:	08 95       	ret

0000304a <mtx2_setup>:
 * @endcode
 */

static void mtx2_setup(void) {

  chMtxInit(&m1);
    304a:	8d e4       	ldi	r24, 0x4D	; 77
    304c:	95 e0       	ldi	r25, 0x05	; 5
    304e:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
}
    3052:	08 95       	ret

00003054 <mtx1_setup>:
 * priority order regardless of the initial order.
 */

static void mtx1_setup(void) {

  chMtxInit(&m1);
    3054:	8d e4       	ldi	r24, 0x4D	; 77
    3056:	95 e0       	ldi	r25, 0x05	; 5
    3058:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
}
    305c:	08 95       	ret

0000305e <mtx7_execute>:

  chCondInit(&c1);
  chMtxInit(&m1);
}

static void mtx7_execute(void) {
    305e:	cf 92       	push	r12
    3060:	df 92       	push	r13
    3062:	ff 92       	push	r15
    3064:	0f 93       	push	r16
    3066:	1f 93       	push	r17

  tprio_t prio = chThdGetPriority();
    3068:	e0 91 fe 0b 	lds	r30, 0x0BFE
    306c:	f0 91 ff 0b 	lds	r31, 0x0BFF
    3070:	f4 80       	ldd	r15, Z+4	; 0x04
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
    3072:	f3 94       	inc	r15
    3074:	8b eb       	ldi	r24, 0xBB	; 187
    3076:	c8 2e       	mov	r12, r24
    3078:	87 e1       	ldi	r24, 0x17	; 23
    307a:	d8 2e       	mov	r13, r24
    307c:	80 91 95 02 	lds	r24, 0x0295
    3080:	90 91 96 02 	lds	r25, 0x0296
    3084:	65 e9       	ldi	r22, 0x95	; 149
    3086:	70 e0       	ldi	r23, 0x00	; 0
    3088:	4f 2d       	mov	r20, r15
    308a:	96 01       	movw	r18, r12
    308c:	03 e0       	ldi	r16, 0x03	; 3
    308e:	14 e0       	ldi	r17, 0x04	; 4
    3090:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    3094:	90 93 02 0c 	sts	0x0C02, r25
    3098:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
    309c:	f3 94       	inc	r15
    309e:	80 91 97 02 	lds	r24, 0x0297
    30a2:	90 91 98 02 	lds	r25, 0x0298
    30a6:	65 e9       	ldi	r22, 0x95	; 149
    30a8:	70 e0       	ldi	r23, 0x00	; 0
    30aa:	4f 2d       	mov	r20, r15
    30ac:	96 01       	movw	r18, r12
    30ae:	05 e0       	ldi	r16, 0x05	; 5
    30b0:	14 e0       	ldi	r17, 0x04	; 4
    30b2:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    30b6:	90 93 04 0c 	sts	0x0C04, r25
    30ba:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
    30be:	f3 94       	inc	r15
    30c0:	80 91 99 02 	lds	r24, 0x0299
    30c4:	90 91 9a 02 	lds	r25, 0x029A
    30c8:	65 e9       	ldi	r22, 0x95	; 149
    30ca:	70 e0       	ldi	r23, 0x00	; 0
    30cc:	4f 2d       	mov	r20, r15
    30ce:	96 01       	movw	r18, r12
    30d0:	0b ef       	ldi	r16, 0xFB	; 251
    30d2:	13 e0       	ldi	r17, 0x03	; 3
    30d4:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    30d8:	90 93 06 0c 	sts	0x0C06, r25
    30dc:	80 93 05 0c 	sts	0x0C05, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
    30e0:	f3 94       	inc	r15
    30e2:	80 91 9b 02 	lds	r24, 0x029B
    30e6:	90 91 9c 02 	lds	r25, 0x029C
    30ea:	65 e9       	ldi	r22, 0x95	; 149
    30ec:	70 e0       	ldi	r23, 0x00	; 0
    30ee:	4f 2d       	mov	r20, r15
    30f0:	96 01       	movw	r18, r12
    30f2:	0d ef       	ldi	r16, 0xFD	; 253
    30f4:	13 e0       	ldi	r17, 0x03	; 3
    30f6:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    30fa:	90 93 08 0c 	sts	0x0C08, r25
    30fe:	80 93 07 0c 	sts	0x0C07, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
    3102:	f3 94       	inc	r15
    3104:	80 91 9d 02 	lds	r24, 0x029D
    3108:	90 91 9e 02 	lds	r25, 0x029E
    310c:	65 e9       	ldi	r22, 0x95	; 149
    310e:	70 e0       	ldi	r23, 0x00	; 0
    3110:	4f 2d       	mov	r20, r15
    3112:	96 01       	movw	r18, r12
    3114:	09 ef       	ldi	r16, 0xF9	; 249
    3116:	13 e0       	ldi	r17, 0x03	; 3
    3118:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    311c:	90 93 0a 0c 	sts	0x0C0A, r25
    3120:	80 93 09 0c 	sts	0x0C09, r24
  chCondBroadcast(&c1);
    3124:	81 e4       	ldi	r24, 0x41	; 65
    3126:	95 e0       	ldi	r25, 0x05	; 5
    3128:	0e 94 bd 08 	call	0x117a	; 0x117a <chCondBroadcast>
  test_wait_threads();
    312c:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    3130:	81 e0       	ldi	r24, 0x01	; 1
    3132:	90 e0       	ldi	r25, 0x00	; 0
    3134:	67 e0       	ldi	r22, 0x07	; 7
    3136:	74 e0       	ldi	r23, 0x04	; 4
    3138:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
}
    313c:	1f 91       	pop	r17
    313e:	0f 91       	pop	r16
    3140:	ff 90       	pop	r15
    3142:	df 90       	pop	r13
    3144:	cf 90       	pop	r12
    3146:	08 95       	ret

00003148 <mtx6_execute>:
  test_emit_token(*(char *)p);
  chMtxUnlock();
  return 0;
}

static void mtx6_execute(void) {
    3148:	cf 92       	push	r12
    314a:	df 92       	push	r13
    314c:	ff 92       	push	r15
    314e:	0f 93       	push	r16
    3150:	1f 93       	push	r17

  tprio_t prio = chThdGetPriority();
    3152:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3156:	f0 91 ff 0b 	lds	r31, 0x0BFF
    315a:	f4 80       	ldd	r15, Z+4	; 0x04
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
    315c:	f3 94       	inc	r15
    315e:	9b eb       	ldi	r25, 0xBB	; 187
    3160:	c9 2e       	mov	r12, r25
    3162:	97 e1       	ldi	r25, 0x17	; 23
    3164:	d9 2e       	mov	r13, r25
    3166:	80 91 95 02 	lds	r24, 0x0295
    316a:	90 91 96 02 	lds	r25, 0x0296
    316e:	65 e9       	ldi	r22, 0x95	; 149
    3170:	70 e0       	ldi	r23, 0x00	; 0
    3172:	4f 2d       	mov	r20, r15
    3174:	96 01       	movw	r18, r12
    3176:	03 e0       	ldi	r16, 0x03	; 3
    3178:	14 e0       	ldi	r17, 0x04	; 4
    317a:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    317e:	90 93 02 0c 	sts	0x0C02, r25
    3182:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
    3186:	f3 94       	inc	r15
    3188:	80 91 97 02 	lds	r24, 0x0297
    318c:	90 91 98 02 	lds	r25, 0x0298
    3190:	65 e9       	ldi	r22, 0x95	; 149
    3192:	70 e0       	ldi	r23, 0x00	; 0
    3194:	4f 2d       	mov	r20, r15
    3196:	96 01       	movw	r18, r12
    3198:	05 e0       	ldi	r16, 0x05	; 5
    319a:	14 e0       	ldi	r17, 0x04	; 4
    319c:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    31a0:	90 93 04 0c 	sts	0x0C04, r25
    31a4:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
    31a8:	f3 94       	inc	r15
    31aa:	80 91 99 02 	lds	r24, 0x0299
    31ae:	90 91 9a 02 	lds	r25, 0x029A
    31b2:	65 e9       	ldi	r22, 0x95	; 149
    31b4:	70 e0       	ldi	r23, 0x00	; 0
    31b6:	4f 2d       	mov	r20, r15
    31b8:	96 01       	movw	r18, r12
    31ba:	0b ef       	ldi	r16, 0xFB	; 251
    31bc:	13 e0       	ldi	r17, 0x03	; 3
    31be:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    31c2:	90 93 06 0c 	sts	0x0C06, r25
    31c6:	80 93 05 0c 	sts	0x0C05, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
    31ca:	f3 94       	inc	r15
    31cc:	80 91 9b 02 	lds	r24, 0x029B
    31d0:	90 91 9c 02 	lds	r25, 0x029C
    31d4:	65 e9       	ldi	r22, 0x95	; 149
    31d6:	70 e0       	ldi	r23, 0x00	; 0
    31d8:	4f 2d       	mov	r20, r15
    31da:	96 01       	movw	r18, r12
    31dc:	0d ef       	ldi	r16, 0xFD	; 253
    31de:	13 e0       	ldi	r17, 0x03	; 3
    31e0:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    31e4:	90 93 08 0c 	sts	0x0C08, r25
    31e8:	80 93 07 0c 	sts	0x0C07, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
    31ec:	f3 94       	inc	r15
    31ee:	80 91 9d 02 	lds	r24, 0x029D
    31f2:	90 91 9e 02 	lds	r25, 0x029E
    31f6:	65 e9       	ldi	r22, 0x95	; 149
    31f8:	70 e0       	ldi	r23, 0x00	; 0
    31fa:	4f 2d       	mov	r20, r15
    31fc:	96 01       	movw	r18, r12
    31fe:	09 ef       	ldi	r16, 0xF9	; 249
    3200:	13 e0       	ldi	r17, 0x03	; 3
    3202:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    3206:	90 93 0a 0c 	sts	0x0C0A, r25
    320a:	80 93 09 0c 	sts	0x0C09, r24
  chSysLock();
    320e:	f8 94       	cli
  chCondSignalI(&c1);
    3210:	01 e4       	ldi	r16, 0x41	; 65
    3212:	15 e0       	ldi	r17, 0x05	; 5
    3214:	c8 01       	movw	r24, r16
    3216:	0e 94 a5 08 	call	0x114a	; 0x114a <chCondSignalI>
  chCondSignalI(&c1);
    321a:	c8 01       	movw	r24, r16
    321c:	0e 94 a5 08 	call	0x114a	; 0x114a <chCondSignalI>
  chCondSignalI(&c1);
    3220:	c8 01       	movw	r24, r16
    3222:	0e 94 a5 08 	call	0x114a	; 0x114a <chCondSignalI>
  chCondSignalI(&c1);
    3226:	c8 01       	movw	r24, r16
    3228:	0e 94 a5 08 	call	0x114a	; 0x114a <chCondSignalI>
  chCondSignalI(&c1);
    322c:	c8 01       	movw	r24, r16
    322e:	0e 94 a5 08 	call	0x114a	; 0x114a <chCondSignalI>
  chSchRescheduleS();
    3232:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  chSysUnlock();
    3236:	78 94       	sei
  test_wait_threads();
    3238:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    323c:	81 e0       	ldi	r24, 0x01	; 1
    323e:	90 e0       	ldi	r25, 0x00	; 0
    3240:	67 e0       	ldi	r22, 0x07	; 7
    3242:	74 e0       	ldi	r23, 0x04	; 4
    3244:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
}
    3248:	1f 91       	pop	r17
    324a:	0f 91       	pop	r16
    324c:	ff 90       	pop	r15
    324e:	df 90       	pop	r13
    3250:	cf 90       	pop	r12
    3252:	08 95       	ret

00003254 <mtx1_execute>:
  test_emit_token(*(char *)p);
  chMtxUnlock();
  return 0;
}

static void mtx1_execute(void) {
    3254:	ff 92       	push	r15
    3256:	0f 93       	push	r16
    3258:	1f 93       	push	r17

  tprio_t prio = chThdGetPriority(); /* Because priority inheritance.*/
    325a:	e0 91 fe 0b 	lds	r30, 0x0BFE
    325e:	f0 91 ff 0b 	lds	r31, 0x0BFF
    3262:	f4 80       	ldd	r15, Z+4	; 0x04
  chMtxLock(&m1);
    3264:	8d e4       	ldi	r24, 0x4D	; 77
    3266:	95 e0       	ldi	r25, 0x05	; 5
    3268:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    326c:	4f 2d       	mov	r20, r15
    326e:	4f 5f       	subi	r20, 0xFF	; 255
    3270:	80 91 95 02 	lds	r24, 0x0295
    3274:	90 91 96 02 	lds	r25, 0x0296
    3278:	65 e9       	ldi	r22, 0x95	; 149
    327a:	70 e0       	ldi	r23, 0x00	; 0
    327c:	29 ea       	ldi	r18, 0xA9	; 169
    327e:	37 e1       	ldi	r19, 0x17	; 23
    3280:	03 e0       	ldi	r16, 0x03	; 3
    3282:	14 e0       	ldi	r17, 0x04	; 4
    3284:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    3288:	90 93 02 0c 	sts	0x0C02, r25
    328c:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    3290:	4f 2d       	mov	r20, r15
    3292:	4e 5f       	subi	r20, 0xFE	; 254
    3294:	80 91 97 02 	lds	r24, 0x0297
    3298:	90 91 98 02 	lds	r25, 0x0298
    329c:	65 e9       	ldi	r22, 0x95	; 149
    329e:	70 e0       	ldi	r23, 0x00	; 0
    32a0:	29 ea       	ldi	r18, 0xA9	; 169
    32a2:	37 e1       	ldi	r19, 0x17	; 23
    32a4:	05 e0       	ldi	r16, 0x05	; 5
    32a6:	14 e0       	ldi	r17, 0x04	; 4
    32a8:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    32ac:	90 93 04 0c 	sts	0x0C04, r25
    32b0:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    32b4:	4f 2d       	mov	r20, r15
    32b6:	4d 5f       	subi	r20, 0xFD	; 253
    32b8:	80 91 99 02 	lds	r24, 0x0299
    32bc:	90 91 9a 02 	lds	r25, 0x029A
    32c0:	65 e9       	ldi	r22, 0x95	; 149
    32c2:	70 e0       	ldi	r23, 0x00	; 0
    32c4:	29 ea       	ldi	r18, 0xA9	; 169
    32c6:	37 e1       	ldi	r19, 0x17	; 23
    32c8:	0b ef       	ldi	r16, 0xFB	; 251
    32ca:	13 e0       	ldi	r17, 0x03	; 3
    32cc:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    32d0:	90 93 06 0c 	sts	0x0C06, r25
    32d4:	80 93 05 0c 	sts	0x0C05, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
    32d8:	4f 2d       	mov	r20, r15
    32da:	4c 5f       	subi	r20, 0xFC	; 252
    32dc:	80 91 9b 02 	lds	r24, 0x029B
    32e0:	90 91 9c 02 	lds	r25, 0x029C
    32e4:	65 e9       	ldi	r22, 0x95	; 149
    32e6:	70 e0       	ldi	r23, 0x00	; 0
    32e8:	29 ea       	ldi	r18, 0xA9	; 169
    32ea:	37 e1       	ldi	r19, 0x17	; 23
    32ec:	0d ef       	ldi	r16, 0xFD	; 253
    32ee:	13 e0       	ldi	r17, 0x03	; 3
    32f0:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    32f4:	90 93 08 0c 	sts	0x0C08, r25
    32f8:	80 93 07 0c 	sts	0x0C07, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
    32fc:	4f 2d       	mov	r20, r15
    32fe:	4b 5f       	subi	r20, 0xFB	; 251
    3300:	80 91 9d 02 	lds	r24, 0x029D
    3304:	90 91 9e 02 	lds	r25, 0x029E
    3308:	65 e9       	ldi	r22, 0x95	; 149
    330a:	70 e0       	ldi	r23, 0x00	; 0
    330c:	29 ea       	ldi	r18, 0xA9	; 169
    330e:	37 e1       	ldi	r19, 0x17	; 23
    3310:	09 ef       	ldi	r16, 0xF9	; 249
    3312:	13 e0       	ldi	r17, 0x03	; 3
    3314:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    3318:	90 93 0a 0c 	sts	0x0C0A, r25
    331c:	80 93 09 0c 	sts	0x0C09, r24
  chMtxUnlock();
    3320:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  test_wait_threads();
    3324:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_assert(1, prio == chThdGetPriority(), "wrong priority level");
    3328:	60 e0       	ldi	r22, 0x00	; 0
    332a:	e0 91 fe 0b 	lds	r30, 0x0BFE
    332e:	f0 91 ff 0b 	lds	r31, 0x0BFF
    3332:	84 81       	ldd	r24, Z+4	; 0x04
    3334:	8f 15       	cp	r24, r15
    3336:	81 f0       	breq	.+32     	; 0x3358 <mtx1_execute+0x104>
    3338:	81 e0       	ldi	r24, 0x01	; 1
    333a:	90 e0       	ldi	r25, 0x00	; 0
    333c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3340:	88 23       	and	r24, r24
    3342:	31 f4       	brne	.+12     	; 0x3350 <mtx1_execute+0xfc>
  test_assert_sequence(2, "ABCDE");
    3344:	82 e0       	ldi	r24, 0x02	; 2
    3346:	90 e0       	ldi	r25, 0x00	; 0
    3348:	67 e0       	ldi	r22, 0x07	; 7
    334a:	74 e0       	ldi	r23, 0x04	; 4
    334c:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
}
    3350:	1f 91       	pop	r17
    3352:	0f 91       	pop	r16
    3354:	ff 90       	pop	r15
    3356:	08 95       	ret
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock();
  test_wait_threads();
  test_assert(1, prio == chThdGetPriority(), "wrong priority level");
    3358:	61 e0       	ldi	r22, 0x01	; 1
    335a:	ee cf       	rjmp	.-36     	; 0x3338 <mtx1_execute+0xe4>

0000335c <mtx5_execute>:
static void mtx5_setup(void) {

  chMtxInit(&m1);
}

static void mtx5_execute(void) {
    335c:	1f 93       	push	r17
  bool_t b;
  tprio_t prio;

  prio = chThdGetPriority();
    335e:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3362:	f0 91 ff 0b 	lds	r31, 0x0BFF
    3366:	14 81       	ldd	r17, Z+4	; 0x04

  b = chMtxTryLock(&m1);
    3368:	8d e4       	ldi	r24, 0x4D	; 77
    336a:	95 e0       	ldi	r25, 0x05	; 5
    336c:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <chMtxTryLock>
    3370:	68 2f       	mov	r22, r24
  test_assert(1, b, "already locked");
    3372:	81 e0       	ldi	r24, 0x01	; 1
    3374:	90 e0       	ldi	r25, 0x00	; 0
    3376:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    337a:	88 23       	and	r24, r24
    337c:	11 f0       	breq	.+4      	; 0x3382 <mtx5_execute+0x26>
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, isempty(&m1.m_queue), "queue not empty");
  test_assert(7, m1.m_owner == NULL, "still owned");
}
    337e:	1f 91       	pop	r17
    3380:	08 95       	ret
  prio = chThdGetPriority();

  b = chMtxTryLock(&m1);
  test_assert(1, b, "already locked");

  b = chMtxTryLock(&m1);
    3382:	8d e4       	ldi	r24, 0x4D	; 77
    3384:	95 e0       	ldi	r25, 0x05	; 5
    3386:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <chMtxTryLock>
  test_assert(2, !b, "not locked");
    338a:	60 e0       	ldi	r22, 0x00	; 0
    338c:	88 23       	and	r24, r24
    338e:	09 f4       	brne	.+2      	; 0x3392 <mtx5_execute+0x36>
    3390:	5a c0       	rjmp	.+180    	; 0x3446 <mtx5_execute+0xea>
    3392:	82 e0       	ldi	r24, 0x02	; 2
    3394:	90 e0       	ldi	r25, 0x00	; 0
    3396:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    339a:	88 23       	and	r24, r24
    339c:	81 f7       	brne	.-32     	; 0x337e <mtx5_execute+0x22>

  chSysLock();
    339e:	f8 94       	cli
  chMtxUnlockS();
    33a0:	0e 94 31 06 	call	0xc62	; 0xc62 <chMtxUnlockS>
  chSysUnlock();
    33a4:	78 94       	sei

  test_assert(3, isempty(&m1.m_queue), "queue not empty");
    33a6:	60 e0       	ldi	r22, 0x00	; 0
    33a8:	80 91 4d 05 	lds	r24, 0x054D
    33ac:	90 91 4e 05 	lds	r25, 0x054E
    33b0:	8d 54       	subi	r24, 0x4D	; 77
    33b2:	95 40       	sbci	r25, 0x05	; 5
    33b4:	09 f4       	brne	.+2      	; 0x33b8 <mtx5_execute+0x5c>
    33b6:	50 c0       	rjmp	.+160    	; 0x3458 <mtx5_execute+0xfc>
    33b8:	83 e0       	ldi	r24, 0x03	; 3
    33ba:	90 e0       	ldi	r25, 0x00	; 0
    33bc:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    33c0:	88 23       	and	r24, r24
    33c2:	e9 f6       	brne	.-70     	; 0x337e <mtx5_execute+0x22>
  test_assert(4, m1.m_owner == NULL, "still owned");
    33c4:	60 e0       	ldi	r22, 0x00	; 0
    33c6:	80 91 51 05 	lds	r24, 0x0551
    33ca:	90 91 52 05 	lds	r25, 0x0552
    33ce:	89 2b       	or	r24, r25
    33d0:	09 f4       	brne	.+2      	; 0x33d4 <mtx5_execute+0x78>
    33d2:	61 e0       	ldi	r22, 0x01	; 1
    33d4:	84 e0       	ldi	r24, 0x04	; 4
    33d6:	90 e0       	ldi	r25, 0x00	; 0
    33d8:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    33dc:	88 23       	and	r24, r24
    33de:	79 f6       	brne	.-98     	; 0x337e <mtx5_execute+0x22>
  test_assert(5, chThdGetPriority() == prio, "wrong priority level");
    33e0:	60 e0       	ldi	r22, 0x00	; 0
    33e2:	e0 91 fe 0b 	lds	r30, 0x0BFE
    33e6:	f0 91 ff 0b 	lds	r31, 0x0BFF
    33ea:	84 81       	ldd	r24, Z+4	; 0x04
    33ec:	81 17       	cp	r24, r17
    33ee:	b1 f1       	breq	.+108    	; 0x345c <mtx5_execute+0x100>
    33f0:	85 e0       	ldi	r24, 0x05	; 5
    33f2:	90 e0       	ldi	r25, 0x00	; 0
    33f4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    33f8:	88 23       	and	r24, r24
    33fa:	09 f0       	breq	.+2      	; 0x33fe <mtx5_execute+0xa2>
    33fc:	c0 cf       	rjmp	.-128    	; 0x337e <mtx5_execute+0x22>
  
  chMtxLock(&m1);
    33fe:	8d e4       	ldi	r24, 0x4D	; 77
    3400:	95 e0       	ldi	r25, 0x05	; 5
    3402:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  chMtxUnlockAll();
    3406:	0e 94 7d 06 	call	0xcfa	; 0xcfa <chMtxUnlockAll>
  test_assert(6, isempty(&m1.m_queue), "queue not empty");
    340a:	60 e0       	ldi	r22, 0x00	; 0
    340c:	20 91 4d 05 	lds	r18, 0x054D
    3410:	30 91 4e 05 	lds	r19, 0x054E
    3414:	8d e4       	ldi	r24, 0x4D	; 77
    3416:	95 e0       	ldi	r25, 0x05	; 5
    3418:	82 17       	cp	r24, r18
    341a:	93 07       	cpc	r25, r19
    341c:	09 f1       	breq	.+66     	; 0x3460 <mtx5_execute+0x104>
    341e:	86 e0       	ldi	r24, 0x06	; 6
    3420:	90 e0       	ldi	r25, 0x00	; 0
    3422:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3426:	88 23       	and	r24, r24
    3428:	09 f0       	breq	.+2      	; 0x342c <mtx5_execute+0xd0>
    342a:	a9 cf       	rjmp	.-174    	; 0x337e <mtx5_execute+0x22>
  test_assert(7, m1.m_owner == NULL, "still owned");
    342c:	60 e0       	ldi	r22, 0x00	; 0
    342e:	80 91 51 05 	lds	r24, 0x0551
    3432:	90 91 52 05 	lds	r25, 0x0552
    3436:	89 2b       	or	r24, r25
    3438:	09 f4       	brne	.+2      	; 0x343c <mtx5_execute+0xe0>
    343a:	61 e0       	ldi	r22, 0x01	; 1
    343c:	87 e0       	ldi	r24, 0x07	; 7
    343e:	90 e0       	ldi	r25, 0x00	; 0
    3440:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3444:	9c cf       	rjmp	.-200    	; 0x337e <mtx5_execute+0x22>

  b = chMtxTryLock(&m1);
  test_assert(1, b, "already locked");

  b = chMtxTryLock(&m1);
  test_assert(2, !b, "not locked");
    3446:	61 e0       	ldi	r22, 0x01	; 1
    3448:	82 e0       	ldi	r24, 0x02	; 2
    344a:	90 e0       	ldi	r25, 0x00	; 0
    344c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3450:	88 23       	and	r24, r24
    3452:	09 f0       	breq	.+2      	; 0x3456 <mtx5_execute+0xfa>
    3454:	94 cf       	rjmp	.-216    	; 0x337e <mtx5_execute+0x22>
    3456:	a3 cf       	rjmp	.-186    	; 0x339e <mtx5_execute+0x42>

  chSysLock();
  chMtxUnlockS();
  chSysUnlock();

  test_assert(3, isempty(&m1.m_queue), "queue not empty");
    3458:	61 e0       	ldi	r22, 0x01	; 1
    345a:	ae cf       	rjmp	.-164    	; 0x33b8 <mtx5_execute+0x5c>
  test_assert(4, m1.m_owner == NULL, "still owned");
  test_assert(5, chThdGetPriority() == prio, "wrong priority level");
    345c:	61 e0       	ldi	r22, 0x01	; 1
    345e:	c8 cf       	rjmp	.-112    	; 0x33f0 <mtx5_execute+0x94>
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, isempty(&m1.m_queue), "queue not empty");
    3460:	61 e0       	ldi	r22, 0x01	; 1
    3462:	dd cf       	rjmp	.-70     	; 0x341e <mtx5_execute+0xc2>

00003464 <mtx4_execute>:
  chMtxLock(&m1);
  chMtxUnlock();
  return 0;
}

static void mtx4_execute(void) {
    3464:	bf 92       	push	r11
    3466:	cf 92       	push	r12
    3468:	df 92       	push	r13
    346a:	ef 92       	push	r14
    346c:	ff 92       	push	r15
    346e:	0f 93       	push	r16
    3470:	1f 93       	push	r17
    3472:	cf 93       	push	r28
    3474:	df 93       	push	r29
  tprio_t p, p1, p2;

  p = chThdGetPriority();
    3476:	e0 91 fe 0b 	lds	r30, 0x0BFE
    347a:	f0 91 ff 0b 	lds	r31, 0x0BFF
    347e:	f4 80       	ldd	r15, Z+4	; 0x04
  p1 = p + 1;
    3480:	ef 2c       	mov	r14, r15
    3482:	e3 94       	inc	r14
  p2 = p + 2;
    3484:	22 e0       	ldi	r18, 0x02	; 2
    3486:	b2 2e       	mov	r11, r18
    3488:	bf 0c       	add	r11, r15
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
    348a:	c0 90 95 02 	lds	r12, 0x0295
    348e:	d0 90 96 02 	lds	r13, 0x0296
    3492:	c6 01       	movw	r24, r12
    3494:	65 e9       	ldi	r22, 0x95	; 149
    3496:	70 e0       	ldi	r23, 0x00	; 0
    3498:	4e 2d       	mov	r20, r14
    349a:	20 ec       	ldi	r18, 0xC0	; 192
    349c:	3b e1       	ldi	r19, 0x1B	; 27
    349e:	0d ef       	ldi	r16, 0xFD	; 253
    34a0:	13 e0       	ldi	r17, 0x03	; 3
    34a2:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    34a6:	90 93 02 0c 	sts	0x0C02, r25
    34aa:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
    34ae:	c0 91 97 02 	lds	r28, 0x0297
    34b2:	d0 91 98 02 	lds	r29, 0x0298
    34b6:	ce 01       	movw	r24, r28
    34b8:	65 e9       	ldi	r22, 0x95	; 149
    34ba:	70 e0       	ldi	r23, 0x00	; 0
    34bc:	4b 2d       	mov	r20, r11
    34be:	23 eb       	ldi	r18, 0xB3	; 179
    34c0:	3b e1       	ldi	r19, 0x1B	; 27
    34c2:	09 ef       	ldi	r16, 0xF9	; 249
    34c4:	13 e0       	ldi	r17, 0x03	; 3
    34c6:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    34ca:	90 93 04 0c 	sts	0x0C04, r25
    34ce:	80 93 03 0c 	sts	0x0C03, r24
  chMtxLock(&m2);
    34d2:	85 e4       	ldi	r24, 0x45	; 69
    34d4:	95 e0       	ldi	r25, 0x05	; 5
    34d6:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_assert(1, chThdGetPriority() == p, "wrong priority level");
    34da:	60 e0       	ldi	r22, 0x00	; 0
    34dc:	e0 91 fe 0b 	lds	r30, 0x0BFE
    34e0:	f0 91 ff 0b 	lds	r31, 0x0BFF
    34e4:	84 81       	ldd	r24, Z+4	; 0x04
    34e6:	8f 15       	cp	r24, r15
    34e8:	09 f4       	brne	.+2      	; 0x34ec <mtx4_execute+0x88>
    34ea:	2d c1       	rjmp	.+602    	; 0x3746 <mtx4_execute+0x2e2>
    34ec:	81 e0       	ldi	r24, 0x01	; 1
    34ee:	90 e0       	ldi	r25, 0x00	; 0
    34f0:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    34f4:	88 23       	and	r24, r24
    34f6:	51 f0       	breq	.+20     	; 0x350c <mtx4_execute+0xa8>
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriority() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriority() == p, "wrong priority level");
  test_wait_threads();
}
    34f8:	df 91       	pop	r29
    34fa:	cf 91       	pop	r28
    34fc:	1f 91       	pop	r17
    34fe:	0f 91       	pop	r16
    3500:	ff 90       	pop	r15
    3502:	ef 90       	pop	r14
    3504:	df 90       	pop	r13
    3506:	cf 90       	pop	r12
    3508:	bf 90       	pop	r11
    350a:	08 95       	ret
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
  chMtxLock(&m2);
  test_assert(1, chThdGetPriority() == p, "wrong priority level");
  chThdSleepMilliseconds(100);
    350c:	84 e6       	ldi	r24, 0x64	; 100
    350e:	90 e0       	ldi	r25, 0x00	; 0
    3510:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_assert(2, chThdGetPriority() == p1, "wrong priority level");
    3514:	60 e0       	ldi	r22, 0x00	; 0
    3516:	e0 91 fe 0b 	lds	r30, 0x0BFE
    351a:	f0 91 ff 0b 	lds	r31, 0x0BFF
    351e:	84 81       	ldd	r24, Z+4	; 0x04
    3520:	8e 15       	cp	r24, r14
    3522:	09 f4       	brne	.+2      	; 0x3526 <mtx4_execute+0xc2>
    3524:	12 c1       	rjmp	.+548    	; 0x374a <mtx4_execute+0x2e6>
    3526:	82 e0       	ldi	r24, 0x02	; 2
    3528:	90 e0       	ldi	r25, 0x00	; 0
    352a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    352e:	88 23       	and	r24, r24
    3530:	19 f7       	brne	.-58     	; 0x34f8 <mtx4_execute+0x94>
  chMtxLock(&m1);
    3532:	8d e4       	ldi	r24, 0x4D	; 77
    3534:	95 e0       	ldi	r25, 0x05	; 5
    3536:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_assert(3, chThdGetPriority() == p1, "wrong priority level");
    353a:	60 e0       	ldi	r22, 0x00	; 0
    353c:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3540:	f0 91 ff 0b 	lds	r31, 0x0BFF
    3544:	84 81       	ldd	r24, Z+4	; 0x04
    3546:	8e 15       	cp	r24, r14
    3548:	09 f4       	brne	.+2      	; 0x354c <mtx4_execute+0xe8>
    354a:	01 c1       	rjmp	.+514    	; 0x374e <mtx4_execute+0x2ea>
    354c:	83 e0       	ldi	r24, 0x03	; 3
    354e:	90 e0       	ldi	r25, 0x00	; 0
    3550:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3554:	88 23       	and	r24, r24
    3556:	81 f6       	brne	.-96     	; 0x34f8 <mtx4_execute+0x94>
  chThdSleepMilliseconds(100);
    3558:	84 e6       	ldi	r24, 0x64	; 100
    355a:	90 e0       	ldi	r25, 0x00	; 0
    355c:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_assert(4, chThdGetPriority() == p2, "wrong priority level");
    3560:	60 e0       	ldi	r22, 0x00	; 0
    3562:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3566:	f0 91 ff 0b 	lds	r31, 0x0BFF
    356a:	84 81       	ldd	r24, Z+4	; 0x04
    356c:	8b 15       	cp	r24, r11
    356e:	09 f4       	brne	.+2      	; 0x3572 <mtx4_execute+0x10e>
    3570:	f0 c0       	rjmp	.+480    	; 0x3752 <mtx4_execute+0x2ee>
    3572:	84 e0       	ldi	r24, 0x04	; 4
    3574:	90 e0       	ldi	r25, 0x00	; 0
    3576:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    357a:	88 23       	and	r24, r24
    357c:	09 f0       	breq	.+2      	; 0x3580 <mtx4_execute+0x11c>
    357e:	bc cf       	rjmp	.-136    	; 0x34f8 <mtx4_execute+0x94>
  chMtxUnlock();
    3580:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  test_assert(5, chThdGetPriority() == p1, "wrong priority level");
    3584:	60 e0       	ldi	r22, 0x00	; 0
    3586:	e0 91 fe 0b 	lds	r30, 0x0BFE
    358a:	f0 91 ff 0b 	lds	r31, 0x0BFF
    358e:	84 81       	ldd	r24, Z+4	; 0x04
    3590:	8e 15       	cp	r24, r14
    3592:	09 f4       	brne	.+2      	; 0x3596 <mtx4_execute+0x132>
    3594:	e0 c0       	rjmp	.+448    	; 0x3756 <mtx4_execute+0x2f2>
    3596:	85 e0       	ldi	r24, 0x05	; 5
    3598:	90 e0       	ldi	r25, 0x00	; 0
    359a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    359e:	88 23       	and	r24, r24
    35a0:	09 f0       	breq	.+2      	; 0x35a4 <mtx4_execute+0x140>
    35a2:	aa cf       	rjmp	.-172    	; 0x34f8 <mtx4_execute+0x94>
  chThdSleepMilliseconds(100);
    35a4:	84 e6       	ldi	r24, 0x64	; 100
    35a6:	90 e0       	ldi	r25, 0x00	; 0
    35a8:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_assert(6, chThdGetPriority() == p1, "wrong priority level");
    35ac:	60 e0       	ldi	r22, 0x00	; 0
    35ae:	e0 91 fe 0b 	lds	r30, 0x0BFE
    35b2:	f0 91 ff 0b 	lds	r31, 0x0BFF
    35b6:	84 81       	ldd	r24, Z+4	; 0x04
    35b8:	8e 15       	cp	r24, r14
    35ba:	09 f4       	brne	.+2      	; 0x35be <mtx4_execute+0x15a>
    35bc:	ce c0       	rjmp	.+412    	; 0x375a <mtx4_execute+0x2f6>
    35be:	86 e0       	ldi	r24, 0x06	; 6
    35c0:	90 e0       	ldi	r25, 0x00	; 0
    35c2:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    35c6:	88 23       	and	r24, r24
    35c8:	09 f0       	breq	.+2      	; 0x35cc <mtx4_execute+0x168>
    35ca:	96 cf       	rjmp	.-212    	; 0x34f8 <mtx4_execute+0x94>
  chMtxUnlockAll();
    35cc:	0e 94 7d 06 	call	0xcfa	; 0xcfa <chMtxUnlockAll>
  test_assert(7, chThdGetPriority() == p, "wrong priority level");
    35d0:	60 e0       	ldi	r22, 0x00	; 0
    35d2:	e0 91 fe 0b 	lds	r30, 0x0BFE
    35d6:	f0 91 ff 0b 	lds	r31, 0x0BFF
    35da:	84 81       	ldd	r24, Z+4	; 0x04
    35dc:	8f 15       	cp	r24, r15
    35de:	09 f4       	brne	.+2      	; 0x35e2 <mtx4_execute+0x17e>
    35e0:	be c0       	rjmp	.+380    	; 0x375e <mtx4_execute+0x2fa>
    35e2:	87 e0       	ldi	r24, 0x07	; 7
    35e4:	90 e0       	ldi	r25, 0x00	; 0
    35e6:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    35ea:	88 23       	and	r24, r24
    35ec:	09 f0       	breq	.+2      	; 0x35f0 <mtx4_execute+0x18c>
    35ee:	84 cf       	rjmp	.-248    	; 0x34f8 <mtx4_execute+0x94>
  test_wait_threads();
    35f0:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
    35f4:	c6 01       	movw	r24, r12
    35f6:	65 e9       	ldi	r22, 0x95	; 149
    35f8:	70 e0       	ldi	r23, 0x00	; 0
    35fa:	4e 2d       	mov	r20, r14
    35fc:	20 ec       	ldi	r18, 0xC0	; 192
    35fe:	3b e1       	ldi	r19, 0x1B	; 27
    3600:	05 e0       	ldi	r16, 0x05	; 5
    3602:	14 e0       	ldi	r17, 0x04	; 4
    3604:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    3608:	90 93 02 0c 	sts	0x0C02, r25
    360c:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
    3610:	ce 01       	movw	r24, r28
    3612:	65 e9       	ldi	r22, 0x95	; 149
    3614:	70 e0       	ldi	r23, 0x00	; 0
    3616:	4b 2d       	mov	r20, r11
    3618:	23 eb       	ldi	r18, 0xB3	; 179
    361a:	3b e1       	ldi	r19, 0x1B	; 27
    361c:	0b ef       	ldi	r16, 0xFB	; 251
    361e:	13 e0       	ldi	r17, 0x03	; 3
    3620:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    3624:	90 93 04 0c 	sts	0x0C04, r25
    3628:	80 93 03 0c 	sts	0x0C03, r24
  chMtxLock(&m2);
    362c:	85 e4       	ldi	r24, 0x45	; 69
    362e:	95 e0       	ldi	r25, 0x05	; 5
    3630:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_assert(8, chThdGetPriority() == p, "wrong priority level");
    3634:	60 e0       	ldi	r22, 0x00	; 0
    3636:	e0 91 fe 0b 	lds	r30, 0x0BFE
    363a:	f0 91 ff 0b 	lds	r31, 0x0BFF
    363e:	84 81       	ldd	r24, Z+4	; 0x04
    3640:	8f 15       	cp	r24, r15
    3642:	09 f4       	brne	.+2      	; 0x3646 <mtx4_execute+0x1e2>
    3644:	61 e0       	ldi	r22, 0x01	; 1
    3646:	88 e0       	ldi	r24, 0x08	; 8
    3648:	90 e0       	ldi	r25, 0x00	; 0
    364a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    364e:	88 23       	and	r24, r24
    3650:	09 f0       	breq	.+2      	; 0x3654 <mtx4_execute+0x1f0>
    3652:	52 cf       	rjmp	.-348    	; 0x34f8 <mtx4_execute+0x94>
  chThdSleepMilliseconds(100);
    3654:	84 e6       	ldi	r24, 0x64	; 100
    3656:	90 e0       	ldi	r25, 0x00	; 0
    3658:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_assert(9, chThdGetPriority() == p1, "wrong priority level");
    365c:	60 e0       	ldi	r22, 0x00	; 0
    365e:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3662:	f0 91 ff 0b 	lds	r31, 0x0BFF
    3666:	84 81       	ldd	r24, Z+4	; 0x04
    3668:	8e 15       	cp	r24, r14
    366a:	09 f4       	brne	.+2      	; 0x366e <mtx4_execute+0x20a>
    366c:	61 e0       	ldi	r22, 0x01	; 1
    366e:	89 e0       	ldi	r24, 0x09	; 9
    3670:	90 e0       	ldi	r25, 0x00	; 0
    3672:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3676:	88 23       	and	r24, r24
    3678:	09 f0       	breq	.+2      	; 0x367c <mtx4_execute+0x218>
    367a:	3e cf       	rjmp	.-388    	; 0x34f8 <mtx4_execute+0x94>
  chMtxLock(&m1);
    367c:	8d e4       	ldi	r24, 0x4D	; 77
    367e:	95 e0       	ldi	r25, 0x05	; 5
    3680:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_assert(10, chThdGetPriority() == p1, "wrong priority level");
    3684:	60 e0       	ldi	r22, 0x00	; 0
    3686:	e0 91 fe 0b 	lds	r30, 0x0BFE
    368a:	f0 91 ff 0b 	lds	r31, 0x0BFF
    368e:	84 81       	ldd	r24, Z+4	; 0x04
    3690:	8e 15       	cp	r24, r14
    3692:	09 f4       	brne	.+2      	; 0x3696 <mtx4_execute+0x232>
    3694:	66 c0       	rjmp	.+204    	; 0x3762 <mtx4_execute+0x2fe>
    3696:	8a e0       	ldi	r24, 0x0A	; 10
    3698:	90 e0       	ldi	r25, 0x00	; 0
    369a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    369e:	88 23       	and	r24, r24
    36a0:	09 f0       	breq	.+2      	; 0x36a4 <mtx4_execute+0x240>
    36a2:	2a cf       	rjmp	.-428    	; 0x34f8 <mtx4_execute+0x94>
  chThdSleepMilliseconds(100);
    36a4:	84 e6       	ldi	r24, 0x64	; 100
    36a6:	90 e0       	ldi	r25, 0x00	; 0
    36a8:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_assert(11, chThdGetPriority() == p2, "wrong priority level");
    36ac:	60 e0       	ldi	r22, 0x00	; 0
    36ae:	e0 91 fe 0b 	lds	r30, 0x0BFE
    36b2:	f0 91 ff 0b 	lds	r31, 0x0BFF
    36b6:	84 81       	ldd	r24, Z+4	; 0x04
    36b8:	8b 15       	cp	r24, r11
    36ba:	09 f4       	brne	.+2      	; 0x36be <mtx4_execute+0x25a>
    36bc:	61 e0       	ldi	r22, 0x01	; 1
    36be:	8b e0       	ldi	r24, 0x0B	; 11
    36c0:	90 e0       	ldi	r25, 0x00	; 0
    36c2:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    36c6:	88 23       	and	r24, r24
    36c8:	09 f0       	breq	.+2      	; 0x36cc <mtx4_execute+0x268>
    36ca:	16 cf       	rjmp	.-468    	; 0x34f8 <mtx4_execute+0x94>
  chSysLock();
    36cc:	f8 94       	cli
  chMtxUnlockS();
    36ce:	0e 94 31 06 	call	0xc62	; 0xc62 <chMtxUnlockS>
  chSysUnlock();
    36d2:	78 94       	sei
  test_assert(12, chThdGetPriority() == p1, "wrong priority level");
    36d4:	60 e0       	ldi	r22, 0x00	; 0
    36d6:	e0 91 fe 0b 	lds	r30, 0x0BFE
    36da:	f0 91 ff 0b 	lds	r31, 0x0BFF
    36de:	84 81       	ldd	r24, Z+4	; 0x04
    36e0:	8e 15       	cp	r24, r14
    36e2:	09 f4       	brne	.+2      	; 0x36e6 <mtx4_execute+0x282>
    36e4:	61 e0       	ldi	r22, 0x01	; 1
    36e6:	8c e0       	ldi	r24, 0x0C	; 12
    36e8:	90 e0       	ldi	r25, 0x00	; 0
    36ea:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    36ee:	88 23       	and	r24, r24
    36f0:	09 f0       	breq	.+2      	; 0x36f4 <mtx4_execute+0x290>
    36f2:	02 cf       	rjmp	.-508    	; 0x34f8 <mtx4_execute+0x94>
  chThdSleepMilliseconds(100);
    36f4:	84 e6       	ldi	r24, 0x64	; 100
    36f6:	90 e0       	ldi	r25, 0x00	; 0
    36f8:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_assert(13, chThdGetPriority() == p1, "wrong priority level");
    36fc:	60 e0       	ldi	r22, 0x00	; 0
    36fe:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3702:	f0 91 ff 0b 	lds	r31, 0x0BFF
    3706:	84 81       	ldd	r24, Z+4	; 0x04
    3708:	8e 15       	cp	r24, r14
    370a:	09 f4       	brne	.+2      	; 0x370e <mtx4_execute+0x2aa>
    370c:	61 e0       	ldi	r22, 0x01	; 1
    370e:	8d e0       	ldi	r24, 0x0D	; 13
    3710:	90 e0       	ldi	r25, 0x00	; 0
    3712:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3716:	88 23       	and	r24, r24
    3718:	09 f0       	breq	.+2      	; 0x371c <mtx4_execute+0x2b8>
    371a:	ee ce       	rjmp	.-548    	; 0x34f8 <mtx4_execute+0x94>
  chMtxUnlockAll();
    371c:	0e 94 7d 06 	call	0xcfa	; 0xcfa <chMtxUnlockAll>
  test_assert(14, chThdGetPriority() == p, "wrong priority level");
    3720:	60 e0       	ldi	r22, 0x00	; 0
    3722:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3726:	f0 91 ff 0b 	lds	r31, 0x0BFF
    372a:	84 81       	ldd	r24, Z+4	; 0x04
    372c:	8f 15       	cp	r24, r15
    372e:	09 f4       	brne	.+2      	; 0x3732 <mtx4_execute+0x2ce>
    3730:	61 e0       	ldi	r22, 0x01	; 1
    3732:	8e e0       	ldi	r24, 0x0E	; 14
    3734:	90 e0       	ldi	r25, 0x00	; 0
    3736:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    373a:	88 23       	and	r24, r24
    373c:	09 f0       	breq	.+2      	; 0x3740 <mtx4_execute+0x2dc>
    373e:	dc ce       	rjmp	.-584    	; 0x34f8 <mtx4_execute+0x94>
  test_wait_threads();
    3740:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
    3744:	d9 ce       	rjmp	.-590    	; 0x34f8 <mtx4_execute+0x94>
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
  chMtxLock(&m2);
  test_assert(1, chThdGetPriority() == p, "wrong priority level");
    3746:	61 e0       	ldi	r22, 0x01	; 1
    3748:	d1 ce       	rjmp	.-606    	; 0x34ec <mtx4_execute+0x88>
  chThdSleepMilliseconds(100);
  test_assert(2, chThdGetPriority() == p1, "wrong priority level");
    374a:	61 e0       	ldi	r22, 0x01	; 1
    374c:	ec ce       	rjmp	.-552    	; 0x3526 <mtx4_execute+0xc2>
  chMtxLock(&m1);
  test_assert(3, chThdGetPriority() == p1, "wrong priority level");
    374e:	61 e0       	ldi	r22, 0x01	; 1
    3750:	fd ce       	rjmp	.-518    	; 0x354c <mtx4_execute+0xe8>
  chThdSleepMilliseconds(100);
  test_assert(4, chThdGetPriority() == p2, "wrong priority level");
    3752:	61 e0       	ldi	r22, 0x01	; 1
    3754:	0e cf       	rjmp	.-484    	; 0x3572 <mtx4_execute+0x10e>
  chMtxUnlock();
  test_assert(5, chThdGetPriority() == p1, "wrong priority level");
    3756:	61 e0       	ldi	r22, 0x01	; 1
    3758:	1e cf       	rjmp	.-452    	; 0x3596 <mtx4_execute+0x132>
  chThdSleepMilliseconds(100);
  test_assert(6, chThdGetPriority() == p1, "wrong priority level");
    375a:	61 e0       	ldi	r22, 0x01	; 1
    375c:	30 cf       	rjmp	.-416    	; 0x35be <mtx4_execute+0x15a>
  chMtxUnlockAll();
  test_assert(7, chThdGetPriority() == p, "wrong priority level");
    375e:	61 e0       	ldi	r22, 0x01	; 1
    3760:	40 cf       	rjmp	.-384    	; 0x35e2 <mtx4_execute+0x17e>
  chMtxLock(&m2);
  test_assert(8, chThdGetPriority() == p, "wrong priority level");
  chThdSleepMilliseconds(100);
  test_assert(9, chThdGetPriority() == p1, "wrong priority level");
  chMtxLock(&m1);
  test_assert(10, chThdGetPriority() == p1, "wrong priority level");
    3762:	61 e0       	ldi	r22, 0x01	; 1
    3764:	98 cf       	rjmp	.-208    	; 0x3696 <mtx4_execute+0x232>

00003766 <thread4b>:
}

static msg_t thread4b(void *p) {

  (void)p;
  chThdSleepMilliseconds(150);
    3766:	86 e9       	ldi	r24, 0x96	; 150
    3768:	90 e0       	ldi	r25, 0x00	; 0
    376a:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  chMtxLock(&m1);
    376e:	8d e4       	ldi	r24, 0x4D	; 77
    3770:	95 e0       	ldi	r25, 0x05	; 5
    3772:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  chMtxUnlock();
    3776:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  return 0;
}
    377a:	80 e0       	ldi	r24, 0x00	; 0
    377c:	90 e0       	ldi	r25, 0x00	; 0
    377e:	08 95       	ret

00003780 <thread4a>:
}

static msg_t thread4a(void *p) {

  (void)p;
  chThdSleepMilliseconds(50);
    3780:	82 e3       	ldi	r24, 0x32	; 50
    3782:	90 e0       	ldi	r25, 0x00	; 0
    3784:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  chMtxLock(&m2);
    3788:	85 e4       	ldi	r24, 0x45	; 69
    378a:	95 e0       	ldi	r25, 0x05	; 5
    378c:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  chMtxUnlock();
    3790:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  return 0;
}
    3794:	80 e0       	ldi	r24, 0x00	; 0
    3796:	90 e0       	ldi	r25, 0x00	; 0
    3798:	08 95       	ret

0000379a <mtx3_execute>:
  chMtxUnlock();
  test_emit_token('A');
  return 0;
}

static void mtx3_execute(void) {
    379a:	0f 93       	push	r16
    379c:	1f 93       	push	r17
    379e:	cf 93       	push	r28
    37a0:	df 93       	push	r29
  systime_t time;

  test_wait_tick();
    37a2:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  time = chTimeNow();
    37a6:	c0 91 f1 0b 	lds	r28, 0x0BF1
    37aa:	d0 91 f2 0b 	lds	r29, 0x0BF2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-5, thread3LL, 0);
    37ae:	e0 91 fe 0b 	lds	r30, 0x0BFE
    37b2:	f0 91 ff 0b 	lds	r31, 0x0BFF
    37b6:	44 81       	ldd	r20, Z+4	; 0x04
    37b8:	45 50       	subi	r20, 0x05	; 5
    37ba:	80 91 95 02 	lds	r24, 0x0295
    37be:	90 91 96 02 	lds	r25, 0x0296
    37c2:	65 e9       	ldi	r22, 0x95	; 149
    37c4:	70 e0       	ldi	r23, 0x00	; 0
    37c6:	2f e0       	ldi	r18, 0x0F	; 15
    37c8:	3d e1       	ldi	r19, 0x1D	; 29
    37ca:	00 e0       	ldi	r16, 0x00	; 0
    37cc:	10 e0       	ldi	r17, 0x00	; 0
    37ce:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    37d2:	90 93 02 0c 	sts	0x0C02, r25
    37d6:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-4, thread3L, 0);
    37da:	e0 91 fe 0b 	lds	r30, 0x0BFE
    37de:	f0 91 ff 0b 	lds	r31, 0x0BFF
    37e2:	44 81       	ldd	r20, Z+4	; 0x04
    37e4:	44 50       	subi	r20, 0x04	; 4
    37e6:	80 91 97 02 	lds	r24, 0x0297
    37ea:	90 91 98 02 	lds	r25, 0x0298
    37ee:	65 e9       	ldi	r22, 0x95	; 149
    37f0:	70 e0       	ldi	r23, 0x00	; 0
    37f2:	2d ee       	ldi	r18, 0xED	; 237
    37f4:	3c e1       	ldi	r19, 0x1C	; 28
    37f6:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    37fa:	90 93 04 0c 	sts	0x0C04, r25
    37fe:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread3M, 0);
    3802:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3806:	f0 91 ff 0b 	lds	r31, 0x0BFF
    380a:	44 81       	ldd	r20, Z+4	; 0x04
    380c:	43 50       	subi	r20, 0x03	; 3
    380e:	80 91 99 02 	lds	r24, 0x0299
    3812:	90 91 9a 02 	lds	r25, 0x029A
    3816:	65 e9       	ldi	r22, 0x95	; 149
    3818:	70 e0       	ldi	r23, 0x00	; 0
    381a:	29 ed       	ldi	r18, 0xD9	; 217
    381c:	3c e1       	ldi	r19, 0x1C	; 28
    381e:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    3822:	90 93 06 0c 	sts	0x0C06, r25
    3826:	80 93 05 0c 	sts	0x0C05, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-2, thread3H, 0);
    382a:	e0 91 fe 0b 	lds	r30, 0x0BFE
    382e:	f0 91 ff 0b 	lds	r31, 0x0BFF
    3832:	44 81       	ldd	r20, Z+4	; 0x04
    3834:	42 50       	subi	r20, 0x02	; 2
    3836:	80 91 9b 02 	lds	r24, 0x029B
    383a:	90 91 9c 02 	lds	r25, 0x029C
    383e:	65 e9       	ldi	r22, 0x95	; 149
    3840:	70 e0       	ldi	r23, 0x00	; 0
    3842:	2b ec       	ldi	r18, 0xCB	; 203
    3844:	3c e1       	ldi	r19, 0x1C	; 28
    3846:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    384a:	90 93 08 0c 	sts	0x0C08, r25
    384e:	80 93 07 0c 	sts	0x0C07, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread3HH, 0);
    3852:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3856:	f0 91 ff 0b 	lds	r31, 0x0BFF
    385a:	44 81       	ldd	r20, Z+4	; 0x04
    385c:	41 50       	subi	r20, 0x01	; 1
    385e:	80 91 9d 02 	lds	r24, 0x029D
    3862:	90 91 9e 02 	lds	r25, 0x029E
    3866:	65 e9       	ldi	r22, 0x95	; 149
    3868:	70 e0       	ldi	r23, 0x00	; 0
    386a:	27 eb       	ldi	r18, 0xB7	; 183
    386c:	3c e1       	ldi	r19, 0x1C	; 28
    386e:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    3872:	90 93 0a 0c 	sts	0x0C0A, r25
    3876:	80 93 09 0c 	sts	0x0C09, r24
  test_wait_threads();
    387a:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    387e:	81 e0       	ldi	r24, 0x01	; 1
    3880:	90 e0       	ldi	r25, 0x00	; 0
    3882:	67 e0       	ldi	r22, 0x07	; 7
    3884:	74 e0       	ldi	r23, 0x04	; 4
    3886:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
    388a:	88 23       	and	r24, r24
    388c:	51 f4       	brne	.+20     	; 0x38a2 <mtx3_execute+0x108>
  test_assert_time_window(2, time + MS2ST(110), time + MS2ST(110) + ALLOWED_DELAY);
    388e:	ae 01       	movw	r20, r28
    3890:	4d 58       	subi	r20, 0x8D	; 141
    3892:	5f 4f       	sbci	r21, 0xFF	; 255
    3894:	82 e0       	ldi	r24, 0x02	; 2
    3896:	90 e0       	ldi	r25, 0x00	; 0
    3898:	c2 59       	subi	r28, 0x92	; 146
    389a:	df 4f       	sbci	r29, 0xFF	; 255
    389c:	be 01       	movw	r22, r28
    389e:	0e 94 de 11 	call	0x23bc	; 0x23bc <_test_assert_time_window>
}
    38a2:	df 91       	pop	r29
    38a4:	cf 91       	pop	r28
    38a6:	1f 91       	pop	r17
    38a8:	0f 91       	pop	r16
    38aa:	08 95       	ret

000038ac <mtx2_execute>:
  chMtxUnlock();
  test_emit_token('A');
  return 0;
}

static void mtx2_execute(void) {
    38ac:	0f 93       	push	r16
    38ae:	1f 93       	push	r17
    38b0:	cf 93       	push	r28
    38b2:	df 93       	push	r29
  systime_t time;

  test_wait_tick();
    38b4:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  time = chTimeNow();
    38b8:	c0 91 f1 0b 	lds	r28, 0x0BF1
    38bc:	d0 91 f2 0b 	lds	r29, 0x0BF2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-1, thread2H, 0);
    38c0:	e0 91 fe 0b 	lds	r30, 0x0BFE
    38c4:	f0 91 ff 0b 	lds	r31, 0x0BFF
    38c8:	44 81       	ldd	r20, Z+4	; 0x04
    38ca:	41 50       	subi	r20, 0x01	; 1
    38cc:	80 91 95 02 	lds	r24, 0x0295
    38d0:	90 91 96 02 	lds	r25, 0x0296
    38d4:	65 e9       	ldi	r22, 0x95	; 149
    38d6:	70 e0       	ldi	r23, 0x00	; 0
    38d8:	21 e4       	ldi	r18, 0x41	; 65
    38da:	3d e1       	ldi	r19, 0x1D	; 29
    38dc:	00 e0       	ldi	r16, 0x00	; 0
    38de:	10 e0       	ldi	r17, 0x00	; 0
    38e0:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    38e4:	90 93 02 0c 	sts	0x0C02, r25
    38e8:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-2, thread2M, 0);
    38ec:	e0 91 fe 0b 	lds	r30, 0x0BFE
    38f0:	f0 91 ff 0b 	lds	r31, 0x0BFF
    38f4:	44 81       	ldd	r20, Z+4	; 0x04
    38f6:	42 50       	subi	r20, 0x02	; 2
    38f8:	80 91 97 02 	lds	r24, 0x0297
    38fc:	90 91 98 02 	lds	r25, 0x0298
    3900:	65 e9       	ldi	r22, 0x95	; 149
    3902:	70 e0       	ldi	r23, 0x00	; 0
    3904:	23 e3       	ldi	r18, 0x33	; 51
    3906:	3d e1       	ldi	r19, 0x1D	; 29
    3908:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    390c:	90 93 04 0c 	sts	0x0C04, r25
    3910:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread2L, 0);
    3914:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3918:	f0 91 ff 0b 	lds	r31, 0x0BFF
    391c:	44 81       	ldd	r20, Z+4	; 0x04
    391e:	43 50       	subi	r20, 0x03	; 3
    3920:	80 91 99 02 	lds	r24, 0x0299
    3924:	90 91 9a 02 	lds	r25, 0x029A
    3928:	65 e9       	ldi	r22, 0x95	; 149
    392a:	70 e0       	ldi	r23, 0x00	; 0
    392c:	2f e1       	ldi	r18, 0x1F	; 31
    392e:	3d e1       	ldi	r19, 0x1D	; 29
    3930:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    3934:	90 93 06 0c 	sts	0x0C06, r25
    3938:	80 93 05 0c 	sts	0x0C05, r24
  test_wait_threads();
    393c:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_assert_sequence(1, "ABC");
    3940:	81 e0       	ldi	r24, 0x01	; 1
    3942:	90 e0       	ldi	r25, 0x00	; 0
    3944:	6f ef       	ldi	r22, 0xFF	; 255
    3946:	73 e0       	ldi	r23, 0x03	; 3
    3948:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
    394c:	88 23       	and	r24, r24
    394e:	51 f4       	brne	.+20     	; 0x3964 <mtx2_execute+0xb8>
  test_assert_time_window(2, time + MS2ST(100), time + MS2ST(100) + ALLOWED_DELAY);
    3950:	ae 01       	movw	r20, r28
    3952:	47 59       	subi	r20, 0x97	; 151
    3954:	5f 4f       	sbci	r21, 0xFF	; 255
    3956:	82 e0       	ldi	r24, 0x02	; 2
    3958:	90 e0       	ldi	r25, 0x00	; 0
    395a:	cc 59       	subi	r28, 0x9C	; 156
    395c:	df 4f       	sbci	r29, 0xFF	; 255
    395e:	be 01       	movw	r22, r28
    3960:	0e 94 de 11 	call	0x23bc	; 0x23bc <_test_assert_time_window>
}
    3964:	df 91       	pop	r29
    3966:	cf 91       	pop	r28
    3968:	1f 91       	pop	r17
    396a:	0f 91       	pop	r16
    396c:	08 95       	ret

0000396e <thread3HH>:

/* Highest priority thread */
static msg_t thread3HH(void *p) {

  (void)p;
  chThdSleepMilliseconds(50);
    396e:	82 e3       	ldi	r24, 0x32	; 50
    3970:	90 e0       	ldi	r25, 0x00	; 0
    3972:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  chMtxLock(&m2);
    3976:	85 e4       	ldi	r24, 0x45	; 69
    3978:	95 e0       	ldi	r25, 0x05	; 5
    397a:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_cpu_pulse(10);
    397e:	8a e0       	ldi	r24, 0x0A	; 10
    3980:	90 e0       	ldi	r25, 0x00	; 0
    3982:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  chMtxUnlock();
    3986:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  test_emit_token('A');
    398a:	81 e4       	ldi	r24, 0x41	; 65
    398c:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  return 0;
}
    3990:	80 e0       	ldi	r24, 0x00	; 0
    3992:	90 e0       	ldi	r25, 0x00	; 0
    3994:	08 95       	ret

00003996 <thread3H>:

/* High priority thread */
static msg_t thread3H(void *p) {

  (void)p;
  chThdSleepMilliseconds(40);
    3996:	88 e2       	ldi	r24, 0x28	; 40
    3998:	90 e0       	ldi	r25, 0x00	; 0
    399a:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_cpu_pulse(20);
    399e:	84 e1       	ldi	r24, 0x14	; 20
    39a0:	90 e0       	ldi	r25, 0x00	; 0
    39a2:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  test_emit_token('B');
    39a6:	82 e4       	ldi	r24, 0x42	; 66
    39a8:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  return 0;
}
    39ac:	80 e0       	ldi	r24, 0x00	; 0
    39ae:	90 e0       	ldi	r25, 0x00	; 0
    39b0:	08 95       	ret

000039b2 <thread3M>:

/* Medium priority thread */
static msg_t thread3M(void *p) {

  (void)p;
  chThdSleepMilliseconds(20);
    39b2:	84 e1       	ldi	r24, 0x14	; 20
    39b4:	90 e0       	ldi	r25, 0x00	; 0
    39b6:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  chMtxLock(&m2);
    39ba:	85 e4       	ldi	r24, 0x45	; 69
    39bc:	95 e0       	ldi	r25, 0x05	; 5
    39be:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_cpu_pulse(10);
    39c2:	8a e0       	ldi	r24, 0x0A	; 10
    39c4:	90 e0       	ldi	r25, 0x00	; 0
    39c6:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  chMtxUnlock();
    39ca:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  test_emit_token('C');
    39ce:	83 e4       	ldi	r24, 0x43	; 67
    39d0:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  return 0;
}
    39d4:	80 e0       	ldi	r24, 0x00	; 0
    39d6:	90 e0       	ldi	r25, 0x00	; 0
    39d8:	08 95       	ret

000039da <thread3L>:

/* Low priority thread */
static msg_t thread3L(void *p) {

  (void)p;
  chThdSleepMilliseconds(10);
    39da:	8a e0       	ldi	r24, 0x0A	; 10
    39dc:	90 e0       	ldi	r25, 0x00	; 0
    39de:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  chMtxLock(&m2);
    39e2:	85 e4       	ldi	r24, 0x45	; 69
    39e4:	95 e0       	ldi	r25, 0x05	; 5
    39e6:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_cpu_pulse(20);
    39ea:	84 e1       	ldi	r24, 0x14	; 20
    39ec:	90 e0       	ldi	r25, 0x00	; 0
    39ee:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  chMtxLock(&m1);
    39f2:	8d e4       	ldi	r24, 0x4D	; 77
    39f4:	95 e0       	ldi	r25, 0x05	; 5
    39f6:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_cpu_pulse(10);
    39fa:	8a e0       	ldi	r24, 0x0A	; 10
    39fc:	90 e0       	ldi	r25, 0x00	; 0
    39fe:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  chMtxUnlock();
    3a02:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  test_cpu_pulse(10);
    3a06:	8a e0       	ldi	r24, 0x0A	; 10
    3a08:	90 e0       	ldi	r25, 0x00	; 0
    3a0a:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  chMtxUnlock();
    3a0e:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  test_emit_token('D');
    3a12:	84 e4       	ldi	r24, 0x44	; 68
    3a14:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  return 0;
}
    3a18:	80 e0       	ldi	r24, 0x00	; 0
    3a1a:	90 e0       	ldi	r25, 0x00	; 0
    3a1c:	08 95       	ret

00003a1e <thread3LL>:

/* Lowest priority thread */
static msg_t thread3LL(void *p) {

  (void)p;
  chMtxLock(&m1);
    3a1e:	8d e4       	ldi	r24, 0x4D	; 77
    3a20:	95 e0       	ldi	r25, 0x05	; 5
    3a22:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_cpu_pulse(30);
    3a26:	8e e1       	ldi	r24, 0x1E	; 30
    3a28:	90 e0       	ldi	r25, 0x00	; 0
    3a2a:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  chMtxUnlock();
    3a2e:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  test_emit_token('E');
    3a32:	85 e4       	ldi	r24, 0x45	; 69
    3a34:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  return 0;
}
    3a38:	80 e0       	ldi	r24, 0x00	; 0
    3a3a:	90 e0       	ldi	r25, 0x00	; 0
    3a3c:	08 95       	ret

00003a3e <thread2L>:

/* Low priority thread */
static msg_t thread2L(void *p) {

  (void)p;
  chMtxLock(&m1);
    3a3e:	8d e4       	ldi	r24, 0x4D	; 77
    3a40:	95 e0       	ldi	r25, 0x05	; 5
    3a42:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_cpu_pulse(40);
    3a46:	88 e2       	ldi	r24, 0x28	; 40
    3a48:	90 e0       	ldi	r25, 0x00	; 0
    3a4a:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  chMtxUnlock();
    3a4e:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  test_cpu_pulse(10);
    3a52:	8a e0       	ldi	r24, 0x0A	; 10
    3a54:	90 e0       	ldi	r25, 0x00	; 0
    3a56:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  test_emit_token('C');
    3a5a:	83 e4       	ldi	r24, 0x43	; 67
    3a5c:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  return 0;
}
    3a60:	80 e0       	ldi	r24, 0x00	; 0
    3a62:	90 e0       	ldi	r25, 0x00	; 0
    3a64:	08 95       	ret

00003a66 <thread2M>:

/* Medium priority thread */
static msg_t thread2M(void *p) {

  (void)p;
  chThdSleepMilliseconds(20);
    3a66:	84 e1       	ldi	r24, 0x14	; 20
    3a68:	90 e0       	ldi	r25, 0x00	; 0
    3a6a:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_cpu_pulse(40);
    3a6e:	88 e2       	ldi	r24, 0x28	; 40
    3a70:	90 e0       	ldi	r25, 0x00	; 0
    3a72:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  test_emit_token('B');
    3a76:	82 e4       	ldi	r24, 0x42	; 66
    3a78:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  return 0;
}
    3a7c:	80 e0       	ldi	r24, 0x00	; 0
    3a7e:	90 e0       	ldi	r25, 0x00	; 0
    3a80:	08 95       	ret

00003a82 <thread2H>:

/* High priority thread */
static msg_t thread2H(void *p) {

  (void)p;
  chThdSleepMilliseconds(40);
    3a82:	88 e2       	ldi	r24, 0x28	; 40
    3a84:	90 e0       	ldi	r25, 0x00	; 0
    3a86:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  chMtxLock(&m1);
    3a8a:	8d e4       	ldi	r24, 0x4D	; 77
    3a8c:	95 e0       	ldi	r25, 0x05	; 5
    3a8e:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
  test_cpu_pulse(10);
    3a92:	8a e0       	ldi	r24, 0x0A	; 10
    3a94:	90 e0       	ldi	r25, 0x00	; 0
    3a96:	0e 94 05 10 	call	0x200a	; 0x200a <test_cpu_pulse>
  chMtxUnlock();
    3a9a:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
  test_emit_token('A');
    3a9e:	81 e4       	ldi	r24, 0x41	; 65
    3aa0:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  return 0;
}
    3aa4:	80 e0       	ldi	r24, 0x00	; 0
    3aa6:	90 e0       	ldi	r25, 0x00	; 0
    3aa8:	08 95       	ret

00003aaa <msg1_execute>:
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
  return 0;
}

static void msg1_execute(void) {
    3aaa:	0f 93       	push	r16
    3aac:	1f 93       	push	r17
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() + 1,
    3aae:	e0 91 fe 0b 	lds	r30, 0x0BFE
    3ab2:	f0 91 ff 0b 	lds	r31, 0x0BFF
    3ab6:	44 81       	ldd	r20, Z+4	; 0x04
    3ab8:	4f 5f       	subi	r20, 0xFF	; 255
    3aba:	80 91 95 02 	lds	r24, 0x0295
    3abe:	90 91 96 02 	lds	r25, 0x0296
    3ac2:	65 e9       	ldi	r22, 0x95	; 149
    3ac4:	70 e0       	ldi	r23, 0x00	; 0
    3ac6:	26 e9       	ldi	r18, 0x96	; 150
    3ac8:	3d e1       	ldi	r19, 0x1D	; 29
    3aca:	8f 01       	movw	r16, r30
    3acc:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    3ad0:	90 93 02 0c 	sts	0x0C02, r25
    3ad4:	80 93 01 0c 	sts	0x0C01, r24
                                 thread, chThdSelf());
  tp = chMsgWait();
    3ad8:	0e 94 8b 0a 	call	0x1516	; 0x1516 <chMsgWait>
    3adc:	fc 01       	movw	r30, r24
  msg = chMsgGet(tp);
    3ade:	12 8d       	ldd	r17, Z+26	; 0x1a
    3ae0:	73 8d       	ldd	r23, Z+27	; 0x1b
  chMsgRelease(tp, msg);
    3ae2:	61 2f       	mov	r22, r17
    3ae4:	0e 94 86 0a 	call	0x150c	; 0x150c <chMsgRelease>
  test_emit_token(msg);
    3ae8:	81 2f       	mov	r24, r17
    3aea:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  tp = chMsgWait();
    3aee:	0e 94 8b 0a 	call	0x1516	; 0x1516 <chMsgWait>
    3af2:	fc 01       	movw	r30, r24
  msg = chMsgGet(tp);
    3af4:	12 8d       	ldd	r17, Z+26	; 0x1a
    3af6:	73 8d       	ldd	r23, Z+27	; 0x1b
  chMsgRelease(tp, msg);
    3af8:	61 2f       	mov	r22, r17
    3afa:	0e 94 86 0a 	call	0x150c	; 0x150c <chMsgRelease>
  test_emit_token(msg);
    3afe:	81 2f       	mov	r24, r17
    3b00:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  tp = chMsgWait();
    3b04:	0e 94 8b 0a 	call	0x1516	; 0x1516 <chMsgWait>
    3b08:	fc 01       	movw	r30, r24
  msg = chMsgGet(tp);
    3b0a:	12 8d       	ldd	r17, Z+26	; 0x1a
    3b0c:	73 8d       	ldd	r23, Z+27	; 0x1b
  chMsgRelease(tp, msg);
    3b0e:	61 2f       	mov	r22, r17
    3b10:	0e 94 86 0a 	call	0x150c	; 0x150c <chMsgRelease>
  test_emit_token(msg);
    3b14:	81 2f       	mov	r24, r17
    3b16:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  test_assert_sequence(1, "ABC");
    3b1a:	81 e0       	ldi	r24, 0x01	; 1
    3b1c:	90 e0       	ldi	r25, 0x00	; 0
    3b1e:	65 e5       	ldi	r22, 0x55	; 85
    3b20:	75 e0       	ldi	r23, 0x05	; 5
    3b22:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
}
    3b26:	1f 91       	pop	r17
    3b28:	0f 91       	pop	r16
    3b2a:	08 95       	ret

00003b2c <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static msg_t thread(void *p) {
    3b2c:	0f 93       	push	r16
    3b2e:	1f 93       	push	r17
    3b30:	18 2f       	mov	r17, r24
    3b32:	09 2f       	mov	r16, r25

  chMsgSend(p, 'A');
    3b34:	61 e4       	ldi	r22, 0x41	; 65
    3b36:	70 e0       	ldi	r23, 0x00	; 0
    3b38:	0e 94 b5 0a 	call	0x156a	; 0x156a <chMsgSend>
  chMsgSend(p, 'B');
    3b3c:	81 2f       	mov	r24, r17
    3b3e:	90 2f       	mov	r25, r16
    3b40:	62 e4       	ldi	r22, 0x42	; 66
    3b42:	70 e0       	ldi	r23, 0x00	; 0
    3b44:	0e 94 b5 0a 	call	0x156a	; 0x156a <chMsgSend>
  chMsgSend(p, 'C');
    3b48:	81 2f       	mov	r24, r17
    3b4a:	90 2f       	mov	r25, r16
    3b4c:	63 e4       	ldi	r22, 0x43	; 67
    3b4e:	70 e0       	ldi	r23, 0x00	; 0
    3b50:	0e 94 b5 0a 	call	0x156a	; 0x156a <chMsgSend>
  return 0;
}
    3b54:	80 e0       	ldi	r24, 0x00	; 0
    3b56:	90 e0       	ldi	r25, 0x00	; 0
    3b58:	1f 91       	pop	r17
    3b5a:	0f 91       	pop	r16
    3b5c:	08 95       	ret

00003b5e <mbox1_execute>:
static void mbox1_setup(void) {

  chMBInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}

static void mbox1_execute(void) {
    3b5e:	ef 92       	push	r14
    3b60:	ff 92       	push	r15
    3b62:	0f 93       	push	r16
    3b64:	1f 93       	push	r17
    3b66:	df 93       	push	r29
    3b68:	cf 93       	push	r28
    3b6a:	00 d0       	rcall	.+0      	; 0x3b6c <mbox1_execute+0xe>
    3b6c:	cd b7       	in	r28, 0x3d	; 61
    3b6e:	de b7       	in	r29, 0x3e	; 62
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
    3b70:	60 e0       	ldi	r22, 0x00	; 0
    3b72:	80 91 b7 05 	lds	r24, 0x05B7
    3b76:	85 30       	cpi	r24, 0x05	; 5
    3b78:	c9 f1       	breq	.+114    	; 0x3bec <mbox1_execute+0x8e>
    3b7a:	81 e0       	ldi	r24, 0x01	; 1
    3b7c:	90 e0       	ldi	r25, 0x00	; 0
    3b7e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3b82:	88 23       	and	r24, r24
    3b84:	51 f5       	brne	.+84     	; 0x3bda <mbox1_execute+0x7c>
    3b86:	02 e4       	ldi	r16, 0x42	; 66
    3b88:	10 e0       	ldi	r17, 0x00	; 0

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    3b8a:	86 ea       	ldi	r24, 0xA6	; 166
    3b8c:	95 e0       	ldi	r25, 0x05	; 5
    3b8e:	b8 01       	movw	r22, r16
    3b90:	4f ef       	ldi	r20, 0xFF	; 255
    3b92:	5f ef       	ldi	r21, 0xFF	; 255
    3b94:	0e 94 12 0c 	call	0x1824	; 0x1824 <chMBPost>
    test_assert(2, msg1 == RDY_OK, "wrong wake-up message");
    3b98:	60 e0       	ldi	r22, 0x00	; 0
    3b9a:	89 2b       	or	r24, r25
    3b9c:	09 f4       	brne	.+2      	; 0x3ba0 <mbox1_execute+0x42>
    3b9e:	61 e0       	ldi	r22, 0x01	; 1
    3ba0:	82 e0       	ldi	r24, 0x02	; 2
    3ba2:	90 e0       	ldi	r25, 0x00	; 0
    3ba4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3ba8:	88 23       	and	r24, r24
    3baa:	b9 f4       	brne	.+46     	; 0x3bda <mbox1_execute+0x7c>
    3bac:	0f 5f       	subi	r16, 0xFF	; 255
    3bae:	1f 4f       	sbci	r17, 0xFF	; 255
  test_assert(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    3bb0:	06 34       	cpi	r16, 0x46	; 70
    3bb2:	11 05       	cpc	r17, r1
    3bb4:	51 f7       	brne	.-44     	; 0x3b8a <mbox1_execute+0x2c>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == RDY_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
    3bb6:	86 ea       	ldi	r24, 0xA6	; 166
    3bb8:	95 e0       	ldi	r25, 0x05	; 5
    3bba:	61 e4       	ldi	r22, 0x41	; 65
    3bbc:	70 e0       	ldi	r23, 0x00	; 0
    3bbe:	4f ef       	ldi	r20, 0xFF	; 255
    3bc0:	5f ef       	ldi	r21, 0xFF	; 255
    3bc2:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <chMBPostAhead>
  test_assert(3, msg1 == RDY_OK, "wrong wake-up message");
    3bc6:	60 e0       	ldi	r22, 0x00	; 0
    3bc8:	89 2b       	or	r24, r25
    3bca:	09 f4       	brne	.+2      	; 0x3bce <mbox1_execute+0x70>
    3bcc:	61 e0       	ldi	r22, 0x01	; 1
    3bce:	83 e0       	ldi	r24, 0x03	; 3
    3bd0:	90 e0       	ldi	r25, 0x00	; 0
    3bd2:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3bd6:	88 23       	and	r24, r24
    3bd8:	59 f0       	breq	.+22     	; 0x3bf0 <mbox1_execute+0x92>
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
}
    3bda:	0f 90       	pop	r0
    3bdc:	0f 90       	pop	r0
    3bde:	cf 91       	pop	r28
    3be0:	df 91       	pop	r29
    3be2:	1f 91       	pop	r17
    3be4:	0f 91       	pop	r16
    3be6:	ff 90       	pop	r15
    3be8:	ef 90       	pop	r14
    3bea:	08 95       	ret
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
    3bec:	61 e0       	ldi	r22, 0x01	; 1
    3bee:	c5 cf       	rjmp	.-118    	; 0x3b7a <mbox1_execute+0x1c>
  test_assert(3, msg1 == RDY_OK, "wrong wake-up message");

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
    3bf0:	86 ea       	ldi	r24, 0xA6	; 166
    3bf2:	95 e0       	ldi	r25, 0x05	; 5
    3bf4:	68 e5       	ldi	r22, 0x58	; 88
    3bf6:	70 e0       	ldi	r23, 0x00	; 0
    3bf8:	41 e0       	ldi	r20, 0x01	; 1
    3bfa:	50 e0       	ldi	r21, 0x00	; 0
    3bfc:	0e 94 12 0c 	call	0x1824	; 0x1824 <chMBPost>
  test_assert(4, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3c00:	60 e0       	ldi	r22, 0x00	; 0
    3c02:	8f 5f       	subi	r24, 0xFF	; 255
    3c04:	9f 4f       	sbci	r25, 0xFF	; 255
    3c06:	09 f4       	brne	.+2      	; 0x3c0a <mbox1_execute+0xac>
    3c08:	50 c0       	rjmp	.+160    	; 0x3caa <mbox1_execute+0x14c>
    3c0a:	84 e0       	ldi	r24, 0x04	; 4
    3c0c:	90 e0       	ldi	r25, 0x00	; 0
    3c0e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3c12:	88 23       	and	r24, r24
    3c14:	11 f7       	brne	.-60     	; 0x3bda <mbox1_execute+0x7c>
  chSysLock();
    3c16:	f8 94       	cli
  msg1 = chMBPostI(&mb1, 'X');
    3c18:	86 ea       	ldi	r24, 0xA6	; 166
    3c1a:	95 e0       	ldi	r25, 0x05	; 5
    3c1c:	68 e5       	ldi	r22, 0x58	; 88
    3c1e:	70 e0       	ldi	r23, 0x00	; 0
    3c20:	0e 94 4c 0b 	call	0x1698	; 0x1698 <chMBPostI>
  chSysUnlock();
    3c24:	78 94       	sei
  test_assert(5, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3c26:	60 e0       	ldi	r22, 0x00	; 0
    3c28:	8f 5f       	subi	r24, 0xFF	; 255
    3c2a:	9f 4f       	sbci	r25, 0xFF	; 255
    3c2c:	09 f4       	brne	.+2      	; 0x3c30 <mbox1_execute+0xd2>
    3c2e:	3b c0       	rjmp	.+118    	; 0x3ca6 <mbox1_execute+0x148>
    3c30:	85 e0       	ldi	r24, 0x05	; 5
    3c32:	90 e0       	ldi	r25, 0x00	; 0
    3c34:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3c38:	88 23       	and	r24, r24
    3c3a:	79 f6       	brne	.-98     	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
    3c3c:	86 ea       	ldi	r24, 0xA6	; 166
    3c3e:	95 e0       	ldi	r25, 0x05	; 5
    3c40:	68 e5       	ldi	r22, 0x58	; 88
    3c42:	70 e0       	ldi	r23, 0x00	; 0
    3c44:	41 e0       	ldi	r20, 0x01	; 1
    3c46:	50 e0       	ldi	r21, 0x00	; 0
    3c48:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <chMBPostAhead>
  test_assert(6, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3c4c:	60 e0       	ldi	r22, 0x00	; 0
    3c4e:	8f 5f       	subi	r24, 0xFF	; 255
    3c50:	9f 4f       	sbci	r25, 0xFF	; 255
    3c52:	69 f1       	breq	.+90     	; 0x3cae <mbox1_execute+0x150>
    3c54:	86 e0       	ldi	r24, 0x06	; 6
    3c56:	90 e0       	ldi	r25, 0x00	; 0
    3c58:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3c5c:	88 23       	and	r24, r24
    3c5e:	09 f0       	breq	.+2      	; 0x3c62 <mbox1_execute+0x104>
    3c60:	bc cf       	rjmp	.-136    	; 0x3bda <mbox1_execute+0x7c>
  chSysLock();
    3c62:	f8 94       	cli
  msg1 = chMBPostAheadI(&mb1, 'X');
    3c64:	86 ea       	ldi	r24, 0xA6	; 166
    3c66:	95 e0       	ldi	r25, 0x05	; 5
    3c68:	68 e5       	ldi	r22, 0x58	; 88
    3c6a:	70 e0       	ldi	r23, 0x00	; 0
    3c6c:	0e 94 1a 0b 	call	0x1634	; 0x1634 <chMBPostAheadI>
  chSysUnlock();
    3c70:	78 94       	sei
  test_assert(7, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3c72:	60 e0       	ldi	r22, 0x00	; 0
    3c74:	8f 5f       	subi	r24, 0xFF	; 255
    3c76:	9f 4f       	sbci	r25, 0xFF	; 255
    3c78:	e1 f0       	breq	.+56     	; 0x3cb2 <mbox1_execute+0x154>
    3c7a:	87 e0       	ldi	r24, 0x07	; 7
    3c7c:	90 e0       	ldi	r25, 0x00	; 0
    3c7e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3c82:	88 23       	and	r24, r24
    3c84:	09 f0       	breq	.+2      	; 0x3c88 <mbox1_execute+0x12a>
    3c86:	a9 cf       	rjmp	.-174    	; 0x3bda <mbox1_execute+0x7c>

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
    3c88:	f8 94       	cli
    3c8a:	60 e0       	ldi	r22, 0x00	; 0
    3c8c:	80 91 b7 05 	lds	r24, 0x05B7
    3c90:	88 23       	and	r24, r24
    3c92:	09 f4       	brne	.+2      	; 0x3c96 <mbox1_execute+0x138>
    3c94:	61 e0       	ldi	r22, 0x01	; 1
    3c96:	88 e0       	ldi	r24, 0x08	; 8
    3c98:	90 e0       	ldi	r25, 0x00	; 0
    3c9a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3c9e:	88 23       	and	r24, r24
    3ca0:	51 f0       	breq	.+20     	; 0x3cb6 <mbox1_execute+0x158>
    3ca2:	78 94       	sei
    3ca4:	9a cf       	rjmp	.-204    	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBPost(&mb1, 'X', 1);
  test_assert(4, msg1 == RDY_TIMEOUT, "wrong wake-up message");
  chSysLock();
  msg1 = chMBPostI(&mb1, 'X');
  chSysUnlock();
  test_assert(5, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3ca6:	61 e0       	ldi	r22, 0x01	; 1
    3ca8:	c3 cf       	rjmp	.-122    	; 0x3c30 <mbox1_execute+0xd2>

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
  test_assert(4, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3caa:	61 e0       	ldi	r22, 0x01	; 1
    3cac:	ae cf       	rjmp	.-164    	; 0x3c0a <mbox1_execute+0xac>
  chSysLock();
  msg1 = chMBPostI(&mb1, 'X');
  chSysUnlock();
  test_assert(5, msg1 == RDY_TIMEOUT, "wrong wake-up message");
  msg1 = chMBPostAhead(&mb1, 'X', 1);
  test_assert(6, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3cae:	61 e0       	ldi	r22, 0x01	; 1
    3cb0:	d1 cf       	rjmp	.-94     	; 0x3c54 <mbox1_execute+0xf6>
  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'X');
  chSysUnlock();
  test_assert(7, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3cb2:	61 e0       	ldi	r22, 0x01	; 1
    3cb4:	e2 cf       	rjmp	.-60     	; 0x3c7a <mbox1_execute+0x11c>

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
    3cb6:	78 94       	sei
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
    3cb8:	f8 94       	cli
    3cba:	60 e0       	ldi	r22, 0x00	; 0
    3cbc:	80 91 b2 05 	lds	r24, 0x05B2
    3cc0:	85 30       	cpi	r24, 0x05	; 5
    3cc2:	09 f4       	brne	.+2      	; 0x3cc6 <mbox1_execute+0x168>
    3cc4:	61 e0       	ldi	r22, 0x01	; 1
    3cc6:	89 e0       	ldi	r24, 0x09	; 9
    3cc8:	90 e0       	ldi	r25, 0x00	; 0
    3cca:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3cce:	88 23       	and	r24, r24
    3cd0:	11 f0       	breq	.+4      	; 0x3cd6 <mbox1_execute+0x178>
    3cd2:	78 94       	sei
    3cd4:	82 cf       	rjmp	.-252    	; 0x3bda <mbox1_execute+0x7c>
    3cd6:	78 94       	sei
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    3cd8:	f8 94       	cli
    3cda:	60 e0       	ldi	r22, 0x00	; 0
    3cdc:	20 91 ac 05 	lds	r18, 0x05AC
    3ce0:	30 91 ad 05 	lds	r19, 0x05AD
    3ce4:	80 91 aa 05 	lds	r24, 0x05AA
    3ce8:	90 91 ab 05 	lds	r25, 0x05AB
    3cec:	28 17       	cp	r18, r24
    3cee:	39 07       	cpc	r19, r25
    3cf0:	09 f4       	brne	.+2      	; 0x3cf4 <mbox1_execute+0x196>
    3cf2:	b5 c0       	rjmp	.+362    	; 0x3e5e <mbox1_execute+0x300>
    3cf4:	8a e0       	ldi	r24, 0x0A	; 10
    3cf6:	90 e0       	ldi	r25, 0x00	; 0
    3cf8:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3cfc:	88 23       	and	r24, r24
    3cfe:	09 f0       	breq	.+2      	; 0x3d02 <mbox1_execute+0x1a4>
    3d00:	ac c0       	rjmp	.+344    	; 0x3e5a <mbox1_execute+0x2fc>
    3d02:	78 94       	sei
    3d04:	00 e0       	ldi	r16, 0x00	; 0
    3d06:	10 e0       	ldi	r17, 0x00	; 0
    3d08:	7e 01       	movw	r14, r28
    3d0a:	08 94       	sec
    3d0c:	e1 1c       	adc	r14, r1
    3d0e:	f1 1c       	adc	r15, r1

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    3d10:	86 ea       	ldi	r24, 0xA6	; 166
    3d12:	95 e0       	ldi	r25, 0x05	; 5
    3d14:	b7 01       	movw	r22, r14
    3d16:	4f ef       	ldi	r20, 0xFF	; 255
    3d18:	5f ef       	ldi	r21, 0xFF	; 255
    3d1a:	0e 94 ab 0b 	call	0x1756	; 0x1756 <chMBFetch>
    test_assert(11, msg1 == RDY_OK, "wrong wake-up message");
    3d1e:	60 e0       	ldi	r22, 0x00	; 0
    3d20:	89 2b       	or	r24, r25
    3d22:	09 f4       	brne	.+2      	; 0x3d26 <mbox1_execute+0x1c8>
    3d24:	61 e0       	ldi	r22, 0x01	; 1
    3d26:	8b e0       	ldi	r24, 0x0B	; 11
    3d28:	90 e0       	ldi	r25, 0x00	; 0
    3d2a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3d2e:	88 23       	and	r24, r24
    3d30:	09 f0       	breq	.+2      	; 0x3d34 <mbox1_execute+0x1d6>
    3d32:	53 cf       	rjmp	.-346    	; 0x3bda <mbox1_execute+0x7c>
    test_emit_token(msg2);
    3d34:	89 81       	ldd	r24, Y+1	; 0x01
    3d36:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    3d3a:	0f 5f       	subi	r16, 0xFF	; 255
    3d3c:	1f 4f       	sbci	r17, 0xFF	; 255
    3d3e:	05 30       	cpi	r16, 0x05	; 5
    3d40:	11 05       	cpc	r17, r1
    3d42:	31 f7       	brne	.-52     	; 0x3d10 <mbox1_execute+0x1b2>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == RDY_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
    3d44:	8c e0       	ldi	r24, 0x0C	; 12
    3d46:	90 e0       	ldi	r25, 0x00	; 0
    3d48:	64 e7       	ldi	r22, 0x74	; 116
    3d4a:	75 e0       	ldi	r23, 0x05	; 5
    3d4c:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
    3d50:	88 23       	and	r24, r24
    3d52:	09 f0       	breq	.+2      	; 0x3d56 <mbox1_execute+0x1f8>
    3d54:	42 cf       	rjmp	.-380    	; 0x3bda <mbox1_execute+0x7c>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    3d56:	86 ea       	ldi	r24, 0xA6	; 166
    3d58:	95 e0       	ldi	r25, 0x05	; 5
    3d5a:	67 e4       	ldi	r22, 0x47	; 71
    3d5c:	70 e0       	ldi	r23, 0x00	; 0
    3d5e:	4f ef       	ldi	r20, 0xFF	; 255
    3d60:	5f ef       	ldi	r21, 0xFF	; 255
    3d62:	0e 94 12 0c 	call	0x1824	; 0x1824 <chMBPost>
  test_assert(13, msg1 == RDY_OK, "wrong wake-up message");
    3d66:	60 e0       	ldi	r22, 0x00	; 0
    3d68:	89 2b       	or	r24, r25
    3d6a:	09 f4       	brne	.+2      	; 0x3d6e <mbox1_execute+0x210>
    3d6c:	61 e0       	ldi	r22, 0x01	; 1
    3d6e:	8d e0       	ldi	r24, 0x0D	; 13
    3d70:	90 e0       	ldi	r25, 0x00	; 0
    3d72:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3d76:	88 23       	and	r24, r24
    3d78:	09 f0       	breq	.+2      	; 0x3d7c <mbox1_execute+0x21e>
    3d7a:	2f cf       	rjmp	.-418    	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    3d7c:	86 ea       	ldi	r24, 0xA6	; 166
    3d7e:	95 e0       	ldi	r25, 0x05	; 5
    3d80:	b7 01       	movw	r22, r14
    3d82:	4f ef       	ldi	r20, 0xFF	; 255
    3d84:	5f ef       	ldi	r21, 0xFF	; 255
    3d86:	0e 94 ab 0b 	call	0x1756	; 0x1756 <chMBFetch>
  test_assert(14, msg1 == RDY_OK, "wrong wake-up message");
    3d8a:	60 e0       	ldi	r22, 0x00	; 0
    3d8c:	89 2b       	or	r24, r25
    3d8e:	09 f4       	brne	.+2      	; 0x3d92 <mbox1_execute+0x234>
    3d90:	61 e0       	ldi	r22, 0x01	; 1
    3d92:	8e e0       	ldi	r24, 0x0E	; 14
    3d94:	90 e0       	ldi	r25, 0x00	; 0
    3d96:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3d9a:	88 23       	and	r24, r24
    3d9c:	09 f0       	breq	.+2      	; 0x3da0 <mbox1_execute+0x242>
    3d9e:	1d cf       	rjmp	.-454    	; 0x3bda <mbox1_execute+0x7c>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
    3da0:	60 e0       	ldi	r22, 0x00	; 0
    3da2:	20 91 a6 05 	lds	r18, 0x05A6
    3da6:	30 91 a7 05 	lds	r19, 0x05A7
    3daa:	80 91 aa 05 	lds	r24, 0x05AA
    3dae:	90 91 ab 05 	lds	r25, 0x05AB
    3db2:	28 17       	cp	r18, r24
    3db4:	39 07       	cpc	r19, r25
    3db6:	09 f4       	brne	.+2      	; 0x3dba <mbox1_execute+0x25c>
    3db8:	61 e0       	ldi	r22, 0x01	; 1
    3dba:	8f e0       	ldi	r24, 0x0F	; 15
    3dbc:	90 e0       	ldi	r25, 0x00	; 0
    3dbe:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3dc2:	88 23       	and	r24, r24
    3dc4:	09 f0       	breq	.+2      	; 0x3dc8 <mbox1_execute+0x26a>
    3dc6:	09 cf       	rjmp	.-494    	; 0x3bda <mbox1_execute+0x7c>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
    3dc8:	60 e0       	ldi	r22, 0x00	; 0
    3dca:	20 91 a6 05 	lds	r18, 0x05A6
    3dce:	30 91 a7 05 	lds	r19, 0x05A7
    3dd2:	80 91 ac 05 	lds	r24, 0x05AC
    3dd6:	90 91 ad 05 	lds	r25, 0x05AD
    3dda:	28 17       	cp	r18, r24
    3ddc:	39 07       	cpc	r19, r25
    3dde:	09 f4       	brne	.+2      	; 0x3de2 <mbox1_execute+0x284>
    3de0:	61 e0       	ldi	r22, 0x01	; 1
    3de2:	80 e1       	ldi	r24, 0x10	; 16
    3de4:	90 e0       	ldi	r25, 0x00	; 0
    3de6:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3dea:	88 23       	and	r24, r24
    3dec:	09 f0       	breq	.+2      	; 0x3df0 <mbox1_execute+0x292>
    3dee:	f5 ce       	rjmp	.-534    	; 0x3bda <mbox1_execute+0x7c>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
    3df0:	86 ea       	ldi	r24, 0xA6	; 166
    3df2:	95 e0       	ldi	r25, 0x05	; 5
    3df4:	b7 01       	movw	r22, r14
    3df6:	41 e0       	ldi	r20, 0x01	; 1
    3df8:	50 e0       	ldi	r21, 0x00	; 0
    3dfa:	0e 94 ab 0b 	call	0x1756	; 0x1756 <chMBFetch>
  test_assert(17, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3dfe:	60 e0       	ldi	r22, 0x00	; 0
    3e00:	8f 5f       	subi	r24, 0xFF	; 255
    3e02:	9f 4f       	sbci	r25, 0xFF	; 255
    3e04:	09 f4       	brne	.+2      	; 0x3e08 <mbox1_execute+0x2aa>
    3e06:	61 e0       	ldi	r22, 0x01	; 1
    3e08:	81 e1       	ldi	r24, 0x11	; 17
    3e0a:	90 e0       	ldi	r25, 0x00	; 0
    3e0c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3e10:	88 23       	and	r24, r24
    3e12:	09 f0       	breq	.+2      	; 0x3e16 <mbox1_execute+0x2b8>
    3e14:	e2 ce       	rjmp	.-572    	; 0x3bda <mbox1_execute+0x7c>
  chSysLock();
    3e16:	f8 94       	cli
  msg1 = chMBFetchI(&mb1, &msg2);
    3e18:	86 ea       	ldi	r24, 0xA6	; 166
    3e1a:	95 e0       	ldi	r25, 0x05	; 5
    3e1c:	b7 01       	movw	r22, r14
    3e1e:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <chMBFetchI>
  chSysUnlock();
    3e22:	78 94       	sei
  test_assert(18, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3e24:	60 e0       	ldi	r22, 0x00	; 0
    3e26:	8f 5f       	subi	r24, 0xFF	; 255
    3e28:	9f 4f       	sbci	r25, 0xFF	; 255
    3e2a:	09 f4       	brne	.+2      	; 0x3e2e <mbox1_execute+0x2d0>
    3e2c:	61 e0       	ldi	r22, 0x01	; 1
    3e2e:	82 e1       	ldi	r24, 0x12	; 18
    3e30:	90 e0       	ldi	r25, 0x00	; 0
    3e32:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3e36:	88 23       	and	r24, r24
    3e38:	09 f0       	breq	.+2      	; 0x3e3c <mbox1_execute+0x2de>
    3e3a:	cf ce       	rjmp	.-610    	; 0x3bda <mbox1_execute+0x7c>

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    3e3c:	f8 94       	cli
    3e3e:	60 e0       	ldi	r22, 0x00	; 0
    3e40:	80 91 b7 05 	lds	r24, 0x05B7
    3e44:	85 30       	cpi	r24, 0x05	; 5
    3e46:	09 f4       	brne	.+2      	; 0x3e4a <mbox1_execute+0x2ec>
    3e48:	61 e0       	ldi	r22, 0x01	; 1
    3e4a:	83 e1       	ldi	r24, 0x13	; 19
    3e4c:	90 e0       	ldi	r25, 0x00	; 0
    3e4e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3e52:	88 23       	and	r24, r24
    3e54:	31 f0       	breq	.+12     	; 0x3e62 <mbox1_execute+0x304>
    3e56:	78 94       	sei
    3e58:	c0 ce       	rjmp	.-640    	; 0x3bda <mbox1_execute+0x7c>
  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    3e5a:	78 94       	sei
    3e5c:	be ce       	rjmp	.-644    	; 0x3bda <mbox1_execute+0x7c>
    3e5e:	61 e0       	ldi	r22, 0x01	; 1
    3e60:	49 cf       	rjmp	.-366    	; 0x3cf4 <mbox1_execute+0x196>
  test_assert(18, msg1 == RDY_TIMEOUT, "wrong wake-up message");

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    3e62:	78 94       	sei
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
    3e64:	f8 94       	cli
    3e66:	60 e0       	ldi	r22, 0x00	; 0
    3e68:	80 91 b2 05 	lds	r24, 0x05B2
    3e6c:	88 23       	and	r24, r24
    3e6e:	09 f4       	brne	.+2      	; 0x3e72 <mbox1_execute+0x314>
    3e70:	61 e0       	ldi	r22, 0x01	; 1
    3e72:	84 e1       	ldi	r24, 0x14	; 20
    3e74:	90 e0       	ldi	r25, 0x00	; 0
    3e76:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3e7a:	88 23       	and	r24, r24
    3e7c:	11 f0       	breq	.+4      	; 0x3e82 <mbox1_execute+0x324>
    3e7e:	78 94       	sei
    3e80:	ac ce       	rjmp	.-680    	; 0x3bda <mbox1_execute+0x7c>
    3e82:	78 94       	sei
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    3e84:	f8 94       	cli
    3e86:	60 e0       	ldi	r22, 0x00	; 0
    3e88:	20 91 ac 05 	lds	r18, 0x05AC
    3e8c:	30 91 ad 05 	lds	r19, 0x05AD
    3e90:	80 91 aa 05 	lds	r24, 0x05AA
    3e94:	90 91 ab 05 	lds	r25, 0x05AB
    3e98:	28 17       	cp	r18, r24
    3e9a:	39 07       	cpc	r19, r25
    3e9c:	09 f4       	brne	.+2      	; 0x3ea0 <mbox1_execute+0x342>
    3e9e:	61 e0       	ldi	r22, 0x01	; 1
    3ea0:	85 e1       	ldi	r24, 0x15	; 21
    3ea2:	90 e0       	ldi	r25, 0x00	; 0
    3ea4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3ea8:	88 23       	and	r24, r24
    3eaa:	11 f0       	breq	.+4      	; 0x3eb0 <mbox1_execute+0x352>
    3eac:	78 94       	sei
    3eae:	95 ce       	rjmp	.-726    	; 0x3bda <mbox1_execute+0x7c>
    3eb0:	78 94       	sei

  /*
   * Testing I-Class.
   */
  chSysLock()
    3eb2:	f8 94       	cli
  msg1 = chMBPostI(&mb1, 'A');
    3eb4:	86 ea       	ldi	r24, 0xA6	; 166
    3eb6:	95 e0       	ldi	r25, 0x05	; 5
    3eb8:	61 e4       	ldi	r22, 0x41	; 65
    3eba:	70 e0       	ldi	r23, 0x00	; 0
    3ebc:	0e 94 4c 0b 	call	0x1698	; 0x1698 <chMBPostI>
  test_assert(22, msg1 == RDY_OK, "wrong wake-up message");
    3ec0:	60 e0       	ldi	r22, 0x00	; 0
    3ec2:	89 2b       	or	r24, r25
    3ec4:	09 f4       	brne	.+2      	; 0x3ec8 <mbox1_execute+0x36a>
    3ec6:	61 e0       	ldi	r22, 0x01	; 1
    3ec8:	86 e1       	ldi	r24, 0x16	; 22
    3eca:	90 e0       	ldi	r25, 0x00	; 0
    3ecc:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3ed0:	88 23       	and	r24, r24
    3ed2:	09 f0       	breq	.+2      	; 0x3ed6 <mbox1_execute+0x378>
    3ed4:	82 ce       	rjmp	.-764    	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBPostI(&mb1, 'B');
    3ed6:	86 ea       	ldi	r24, 0xA6	; 166
    3ed8:	95 e0       	ldi	r25, 0x05	; 5
    3eda:	62 e4       	ldi	r22, 0x42	; 66
    3edc:	70 e0       	ldi	r23, 0x00	; 0
    3ede:	0e 94 4c 0b 	call	0x1698	; 0x1698 <chMBPostI>
  test_assert(23, msg1 == RDY_OK, "wrong wake-up message");
    3ee2:	60 e0       	ldi	r22, 0x00	; 0
    3ee4:	89 2b       	or	r24, r25
    3ee6:	09 f4       	brne	.+2      	; 0x3eea <mbox1_execute+0x38c>
    3ee8:	61 e0       	ldi	r22, 0x01	; 1
    3eea:	87 e1       	ldi	r24, 0x17	; 23
    3eec:	90 e0       	ldi	r25, 0x00	; 0
    3eee:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3ef2:	88 23       	and	r24, r24
    3ef4:	09 f0       	breq	.+2      	; 0x3ef8 <mbox1_execute+0x39a>
    3ef6:	71 ce       	rjmp	.-798    	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBPostI(&mb1, 'C');
    3ef8:	86 ea       	ldi	r24, 0xA6	; 166
    3efa:	95 e0       	ldi	r25, 0x05	; 5
    3efc:	63 e4       	ldi	r22, 0x43	; 67
    3efe:	70 e0       	ldi	r23, 0x00	; 0
    3f00:	0e 94 4c 0b 	call	0x1698	; 0x1698 <chMBPostI>
  test_assert(24, msg1 == RDY_OK, "wrong wake-up message");
    3f04:	60 e0       	ldi	r22, 0x00	; 0
    3f06:	89 2b       	or	r24, r25
    3f08:	09 f4       	brne	.+2      	; 0x3f0c <mbox1_execute+0x3ae>
    3f0a:	61 e0       	ldi	r22, 0x01	; 1
    3f0c:	88 e1       	ldi	r24, 0x18	; 24
    3f0e:	90 e0       	ldi	r25, 0x00	; 0
    3f10:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3f14:	88 23       	and	r24, r24
    3f16:	09 f0       	breq	.+2      	; 0x3f1a <mbox1_execute+0x3bc>
    3f18:	60 ce       	rjmp	.-832    	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBPostI(&mb1, 'D');
    3f1a:	86 ea       	ldi	r24, 0xA6	; 166
    3f1c:	95 e0       	ldi	r25, 0x05	; 5
    3f1e:	64 e4       	ldi	r22, 0x44	; 68
    3f20:	70 e0       	ldi	r23, 0x00	; 0
    3f22:	0e 94 4c 0b 	call	0x1698	; 0x1698 <chMBPostI>
  test_assert(25, msg1 == RDY_OK, "wrong wake-up message");
    3f26:	60 e0       	ldi	r22, 0x00	; 0
    3f28:	89 2b       	or	r24, r25
    3f2a:	09 f4       	brne	.+2      	; 0x3f2e <mbox1_execute+0x3d0>
    3f2c:	61 e0       	ldi	r22, 0x01	; 1
    3f2e:	89 e1       	ldi	r24, 0x19	; 25
    3f30:	90 e0       	ldi	r25, 0x00	; 0
    3f32:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3f36:	88 23       	and	r24, r24
    3f38:	09 f0       	breq	.+2      	; 0x3f3c <mbox1_execute+0x3de>
    3f3a:	4f ce       	rjmp	.-866    	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBPostI(&mb1, 'E');
    3f3c:	86 ea       	ldi	r24, 0xA6	; 166
    3f3e:	95 e0       	ldi	r25, 0x05	; 5
    3f40:	65 e4       	ldi	r22, 0x45	; 69
    3f42:	70 e0       	ldi	r23, 0x00	; 0
    3f44:	0e 94 4c 0b 	call	0x1698	; 0x1698 <chMBPostI>
  chSysUnlock();
    3f48:	78 94       	sei
  test_assert(26, msg1 == RDY_OK, "wrong wake-up message");
    3f4a:	60 e0       	ldi	r22, 0x00	; 0
    3f4c:	89 2b       	or	r24, r25
    3f4e:	09 f4       	brne	.+2      	; 0x3f52 <mbox1_execute+0x3f4>
    3f50:	61 e0       	ldi	r22, 0x01	; 1
    3f52:	8a e1       	ldi	r24, 0x1A	; 26
    3f54:	90 e0       	ldi	r25, 0x00	; 0
    3f56:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3f5a:	88 23       	and	r24, r24
    3f5c:	09 f0       	breq	.+2      	; 0x3f60 <mbox1_execute+0x402>
    3f5e:	3d ce       	rjmp	.-902    	; 0x3bda <mbox1_execute+0x7c>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    3f60:	60 e0       	ldi	r22, 0x00	; 0
    3f62:	20 91 ac 05 	lds	r18, 0x05AC
    3f66:	30 91 ad 05 	lds	r19, 0x05AD
    3f6a:	80 91 aa 05 	lds	r24, 0x05AA
    3f6e:	90 91 ab 05 	lds	r25, 0x05AB
    3f72:	28 17       	cp	r18, r24
    3f74:	39 07       	cpc	r19, r25
    3f76:	09 f4       	brne	.+2      	; 0x3f7a <mbox1_execute+0x41c>
    3f78:	61 e0       	ldi	r22, 0x01	; 1
    3f7a:	8b e1       	ldi	r24, 0x1B	; 27
    3f7c:	90 e0       	ldi	r25, 0x00	; 0
    3f7e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3f82:	88 23       	and	r24, r24
    3f84:	09 f0       	breq	.+2      	; 0x3f88 <mbox1_execute+0x42a>
    3f86:	29 ce       	rjmp	.-942    	; 0x3bda <mbox1_execute+0x7c>
    3f88:	00 e0       	ldi	r16, 0x00	; 0
    3f8a:	10 e0       	ldi	r17, 0x00	; 0
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    3f8c:	f8 94       	cli
    msg1 = chMBFetchI(&mb1, &msg2);
    3f8e:	86 ea       	ldi	r24, 0xA6	; 166
    3f90:	95 e0       	ldi	r25, 0x05	; 5
    3f92:	b7 01       	movw	r22, r14
    3f94:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <chMBFetchI>
    chSysUnlock();
    3f98:	78 94       	sei
    test_assert(28, msg1 == RDY_OK, "wrong wake-up message");
    3f9a:	60 e0       	ldi	r22, 0x00	; 0
    3f9c:	89 2b       	or	r24, r25
    3f9e:	09 f4       	brne	.+2      	; 0x3fa2 <mbox1_execute+0x444>
    3fa0:	61 e0       	ldi	r22, 0x01	; 1
    3fa2:	8c e1       	ldi	r24, 0x1C	; 28
    3fa4:	90 e0       	ldi	r25, 0x00	; 0
    3fa6:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3faa:	88 23       	and	r24, r24
    3fac:	09 f0       	breq	.+2      	; 0x3fb0 <mbox1_execute+0x452>
    3fae:	15 ce       	rjmp	.-982    	; 0x3bda <mbox1_execute+0x7c>
    test_emit_token(msg2);
    3fb0:	89 81       	ldd	r24, Y+1	; 0x01
    3fb2:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  test_assert(25, msg1 == RDY_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == RDY_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    3fb6:	0f 5f       	subi	r16, 0xFF	; 255
    3fb8:	1f 4f       	sbci	r17, 0xFF	; 255
    3fba:	05 30       	cpi	r16, 0x05	; 5
    3fbc:	11 05       	cpc	r17, r1
    3fbe:	31 f7       	brne	.-52     	; 0x3f8c <mbox1_execute+0x42e>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == RDY_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
    3fc0:	8d e1       	ldi	r24, 0x1D	; 29
    3fc2:	90 e0       	ldi	r25, 0x00	; 0
    3fc4:	64 e7       	ldi	r22, 0x74	; 116
    3fc6:	75 e0       	ldi	r23, 0x05	; 5
    3fc8:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
    3fcc:	88 23       	and	r24, r24
    3fce:	09 f0       	breq	.+2      	; 0x3fd2 <mbox1_execute+0x474>
    3fd0:	04 ce       	rjmp	.-1016   	; 0x3bda <mbox1_execute+0x7c>
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    3fd2:	f8 94       	cli
    3fd4:	60 e0       	ldi	r22, 0x00	; 0
    3fd6:	80 91 b7 05 	lds	r24, 0x05B7
    3fda:	85 30       	cpi	r24, 0x05	; 5
    3fdc:	09 f4       	brne	.+2      	; 0x3fe0 <mbox1_execute+0x482>
    3fde:	61 e0       	ldi	r22, 0x01	; 1
    3fe0:	8e e1       	ldi	r24, 0x1E	; 30
    3fe2:	90 e0       	ldi	r25, 0x00	; 0
    3fe4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    3fe8:	88 23       	and	r24, r24
    3fea:	11 f0       	breq	.+4      	; 0x3ff0 <mbox1_execute+0x492>
    3fec:	78 94       	sei
    3fee:	f5 cd       	rjmp	.-1046   	; 0x3bda <mbox1_execute+0x7c>
    3ff0:	78 94       	sei
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
    3ff2:	f8 94       	cli
    3ff4:	60 e0       	ldi	r22, 0x00	; 0
    3ff6:	80 91 b2 05 	lds	r24, 0x05B2
    3ffa:	88 23       	and	r24, r24
    3ffc:	09 f4       	brne	.+2      	; 0x4000 <mbox1_execute+0x4a2>
    3ffe:	61 e0       	ldi	r22, 0x01	; 1
    4000:	8f e1       	ldi	r24, 0x1F	; 31
    4002:	90 e0       	ldi	r25, 0x00	; 0
    4004:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4008:	88 23       	and	r24, r24
    400a:	11 f0       	breq	.+4      	; 0x4010 <mbox1_execute+0x4b2>
    400c:	78 94       	sei
    400e:	e5 cd       	rjmp	.-1078   	; 0x3bda <mbox1_execute+0x7c>
    4010:	78 94       	sei
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    4012:	60 e0       	ldi	r22, 0x00	; 0
    4014:	20 91 ac 05 	lds	r18, 0x05AC
    4018:	30 91 ad 05 	lds	r19, 0x05AD
    401c:	80 91 aa 05 	lds	r24, 0x05AA
    4020:	90 91 ab 05 	lds	r25, 0x05AB
    4024:	28 17       	cp	r18, r24
    4026:	39 07       	cpc	r19, r25
    4028:	09 f4       	brne	.+2      	; 0x402c <mbox1_execute+0x4ce>
    402a:	61 e0       	ldi	r22, 0x01	; 1
    402c:	80 e2       	ldi	r24, 0x20	; 32
    402e:	90 e0       	ldi	r25, 0x00	; 0
    4030:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4034:	88 23       	and	r24, r24
    4036:	09 f0       	breq	.+2      	; 0x403a <mbox1_execute+0x4dc>
    4038:	d0 cd       	rjmp	.-1120   	; 0x3bda <mbox1_execute+0x7c>

  chSysLock();
    403a:	f8 94       	cli
  msg1 = chMBPostAheadI(&mb1, 'E');
    403c:	86 ea       	ldi	r24, 0xA6	; 166
    403e:	95 e0       	ldi	r25, 0x05	; 5
    4040:	65 e4       	ldi	r22, 0x45	; 69
    4042:	70 e0       	ldi	r23, 0x00	; 0
    4044:	0e 94 1a 0b 	call	0x1634	; 0x1634 <chMBPostAheadI>
  test_assert(33, msg1 == RDY_OK, "wrong wake-up message");
    4048:	60 e0       	ldi	r22, 0x00	; 0
    404a:	89 2b       	or	r24, r25
    404c:	09 f4       	brne	.+2      	; 0x4050 <mbox1_execute+0x4f2>
    404e:	61 e0       	ldi	r22, 0x01	; 1
    4050:	81 e2       	ldi	r24, 0x21	; 33
    4052:	90 e0       	ldi	r25, 0x00	; 0
    4054:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4058:	88 23       	and	r24, r24
    405a:	09 f0       	breq	.+2      	; 0x405e <mbox1_execute+0x500>
    405c:	be cd       	rjmp	.-1156   	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBPostAheadI(&mb1, 'D');
    405e:	86 ea       	ldi	r24, 0xA6	; 166
    4060:	95 e0       	ldi	r25, 0x05	; 5
    4062:	64 e4       	ldi	r22, 0x44	; 68
    4064:	70 e0       	ldi	r23, 0x00	; 0
    4066:	0e 94 1a 0b 	call	0x1634	; 0x1634 <chMBPostAheadI>
  test_assert(34, msg1 == RDY_OK, "wrong wake-up message");
    406a:	60 e0       	ldi	r22, 0x00	; 0
    406c:	89 2b       	or	r24, r25
    406e:	09 f4       	brne	.+2      	; 0x4072 <mbox1_execute+0x514>
    4070:	61 e0       	ldi	r22, 0x01	; 1
    4072:	82 e2       	ldi	r24, 0x22	; 34
    4074:	90 e0       	ldi	r25, 0x00	; 0
    4076:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    407a:	88 23       	and	r24, r24
    407c:	09 f0       	breq	.+2      	; 0x4080 <mbox1_execute+0x522>
    407e:	ad cd       	rjmp	.-1190   	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBPostAheadI(&mb1, 'C');
    4080:	86 ea       	ldi	r24, 0xA6	; 166
    4082:	95 e0       	ldi	r25, 0x05	; 5
    4084:	63 e4       	ldi	r22, 0x43	; 67
    4086:	70 e0       	ldi	r23, 0x00	; 0
    4088:	0e 94 1a 0b 	call	0x1634	; 0x1634 <chMBPostAheadI>
  test_assert(35, msg1 == RDY_OK, "wrong wake-up message");
    408c:	60 e0       	ldi	r22, 0x00	; 0
    408e:	89 2b       	or	r24, r25
    4090:	09 f4       	brne	.+2      	; 0x4094 <mbox1_execute+0x536>
    4092:	61 e0       	ldi	r22, 0x01	; 1
    4094:	83 e2       	ldi	r24, 0x23	; 35
    4096:	90 e0       	ldi	r25, 0x00	; 0
    4098:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    409c:	88 23       	and	r24, r24
    409e:	09 f0       	breq	.+2      	; 0x40a2 <mbox1_execute+0x544>
    40a0:	9c cd       	rjmp	.-1224   	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBPostAheadI(&mb1, 'B');
    40a2:	86 ea       	ldi	r24, 0xA6	; 166
    40a4:	95 e0       	ldi	r25, 0x05	; 5
    40a6:	62 e4       	ldi	r22, 0x42	; 66
    40a8:	70 e0       	ldi	r23, 0x00	; 0
    40aa:	0e 94 1a 0b 	call	0x1634	; 0x1634 <chMBPostAheadI>
  test_assert(36, msg1 == RDY_OK, "wrong wake-up message");
    40ae:	60 e0       	ldi	r22, 0x00	; 0
    40b0:	89 2b       	or	r24, r25
    40b2:	09 f4       	brne	.+2      	; 0x40b6 <mbox1_execute+0x558>
    40b4:	61 e0       	ldi	r22, 0x01	; 1
    40b6:	84 e2       	ldi	r24, 0x24	; 36
    40b8:	90 e0       	ldi	r25, 0x00	; 0
    40ba:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    40be:	88 23       	and	r24, r24
    40c0:	09 f0       	breq	.+2      	; 0x40c4 <mbox1_execute+0x566>
    40c2:	8b cd       	rjmp	.-1258   	; 0x3bda <mbox1_execute+0x7c>
  msg1 = chMBPostAheadI(&mb1, 'A');
    40c4:	86 ea       	ldi	r24, 0xA6	; 166
    40c6:	95 e0       	ldi	r25, 0x05	; 5
    40c8:	61 e4       	ldi	r22, 0x41	; 65
    40ca:	70 e0       	ldi	r23, 0x00	; 0
    40cc:	0e 94 1a 0b 	call	0x1634	; 0x1634 <chMBPostAheadI>
  chSysUnlock();
    40d0:	78 94       	sei
  test_assert(37, msg1 == RDY_OK, "wrong wake-up message");
    40d2:	60 e0       	ldi	r22, 0x00	; 0
    40d4:	89 2b       	or	r24, r25
    40d6:	09 f4       	brne	.+2      	; 0x40da <mbox1_execute+0x57c>
    40d8:	61 e0       	ldi	r22, 0x01	; 1
    40da:	85 e2       	ldi	r24, 0x25	; 37
    40dc:	90 e0       	ldi	r25, 0x00	; 0
    40de:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    40e2:	88 23       	and	r24, r24
    40e4:	09 f0       	breq	.+2      	; 0x40e8 <mbox1_execute+0x58a>
    40e6:	79 cd       	rjmp	.-1294   	; 0x3bda <mbox1_execute+0x7c>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    40e8:	60 e0       	ldi	r22, 0x00	; 0
    40ea:	20 91 ac 05 	lds	r18, 0x05AC
    40ee:	30 91 ad 05 	lds	r19, 0x05AD
    40f2:	80 91 aa 05 	lds	r24, 0x05AA
    40f6:	90 91 ab 05 	lds	r25, 0x05AB
    40fa:	28 17       	cp	r18, r24
    40fc:	39 07       	cpc	r19, r25
    40fe:	09 f4       	brne	.+2      	; 0x4102 <__stack+0x3>
    4100:	61 e0       	ldi	r22, 0x01	; 1
    4102:	86 e2       	ldi	r24, 0x26	; 38
    4104:	90 e0       	ldi	r25, 0x00	; 0
    4106:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    410a:	88 23       	and	r24, r24
    410c:	09 f0       	breq	.+2      	; 0x4110 <__stack+0x11>
    410e:	65 cd       	rjmp	.-1334   	; 0x3bda <mbox1_execute+0x7c>
    4110:	00 e0       	ldi	r16, 0x00	; 0
    4112:	10 e0       	ldi	r17, 0x00	; 0
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    4114:	f8 94       	cli
    msg1 = chMBFetchI(&mb1, &msg2);
    4116:	86 ea       	ldi	r24, 0xA6	; 166
    4118:	95 e0       	ldi	r25, 0x05	; 5
    411a:	b7 01       	movw	r22, r14
    411c:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <chMBFetchI>
    chSysUnlock();
    4120:	78 94       	sei
    test_assert(39, msg1 == RDY_OK, "wrong wake-up message");
    4122:	60 e0       	ldi	r22, 0x00	; 0
    4124:	89 2b       	or	r24, r25
    4126:	09 f4       	brne	.+2      	; 0x412a <__stack+0x2b>
    4128:	61 e0       	ldi	r22, 0x01	; 1
    412a:	87 e2       	ldi	r24, 0x27	; 39
    412c:	90 e0       	ldi	r25, 0x00	; 0
    412e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4132:	88 23       	and	r24, r24
    4134:	09 f0       	breq	.+2      	; 0x4138 <__stack+0x39>
    4136:	51 cd       	rjmp	.-1374   	; 0x3bda <mbox1_execute+0x7c>
    test_emit_token(msg2);
    4138:	89 81       	ldd	r24, Y+1	; 0x01
    413a:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  test_assert(36, msg1 == RDY_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == RDY_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    413e:	0f 5f       	subi	r16, 0xFF	; 255
    4140:	1f 4f       	sbci	r17, 0xFF	; 255
    4142:	05 30       	cpi	r16, 0x05	; 5
    4144:	11 05       	cpc	r17, r1
    4146:	31 f7       	brne	.-52     	; 0x4114 <__stack+0x15>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == RDY_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
    4148:	88 e2       	ldi	r24, 0x28	; 40
    414a:	90 e0       	ldi	r25, 0x00	; 0
    414c:	64 e7       	ldi	r22, 0x74	; 116
    414e:	75 e0       	ldi	r23, 0x05	; 5
    4150:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
    4154:	88 23       	and	r24, r24
    4156:	09 f0       	breq	.+2      	; 0x415a <__stack+0x5b>
    4158:	40 cd       	rjmp	.-1408   	; 0x3bda <mbox1_execute+0x7c>
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    415a:	f8 94       	cli
    415c:	60 e0       	ldi	r22, 0x00	; 0
    415e:	80 91 b7 05 	lds	r24, 0x05B7
    4162:	85 30       	cpi	r24, 0x05	; 5
    4164:	09 f4       	brne	.+2      	; 0x4168 <__stack+0x69>
    4166:	61 e0       	ldi	r22, 0x01	; 1
    4168:	89 e2       	ldi	r24, 0x29	; 41
    416a:	90 e0       	ldi	r25, 0x00	; 0
    416c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4170:	88 23       	and	r24, r24
    4172:	11 f0       	breq	.+4      	; 0x4178 <__stack+0x79>
    4174:	78 94       	sei
    4176:	31 cd       	rjmp	.-1438   	; 0x3bda <mbox1_execute+0x7c>
    4178:	78 94       	sei
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
    417a:	f8 94       	cli
    417c:	60 e0       	ldi	r22, 0x00	; 0
    417e:	80 91 b2 05 	lds	r24, 0x05B2
    4182:	88 23       	and	r24, r24
    4184:	09 f4       	brne	.+2      	; 0x4188 <__stack+0x89>
    4186:	61 e0       	ldi	r22, 0x01	; 1
    4188:	8a e2       	ldi	r24, 0x2A	; 42
    418a:	90 e0       	ldi	r25, 0x00	; 0
    418c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4190:	88 23       	and	r24, r24
    4192:	11 f0       	breq	.+4      	; 0x4198 <__stack+0x99>
    4194:	78 94       	sei
    4196:	21 cd       	rjmp	.-1470   	; 0x3bda <mbox1_execute+0x7c>
    4198:	78 94       	sei
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    419a:	60 e0       	ldi	r22, 0x00	; 0
    419c:	20 91 ac 05 	lds	r18, 0x05AC
    41a0:	30 91 ad 05 	lds	r19, 0x05AD
    41a4:	80 91 aa 05 	lds	r24, 0x05AA
    41a8:	90 91 ab 05 	lds	r25, 0x05AB
    41ac:	28 17       	cp	r18, r24
    41ae:	39 07       	cpc	r19, r25
    41b0:	09 f4       	brne	.+2      	; 0x41b4 <__stack+0xb5>
    41b2:	61 e0       	ldi	r22, 0x01	; 1
    41b4:	8b e2       	ldi	r24, 0x2B	; 43
    41b6:	90 e0       	ldi	r25, 0x00	; 0
    41b8:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    41bc:	88 23       	and	r24, r24
    41be:	09 f0       	breq	.+2      	; 0x41c2 <__stack+0xc3>
    41c0:	0c cd       	rjmp	.-1512   	; 0x3bda <mbox1_execute+0x7c>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
    41c2:	86 ea       	ldi	r24, 0xA6	; 166
    41c4:	95 e0       	ldi	r25, 0x05	; 5
    41c6:	0e 94 17 0c 	call	0x182e	; 0x182e <chMBReset>

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    41ca:	f8 94       	cli
    41cc:	60 e0       	ldi	r22, 0x00	; 0
    41ce:	80 91 b7 05 	lds	r24, 0x05B7
    41d2:	85 30       	cpi	r24, 0x05	; 5
    41d4:	09 f4       	brne	.+2      	; 0x41d8 <__stack+0xd9>
    41d6:	61 e0       	ldi	r22, 0x01	; 1
    41d8:	8c e2       	ldi	r24, 0x2C	; 44
    41da:	90 e0       	ldi	r25, 0x00	; 0
    41dc:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    41e0:	88 23       	and	r24, r24
    41e2:	11 f0       	breq	.+4      	; 0x41e8 <__stack+0xe9>
    41e4:	78 94       	sei
    41e6:	f9 cc       	rjmp	.-1550   	; 0x3bda <mbox1_execute+0x7c>
    41e8:	78 94       	sei
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
    41ea:	f8 94       	cli
    41ec:	60 e0       	ldi	r22, 0x00	; 0
    41ee:	80 91 b2 05 	lds	r24, 0x05B2
    41f2:	88 23       	and	r24, r24
    41f4:	09 f4       	brne	.+2      	; 0x41f8 <__stack+0xf9>
    41f6:	61 e0       	ldi	r22, 0x01	; 1
    41f8:	8d e2       	ldi	r24, 0x2D	; 45
    41fa:	90 e0       	ldi	r25, 0x00	; 0
    41fc:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4200:	88 23       	and	r24, r24
    4202:	11 f0       	breq	.+4      	; 0x4208 <__stack+0x109>
    4204:	78 94       	sei
    4206:	e9 cc       	rjmp	.-1582   	; 0x3bda <mbox1_execute+0x7c>
    4208:	78 94       	sei
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
    420a:	f8 94       	cli
    420c:	60 e0       	ldi	r22, 0x00	; 0
    420e:	20 91 a6 05 	lds	r18, 0x05A6
    4212:	30 91 a7 05 	lds	r19, 0x05A7
    4216:	80 91 aa 05 	lds	r24, 0x05AA
    421a:	90 91 ab 05 	lds	r25, 0x05AB
    421e:	28 17       	cp	r18, r24
    4220:	39 07       	cpc	r19, r25
    4222:	09 f4       	brne	.+2      	; 0x4226 <__stack+0x127>
    4224:	61 e0       	ldi	r22, 0x01	; 1
    4226:	8e e2       	ldi	r24, 0x2E	; 46
    4228:	90 e0       	ldi	r25, 0x00	; 0
    422a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    422e:	88 23       	and	r24, r24
    4230:	11 f0       	breq	.+4      	; 0x4236 <__stack+0x137>
    4232:	78 94       	sei
    4234:	d2 cc       	rjmp	.-1628   	; 0x3bda <mbox1_execute+0x7c>
    4236:	78 94       	sei
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
    4238:	f8 94       	cli
    423a:	60 e0       	ldi	r22, 0x00	; 0
    423c:	20 91 a6 05 	lds	r18, 0x05A6
    4240:	30 91 a7 05 	lds	r19, 0x05A7
    4244:	80 91 ac 05 	lds	r24, 0x05AC
    4248:	90 91 ad 05 	lds	r25, 0x05AD
    424c:	28 17       	cp	r18, r24
    424e:	39 07       	cpc	r19, r25
    4250:	09 f4       	brne	.+2      	; 0x4254 <__stack+0x155>
    4252:	61 e0       	ldi	r22, 0x01	; 1
    4254:	8f e2       	ldi	r24, 0x2F	; 47
    4256:	90 e0       	ldi	r25, 0x00	; 0
    4258:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    425c:	78 94       	sei
    425e:	bd cc       	rjmp	.-1670   	; 0x3bda <mbox1_execute+0x7c>

00004260 <mbox1_setup>:
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {

  chMBInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
    4260:	86 ea       	ldi	r24, 0xA6	; 166
    4262:	95 e0       	ldi	r25, 0x05	; 5
    4264:	6b e0       	ldi	r22, 0x0B	; 11
    4266:	7c e0       	ldi	r23, 0x0C	; 12
    4268:	45 e0       	ldi	r20, 0x05	; 5
    426a:	0e 94 37 0c 	call	0x186e	; 0x186e <chMBInit>
}
    426e:	08 95       	ret

00004270 <evt3_execute>:
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    4270:	8f ef       	ldi	r24, 0xFF	; 255
    4272:	60 e0       	ldi	r22, 0x00	; 0
    4274:	70 e0       	ldi	r23, 0x00	; 0
    4276:	0e 94 b3 09 	call	0x1366	; 0x1366 <chEvtWaitOneTimeout>
  test_assert(1, m == 0, "spurious event");
    427a:	60 e0       	ldi	r22, 0x00	; 0
    427c:	88 23       	and	r24, r24
    427e:	09 f4       	brne	.+2      	; 0x4282 <evt3_execute+0x12>
    4280:	61 e0       	ldi	r22, 0x01	; 1
    4282:	81 e0       	ldi	r24, 0x01	; 1
    4284:	90 e0       	ldi	r25, 0x00	; 0
    4286:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    428a:	81 11       	cpse	r24, r1
    428c:	08 95       	ret
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    428e:	8f ef       	ldi	r24, 0xFF	; 255
    4290:	60 e0       	ldi	r22, 0x00	; 0
    4292:	70 e0       	ldi	r23, 0x00	; 0
    4294:	0e 94 85 09 	call	0x130a	; 0x130a <chEvtWaitAnyTimeout>
  test_assert(2, m == 0, "spurious event");
    4298:	60 e0       	ldi	r22, 0x00	; 0
    429a:	88 23       	and	r24, r24
    429c:	09 f4       	brne	.+2      	; 0x42a0 <evt3_execute+0x30>
    429e:	41 c0       	rjmp	.+130    	; 0x4322 <evt3_execute+0xb2>
    42a0:	82 e0       	ldi	r24, 0x02	; 2
    42a2:	90 e0       	ldi	r25, 0x00	; 0
    42a4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    42a8:	88 23       	and	r24, r24
    42aa:	81 f7       	brne	.-32     	; 0x428c <evt3_execute+0x1c>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    42ac:	8f ef       	ldi	r24, 0xFF	; 255
    42ae:	60 e0       	ldi	r22, 0x00	; 0
    42b0:	70 e0       	ldi	r23, 0x00	; 0
    42b2:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <chEvtWaitAllTimeout>
  test_assert(3, m == 0, "spurious event");
    42b6:	60 e0       	ldi	r22, 0x00	; 0
    42b8:	88 23       	and	r24, r24
    42ba:	09 f4       	brne	.+2      	; 0x42be <evt3_execute+0x4e>
    42bc:	61 e0       	ldi	r22, 0x01	; 1
    42be:	83 e0       	ldi	r24, 0x03	; 3
    42c0:	90 e0       	ldi	r25, 0x00	; 0
    42c2:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    42c6:	88 23       	and	r24, r24
    42c8:	09 f7       	brne	.-62     	; 0x428c <evt3_execute+0x1c>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
    42ca:	8f ef       	ldi	r24, 0xFF	; 255
    42cc:	6a e0       	ldi	r22, 0x0A	; 10
    42ce:	70 e0       	ldi	r23, 0x00	; 0
    42d0:	0e 94 b3 09 	call	0x1366	; 0x1366 <chEvtWaitOneTimeout>
  test_assert(4, m == 0, "spurious event");
    42d4:	60 e0       	ldi	r22, 0x00	; 0
    42d6:	88 23       	and	r24, r24
    42d8:	09 f4       	brne	.+2      	; 0x42dc <evt3_execute+0x6c>
    42da:	61 e0       	ldi	r22, 0x01	; 1
    42dc:	84 e0       	ldi	r24, 0x04	; 4
    42de:	90 e0       	ldi	r25, 0x00	; 0
    42e0:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    42e4:	88 23       	and	r24, r24
    42e6:	91 f6       	brne	.-92     	; 0x428c <evt3_execute+0x1c>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
    42e8:	8f ef       	ldi	r24, 0xFF	; 255
    42ea:	6a e0       	ldi	r22, 0x0A	; 10
    42ec:	70 e0       	ldi	r23, 0x00	; 0
    42ee:	0e 94 85 09 	call	0x130a	; 0x130a <chEvtWaitAnyTimeout>
  test_assert(5, m == 0, "spurious event");
    42f2:	60 e0       	ldi	r22, 0x00	; 0
    42f4:	88 23       	and	r24, r24
    42f6:	09 f4       	brne	.+2      	; 0x42fa <evt3_execute+0x8a>
    42f8:	61 e0       	ldi	r22, 0x01	; 1
    42fa:	85 e0       	ldi	r24, 0x05	; 5
    42fc:	90 e0       	ldi	r25, 0x00	; 0
    42fe:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4302:	88 23       	and	r24, r24
    4304:	19 f6       	brne	.-122    	; 0x428c <evt3_execute+0x1c>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
    4306:	8f ef       	ldi	r24, 0xFF	; 255
    4308:	6a e0       	ldi	r22, 0x0A	; 10
    430a:	70 e0       	ldi	r23, 0x00	; 0
    430c:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <chEvtWaitAllTimeout>
  test_assert(6, m == 0, "spurious event");
    4310:	60 e0       	ldi	r22, 0x00	; 0
    4312:	88 23       	and	r24, r24
    4314:	09 f4       	brne	.+2      	; 0x4318 <evt3_execute+0xa8>
    4316:	61 e0       	ldi	r22, 0x01	; 1
    4318:	86 e0       	ldi	r24, 0x06	; 6
    431a:	90 e0       	ldi	r25, 0x00	; 0
    431c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4320:	08 95       	ret
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(1, m == 0, "spurious event");
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(2, m == 0, "spurious event");
    4322:	61 e0       	ldi	r22, 0x01	; 1
    4324:	82 e0       	ldi	r24, 0x02	; 2
    4326:	90 e0       	ldi	r25, 0x00	; 0
    4328:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    432c:	88 23       	and	r24, r24
    432e:	09 f0       	breq	.+2      	; 0x4332 <evt3_execute+0xc2>
    4330:	ad cf       	rjmp	.-166    	; 0x428c <evt3_execute+0x1c>
    4332:	bc cf       	rjmp	.-136    	; 0x42ac <evt3_execute+0x3c>

00004334 <evt3_setup>:
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
    4334:	8f ef       	ldi	r24, 0xFF	; 255
    4336:	0e 94 07 09 	call	0x120e	; 0x120e <chEvtGetAndClearEvents>
}
    433a:	08 95       	ret

0000433c <evt2_setup>:
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
    433c:	8f ef       	ldi	r24, 0xFF	; 255
    433e:	0e 94 07 09 	call	0x120e	; 0x120e <chEvtGetAndClearEvents>
}
    4342:	08 95       	ret

00004344 <evt1_setup>:
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
    4344:	8f ef       	ldi	r24, 0xFF	; 255
    4346:	0e 94 07 09 	call	0x120e	; 0x120e <chEvtGetAndClearEvents>
}
    434a:	08 95       	ret

0000434c <evt2_execute>:
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
  return 0;
}

static void evt2_execute(void) {
    434c:	8f 92       	push	r8
    434e:	9f 92       	push	r9
    4350:	af 92       	push	r10
    4352:	bf 92       	push	r11
    4354:	cf 92       	push	r12
    4356:	df 92       	push	r13
    4358:	ef 92       	push	r14
    435a:	ff 92       	push	r15
    435c:	0f 93       	push	r16
    435e:	1f 93       	push	r17
    4360:	df 93       	push	r29
    4362:	cf 93       	push	r28
    4364:	cd b7       	in	r28, 0x3d	; 61
    4366:	de b7       	in	r29, 0x3e	; 62
    4368:	2c 97       	sbiw	r28, 0x0c	; 12
    436a:	0f b6       	in	r0, 0x3f	; 63
    436c:	f8 94       	cli
    436e:	de bf       	out	0x3e, r29	; 62
    4370:	0f be       	out	0x3f, r0	; 63
    4372:	cd bf       	out	0x3d, r28	; 61
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(5);
    4374:	85 e0       	ldi	r24, 0x05	; 5
    4376:	0e 94 14 09 	call	0x1228	; 0x1228 <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
    437a:	8f ef       	ldi	r24, 0xFF	; 255
    437c:	0e 94 1e 0a 	call	0x143c	; 0x143c <chEvtWaitOne>
  test_assert(1, m == 1, "single event error");
    4380:	60 e0       	ldi	r22, 0x00	; 0
    4382:	81 30       	cpi	r24, 0x01	; 1
    4384:	09 f4       	brne	.+2      	; 0x4388 <evt2_execute+0x3c>
    4386:	63 c1       	rjmp	.+710    	; 0x464e <evt2_execute+0x302>
    4388:	81 e0       	ldi	r24, 0x01	; 1
    438a:	90 e0       	ldi	r25, 0x00	; 0
    438c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4390:	88 23       	and	r24, r24
    4392:	99 f0       	breq	.+38     	; 0x43ba <evt2_execute+0x6e>
  test_wait_threads();
  chEvtUnregister(&es1, &el1);
  chEvtUnregister(&es2, &el2);
  test_assert(14, !chEvtIsListeningI(&es1), "stuck listener");
  test_assert(15, !chEvtIsListeningI(&es2), "stuck listener");
}
    4394:	2c 96       	adiw	r28, 0x0c	; 12
    4396:	0f b6       	in	r0, 0x3f	; 63
    4398:	f8 94       	cli
    439a:	de bf       	out	0x3e, r29	; 62
    439c:	0f be       	out	0x3f, r0	; 63
    439e:	cd bf       	out	0x3d, r28	; 61
    43a0:	cf 91       	pop	r28
    43a2:	df 91       	pop	r29
    43a4:	1f 91       	pop	r17
    43a6:	0f 91       	pop	r16
    43a8:	ff 90       	pop	r15
    43aa:	ef 90       	pop	r14
    43ac:	df 90       	pop	r13
    43ae:	cf 90       	pop	r12
    43b0:	bf 90       	pop	r11
    43b2:	af 90       	pop	r10
    43b4:	9f 90       	pop	r9
    43b6:	8f 90       	pop	r8
    43b8:	08 95       	ret
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(5);
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
  m = chEvtWaitOne(ALL_EVENTS);
    43ba:	8f ef       	ldi	r24, 0xFF	; 255
    43bc:	0e 94 1e 0a 	call	0x143c	; 0x143c <chEvtWaitOne>
  test_assert(2, m == 4, "single event error");
    43c0:	60 e0       	ldi	r22, 0x00	; 0
    43c2:	84 30       	cpi	r24, 0x04	; 4
    43c4:	09 f4       	brne	.+2      	; 0x43c8 <evt2_execute+0x7c>
    43c6:	45 c1       	rjmp	.+650    	; 0x4652 <evt2_execute+0x306>
    43c8:	82 e0       	ldi	r24, 0x02	; 2
    43ca:	90 e0       	ldi	r25, 0x00	; 0
    43cc:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    43d0:	88 23       	and	r24, r24
    43d2:	01 f7       	brne	.-64     	; 0x4394 <evt2_execute+0x48>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    43d4:	8f ef       	ldi	r24, 0xFF	; 255
    43d6:	0e 94 07 09 	call	0x120e	; 0x120e <chEvtGetAndClearEvents>
  test_assert(3, m == 0, "stuck event");
    43da:	60 e0       	ldi	r22, 0x00	; 0
    43dc:	88 23       	and	r24, r24
    43de:	09 f4       	brne	.+2      	; 0x43e2 <evt2_execute+0x96>
    43e0:	61 e0       	ldi	r22, 0x01	; 1
    43e2:	83 e0       	ldi	r24, 0x03	; 3
    43e4:	90 e0       	ldi	r25, 0x00	; 0
    43e6:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    43ea:	88 23       	and	r24, r24
    43ec:	99 f6       	brne	.-90     	; 0x4394 <evt2_execute+0x48>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
    43ee:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  target_time = chTimeNow() + MS2ST(50);
    43f2:	e0 90 f1 0b 	lds	r14, 0x0BF1
    43f6:	f0 90 f2 0b 	lds	r15, 0x0BF2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
    43fa:	c0 90 95 02 	lds	r12, 0x0295
    43fe:	d0 90 96 02 	lds	r13, 0x0296
    4402:	e0 91 fe 0b 	lds	r30, 0x0BFE
    4406:	f0 91 ff 0b 	lds	r31, 0x0BFF
    440a:	44 81       	ldd	r20, Z+4	; 0x04
    440c:	41 50       	subi	r20, 0x01	; 1
    440e:	c6 01       	movw	r24, r12
    4410:	65 e9       	ldi	r22, 0x95	; 149
    4412:	70 e0       	ldi	r23, 0x00	; 0
    4414:	22 e4       	ldi	r18, 0x42	; 66
    4416:	33 e2       	ldi	r19, 0x23	; 35
    4418:	8f 01       	movw	r16, r30
    441a:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    441e:	90 93 02 0c 	sts	0x0C02, r25
    4422:	80 93 01 0c 	sts	0x0C01, r24
                                 thread1, chThdSelf());
  m = chEvtWaitOne(ALL_EVENTS);
    4426:	8f ef       	ldi	r24, 0xFF	; 255
    4428:	0e 94 1e 0a 	call	0x143c	; 0x143c <chEvtWaitOne>
    442c:	18 2f       	mov	r17, r24
  test_assert_time_window(4, target_time, target_time + ALLOWED_DELAY);
    442e:	a7 01       	movw	r20, r14
    4430:	49 5c       	subi	r20, 0xC9	; 201
    4432:	5f 4f       	sbci	r21, 0xFF	; 255
    4434:	84 e0       	ldi	r24, 0x04	; 4
    4436:	90 e0       	ldi	r25, 0x00	; 0

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(50);
    4438:	22 e3       	ldi	r18, 0x32	; 50
    443a:	30 e0       	ldi	r19, 0x00	; 0
    443c:	e2 0e       	add	r14, r18
    443e:	f3 1e       	adc	r15, r19
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
                                 thread1, chThdSelf());
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert_time_window(4, target_time, target_time + ALLOWED_DELAY);
    4440:	b7 01       	movw	r22, r14
    4442:	0e 94 de 11 	call	0x23bc	; 0x23bc <_test_assert_time_window>
    4446:	88 23       	and	r24, r24
    4448:	09 f0       	breq	.+2      	; 0x444c <evt2_execute+0x100>
    444a:	a4 cf       	rjmp	.-184    	; 0x4394 <evt2_execute+0x48>
  test_assert(5, m == 1, "single event error");
    444c:	60 e0       	ldi	r22, 0x00	; 0
    444e:	11 30       	cpi	r17, 0x01	; 1
    4450:	09 f4       	brne	.+2      	; 0x4454 <evt2_execute+0x108>
    4452:	01 c1       	rjmp	.+514    	; 0x4656 <evt2_execute+0x30a>
    4454:	85 e0       	ldi	r24, 0x05	; 5
    4456:	90 e0       	ldi	r25, 0x00	; 0
    4458:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    445c:	88 23       	and	r24, r24
    445e:	09 f0       	breq	.+2      	; 0x4462 <evt2_execute+0x116>
    4460:	99 cf       	rjmp	.-206    	; 0x4394 <evt2_execute+0x48>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    4462:	8f ef       	ldi	r24, 0xFF	; 255
    4464:	0e 94 07 09 	call	0x120e	; 0x120e <chEvtGetAndClearEvents>
  test_assert(6, m == 0, "stuck event");
    4468:	60 e0       	ldi	r22, 0x00	; 0
    446a:	88 23       	and	r24, r24
    446c:	09 f4       	brne	.+2      	; 0x4470 <evt2_execute+0x124>
    446e:	61 e0       	ldi	r22, 0x01	; 1
    4470:	86 e0       	ldi	r24, 0x06	; 6
    4472:	90 e0       	ldi	r25, 0x00	; 0
    4474:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4478:	88 23       	and	r24, r24
    447a:	09 f0       	breq	.+2      	; 0x447e <evt2_execute+0x132>
    447c:	8b cf       	rjmp	.-234    	; 0x4394 <evt2_execute+0x48>
  test_wait_threads();
    447e:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
    4482:	85 e0       	ldi	r24, 0x05	; 5
    4484:	0e 94 14 09 	call	0x1228	; 0x1228 <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
    4488:	8f ef       	ldi	r24, 0xFF	; 255
    448a:	0e 94 00 0a 	call	0x1400	; 0x1400 <chEvtWaitAny>
  test_assert(7, m == 5, "unexpected pending bit");
    448e:	60 e0       	ldi	r22, 0x00	; 0
    4490:	85 30       	cpi	r24, 0x05	; 5
    4492:	09 f4       	brne	.+2      	; 0x4496 <evt2_execute+0x14a>
    4494:	e2 c0       	rjmp	.+452    	; 0x465a <evt2_execute+0x30e>
    4496:	87 e0       	ldi	r24, 0x07	; 7
    4498:	90 e0       	ldi	r25, 0x00	; 0
    449a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    449e:	88 23       	and	r24, r24
    44a0:	09 f0       	breq	.+2      	; 0x44a4 <evt2_execute+0x158>
    44a2:	78 cf       	rjmp	.-272    	; 0x4394 <evt2_execute+0x48>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    44a4:	8f ef       	ldi	r24, 0xFF	; 255
    44a6:	0e 94 07 09 	call	0x120e	; 0x120e <chEvtGetAndClearEvents>
  test_assert(8, m == 0, "stuck event");
    44aa:	60 e0       	ldi	r22, 0x00	; 0
    44ac:	88 23       	and	r24, r24
    44ae:	09 f4       	brne	.+2      	; 0x44b2 <evt2_execute+0x166>
    44b0:	61 e0       	ldi	r22, 0x01	; 1
    44b2:	88 e0       	ldi	r24, 0x08	; 8
    44b4:	90 e0       	ldi	r25, 0x00	; 0
    44b6:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    44ba:	88 23       	and	r24, r24
    44bc:	09 f0       	breq	.+2      	; 0x44c0 <evt2_execute+0x174>
    44be:	6a cf       	rjmp	.-300    	; 0x4394 <evt2_execute+0x48>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
    44c0:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  target_time = chTimeNow() + MS2ST(50);
    44c4:	e0 90 f1 0b 	lds	r14, 0x0BF1
    44c8:	f0 90 f2 0b 	lds	r15, 0x0BF2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
    44cc:	e0 91 fe 0b 	lds	r30, 0x0BFE
    44d0:	f0 91 ff 0b 	lds	r31, 0x0BFF
    44d4:	44 81       	ldd	r20, Z+4	; 0x04
    44d6:	41 50       	subi	r20, 0x01	; 1
    44d8:	c6 01       	movw	r24, r12
    44da:	65 e9       	ldi	r22, 0x95	; 149
    44dc:	70 e0       	ldi	r23, 0x00	; 0
    44de:	22 e4       	ldi	r18, 0x42	; 66
    44e0:	33 e2       	ldi	r19, 0x23	; 35
    44e2:	8f 01       	movw	r16, r30
    44e4:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    44e8:	90 93 02 0c 	sts	0x0C02, r25
    44ec:	80 93 01 0c 	sts	0x0C01, r24
                                 thread1, chThdSelf());
  m = chEvtWaitAny(ALL_EVENTS);
    44f0:	8f ef       	ldi	r24, 0xFF	; 255
    44f2:	0e 94 00 0a 	call	0x1400	; 0x1400 <chEvtWaitAny>
    44f6:	18 2f       	mov	r17, r24
  test_assert_time_window(9, target_time, target_time + ALLOWED_DELAY);
    44f8:	a7 01       	movw	r20, r14
    44fa:	49 5c       	subi	r20, 0xC9	; 201
    44fc:	5f 4f       	sbci	r21, 0xFF	; 255
    44fe:	89 e0       	ldi	r24, 0x09	; 9
    4500:	90 e0       	ldi	r25, 0x00	; 0

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(50);
    4502:	22 e3       	ldi	r18, 0x32	; 50
    4504:	30 e0       	ldi	r19, 0x00	; 0
    4506:	e2 0e       	add	r14, r18
    4508:	f3 1e       	adc	r15, r19
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
                                 thread1, chThdSelf());
  m = chEvtWaitAny(ALL_EVENTS);
  test_assert_time_window(9, target_time, target_time + ALLOWED_DELAY);
    450a:	b7 01       	movw	r22, r14
    450c:	0e 94 de 11 	call	0x23bc	; 0x23bc <_test_assert_time_window>
    4510:	88 23       	and	r24, r24
    4512:	09 f0       	breq	.+2      	; 0x4516 <evt2_execute+0x1ca>
    4514:	3f cf       	rjmp	.-386    	; 0x4394 <evt2_execute+0x48>
  test_assert(10, m == 1, "single event error");
    4516:	60 e0       	ldi	r22, 0x00	; 0
    4518:	11 30       	cpi	r17, 0x01	; 1
    451a:	09 f4       	brne	.+2      	; 0x451e <evt2_execute+0x1d2>
    451c:	a0 c0       	rjmp	.+320    	; 0x465e <evt2_execute+0x312>
    451e:	8a e0       	ldi	r24, 0x0A	; 10
    4520:	90 e0       	ldi	r25, 0x00	; 0
    4522:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4526:	88 23       	and	r24, r24
    4528:	09 f0       	breq	.+2      	; 0x452c <evt2_execute+0x1e0>
    452a:	34 cf       	rjmp	.-408    	; 0x4394 <evt2_execute+0x48>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    452c:	8f ef       	ldi	r24, 0xFF	; 255
    452e:	0e 94 07 09 	call	0x120e	; 0x120e <chEvtGetAndClearEvents>
  test_assert(11, m == 0, "stuck event");
    4532:	60 e0       	ldi	r22, 0x00	; 0
    4534:	88 23       	and	r24, r24
    4536:	09 f4       	brne	.+2      	; 0x453a <evt2_execute+0x1ee>
    4538:	61 e0       	ldi	r22, 0x01	; 1
    453a:	8b e0       	ldi	r24, 0x0B	; 11
    453c:	90 e0       	ldi	r25, 0x00	; 0
    453e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4542:	88 23       	and	r24, r24
    4544:	09 f0       	breq	.+2      	; 0x4548 <evt2_execute+0x1fc>
    4546:	26 cf       	rjmp	.-436    	; 0x4394 <evt2_execute+0x48>
  test_wait_threads();
    4548:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>

  /*
   * Test on chEvtWaitAll().
   */
  chEvtInit(&es1);
    454c:	8c e2       	ldi	r24, 0x2C	; 44
    454e:	96 e0       	ldi	r25, 0x06	; 6
    4550:	90 93 2d 06 	sts	0x062D, r25
    4554:	80 93 2c 06 	sts	0x062C, r24
  chEvtInit(&es2);
    4558:	0e e2       	ldi	r16, 0x2E	; 46
    455a:	16 e0       	ldi	r17, 0x06	; 6
    455c:	10 93 2f 06 	sts	0x062F, r17
    4560:	00 93 2e 06 	sts	0x062E, r16
  chEvtRegisterMask(&es1, &el1, 1);
    4564:	5e 01       	movw	r10, r28
    4566:	08 94       	sec
    4568:	a1 1c       	adc	r10, r1
    456a:	b1 1c       	adc	r11, r1
    456c:	b5 01       	movw	r22, r10
    456e:	41 e0       	ldi	r20, 0x01	; 1
    4570:	0e 94 dd 08 	call	0x11ba	; 0x11ba <chEvtRegisterMask>
  chEvtRegisterMask(&es2, &el2, 4);
    4574:	87 e0       	ldi	r24, 0x07	; 7
    4576:	88 2e       	mov	r8, r24
    4578:	91 2c       	mov	r9, r1
    457a:	8c 0e       	add	r8, r28
    457c:	9d 1e       	adc	r9, r29
    457e:	c8 01       	movw	r24, r16
    4580:	b4 01       	movw	r22, r8
    4582:	44 e0       	ldi	r20, 0x04	; 4
    4584:	0e 94 dd 08 	call	0x11ba	; 0x11ba <chEvtRegisterMask>
  test_wait_tick();
    4588:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  target_time = chTimeNow() + MS2ST(50);
    458c:	e0 90 f1 0b 	lds	r14, 0x0BF1
    4590:	f0 90 f2 0b 	lds	r15, 0x0BF2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
    4594:	e0 91 fe 0b 	lds	r30, 0x0BFE
    4598:	f0 91 ff 0b 	lds	r31, 0x0BFF
    459c:	44 81       	ldd	r20, Z+4	; 0x04
    459e:	41 50       	subi	r20, 0x01	; 1
    45a0:	c6 01       	movw	r24, r12
    45a2:	65 e9       	ldi	r22, 0x95	; 149
    45a4:	70 e0       	ldi	r23, 0x00	; 0
    45a6:	21 e3       	ldi	r18, 0x31	; 49
    45a8:	33 e2       	ldi	r19, 0x23	; 35
    45aa:	08 eb       	ldi	r16, 0xB8	; 184
    45ac:	15 e0       	ldi	r17, 0x05	; 5
    45ae:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    45b2:	90 93 02 0c 	sts	0x0C02, r25
    45b6:	80 93 01 0c 	sts	0x0C01, r24
                                 thread2, "A");
  m = chEvtWaitAll(5);
    45ba:	85 e0       	ldi	r24, 0x05	; 5
    45bc:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <chEvtWaitAll>
  test_assert_time_window(12, target_time, target_time + ALLOWED_DELAY);
    45c0:	a7 01       	movw	r20, r14
    45c2:	49 5c       	subi	r20, 0xC9	; 201
    45c4:	5f 4f       	sbci	r21, 0xFF	; 255
    45c6:	8c e0       	ldi	r24, 0x0C	; 12
    45c8:	90 e0       	ldi	r25, 0x00	; 0
  chEvtInit(&es1);
  chEvtInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(50);
    45ca:	22 e3       	ldi	r18, 0x32	; 50
    45cc:	30 e0       	ldi	r19, 0x00	; 0
    45ce:	e2 0e       	add	r14, r18
    45d0:	f3 1e       	adc	r15, r19
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
                                 thread2, "A");
  m = chEvtWaitAll(5);
  test_assert_time_window(12, target_time, target_time + ALLOWED_DELAY);
    45d2:	b7 01       	movw	r22, r14
    45d4:	0e 94 de 11 	call	0x23bc	; 0x23bc <_test_assert_time_window>
    45d8:	88 23       	and	r24, r24
    45da:	09 f0       	breq	.+2      	; 0x45de <evt2_execute+0x292>
    45dc:	db ce       	rjmp	.-586    	; 0x4394 <evt2_execute+0x48>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    45de:	8f ef       	ldi	r24, 0xFF	; 255
    45e0:	0e 94 07 09 	call	0x120e	; 0x120e <chEvtGetAndClearEvents>
  test_assert(13, m == 0, "stuck event");
    45e4:	60 e0       	ldi	r22, 0x00	; 0
    45e6:	88 23       	and	r24, r24
    45e8:	09 f4       	brne	.+2      	; 0x45ec <evt2_execute+0x2a0>
    45ea:	61 e0       	ldi	r22, 0x01	; 1
    45ec:	8d e0       	ldi	r24, 0x0D	; 13
    45ee:	90 e0       	ldi	r25, 0x00	; 0
    45f0:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    45f4:	88 23       	and	r24, r24
    45f6:	09 f0       	breq	.+2      	; 0x45fa <evt2_execute+0x2ae>
    45f8:	cd ce       	rjmp	.-614    	; 0x4394 <evt2_execute+0x48>
  test_wait_threads();
    45fa:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
    45fe:	8c e2       	ldi	r24, 0x2C	; 44
    4600:	96 e0       	ldi	r25, 0x06	; 6
    4602:	b5 01       	movw	r22, r10
    4604:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
    4608:	8e e2       	ldi	r24, 0x2E	; 46
    460a:	96 e0       	ldi	r25, 0x06	; 6
    460c:	b4 01       	movw	r22, r8
    460e:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <chEvtUnregister>
  test_assert(14, !chEvtIsListeningI(&es1), "stuck listener");
    4612:	60 e0       	ldi	r22, 0x00	; 0
    4614:	80 91 2c 06 	lds	r24, 0x062C
    4618:	90 91 2d 06 	lds	r25, 0x062D
    461c:	8c 52       	subi	r24, 0x2C	; 44
    461e:	96 40       	sbci	r25, 0x06	; 6
    4620:	09 f4       	brne	.+2      	; 0x4624 <evt2_execute+0x2d8>
    4622:	61 e0       	ldi	r22, 0x01	; 1
    4624:	8e e0       	ldi	r24, 0x0E	; 14
    4626:	90 e0       	ldi	r25, 0x00	; 0
    4628:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    462c:	88 23       	and	r24, r24
    462e:	09 f0       	breq	.+2      	; 0x4632 <evt2_execute+0x2e6>
    4630:	b1 ce       	rjmp	.-670    	; 0x4394 <evt2_execute+0x48>
  test_assert(15, !chEvtIsListeningI(&es2), "stuck listener");
    4632:	60 e0       	ldi	r22, 0x00	; 0
    4634:	80 91 2e 06 	lds	r24, 0x062E
    4638:	90 91 2f 06 	lds	r25, 0x062F
    463c:	8e 52       	subi	r24, 0x2E	; 46
    463e:	96 40       	sbci	r25, 0x06	; 6
    4640:	09 f4       	brne	.+2      	; 0x4644 <evt2_execute+0x2f8>
    4642:	61 e0       	ldi	r22, 0x01	; 1
    4644:	8f e0       	ldi	r24, 0x0F	; 15
    4646:	90 e0       	ldi	r25, 0x00	; 0
    4648:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    464c:	a3 ce       	rjmp	.-698    	; 0x4394 <evt2_execute+0x48>
  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(5);
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
    464e:	61 e0       	ldi	r22, 0x01	; 1
    4650:	9b ce       	rjmp	.-714    	; 0x4388 <evt2_execute+0x3c>
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(2, m == 4, "single event error");
    4652:	61 e0       	ldi	r22, 0x01	; 1
    4654:	b9 ce       	rjmp	.-654    	; 0x43c8 <evt2_execute+0x7c>
  target_time = chTimeNow() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
                                 thread1, chThdSelf());
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert_time_window(4, target_time, target_time + ALLOWED_DELAY);
  test_assert(5, m == 1, "single event error");
    4656:	61 e0       	ldi	r22, 0x01	; 1
    4658:	fd ce       	rjmp	.-518    	; 0x4454 <evt2_execute+0x108>
  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
  m = chEvtWaitAny(ALL_EVENTS);
  test_assert(7, m == 5, "unexpected pending bit");
    465a:	61 e0       	ldi	r22, 0x01	; 1
    465c:	1c cf       	rjmp	.-456    	; 0x4496 <evt2_execute+0x14a>
  target_time = chTimeNow() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
                                 thread1, chThdSelf());
  m = chEvtWaitAny(ALL_EVENTS);
  test_assert_time_window(9, target_time, target_time + ALLOWED_DELAY);
  test_assert(10, m == 1, "single event error");
    465e:	61 e0       	ldi	r22, 0x01	; 1
    4660:	5e cf       	rjmp	.-324    	; 0x451e <evt2_execute+0x1d2>

00004662 <thread2>:
}

static msg_t thread2(void *p) {

  (void)p;
  chEvtBroadcast(&es1);
    4662:	8c e2       	ldi	r24, 0x2C	; 44
    4664:	96 e0       	ldi	r25, 0x06	; 6
    4666:	60 e0       	ldi	r22, 0x00	; 0
    4668:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <chEvtBroadcastFlags>
  chThdSleepMilliseconds(50);
    466c:	82 e3       	ldi	r24, 0x32	; 50
    466e:	90 e0       	ldi	r25, 0x00	; 0
    4670:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  chEvtBroadcast(&es2);
    4674:	8e e2       	ldi	r24, 0x2E	; 46
    4676:	96 e0       	ldi	r25, 0x06	; 6
    4678:	60 e0       	ldi	r22, 0x00	; 0
    467a:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <chEvtBroadcastFlags>
  return 0;
}
    467e:	80 e0       	ldi	r24, 0x00	; 0
    4680:	90 e0       	ldi	r25, 0x00	; 0
    4682:	08 95       	ret

00004684 <thread1>:
static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static msg_t thread1(void *p) {
    4684:	0f 93       	push	r16
    4686:	1f 93       	push	r17
    4688:	8c 01       	movw	r16, r24

  chThdSleepMilliseconds(50);
    468a:	82 e3       	ldi	r24, 0x32	; 50
    468c:	90 e0       	ldi	r25, 0x00	; 0
    468e:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  chEvtSignal((Thread *)p, 1);
    4692:	c8 01       	movw	r24, r16
    4694:	61 e0       	ldi	r22, 0x01	; 1
    4696:	0e 94 57 0a 	call	0x14ae	; 0x14ae <chEvtSignal>
  return 0;
}
    469a:	80 e0       	ldi	r24, 0x00	; 0
    469c:	90 e0       	ldi	r25, 0x00	; 0
    469e:	1f 91       	pop	r17
    46a0:	0f 91       	pop	r16
    46a2:	08 95       	ret

000046a4 <evt1_execute>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
    46a4:	cf 92       	push	r12
    46a6:	df 92       	push	r13
    46a8:	ef 92       	push	r14
    46aa:	ff 92       	push	r15
    46ac:	0f 93       	push	r16
    46ae:	1f 93       	push	r17
    46b0:	df 93       	push	r29
    46b2:	cf 93       	push	r28
    46b4:	cd b7       	in	r28, 0x3d	; 61
    46b6:	de b7       	in	r29, 0x3e	; 62
    46b8:	2c 97       	sbiw	r28, 0x0c	; 12
    46ba:	0f b6       	in	r0, 0x3f	; 63
    46bc:	f8 94       	cli
    46be:	de bf       	out	0x3e, r29	; 62
    46c0:	0f be       	out	0x3f, r0	; 63
    46c2:	cd bf       	out	0x3d, r28	; 61
  EventListener el1, el2;

  /*
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtInit(&es1);
    46c4:	0c e2       	ldi	r16, 0x2C	; 44
    46c6:	16 e0       	ldi	r17, 0x06	; 6
    46c8:	10 93 2d 06 	sts	0x062D, r17
    46cc:	00 93 2c 06 	sts	0x062C, r16
  chEvtRegisterMask(&es1, &el1, 1);
    46d0:	c8 01       	movw	r24, r16
    46d2:	7e 01       	movw	r14, r28
    46d4:	08 94       	sec
    46d6:	e1 1c       	adc	r14, r1
    46d8:	f1 1c       	adc	r15, r1
    46da:	b7 01       	movw	r22, r14
    46dc:	41 e0       	ldi	r20, 0x01	; 1
    46de:	0e 94 dd 08 	call	0x11ba	; 0x11ba <chEvtRegisterMask>
  chEvtRegisterMask(&es1, &el2, 2);
    46e2:	97 e0       	ldi	r25, 0x07	; 7
    46e4:	c9 2e       	mov	r12, r25
    46e6:	d1 2c       	mov	r13, r1
    46e8:	cc 0e       	add	r12, r28
    46ea:	dd 1e       	adc	r13, r29
    46ec:	c8 01       	movw	r24, r16
    46ee:	b6 01       	movw	r22, r12
    46f0:	42 e0       	ldi	r20, 0x02	; 2
    46f2:	0e 94 dd 08 	call	0x11ba	; 0x11ba <chEvtRegisterMask>
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
    46f6:	60 e0       	ldi	r22, 0x00	; 0
    46f8:	80 91 2c 06 	lds	r24, 0x062C
    46fc:	90 91 2d 06 	lds	r25, 0x062D
    4700:	80 17       	cp	r24, r16
    4702:	91 07       	cpc	r25, r17
    4704:	09 f0       	breq	.+2      	; 0x4708 <evt1_execute+0x64>
    4706:	61 e0       	ldi	r22, 0x01	; 1
    4708:	81 e0       	ldi	r24, 0x01	; 1
    470a:	90 e0       	ldi	r25, 0x00	; 0
    470c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4710:	88 23       	and	r24, r24
    4712:	79 f0       	breq	.+30     	; 0x4732 <evt1_execute+0x8e>
  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
}
    4714:	2c 96       	adiw	r28, 0x0c	; 12
    4716:	0f b6       	in	r0, 0x3f	; 63
    4718:	f8 94       	cli
    471a:	de bf       	out	0x3e, r29	; 62
    471c:	0f be       	out	0x3f, r0	; 63
    471e:	cd bf       	out	0x3d, r28	; 61
    4720:	cf 91       	pop	r28
    4722:	df 91       	pop	r29
    4724:	1f 91       	pop	r17
    4726:	0f 91       	pop	r16
    4728:	ff 90       	pop	r15
    472a:	ef 90       	pop	r14
    472c:	df 90       	pop	r13
    472e:	cf 90       	pop	r12
    4730:	08 95       	ret
   */
  chEvtInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el1);
    4732:	8c e2       	ldi	r24, 0x2C	; 44
    4734:	96 e0       	ldi	r25, 0x06	; 6
    4736:	b7 01       	movw	r22, r14
    4738:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <chEvtUnregister>
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
    473c:	60 e0       	ldi	r22, 0x00	; 0
    473e:	80 91 2c 06 	lds	r24, 0x062C
    4742:	90 91 2d 06 	lds	r25, 0x062D
    4746:	8c 52       	subi	r24, 0x2C	; 44
    4748:	96 40       	sbci	r25, 0x06	; 6
    474a:	09 f0       	breq	.+2      	; 0x474e <evt1_execute+0xaa>
    474c:	61 e0       	ldi	r22, 0x01	; 1
    474e:	82 e0       	ldi	r24, 0x02	; 2
    4750:	90 e0       	ldi	r25, 0x00	; 0
    4752:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4756:	88 23       	and	r24, r24
    4758:	e9 f6       	brne	.-70     	; 0x4714 <evt1_execute+0x70>
  chEvtUnregister(&es1, &el2);
    475a:	8c e2       	ldi	r24, 0x2C	; 44
    475c:	96 e0       	ldi	r25, 0x06	; 6
    475e:	b6 01       	movw	r22, r12
    4760:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
    4764:	60 e0       	ldi	r22, 0x00	; 0
    4766:	80 91 2c 06 	lds	r24, 0x062C
    476a:	90 91 2d 06 	lds	r25, 0x062D
    476e:	8c 52       	subi	r24, 0x2C	; 44
    4770:	96 40       	sbci	r25, 0x06	; 6
    4772:	91 f0       	breq	.+36     	; 0x4798 <evt1_execute+0xf4>
    4774:	83 e0       	ldi	r24, 0x03	; 3
    4776:	90 e0       	ldi	r25, 0x00	; 0
    4778:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    477c:	88 23       	and	r24, r24
    477e:	51 f6       	brne	.-108    	; 0x4714 <evt1_execute+0x70>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
    4780:	80 e3       	ldi	r24, 0x30	; 48
    4782:	96 e0       	ldi	r25, 0x06	; 6
    4784:	67 e0       	ldi	r22, 0x07	; 7
    4786:	0e 94 28 09 	call	0x1250	; 0x1250 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
    478a:	84 e0       	ldi	r24, 0x04	; 4
    478c:	90 e0       	ldi	r25, 0x00	; 0
    478e:	6a eb       	ldi	r22, 0xBA	; 186
    4790:	75 e0       	ldi	r23, 0x05	; 5
    4792:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
    4796:	be cf       	rjmp	.-132    	; 0x4714 <evt1_execute+0x70>
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el1);
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el2);
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
    4798:	61 e0       	ldi	r22, 0x01	; 1
    479a:	ec cf       	rjmp	.-40     	; 0x4774 <evt1_execute+0xd0>

0000479c <h3>:
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
    479c:	83 e4       	ldi	r24, 0x43	; 67
    479e:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
    47a2:	08 95       	ret

000047a4 <h2>:

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
    47a4:	82 e4       	ldi	r24, 0x42	; 66
    47a6:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
    47aa:	08 95       	ret

000047ac <h1>:
static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
    47ac:	81 e4       	ldi	r24, 0x41	; 65
    47ae:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
    47b2:	08 95       	ret

000047b4 <notify>:

#define TEST_QUEUES_SIZE 4

static void notify(GenericQueue *qp) {
  (void)qp;
}
    47b4:	08 95       	ret

000047b6 <thread2>:
}

static msg_t thread2(void *p) {

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
    47b6:	82 e8       	ldi	r24, 0x82	; 130
    47b8:	96 e0       	ldi	r25, 0x06	; 6
    47ba:	60 e0       	ldi	r22, 0x00	; 0
    47bc:	48 ec       	ldi	r20, 0xC8	; 200
    47be:	50 e0       	ldi	r21, 0x00	; 0
    47c0:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chOQPutTimeout>
  return 0;
}
    47c4:	80 e0       	ldi	r24, 0x00	; 0
    47c6:	90 e0       	ldi	r25, 0x00	; 0
    47c8:	08 95       	ret

000047ca <queues2_execute>:

static void queues2_execute(void) {
    47ca:	0f 93       	push	r16
    47cc:	1f 93       	push	r17
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
    47ce:	f8 94       	cli
    47d0:	20 91 8c 06 	lds	r18, 0x068C
    47d4:	30 91 8d 06 	lds	r19, 0x068D
    47d8:	80 91 8e 06 	lds	r24, 0x068E
    47dc:	90 91 8f 06 	lds	r25, 0x068F
    47e0:	28 17       	cp	r18, r24
    47e2:	39 07       	cpc	r19, r25
    47e4:	09 f4       	brne	.+2      	; 0x47e8 <queues2_execute+0x1e>
    47e6:	74 c0       	rjmp	.+232    	; 0x48d0 <queues2_execute+0x106>
    47e8:	60 e0       	ldi	r22, 0x00	; 0
    47ea:	81 e0       	ldi	r24, 0x01	; 1
    47ec:	90 e0       	ldi	r25, 0x00	; 0
    47ee:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    47f2:	88 23       	and	r24, r24
    47f4:	09 f0       	breq	.+2      	; 0x47f8 <queues2_execute+0x2e>
    47f6:	4d c0       	rjmp	.+154    	; 0x4892 <queues2_execute+0xc8>
    47f8:	78 94       	sei
    47fa:	11 e4       	ldi	r17, 0x41	; 65

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
    47fc:	82 e8       	ldi	r24, 0x82	; 130
    47fe:	96 e0       	ldi	r25, 0x06	; 6
    4800:	61 2f       	mov	r22, r17
    4802:	4f ef       	ldi	r20, 0xFF	; 255
    4804:	5f ef       	ldi	r21, 0xFF	; 255
    4806:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chOQPutTimeout>
    480a:	1f 5f       	subi	r17, 0xFF	; 255

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    480c:	15 34       	cpi	r17, 0x45	; 69
    480e:	b1 f7       	brne	.-20     	; 0x47fc <queues2_execute+0x32>
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
    4810:	f8 94       	cli
    4812:	60 e0       	ldi	r22, 0x00	; 0
    4814:	80 91 86 06 	lds	r24, 0x0686
    4818:	90 91 87 06 	lds	r25, 0x0687
    481c:	89 2b       	or	r24, r25
    481e:	71 f1       	breq	.+92     	; 0x487c <queues2_execute+0xb2>
    4820:	82 e0       	ldi	r24, 0x02	; 2
    4822:	90 e0       	ldi	r25, 0x00	; 0
    4824:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4828:	88 23       	and	r24, r24
    482a:	79 f5       	brne	.+94     	; 0x488a <queues2_execute+0xc0>
    482c:	78 94       	sei
    482e:	00 e0       	ldi	r16, 0x00	; 0
    4830:	10 e0       	ldi	r17, 0x00	; 0

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    4832:	f8 94       	cli
    c = chOQGetI(&oq);
    4834:	82 e8       	ldi	r24, 0x82	; 130
    4836:	96 e0       	ldi	r25, 0x06	; 6
    4838:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <chOQGetI>
    chSysUnlock();
    483c:	78 94       	sei
    test_emit_token(c);
    483e:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    4842:	0f 5f       	subi	r16, 0xFF	; 255
    4844:	1f 4f       	sbci	r17, 0xFF	; 255
    4846:	04 30       	cpi	r16, 0x04	; 4
    4848:	11 05       	cpc	r17, r1
    484a:	99 f7       	brne	.-26     	; 0x4832 <queues2_execute+0x68>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
    484c:	f8 94       	cli
    484e:	20 91 8c 06 	lds	r18, 0x068C
    4852:	30 91 8d 06 	lds	r19, 0x068D
    4856:	80 91 8e 06 	lds	r24, 0x068E
    485a:	90 91 8f 06 	lds	r25, 0x068F
    485e:	28 17       	cp	r18, r24
    4860:	39 07       	cpc	r19, r25
    4862:	09 f4       	brne	.+2      	; 0x4866 <queues2_execute+0x9c>
    4864:	40 c0       	rjmp	.+128    	; 0x48e6 <queues2_execute+0x11c>
    4866:	60 e0       	ldi	r22, 0x00	; 0
    4868:	83 e0       	ldi	r24, 0x03	; 3
    486a:	90 e0       	ldi	r25, 0x00	; 0
    486c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4870:	88 23       	and	r24, r24
    4872:	99 f0       	breq	.+38     	; 0x489a <queues2_execute+0xd0>
    4874:	78 94       	sei
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
    4876:	1f 91       	pop	r17
    4878:	0f 91       	pop	r16
    487a:	08 95       	ret
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
    487c:	61 e0       	ldi	r22, 0x01	; 1
    487e:	82 e0       	ldi	r24, 0x02	; 2
    4880:	90 e0       	ldi	r25, 0x00	; 0
    4882:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4886:	88 23       	and	r24, r24
    4888:	89 f2       	breq	.-94     	; 0x482c <queues2_execute+0x62>
    488a:	78 94       	sei
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
    488c:	1f 91       	pop	r17
    488e:	0f 91       	pop	r16
    4890:	08 95       	ret
static void queues2_execute(void) {
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
    4892:	78 94       	sei
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
    4894:	1f 91       	pop	r17
    4896:	0f 91       	pop	r16
    4898:	08 95       	ret
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
    489a:	78 94       	sei
  test_assert_sequence(4, "ABCD");
    489c:	84 e0       	ldi	r24, 0x04	; 4
    489e:	90 e0       	ldi	r25, 0x00	; 0
    48a0:	6c e3       	ldi	r22, 0x3C	; 60
    48a2:	76 e0       	ldi	r23, 0x06	; 6
    48a4:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
    48a8:	88 23       	and	r24, r24
    48aa:	81 f7       	brne	.-32     	; 0x488c <queues2_execute+0xc2>
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
    48ac:	f8 94       	cli
    48ae:	82 e8       	ldi	r24, 0x82	; 130
    48b0:	96 e0       	ldi	r25, 0x06	; 6
    48b2:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <chOQGetI>
    48b6:	60 e0       	ldi	r22, 0x00	; 0
    48b8:	8d 5f       	subi	r24, 0xFD	; 253
    48ba:	9f 4f       	sbci	r25, 0xFF	; 255
    48bc:	09 f4       	brne	.+2      	; 0x48c0 <queues2_execute+0xf6>
    48be:	46 c0       	rjmp	.+140    	; 0x494c <queues2_execute+0x182>
    48c0:	85 e0       	ldi	r24, 0x05	; 5
    48c2:	90 e0       	ldi	r25, 0x00	; 0
    48c4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    48c8:	88 23       	and	r24, r24
    48ca:	c1 f0       	breq	.+48     	; 0x48fc <queues2_execute+0x132>
    48cc:	78 94       	sei
    48ce:	de cf       	rjmp	.-68     	; 0x488c <queues2_execute+0xc2>
static void queues2_execute(void) {
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
    48d0:	60 e0       	ldi	r22, 0x00	; 0
    48d2:	80 91 86 06 	lds	r24, 0x0686
    48d6:	90 91 87 06 	lds	r25, 0x0687
    48da:	89 2b       	or	r24, r25
    48dc:	09 f4       	brne	.+2      	; 0x48e0 <queues2_execute+0x116>
    48de:	61 e0       	ldi	r22, 0x01	; 1
    48e0:	81 e0       	ldi	r24, 0x01	; 1
    48e2:	68 27       	eor	r22, r24
    48e4:	82 cf       	rjmp	.-252    	; 0x47ea <queues2_execute+0x20>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
    48e6:	60 e0       	ldi	r22, 0x00	; 0
    48e8:	80 91 86 06 	lds	r24, 0x0686
    48ec:	90 91 87 06 	lds	r25, 0x0687
    48f0:	89 2b       	or	r24, r25
    48f2:	09 f4       	brne	.+2      	; 0x48f6 <queues2_execute+0x12c>
    48f4:	61 e0       	ldi	r22, 0x01	; 1
    48f6:	81 e0       	ldi	r24, 0x01	; 1
    48f8:	68 27       	eor	r22, r24
    48fa:	b6 cf       	rjmp	.-148    	; 0x4868 <queues2_execute+0x9e>
  test_assert_sequence(4, "ABCD");
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
    48fc:	78 94       	sei

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
    48fe:	60 91 97 02 	lds	r22, 0x0297
    4902:	70 91 98 02 	lds	r23, 0x0298
    4906:	82 e8       	ldi	r24, 0x82	; 130
    4908:	96 e0       	ldi	r25, 0x06	; 6
    490a:	48 e0       	ldi	r20, 0x08	; 8
    490c:	50 e0       	ldi	r21, 0x00	; 0
    490e:	20 e0       	ldi	r18, 0x00	; 0
    4910:	30 e0       	ldi	r19, 0x00	; 0
    4912:	0e 94 b0 0c 	call	0x1960	; 0x1960 <chOQWriteTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
    4916:	60 e0       	ldi	r22, 0x00	; 0
    4918:	04 97       	sbiw	r24, 0x04	; 4
    491a:	d1 f0       	breq	.+52     	; 0x4950 <queues2_execute+0x186>
    491c:	86 e0       	ldi	r24, 0x06	; 6
    491e:	90 e0       	ldi	r25, 0x00	; 0
    4920:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4924:	88 23       	and	r24, r24
    4926:	09 f0       	breq	.+2      	; 0x492a <queues2_execute+0x160>
    4928:	b1 cf       	rjmp	.-158    	; 0x488c <queues2_execute+0xc2>
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
    492a:	f8 94       	cli
    492c:	60 e0       	ldi	r22, 0x00	; 0
    492e:	80 91 86 06 	lds	r24, 0x0686
    4932:	90 91 87 06 	lds	r25, 0x0687
    4936:	89 2b       	or	r24, r25
    4938:	09 f4       	brne	.+2      	; 0x493c <queues2_execute+0x172>
    493a:	61 e0       	ldi	r22, 0x01	; 1
    493c:	87 e0       	ldi	r24, 0x07	; 7
    493e:	90 e0       	ldi	r25, 0x00	; 0
    4940:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4944:	88 23       	and	r24, r24
    4946:	31 f0       	breq	.+12     	; 0x4954 <queues2_execute+0x18a>
    4948:	78 94       	sei
    494a:	a0 cf       	rjmp	.-192    	; 0x488c <queues2_execute+0xc2>
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
  test_assert_sequence(4, "ABCD");
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
    494c:	61 e0       	ldi	r22, 0x01	; 1
    494e:	b8 cf       	rjmp	.-144    	; 0x48c0 <queues2_execute+0xf6>

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
    4950:	61 e0       	ldi	r22, 0x01	; 1
    4952:	e4 cf       	rjmp	.-56     	; 0x491c <queues2_execute+0x152>
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
    4954:	78 94       	sei
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread2, NULL);
    4956:	e0 91 fe 0b 	lds	r30, 0x0BFE
    495a:	f0 91 ff 0b 	lds	r31, 0x0BFF
    495e:	44 81       	ldd	r20, Z+4	; 0x04
    4960:	4f 5f       	subi	r20, 0xFF	; 255
    4962:	80 91 95 02 	lds	r24, 0x0295
    4966:	90 91 96 02 	lds	r25, 0x0296
    496a:	65 e9       	ldi	r22, 0x95	; 149
    496c:	70 e0       	ldi	r23, 0x00	; 0
    496e:	2b ed       	ldi	r18, 0xDB	; 219
    4970:	33 e2       	ldi	r19, 0x23	; 35
    4972:	00 e0       	ldi	r16, 0x00	; 0
    4974:	10 e0       	ldi	r17, 0x00	; 0
    4976:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    497a:	90 93 02 0c 	sts	0x0C02, r25
    497e:	80 93 01 0c 	sts	0x0C01, r24
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
    4982:	f8 94       	cli
    4984:	60 e0       	ldi	r22, 0x00	; 0
    4986:	80 91 8a 06 	lds	r24, 0x068A
    498a:	90 91 8b 06 	lds	r25, 0x068B
    498e:	20 91 88 06 	lds	r18, 0x0688
    4992:	30 91 89 06 	lds	r19, 0x0689
    4996:	82 1b       	sub	r24, r18
    4998:	93 0b       	sbc	r25, r19
    499a:	20 91 86 06 	lds	r18, 0x0686
    499e:	30 91 87 06 	lds	r19, 0x0687
    49a2:	82 1b       	sub	r24, r18
    49a4:	93 0b       	sbc	r25, r19
    49a6:	04 97       	sbiw	r24, 0x04	; 4
    49a8:	69 f1       	breq	.+90     	; 0x4a04 <queues2_execute+0x23a>
    49aa:	88 e0       	ldi	r24, 0x08	; 8
    49ac:	90 e0       	ldi	r25, 0x00	; 0
    49ae:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    49b2:	88 23       	and	r24, r24
    49b4:	11 f0       	breq	.+4      	; 0x49ba <queues2_execute+0x1f0>
    49b6:	78 94       	sei
    49b8:	69 cf       	rjmp	.-302    	; 0x488c <queues2_execute+0xc2>
    49ba:	78 94       	sei
  test_wait_threads();
    49bc:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>

  /* Testing reset */
  chSysLock();
    49c0:	f8 94       	cli
  chOQResetI(&oq);
    49c2:	82 e8       	ldi	r24, 0x82	; 130
    49c4:	96 e0       	ldi	r25, 0x06	; 6
    49c6:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <chOQResetI>
  chSysUnlock();
    49ca:	78 94       	sei
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
    49cc:	f8 94       	cli
    49ce:	60 e0       	ldi	r22, 0x00	; 0
    49d0:	80 91 8a 06 	lds	r24, 0x068A
    49d4:	90 91 8b 06 	lds	r25, 0x068B
    49d8:	20 91 88 06 	lds	r18, 0x0688
    49dc:	30 91 89 06 	lds	r19, 0x0689
    49e0:	82 1b       	sub	r24, r18
    49e2:	93 0b       	sbc	r25, r19
    49e4:	20 91 86 06 	lds	r18, 0x0686
    49e8:	30 91 87 06 	lds	r19, 0x0687
    49ec:	82 17       	cp	r24, r18
    49ee:	93 07       	cpc	r25, r19
    49f0:	09 f4       	brne	.+2      	; 0x49f4 <queues2_execute+0x22a>
    49f2:	61 e0       	ldi	r22, 0x01	; 1
    49f4:	89 e0       	ldi	r24, 0x09	; 9
    49f6:	90 e0       	ldi	r25, 0x00	; 0
    49f8:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    49fc:	88 23       	and	r24, r24
    49fe:	21 f0       	breq	.+8      	; 0x4a08 <queues2_execute+0x23e>
    4a00:	78 94       	sei
    4a02:	44 cf       	rjmp	.-376    	; 0x488c <queues2_execute+0xc2>
  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread2, NULL);
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
    4a04:	61 e0       	ldi	r22, 0x01	; 1
    4a06:	d1 cf       	rjmp	.-94     	; 0x49aa <queues2_execute+0x1e0>

  /* Testing reset */
  chSysLock();
  chOQResetI(&oq);
  chSysUnlock();
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
    4a08:	78 94       	sei

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    4a0a:	00 91 97 02 	lds	r16, 0x0297
    4a0e:	10 91 98 02 	lds	r17, 0x0298
    4a12:	82 e8       	ldi	r24, 0x82	; 130
    4a14:	96 e0       	ldi	r25, 0x06	; 6
    4a16:	b8 01       	movw	r22, r16
    4a18:	42 e0       	ldi	r20, 0x02	; 2
    4a1a:	50 e0       	ldi	r21, 0x00	; 0
    4a1c:	20 e0       	ldi	r18, 0x00	; 0
    4a1e:	30 e0       	ldi	r19, 0x00	; 0
    4a20:	0e 94 b0 0c 	call	0x1960	; 0x1960 <chOQWriteTimeout>
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    4a24:	60 e0       	ldi	r22, 0x00	; 0
    4a26:	02 97       	sbiw	r24, 0x02	; 2
    4a28:	61 f1       	breq	.+88     	; 0x4a82 <queues2_execute+0x2b8>
    4a2a:	8a e0       	ldi	r24, 0x0A	; 10
    4a2c:	90 e0       	ldi	r25, 0x00	; 0
    4a2e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4a32:	88 23       	and	r24, r24
    4a34:	09 f0       	breq	.+2      	; 0x4a38 <queues2_execute+0x26e>
    4a36:	2a cf       	rjmp	.-428    	; 0x488c <queues2_execute+0xc2>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    4a38:	82 e8       	ldi	r24, 0x82	; 130
    4a3a:	96 e0       	ldi	r25, 0x06	; 6
    4a3c:	b8 01       	movw	r22, r16
    4a3e:	42 e0       	ldi	r20, 0x02	; 2
    4a40:	50 e0       	ldi	r21, 0x00	; 0
    4a42:	20 e0       	ldi	r18, 0x00	; 0
    4a44:	30 e0       	ldi	r19, 0x00	; 0
    4a46:	0e 94 b0 0c 	call	0x1960	; 0x1960 <chOQWriteTimeout>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    4a4a:	60 e0       	ldi	r22, 0x00	; 0
    4a4c:	02 97       	sbiw	r24, 0x02	; 2
    4a4e:	09 f4       	brne	.+2      	; 0x4a52 <queues2_execute+0x288>
    4a50:	61 e0       	ldi	r22, 0x01	; 1
    4a52:	8b e0       	ldi	r24, 0x0B	; 11
    4a54:	90 e0       	ldi	r25, 0x00	; 0
    4a56:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4a5a:	88 23       	and	r24, r24
    4a5c:	09 f0       	breq	.+2      	; 0x4a60 <queues2_execute+0x296>
    4a5e:	16 cf       	rjmp	.-468    	; 0x488c <queues2_execute+0xc2>
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
    4a60:	f8 94       	cli
    4a62:	60 e0       	ldi	r22, 0x00	; 0
    4a64:	80 91 86 06 	lds	r24, 0x0686
    4a68:	90 91 87 06 	lds	r25, 0x0687
    4a6c:	89 2b       	or	r24, r25
    4a6e:	09 f4       	brne	.+2      	; 0x4a72 <queues2_execute+0x2a8>
    4a70:	61 e0       	ldi	r22, 0x01	; 1
    4a72:	8c e0       	ldi	r24, 0x0C	; 12
    4a74:	90 e0       	ldi	r25, 0x00	; 0
    4a76:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4a7a:	88 23       	and	r24, r24
    4a7c:	21 f0       	breq	.+8      	; 0x4a86 <queues2_execute+0x2bc>
    4a7e:	78 94       	sei
    4a80:	05 cf       	rjmp	.-502    	; 0x488c <queues2_execute+0xc2>
  chSysUnlock();
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    4a82:	61 e0       	ldi	r22, 0x01	; 1
    4a84:	d2 cf       	rjmp	.-92     	; 0x4a2a <queues2_execute+0x260>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
    4a86:	78 94       	sei

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
    4a88:	82 e8       	ldi	r24, 0x82	; 130
    4a8a:	96 e0       	ldi	r25, 0x06	; 6
    4a8c:	60 e0       	ldi	r22, 0x00	; 0
    4a8e:	4a e0       	ldi	r20, 0x0A	; 10
    4a90:	50 e0       	ldi	r21, 0x00	; 0
    4a92:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chOQPutTimeout>
    4a96:	60 e0       	ldi	r22, 0x00	; 0
    4a98:	8f 5f       	subi	r24, 0xFF	; 255
    4a9a:	9f 4f       	sbci	r25, 0xFF	; 255
    4a9c:	09 f4       	brne	.+2      	; 0x4aa0 <queues2_execute+0x2d6>
    4a9e:	61 e0       	ldi	r22, 0x01	; 1
    4aa0:	8d e0       	ldi	r24, 0x0D	; 13
    4aa2:	90 e0       	ldi	r25, 0x00	; 0
    4aa4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4aa8:	f1 ce       	rjmp	.-542    	; 0x488c <queues2_execute+0xc2>

00004aaa <queues2_setup>:
 * This test case tests sysnchronos and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
    4aaa:	0f 93       	push	r16
    4aac:	1f 93       	push	r17

  chOQInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
    4aae:	60 91 95 02 	lds	r22, 0x0295
    4ab2:	70 91 96 02 	lds	r23, 0x0296
    4ab6:	82 e8       	ldi	r24, 0x82	; 130
    4ab8:	96 e0       	ldi	r25, 0x06	; 6
    4aba:	44 e0       	ldi	r20, 0x04	; 4
    4abc:	50 e0       	ldi	r21, 0x00	; 0
    4abe:	2a ed       	ldi	r18, 0xDA	; 218
    4ac0:	33 e2       	ldi	r19, 0x23	; 35
    4ac2:	00 e0       	ldi	r16, 0x00	; 0
    4ac4:	10 e0       	ldi	r17, 0x00	; 0
    4ac6:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <chOQInit>
}
    4aca:	1f 91       	pop	r17
    4acc:	0f 91       	pop	r16
    4ace:	08 95       	ret

00004ad0 <thread1>:
}

static msg_t thread1(void *p) {

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
    4ad0:	84 e9       	ldi	r24, 0x94	; 148
    4ad2:	96 e0       	ldi	r25, 0x06	; 6
    4ad4:	68 ec       	ldi	r22, 0xC8	; 200
    4ad6:	70 e0       	ldi	r23, 0x00	; 0
    4ad8:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <chIQGetTimeout>
  return 0;
}
    4adc:	80 e0       	ldi	r24, 0x00	; 0
    4ade:	90 e0       	ldi	r25, 0x00	; 0
    4ae0:	08 95       	ret

00004ae2 <queues1_execute>:

static void queues1_execute(void) {
    4ae2:	0f 93       	push	r16
    4ae4:	1f 93       	push	r17
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
    4ae6:	f8 94       	cli
    4ae8:	60 e0       	ldi	r22, 0x00	; 0
    4aea:	80 91 98 06 	lds	r24, 0x0698
    4aee:	90 91 99 06 	lds	r25, 0x0699
    4af2:	89 2b       	or	r24, r25
    4af4:	09 f4       	brne	.+2      	; 0x4af8 <queues1_execute+0x16>
    4af6:	61 e0       	ldi	r22, 0x01	; 1
    4af8:	81 e0       	ldi	r24, 0x01	; 1
    4afa:	90 e0       	ldi	r25, 0x00	; 0
    4afc:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4b00:	88 23       	and	r24, r24
    4b02:	19 f5       	brne	.+70     	; 0x4b4a <queues1_execute+0x68>
    4b04:	78 94       	sei

  /* Queue filling */
  chSysLock();
    4b06:	f8 94       	cli
    4b08:	11 e4       	ldi	r17, 0x41	; 65
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
    4b0a:	84 e9       	ldi	r24, 0x94	; 148
    4b0c:	96 e0       	ldi	r25, 0x06	; 6
    4b0e:	61 2f       	mov	r22, r17
    4b10:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
    4b14:	1f 5f       	subi	r17, 0xFF	; 255
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    4b16:	15 34       	cpi	r17, 0x45	; 69
    4b18:	c1 f7       	brne	.-16     	; 0x4b0a <queues1_execute+0x28>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
    4b1a:	78 94       	sei
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
    4b1c:	f8 94       	cli
    4b1e:	20 91 9e 06 	lds	r18, 0x069E
    4b22:	30 91 9f 06 	lds	r19, 0x069F
    4b26:	80 91 a0 06 	lds	r24, 0x06A0
    4b2a:	90 91 a1 06 	lds	r25, 0x06A1
    4b2e:	28 17       	cp	r18, r24
    4b30:	39 07       	cpc	r19, r25
    4b32:	79 f0       	breq	.+30     	; 0x4b52 <queues1_execute+0x70>
    4b34:	60 e0       	ldi	r22, 0x00	; 0
    4b36:	82 e0       	ldi	r24, 0x02	; 2
    4b38:	90 e0       	ldi	r25, 0x00	; 0
    4b3a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4b3e:	88 23       	and	r24, r24
    4b40:	99 f0       	breq	.+38     	; 0x4b68 <queues1_execute+0x86>
    4b42:	78 94       	sei
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
    4b44:	1f 91       	pop	r17
    4b46:	0f 91       	pop	r16
    4b48:	08 95       	ret
static void queues1_execute(void) {
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
    4b4a:	78 94       	sei
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
    4b4c:	1f 91       	pop	r17
    4b4e:	0f 91       	pop	r16
    4b50:	08 95       	ret
  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
    4b52:	60 e0       	ldi	r22, 0x00	; 0
    4b54:	80 91 98 06 	lds	r24, 0x0698
    4b58:	90 91 99 06 	lds	r25, 0x0699
    4b5c:	89 2b       	or	r24, r25
    4b5e:	09 f4       	brne	.+2      	; 0x4b62 <queues1_execute+0x80>
    4b60:	39 c0       	rjmp	.+114    	; 0x4bd4 <queues1_execute+0xf2>
    4b62:	81 e0       	ldi	r24, 0x01	; 1
    4b64:	68 27       	eor	r22, r24
    4b66:	e7 cf       	rjmp	.-50     	; 0x4b36 <queues1_execute+0x54>
    4b68:	78 94       	sei
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
    4b6a:	f8 94       	cli
    4b6c:	84 e9       	ldi	r24, 0x94	; 148
    4b6e:	96 e0       	ldi	r25, 0x06	; 6
    4b70:	60 e0       	ldi	r22, 0x00	; 0
    4b72:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
    4b76:	60 e0       	ldi	r22, 0x00	; 0
    4b78:	8c 5f       	subi	r24, 0xFC	; 252
    4b7a:	9f 4f       	sbci	r25, 0xFF	; 255
    4b7c:	49 f1       	breq	.+82     	; 0x4bd0 <queues1_execute+0xee>
    4b7e:	83 e0       	ldi	r24, 0x03	; 3
    4b80:	90 e0       	ldi	r25, 0x00	; 0
    4b82:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4b86:	88 23       	and	r24, r24
    4b88:	09 f5       	brne	.+66     	; 0x4bcc <queues1_execute+0xea>
    4b8a:	78 94       	sei
    4b8c:	00 e0       	ldi	r16, 0x00	; 0
    4b8e:	10 e0       	ldi	r17, 0x00	; 0

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
    4b90:	84 e9       	ldi	r24, 0x94	; 148
    4b92:	96 e0       	ldi	r25, 0x06	; 6
    4b94:	6f ef       	ldi	r22, 0xFF	; 255
    4b96:	7f ef       	ldi	r23, 0xFF	; 255
    4b98:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <chIQGetTimeout>
    4b9c:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    4ba0:	0f 5f       	subi	r16, 0xFF	; 255
    4ba2:	1f 4f       	sbci	r17, 0xFF	; 255
    4ba4:	04 30       	cpi	r16, 0x04	; 4
    4ba6:	11 05       	cpc	r17, r1
    4ba8:	99 f7       	brne	.-26     	; 0x4b90 <queues1_execute+0xae>
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
    4baa:	f8 94       	cli
    4bac:	60 e0       	ldi	r22, 0x00	; 0
    4bae:	80 91 98 06 	lds	r24, 0x0698
    4bb2:	90 91 99 06 	lds	r25, 0x0699
    4bb6:	89 2b       	or	r24, r25
    4bb8:	09 f4       	brne	.+2      	; 0x4bbc <queues1_execute+0xda>
    4bba:	61 e0       	ldi	r22, 0x01	; 1
    4bbc:	84 e0       	ldi	r24, 0x04	; 4
    4bbe:	90 e0       	ldi	r25, 0x00	; 0
    4bc0:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4bc4:	88 23       	and	r24, r24
    4bc6:	41 f0       	breq	.+16     	; 0x4bd8 <queues1_execute+0xf6>
    4bc8:	78 94       	sei
    4bca:	bc cf       	rjmp	.-136    	; 0x4b44 <queues1_execute+0x62>
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
    4bcc:	78 94       	sei
    4bce:	ba cf       	rjmp	.-140    	; 0x4b44 <queues1_execute+0x62>
    4bd0:	61 e0       	ldi	r22, 0x01	; 1
    4bd2:	d5 cf       	rjmp	.-86     	; 0x4b7e <queues1_execute+0x9c>
  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
    4bd4:	61 e0       	ldi	r22, 0x01	; 1
    4bd6:	c5 cf       	rjmp	.-118    	; 0x4b62 <queues1_execute+0x80>
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
    4bd8:	78 94       	sei
  test_assert_sequence(5, "ABCD");
    4bda:	85 e0       	ldi	r24, 0x05	; 5
    4bdc:	90 e0       	ldi	r25, 0x00	; 0
    4bde:	6c e3       	ldi	r22, 0x3C	; 60
    4be0:	76 e0       	ldi	r23, 0x06	; 6
    4be2:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <_test_assert_sequence>
    4be6:	88 23       	and	r24, r24
    4be8:	09 f0       	breq	.+2      	; 0x4bec <queues1_execute+0x10a>
    4bea:	ac cf       	rjmp	.-168    	; 0x4b44 <queues1_execute+0x62>

  /* Queue filling again */
  chSysLock();
    4bec:	f8 94       	cli
    4bee:	11 e4       	ldi	r17, 0x41	; 65
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
    4bf0:	84 e9       	ldi	r24, 0x94	; 148
    4bf2:	96 e0       	ldi	r25, 0x06	; 6
    4bf4:	61 2f       	mov	r22, r17
    4bf6:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
    4bfa:	1f 5f       	subi	r17, 0xFF	; 255
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    4bfc:	15 34       	cpi	r17, 0x45	; 69
    4bfe:	c1 f7       	brne	.-16     	; 0x4bf0 <queues1_execute+0x10e>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
    4c00:	78 94       	sei

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
    4c02:	60 91 97 02 	lds	r22, 0x0297
    4c06:	70 91 98 02 	lds	r23, 0x0298
    4c0a:	84 e9       	ldi	r24, 0x94	; 148
    4c0c:	96 e0       	ldi	r25, 0x06	; 6
    4c0e:	48 e0       	ldi	r20, 0x08	; 8
    4c10:	50 e0       	ldi	r21, 0x00	; 0
    4c12:	20 e0       	ldi	r18, 0x00	; 0
    4c14:	30 e0       	ldi	r19, 0x00	; 0
    4c16:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <chIQReadTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
    4c1a:	60 e0       	ldi	r22, 0x00	; 0
    4c1c:	04 97       	sbiw	r24, 0x04	; 4
    4c1e:	09 f4       	brne	.+2      	; 0x4c22 <queues1_execute+0x140>
    4c20:	5f c0       	rjmp	.+190    	; 0x4ce0 <queues1_execute+0x1fe>
    4c22:	86 e0       	ldi	r24, 0x06	; 6
    4c24:	90 e0       	ldi	r25, 0x00	; 0
    4c26:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4c2a:	88 23       	and	r24, r24
    4c2c:	09 f0       	breq	.+2      	; 0x4c30 <queues1_execute+0x14e>
    4c2e:	8a cf       	rjmp	.-236    	; 0x4b44 <queues1_execute+0x62>
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
    4c30:	f8 94       	cli
    4c32:	60 e0       	ldi	r22, 0x00	; 0
    4c34:	80 91 98 06 	lds	r24, 0x0698
    4c38:	90 91 99 06 	lds	r25, 0x0699
    4c3c:	89 2b       	or	r24, r25
    4c3e:	09 f4       	brne	.+2      	; 0x4c42 <queues1_execute+0x160>
    4c40:	61 e0       	ldi	r22, 0x01	; 1
    4c42:	87 e0       	ldi	r24, 0x07	; 7
    4c44:	90 e0       	ldi	r25, 0x00	; 0
    4c46:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4c4a:	88 23       	and	r24, r24
    4c4c:	09 f0       	breq	.+2      	; 0x4c50 <queues1_execute+0x16e>
    4c4e:	4a c0       	rjmp	.+148    	; 0x4ce4 <queues1_execute+0x202>
    4c50:	78 94       	sei

  /* Queue filling again */
  chSysLock();
    4c52:	f8 94       	cli
    4c54:	11 e4       	ldi	r17, 0x41	; 65
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
    4c56:	84 e9       	ldi	r24, 0x94	; 148
    4c58:	96 e0       	ldi	r25, 0x06	; 6
    4c5a:	61 2f       	mov	r22, r17
    4c5c:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
    4c60:	1f 5f       	subi	r17, 0xFF	; 255
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    4c62:	15 34       	cpi	r17, 0x45	; 69
    4c64:	c1 f7       	brne	.-16     	; 0x4c56 <queues1_execute+0x174>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
    4c66:	78 94       	sei

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    4c68:	00 91 97 02 	lds	r16, 0x0297
    4c6c:	10 91 98 02 	lds	r17, 0x0298
    4c70:	84 e9       	ldi	r24, 0x94	; 148
    4c72:	96 e0       	ldi	r25, 0x06	; 6
    4c74:	b8 01       	movw	r22, r16
    4c76:	42 e0       	ldi	r20, 0x02	; 2
    4c78:	50 e0       	ldi	r21, 0x00	; 0
    4c7a:	20 e0       	ldi	r18, 0x00	; 0
    4c7c:	30 e0       	ldi	r19, 0x00	; 0
    4c7e:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <chIQReadTimeout>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    4c82:	60 e0       	ldi	r22, 0x00	; 0
    4c84:	02 97       	sbiw	r24, 0x02	; 2
    4c86:	81 f1       	breq	.+96     	; 0x4ce8 <queues1_execute+0x206>
    4c88:	88 e0       	ldi	r24, 0x08	; 8
    4c8a:	90 e0       	ldi	r25, 0x00	; 0
    4c8c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4c90:	88 23       	and	r24, r24
    4c92:	09 f0       	breq	.+2      	; 0x4c96 <queues1_execute+0x1b4>
    4c94:	57 cf       	rjmp	.-338    	; 0x4b44 <queues1_execute+0x62>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    4c96:	84 e9       	ldi	r24, 0x94	; 148
    4c98:	96 e0       	ldi	r25, 0x06	; 6
    4c9a:	b8 01       	movw	r22, r16
    4c9c:	42 e0       	ldi	r20, 0x02	; 2
    4c9e:	50 e0       	ldi	r21, 0x00	; 0
    4ca0:	20 e0       	ldi	r18, 0x00	; 0
    4ca2:	30 e0       	ldi	r19, 0x00	; 0
    4ca4:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <chIQReadTimeout>
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    4ca8:	60 e0       	ldi	r22, 0x00	; 0
    4caa:	02 97       	sbiw	r24, 0x02	; 2
    4cac:	09 f4       	brne	.+2      	; 0x4cb0 <queues1_execute+0x1ce>
    4cae:	3b c0       	rjmp	.+118    	; 0x4d26 <queues1_execute+0x244>
    4cb0:	89 e0       	ldi	r24, 0x09	; 9
    4cb2:	90 e0       	ldi	r25, 0x00	; 0
    4cb4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4cb8:	88 23       	and	r24, r24
    4cba:	09 f0       	breq	.+2      	; 0x4cbe <queues1_execute+0x1dc>
    4cbc:	43 cf       	rjmp	.-378    	; 0x4b44 <queues1_execute+0x62>
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
    4cbe:	f8 94       	cli
    4cc0:	60 e0       	ldi	r22, 0x00	; 0
    4cc2:	80 91 98 06 	lds	r24, 0x0698
    4cc6:	90 91 99 06 	lds	r25, 0x0699
    4cca:	89 2b       	or	r24, r25
    4ccc:	09 f4       	brne	.+2      	; 0x4cd0 <queues1_execute+0x1ee>
    4cce:	61 e0       	ldi	r22, 0x01	; 1
    4cd0:	8a e0       	ldi	r24, 0x0A	; 10
    4cd2:	90 e0       	ldi	r25, 0x00	; 0
    4cd4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4cd8:	88 23       	and	r24, r24
    4cda:	41 f0       	breq	.+16     	; 0x4cec <queues1_execute+0x20a>
    4cdc:	78 94       	sei
    4cde:	32 cf       	rjmp	.-412    	; 0x4b44 <queues1_execute+0x62>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
    4ce0:	61 e0       	ldi	r22, 0x01	; 1
    4ce2:	9f cf       	rjmp	.-194    	; 0x4c22 <queues1_execute+0x140>
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
    4ce4:	78 94       	sei
    4ce6:	2e cf       	rjmp	.-420    	; 0x4b44 <queues1_execute+0x62>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    4ce8:	61 e0       	ldi	r22, 0x01	; 1
    4cea:	ce cf       	rjmp	.-100    	; 0x4c88 <queues1_execute+0x1a6>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
    4cec:	78 94       	sei

  /* Testing reset */
  chSysLock();
    4cee:	f8 94       	cli
  chIQPutI(&iq, 0);
    4cf0:	84 e9       	ldi	r24, 0x94	; 148
    4cf2:	96 e0       	ldi	r25, 0x06	; 6
    4cf4:	60 e0       	ldi	r22, 0x00	; 0
    4cf6:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
  chIQResetI(&iq);
    4cfa:	84 e9       	ldi	r24, 0x94	; 148
    4cfc:	96 e0       	ldi	r25, 0x06	; 6
    4cfe:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <chIQResetI>
  chSysUnlock();
    4d02:	78 94       	sei
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
    4d04:	f8 94       	cli
    4d06:	60 e0       	ldi	r22, 0x00	; 0
    4d08:	80 91 98 06 	lds	r24, 0x0698
    4d0c:	90 91 99 06 	lds	r25, 0x0699
    4d10:	89 2b       	or	r24, r25
    4d12:	09 f4       	brne	.+2      	; 0x4d16 <queues1_execute+0x234>
    4d14:	61 e0       	ldi	r22, 0x01	; 1
    4d16:	8b e0       	ldi	r24, 0x0B	; 11
    4d18:	90 e0       	ldi	r25, 0x00	; 0
    4d1a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4d1e:	88 23       	and	r24, r24
    4d20:	21 f0       	breq	.+8      	; 0x4d2a <queues1_execute+0x248>
    4d22:	78 94       	sei
    4d24:	0f cf       	rjmp	.-482    	; 0x4b44 <queues1_execute+0x62>

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    4d26:	61 e0       	ldi	r22, 0x01	; 1
    4d28:	c3 cf       	rjmp	.-122    	; 0x4cb0 <queues1_execute+0x1ce>
  /* Testing reset */
  chSysLock();
  chIQPutI(&iq, 0);
  chIQResetI(&iq);
  chSysUnlock();
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
    4d2a:	78 94       	sei
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread1, NULL);
    4d2c:	e0 91 fe 0b 	lds	r30, 0x0BFE
    4d30:	f0 91 ff 0b 	lds	r31, 0x0BFF
    4d34:	44 81       	ldd	r20, Z+4	; 0x04
    4d36:	4f 5f       	subi	r20, 0xFF	; 255
    4d38:	80 91 95 02 	lds	r24, 0x0295
    4d3c:	90 91 96 02 	lds	r25, 0x0296
    4d40:	65 e9       	ldi	r22, 0x95	; 149
    4d42:	70 e0       	ldi	r23, 0x00	; 0
    4d44:	28 e6       	ldi	r18, 0x68	; 104
    4d46:	35 e2       	ldi	r19, 0x25	; 37
    4d48:	00 e0       	ldi	r16, 0x00	; 0
    4d4a:	10 e0       	ldi	r17, 0x00	; 0
    4d4c:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    4d50:	90 93 02 0c 	sts	0x0C02, r25
    4d54:	80 93 01 0c 	sts	0x0C01, r24
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
    4d58:	f8 94       	cli
    4d5a:	60 e0       	ldi	r22, 0x00	; 0
    4d5c:	80 91 98 06 	lds	r24, 0x0698
    4d60:	90 91 99 06 	lds	r25, 0x0699
    4d64:	89 2b       	or	r24, r25
    4d66:	09 f4       	brne	.+2      	; 0x4d6a <queues1_execute+0x288>
    4d68:	61 e0       	ldi	r22, 0x01	; 1
    4d6a:	8c e0       	ldi	r24, 0x0C	; 12
    4d6c:	90 e0       	ldi	r25, 0x00	; 0
    4d6e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4d72:	88 23       	and	r24, r24
    4d74:	11 f0       	breq	.+4      	; 0x4d7a <queues1_execute+0x298>
    4d76:	78 94       	sei
    4d78:	e5 ce       	rjmp	.-566    	; 0x4b44 <queues1_execute+0x62>
    4d7a:	78 94       	sei
  test_wait_threads();
    4d7c:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
    4d80:	84 e9       	ldi	r24, 0x94	; 148
    4d82:	96 e0       	ldi	r25, 0x06	; 6
    4d84:	6a e0       	ldi	r22, 0x0A	; 10
    4d86:	70 e0       	ldi	r23, 0x00	; 0
    4d88:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <chIQGetTimeout>
    4d8c:	60 e0       	ldi	r22, 0x00	; 0
    4d8e:	8f 5f       	subi	r24, 0xFF	; 255
    4d90:	9f 4f       	sbci	r25, 0xFF	; 255
    4d92:	09 f4       	brne	.+2      	; 0x4d96 <queues1_execute+0x2b4>
    4d94:	61 e0       	ldi	r22, 0x01	; 1
    4d96:	8d e0       	ldi	r24, 0x0D	; 13
    4d98:	90 e0       	ldi	r25, 0x00	; 0
    4d9a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_test_assert>
    4d9e:	d2 ce       	rjmp	.-604    	; 0x4b44 <queues1_execute+0x62>

00004da0 <queues1_setup>:
 * This test case tests sysnchronos and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
    4da0:	0f 93       	push	r16
    4da2:	1f 93       	push	r17

  chIQInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
    4da4:	60 91 95 02 	lds	r22, 0x0295
    4da8:	70 91 96 02 	lds	r23, 0x0296
    4dac:	84 e9       	ldi	r24, 0x94	; 148
    4dae:	96 e0       	ldi	r25, 0x06	; 6
    4db0:	44 e0       	ldi	r20, 0x04	; 4
    4db2:	50 e0       	ldi	r21, 0x00	; 0
    4db4:	2a ed       	ldi	r18, 0xDA	; 218
    4db6:	33 e2       	ldi	r19, 0x23	; 35
    4db8:	00 e0       	ldi	r16, 0x00	; 0
    4dba:	10 e0       	ldi	r17, 0x00	; 0
    4dbc:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <chIQInit>
}
    4dc0:	1f 91       	pop	r17
    4dc2:	0f 91       	pop	r16
    4dc4:	08 95       	ret

00004dc6 <thread2>:
};

static msg_t thread2(void *p) {

  return (msg_t)p;
}
    4dc6:	08 95       	ret

00004dc8 <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
    4dc8:	08 95       	ret

00004dca <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
    4dca:	0f 93       	push	r16
    4dcc:	1f 93       	push	r17

  test_print("--- System: ");
    4dce:	86 ea       	ldi	r24, 0xA6	; 166
    4dd0:	96 e0       	ldi	r25, 0x06	; 6
    4dd2:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(sizeof(ReadyList) + sizeof(VTList) +
    4dd6:	6b ee       	ldi	r22, 0xEB	; 235
    4dd8:	70 e0       	ldi	r23, 0x00	; 0
    4dda:	80 e0       	ldi	r24, 0x00	; 0
    4ddc:	90 e0       	ldi	r25, 0x00	; 0
    4dde:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
              PORT_IDLE_THREAD_STACK_SIZE +
              (sizeof(Thread) + sizeof(struct intctx) +
               sizeof(struct extctx) +
               PORT_INT_REQUIRED_STACK) * 2);
  test_println(" bytes");
    4de2:	03 eb       	ldi	r16, 0xB3	; 179
    4de4:	16 e0       	ldi	r17, 0x06	; 6
    4de6:	c8 01       	movw	r24, r16
    4de8:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
  test_print("--- Thread: ");
    4dec:	8a eb       	ldi	r24, 0xBA	; 186
    4dee:	96 e0       	ldi	r25, 0x06	; 6
    4df0:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(sizeof(Thread));
    4df4:	60 e2       	ldi	r22, 0x20	; 32
    4df6:	70 e0       	ldi	r23, 0x00	; 0
    4df8:	80 e0       	ldi	r24, 0x00	; 0
    4dfa:	90 e0       	ldi	r25, 0x00	; 0
    4dfc:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" bytes");
    4e00:	c8 01       	movw	r24, r16
    4e02:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
  test_print("--- Timer : ");
    4e06:	87 ec       	ldi	r24, 0xC7	; 199
    4e08:	96 e0       	ldi	r25, 0x06	; 6
    4e0a:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(sizeof(VirtualTimer));
    4e0e:	6a e0       	ldi	r22, 0x0A	; 10
    4e10:	70 e0       	ldi	r23, 0x00	; 0
    4e12:	80 e0       	ldi	r24, 0x00	; 0
    4e14:	90 e0       	ldi	r25, 0x00	; 0
    4e16:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" bytes");
    4e1a:	c8 01       	movw	r24, r16
    4e1c:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
  test_print("--- Semaph: ");
    4e20:	84 ed       	ldi	r24, 0xD4	; 212
    4e22:	96 e0       	ldi	r25, 0x06	; 6
    4e24:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(sizeof(Semaphore));
    4e28:	65 e0       	ldi	r22, 0x05	; 5
    4e2a:	70 e0       	ldi	r23, 0x00	; 0
    4e2c:	80 e0       	ldi	r24, 0x00	; 0
    4e2e:	90 e0       	ldi	r25, 0x00	; 0
    4e30:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" bytes");
    4e34:	c8 01       	movw	r24, r16
    4e36:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#if CH_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
    4e3a:	81 ee       	ldi	r24, 0xE1	; 225
    4e3c:	96 e0       	ldi	r25, 0x06	; 6
    4e3e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(sizeof(EventSource));
    4e42:	62 e0       	ldi	r22, 0x02	; 2
    4e44:	70 e0       	ldi	r23, 0x00	; 0
    4e46:	80 e0       	ldi	r24, 0x00	; 0
    4e48:	90 e0       	ldi	r25, 0x00	; 0
    4e4a:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" bytes");
    4e4e:	c8 01       	movw	r24, r16
    4e50:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
  test_print("--- EventL: ");
    4e54:	8e ee       	ldi	r24, 0xEE	; 238
    4e56:	96 e0       	ldi	r25, 0x06	; 6
    4e58:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(sizeof(EventListener));
    4e5c:	66 e0       	ldi	r22, 0x06	; 6
    4e5e:	70 e0       	ldi	r23, 0x00	; 0
    4e60:	80 e0       	ldi	r24, 0x00	; 0
    4e62:	90 e0       	ldi	r25, 0x00	; 0
    4e64:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" bytes");
    4e68:	c8 01       	movw	r24, r16
    4e6a:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#endif
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
    4e6e:	8b ef       	ldi	r24, 0xFB	; 251
    4e70:	96 e0       	ldi	r25, 0x06	; 6
    4e72:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(sizeof(Mutex));
    4e76:	68 e0       	ldi	r22, 0x08	; 8
    4e78:	70 e0       	ldi	r23, 0x00	; 0
    4e7a:	80 e0       	ldi	r24, 0x00	; 0
    4e7c:	90 e0       	ldi	r25, 0x00	; 0
    4e7e:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" bytes");
    4e82:	c8 01       	movw	r24, r16
    4e84:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#endif
#if CH_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
    4e88:	88 e0       	ldi	r24, 0x08	; 8
    4e8a:	97 e0       	ldi	r25, 0x07	; 7
    4e8c:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(sizeof(CondVar));
    4e90:	64 e0       	ldi	r22, 0x04	; 4
    4e92:	70 e0       	ldi	r23, 0x00	; 0
    4e94:	80 e0       	ldi	r24, 0x00	; 0
    4e96:	90 e0       	ldi	r25, 0x00	; 0
    4e98:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" bytes");
    4e9c:	c8 01       	movw	r24, r16
    4e9e:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#endif
#if CH_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
    4ea2:	85 e1       	ldi	r24, 0x15	; 21
    4ea4:	97 e0       	ldi	r25, 0x07	; 7
    4ea6:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(sizeof(GenericQueue));
    4eaa:	62 e1       	ldi	r22, 0x12	; 18
    4eac:	70 e0       	ldi	r23, 0x00	; 0
    4eae:	80 e0       	ldi	r24, 0x00	; 0
    4eb0:	90 e0       	ldi	r25, 0x00	; 0
    4eb2:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" bytes");
    4eb6:	c8 01       	movw	r24, r16
    4eb8:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#endif
#if CH_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
    4ebc:	82 e2       	ldi	r24, 0x22	; 34
    4ebe:	97 e0       	ldi	r25, 0x07	; 7
    4ec0:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(sizeof(Mailbox));
    4ec4:	62 e1       	ldi	r22, 0x12	; 18
    4ec6:	70 e0       	ldi	r23, 0x00	; 0
    4ec8:	80 e0       	ldi	r24, 0x00	; 0
    4eca:	90 e0       	ldi	r25, 0x00	; 0
    4ecc:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" bytes");
    4ed0:	c8 01       	movw	r24, r16
    4ed2:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
#endif
}
    4ed6:	1f 91       	pop	r17
    4ed8:	0f 91       	pop	r16
    4eda:	08 95       	ret

00004edc <bmk12_execute>:
static void bmk12_setup(void) {

  chMtxInit(&mtx1);
}

static void bmk12_execute(void) {
    4edc:	ef 92       	push	r14
    4ede:	ff 92       	push	r15
    4ee0:	0f 93       	push	r16
    4ee2:	1f 93       	push	r17
  uint32_t n = 0;

  test_wait_tick();
    4ee4:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  test_start_timer(1000);
    4ee8:	88 ee       	ldi	r24, 0xE8	; 232
    4eea:	93 e0       	ldi	r25, 0x03	; 3
    4eec:	0e 94 53 10 	call	0x20a6	; 0x20a6 <test_start_timer>
    4ef0:	ee 24       	eor	r14, r14
    4ef2:	ff 24       	eor	r15, r15
    4ef4:	87 01       	movw	r16, r14
  do {
    chMtxLock(&mtx1);
    4ef6:	81 ef       	ldi	r24, 0xF1	; 241
    4ef8:	9a e0       	ldi	r25, 0x0A	; 10
    4efa:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
    chMtxUnlock();
    4efe:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
    chMtxLock(&mtx1);
    4f02:	81 ef       	ldi	r24, 0xF1	; 241
    4f04:	9a e0       	ldi	r25, 0x0A	; 10
    4f06:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
    chMtxUnlock();
    4f0a:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
    chMtxLock(&mtx1);
    4f0e:	81 ef       	ldi	r24, 0xF1	; 241
    4f10:	9a e0       	ldi	r25, 0x0A	; 10
    4f12:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
    chMtxUnlock();
    4f16:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
    chMtxLock(&mtx1);
    4f1a:	81 ef       	ldi	r24, 0xF1	; 241
    4f1c:	9a e0       	ldi	r25, 0x0A	; 10
    4f1e:	0e 94 dd 07 	call	0xfba	; 0xfba <chMtxLock>
    chMtxUnlock();
    4f22:	0e 94 c7 06 	call	0xd8e	; 0xd8e <chMtxUnlock>
    n++;
    4f26:	08 94       	sec
    4f28:	e1 1c       	adc	r14, r1
    4f2a:	f1 1c       	adc	r15, r1
    4f2c:	01 1d       	adc	r16, r1
    4f2e:	11 1d       	adc	r17, r1
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    4f30:	80 91 00 0c 	lds	r24, 0x0C00
    4f34:	88 23       	and	r24, r24
    4f36:	f9 f2       	breq	.-66     	; 0x4ef6 <bmk12_execute+0x1a>
  test_print("--- Score : ");
    4f38:	8f e2       	ldi	r24, 0x2F	; 47
    4f3a:	97 e0       	ldi	r25, 0x07	; 7
    4f3c:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n * 4);
    4f40:	ee 0c       	add	r14, r14
    4f42:	ff 1c       	adc	r15, r15
    4f44:	00 1f       	adc	r16, r16
    4f46:	11 1f       	adc	r17, r17
    4f48:	ee 0c       	add	r14, r14
    4f4a:	ff 1c       	adc	r15, r15
    4f4c:	00 1f       	adc	r16, r16
    4f4e:	11 1f       	adc	r17, r17
    4f50:	c8 01       	movw	r24, r16
    4f52:	b7 01       	movw	r22, r14
    4f54:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" lock+unlock/S");
    4f58:	8c e3       	ldi	r24, 0x3C	; 60
    4f5a:	97 e0       	ldi	r25, 0x07	; 7
    4f5c:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    4f60:	1f 91       	pop	r17
    4f62:	0f 91       	pop	r16
    4f64:	ff 90       	pop	r15
    4f66:	ef 90       	pop	r14
    4f68:	08 95       	ret

00004f6a <bmk12_setup>:
 * a second of continuous operations.
 */

static void bmk12_setup(void) {

  chMtxInit(&mtx1);
    4f6a:	81 ef       	ldi	r24, 0xF1	; 241
    4f6c:	9a e0       	ldi	r25, 0x0A	; 10
    4f6e:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <chMtxInit>
}
    4f72:	08 95       	ret

00004f74 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static msg_t thread3(void *p) {
    4f74:	04 c0       	rjmp	.+8      	; 0x4f7e <thread3+0xa>

  (void)p;
  while (!chThdShouldTerminate())
    chSemWait(&sem1);
    4f76:	8c ee       	ldi	r24, 0xEC	; 236
    4f78:	9a e0       	ldi	r25, 0x0A	; 10
    4f7a:	0e 94 3d 05 	call	0xa7a	; 0xa7a <chSemWait>
 */

static msg_t thread3(void *p) {

  (void)p;
  while (!chThdShouldTerminate())
    4f7e:	e0 91 fe 0b 	lds	r30, 0x0BFE
    4f82:	f0 91 ff 0b 	lds	r31, 0x0BFF
    4f86:	86 85       	ldd	r24, Z+14	; 0x0e
    4f88:	82 ff       	sbrs	r24, 2
    4f8a:	f5 cf       	rjmp	.-22     	; 0x4f76 <thread3+0x2>
    chSemWait(&sem1);
  return 0;
}
    4f8c:	80 e0       	ldi	r24, 0x00	; 0
    4f8e:	90 e0       	ldi	r25, 0x00	; 0
    4f90:	08 95       	ret

00004f92 <bmk11_execute>:
static void bmk11_setup(void) {

  chSemInit(&sem1, 1);
}

static void bmk11_execute(void) {
    4f92:	ef 92       	push	r14
    4f94:	ff 92       	push	r15
    4f96:	0f 93       	push	r16
    4f98:	1f 93       	push	r17
  uint32_t n = 0;

  test_wait_tick();
    4f9a:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  test_start_timer(1000);
    4f9e:	88 ee       	ldi	r24, 0xE8	; 232
    4fa0:	93 e0       	ldi	r25, 0x03	; 3
    4fa2:	0e 94 53 10 	call	0x20a6	; 0x20a6 <test_start_timer>
    4fa6:	ee 24       	eor	r14, r14
    4fa8:	ff 24       	eor	r15, r15
    4faa:	87 01       	movw	r16, r14
  do {
    chSemWait(&sem1);
    4fac:	8c ee       	ldi	r24, 0xEC	; 236
    4fae:	9a e0       	ldi	r25, 0x0A	; 10
    4fb0:	0e 94 3d 05 	call	0xa7a	; 0xa7a <chSemWait>
    chSemSignal(&sem1);
    4fb4:	8c ee       	ldi	r24, 0xEC	; 236
    4fb6:	9a e0       	ldi	r25, 0x0A	; 10
    4fb8:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chSemSignal>
    chSemWait(&sem1);
    4fbc:	8c ee       	ldi	r24, 0xEC	; 236
    4fbe:	9a e0       	ldi	r25, 0x0A	; 10
    4fc0:	0e 94 3d 05 	call	0xa7a	; 0xa7a <chSemWait>
    chSemSignal(&sem1);
    4fc4:	8c ee       	ldi	r24, 0xEC	; 236
    4fc6:	9a e0       	ldi	r25, 0x0A	; 10
    4fc8:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chSemSignal>
    chSemWait(&sem1);
    4fcc:	8c ee       	ldi	r24, 0xEC	; 236
    4fce:	9a e0       	ldi	r25, 0x0A	; 10
    4fd0:	0e 94 3d 05 	call	0xa7a	; 0xa7a <chSemWait>
    chSemSignal(&sem1);
    4fd4:	8c ee       	ldi	r24, 0xEC	; 236
    4fd6:	9a e0       	ldi	r25, 0x0A	; 10
    4fd8:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chSemSignal>
    chSemWait(&sem1);
    4fdc:	8c ee       	ldi	r24, 0xEC	; 236
    4fde:	9a e0       	ldi	r25, 0x0A	; 10
    4fe0:	0e 94 3d 05 	call	0xa7a	; 0xa7a <chSemWait>
    chSemSignal(&sem1);
    4fe4:	8c ee       	ldi	r24, 0xEC	; 236
    4fe6:	9a e0       	ldi	r25, 0x0A	; 10
    4fe8:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chSemSignal>
    n++;
    4fec:	08 94       	sec
    4fee:	e1 1c       	adc	r14, r1
    4ff0:	f1 1c       	adc	r15, r1
    4ff2:	01 1d       	adc	r16, r1
    4ff4:	11 1d       	adc	r17, r1
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    4ff6:	80 91 00 0c 	lds	r24, 0x0C00
    4ffa:	88 23       	and	r24, r24
    4ffc:	b9 f2       	breq	.-82     	; 0x4fac <bmk11_execute+0x1a>
  test_print("--- Score : ");
    4ffe:	8f e2       	ldi	r24, 0x2F	; 47
    5000:	97 e0       	ldi	r25, 0x07	; 7
    5002:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n * 4);
    5006:	ee 0c       	add	r14, r14
    5008:	ff 1c       	adc	r15, r15
    500a:	00 1f       	adc	r16, r16
    500c:	11 1f       	adc	r17, r17
    500e:	ee 0c       	add	r14, r14
    5010:	ff 1c       	adc	r15, r15
    5012:	00 1f       	adc	r16, r16
    5014:	11 1f       	adc	r17, r17
    5016:	c8 01       	movw	r24, r16
    5018:	b7 01       	movw	r22, r14
    501a:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" wait+signal/S");
    501e:	8b e4       	ldi	r24, 0x4B	; 75
    5020:	97 e0       	ldi	r25, 0x07	; 7
    5022:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    5026:	1f 91       	pop	r17
    5028:	0f 91       	pop	r16
    502a:	ff 90       	pop	r15
    502c:	ef 90       	pop	r14
    502e:	08 95       	ret

00005030 <bmk11_setup>:
 * a second of continuous operations.
 */

static void bmk11_setup(void) {

  chSemInit(&sem1, 1);
    5030:	8c ee       	ldi	r24, 0xEC	; 236
    5032:	9a e0       	ldi	r25, 0x0A	; 10
    5034:	61 e0       	ldi	r22, 0x01	; 1
    5036:	0e 94 93 04 	call	0x926	; 0x926 <chSemInit>
}
    503a:	08 95       	ret

0000503c <bmk7_setup>:
  return 0;
}

static void bmk7_setup(void) {

  chSemInit(&sem1, 0);
    503c:	8c ee       	ldi	r24, 0xEC	; 236
    503e:	9a e0       	ldi	r25, 0x0A	; 10
    5040:	60 e0       	ldi	r22, 0x00	; 0
    5042:	0e 94 93 04 	call	0x926	; 0x926 <chSemInit>
}
    5046:	08 95       	ret

00005048 <bmk10_execute>:
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
    5048:	ef 92       	push	r14
    504a:	ff 92       	push	r15
    504c:	0f 93       	push	r16
    504e:	1f 93       	push	r17
  static VirtualTimer vt1, vt2;
  uint32_t n = 0;

  test_wait_tick();
    5050:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  test_start_timer(1000);
    5054:	88 ee       	ldi	r24, 0xE8	; 232
    5056:	93 e0       	ldi	r25, 0x03	; 3
    5058:	0e 94 53 10 	call	0x20a6	; 0x20a6 <test_start_timer>
    505c:	ee 24       	eor	r14, r14
    505e:	ff 24       	eor	r15, r15
    5060:	87 01       	movw	r16, r14
  do {
    chSysLock();
    5062:	f8 94       	cli
    chVTSetI(&vt1, 1, tmo, NULL);
    5064:	80 ec       	ldi	r24, 0xC0	; 192
    5066:	9a e0       	ldi	r25, 0x0A	; 10
    5068:	61 e0       	ldi	r22, 0x01	; 1
    506a:	70 e0       	ldi	r23, 0x00	; 0
    506c:	44 ee       	ldi	r20, 0xE4	; 228
    506e:	56 e2       	ldi	r21, 0x26	; 38
    5070:	20 e0       	ldi	r18, 0x00	; 0
    5072:	30 e0       	ldi	r19, 0x00	; 0
    5074:	0e 94 4b 01 	call	0x296	; 0x296 <chVTSetI>
    chVTSetI(&vt2, 10000, tmo, NULL);
    5078:	86 eb       	ldi	r24, 0xB6	; 182
    507a:	9a e0       	ldi	r25, 0x0A	; 10
    507c:	60 e1       	ldi	r22, 0x10	; 16
    507e:	77 e2       	ldi	r23, 0x27	; 39
    5080:	44 ee       	ldi	r20, 0xE4	; 228
    5082:	56 e2       	ldi	r21, 0x26	; 38
    5084:	20 e0       	ldi	r18, 0x00	; 0
    5086:	30 e0       	ldi	r19, 0x00	; 0
    5088:	0e 94 4b 01 	call	0x296	; 0x296 <chVTSetI>
    chVTResetI(&vt1);
    508c:	80 ec       	ldi	r24, 0xC0	; 192
    508e:	9a e0       	ldi	r25, 0x0A	; 10
    5090:	0e 94 8a 01 	call	0x314	; 0x314 <chVTResetI>
    chVTResetI(&vt2);
    5094:	86 eb       	ldi	r24, 0xB6	; 182
    5096:	9a e0       	ldi	r25, 0x0A	; 10
    5098:	0e 94 8a 01 	call	0x314	; 0x314 <chVTResetI>
    chSysUnlock();
    509c:	78 94       	sei
    n++;
    509e:	08 94       	sec
    50a0:	e1 1c       	adc	r14, r1
    50a2:	f1 1c       	adc	r15, r1
    50a4:	01 1d       	adc	r16, r1
    50a6:	11 1d       	adc	r17, r1
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    50a8:	80 91 00 0c 	lds	r24, 0x0C00
    50ac:	88 23       	and	r24, r24
    50ae:	c9 f2       	breq	.-78     	; 0x5062 <bmk10_execute+0x1a>
  test_print("--- Score : ");
    50b0:	8f e2       	ldi	r24, 0x2F	; 47
    50b2:	97 e0       	ldi	r25, 0x07	; 7
    50b4:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n * 2);
    50b8:	ee 0c       	add	r14, r14
    50ba:	ff 1c       	adc	r15, r15
    50bc:	00 1f       	adc	r16, r16
    50be:	11 1f       	adc	r17, r17
    50c0:	c8 01       	movw	r24, r16
    50c2:	b7 01       	movw	r22, r14
    50c4:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" timers/S");
    50c8:	8a e5       	ldi	r24, 0x5A	; 90
    50ca:	97 e0       	ldi	r25, 0x07	; 7
    50cc:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    50d0:	1f 91       	pop	r17
    50d2:	0f 91       	pop	r16
    50d4:	ff 90       	pop	r15
    50d6:	ef 90       	pop	r14
    50d8:	08 95       	ret

000050da <bmk9_execute>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
    50da:	ef 92       	push	r14
    50dc:	ff 92       	push	r15
    50de:	0f 93       	push	r16
    50e0:	1f 93       	push	r17
  uint32_t n;
  static uint8_t ib[16];
  static InputQueue iq;

  chIQInit(&iq, ib, sizeof(ib), NULL, NULL);
    50e2:	8a ec       	ldi	r24, 0xCA	; 202
    50e4:	9a e0       	ldi	r25, 0x0A	; 10
    50e6:	6c ed       	ldi	r22, 0xDC	; 220
    50e8:	7a e0       	ldi	r23, 0x0A	; 10
    50ea:	40 e1       	ldi	r20, 0x10	; 16
    50ec:	50 e0       	ldi	r21, 0x00	; 0
    50ee:	20 e0       	ldi	r18, 0x00	; 0
    50f0:	30 e0       	ldi	r19, 0x00	; 0
    50f2:	00 e0       	ldi	r16, 0x00	; 0
    50f4:	10 e0       	ldi	r17, 0x00	; 0
    50f6:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <chIQInit>
  n = 0;
  test_wait_tick();
    50fa:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  test_start_timer(1000);
    50fe:	88 ee       	ldi	r24, 0xE8	; 232
    5100:	93 e0       	ldi	r25, 0x03	; 3
    5102:	0e 94 53 10 	call	0x20a6	; 0x20a6 <test_start_timer>
    5106:	ee 24       	eor	r14, r14
    5108:	ff 24       	eor	r15, r15
    510a:	87 01       	movw	r16, r14
  do {
    chSysLock();
    510c:	f8 94       	cli
    chIQPutI(&iq, 0);
    510e:	8a ec       	ldi	r24, 0xCA	; 202
    5110:	9a e0       	ldi	r25, 0x0A	; 10
    5112:	60 e0       	ldi	r22, 0x00	; 0
    5114:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
    chIQPutI(&iq, 1);
    5118:	8a ec       	ldi	r24, 0xCA	; 202
    511a:	9a e0       	ldi	r25, 0x0A	; 10
    511c:	61 e0       	ldi	r22, 0x01	; 1
    511e:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
    chIQPutI(&iq, 2);
    5122:	8a ec       	ldi	r24, 0xCA	; 202
    5124:	9a e0       	ldi	r25, 0x0A	; 10
    5126:	62 e0       	ldi	r22, 0x02	; 2
    5128:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
    chIQPutI(&iq, 3);
    512c:	8a ec       	ldi	r24, 0xCA	; 202
    512e:	9a e0       	ldi	r25, 0x0A	; 10
    5130:	63 e0       	ldi	r22, 0x03	; 3
    5132:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
    chSysUnlock();
    5136:	78 94       	sei
    (void)chIQGet(&iq);
    5138:	8a ec       	ldi	r24, 0xCA	; 202
    513a:	9a e0       	ldi	r25, 0x0A	; 10
    513c:	6f ef       	ldi	r22, 0xFF	; 255
    513e:	7f ef       	ldi	r23, 0xFF	; 255
    5140:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <chIQGetTimeout>
    (void)chIQGet(&iq);
    5144:	8a ec       	ldi	r24, 0xCA	; 202
    5146:	9a e0       	ldi	r25, 0x0A	; 10
    5148:	6f ef       	ldi	r22, 0xFF	; 255
    514a:	7f ef       	ldi	r23, 0xFF	; 255
    514c:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <chIQGetTimeout>
    (void)chIQGet(&iq);
    5150:	8a ec       	ldi	r24, 0xCA	; 202
    5152:	9a e0       	ldi	r25, 0x0A	; 10
    5154:	6f ef       	ldi	r22, 0xFF	; 255
    5156:	7f ef       	ldi	r23, 0xFF	; 255
    5158:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <chIQGetTimeout>
    (void)chIQGet(&iq);
    515c:	8a ec       	ldi	r24, 0xCA	; 202
    515e:	9a e0       	ldi	r25, 0x0A	; 10
    5160:	6f ef       	ldi	r22, 0xFF	; 255
    5162:	7f ef       	ldi	r23, 0xFF	; 255
    5164:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <chIQGetTimeout>
    n++;
    5168:	08 94       	sec
    516a:	e1 1c       	adc	r14, r1
    516c:	f1 1c       	adc	r15, r1
    516e:	01 1d       	adc	r16, r1
    5170:	11 1d       	adc	r17, r1
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    5172:	80 91 00 0c 	lds	r24, 0x0C00
    5176:	88 23       	and	r24, r24
    5178:	49 f2       	breq	.-110    	; 0x510c <bmk9_execute+0x32>
  test_print("--- Score : ");
    517a:	8f e2       	ldi	r24, 0x2F	; 47
    517c:	97 e0       	ldi	r25, 0x07	; 7
    517e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n * 4);
    5182:	ee 0c       	add	r14, r14
    5184:	ff 1c       	adc	r15, r15
    5186:	00 1f       	adc	r16, r16
    5188:	11 1f       	adc	r17, r17
    518a:	ee 0c       	add	r14, r14
    518c:	ff 1c       	adc	r15, r15
    518e:	00 1f       	adc	r16, r16
    5190:	11 1f       	adc	r17, r17
    5192:	c8 01       	movw	r24, r16
    5194:	b7 01       	movw	r22, r14
    5196:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" bytes/S");
    519a:	84 e6       	ldi	r24, 0x64	; 100
    519c:	97 e0       	ldi	r25, 0x07	; 7
    519e:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    51a2:	1f 91       	pop	r17
    51a4:	0f 91       	pop	r16
    51a6:	ff 90       	pop	r15
    51a8:	ef 90       	pop	r14
    51aa:	08 95       	ret

000051ac <bmk6_execute>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
    51ac:	bf 92       	push	r11
    51ae:	cf 92       	push	r12
    51b0:	df 92       	push	r13
    51b2:	ef 92       	push	r14
    51b4:	ff 92       	push	r15
    51b6:	0f 93       	push	r16
    51b8:	1f 93       	push	r17
    51ba:	cf 93       	push	r28
    51bc:	df 93       	push	r29

  uint32_t n = 0;
  void *wap = wa[0];
    51be:	c0 91 95 02 	lds	r28, 0x0295
    51c2:	d0 91 96 02 	lds	r29, 0x0296
  tprio_t prio = chThdGetPriority() + 1;
    51c6:	e0 91 fe 0b 	lds	r30, 0x0BFE
    51ca:	f0 91 ff 0b 	lds	r31, 0x0BFF
    51ce:	b4 80       	ldd	r11, Z+4	; 0x04
    51d0:	b3 94       	inc	r11
  test_wait_tick();
    51d2:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  test_start_timer(1000);
    51d6:	88 ee       	ldi	r24, 0xE8	; 232
    51d8:	93 e0       	ldi	r25, 0x03	; 3
    51da:	0e 94 53 10 	call	0x20a6	; 0x20a6 <test_start_timer>
    51de:	cc 24       	eor	r12, r12
    51e0:	dd 24       	eor	r13, r13
    51e2:	76 01       	movw	r14, r12
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread2, NULL);
    51e4:	ce 01       	movw	r24, r28
    51e6:	65 e9       	ldi	r22, 0x95	; 149
    51e8:	70 e0       	ldi	r23, 0x00	; 0
    51ea:	4b 2d       	mov	r20, r11
    51ec:	23 ee       	ldi	r18, 0xE3	; 227
    51ee:	36 e2       	ldi	r19, 0x26	; 38
    51f0:	00 e0       	ldi	r16, 0x00	; 0
    51f2:	10 e0       	ldi	r17, 0x00	; 0
    51f4:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    n++;
    51f8:	08 94       	sec
    51fa:	c1 1c       	adc	r12, r1
    51fc:	d1 1c       	adc	r13, r1
    51fe:	e1 1c       	adc	r14, r1
    5200:	f1 1c       	adc	r15, r1
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    5202:	80 91 00 0c 	lds	r24, 0x0C00
    5206:	88 23       	and	r24, r24
    5208:	69 f3       	breq	.-38     	; 0x51e4 <bmk6_execute+0x38>
  test_print("--- Score : ");
    520a:	8f e2       	ldi	r24, 0x2F	; 47
    520c:	97 e0       	ldi	r25, 0x07	; 7
    520e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n);
    5212:	c7 01       	movw	r24, r14
    5214:	b6 01       	movw	r22, r12
    5216:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" threads/S");
    521a:	8d e6       	ldi	r24, 0x6D	; 109
    521c:	97 e0       	ldi	r25, 0x07	; 7
    521e:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    5222:	df 91       	pop	r29
    5224:	cf 91       	pop	r28
    5226:	1f 91       	pop	r17
    5228:	0f 91       	pop	r16
    522a:	ff 90       	pop	r15
    522c:	ef 90       	pop	r14
    522e:	df 90       	pop	r13
    5230:	cf 90       	pop	r12
    5232:	bf 90       	pop	r11
    5234:	08 95       	ret

00005236 <bmk8_execute>:
#endif
  } while(!chThdShouldTerminate());
  return 0;
}

static void bmk8_execute(void) {
    5236:	cf 92       	push	r12
    5238:	df 92       	push	r13
    523a:	ef 92       	push	r14
    523c:	ff 92       	push	r15
    523e:	0f 93       	push	r16
    5240:	1f 93       	push	r17
    5242:	df 93       	push	r29
    5244:	cf 93       	push	r28
    5246:	00 d0       	rcall	.+0      	; 0x5248 <bmk8_execute+0x12>
    5248:	00 d0       	rcall	.+0      	; 0x524a <bmk8_execute+0x14>
    524a:	cd b7       	in	r28, 0x3d	; 61
    524c:	de b7       	in	r29, 0x3e	; 62
  uint32_t n;

  n = 0;
    524e:	19 82       	std	Y+1, r1	; 0x01
    5250:	1a 82       	std	Y+2, r1	; 0x02
    5252:	1b 82       	std	Y+3, r1	; 0x03
    5254:	1c 82       	std	Y+4, r1	; 0x04
  test_wait_tick();
    5256:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-1, thread8, (void *)&n);
    525a:	e0 91 fe 0b 	lds	r30, 0x0BFE
    525e:	f0 91 ff 0b 	lds	r31, 0x0BFF
    5262:	44 81       	ldd	r20, Z+4	; 0x04
    5264:	41 50       	subi	r20, 0x01	; 1
    5266:	58 eb       	ldi	r21, 0xB8	; 184
    5268:	c5 2e       	mov	r12, r21
    526a:	59 e2       	ldi	r21, 0x29	; 41
    526c:	d5 2e       	mov	r13, r21
    526e:	80 91 95 02 	lds	r24, 0x0295
    5272:	90 91 96 02 	lds	r25, 0x0296
    5276:	65 e9       	ldi	r22, 0x95	; 149
    5278:	70 e0       	ldi	r23, 0x00	; 0
    527a:	96 01       	movw	r18, r12
    527c:	7e 01       	movw	r14, r28
    527e:	08 94       	sec
    5280:	e1 1c       	adc	r14, r1
    5282:	f1 1c       	adc	r15, r1
    5284:	87 01       	movw	r16, r14
    5286:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    528a:	90 93 02 0c 	sts	0x0C02, r25
    528e:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-1, thread8, (void *)&n);
    5292:	e0 91 fe 0b 	lds	r30, 0x0BFE
    5296:	f0 91 ff 0b 	lds	r31, 0x0BFF
    529a:	44 81       	ldd	r20, Z+4	; 0x04
    529c:	41 50       	subi	r20, 0x01	; 1
    529e:	80 91 97 02 	lds	r24, 0x0297
    52a2:	90 91 98 02 	lds	r25, 0x0298
    52a6:	65 e9       	ldi	r22, 0x95	; 149
    52a8:	70 e0       	ldi	r23, 0x00	; 0
    52aa:	96 01       	movw	r18, r12
    52ac:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    52b0:	90 93 04 0c 	sts	0x0C04, r25
    52b4:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-1, thread8, (void *)&n);
    52b8:	e0 91 fe 0b 	lds	r30, 0x0BFE
    52bc:	f0 91 ff 0b 	lds	r31, 0x0BFF
    52c0:	44 81       	ldd	r20, Z+4	; 0x04
    52c2:	41 50       	subi	r20, 0x01	; 1
    52c4:	80 91 99 02 	lds	r24, 0x0299
    52c8:	90 91 9a 02 	lds	r25, 0x029A
    52cc:	65 e9       	ldi	r22, 0x95	; 149
    52ce:	70 e0       	ldi	r23, 0x00	; 0
    52d0:	96 01       	movw	r18, r12
    52d2:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    52d6:	90 93 06 0c 	sts	0x0C06, r25
    52da:	80 93 05 0c 	sts	0x0C05, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-1, thread8, (void *)&n);
    52de:	e0 91 fe 0b 	lds	r30, 0x0BFE
    52e2:	f0 91 ff 0b 	lds	r31, 0x0BFF
    52e6:	44 81       	ldd	r20, Z+4	; 0x04
    52e8:	41 50       	subi	r20, 0x01	; 1
    52ea:	80 91 9b 02 	lds	r24, 0x029B
    52ee:	90 91 9c 02 	lds	r25, 0x029C
    52f2:	65 e9       	ldi	r22, 0x95	; 149
    52f4:	70 e0       	ldi	r23, 0x00	; 0
    52f6:	96 01       	movw	r18, r12
    52f8:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    52fc:	90 93 08 0c 	sts	0x0C08, r25
    5300:	80 93 07 0c 	sts	0x0C07, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread8, (void *)&n);
    5304:	e0 91 fe 0b 	lds	r30, 0x0BFE
    5308:	f0 91 ff 0b 	lds	r31, 0x0BFF
    530c:	44 81       	ldd	r20, Z+4	; 0x04
    530e:	41 50       	subi	r20, 0x01	; 1
    5310:	80 91 9d 02 	lds	r24, 0x029D
    5314:	90 91 9e 02 	lds	r25, 0x029E
    5318:	65 e9       	ldi	r22, 0x95	; 149
    531a:	70 e0       	ldi	r23, 0x00	; 0
    531c:	96 01       	movw	r18, r12
    531e:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5322:	90 93 0a 0c 	sts	0x0C0A, r25
    5326:	80 93 09 0c 	sts	0x0C09, r24

  chThdSleepSeconds(1);
    532a:	88 ee       	ldi	r24, 0xE8	; 232
    532c:	93 e0       	ldi	r25, 0x03	; 3
    532e:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  test_terminate_threads();
    5332:	0e 94 cc 11 	call	0x2398	; 0x2398 <test_terminate_threads>
  test_wait_threads();
    5336:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>

  test_print("--- Score : ");
    533a:	8f e2       	ldi	r24, 0x2F	; 47
    533c:	97 e0       	ldi	r25, 0x07	; 7
    533e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n);
    5342:	69 81       	ldd	r22, Y+1	; 0x01
    5344:	7a 81       	ldd	r23, Y+2	; 0x02
    5346:	8b 81       	ldd	r24, Y+3	; 0x03
    5348:	9c 81       	ldd	r25, Y+4	; 0x04
    534a:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" ctxswc/S");
    534e:	88 e7       	ldi	r24, 0x78	; 120
    5350:	97 e0       	ldi	r25, 0x07	; 7
    5352:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    5356:	0f 90       	pop	r0
    5358:	0f 90       	pop	r0
    535a:	0f 90       	pop	r0
    535c:	0f 90       	pop	r0
    535e:	cf 91       	pop	r28
    5360:	df 91       	pop	r29
    5362:	1f 91       	pop	r17
    5364:	0f 91       	pop	r16
    5366:	ff 90       	pop	r15
    5368:	ef 90       	pop	r14
    536a:	df 90       	pop	r13
    536c:	cf 90       	pop	r12
    536e:	08 95       	ret

00005370 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static msg_t thread8(void *p) {
    5370:	cf 93       	push	r28
    5372:	df 93       	push	r29
    5374:	ec 01       	movw	r28, r24

  do {
    chThdYield();
    5376:	0e 94 23 04 	call	0x846	; 0x846 <chThdYield>
    chThdYield();
    537a:	0e 94 23 04 	call	0x846	; 0x846 <chThdYield>
    chThdYield();
    537e:	0e 94 23 04 	call	0x846	; 0x846 <chThdYield>
    chThdYield();
    5382:	0e 94 23 04 	call	0x846	; 0x846 <chThdYield>
    (*(uint32_t *)p) += 4;
    5386:	88 81       	ld	r24, Y
    5388:	99 81       	ldd	r25, Y+1	; 0x01
    538a:	aa 81       	ldd	r26, Y+2	; 0x02
    538c:	bb 81       	ldd	r27, Y+3	; 0x03
    538e:	04 96       	adiw	r24, 0x04	; 4
    5390:	a1 1d       	adc	r26, r1
    5392:	b1 1d       	adc	r27, r1
    5394:	88 83       	st	Y, r24
    5396:	99 83       	std	Y+1, r25	; 0x01
    5398:	aa 83       	std	Y+2, r26	; 0x02
    539a:	bb 83       	std	Y+3, r27	; 0x03
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while(!chThdShouldTerminate());
    539c:	e0 91 fe 0b 	lds	r30, 0x0BFE
    53a0:	f0 91 ff 0b 	lds	r31, 0x0BFF
    53a4:	86 85       	ldd	r24, Z+14	; 0x0e
    53a6:	82 ff       	sbrs	r24, 2
    53a8:	e6 cf       	rjmp	.-52     	; 0x5376 <thread8+0x6>
  return 0;
}
    53aa:	80 e0       	ldi	r24, 0x00	; 0
    53ac:	90 e0       	ldi	r25, 0x00	; 0
    53ae:	df 91       	pop	r29
    53b0:	cf 91       	pop	r28
    53b2:	08 95       	ret

000053b4 <bmk7_execute>:
static void bmk7_setup(void) {

  chSemInit(&sem1, 0);
}

static void bmk7_execute(void) {
    53b4:	ef 92       	push	r14
    53b6:	ff 92       	push	r15
    53b8:	0f 93       	push	r16
    53ba:	1f 93       	push	r17
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+5, thread3, NULL);
    53bc:	e0 91 fe 0b 	lds	r30, 0x0BFE
    53c0:	f0 91 ff 0b 	lds	r31, 0x0BFF
    53c4:	44 81       	ldd	r20, Z+4	; 0x04
    53c6:	4b 5f       	subi	r20, 0xFB	; 251
    53c8:	80 91 95 02 	lds	r24, 0x0295
    53cc:	90 91 96 02 	lds	r25, 0x0296
    53d0:	65 e9       	ldi	r22, 0x95	; 149
    53d2:	70 e0       	ldi	r23, 0x00	; 0
    53d4:	2a eb       	ldi	r18, 0xBA	; 186
    53d6:	37 e2       	ldi	r19, 0x27	; 39
    53d8:	00 e0       	ldi	r16, 0x00	; 0
    53da:	10 e0       	ldi	r17, 0x00	; 0
    53dc:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    53e0:	90 93 02 0c 	sts	0x0C02, r25
    53e4:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()+4, thread3, NULL);
    53e8:	e0 91 fe 0b 	lds	r30, 0x0BFE
    53ec:	f0 91 ff 0b 	lds	r31, 0x0BFF
    53f0:	44 81       	ldd	r20, Z+4	; 0x04
    53f2:	4c 5f       	subi	r20, 0xFC	; 252
    53f4:	80 91 97 02 	lds	r24, 0x0297
    53f8:	90 91 98 02 	lds	r25, 0x0298
    53fc:	65 e9       	ldi	r22, 0x95	; 149
    53fe:	70 e0       	ldi	r23, 0x00	; 0
    5400:	2a eb       	ldi	r18, 0xBA	; 186
    5402:	37 e2       	ldi	r19, 0x27	; 39
    5404:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5408:	90 93 04 0c 	sts	0x0C04, r25
    540c:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()+3, thread3, NULL);
    5410:	e0 91 fe 0b 	lds	r30, 0x0BFE
    5414:	f0 91 ff 0b 	lds	r31, 0x0BFF
    5418:	44 81       	ldd	r20, Z+4	; 0x04
    541a:	4d 5f       	subi	r20, 0xFD	; 253
    541c:	80 91 99 02 	lds	r24, 0x0299
    5420:	90 91 9a 02 	lds	r25, 0x029A
    5424:	65 e9       	ldi	r22, 0x95	; 149
    5426:	70 e0       	ldi	r23, 0x00	; 0
    5428:	2a eb       	ldi	r18, 0xBA	; 186
    542a:	37 e2       	ldi	r19, 0x27	; 39
    542c:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5430:	90 93 06 0c 	sts	0x0C06, r25
    5434:	80 93 05 0c 	sts	0x0C05, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()+2, thread3, NULL);
    5438:	e0 91 fe 0b 	lds	r30, 0x0BFE
    543c:	f0 91 ff 0b 	lds	r31, 0x0BFF
    5440:	44 81       	ldd	r20, Z+4	; 0x04
    5442:	4e 5f       	subi	r20, 0xFE	; 254
    5444:	80 91 9b 02 	lds	r24, 0x029B
    5448:	90 91 9c 02 	lds	r25, 0x029C
    544c:	65 e9       	ldi	r22, 0x95	; 149
    544e:	70 e0       	ldi	r23, 0x00	; 0
    5450:	2a eb       	ldi	r18, 0xBA	; 186
    5452:	37 e2       	ldi	r19, 0x27	; 39
    5454:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5458:	90 93 08 0c 	sts	0x0C08, r25
    545c:	80 93 07 0c 	sts	0x0C07, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()+1, thread3, NULL);
    5460:	e0 91 fe 0b 	lds	r30, 0x0BFE
    5464:	f0 91 ff 0b 	lds	r31, 0x0BFF
    5468:	44 81       	ldd	r20, Z+4	; 0x04
    546a:	4f 5f       	subi	r20, 0xFF	; 255
    546c:	80 91 9d 02 	lds	r24, 0x029D
    5470:	90 91 9e 02 	lds	r25, 0x029E
    5474:	65 e9       	ldi	r22, 0x95	; 149
    5476:	70 e0       	ldi	r23, 0x00	; 0
    5478:	2a eb       	ldi	r18, 0xBA	; 186
    547a:	37 e2       	ldi	r19, 0x27	; 39
    547c:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5480:	90 93 0a 0c 	sts	0x0C0A, r25
    5484:	80 93 09 0c 	sts	0x0C09, r24

  n = 0;
  test_wait_tick();
    5488:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  test_start_timer(1000);
    548c:	88 ee       	ldi	r24, 0xE8	; 232
    548e:	93 e0       	ldi	r25, 0x03	; 3
    5490:	0e 94 53 10 	call	0x20a6	; 0x20a6 <test_start_timer>
    5494:	ee 24       	eor	r14, r14
    5496:	ff 24       	eor	r15, r15
    5498:	87 01       	movw	r16, r14
  do {
    chSemReset(&sem1, 0);
    549a:	8c ee       	ldi	r24, 0xEC	; 236
    549c:	9a e0       	ldi	r25, 0x0A	; 10
    549e:	60 e0       	ldi	r22, 0x00	; 0
    54a0:	0e 94 97 05 	call	0xb2e	; 0xb2e <chSemReset>
    n++;
    54a4:	08 94       	sec
    54a6:	e1 1c       	adc	r14, r1
    54a8:	f1 1c       	adc	r15, r1
    54aa:	01 1d       	adc	r16, r1
    54ac:	11 1d       	adc	r17, r1
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    54ae:	80 91 00 0c 	lds	r24, 0x0C00
    54b2:	88 23       	and	r24, r24
    54b4:	91 f3       	breq	.-28     	; 0x549a <bmk7_execute+0xe6>
  test_terminate_threads();
    54b6:	0e 94 cc 11 	call	0x2398	; 0x2398 <test_terminate_threads>
  chSemReset(&sem1, 0);
    54ba:	8c ee       	ldi	r24, 0xEC	; 236
    54bc:	9a e0       	ldi	r25, 0x0A	; 10
    54be:	60 e0       	ldi	r22, 0x00	; 0
    54c0:	0e 94 97 05 	call	0xb2e	; 0xb2e <chSemReset>
  test_wait_threads();
    54c4:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>

  test_print("--- Score : ");
    54c8:	8f e2       	ldi	r24, 0x2F	; 47
    54ca:	97 e0       	ldi	r25, 0x07	; 7
    54cc:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n);
    54d0:	c8 01       	movw	r24, r16
    54d2:	b7 01       	movw	r22, r14
    54d4:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_print(" reschedules/S, ");
    54d8:	82 e8       	ldi	r24, 0x82	; 130
    54da:	97 e0       	ldi	r25, 0x07	; 7
    54dc:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n * 6);
    54e0:	c8 01       	movw	r24, r16
    54e2:	b7 01       	movw	r22, r14
    54e4:	26 e0       	ldi	r18, 0x06	; 6
    54e6:	30 e0       	ldi	r19, 0x00	; 0
    54e8:	40 e0       	ldi	r20, 0x00	; 0
    54ea:	50 e0       	ldi	r21, 0x00	; 0
    54ec:	0e 94 10 33 	call	0x6620	; 0x6620 <__mulsi3>
    54f0:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" ctxswc/S");
    54f4:	88 e7       	ldi	r24, 0x78	; 120
    54f6:	97 e0       	ldi	r25, 0x07	; 7
    54f8:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    54fc:	1f 91       	pop	r17
    54fe:	0f 91       	pop	r16
    5500:	ff 90       	pop	r15
    5502:	ef 90       	pop	r14
    5504:	08 95       	ret

00005506 <bmk5_execute>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
    5506:	bf 92       	push	r11
    5508:	cf 92       	push	r12
    550a:	df 92       	push	r13
    550c:	ef 92       	push	r14
    550e:	ff 92       	push	r15
    5510:	0f 93       	push	r16
    5512:	1f 93       	push	r17
    5514:	cf 93       	push	r28
    5516:	df 93       	push	r29

  uint32_t n = 0;
  void *wap = wa[0];
    5518:	c0 91 95 02 	lds	r28, 0x0295
    551c:	d0 91 96 02 	lds	r29, 0x0296
  tprio_t prio = chThdGetPriority() - 1;
    5520:	e0 91 fe 0b 	lds	r30, 0x0BFE
    5524:	f0 91 ff 0b 	lds	r31, 0x0BFF
    5528:	b4 80       	ldd	r11, Z+4	; 0x04
    552a:	ba 94       	dec	r11
  test_wait_tick();
    552c:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  test_start_timer(1000);
    5530:	88 ee       	ldi	r24, 0xE8	; 232
    5532:	93 e0       	ldi	r25, 0x03	; 3
    5534:	0e 94 53 10 	call	0x20a6	; 0x20a6 <test_start_timer>
    5538:	cc 24       	eor	r12, r12
    553a:	dd 24       	eor	r13, r13
    553c:	76 01       	movw	r14, r12
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread2, NULL));
    553e:	ce 01       	movw	r24, r28
    5540:	65 e9       	ldi	r22, 0x95	; 149
    5542:	70 e0       	ldi	r23, 0x00	; 0
    5544:	4b 2d       	mov	r20, r11
    5546:	23 ee       	ldi	r18, 0xE3	; 227
    5548:	36 e2       	ldi	r19, 0x26	; 38
    554a:	00 e0       	ldi	r16, 0x00	; 0
    554c:	10 e0       	ldi	r17, 0x00	; 0
    554e:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5552:	0e 94 cd 03 	call	0x79a	; 0x79a <chThdWait>
    n++;
    5556:	08 94       	sec
    5558:	c1 1c       	adc	r12, r1
    555a:	d1 1c       	adc	r13, r1
    555c:	e1 1c       	adc	r14, r1
    555e:	f1 1c       	adc	r15, r1
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    5560:	80 91 00 0c 	lds	r24, 0x0C00
    5564:	88 23       	and	r24, r24
    5566:	59 f3       	breq	.-42     	; 0x553e <bmk5_execute+0x38>
  test_print("--- Score : ");
    5568:	8f e2       	ldi	r24, 0x2F	; 47
    556a:	97 e0       	ldi	r25, 0x07	; 7
    556c:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n);
    5570:	c7 01       	movw	r24, r14
    5572:	b6 01       	movw	r22, r12
    5574:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" threads/S");
    5578:	8d e6       	ldi	r24, 0x6D	; 109
    557a:	97 e0       	ldi	r25, 0x07	; 7
    557c:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    5580:	df 91       	pop	r29
    5582:	cf 91       	pop	r28
    5584:	1f 91       	pop	r17
    5586:	0f 91       	pop	r16
    5588:	ff 90       	pop	r15
    558a:	ef 90       	pop	r14
    558c:	df 90       	pop	r13
    558e:	cf 90       	pop	r12
    5590:	bf 90       	pop	r11
    5592:	08 95       	ret

00005594 <bmk4_execute>:
  } while (msg == RDY_OK);
  chSysUnlock();
  return 0;
}

static void bmk4_execute(void) {
    5594:	cf 92       	push	r12
    5596:	df 92       	push	r13
    5598:	ef 92       	push	r14
    559a:	ff 92       	push	r15
    559c:	0f 93       	push	r16
    559e:	1f 93       	push	r17
  Thread *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread4, NULL);
    55a0:	e0 91 fe 0b 	lds	r30, 0x0BFE
    55a4:	f0 91 ff 0b 	lds	r31, 0x0BFF
    55a8:	44 81       	ldd	r20, Z+4	; 0x04
    55aa:	4f 5f       	subi	r20, 0xFF	; 255
    55ac:	80 91 95 02 	lds	r24, 0x0295
    55b0:	90 91 96 02 	lds	r25, 0x0296
    55b4:	65 e9       	ldi	r22, 0x95	; 149
    55b6:	70 e0       	ldi	r23, 0x00	; 0
    55b8:	2c e7       	ldi	r18, 0x7C	; 124
    55ba:	3c e2       	ldi	r19, 0x2C	; 44
    55bc:	00 e0       	ldi	r16, 0x00	; 0
    55be:	10 e0       	ldi	r17, 0x00	; 0
    55c0:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    55c4:	8c 01       	movw	r16, r24
    55c6:	90 93 02 0c 	sts	0x0C02, r25
    55ca:	80 93 01 0c 	sts	0x0C01, r24
  n = 0;
  test_wait_tick();
    55ce:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  test_start_timer(1000);
    55d2:	88 ee       	ldi	r24, 0xE8	; 232
    55d4:	93 e0       	ldi	r25, 0x03	; 3
    55d6:	0e 94 53 10 	call	0x20a6	; 0x20a6 <test_start_timer>
    55da:	cc 24       	eor	r12, r12
    55dc:	dd 24       	eor	r13, r13
    55de:	76 01       	movw	r14, r12
  do {
    chSysLock();
    55e0:	f8 94       	cli
    chSchWakeupS(tp, RDY_OK);
    55e2:	c8 01       	movw	r24, r16
    55e4:	60 e0       	ldi	r22, 0x00	; 0
    55e6:	70 e0       	ldi	r23, 0x00	; 0
    55e8:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
    chSchWakeupS(tp, RDY_OK);
    55ec:	c8 01       	movw	r24, r16
    55ee:	60 e0       	ldi	r22, 0x00	; 0
    55f0:	70 e0       	ldi	r23, 0x00	; 0
    55f2:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
    chSchWakeupS(tp, RDY_OK);
    55f6:	c8 01       	movw	r24, r16
    55f8:	60 e0       	ldi	r22, 0x00	; 0
    55fa:	70 e0       	ldi	r23, 0x00	; 0
    55fc:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
    chSchWakeupS(tp, RDY_OK);
    5600:	c8 01       	movw	r24, r16
    5602:	60 e0       	ldi	r22, 0x00	; 0
    5604:	70 e0       	ldi	r23, 0x00	; 0
    5606:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
    chSysUnlock();
    560a:	78 94       	sei
    n += 4;
    560c:	84 e0       	ldi	r24, 0x04	; 4
    560e:	90 e0       	ldi	r25, 0x00	; 0
    5610:	a0 e0       	ldi	r26, 0x00	; 0
    5612:	b0 e0       	ldi	r27, 0x00	; 0
    5614:	c8 0e       	add	r12, r24
    5616:	d9 1e       	adc	r13, r25
    5618:	ea 1e       	adc	r14, r26
    561a:	fb 1e       	adc	r15, r27
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    561c:	80 91 00 0c 	lds	r24, 0x0C00
    5620:	88 23       	and	r24, r24
    5622:	f1 f2       	breq	.-68     	; 0x55e0 <bmk4_execute+0x4c>
  chSysLock();
    5624:	f8 94       	cli
  chSchWakeupS(tp, RDY_TIMEOUT);
    5626:	c8 01       	movw	r24, r16
    5628:	6f ef       	ldi	r22, 0xFF	; 255
    562a:	7f ef       	ldi	r23, 0xFF	; 255
    562c:	0e 94 db 02 	call	0x5b6	; 0x5b6 <chSchWakeupS>
  chSysUnlock();
    5630:	78 94       	sei

  test_wait_threads();
    5632:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_print("--- Score : ");
    5636:	8f e2       	ldi	r24, 0x2F	; 47
    5638:	97 e0       	ldi	r25, 0x07	; 7
    563a:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n * 2);
    563e:	cc 0c       	add	r12, r12
    5640:	dd 1c       	adc	r13, r13
    5642:	ee 1c       	adc	r14, r14
    5644:	ff 1c       	adc	r15, r15
    5646:	c7 01       	movw	r24, r14
    5648:	b6 01       	movw	r22, r12
    564a:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" ctxswc/S");
    564e:	88 e7       	ldi	r24, 0x78	; 120
    5650:	97 e0       	ldi	r25, 0x07	; 7
    5652:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    5656:	1f 91       	pop	r17
    5658:	0f 91       	pop	r16
    565a:	ff 90       	pop	r15
    565c:	ef 90       	pop	r14
    565e:	df 90       	pop	r13
    5660:	cf 90       	pop	r12
    5662:	08 95       	ret

00005664 <msg_loop_test>:
}

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(Thread *tp) {
    5664:	ef 92       	push	r14
    5666:	ff 92       	push	r15
    5668:	0f 93       	push	r16
    566a:	1f 93       	push	r17
    566c:	cf 93       	push	r28
    566e:	df 93       	push	r29
    5670:	ec 01       	movw	r28, r24

  uint32_t n = 0;
  test_wait_tick();
    5672:	0e 94 49 10 	call	0x2092	; 0x2092 <test_wait_tick>
  test_start_timer(1000);
    5676:	88 ee       	ldi	r24, 0xE8	; 232
    5678:	93 e0       	ldi	r25, 0x03	; 3
    567a:	0e 94 53 10 	call	0x20a6	; 0x20a6 <test_start_timer>
    567e:	ee 24       	eor	r14, r14
    5680:	ff 24       	eor	r15, r15
    5682:	87 01       	movw	r16, r14
  do {
    (void)chMsgSend(tp, 1);
    5684:	ce 01       	movw	r24, r28
    5686:	61 e0       	ldi	r22, 0x01	; 1
    5688:	70 e0       	ldi	r23, 0x00	; 0
    568a:	0e 94 b5 0a 	call	0x156a	; 0x156a <chMsgSend>
    n++;
    568e:	08 94       	sec
    5690:	e1 1c       	adc	r14, r1
    5692:	f1 1c       	adc	r15, r1
    5694:	01 1d       	adc	r16, r1
    5696:	11 1d       	adc	r17, r1
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    5698:	80 91 00 0c 	lds	r24, 0x0C00
    569c:	88 23       	and	r24, r24
    569e:	91 f3       	breq	.-28     	; 0x5684 <msg_loop_test+0x20>
  (void)chMsgSend(tp, 0);
    56a0:	ce 01       	movw	r24, r28
    56a2:	60 e0       	ldi	r22, 0x00	; 0
    56a4:	70 e0       	ldi	r23, 0x00	; 0
    56a6:	0e 94 b5 0a 	call	0x156a	; 0x156a <chMsgSend>
  return n;
}
    56aa:	c7 01       	movw	r24, r14
    56ac:	df 91       	pop	r29
    56ae:	cf 91       	pop	r28
    56b0:	1f 91       	pop	r17
    56b2:	0f 91       	pop	r16
    56b4:	ff 90       	pop	r15
    56b6:	ef 90       	pop	r14
    56b8:	08 95       	ret

000056ba <bmk3_execute>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
    56ba:	ef 92       	push	r14
    56bc:	ff 92       	push	r15
    56be:	0f 93       	push	r16
    56c0:	1f 93       	push	r17
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread1, NULL);
    56c2:	e0 91 fe 0b 	lds	r30, 0x0BFE
    56c6:	f0 91 ff 0b 	lds	r31, 0x0BFF
    56ca:	44 81       	ldd	r20, Z+4	; 0x04
    56cc:	4f 5f       	subi	r20, 0xFF	; 255
    56ce:	80 91 95 02 	lds	r24, 0x0295
    56d2:	90 91 96 02 	lds	r25, 0x0296
    56d6:	65 e9       	ldi	r22, 0x95	; 149
    56d8:	70 e0       	ldi	r23, 0x00	; 0
    56da:	2b e6       	ldi	r18, 0x6B	; 107
    56dc:	3c e2       	ldi	r19, 0x2C	; 44
    56de:	00 e0       	ldi	r16, 0x00	; 0
    56e0:	10 e0       	ldi	r17, 0x00	; 0
    56e2:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    56e6:	90 93 02 0c 	sts	0x0C02, r25
    56ea:	80 93 01 0c 	sts	0x0C01, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-2, thread2, NULL);
    56ee:	e0 91 fe 0b 	lds	r30, 0x0BFE
    56f2:	f0 91 ff 0b 	lds	r31, 0x0BFF
    56f6:	44 81       	ldd	r20, Z+4	; 0x04
    56f8:	42 50       	subi	r20, 0x02	; 2
    56fa:	e3 ee       	ldi	r30, 0xE3	; 227
    56fc:	ee 2e       	mov	r14, r30
    56fe:	e6 e2       	ldi	r30, 0x26	; 38
    5700:	fe 2e       	mov	r15, r30
    5702:	80 91 97 02 	lds	r24, 0x0297
    5706:	90 91 98 02 	lds	r25, 0x0298
    570a:	65 e9       	ldi	r22, 0x95	; 149
    570c:	70 e0       	ldi	r23, 0x00	; 0
    570e:	97 01       	movw	r18, r14
    5710:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5714:	90 93 04 0c 	sts	0x0C04, r25
    5718:	80 93 03 0c 	sts	0x0C03, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread2, NULL);
    571c:	e0 91 fe 0b 	lds	r30, 0x0BFE
    5720:	f0 91 ff 0b 	lds	r31, 0x0BFF
    5724:	44 81       	ldd	r20, Z+4	; 0x04
    5726:	43 50       	subi	r20, 0x03	; 3
    5728:	80 91 99 02 	lds	r24, 0x0299
    572c:	90 91 9a 02 	lds	r25, 0x029A
    5730:	65 e9       	ldi	r22, 0x95	; 149
    5732:	70 e0       	ldi	r23, 0x00	; 0
    5734:	97 01       	movw	r18, r14
    5736:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    573a:	90 93 06 0c 	sts	0x0C06, r25
    573e:	80 93 05 0c 	sts	0x0C05, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-4, thread2, NULL);
    5742:	e0 91 fe 0b 	lds	r30, 0x0BFE
    5746:	f0 91 ff 0b 	lds	r31, 0x0BFF
    574a:	44 81       	ldd	r20, Z+4	; 0x04
    574c:	44 50       	subi	r20, 0x04	; 4
    574e:	80 91 9b 02 	lds	r24, 0x029B
    5752:	90 91 9c 02 	lds	r25, 0x029C
    5756:	65 e9       	ldi	r22, 0x95	; 149
    5758:	70 e0       	ldi	r23, 0x00	; 0
    575a:	97 01       	movw	r18, r14
    575c:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5760:	90 93 08 0c 	sts	0x0C08, r25
    5764:	80 93 07 0c 	sts	0x0C07, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-5, thread2, NULL);
    5768:	e0 91 fe 0b 	lds	r30, 0x0BFE
    576c:	f0 91 ff 0b 	lds	r31, 0x0BFF
    5770:	44 81       	ldd	r20, Z+4	; 0x04
    5772:	45 50       	subi	r20, 0x05	; 5
    5774:	80 91 9d 02 	lds	r24, 0x029D
    5778:	90 91 9e 02 	lds	r25, 0x029E
    577c:	65 e9       	ldi	r22, 0x95	; 149
    577e:	70 e0       	ldi	r23, 0x00	; 0
    5780:	97 01       	movw	r18, r14
    5782:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5786:	90 93 0a 0c 	sts	0x0C0A, r25
    578a:	80 93 09 0c 	sts	0x0C09, r24
  n = msg_loop_test(threads[0]);
    578e:	80 91 01 0c 	lds	r24, 0x0C01
    5792:	90 91 02 0c 	lds	r25, 0x0C02
    5796:	0e 94 32 2b 	call	0x5664	; 0x5664 <msg_loop_test>
    579a:	7c 01       	movw	r14, r24
    579c:	00 e0       	ldi	r16, 0x00	; 0
    579e:	10 e0       	ldi	r17, 0x00	; 0
  test_wait_threads();
    57a0:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_print("--- Score : ");
    57a4:	8f e2       	ldi	r24, 0x2F	; 47
    57a6:	97 e0       	ldi	r25, 0x07	; 7
    57a8:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n);
    57ac:	c8 01       	movw	r24, r16
    57ae:	b7 01       	movw	r22, r14
    57b0:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_print(" msgs/S, ");
    57b4:	83 e9       	ldi	r24, 0x93	; 147
    57b6:	97 e0       	ldi	r25, 0x07	; 7
    57b8:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n << 1);
    57bc:	ee 0c       	add	r14, r14
    57be:	ff 1c       	adc	r15, r15
    57c0:	00 1f       	adc	r16, r16
    57c2:	11 1f       	adc	r17, r17
    57c4:	c8 01       	movw	r24, r16
    57c6:	b7 01       	movw	r22, r14
    57c8:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" ctxswc/S");
    57cc:	88 e7       	ldi	r24, 0x78	; 120
    57ce:	97 e0       	ldi	r25, 0x07	; 7
    57d0:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    57d4:	1f 91       	pop	r17
    57d6:	0f 91       	pop	r16
    57d8:	ff 90       	pop	r15
    57da:	ef 90       	pop	r14
    57dc:	08 95       	ret

000057de <bmk2_execute>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
    57de:	ef 92       	push	r14
    57e0:	ff 92       	push	r15
    57e2:	0f 93       	push	r16
    57e4:	1f 93       	push	r17
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread1, NULL);
    57e6:	e0 91 fe 0b 	lds	r30, 0x0BFE
    57ea:	f0 91 ff 0b 	lds	r31, 0x0BFF
    57ee:	44 81       	ldd	r20, Z+4	; 0x04
    57f0:	4f 5f       	subi	r20, 0xFF	; 255
    57f2:	80 91 95 02 	lds	r24, 0x0295
    57f6:	90 91 96 02 	lds	r25, 0x0296
    57fa:	65 e9       	ldi	r22, 0x95	; 149
    57fc:	70 e0       	ldi	r23, 0x00	; 0
    57fe:	2b e6       	ldi	r18, 0x6B	; 107
    5800:	3c e2       	ldi	r19, 0x2C	; 44
    5802:	00 e0       	ldi	r16, 0x00	; 0
    5804:	10 e0       	ldi	r17, 0x00	; 0
    5806:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    580a:	90 93 02 0c 	sts	0x0C02, r25
    580e:	80 93 01 0c 	sts	0x0C01, r24
  n = msg_loop_test(threads[0]);
    5812:	0e 94 32 2b 	call	0x5664	; 0x5664 <msg_loop_test>
    5816:	7c 01       	movw	r14, r24
    5818:	00 e0       	ldi	r16, 0x00	; 0
    581a:	10 e0       	ldi	r17, 0x00	; 0
  test_wait_threads();
    581c:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_print("--- Score : ");
    5820:	8f e2       	ldi	r24, 0x2F	; 47
    5822:	97 e0       	ldi	r25, 0x07	; 7
    5824:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n);
    5828:	c8 01       	movw	r24, r16
    582a:	b7 01       	movw	r22, r14
    582c:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_print(" msgs/S, ");
    5830:	83 e9       	ldi	r24, 0x93	; 147
    5832:	97 e0       	ldi	r25, 0x07	; 7
    5834:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n << 1);
    5838:	ee 0c       	add	r14, r14
    583a:	ff 1c       	adc	r15, r15
    583c:	00 1f       	adc	r16, r16
    583e:	11 1f       	adc	r17, r17
    5840:	c8 01       	movw	r24, r16
    5842:	b7 01       	movw	r22, r14
    5844:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" ctxswc/S");
    5848:	88 e7       	ldi	r24, 0x78	; 120
    584a:	97 e0       	ldi	r25, 0x07	; 7
    584c:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    5850:	1f 91       	pop	r17
    5852:	0f 91       	pop	r16
    5854:	ff 90       	pop	r15
    5856:	ef 90       	pop	r14
    5858:	08 95       	ret

0000585a <bmk1_execute>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
    585a:	ef 92       	push	r14
    585c:	ff 92       	push	r15
    585e:	0f 93       	push	r16
    5860:	1f 93       	push	r17
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-1, thread1, NULL);
    5862:	e0 91 fe 0b 	lds	r30, 0x0BFE
    5866:	f0 91 ff 0b 	lds	r31, 0x0BFF
    586a:	44 81       	ldd	r20, Z+4	; 0x04
    586c:	41 50       	subi	r20, 0x01	; 1
    586e:	80 91 95 02 	lds	r24, 0x0295
    5872:	90 91 96 02 	lds	r25, 0x0296
    5876:	65 e9       	ldi	r22, 0x95	; 149
    5878:	70 e0       	ldi	r23, 0x00	; 0
    587a:	2b e6       	ldi	r18, 0x6B	; 107
    587c:	3c e2       	ldi	r19, 0x2C	; 44
    587e:	00 e0       	ldi	r16, 0x00	; 0
    5880:	10 e0       	ldi	r17, 0x00	; 0
    5882:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5886:	90 93 02 0c 	sts	0x0C02, r25
    588a:	80 93 01 0c 	sts	0x0C01, r24
  n = msg_loop_test(threads[0]);
    588e:	0e 94 32 2b 	call	0x5664	; 0x5664 <msg_loop_test>
    5892:	7c 01       	movw	r14, r24
    5894:	00 e0       	ldi	r16, 0x00	; 0
    5896:	10 e0       	ldi	r17, 0x00	; 0
  test_wait_threads();
    5898:	0e 94 61 10 	call	0x20c2	; 0x20c2 <test_wait_threads>
  test_print("--- Score : ");
    589c:	8f e2       	ldi	r24, 0x2F	; 47
    589e:	97 e0       	ldi	r25, 0x07	; 7
    58a0:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n);
    58a4:	c8 01       	movw	r24, r16
    58a6:	b7 01       	movw	r22, r14
    58a8:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_print(" msgs/S, ");
    58ac:	83 e9       	ldi	r24, 0x93	; 147
    58ae:	97 e0       	ldi	r25, 0x07	; 7
    58b0:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <test_print>
  test_printn(n << 1);
    58b4:	ee 0c       	add	r14, r14
    58b6:	ff 1c       	adc	r15, r15
    58b8:	00 1f       	adc	r16, r16
    58ba:	11 1f       	adc	r17, r17
    58bc:	c8 01       	movw	r24, r16
    58be:	b7 01       	movw	r22, r14
    58c0:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <test_printn>
  test_println(" ctxswc/S");
    58c4:	88 e7       	ldi	r24, 0x78	; 120
    58c6:	97 e0       	ldi	r25, 0x07	; 7
    58c8:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <test_println>
}
    58cc:	1f 91       	pop	r17
    58ce:	0f 91       	pop	r16
    58d0:	ff 90       	pop	r15
    58d2:	ef 90       	pop	r14
    58d4:	08 95       	ret

000058d6 <thread1>:
static Semaphore sem1;
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
static Mutex mtx1;
#endif

static msg_t thread1(void *p) {
    58d6:	0f 93       	push	r16
    58d8:	1f 93       	push	r17
  Thread *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
    58da:	0e 94 8b 0a 	call	0x1516	; 0x1516 <chMsgWait>
    58de:	fc 01       	movw	r30, r24
    msg = chMsgGet(tp);
    58e0:	02 8d       	ldd	r16, Z+26	; 0x1a
    58e2:	13 8d       	ldd	r17, Z+27	; 0x1b
    chMsgRelease(tp, msg);
    58e4:	b8 01       	movw	r22, r16
    58e6:	0e 94 86 0a 	call	0x150c	; 0x150c <chMsgRelease>
  } while (msg);
    58ea:	01 2b       	or	r16, r17
    58ec:	b1 f7       	brne	.-20     	; 0x58da <thread1+0x4>
  return 0;
}
    58ee:	80 e0       	ldi	r24, 0x00	; 0
    58f0:	90 e0       	ldi	r25, 0x00	; 0
    58f2:	1f 91       	pop	r17
    58f4:	0f 91       	pop	r16
    58f6:	08 95       	ret

000058f8 <thread4>:
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

msg_t thread4(void *p) {
    58f8:	cf 93       	push	r28
    58fa:	df 93       	push	r29
  msg_t msg;
  Thread *self = chThdSelf();
    58fc:	c0 91 fe 0b 	lds	r28, 0x0BFE
    5900:	d0 91 ff 0b 	lds	r29, 0x0BFF

  (void)p;
  chSysLock();
    5904:	f8 94       	cli
  do {
    chSchGoSleepS(THD_STATE_SUSPENDED);
    5906:	82 e0       	ldi	r24, 0x02	; 2
    5908:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchGoSleepS>
    msg = self->p_u.rdymsg;
  } while (msg == RDY_OK);
    590c:	8a 89       	ldd	r24, Y+18	; 0x12
    590e:	9b 89       	ldd	r25, Y+19	; 0x13
    5910:	89 2b       	or	r24, r25
    5912:	c9 f3       	breq	.-14     	; 0x5906 <thread4+0xe>
  chSysUnlock();
    5914:	78 94       	sei
  return 0;
}
    5916:	80 e0       	ldi	r24, 0x00	; 0
    5918:	90 e0       	ldi	r25, 0x00	; 0
    591a:	df 91       	pop	r29
    591c:	cf 91       	pop	r28
    591e:	08 95       	ret

00005920 <halInit>:
 *
 * @init
 */
void halInit(void) {

  hal_lld_init();
    5920:	0e 94 9d 2d 	call	0x5b3a	; 0x5b3a <hal_lld_init>

#if HAL_USE_TM || defined(__DOXYGEN__)
  tmInit();
#endif
#if HAL_USE_PAL || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    5924:	80 ec       	ldi	r24, 0xC0	; 192
    5926:	99 e0       	ldi	r25, 0x09	; 9
    5928:	0e 94 9e 2d 	call	0x5b3c	; 0x5b3c <_pal_lld_init>
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
    592c:	0e 94 9a 2d 	call	0x5b34	; 0x5b34 <sdInit>
#endif
#if HAL_USE_RTC || defined(__DOXYGEN__)
  rtcInit();
#endif
  /* Board specific initialization.*/
  boardInit();
    5930:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <boardInit>
}
    5934:	08 95       	ret

00005936 <palReadBus>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @return              The bus logical states.
 *
 * @api
 */
ioportmask_t palReadBus(IOBus *bus) {
    5936:	dc 01       	movw	r26, r24

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palReadBus");

  return palReadGroup(bus->portid, bus->mask, bus->offset);
    5938:	ed 91       	ld	r30, X+
    593a:	fc 91       	ld	r31, X
    593c:	11 97       	sbiw	r26, 0x01	; 1
    593e:	20 81       	ld	r18, Z
    5940:	30 e0       	ldi	r19, 0x00	; 0
    5942:	13 96       	adiw	r26, 0x03	; 3
    5944:	0c 90       	ld	r0, X
    5946:	13 97       	sbiw	r26, 0x03	; 3
    5948:	02 c0       	rjmp	.+4      	; 0x594e <palReadBus+0x18>
    594a:	35 95       	asr	r19
    594c:	27 95       	ror	r18
    594e:	0a 94       	dec	r0
    5950:	e2 f7       	brpl	.-8      	; 0x594a <palReadBus+0x14>
    5952:	12 96       	adiw	r26, 0x02	; 2
    5954:	8c 91       	ld	r24, X
}
    5956:	82 23       	and	r24, r18
    5958:	08 95       	ret

0000595a <palWriteBus>:
 *                      the bus width are masked so most significant bits are
 *                      lost.
 *
 * @api
 */
void palWriteBus(IOBus *bus, ioportmask_t bits) {
    595a:	fc 01       	movw	r30, r24

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palWriteBus");

  palWriteGroup(bus->portid, bus->mask, bus->offset, bits);
    595c:	a0 81       	ld	r26, Z
    595e:	b1 81       	ldd	r27, Z+1	; 0x01
    5960:	12 96       	adiw	r26, 0x02	; 2
    5962:	3c 91       	ld	r19, X
    5964:	12 97       	sbiw	r26, 0x02	; 2
    5966:	82 81       	ldd	r24, Z+2	; 0x02
    5968:	23 81       	ldd	r18, Z+3	; 0x03
    596a:	68 23       	and	r22, r24
    596c:	70 e0       	ldi	r23, 0x00	; 0
    596e:	02 2e       	mov	r0, r18
    5970:	02 c0       	rjmp	.+4      	; 0x5976 <palWriteBus+0x1c>
    5972:	66 0f       	add	r22, r22
    5974:	77 1f       	adc	r23, r23
    5976:	0a 94       	dec	r0
    5978:	e2 f7       	brpl	.-8      	; 0x5972 <palWriteBus+0x18>
    597a:	90 e0       	ldi	r25, 0x00	; 0
    597c:	02 c0       	rjmp	.+4      	; 0x5982 <palWriteBus+0x28>
    597e:	88 0f       	add	r24, r24
    5980:	99 1f       	adc	r25, r25
    5982:	2a 95       	dec	r18
    5984:	e2 f7       	brpl	.-8      	; 0x597e <palWriteBus+0x24>
    5986:	80 95       	com	r24
    5988:	83 23       	and	r24, r19
    598a:	86 2b       	or	r24, r22
    598c:	12 96       	adiw	r26, 0x02	; 2
    598e:	8c 93       	st	X, r24
}
    5990:	08 95       	ret

00005992 <palSetBusMode>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @param[in] mode      the mode
 *
 * @api
 */
void palSetBusMode(IOBus *bus, iomode_t mode) {
    5992:	fc 01       	movw	r30, r24
    5994:	46 2f       	mov	r20, r22

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palSetBusMode");

  palSetGroupMode(bus->portid, bus->mask, bus->offset, mode);
    5996:	62 81       	ldd	r22, Z+2	; 0x02
    5998:	70 e0       	ldi	r23, 0x00	; 0
    599a:	03 80       	ldd	r0, Z+3	; 0x03
    599c:	02 c0       	rjmp	.+4      	; 0x59a2 <palSetBusMode+0x10>
    599e:	66 0f       	add	r22, r22
    59a0:	77 1f       	adc	r23, r23
    59a2:	0a 94       	dec	r0
    59a4:	e2 f7       	brpl	.-8      	; 0x599e <palSetBusMode+0xc>
    59a6:	80 81       	ld	r24, Z
    59a8:	91 81       	ldd	r25, Z+1	; 0x01
    59aa:	0e 94 b0 2d 	call	0x5b60	; 0x5b60 <_pal_lld_setgroupmode>
}
    59ae:	08 95       	ret

000059b0 <sdRequestDataI>:
 * @retval Q_EMPTY      if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    59b0:	0f 93       	push	r16
    59b2:	1f 93       	push	r17
    59b4:	cf 93       	push	r28
    59b6:	df 93       	push	r29
    59b8:	8c 01       	movw	r16, r24
  msg_t  b;

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdRequestDataI");

  b = chOQGetI(&sdp->oqueue);
    59ba:	47 96       	adiw	r24, 0x17	; 23
    59bc:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <chOQGetI>
    59c0:	ec 01       	movw	r28, r24
  if (b < Q_OK)
    59c2:	97 fd       	sbrc	r25, 7
    59c4:	06 c0       	rjmp	.+12     	; 0x59d2 <sdRequestDataI+0x22>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
    59c6:	ce 01       	movw	r24, r28
    59c8:	df 91       	pop	r29
    59ca:	cf 91       	pop	r28
    59cc:	1f 91       	pop	r17
    59ce:	0f 91       	pop	r16
    59d0:	08 95       	ret
  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdRequestDataI");

  b = chOQGetI(&sdp->oqueue);
  if (b < Q_OK)
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    59d2:	c8 01       	movw	r24, r16
    59d4:	02 96       	adiw	r24, 0x02	; 2
    59d6:	68 e0       	ldi	r22, 0x08	; 8
    59d8:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <chEvtBroadcastFlagsI>
  return b;
}
    59dc:	ce 01       	movw	r24, r28
    59de:	df 91       	pop	r29
    59e0:	cf 91       	pop	r28
    59e2:	1f 91       	pop	r17
    59e4:	0f 91       	pop	r16
    59e6:	08 95       	ret

000059e8 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    59e8:	1f 93       	push	r17
    59ea:	cf 93       	push	r28
    59ec:	df 93       	push	r29
    59ee:	ec 01       	movw	r28, r24
    59f0:	16 2f       	mov	r17, r22

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    59f2:	89 85       	ldd	r24, Y+9	; 0x09
    59f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    59f6:	89 2b       	or	r24, r25
    59f8:	59 f0       	breq	.+22     	; 0x5a10 <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    59fa:	ce 01       	movw	r24, r28
    59fc:	05 96       	adiw	r24, 0x05	; 5
    59fe:	61 2f       	mov	r22, r17
    5a00:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
    5a04:	97 fd       	sbrc	r25, 7
    5a06:	10 c0       	rjmp	.+32     	; 0x5a28 <sdIncomingDataI+0x40>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
    5a08:	df 91       	pop	r29
    5a0a:	cf 91       	pop	r28
    5a0c:	1f 91       	pop	r17
    5a0e:	08 95       	ret

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    5a10:	ce 01       	movw	r24, r28
    5a12:	02 96       	adiw	r24, 0x02	; 2
    5a14:	64 e0       	ldi	r22, 0x04	; 4
    5a16:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <chEvtBroadcastFlagsI>
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    5a1a:	ce 01       	movw	r24, r28
    5a1c:	05 96       	adiw	r24, 0x05	; 5
    5a1e:	61 2f       	mov	r22, r17
    5a20:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <chIQPutI>
    5a24:	97 ff       	sbrs	r25, 7
    5a26:	f0 cf       	rjmp	.-32     	; 0x5a08 <sdIncomingDataI+0x20>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    5a28:	ce 01       	movw	r24, r28
    5a2a:	02 96       	adiw	r24, 0x02	; 2
    5a2c:	60 e8       	ldi	r22, 0x80	; 128
    5a2e:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <chEvtBroadcastFlagsI>
}
    5a32:	df 91       	pop	r29
    5a34:	cf 91       	pop	r28
    5a36:	1f 91       	pop	r17
    5a38:	08 95       	ret

00005a3a <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
    5a3a:	0f 93       	push	r16
    5a3c:	1f 93       	push	r17
    5a3e:	8c 01       	movw	r16, r24

  chDbgCheck(sdp != NULL, "sdStop");

  chSysLock();
    5a40:	f8 94       	cli
  chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
              "sdStop(), #1",
              "invalid state");
  sd_lld_stop(sdp);
    5a42:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <sd_lld_stop>
  sdp->state = SD_STOP;
    5a46:	81 e0       	ldi	r24, 0x01	; 1
    5a48:	f8 01       	movw	r30, r16
    5a4a:	84 83       	std	Z+4, r24	; 0x04
  chOQResetI(&sdp->oqueue);
    5a4c:	c8 01       	movw	r24, r16
    5a4e:	47 96       	adiw	r24, 0x17	; 23
    5a50:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <chOQResetI>
  chIQResetI(&sdp->iqueue);
    5a54:	c8 01       	movw	r24, r16
    5a56:	05 96       	adiw	r24, 0x05	; 5
    5a58:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <chIQResetI>
  chSchRescheduleS();
    5a5c:	0e 94 90 02 	call	0x520	; 0x520 <chSchRescheduleS>
  chSysUnlock();
    5a60:	78 94       	sei
}
    5a62:	1f 91       	pop	r17
    5a64:	0f 91       	pop	r16
    5a66:	08 95       	ret

00005a68 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    5a68:	0f 93       	push	r16
    5a6a:	1f 93       	push	r17
    5a6c:	8c 01       	movw	r16, r24

  chDbgCheck(sdp != NULL, "sdStart");

  chSysLock();
    5a6e:	f8 94       	cli
  chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
              "sdStart(), #1",
              "invalid state");
  sd_lld_start(sdp, config);
    5a70:	0e 94 dc 2d 	call	0x5bb8	; 0x5bb8 <sd_lld_start>
  sdp->state = SD_READY;
    5a74:	82 e0       	ldi	r24, 0x02	; 2
    5a76:	f8 01       	movw	r30, r16
    5a78:	84 83       	std	Z+4, r24	; 0x04
  chSysUnlock();
    5a7a:	78 94       	sei
}
    5a7c:	1f 91       	pop	r17
    5a7e:	0f 91       	pop	r16
    5a80:	08 95       	ret

00005a82 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    5a82:	cf 92       	push	r12
    5a84:	df 92       	push	r13
    5a86:	ef 92       	push	r14
    5a88:	ff 92       	push	r15
    5a8a:	0f 93       	push	r16
    5a8c:	1f 93       	push	r17
    5a8e:	7c 01       	movw	r14, r24
    5a90:	9b 01       	movw	r18, r22
    5a92:	6a 01       	movw	r12, r20

  sdp->vmt = &vmt;
    5a94:	fc 01       	movw	r30, r24
    5a96:	8d ea       	ldi	r24, 0xAD	; 173
    5a98:	99 e0       	ldi	r25, 0x09	; 9
    5a9a:	81 93       	st	Z+, r24
    5a9c:	91 93       	st	Z+, r25
  chEvtInit(&sdp->event);
    5a9e:	d7 01       	movw	r26, r14
    5aa0:	13 96       	adiw	r26, 0x03	; 3
    5aa2:	fc 93       	st	X, r31
    5aa4:	ee 93       	st	-X, r30
    5aa6:	12 97       	sbiw	r26, 0x02	; 2
  sdp->state = SD_STOP;
    5aa8:	81 e0       	ldi	r24, 0x01	; 1
    5aaa:	14 96       	adiw	r26, 0x04	; 4
    5aac:	8c 93       	st	X, r24
  chIQInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    5aae:	b7 01       	movw	r22, r14
    5ab0:	67 5d       	subi	r22, 0xD7	; 215
    5ab2:	7f 4f       	sbci	r23, 0xFF	; 255
    5ab4:	c7 01       	movw	r24, r14
    5ab6:	05 96       	adiw	r24, 0x05	; 5
    5ab8:	40 e1       	ldi	r20, 0x10	; 16
    5aba:	50 e0       	ldi	r21, 0x00	; 0
    5abc:	87 01       	movw	r16, r14
    5abe:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <chIQInit>
  chOQInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    5ac2:	b7 01       	movw	r22, r14
    5ac4:	67 5c       	subi	r22, 0xC7	; 199
    5ac6:	7f 4f       	sbci	r23, 0xFF	; 255
    5ac8:	c7 01       	movw	r24, r14
    5aca:	47 96       	adiw	r24, 0x17	; 23
    5acc:	40 e1       	ldi	r20, 0x10	; 16
    5ace:	50 e0       	ldi	r21, 0x00	; 0
    5ad0:	96 01       	movw	r18, r12
    5ad2:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <chOQInit>
}
    5ad6:	1f 91       	pop	r17
    5ad8:	0f 91       	pop	r16
    5ada:	ff 90       	pop	r15
    5adc:	ef 90       	pop	r14
    5ade:	df 90       	pop	r13
    5ae0:	cf 90       	pop	r12
    5ae2:	08 95       	ret

00005ae4 <readt>:
  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
    5ae4:	05 96       	adiw	r24, 0x05	; 5
    5ae6:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <chIQReadTimeout>
}
    5aea:	08 95       	ret

00005aec <read>:
                          n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    5aec:	05 96       	adiw	r24, 0x05	; 5
    5aee:	2f ef       	ldi	r18, 0xFF	; 255
    5af0:	3f ef       	ldi	r19, 0xFF	; 255
    5af2:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <chIQReadTimeout>
                         n, TIME_INFINITE);
}
    5af6:	08 95       	ret

00005af8 <writet>:
  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
    5af8:	47 96       	adiw	r24, 0x17	; 23
    5afa:	0e 94 b0 0c 	call	0x1960	; 0x1960 <chOQWriteTimeout>
}
    5afe:	08 95       	ret

00005b00 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    5b00:	47 96       	adiw	r24, 0x17	; 23
    5b02:	2f ef       	ldi	r18, 0xFF	; 255
    5b04:	3f ef       	ldi	r19, 0xFF	; 255
    5b06:	0e 94 b0 0c 	call	0x1960	; 0x1960 <chOQWriteTimeout>
                          n, TIME_INFINITE);
}
    5b0a:	08 95       	ret

00005b0c <gett>:
  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    5b0c:	05 96       	adiw	r24, 0x05	; 5
    5b0e:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <chIQGetTimeout>
}
    5b12:	08 95       	ret

00005b14 <get>:
  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    5b14:	05 96       	adiw	r24, 0x05	; 5
    5b16:	6f ef       	ldi	r22, 0xFF	; 255
    5b18:	7f ef       	ldi	r23, 0xFF	; 255
    5b1a:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <chIQGetTimeout>
}
    5b1e:	08 95       	ret

00005b20 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    5b20:	47 96       	adiw	r24, 0x17	; 23
    5b22:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chOQPutTimeout>
}
    5b26:	08 95       	ret

00005b28 <put>:
                         n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    5b28:	47 96       	adiw	r24, 0x17	; 23
    5b2a:	4f ef       	ldi	r20, 0xFF	; 255
    5b2c:	5f ef       	ldi	r21, 0xFF	; 255
    5b2e:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chOQPutTimeout>
}
    5b32:	08 95       	ret

00005b34 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    5b34:	0e 94 1e 2e 	call	0x5c3c	; 0x5c3c <sd_lld_init>
}
    5b38:	08 95       	ret

00005b3a <hal_lld_init>:
 *
 * @notapi
 */
void hal_lld_init(void) {

}
    5b3a:	08 95       	ret

00005b3c <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    5b3c:	fc 01       	movw	r30, r24

#if defined(PORTA) || defined(__DOXYGEN__)
  PORTA = config->porta.out;
    5b3e:	80 81       	ld	r24, Z
    5b40:	82 b9       	out	0x02, r24	; 2
  DDRA = config->porta.dir;
    5b42:	81 81       	ldd	r24, Z+1	; 0x01
    5b44:	81 b9       	out	0x01, r24	; 1
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
    5b46:	82 81       	ldd	r24, Z+2	; 0x02
    5b48:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
    5b4a:	83 81       	ldd	r24, Z+3	; 0x03
    5b4c:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
    5b4e:	84 81       	ldd	r24, Z+4	; 0x04
    5b50:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
    5b52:	85 81       	ldd	r24, Z+5	; 0x05
    5b54:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
    5b56:	86 81       	ldd	r24, Z+6	; 0x06
    5b58:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
    5b5a:	87 81       	ldd	r24, Z+7	; 0x07
    5b5c:	8a b9       	out	0x0a, r24	; 10

#if defined(PORTL) || defined(__DOXYGEN__)
  PORTL = config->portl.out;
  DDRL = config->portl.dir;
#endif
}
    5b5e:	08 95       	ret

00005b60 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    5b60:	fc 01       	movw	r30, r24

  switch (mode) {
    5b62:	42 30       	cpi	r20, 0x02	; 2
    5b64:	99 f0       	breq	.+38     	; 0x5b8c <_pal_lld_setgroupmode+0x2c>
    5b66:	43 30       	cpi	r20, 0x03	; 3
    5b68:	78 f0       	brcs	.+30     	; 0x5b88 <_pal_lld_setgroupmode+0x28>
    5b6a:	45 30       	cpi	r20, 0x05	; 5
    5b6c:	79 f0       	breq	.+30     	; 0x5b8c <_pal_lld_setgroupmode+0x2c>
    5b6e:	46 30       	cpi	r20, 0x06	; 6
    5b70:	b1 f0       	breq	.+44     	; 0x5b9e <_pal_lld_setgroupmode+0x3e>
    5b72:	43 30       	cpi	r20, 0x03	; 3
    5b74:	b9 f4       	brne	.+46     	; 0x5ba4 <_pal_lld_setgroupmode+0x44>
    port->dir &= ~mask;
    port->out &= ~mask;
	break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    5b76:	81 81       	ldd	r24, Z+1	; 0x01
    5b78:	96 2f       	mov	r25, r22
    5b7a:	90 95       	com	r25
    5b7c:	98 23       	and	r25, r24
    5b7e:	91 83       	std	Z+1, r25	; 0x01
    port->out |= mask;
    5b80:	82 81       	ldd	r24, Z+2	; 0x02
    5b82:	86 2b       	or	r24, r22
    5b84:	82 83       	std	Z+2, r24	; 0x02
    5b86:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
    5b88:	44 23       	and	r20, r20
    5b8a:	69 f4       	brne	.+26     	; 0x5ba6 <_pal_lld_setgroupmode+0x46>
  case PAL_MODE_RESET:
  case PAL_MODE_INPUT:
  case PAL_MODE_INPUT_ANALOG:
    port->dir &= ~mask;
    5b8c:	81 81       	ldd	r24, Z+1	; 0x01
    5b8e:	96 2f       	mov	r25, r22
    5b90:	90 95       	com	r25
    5b92:	89 23       	and	r24, r25
    5b94:	81 83       	std	Z+1, r24	; 0x01
    port->out &= ~mask;
    5b96:	82 81       	ldd	r24, Z+2	; 0x02
    5b98:	98 23       	and	r25, r24
    5b9a:	92 83       	std	Z+2, r25	; 0x02
    5b9c:	08 95       	ret
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    port->out |= mask;
    break;
  case PAL_MODE_OUTPUT_PUSHPULL:
    port->dir |= mask;
    5b9e:	81 81       	ldd	r24, Z+1	; 0x01
    5ba0:	86 2b       	or	r24, r22
    5ba2:	81 83       	std	Z+1, r24	; 0x01
    5ba4:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
    5ba6:	41 30       	cpi	r20, 0x01	; 1
    5ba8:	31 f3       	breq	.-52     	; 0x5b76 <_pal_lld_setgroupmode+0x16>
    5baa:	08 95       	ret

00005bac <notify2>:

#if USE_AVR_USART1 || defined(__DOXYGEN__)
static void notify2(GenericQueue *qp) {

  (void)qp;
  UCSR1B |= (1 << UDRIE1);
    5bac:	e9 ec       	ldi	r30, 0xC9	; 201
    5bae:	f0 e0       	ldi	r31, 0x00	; 0
    5bb0:	80 81       	ld	r24, Z
    5bb2:	80 62       	ori	r24, 0x20	; 32
    5bb4:	80 83       	st	Z, r24
}
    5bb6:	08 95       	ret

00005bb8 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
    5bb8:	fb 01       	movw	r30, r22

  if (config == NULL)
    5bba:	61 15       	cp	r22, r1
    5bbc:	71 05       	cpc	r23, r1
    5bbe:	b9 f0       	breq	.+46     	; 0x5bee <sd_lld_start+0x36>
    usart0_init(config);
    return;
  }
#endif
#if USE_AVR_USART1
  if (&SD2 == sdp) {
    5bc0:	84 5f       	subi	r24, 0xF4	; 244
    5bc2:	9e 40       	sbci	r25, 0x0E	; 14
    5bc4:	09 f0       	breq	.+2      	; 0x5bc8 <sd_lld_start+0x10>
    5bc6:	08 95       	ret
 *
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart1_init(const SerialConfig *config) {

  UBRR1L = config->sc_brr;
    5bc8:	80 81       	ld	r24, Z
    5bca:	91 81       	ldd	r25, Z+1	; 0x01
    5bcc:	80 93 cc 00 	sts	0x00CC, r24
  UBRR1H = config->sc_brr >> 8;
    5bd0:	90 93 cd 00 	sts	0x00CD, r25
  UCSR1A = 0;
    5bd4:	10 92 c8 00 	sts	0x00C8, r1
  UCSR1B = (1 << RXEN1) | (1 << TXEN1) | (1 << RXCIE1);
    5bd8:	88 e9       	ldi	r24, 0x98	; 152
    5bda:	80 93 c9 00 	sts	0x00C9, r24
  switch (config->sc_bits_per_char) {
    5bde:	62 81       	ldd	r22, Z+2	; 0x02
    5be0:	61 30       	cpi	r22, 0x01	; 1
    5be2:	a1 f0       	breq	.+40     	; 0x5c0c <sd_lld_start+0x54>
    5be4:	61 30       	cpi	r22, 0x01	; 1
    5be6:	30 f4       	brcc	.+12     	; 0x5bf4 <sd_lld_start+0x3c>
  case USART_CHAR_SIZE_5:
    UCSR1C = 0;
    5be8:	10 92 ca 00 	sts	0x00CA, r1
    5bec:	08 95       	ret
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    5bee:	ed eb       	ldi	r30, 0xBD	; 189
    5bf0:	f9 e0       	ldi	r31, 0x09	; 9
    5bf2:	e6 cf       	rjmp	.-52     	; 0x5bc0 <sd_lld_start+0x8>

  UBRR1L = config->sc_brr;
  UBRR1H = config->sc_brr >> 8;
  UCSR1A = 0;
  UCSR1B = (1 << RXEN1) | (1 << TXEN1) | (1 << RXCIE1);
  switch (config->sc_bits_per_char) {
    5bf4:	62 30       	cpi	r22, 0x02	; 2
    5bf6:	31 f0       	breq	.+12     	; 0x5c04 <sd_lld_start+0x4c>
    5bf8:	64 30       	cpi	r22, 0x04	; 4
    5bfa:	61 f0       	breq	.+24     	; 0x5c14 <sd_lld_start+0x5c>
    UCSR1B |= (1 << UCSZ12);
    UCSR1C = (1 << UCSZ10) | (1 << UCSZ11);
    break;
  case USART_CHAR_SIZE_8:
  default:
    UCSR1C = (1 << UCSZ10) | (1 << UCSZ11);
    5bfc:	86 e0       	ldi	r24, 0x06	; 6
    5bfe:	80 93 ca 00 	sts	0x00CA, r24
    5c02:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    UCSR1C = (1 << UCSZ10);
    break;
  case USART_CHAR_SIZE_7:
    UCSR1C = (1 << UCSZ11);
    5c04:	84 e0       	ldi	r24, 0x04	; 4
    5c06:	80 93 ca 00 	sts	0x00CA, r24
    5c0a:	08 95       	ret
  switch (config->sc_bits_per_char) {
  case USART_CHAR_SIZE_5:
    UCSR1C = 0;
    break;
  case USART_CHAR_SIZE_6:
    UCSR1C = (1 << UCSZ10);
    5c0c:	82 e0       	ldi	r24, 0x02	; 2
    5c0e:	80 93 ca 00 	sts	0x00CA, r24
    5c12:	08 95       	ret
    break;
  case USART_CHAR_SIZE_7:
    UCSR1C = (1 << UCSZ11);
    break;
  case USART_CHAR_SIZE_9:
    UCSR1B |= (1 << UCSZ12);
    5c14:	80 91 c9 00 	lds	r24, 0x00C9
    5c18:	84 60       	ori	r24, 0x04	; 4
    5c1a:	80 93 c9 00 	sts	0x00C9, r24
    UCSR1C = (1 << UCSZ10) | (1 << UCSZ11);
    5c1e:	86 e0       	ldi	r24, 0x06	; 6
    5c20:	80 93 ca 00 	sts	0x00CA, r24
    5c24:	08 95       	ret

00005c26 <sd_lld_stop>:
#if USE_AVR_USART0
  if (&SD1 == sdp)
    usart0_deinit();
#endif
#if USE_AVR_USART1
  if (&SD2 == sdp)
    5c26:	84 5f       	subi	r24, 0xF4	; 244
    5c28:	9e 40       	sbci	r25, 0x0E	; 14
    5c2a:	09 f0       	breq	.+2      	; 0x5c2e <sd_lld_stop+0x8>
    5c2c:	08 95       	ret
/**
 * @brief   USART1 de-initialization.
 */
static void usart1_deinit(void) {

  UCSR1A = 0;
    5c2e:	10 92 c8 00 	sts	0x00C8, r1
  UCSR1B = 0;
    5c32:	10 92 c9 00 	sts	0x00C9, r1
  UCSR1C = 0;
    5c36:	10 92 ca 00 	sts	0x00CA, r1
    5c3a:	08 95       	ret

00005c3c <sd_lld_init>:

#if USE_AVR_USART0
  sdObjectInit(&SD1, NULL, notify1);
#endif
#if USE_AVR_USART1
  sdObjectInit(&SD2, NULL, notify2);
    5c3c:	84 ef       	ldi	r24, 0xF4	; 244
    5c3e:	9e e0       	ldi	r25, 0x0E	; 14
    5c40:	60 e0       	ldi	r22, 0x00	; 0
    5c42:	70 e0       	ldi	r23, 0x00	; 0
    5c44:	46 ed       	ldi	r20, 0xD6	; 214
    5c46:	5d e2       	ldi	r21, 0x2D	; 45
    5c48:	0e 94 41 2d 	call	0x5a82	; 0x5a82 <sdObjectInit>
#endif
}
    5c4c:	08 95       	ret

00005c4e <__vector_29>:
/**
 * @brief   USART1 TX interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(USART1_UDRE_vect) {
    5c4e:	1f 92       	push	r1
    5c50:	0f 92       	push	r0
    5c52:	0f b6       	in	r0, 0x3f	; 63
    5c54:	0f 92       	push	r0
    5c56:	0b b6       	in	r0, 0x3b	; 59
    5c58:	0f 92       	push	r0
    5c5a:	11 24       	eor	r1, r1
    5c5c:	2f 93       	push	r18
    5c5e:	3f 93       	push	r19
    5c60:	4f 93       	push	r20
    5c62:	5f 93       	push	r21
    5c64:	6f 93       	push	r22
    5c66:	7f 93       	push	r23
    5c68:	8f 93       	push	r24
    5c6a:	9f 93       	push	r25
    5c6c:	af 93       	push	r26
    5c6e:	bf 93       	push	r27
    5c70:	ef 93       	push	r30
    5c72:	ff 93       	push	r31
  msg_t b;

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
  b = sdRequestDataI(&SD2);
    5c74:	84 ef       	ldi	r24, 0xF4	; 244
    5c76:	9e e0       	ldi	r25, 0x0E	; 14
    5c78:	0e 94 d8 2c 	call	0x59b0	; 0x59b0 <sdRequestDataI>
  chSysUnlockFromIsr();
  if (b < Q_OK)
    5c7c:	97 fd       	sbrc	r25, 7
    5c7e:	1b c0       	rjmp	.+54     	; 0x5cb6 <__vector_29+0x68>
    UCSR1B &= ~(1 << UDRIE1);
  else
    UDR1 = b;
    5c80:	80 93 ce 00 	sts	0x00CE, r24

  CH_IRQ_EPILOGUE();
    5c84:	0e 94 38 02 	call	0x470	; 0x470 <chSchIsPreemptionRequired>
    5c88:	88 23       	and	r24, r24
    5c8a:	11 f0       	breq	.+4      	; 0x5c90 <__vector_29+0x42>
    5c8c:	0e 94 ce 02 	call	0x59c	; 0x59c <chSchDoReschedule>
}
    5c90:	ff 91       	pop	r31
    5c92:	ef 91       	pop	r30
    5c94:	bf 91       	pop	r27
    5c96:	af 91       	pop	r26
    5c98:	9f 91       	pop	r25
    5c9a:	8f 91       	pop	r24
    5c9c:	7f 91       	pop	r23
    5c9e:	6f 91       	pop	r22
    5ca0:	5f 91       	pop	r21
    5ca2:	4f 91       	pop	r20
    5ca4:	3f 91       	pop	r19
    5ca6:	2f 91       	pop	r18
    5ca8:	0f 90       	pop	r0
    5caa:	0b be       	out	0x3b, r0	; 59
    5cac:	0f 90       	pop	r0
    5cae:	0f be       	out	0x3f, r0	; 63
    5cb0:	0f 90       	pop	r0
    5cb2:	1f 90       	pop	r1
    5cb4:	18 95       	reti

  chSysLockFromIsr();
  b = sdRequestDataI(&SD2);
  chSysUnlockFromIsr();
  if (b < Q_OK)
    UCSR1B &= ~(1 << UDRIE1);
    5cb6:	80 91 c9 00 	lds	r24, 0x00C9
    5cba:	8f 7d       	andi	r24, 0xDF	; 223
    5cbc:	80 93 c9 00 	sts	0x00C9, r24
    5cc0:	e1 cf       	rjmp	.-62     	; 0x5c84 <__vector_29+0x36>

00005cc2 <__vector_28>:
/**
 * @brief   USART1 RX interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(USART1_RX_vect) {
    5cc2:	1f 92       	push	r1
    5cc4:	0f 92       	push	r0
    5cc6:	0f b6       	in	r0, 0x3f	; 63
    5cc8:	0f 92       	push	r0
    5cca:	0b b6       	in	r0, 0x3b	; 59
    5ccc:	0f 92       	push	r0
    5cce:	11 24       	eor	r1, r1
    5cd0:	2f 93       	push	r18
    5cd2:	3f 93       	push	r19
    5cd4:	4f 93       	push	r20
    5cd6:	5f 93       	push	r21
    5cd8:	6f 93       	push	r22
    5cda:	7f 93       	push	r23
    5cdc:	8f 93       	push	r24
    5cde:	9f 93       	push	r25
    5ce0:	af 93       	push	r26
    5ce2:	bf 93       	push	r27
    5ce4:	ef 93       	push	r30
    5ce6:	ff 93       	push	r31
  uint8_t sra;

  CH_IRQ_PROLOGUE();

  sra = UCSR1A;
    5ce8:	90 91 c8 00 	lds	r25, 0x00C8
  if (sra & ((1 << DOR1) | (1 << UPE1) | (1 << FE1)))
    5cec:	89 2f       	mov	r24, r25
    5cee:	8c 71       	andi	r24, 0x1C	; 28
    5cf0:	59 f0       	breq	.+22     	; 0x5d08 <__vector_28+0x46>
    upe = (1 << UPE1);
    fe = (1 << FE1);
  }
#endif

  if (sra & dor)
    5cf2:	93 fd       	sbrc	r25, 3
    5cf4:	28 c0       	rjmp	.+80     	; 0x5d46 <__vector_28+0x84>
    5cf6:	60 e0       	ldi	r22, 0x00	; 0
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    5cf8:	92 fd       	sbrc	r25, 2
    sts |= SD_PARITY_ERROR;
    5cfa:	60 62       	ori	r22, 0x20	; 32
  if (sra & fe)
    5cfc:	94 fd       	sbrc	r25, 4
    sts |= SD_FRAMING_ERROR;
    5cfe:	60 64       	ori	r22, 0x40	; 64
  chSysLockFromIsr();
  chnAddFlagsI(sdp, sts);
    5d00:	86 ef       	ldi	r24, 0xF6	; 246
    5d02:	9e e0       	ldi	r25, 0x0E	; 14
    5d04:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <chEvtBroadcastFlagsI>

  sra = UCSR1A;
  if (sra & ((1 << DOR1) | (1 << UPE1) | (1 << FE1)))
    set_error(sra, &SD2);
  chSysLockFromIsr();
  sdIncomingDataI(&SD2, UDR1);
    5d08:	60 91 ce 00 	lds	r22, 0x00CE
    5d0c:	84 ef       	ldi	r24, 0xF4	; 244
    5d0e:	9e e0       	ldi	r25, 0x0E	; 14
    5d10:	0e 94 f4 2c 	call	0x59e8	; 0x59e8 <sdIncomingDataI>
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
    5d14:	0e 94 38 02 	call	0x470	; 0x470 <chSchIsPreemptionRequired>
    5d18:	88 23       	and	r24, r24
    5d1a:	11 f0       	breq	.+4      	; 0x5d20 <__vector_28+0x5e>
    5d1c:	0e 94 ce 02 	call	0x59c	; 0x59c <chSchDoReschedule>
}
    5d20:	ff 91       	pop	r31
    5d22:	ef 91       	pop	r30
    5d24:	bf 91       	pop	r27
    5d26:	af 91       	pop	r26
    5d28:	9f 91       	pop	r25
    5d2a:	8f 91       	pop	r24
    5d2c:	7f 91       	pop	r23
    5d2e:	6f 91       	pop	r22
    5d30:	5f 91       	pop	r21
    5d32:	4f 91       	pop	r20
    5d34:	3f 91       	pop	r19
    5d36:	2f 91       	pop	r18
    5d38:	0f 90       	pop	r0
    5d3a:	0b be       	out	0x3b, r0	; 59
    5d3c:	0f 90       	pop	r0
    5d3e:	0f be       	out	0x3f, r0	; 63
    5d40:	0f 90       	pop	r0
    5d42:	1f 90       	pop	r1
    5d44:	18 95       	reti
    upe = (1 << UPE1);
    fe = (1 << FE1);
  }
#endif

  if (sra & dor)
    5d46:	60 e8       	ldi	r22, 0x80	; 128
    5d48:	d7 cf       	rjmp	.-82     	; 0x5cf8 <__vector_28+0x36>

00005d4a <boardInit>:
    5d4a:	10 92 6a 00 	sts	0x006A, r1
    5d4e:	1a be       	out	0x3a, r1	; 58
    5d50:	19 be       	out	0x39, r1	; 57
    5d52:	80 e2       	ldi	r24, 0x20	; 32
    5d54:	85 bf       	out	0x35, r24	; 53
    5d56:	8c e0       	ldi	r24, 0x0C	; 12
    5d58:	83 bf       	out	0x33, r24	; 51
    5d5a:	89 ef       	ldi	r24, 0xF9	; 249
    5d5c:	81 bf       	out	0x31, r24	; 49
    5d5e:	12 be       	out	0x32, r1	; 50
    5d60:	82 e0       	ldi	r24, 0x02	; 2
    5d62:	86 bf       	out	0x36, r24	; 54
    5d64:	87 bf       	out	0x37, r24	; 55
    5d66:	08 95       	ret

00005d68 <__vector_15>:
    5d68:	1f 92       	push	r1
    5d6a:	0f 92       	push	r0
    5d6c:	0f b6       	in	r0, 0x3f	; 63
    5d6e:	0f 92       	push	r0
    5d70:	0b b6       	in	r0, 0x3b	; 59
    5d72:	0f 92       	push	r0
    5d74:	11 24       	eor	r1, r1
    5d76:	2f 93       	push	r18
    5d78:	3f 93       	push	r19
    5d7a:	4f 93       	push	r20
    5d7c:	5f 93       	push	r21
    5d7e:	6f 93       	push	r22
    5d80:	7f 93       	push	r23
    5d82:	8f 93       	push	r24
    5d84:	9f 93       	push	r25
    5d86:	af 93       	push	r26
    5d88:	bf 93       	push	r27
    5d8a:	ef 93       	push	r30
    5d8c:	ff 93       	push	r31
    5d8e:	0e 94 b9 00 	call	0x172	; 0x172 <chSysTimerHandlerI>
    5d92:	0e 94 38 02 	call	0x470	; 0x470 <chSchIsPreemptionRequired>
    5d96:	88 23       	and	r24, r24
    5d98:	11 f0       	breq	.+4      	; 0x5d9e <__vector_15+0x36>
    5d9a:	0e 94 ce 02 	call	0x59c	; 0x59c <chSchDoReschedule>
    5d9e:	ff 91       	pop	r31
    5da0:	ef 91       	pop	r30
    5da2:	bf 91       	pop	r27
    5da4:	af 91       	pop	r26
    5da6:	9f 91       	pop	r25
    5da8:	8f 91       	pop	r24
    5daa:	7f 91       	pop	r23
    5dac:	6f 91       	pop	r22
    5dae:	5f 91       	pop	r21
    5db0:	4f 91       	pop	r20
    5db2:	3f 91       	pop	r19
    5db4:	2f 91       	pop	r18
    5db6:	0f 90       	pop	r0
    5db8:	0b be       	out	0x3b, r0	; 59
    5dba:	0f 90       	pop	r0
    5dbc:	0f be       	out	0x3f, r0	; 63
    5dbe:	0f 90       	pop	r0
    5dc0:	1f 90       	pop	r1
    5dc2:	18 95       	reti

00005dc4 <evtStop>:
 * @brief Stops the timer.
 * @details If the timer was already stopped then the function has no effect.
 *
 * @param etp pointer to an initialized @p EvTimer structure.
 */
void evtStop(EvTimer *etp) {
    5dc4:	fc 01       	movw	r30, r24

  chVTReset(&etp->et_vt);
    5dc6:	f8 94       	cli
    5dc8:	86 81       	ldd	r24, Z+6	; 0x06
    5dca:	97 81       	ldd	r25, Z+7	; 0x07
    5dcc:	89 2b       	or	r24, r25
    5dce:	19 f0       	breq	.+6      	; 0x5dd6 <evtStop+0x12>
    5dd0:	cf 01       	movw	r24, r30
    5dd2:	0e 94 8a 01 	call	0x314	; 0x314 <chVTResetI>
    5dd6:	78 94       	sei
}
    5dd8:	08 95       	ret

00005dda <evtStart>:
 * @brief Starts the timer
 * @details If the timer was already running then the function has no effect.
 *
 * @param etp pointer to an initialized @p EvTimer structure.
 */
void evtStart(EvTimer *etp) {
    5dda:	fc 01       	movw	r30, r24

  chSysLock();
    5ddc:	f8 94       	cli

  if (!chVTIsArmedI(&etp->et_vt))
    5dde:	86 81       	ldd	r24, Z+6	; 0x06
    5de0:	97 81       	ldd	r25, Z+7	; 0x07
    5de2:	89 2b       	or	r24, r25
    5de4:	11 f0       	breq	.+4      	; 0x5dea <evtStart+0x10>
    chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);

  chSysUnlock();
    5de6:	78 94       	sei
}
    5de8:	08 95       	ret
void evtStart(EvTimer *etp) {

  chSysLock();

  if (!chVTIsArmedI(&etp->et_vt))
    chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    5dea:	64 85       	ldd	r22, Z+12	; 0x0c
    5dec:	75 85       	ldd	r23, Z+13	; 0x0d
    5dee:	cf 01       	movw	r24, r30
    5df0:	4e ef       	ldi	r20, 0xFE	; 254
    5df2:	5e e2       	ldi	r21, 0x2E	; 46
    5df4:	9f 01       	movw	r18, r30
    5df6:	0e 94 4b 01 	call	0x296	; 0x296 <chVTSetI>
    5dfa:	f5 cf       	rjmp	.-22     	; 0x5de6 <evtStart+0xc>

00005dfc <tmrcb>:
 */

#include "ch.h"
#include "evtimer.h"

static void tmrcb(void *p) {
    5dfc:	0f 93       	push	r16
    5dfe:	1f 93       	push	r17
  EvTimer *etp = p;
    5e00:	8c 01       	movw	r16, r24

  chSysLockFromIsr();
  chEvtBroadcastI(&etp->et_es);
    5e02:	0a 96       	adiw	r24, 0x0a	; 10
    5e04:	60 e0       	ldi	r22, 0x00	; 0
    5e06:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <chEvtBroadcastFlagsI>
  chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    5e0a:	f8 01       	movw	r30, r16
    5e0c:	64 85       	ldd	r22, Z+12	; 0x0c
    5e0e:	75 85       	ldd	r23, Z+13	; 0x0d
    5e10:	c8 01       	movw	r24, r16
    5e12:	4e ef       	ldi	r20, 0xFE	; 254
    5e14:	5e e2       	ldi	r21, 0x2E	; 46
    5e16:	98 01       	movw	r18, r16
    5e18:	0e 94 4b 01 	call	0x296	; 0x296 <chVTSetI>
  chSysUnlockFromIsr();
}
    5e1c:	1f 91       	pop	r17
    5e1e:	0f 91       	pop	r16
    5e20:	08 95       	ret

00005e22 <e_pulse>:

#include "ch.h"
#include "hal.h"
#include "lcd.h"

static void e_pulse(void) {
    5e22:	df 93       	push	r29
    5e24:	cf 93       	push	r28
    5e26:	0f 92       	push	r0
    5e28:	cd b7       	in	r28, 0x3d	; 61
    5e2a:	de b7       	in	r29, 0x3e	; 62
  volatile uint8_t i;

  PORTC |= PORTC_44780_E_MASK;
    5e2c:	42 9a       	sbi	0x08, 2	; 8
  for (i = 0; i < ELOOPVALUE; i++);
    5e2e:	19 82       	std	Y+1, r1	; 0x01
    5e30:	89 81       	ldd	r24, Y+1	; 0x01
    5e32:	8a 30       	cpi	r24, 0x0A	; 10
    5e34:	30 f4       	brcc	.+12     	; 0x5e42 <e_pulse+0x20>
    5e36:	89 81       	ldd	r24, Y+1	; 0x01
    5e38:	8f 5f       	subi	r24, 0xFF	; 255
    5e3a:	89 83       	std	Y+1, r24	; 0x01
    5e3c:	89 81       	ldd	r24, Y+1	; 0x01
    5e3e:	8a 30       	cpi	r24, 0x0A	; 10
    5e40:	d0 f3       	brcs	.-12     	; 0x5e36 <e_pulse+0x14>
    ;
  PORTC &= ~PORTC_44780_E_MASK;
    5e42:	42 98       	cbi	0x08, 2	; 8
}
    5e44:	0f 90       	pop	r0
    5e46:	cf 91       	pop	r28
    5e48:	df 91       	pop	r29
    5e4a:	08 95       	ret

00005e4c <lcdPutc>:
}

/*
 * Writes a char on the LCD at the current position.
 */
void lcdPutc(char c) {
    5e4c:	1f 93       	push	r17
    5e4e:	18 2f       	mov	r17, r24
  PORTC &= ~PORTC_44780_E_MASK;
}

static void wait_not_busy(void) {

  chThdSleep(2);
    5e50:	82 e0       	ldi	r24, 0x02	; 2
    5e52:	90 e0       	ldi	r25, 0x00	; 0
    5e54:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
void lcdPutc(char c) {
  uint8_t b;

  wait_not_busy();
  b = c | 0x0F;
  PORTC = (PORTC | PORTC_44780_DATA_MASK | PORTC_44780_RS_MASK) &
    5e58:	88 b1       	in	r24, 0x08	; 8
    5e5a:	91 2f       	mov	r25, r17
    5e5c:	9f 60       	ori	r25, 0x0F	; 15
    5e5e:	81 6f       	ori	r24, 0xF1	; 241
    5e60:	98 23       	and	r25, r24
    5e62:	98 b9       	out	0x08, r25	; 8
          (c | 0x0F);
  e_pulse();
    5e64:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <e_pulse>
  PORTC = (PORTC | PORTC_44780_DATA_MASK | PORTC_44780_RS_MASK) &
    5e68:	88 b1       	in	r24, 0x08	; 8
    5e6a:	12 95       	swap	r17
    5e6c:	10 7f       	andi	r17, 0xF0	; 240
    5e6e:	1f 60       	ori	r17, 0x0F	; 15
    5e70:	81 6f       	ori	r24, 0xF1	; 241
    5e72:	81 23       	and	r24, r17
    5e74:	88 b9       	out	0x08, r24	; 8
          ((c << 4) | 0x0F);
  e_pulse();
    5e76:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <e_pulse>
}
    5e7a:	1f 91       	pop	r17
    5e7c:	08 95       	ret

00005e7e <lcdCmd>:
}

/*
 * Sends a command byte to the 44780.
 */
void lcdCmd(uint8_t cmd) {
    5e7e:	1f 93       	push	r17
    5e80:	18 2f       	mov	r17, r24
  PORTC &= ~PORTC_44780_E_MASK;
}

static void wait_not_busy(void) {

  chThdSleep(2);
    5e82:	82 e0       	ldi	r24, 0x02	; 2
    5e84:	90 e0       	ldi	r25, 0x00	; 0
    5e86:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
 * Sends a command byte to the 44780.
 */
void lcdCmd(uint8_t cmd) {

  wait_not_busy();
  PORTC = (PORTC | PORTC_44780_DATA_MASK) & (cmd |
    5e8a:	88 b1       	in	r24, 0x08	; 8
    5e8c:	91 2f       	mov	r25, r17
    5e8e:	9e 60       	ori	r25, 0x0E	; 14
    5e90:	80 6f       	ori	r24, 0xF0	; 240
    5e92:	98 23       	and	r25, r24
    5e94:	98 b9       	out	0x08, r25	; 8
                                             (0x0F & ~PORTC_44780_RS_MASK));
  e_pulse();
    5e96:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <e_pulse>
  PORTC = (PORTC | PORTC_44780_DATA_MASK) & ((cmd << 4) |
    5e9a:	88 b1       	in	r24, 0x08	; 8
    5e9c:	12 95       	swap	r17
    5e9e:	10 7f       	andi	r17, 0xF0	; 240
    5ea0:	1e 60       	ori	r17, 0x0E	; 14
    5ea2:	80 6f       	ori	r24, 0xF0	; 240
    5ea4:	81 23       	and	r24, r17
    5ea6:	88 b9       	out	0x08, r24	; 8
                                             (0x0F & ~PORTC_44780_RS_MASK));
  e_pulse();
    5ea8:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <e_pulse>
}
    5eac:	1f 91       	pop	r17
    5eae:	08 95       	ret

00005eb0 <lcdPuts>:
}

/*
 * Writes a string on the LCD at an absolute address.
 */
void lcdPuts(uint8_t pos, char *p) {
    5eb0:	cf 93       	push	r28
    5eb2:	df 93       	push	r29
    5eb4:	eb 01       	movw	r28, r22

  lcdCmd(LCD_SET_DDRAM_ADDRESS | pos);
    5eb6:	80 68       	ori	r24, 0x80	; 128
    5eb8:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <lcdCmd>
  while (*p)
    5ebc:	88 81       	ld	r24, Y
    5ebe:	88 23       	and	r24, r24
    5ec0:	31 f0       	breq	.+12     	; 0x5ece <lcdPuts+0x1e>
    lcdPutc(*p++);
    5ec2:	21 96       	adiw	r28, 0x01	; 1
    5ec4:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <lcdPutc>
 * Writes a string on the LCD at an absolute address.
 */
void lcdPuts(uint8_t pos, char *p) {

  lcdCmd(LCD_SET_DDRAM_ADDRESS | pos);
  while (*p)
    5ec8:	88 81       	ld	r24, Y
    5eca:	88 23       	and	r24, r24
    5ecc:	d1 f7       	brne	.-12     	; 0x5ec2 <lcdPuts+0x12>
    lcdPutc(*p++);
}
    5ece:	df 91       	pop	r29
    5ed0:	cf 91       	pop	r28
    5ed2:	08 95       	ret

00005ed4 <lcdInit>:
/*
 * 44780 soft reset procedure.
 */
void lcdInit(void) {

  PORTC = (PORTC & ~(PORTC_44780_DATA_MASK | PORTC_44780_RS_MASK |
    5ed4:	88 b1       	in	r24, 0x08	; 8
    5ed6:	88 70       	andi	r24, 0x08	; 8
    5ed8:	80 63       	ori	r24, 0x30	; 48
    5eda:	88 b9       	out	0x08, r24	; 8
                     PORTC_44780_E_MASK | PORTC_44780_RW_MASK)) |
          (LCD_CMD_INIT8 & PORTC_44780_DATA_MASK);
  chThdSleep(50);
    5edc:	82 e3       	ldi	r24, 0x32	; 50
    5ede:	90 e0       	ldi	r25, 0x00	; 0
    5ee0:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  e_pulse();
    5ee4:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <e_pulse>
  chThdSleep(10);
    5ee8:	8a e0       	ldi	r24, 0x0A	; 10
    5eea:	90 e0       	ldi	r25, 0x00	; 0
    5eec:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  e_pulse();
    5ef0:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <e_pulse>
  chThdSleep(2);
    5ef4:	82 e0       	ldi	r24, 0x02	; 2
    5ef6:	90 e0       	ldi	r25, 0x00	; 0
    5ef8:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  e_pulse();
    5efc:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <e_pulse>
  PORTC &= ~PORTC_44780_E_MASK;
}

static void wait_not_busy(void) {

  chThdSleep(2);
    5f00:	82 e0       	ldi	r24, 0x02	; 2
    5f02:	90 e0       	ldi	r25, 0x00	; 0
    5f04:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
  chThdSleep(10);
  e_pulse();
  chThdSleep(2);
  e_pulse();
  wait_not_busy();
  PORTC = (PORTC & ~(PORTC_44780_DATA_MASK | PORTC_44780_RS_MASK |
    5f08:	88 b1       	in	r24, 0x08	; 8
    5f0a:	88 70       	andi	r24, 0x08	; 8
    5f0c:	80 62       	ori	r24, 0x20	; 32
    5f0e:	88 b9       	out	0x08, r24	; 8
                     PORTC_44780_E_MASK | PORTC_44780_RW_MASK)) |
          (LCD_CMD_INIT4 & PORTC_44780_DATA_MASK);
  e_pulse();
    5f10:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <e_pulse>
  lcdCmd(LCD_CMD_INIT4);
    5f14:	88 e2       	ldi	r24, 0x28	; 40
    5f16:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <lcdCmd>
  lcdCmd(LCD_SET_DM | LCD_DM_DISPLAY_ON);
    5f1a:	8c e0       	ldi	r24, 0x0C	; 12
    5f1c:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <lcdCmd>
  lcdCmd(LCD_SET_INCREMENT_MODE);
    5f20:	86 e0       	ldi	r24, 0x06	; 6
    5f22:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <lcdCmd>
}
    5f26:	08 95       	ret

00005f28 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
    5f28:	0f 93       	push	r16
    5f2a:	1f 93       	push	r17
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
    5f2c:	0e 94 90 2c 	call	0x5920	; 0x5920 <halInit>
  chSysInit();
    5f30:	0e 94 0b 01 	call	0x216	; 0x216 <chSysInit>

  /*
   * Activates the serial driver 2 using the driver default configuration.
   */
  sdStart(&SD2, NULL);
    5f34:	84 ef       	ldi	r24, 0xF4	; 244
    5f36:	9e e0       	ldi	r25, 0x0E	; 14
    5f38:	60 e0       	ldi	r22, 0x00	; 0
    5f3a:	70 e0       	ldi	r23, 0x00	; 0
    5f3c:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <sdStart>

  /*
   * This initialization requires the OS already active because it uses delay
   * APIs inside.
   */
  lcdInit();
    5f40:	0e 94 6a 2f 	call	0x5ed4	; 0x5ed4 <lcdInit>
  lcdCmd(LCD_CLEAR);
    5f44:	81 e0       	ldi	r24, 0x01	; 1
    5f46:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <lcdCmd>
  lcdPuts(LCD_LINE1, "   ChibiOS/RT   ");
    5f4a:	80 e0       	ldi	r24, 0x00	; 0
    5f4c:	6e ec       	ldi	r22, 0xCE	; 206
    5f4e:	79 e0       	ldi	r23, 0x09	; 9
    5f50:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <lcdPuts>
  lcdPuts(LCD_LINE2, "  Hello World!  ");
    5f54:	88 e2       	ldi	r24, 0x28	; 40
    5f56:	6f ed       	ldi	r22, 0xDF	; 223
    5f58:	79 e0       	ldi	r23, 0x09	; 9
    5f5a:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <lcdPuts>

  /*
   * Starts the LED blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
    5f5e:	89 ef       	ldi	r24, 0xF9	; 249
    5f60:	9a e0       	ldi	r25, 0x0A	; 10
    5f62:	65 e8       	ldi	r22, 0x85	; 133
    5f64:	70 e0       	ldi	r23, 0x00	; 0
    5f66:	40 e4       	ldi	r20, 0x40	; 64
    5f68:	26 ec       	ldi	r18, 0xC6	; 198
    5f6a:	3f e2       	ldi	r19, 0x2F	; 47
    5f6c:	00 e0       	ldi	r16, 0x00	; 0
    5f6e:	10 e0       	ldi	r17, 0x00	; 0
    5f70:	0e 94 59 04 	call	0x8b2	; 0x8b2 <chThdCreateStatic>
    5f74:	04 c0       	rjmp	.+8      	; 0x5f7e <main+0x56>

  while(TRUE) {
    if (!palReadPad(IOPORT1, PORTA_BUTTON1))
      TestThread(&SD2);
    chThdSleepMilliseconds(500);
    5f76:	84 ef       	ldi	r24, 0xF4	; 244
    5f78:	91 e0       	ldi	r25, 0x01	; 1
    5f7a:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
   * Starts the LED blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);

  while(TRUE) {
    if (!palReadPad(IOPORT1, PORTA_BUTTON1))
    5f7e:	00 99       	sbic	0x00, 0	; 0
    5f80:	fa cf       	rjmp	.-12     	; 0x5f76 <main+0x4e>
      TestThread(&SD2);
    5f82:	84 ef       	ldi	r24, 0xF4	; 244
    5f84:	9e e0       	ldi	r25, 0x0E	; 14
    5f86:	0e 94 75 10 	call	0x20ea	; 0x20ea <TestThread>
    5f8a:	f5 cf       	rjmp	.-22     	; 0x5f76 <main+0x4e>

00005f8c <Thread1>:
#include "test.h"

#include "lcd.h"

static WORKING_AREA(waThread1, 32);
static msg_t Thread1(void *arg) {
    5f8c:	1f 93       	push	r17
    5f8e:	cf 93       	push	r28
    5f90:	df 93       	push	r29

  while (TRUE) {
    if (!palReadPad(IOPORT1, PORTA_BUTTON2))
    5f92:	c0 e2       	ldi	r28, 0x20	; 32
    5f94:	d0 e0       	ldi	r29, 0x00	; 0
      palTogglePad(IOPORT1, PORTA_RELAY);
    5f96:	10 e4       	ldi	r17, 0x40	; 64

static WORKING_AREA(waThread1, 32);
static msg_t Thread1(void *arg) {

  while (TRUE) {
    if (!palReadPad(IOPORT1, PORTA_BUTTON2))
    5f98:	01 99       	sbic	0x00, 1	; 0
    5f9a:	03 c0       	rjmp	.+6      	; 0x5fa2 <Thread1+0x16>
      palTogglePad(IOPORT1, PORTA_RELAY);
    5f9c:	82 b1       	in	r24, 0x02	; 2
    5f9e:	81 27       	eor	r24, r17
    5fa0:	8a 83       	std	Y+2, r24	; 0x02
    chThdSleepMilliseconds(1000);
    5fa2:	88 ee       	ldi	r24, 0xE8	; 232
    5fa4:	93 e0       	ldi	r25, 0x03	; 3
    5fa6:	0e 94 43 04 	call	0x886	; 0x886 <chThdSleep>
    5faa:	f6 cf       	rjmp	.-20     	; 0x5f98 <Thread1+0xc>

00005fac <vfprintf>:
    5fac:	6f 92       	push	r6
    5fae:	7f 92       	push	r7
    5fb0:	8f 92       	push	r8
    5fb2:	9f 92       	push	r9
    5fb4:	af 92       	push	r10
    5fb6:	bf 92       	push	r11
    5fb8:	cf 92       	push	r12
    5fba:	df 92       	push	r13
    5fbc:	ef 92       	push	r14
    5fbe:	ff 92       	push	r15
    5fc0:	0f 93       	push	r16
    5fc2:	1f 93       	push	r17
    5fc4:	df 93       	push	r29
    5fc6:	cf 93       	push	r28
    5fc8:	cd b7       	in	r28, 0x3d	; 61
    5fca:	de b7       	in	r29, 0x3e	; 62
    5fcc:	2b 97       	sbiw	r28, 0x0b	; 11
    5fce:	0f b6       	in	r0, 0x3f	; 63
    5fd0:	f8 94       	cli
    5fd2:	de bf       	out	0x3e, r29	; 62
    5fd4:	0f be       	out	0x3f, r0	; 63
    5fd6:	cd bf       	out	0x3d, r28	; 61
    5fd8:	5c 01       	movw	r10, r24
    5fda:	4b 01       	movw	r8, r22
    5fdc:	7a 01       	movw	r14, r20
    5fde:	fc 01       	movw	r30, r24
    5fe0:	17 82       	std	Z+7, r1	; 0x07
    5fe2:	16 82       	std	Z+6, r1	; 0x06
    5fe4:	83 81       	ldd	r24, Z+3	; 0x03
    5fe6:	81 fd       	sbrc	r24, 1
    5fe8:	08 c0       	rjmp	.+16     	; 0x5ffa <vfprintf+0x4e>
    5fea:	6f ef       	ldi	r22, 0xFF	; 255
    5fec:	7f ef       	ldi	r23, 0xFF	; 255
    5fee:	08 c1       	rjmp	.+528    	; 0x6200 <vfprintf+0x254>
    5ff0:	42 e0       	ldi	r20, 0x02	; 2
    5ff2:	50 e0       	ldi	r21, 0x00	; 0
    5ff4:	e4 0e       	add	r14, r20
    5ff6:	f5 1e       	adc	r15, r21
    5ff8:	04 c0       	rjmp	.+8      	; 0x6002 <vfprintf+0x56>
    5ffa:	3e 01       	movw	r6, r28
    5ffc:	08 94       	sec
    5ffe:	61 1c       	adc	r6, r1
    6000:	71 1c       	adc	r7, r1
    6002:	f5 01       	movw	r30, r10
    6004:	d3 80       	ldd	r13, Z+3	; 0x03
    6006:	f4 01       	movw	r30, r8
    6008:	d3 fc       	sbrc	r13, 3
    600a:	85 91       	lpm	r24, Z+
    600c:	d3 fe       	sbrs	r13, 3
    600e:	81 91       	ld	r24, Z+
    6010:	4f 01       	movw	r8, r30
    6012:	88 23       	and	r24, r24
    6014:	09 f4       	brne	.+2      	; 0x6018 <vfprintf+0x6c>
    6016:	f1 c0       	rjmp	.+482    	; 0x61fa <vfprintf+0x24e>
    6018:	85 32       	cpi	r24, 0x25	; 37
    601a:	59 f4       	brne	.+22     	; 0x6032 <vfprintf+0x86>
    601c:	d3 fc       	sbrc	r13, 3
    601e:	65 91       	lpm	r22, Z+
    6020:	d3 fe       	sbrs	r13, 3
    6022:	61 91       	ld	r22, Z+
    6024:	4f 01       	movw	r8, r30
    6026:	65 32       	cpi	r22, 0x25	; 37
    6028:	19 f0       	breq	.+6      	; 0x6030 <vfprintf+0x84>
    602a:	06 2f       	mov	r16, r22
    602c:	10 e0       	ldi	r17, 0x00	; 0
    602e:	1b c0       	rjmp	.+54     	; 0x6066 <vfprintf+0xba>
    6030:	85 e2       	ldi	r24, 0x25	; 37
    6032:	90 e0       	ldi	r25, 0x00	; 0
    6034:	2b c0       	rjmp	.+86     	; 0x608c <vfprintf+0xe0>
    6036:	00 23       	and	r16, r16
    6038:	09 f4       	brne	.+2      	; 0x603c <vfprintf+0x90>
    603a:	df c0       	rjmp	.+446    	; 0x61fa <vfprintf+0x24e>
    603c:	83 e9       	ldi	r24, 0x93	; 147
    603e:	90 e0       	ldi	r25, 0x00	; 0
    6040:	60 2f       	mov	r22, r16
    6042:	70 e0       	ldi	r23, 0x00	; 0
    6044:	0e 94 59 33 	call	0x66b2	; 0x66b2 <strchr_P>
    6048:	89 2b       	or	r24, r25
    604a:	39 f4       	brne	.+14     	; 0x605a <vfprintf+0xae>
    604c:	03 32       	cpi	r16, 0x23	; 35
    604e:	11 f4       	brne	.+4      	; 0x6054 <vfprintf+0xa8>
    6050:	10 61       	ori	r17, 0x10	; 16
    6052:	03 c0       	rjmp	.+6      	; 0x605a <vfprintf+0xae>
    6054:	0c 36       	cpi	r16, 0x6C	; 108
    6056:	61 f4       	brne	.+24     	; 0x6070 <vfprintf+0xc4>
    6058:	10 68       	ori	r17, 0x80	; 128
    605a:	f4 01       	movw	r30, r8
    605c:	d3 fc       	sbrc	r13, 3
    605e:	05 91       	lpm	r16, Z+
    6060:	d3 fe       	sbrs	r13, 3
    6062:	01 91       	ld	r16, Z+
    6064:	4f 01       	movw	r8, r30
    6066:	17 ff       	sbrs	r17, 7
    6068:	e6 cf       	rjmp	.-52     	; 0x6036 <vfprintf+0x8a>
    606a:	00 23       	and	r16, r16
    606c:	09 f4       	brne	.+2      	; 0x6070 <vfprintf+0xc4>
    606e:	c5 c0       	rjmp	.+394    	; 0x61fa <vfprintf+0x24e>
    6070:	8c e8       	ldi	r24, 0x8C	; 140
    6072:	90 e0       	ldi	r25, 0x00	; 0
    6074:	60 2f       	mov	r22, r16
    6076:	70 e0       	ldi	r23, 0x00	; 0
    6078:	0e 94 59 33 	call	0x66b2	; 0x66b2 <strchr_P>
    607c:	89 2b       	or	r24, r25
    607e:	51 f0       	breq	.+20     	; 0x6094 <vfprintf+0xe8>
    6080:	44 e0       	ldi	r20, 0x04	; 4
    6082:	50 e0       	ldi	r21, 0x00	; 0
    6084:	e4 0e       	add	r14, r20
    6086:	f5 1e       	adc	r15, r21
    6088:	8f e3       	ldi	r24, 0x3F	; 63
    608a:	90 e0       	ldi	r25, 0x00	; 0
    608c:	b5 01       	movw	r22, r10
    608e:	0e 94 a6 33 	call	0x674c	; 0x674c <fputc>
    6092:	b7 cf       	rjmp	.-146    	; 0x6002 <vfprintf+0x56>
    6094:	03 36       	cpi	r16, 0x63	; 99
    6096:	29 f0       	breq	.+10     	; 0x60a2 <vfprintf+0xf6>
    6098:	03 37       	cpi	r16, 0x73	; 115
    609a:	79 f0       	breq	.+30     	; 0x60ba <vfprintf+0x10e>
    609c:	03 35       	cpi	r16, 0x53	; 83
    609e:	f1 f4       	brne	.+60     	; 0x60dc <vfprintf+0x130>
    60a0:	0b c0       	rjmp	.+22     	; 0x60b8 <vfprintf+0x10c>
    60a2:	87 01       	movw	r16, r14
    60a4:	0e 5f       	subi	r16, 0xFE	; 254
    60a6:	1f 4f       	sbci	r17, 0xFF	; 255
    60a8:	f7 01       	movw	r30, r14
    60aa:	80 81       	ld	r24, Z
    60ac:	91 81       	ldd	r25, Z+1	; 0x01
    60ae:	b5 01       	movw	r22, r10
    60b0:	0e 94 a6 33 	call	0x674c	; 0x674c <fputc>
    60b4:	78 01       	movw	r14, r16
    60b6:	a5 cf       	rjmp	.-182    	; 0x6002 <vfprintf+0x56>
    60b8:	11 60       	ori	r17, 0x01	; 1
    60ba:	f7 01       	movw	r30, r14
    60bc:	c0 80       	ld	r12, Z
    60be:	d1 80       	ldd	r13, Z+1	; 0x01
    60c0:	04 c0       	rjmp	.+8      	; 0x60ca <vfprintf+0x11e>
    60c2:	90 e0       	ldi	r25, 0x00	; 0
    60c4:	b5 01       	movw	r22, r10
    60c6:	0e 94 a6 33 	call	0x674c	; 0x674c <fputc>
    60ca:	f6 01       	movw	r30, r12
    60cc:	10 fd       	sbrc	r17, 0
    60ce:	85 91       	lpm	r24, Z+
    60d0:	10 ff       	sbrs	r17, 0
    60d2:	81 91       	ld	r24, Z+
    60d4:	6f 01       	movw	r12, r30
    60d6:	88 23       	and	r24, r24
    60d8:	a1 f7       	brne	.-24     	; 0x60c2 <vfprintf+0x116>
    60da:	8a cf       	rjmp	.-236    	; 0x5ff0 <vfprintf+0x44>
    60dc:	04 36       	cpi	r16, 0x64	; 100
    60de:	11 f0       	breq	.+4      	; 0x60e4 <vfprintf+0x138>
    60e0:	09 36       	cpi	r16, 0x69	; 105
    60e2:	39 f5       	brne	.+78     	; 0x6132 <vfprintf+0x186>
    60e4:	17 ff       	sbrs	r17, 7
    60e6:	08 c0       	rjmp	.+16     	; 0x60f8 <vfprintf+0x14c>
    60e8:	f7 01       	movw	r30, r14
    60ea:	20 81       	ld	r18, Z
    60ec:	31 81       	ldd	r19, Z+1	; 0x01
    60ee:	42 81       	ldd	r20, Z+2	; 0x02
    60f0:	53 81       	ldd	r21, Z+3	; 0x03
    60f2:	84 e0       	ldi	r24, 0x04	; 4
    60f4:	90 e0       	ldi	r25, 0x00	; 0
    60f6:	0a c0       	rjmp	.+20     	; 0x610c <vfprintf+0x160>
    60f8:	f7 01       	movw	r30, r14
    60fa:	80 81       	ld	r24, Z
    60fc:	91 81       	ldd	r25, Z+1	; 0x01
    60fe:	9c 01       	movw	r18, r24
    6100:	44 27       	eor	r20, r20
    6102:	37 fd       	sbrc	r19, 7
    6104:	40 95       	com	r20
    6106:	54 2f       	mov	r21, r20
    6108:	82 e0       	ldi	r24, 0x02	; 2
    610a:	90 e0       	ldi	r25, 0x00	; 0
    610c:	e8 0e       	add	r14, r24
    610e:	f9 1e       	adc	r15, r25
    6110:	1f 7e       	andi	r17, 0xEF	; 239
    6112:	57 ff       	sbrs	r21, 7
    6114:	08 c0       	rjmp	.+16     	; 0x6126 <vfprintf+0x17a>
    6116:	50 95       	com	r21
    6118:	40 95       	com	r20
    611a:	30 95       	com	r19
    611c:	21 95       	neg	r18
    611e:	3f 4f       	sbci	r19, 0xFF	; 255
    6120:	4f 4f       	sbci	r20, 0xFF	; 255
    6122:	5f 4f       	sbci	r21, 0xFF	; 255
    6124:	10 64       	ori	r17, 0x40	; 64
    6126:	ca 01       	movw	r24, r20
    6128:	b9 01       	movw	r22, r18
    612a:	a3 01       	movw	r20, r6
    612c:	2a e0       	ldi	r18, 0x0A	; 10
    612e:	30 e0       	ldi	r19, 0x00	; 0
    6130:	34 c0       	rjmp	.+104    	; 0x619a <vfprintf+0x1ee>
    6132:	00 37       	cpi	r16, 0x70	; 112
    6134:	a9 f0       	breq	.+42     	; 0x6160 <vfprintf+0x1b4>
    6136:	01 37       	cpi	r16, 0x71	; 113
    6138:	30 f4       	brcc	.+12     	; 0x6146 <vfprintf+0x19a>
    613a:	08 35       	cpi	r16, 0x58	; 88
    613c:	b1 f0       	breq	.+44     	; 0x616a <vfprintf+0x1be>
    613e:	0f 36       	cpi	r16, 0x6F	; 111
    6140:	09 f0       	breq	.+2      	; 0x6144 <vfprintf+0x198>
    6142:	5b c0       	rjmp	.+182    	; 0x61fa <vfprintf+0x24e>
    6144:	06 c0       	rjmp	.+12     	; 0x6152 <vfprintf+0x1a6>
    6146:	05 37       	cpi	r16, 0x75	; 117
    6148:	39 f0       	breq	.+14     	; 0x6158 <vfprintf+0x1ac>
    614a:	08 37       	cpi	r16, 0x78	; 120
    614c:	09 f0       	breq	.+2      	; 0x6150 <vfprintf+0x1a4>
    614e:	55 c0       	rjmp	.+170    	; 0x61fa <vfprintf+0x24e>
    6150:	08 c0       	rjmp	.+16     	; 0x6162 <vfprintf+0x1b6>
    6152:	28 e0       	ldi	r18, 0x08	; 8
    6154:	30 e0       	ldi	r19, 0x00	; 0
    6156:	0c c0       	rjmp	.+24     	; 0x6170 <vfprintf+0x1c4>
    6158:	1f 7e       	andi	r17, 0xEF	; 239
    615a:	2a e0       	ldi	r18, 0x0A	; 10
    615c:	30 e0       	ldi	r19, 0x00	; 0
    615e:	08 c0       	rjmp	.+16     	; 0x6170 <vfprintf+0x1c4>
    6160:	10 61       	ori	r17, 0x10	; 16
    6162:	14 62       	ori	r17, 0x24	; 36
    6164:	20 e1       	ldi	r18, 0x10	; 16
    6166:	30 e0       	ldi	r19, 0x00	; 0
    6168:	03 c0       	rjmp	.+6      	; 0x6170 <vfprintf+0x1c4>
    616a:	14 60       	ori	r17, 0x04	; 4
    616c:	20 e1       	ldi	r18, 0x10	; 16
    616e:	32 e0       	ldi	r19, 0x02	; 2
    6170:	17 ff       	sbrs	r17, 7
    6172:	08 c0       	rjmp	.+16     	; 0x6184 <vfprintf+0x1d8>
    6174:	f7 01       	movw	r30, r14
    6176:	60 81       	ld	r22, Z
    6178:	71 81       	ldd	r23, Z+1	; 0x01
    617a:	82 81       	ldd	r24, Z+2	; 0x02
    617c:	93 81       	ldd	r25, Z+3	; 0x03
    617e:	44 e0       	ldi	r20, 0x04	; 4
    6180:	50 e0       	ldi	r21, 0x00	; 0
    6182:	08 c0       	rjmp	.+16     	; 0x6194 <vfprintf+0x1e8>
    6184:	f7 01       	movw	r30, r14
    6186:	80 81       	ld	r24, Z
    6188:	91 81       	ldd	r25, Z+1	; 0x01
    618a:	bc 01       	movw	r22, r24
    618c:	80 e0       	ldi	r24, 0x00	; 0
    618e:	90 e0       	ldi	r25, 0x00	; 0
    6190:	42 e0       	ldi	r20, 0x02	; 2
    6192:	50 e0       	ldi	r21, 0x00	; 0
    6194:	e4 0e       	add	r14, r20
    6196:	f5 1e       	adc	r15, r21
    6198:	a3 01       	movw	r20, r6
    619a:	0e 94 ec 33 	call	0x67d8	; 0x67d8 <__ultoa_invert>
    619e:	d8 2e       	mov	r13, r24
    61a0:	d6 18       	sub	r13, r6
    61a2:	01 2f       	mov	r16, r17
    61a4:	10 e0       	ldi	r17, 0x00	; 0
    61a6:	06 ff       	sbrs	r16, 6
    61a8:	05 c0       	rjmp	.+10     	; 0x61b4 <vfprintf+0x208>
    61aa:	8d e2       	ldi	r24, 0x2D	; 45
    61ac:	90 e0       	ldi	r25, 0x00	; 0
    61ae:	b5 01       	movw	r22, r10
    61b0:	0e 94 a6 33 	call	0x674c	; 0x674c <fputc>
    61b4:	04 ff       	sbrs	r16, 4
    61b6:	15 c0       	rjmp	.+42     	; 0x61e2 <vfprintf+0x236>
    61b8:	fe 01       	movw	r30, r28
    61ba:	ed 0d       	add	r30, r13
    61bc:	f1 1d       	adc	r31, r1
    61be:	80 81       	ld	r24, Z
    61c0:	80 33       	cpi	r24, 0x30	; 48
    61c2:	79 f0       	breq	.+30     	; 0x61e2 <vfprintf+0x236>
    61c4:	80 e3       	ldi	r24, 0x30	; 48
    61c6:	90 e0       	ldi	r25, 0x00	; 0
    61c8:	b5 01       	movw	r22, r10
    61ca:	0e 94 a6 33 	call	0x674c	; 0x674c <fputc>
    61ce:	02 ff       	sbrs	r16, 2
    61d0:	08 c0       	rjmp	.+16     	; 0x61e2 <vfprintf+0x236>
    61d2:	00 72       	andi	r16, 0x20	; 32
    61d4:	10 70       	andi	r17, 0x00	; 0
    61d6:	c8 01       	movw	r24, r16
    61d8:	88 5a       	subi	r24, 0xA8	; 168
    61da:	9f 4f       	sbci	r25, 0xFF	; 255
    61dc:	b5 01       	movw	r22, r10
    61de:	0e 94 a6 33 	call	0x674c	; 0x674c <fputc>
    61e2:	da 94       	dec	r13
    61e4:	f3 01       	movw	r30, r6
    61e6:	ed 0d       	add	r30, r13
    61e8:	f1 1d       	adc	r31, r1
    61ea:	80 81       	ld	r24, Z
    61ec:	90 e0       	ldi	r25, 0x00	; 0
    61ee:	b5 01       	movw	r22, r10
    61f0:	0e 94 a6 33 	call	0x674c	; 0x674c <fputc>
    61f4:	dd 20       	and	r13, r13
    61f6:	a9 f7       	brne	.-22     	; 0x61e2 <vfprintf+0x236>
    61f8:	04 cf       	rjmp	.-504    	; 0x6002 <vfprintf+0x56>
    61fa:	f5 01       	movw	r30, r10
    61fc:	66 81       	ldd	r22, Z+6	; 0x06
    61fe:	77 81       	ldd	r23, Z+7	; 0x07
    6200:	cb 01       	movw	r24, r22
    6202:	2b 96       	adiw	r28, 0x0b	; 11
    6204:	0f b6       	in	r0, 0x3f	; 63
    6206:	f8 94       	cli
    6208:	de bf       	out	0x3e, r29	; 62
    620a:	0f be       	out	0x3f, r0	; 63
    620c:	cd bf       	out	0x3d, r28	; 61
    620e:	cf 91       	pop	r28
    6210:	df 91       	pop	r29
    6212:	1f 91       	pop	r17
    6214:	0f 91       	pop	r16
    6216:	ff 90       	pop	r15
    6218:	ef 90       	pop	r14
    621a:	df 90       	pop	r13
    621c:	cf 90       	pop	r12
    621e:	bf 90       	pop	r11
    6220:	af 90       	pop	r10
    6222:	9f 90       	pop	r9
    6224:	8f 90       	pop	r8
    6226:	7f 90       	pop	r7
    6228:	6f 90       	pop	r6
    622a:	08 95       	ret

0000622c <putval>:
    622c:	fc 01       	movw	r30, r24
    622e:	20 fd       	sbrc	r18, 0
    6230:	08 c0       	rjmp	.+16     	; 0x6242 <putval+0x16>
    6232:	23 fd       	sbrc	r18, 3
    6234:	05 c0       	rjmp	.+10     	; 0x6240 <putval+0x14>
    6236:	22 ff       	sbrs	r18, 2
    6238:	02 c0       	rjmp	.+4      	; 0x623e <putval+0x12>
    623a:	73 83       	std	Z+3, r23	; 0x03
    623c:	62 83       	std	Z+2, r22	; 0x02
    623e:	51 83       	std	Z+1, r21	; 0x01
    6240:	40 83       	st	Z, r20
    6242:	08 95       	ret

00006244 <mulacc>:
    6244:	ef 92       	push	r14
    6246:	ff 92       	push	r15
    6248:	0f 93       	push	r16
    624a:	1f 93       	push	r17
    624c:	44 ff       	sbrs	r20, 4
    624e:	02 c0       	rjmp	.+4      	; 0x6254 <mulacc+0x10>
    6250:	33 e0       	ldi	r19, 0x03	; 3
    6252:	11 c0       	rjmp	.+34     	; 0x6276 <mulacc+0x32>
    6254:	46 ff       	sbrs	r20, 6
    6256:	02 c0       	rjmp	.+4      	; 0x625c <mulacc+0x18>
    6258:	34 e0       	ldi	r19, 0x04	; 4
    625a:	0d c0       	rjmp	.+26     	; 0x6276 <mulacc+0x32>
    625c:	db 01       	movw	r26, r22
    625e:	fc 01       	movw	r30, r24
    6260:	aa 0f       	add	r26, r26
    6262:	bb 1f       	adc	r27, r27
    6264:	ee 1f       	adc	r30, r30
    6266:	ff 1f       	adc	r31, r31
    6268:	10 94       	com	r1
    626a:	d1 f7       	brne	.-12     	; 0x6260 <mulacc+0x1c>
    626c:	6a 0f       	add	r22, r26
    626e:	7b 1f       	adc	r23, r27
    6270:	8e 1f       	adc	r24, r30
    6272:	9f 1f       	adc	r25, r31
    6274:	31 e0       	ldi	r19, 0x01	; 1
    6276:	66 0f       	add	r22, r22
    6278:	77 1f       	adc	r23, r23
    627a:	88 1f       	adc	r24, r24
    627c:	99 1f       	adc	r25, r25
    627e:	31 50       	subi	r19, 0x01	; 1
    6280:	d1 f7       	brne	.-12     	; 0x6276 <mulacc+0x32>
    6282:	7b 01       	movw	r14, r22
    6284:	8c 01       	movw	r16, r24
    6286:	e2 0e       	add	r14, r18
    6288:	f1 1c       	adc	r15, r1
    628a:	01 1d       	adc	r16, r1
    628c:	11 1d       	adc	r17, r1
    628e:	a8 01       	movw	r20, r16
    6290:	97 01       	movw	r18, r14
    6292:	b7 01       	movw	r22, r14
    6294:	ca 01       	movw	r24, r20
    6296:	1f 91       	pop	r17
    6298:	0f 91       	pop	r16
    629a:	ff 90       	pop	r15
    629c:	ef 90       	pop	r14
    629e:	08 95       	ret

000062a0 <skip_spaces>:
    62a0:	0f 93       	push	r16
    62a2:	1f 93       	push	r17
    62a4:	cf 93       	push	r28
    62a6:	df 93       	push	r29
    62a8:	8c 01       	movw	r16, r24
    62aa:	c8 01       	movw	r24, r16
    62ac:	0e 94 64 33 	call	0x66c8	; 0x66c8 <fgetc>
    62b0:	ec 01       	movw	r28, r24
    62b2:	97 fd       	sbrc	r25, 7
    62b4:	08 c0       	rjmp	.+16     	; 0x62c6 <skip_spaces+0x26>
    62b6:	0e 94 51 33 	call	0x66a2	; 0x66a2 <isspace>
    62ba:	89 2b       	or	r24, r25
    62bc:	b1 f7       	brne	.-20     	; 0x62aa <skip_spaces+0xa>
    62be:	ce 01       	movw	r24, r28
    62c0:	b8 01       	movw	r22, r16
    62c2:	0e 94 d2 33 	call	0x67a4	; 0x67a4 <ungetc>
    62c6:	ce 01       	movw	r24, r28
    62c8:	df 91       	pop	r29
    62ca:	cf 91       	pop	r28
    62cc:	1f 91       	pop	r17
    62ce:	0f 91       	pop	r16
    62d0:	08 95       	ret

000062d2 <conv_int>:
    62d2:	af 92       	push	r10
    62d4:	bf 92       	push	r11
    62d6:	cf 92       	push	r12
    62d8:	df 92       	push	r13
    62da:	ef 92       	push	r14
    62dc:	ff 92       	push	r15
    62de:	0f 93       	push	r16
    62e0:	1f 93       	push	r17
    62e2:	cf 93       	push	r28
    62e4:	df 93       	push	r29
    62e6:	ec 01       	movw	r28, r24
    62e8:	c6 2e       	mov	r12, r22
    62ea:	5a 01       	movw	r10, r20
    62ec:	12 2f       	mov	r17, r18
    62ee:	0e 94 64 33 	call	0x66c8	; 0x66c8 <fgetc>
    62f2:	ac 01       	movw	r20, r24
    62f4:	8b 32       	cpi	r24, 0x2B	; 43
    62f6:	19 f0       	breq	.+6      	; 0x62fe <conv_int+0x2c>
    62f8:	8d 32       	cpi	r24, 0x2D	; 45
    62fa:	51 f4       	brne	.+20     	; 0x6310 <conv_int+0x3e>
    62fc:	10 68       	ori	r17, 0x80	; 128
    62fe:	ca 94       	dec	r12
    6300:	09 f4       	brne	.+2      	; 0x6304 <conv_int+0x32>
    6302:	6d c0       	rjmp	.+218    	; 0x63de <conv_int+0x10c>
    6304:	ce 01       	movw	r24, r28
    6306:	0e 94 64 33 	call	0x66c8	; 0x66c8 <fgetc>
    630a:	ac 01       	movw	r20, r24
    630c:	97 fd       	sbrc	r25, 7
    630e:	67 c0       	rjmp	.+206    	; 0x63de <conv_int+0x10c>
    6310:	6d ef       	ldi	r22, 0xFD	; 253
    6312:	d6 2e       	mov	r13, r22
    6314:	d1 22       	and	r13, r17
    6316:	8d 2d       	mov	r24, r13
    6318:	80 73       	andi	r24, 0x30	; 48
    631a:	01 f5       	brne	.+64     	; 0x635c <conv_int+0x8a>
    631c:	40 33       	cpi	r20, 0x30	; 48
    631e:	f1 f4       	brne	.+60     	; 0x635c <conv_int+0x8a>
    6320:	ca 94       	dec	r12
    6322:	09 f4       	brne	.+2      	; 0x6326 <conv_int+0x54>
    6324:	47 c0       	rjmp	.+142    	; 0x63b4 <conv_int+0xe2>
    6326:	ce 01       	movw	r24, r28
    6328:	0e 94 64 33 	call	0x66c8	; 0x66c8 <fgetc>
    632c:	ac 01       	movw	r20, r24
    632e:	97 fd       	sbrc	r25, 7
    6330:	41 c0       	rjmp	.+130    	; 0x63b4 <conv_int+0xe2>
    6332:	82 e0       	ldi	r24, 0x02	; 2
    6334:	d8 2a       	or	r13, r24
    6336:	48 37       	cpi	r20, 0x78	; 120
    6338:	11 f0       	breq	.+4      	; 0x633e <conv_int+0x6c>
    633a:	48 35       	cpi	r20, 0x58	; 88
    633c:	59 f4       	brne	.+22     	; 0x6354 <conv_int+0x82>
    633e:	80 e4       	ldi	r24, 0x40	; 64
    6340:	d8 2a       	or	r13, r24
    6342:	ca 94       	dec	r12
    6344:	b9 f1       	breq	.+110    	; 0x63b4 <conv_int+0xe2>
    6346:	ce 01       	movw	r24, r28
    6348:	0e 94 64 33 	call	0x66c8	; 0x66c8 <fgetc>
    634c:	ac 01       	movw	r20, r24
    634e:	99 23       	and	r25, r25
    6350:	2c f4       	brge	.+10     	; 0x635c <conv_int+0x8a>
    6352:	30 c0       	rjmp	.+96     	; 0x63b4 <conv_int+0xe2>
    6354:	d6 fc       	sbrc	r13, 6
    6356:	02 c0       	rjmp	.+4      	; 0x635c <conv_int+0x8a>
    6358:	80 e1       	ldi	r24, 0x10	; 16
    635a:	d8 2a       	or	r13, r24
    635c:	ee 24       	eor	r14, r14
    635e:	ff 24       	eor	r15, r15
    6360:	87 01       	movw	r16, r14
    6362:	24 2f       	mov	r18, r20
    6364:	20 53       	subi	r18, 0x30	; 48
    6366:	28 30       	cpi	r18, 0x08	; 8
    6368:	88 f0       	brcs	.+34     	; 0x638c <conv_int+0xba>
    636a:	d4 fc       	sbrc	r13, 4
    636c:	09 c0       	rjmp	.+18     	; 0x6380 <conv_int+0xae>
    636e:	2a 30       	cpi	r18, 0x0A	; 10
    6370:	68 f0       	brcs	.+26     	; 0x638c <conv_int+0xba>
    6372:	d6 fe       	sbrs	r13, 6
    6374:	05 c0       	rjmp	.+10     	; 0x6380 <conv_int+0xae>
    6376:	2f 7d       	andi	r18, 0xDF	; 223
    6378:	82 2f       	mov	r24, r18
    637a:	81 51       	subi	r24, 0x11	; 17
    637c:	86 30       	cpi	r24, 0x06	; 6
    637e:	28 f0       	brcs	.+10     	; 0x638a <conv_int+0xb8>
    6380:	ca 01       	movw	r24, r20
    6382:	be 01       	movw	r22, r28
    6384:	0e 94 d2 33 	call	0x67a4	; 0x67a4 <ungetc>
    6388:	12 c0       	rjmp	.+36     	; 0x63ae <conv_int+0xdc>
    638a:	27 50       	subi	r18, 0x07	; 7
    638c:	c8 01       	movw	r24, r16
    638e:	b7 01       	movw	r22, r14
    6390:	4d 2d       	mov	r20, r13
    6392:	0e 94 22 31 	call	0x6244	; 0x6244 <mulacc>
    6396:	7b 01       	movw	r14, r22
    6398:	8c 01       	movw	r16, r24
    639a:	82 e0       	ldi	r24, 0x02	; 2
    639c:	d8 2a       	or	r13, r24
    639e:	ca 94       	dec	r12
    63a0:	61 f0       	breq	.+24     	; 0x63ba <conv_int+0xe8>
    63a2:	ce 01       	movw	r24, r28
    63a4:	0e 94 64 33 	call	0x66c8	; 0x66c8 <fgetc>
    63a8:	ac 01       	movw	r20, r24
    63aa:	97 ff       	sbrs	r25, 7
    63ac:	da cf       	rjmp	.-76     	; 0x6362 <conv_int+0x90>
    63ae:	d1 fc       	sbrc	r13, 1
    63b0:	04 c0       	rjmp	.+8      	; 0x63ba <conv_int+0xe8>
    63b2:	15 c0       	rjmp	.+42     	; 0x63de <conv_int+0x10c>
    63b4:	ee 24       	eor	r14, r14
    63b6:	ff 24       	eor	r15, r15
    63b8:	87 01       	movw	r16, r14
    63ba:	d7 fe       	sbrs	r13, 7
    63bc:	08 c0       	rjmp	.+16     	; 0x63ce <conv_int+0xfc>
    63be:	10 95       	com	r17
    63c0:	00 95       	com	r16
    63c2:	f0 94       	com	r15
    63c4:	e0 94       	com	r14
    63c6:	e1 1c       	adc	r14, r1
    63c8:	f1 1c       	adc	r15, r1
    63ca:	01 1d       	adc	r16, r1
    63cc:	11 1d       	adc	r17, r1
    63ce:	c5 01       	movw	r24, r10
    63d0:	b8 01       	movw	r22, r16
    63d2:	a7 01       	movw	r20, r14
    63d4:	2d 2d       	mov	r18, r13
    63d6:	0e 94 16 31 	call	0x622c	; 0x622c <putval>
    63da:	81 e0       	ldi	r24, 0x01	; 1
    63dc:	01 c0       	rjmp	.+2      	; 0x63e0 <conv_int+0x10e>
    63de:	80 e0       	ldi	r24, 0x00	; 0
    63e0:	df 91       	pop	r29
    63e2:	cf 91       	pop	r28
    63e4:	1f 91       	pop	r17
    63e6:	0f 91       	pop	r16
    63e8:	ff 90       	pop	r15
    63ea:	ef 90       	pop	r14
    63ec:	df 90       	pop	r13
    63ee:	cf 90       	pop	r12
    63f0:	bf 90       	pop	r11
    63f2:	af 90       	pop	r10
    63f4:	08 95       	ret

000063f6 <vfscanf>:
    63f6:	6f 92       	push	r6
    63f8:	7f 92       	push	r7
    63fa:	8f 92       	push	r8
    63fc:	9f 92       	push	r9
    63fe:	af 92       	push	r10
    6400:	bf 92       	push	r11
    6402:	cf 92       	push	r12
    6404:	df 92       	push	r13
    6406:	ef 92       	push	r14
    6408:	ff 92       	push	r15
    640a:	0f 93       	push	r16
    640c:	1f 93       	push	r17
    640e:	cf 93       	push	r28
    6410:	df 93       	push	r29
    6412:	5c 01       	movw	r10, r24
    6414:	6b 01       	movw	r12, r22
    6416:	3a 01       	movw	r6, r20
    6418:	fc 01       	movw	r30, r24
    641a:	17 82       	std	Z+7, r1	; 0x07
    641c:	16 82       	std	Z+6, r1	; 0x06
    641e:	88 24       	eor	r8, r8
    6420:	dc c0       	rjmp	.+440    	; 0x65da <vfscanf+0x1e4>
    6422:	81 2f       	mov	r24, r17
    6424:	90 e0       	ldi	r25, 0x00	; 0
    6426:	0e 94 51 33 	call	0x66a2	; 0x66a2 <isspace>
    642a:	89 2b       	or	r24, r25
    642c:	21 f0       	breq	.+8      	; 0x6436 <vfscanf+0x40>
    642e:	c5 01       	movw	r24, r10
    6430:	0e 94 50 31 	call	0x62a0	; 0x62a0 <skip_spaces>
    6434:	d2 c0       	rjmp	.+420    	; 0x65da <vfscanf+0x1e4>
    6436:	15 32       	cpi	r17, 0x25	; 37
    6438:	49 f4       	brne	.+18     	; 0x644c <vfscanf+0x56>
    643a:	f6 01       	movw	r30, r12
    643c:	f3 fc       	sbrc	r15, 3
    643e:	65 91       	lpm	r22, Z+
    6440:	f3 fe       	sbrs	r15, 3
    6442:	61 91       	ld	r22, Z+
    6444:	6f 01       	movw	r12, r30
    6446:	65 32       	cpi	r22, 0x25	; 37
    6448:	69 f4       	brne	.+26     	; 0x6464 <vfscanf+0x6e>
    644a:	15 e2       	ldi	r17, 0x25	; 37
    644c:	c5 01       	movw	r24, r10
    644e:	0e 94 64 33 	call	0x66c8	; 0x66c8 <fgetc>
    6452:	97 fd       	sbrc	r25, 7
    6454:	ce c0       	rjmp	.+412    	; 0x65f2 <vfscanf+0x1fc>
    6456:	18 17       	cp	r17, r24
    6458:	09 f4       	brne	.+2      	; 0x645c <vfscanf+0x66>
    645a:	bf c0       	rjmp	.+382    	; 0x65da <vfscanf+0x1e4>
    645c:	b5 01       	movw	r22, r10
    645e:	0e 94 d2 33 	call	0x67a4	; 0x67a4 <ungetc>
    6462:	cc c0       	rjmp	.+408    	; 0x65fc <vfscanf+0x206>
    6464:	6a 32       	cpi	r22, 0x2A	; 42
    6466:	19 f0       	breq	.+6      	; 0x646e <vfscanf+0x78>
    6468:	16 2f       	mov	r17, r22
    646a:	00 e0       	ldi	r16, 0x00	; 0
    646c:	06 c0       	rjmp	.+12     	; 0x647a <vfscanf+0x84>
    646e:	f3 fc       	sbrc	r15, 3
    6470:	15 91       	lpm	r17, Z+
    6472:	f3 fe       	sbrs	r15, 3
    6474:	11 91       	ld	r17, Z+
    6476:	6f 01       	movw	r12, r30
    6478:	01 e0       	ldi	r16, 0x01	; 1
    647a:	99 24       	eor	r9, r9
    647c:	0f c0       	rjmp	.+30     	; 0x649c <vfscanf+0xa6>
    647e:	02 60       	ori	r16, 0x02	; 2
    6480:	69 2d       	mov	r22, r9
    6482:	70 e0       	ldi	r23, 0x00	; 0
    6484:	80 e0       	ldi	r24, 0x00	; 0
    6486:	90 e0       	ldi	r25, 0x00	; 0
    6488:	40 e2       	ldi	r20, 0x20	; 32
    648a:	0e 94 22 31 	call	0x6244	; 0x6244 <mulacc>
    648e:	96 2e       	mov	r9, r22
    6490:	f6 01       	movw	r30, r12
    6492:	f3 fc       	sbrc	r15, 3
    6494:	15 91       	lpm	r17, Z+
    6496:	f3 fe       	sbrs	r15, 3
    6498:	11 91       	ld	r17, Z+
    649a:	6f 01       	movw	r12, r30
    649c:	21 2f       	mov	r18, r17
    649e:	20 53       	subi	r18, 0x30	; 48
    64a0:	2a 30       	cpi	r18, 0x0A	; 10
    64a2:	68 f3       	brcs	.-38     	; 0x647e <vfscanf+0x88>
    64a4:	01 fd       	sbrc	r16, 1
    64a6:	03 c0       	rjmp	.+6      	; 0x64ae <vfscanf+0xb8>
    64a8:	99 24       	eor	r9, r9
    64aa:	9a 94       	dec	r9
    64ac:	03 c0       	rjmp	.+6      	; 0x64b4 <vfscanf+0xbe>
    64ae:	99 20       	and	r9, r9
    64b0:	09 f4       	brne	.+2      	; 0x64b4 <vfscanf+0xbe>
    64b2:	a4 c0       	rjmp	.+328    	; 0x65fc <vfscanf+0x206>
    64b4:	18 36       	cpi	r17, 0x68	; 104
    64b6:	21 f0       	breq	.+8      	; 0x64c0 <vfscanf+0xca>
    64b8:	1c 36       	cpi	r17, 0x6C	; 108
    64ba:	91 f4       	brne	.+36     	; 0x64e0 <vfscanf+0xea>
    64bc:	f6 01       	movw	r30, r12
    64be:	0a c0       	rjmp	.+20     	; 0x64d4 <vfscanf+0xde>
    64c0:	f6 01       	movw	r30, r12
    64c2:	f3 fc       	sbrc	r15, 3
    64c4:	65 91       	lpm	r22, Z+
    64c6:	f3 fe       	sbrs	r15, 3
    64c8:	61 91       	ld	r22, Z+
    64ca:	68 36       	cpi	r22, 0x68	; 104
    64cc:	11 f0       	breq	.+4      	; 0x64d2 <vfscanf+0xdc>
    64ce:	16 2f       	mov	r17, r22
    64d0:	06 c0       	rjmp	.+12     	; 0x64de <vfscanf+0xe8>
    64d2:	08 60       	ori	r16, 0x08	; 8
    64d4:	04 60       	ori	r16, 0x04	; 4
    64d6:	f3 fc       	sbrc	r15, 3
    64d8:	15 91       	lpm	r17, Z+
    64da:	f3 fe       	sbrs	r15, 3
    64dc:	11 91       	ld	r17, Z+
    64de:	6f 01       	movw	r12, r30
    64e0:	11 23       	and	r17, r17
    64e2:	09 f4       	brne	.+2      	; 0x64e6 <vfscanf+0xf0>
    64e4:	8b c0       	rjmp	.+278    	; 0x65fc <vfscanf+0x206>
    64e6:	83 ea       	ldi	r24, 0xA3	; 163
    64e8:	90 e0       	ldi	r25, 0x00	; 0
    64ea:	61 2f       	mov	r22, r17
    64ec:	70 e0       	ldi	r23, 0x00	; 0
    64ee:	0e 94 59 33 	call	0x66b2	; 0x66b2 <strchr_P>
    64f2:	89 2b       	or	r24, r25
    64f4:	09 f4       	brne	.+2      	; 0x64f8 <vfscanf+0x102>
    64f6:	82 c0       	rjmp	.+260    	; 0x65fc <vfscanf+0x206>
    64f8:	80 2f       	mov	r24, r16
    64fa:	00 ff       	sbrs	r16, 0
    64fc:	03 c0       	rjmp	.+6      	; 0x6504 <vfscanf+0x10e>
    64fe:	ee 24       	eor	r14, r14
    6500:	ff 24       	eor	r15, r15
    6502:	07 c0       	rjmp	.+14     	; 0x6512 <vfscanf+0x11c>
    6504:	f3 01       	movw	r30, r6
    6506:	e0 80       	ld	r14, Z
    6508:	f1 80       	ldd	r15, Z+1	; 0x01
    650a:	22 e0       	ldi	r18, 0x02	; 2
    650c:	30 e0       	ldi	r19, 0x00	; 0
    650e:	62 0e       	add	r6, r18
    6510:	73 1e       	adc	r7, r19
    6512:	1e 36       	cpi	r17, 0x6E	; 110
    6514:	51 f4       	brne	.+20     	; 0x652a <vfscanf+0x134>
    6516:	f5 01       	movw	r30, r10
    6518:	46 81       	ldd	r20, Z+6	; 0x06
    651a:	57 81       	ldd	r21, Z+7	; 0x07
    651c:	60 e0       	ldi	r22, 0x00	; 0
    651e:	70 e0       	ldi	r23, 0x00	; 0
    6520:	c7 01       	movw	r24, r14
    6522:	20 2f       	mov	r18, r16
    6524:	0e 94 16 31 	call	0x622c	; 0x622c <putval>
    6528:	58 c0       	rjmp	.+176    	; 0x65da <vfscanf+0x1e4>
    652a:	13 36       	cpi	r17, 0x63	; 99
    652c:	91 f4       	brne	.+36     	; 0x6552 <vfscanf+0x15c>
    652e:	81 fd       	sbrc	r24, 1
    6530:	02 c0       	rjmp	.+4      	; 0x6536 <vfscanf+0x140>
    6532:	99 24       	eor	r9, r9
    6534:	93 94       	inc	r9
    6536:	c5 01       	movw	r24, r10
    6538:	0e 94 64 33 	call	0x66c8	; 0x66c8 <fgetc>
    653c:	97 fd       	sbrc	r25, 7
    653e:	59 c0       	rjmp	.+178    	; 0x65f2 <vfscanf+0x1fc>
    6540:	e1 14       	cp	r14, r1
    6542:	f1 04       	cpc	r15, r1
    6544:	19 f0       	breq	.+6      	; 0x654c <vfscanf+0x156>
    6546:	f7 01       	movw	r30, r14
    6548:	81 93       	st	Z+, r24
    654a:	7f 01       	movw	r14, r30
    654c:	9a 94       	dec	r9
    654e:	99 f7       	brne	.-26     	; 0x6536 <vfscanf+0x140>
    6550:	42 c0       	rjmp	.+132    	; 0x65d6 <vfscanf+0x1e0>
    6552:	c5 01       	movw	r24, r10
    6554:	0e 94 50 31 	call	0x62a0	; 0x62a0 <skip_spaces>
    6558:	97 fd       	sbrc	r25, 7
    655a:	4b c0       	rjmp	.+150    	; 0x65f2 <vfscanf+0x1fc>
    655c:	1f 36       	cpi	r17, 0x6F	; 111
    655e:	59 f1       	breq	.+86     	; 0x65b6 <vfscanf+0x1c0>
    6560:	10 37       	cpi	r17, 0x70	; 112
    6562:	28 f4       	brcc	.+10     	; 0x656e <vfscanf+0x178>
    6564:	14 36       	cpi	r17, 0x64	; 100
    6566:	29 f1       	breq	.+74     	; 0x65b2 <vfscanf+0x1bc>
    6568:	19 36       	cpi	r17, 0x69	; 105
    656a:	39 f5       	brne	.+78     	; 0x65ba <vfscanf+0x1c4>
    656c:	27 c0       	rjmp	.+78     	; 0x65bc <vfscanf+0x1c6>
    656e:	13 37       	cpi	r17, 0x73	; 115
    6570:	19 f0       	breq	.+6      	; 0x6578 <vfscanf+0x182>
    6572:	15 37       	cpi	r17, 0x75	; 117
    6574:	11 f5       	brne	.+68     	; 0x65ba <vfscanf+0x1c4>
    6576:	1d c0       	rjmp	.+58     	; 0x65b2 <vfscanf+0x1bc>
    6578:	c5 01       	movw	r24, r10
    657a:	0e 94 64 33 	call	0x66c8	; 0x66c8 <fgetc>
    657e:	ec 01       	movw	r28, r24
    6580:	97 fd       	sbrc	r25, 7
    6582:	11 c0       	rjmp	.+34     	; 0x65a6 <vfscanf+0x1b0>
    6584:	0e 94 51 33 	call	0x66a2	; 0x66a2 <isspace>
    6588:	89 2b       	or	r24, r25
    658a:	29 f0       	breq	.+10     	; 0x6596 <vfscanf+0x1a0>
    658c:	ce 01       	movw	r24, r28
    658e:	b5 01       	movw	r22, r10
    6590:	0e 94 d2 33 	call	0x67a4	; 0x67a4 <ungetc>
    6594:	08 c0       	rjmp	.+16     	; 0x65a6 <vfscanf+0x1b0>
    6596:	e1 14       	cp	r14, r1
    6598:	f1 04       	cpc	r15, r1
    659a:	19 f0       	breq	.+6      	; 0x65a2 <vfscanf+0x1ac>
    659c:	f7 01       	movw	r30, r14
    659e:	c1 93       	st	Z+, r28
    65a0:	7f 01       	movw	r14, r30
    65a2:	9a 94       	dec	r9
    65a4:	49 f7       	brne	.-46     	; 0x6578 <vfscanf+0x182>
    65a6:	e1 14       	cp	r14, r1
    65a8:	f1 04       	cpc	r15, r1
    65aa:	a9 f0       	breq	.+42     	; 0x65d6 <vfscanf+0x1e0>
    65ac:	f7 01       	movw	r30, r14
    65ae:	10 82       	st	Z, r1
    65b0:	12 c0       	rjmp	.+36     	; 0x65d6 <vfscanf+0x1e0>
    65b2:	00 62       	ori	r16, 0x20	; 32
    65b4:	03 c0       	rjmp	.+6      	; 0x65bc <vfscanf+0x1c6>
    65b6:	00 61       	ori	r16, 0x10	; 16
    65b8:	01 c0       	rjmp	.+2      	; 0x65bc <vfscanf+0x1c6>
    65ba:	00 64       	ori	r16, 0x40	; 64
    65bc:	c5 01       	movw	r24, r10
    65be:	69 2d       	mov	r22, r9
    65c0:	a7 01       	movw	r20, r14
    65c2:	20 2f       	mov	r18, r16
    65c4:	0e 94 69 31 	call	0x62d2	; 0x62d2 <conv_int>
    65c8:	88 23       	and	r24, r24
    65ca:	29 f4       	brne	.+10     	; 0x65d6 <vfscanf+0x1e0>
    65cc:	f5 01       	movw	r30, r10
    65ce:	83 81       	ldd	r24, Z+3	; 0x03
    65d0:	80 73       	andi	r24, 0x30	; 48
    65d2:	79 f4       	brne	.+30     	; 0x65f2 <vfscanf+0x1fc>
    65d4:	13 c0       	rjmp	.+38     	; 0x65fc <vfscanf+0x206>
    65d6:	00 ff       	sbrs	r16, 0
    65d8:	83 94       	inc	r8
    65da:	f5 01       	movw	r30, r10
    65dc:	f3 80       	ldd	r15, Z+3	; 0x03
    65de:	f6 01       	movw	r30, r12
    65e0:	f3 fc       	sbrc	r15, 3
    65e2:	15 91       	lpm	r17, Z+
    65e4:	f3 fe       	sbrs	r15, 3
    65e6:	11 91       	ld	r17, Z+
    65e8:	6f 01       	movw	r12, r30
    65ea:	11 23       	and	r17, r17
    65ec:	09 f0       	breq	.+2      	; 0x65f0 <vfscanf+0x1fa>
    65ee:	19 cf       	rjmp	.-462    	; 0x6422 <vfscanf+0x2c>
    65f0:	05 c0       	rjmp	.+10     	; 0x65fc <vfscanf+0x206>
    65f2:	88 20       	and	r8, r8
    65f4:	19 f4       	brne	.+6      	; 0x65fc <vfscanf+0x206>
    65f6:	2f ef       	ldi	r18, 0xFF	; 255
    65f8:	3f ef       	ldi	r19, 0xFF	; 255
    65fa:	02 c0       	rjmp	.+4      	; 0x6600 <vfscanf+0x20a>
    65fc:	28 2d       	mov	r18, r8
    65fe:	30 e0       	ldi	r19, 0x00	; 0
    6600:	c9 01       	movw	r24, r18
    6602:	df 91       	pop	r29
    6604:	cf 91       	pop	r28
    6606:	1f 91       	pop	r17
    6608:	0f 91       	pop	r16
    660a:	ff 90       	pop	r15
    660c:	ef 90       	pop	r14
    660e:	df 90       	pop	r13
    6610:	cf 90       	pop	r12
    6612:	bf 90       	pop	r11
    6614:	af 90       	pop	r10
    6616:	9f 90       	pop	r9
    6618:	8f 90       	pop	r8
    661a:	7f 90       	pop	r7
    661c:	6f 90       	pop	r6
    661e:	08 95       	ret

00006620 <__mulsi3>:
    6620:	62 9f       	mul	r22, r18
    6622:	d0 01       	movw	r26, r0
    6624:	73 9f       	mul	r23, r19
    6626:	f0 01       	movw	r30, r0
    6628:	82 9f       	mul	r24, r18
    662a:	e0 0d       	add	r30, r0
    662c:	f1 1d       	adc	r31, r1
    662e:	64 9f       	mul	r22, r20
    6630:	e0 0d       	add	r30, r0
    6632:	f1 1d       	adc	r31, r1
    6634:	92 9f       	mul	r25, r18
    6636:	f0 0d       	add	r31, r0
    6638:	83 9f       	mul	r24, r19
    663a:	f0 0d       	add	r31, r0
    663c:	74 9f       	mul	r23, r20
    663e:	f0 0d       	add	r31, r0
    6640:	65 9f       	mul	r22, r21
    6642:	f0 0d       	add	r31, r0
    6644:	99 27       	eor	r25, r25
    6646:	72 9f       	mul	r23, r18
    6648:	b0 0d       	add	r27, r0
    664a:	e1 1d       	adc	r30, r1
    664c:	f9 1f       	adc	r31, r25
    664e:	63 9f       	mul	r22, r19
    6650:	b0 0d       	add	r27, r0
    6652:	e1 1d       	adc	r30, r1
    6654:	f9 1f       	adc	r31, r25
    6656:	bd 01       	movw	r22, r26
    6658:	cf 01       	movw	r24, r30
    665a:	11 24       	eor	r1, r1
    665c:	08 95       	ret

0000665e <__udivmodsi4>:
    665e:	a1 e2       	ldi	r26, 0x21	; 33
    6660:	1a 2e       	mov	r1, r26
    6662:	aa 1b       	sub	r26, r26
    6664:	bb 1b       	sub	r27, r27
    6666:	fd 01       	movw	r30, r26
    6668:	0d c0       	rjmp	.+26     	; 0x6684 <__udivmodsi4_ep>

0000666a <__udivmodsi4_loop>:
    666a:	aa 1f       	adc	r26, r26
    666c:	bb 1f       	adc	r27, r27
    666e:	ee 1f       	adc	r30, r30
    6670:	ff 1f       	adc	r31, r31
    6672:	a2 17       	cp	r26, r18
    6674:	b3 07       	cpc	r27, r19
    6676:	e4 07       	cpc	r30, r20
    6678:	f5 07       	cpc	r31, r21
    667a:	20 f0       	brcs	.+8      	; 0x6684 <__udivmodsi4_ep>
    667c:	a2 1b       	sub	r26, r18
    667e:	b3 0b       	sbc	r27, r19
    6680:	e4 0b       	sbc	r30, r20
    6682:	f5 0b       	sbc	r31, r21

00006684 <__udivmodsi4_ep>:
    6684:	66 1f       	adc	r22, r22
    6686:	77 1f       	adc	r23, r23
    6688:	88 1f       	adc	r24, r24
    668a:	99 1f       	adc	r25, r25
    668c:	1a 94       	dec	r1
    668e:	69 f7       	brne	.-38     	; 0x666a <__udivmodsi4_loop>
    6690:	60 95       	com	r22
    6692:	70 95       	com	r23
    6694:	80 95       	com	r24
    6696:	90 95       	com	r25
    6698:	9b 01       	movw	r18, r22
    669a:	ac 01       	movw	r20, r24
    669c:	bd 01       	movw	r22, r26
    669e:	cf 01       	movw	r24, r30
    66a0:	08 95       	ret

000066a2 <isspace>:
    66a2:	91 11       	cpse	r25, r1
    66a4:	f7 c0       	rjmp	.+494    	; 0x6894 <__ctype_isfalse>
    66a6:	80 32       	cpi	r24, 0x20	; 32
    66a8:	19 f0       	breq	.+6      	; 0x66b0 <isspace+0xe>
    66aa:	89 50       	subi	r24, 0x09	; 9
    66ac:	85 50       	subi	r24, 0x05	; 5
    66ae:	d0 f7       	brcc	.-12     	; 0x66a4 <isspace+0x2>
    66b0:	08 95       	ret

000066b2 <strchr_P>:
    66b2:	fc 01       	movw	r30, r24
    66b4:	05 90       	lpm	r0, Z+
    66b6:	06 16       	cp	r0, r22
    66b8:	21 f0       	breq	.+8      	; 0x66c2 <strchr_P+0x10>
    66ba:	00 20       	and	r0, r0
    66bc:	d9 f7       	brne	.-10     	; 0x66b4 <strchr_P+0x2>
    66be:	c0 01       	movw	r24, r0
    66c0:	08 95       	ret
    66c2:	31 97       	sbiw	r30, 0x01	; 1
    66c4:	cf 01       	movw	r24, r30
    66c6:	08 95       	ret

000066c8 <fgetc>:
    66c8:	cf 93       	push	r28
    66ca:	df 93       	push	r29
    66cc:	ec 01       	movw	r28, r24
    66ce:	4b 81       	ldd	r20, Y+3	; 0x03
    66d0:	40 ff       	sbrs	r20, 0
    66d2:	1a c0       	rjmp	.+52     	; 0x6708 <fgetc+0x40>
    66d4:	46 ff       	sbrs	r20, 6
    66d6:	0a c0       	rjmp	.+20     	; 0x66ec <fgetc+0x24>
    66d8:	4f 7b       	andi	r20, 0xBF	; 191
    66da:	4b 83       	std	Y+3, r20	; 0x03
    66dc:	8e 81       	ldd	r24, Y+6	; 0x06
    66de:	9f 81       	ldd	r25, Y+7	; 0x07
    66e0:	01 96       	adiw	r24, 0x01	; 1
    66e2:	9f 83       	std	Y+7, r25	; 0x07
    66e4:	8e 83       	std	Y+6, r24	; 0x06
    66e6:	8a 81       	ldd	r24, Y+2	; 0x02
    66e8:	28 2f       	mov	r18, r24
    66ea:	2b c0       	rjmp	.+86     	; 0x6742 <fgetc+0x7a>
    66ec:	42 ff       	sbrs	r20, 2
    66ee:	13 c0       	rjmp	.+38     	; 0x6716 <fgetc+0x4e>
    66f0:	e8 81       	ld	r30, Y
    66f2:	f9 81       	ldd	r31, Y+1	; 0x01
    66f4:	80 81       	ld	r24, Z
    66f6:	28 2f       	mov	r18, r24
    66f8:	33 27       	eor	r19, r19
    66fa:	27 fd       	sbrc	r18, 7
    66fc:	30 95       	com	r19
    66fe:	21 15       	cp	r18, r1
    6700:	31 05       	cpc	r19, r1
    6702:	29 f4       	brne	.+10     	; 0x670e <fgetc+0x46>
    6704:	40 62       	ori	r20, 0x20	; 32
    6706:	4b 83       	std	Y+3, r20	; 0x03
    6708:	2f ef       	ldi	r18, 0xFF	; 255
    670a:	3f ef       	ldi	r19, 0xFF	; 255
    670c:	1b c0       	rjmp	.+54     	; 0x6744 <fgetc+0x7c>
    670e:	31 96       	adiw	r30, 0x01	; 1
    6710:	f9 83       	std	Y+1, r31	; 0x01
    6712:	e8 83       	st	Y, r30
    6714:	11 c0       	rjmp	.+34     	; 0x6738 <fgetc+0x70>
    6716:	ea 85       	ldd	r30, Y+10	; 0x0a
    6718:	fb 85       	ldd	r31, Y+11	; 0x0b
    671a:	ce 01       	movw	r24, r28
    671c:	09 95       	icall
    671e:	9c 01       	movw	r18, r24
    6720:	97 ff       	sbrs	r25, 7
    6722:	0a c0       	rjmp	.+20     	; 0x6738 <fgetc+0x70>
    6724:	9b 81       	ldd	r25, Y+3	; 0x03
    6726:	2f 5f       	subi	r18, 0xFF	; 255
    6728:	3f 4f       	sbci	r19, 0xFF	; 255
    672a:	11 f0       	breq	.+4      	; 0x6730 <fgetc+0x68>
    672c:	80 e2       	ldi	r24, 0x20	; 32
    672e:	01 c0       	rjmp	.+2      	; 0x6732 <fgetc+0x6a>
    6730:	80 e1       	ldi	r24, 0x10	; 16
    6732:	89 2b       	or	r24, r25
    6734:	8b 83       	std	Y+3, r24	; 0x03
    6736:	e8 cf       	rjmp	.-48     	; 0x6708 <fgetc+0x40>
    6738:	8e 81       	ldd	r24, Y+6	; 0x06
    673a:	9f 81       	ldd	r25, Y+7	; 0x07
    673c:	01 96       	adiw	r24, 0x01	; 1
    673e:	9f 83       	std	Y+7, r25	; 0x07
    6740:	8e 83       	std	Y+6, r24	; 0x06
    6742:	30 e0       	ldi	r19, 0x00	; 0
    6744:	c9 01       	movw	r24, r18
    6746:	df 91       	pop	r29
    6748:	cf 91       	pop	r28
    674a:	08 95       	ret

0000674c <fputc>:
    674c:	0f 93       	push	r16
    674e:	1f 93       	push	r17
    6750:	cf 93       	push	r28
    6752:	df 93       	push	r29
    6754:	8c 01       	movw	r16, r24
    6756:	eb 01       	movw	r28, r22
    6758:	8b 81       	ldd	r24, Y+3	; 0x03
    675a:	81 ff       	sbrs	r24, 1
    675c:	1b c0       	rjmp	.+54     	; 0x6794 <fputc+0x48>
    675e:	82 ff       	sbrs	r24, 2
    6760:	0d c0       	rjmp	.+26     	; 0x677c <fputc+0x30>
    6762:	2e 81       	ldd	r18, Y+6	; 0x06
    6764:	3f 81       	ldd	r19, Y+7	; 0x07
    6766:	8c 81       	ldd	r24, Y+4	; 0x04
    6768:	9d 81       	ldd	r25, Y+5	; 0x05
    676a:	28 17       	cp	r18, r24
    676c:	39 07       	cpc	r19, r25
    676e:	64 f4       	brge	.+24     	; 0x6788 <fputc+0x3c>
    6770:	e8 81       	ld	r30, Y
    6772:	f9 81       	ldd	r31, Y+1	; 0x01
    6774:	01 93       	st	Z+, r16
    6776:	f9 83       	std	Y+1, r31	; 0x01
    6778:	e8 83       	st	Y, r30
    677a:	06 c0       	rjmp	.+12     	; 0x6788 <fputc+0x3c>
    677c:	e8 85       	ldd	r30, Y+8	; 0x08
    677e:	f9 85       	ldd	r31, Y+9	; 0x09
    6780:	80 2f       	mov	r24, r16
    6782:	09 95       	icall
    6784:	89 2b       	or	r24, r25
    6786:	31 f4       	brne	.+12     	; 0x6794 <fputc+0x48>
    6788:	8e 81       	ldd	r24, Y+6	; 0x06
    678a:	9f 81       	ldd	r25, Y+7	; 0x07
    678c:	01 96       	adiw	r24, 0x01	; 1
    678e:	9f 83       	std	Y+7, r25	; 0x07
    6790:	8e 83       	std	Y+6, r24	; 0x06
    6792:	02 c0       	rjmp	.+4      	; 0x6798 <fputc+0x4c>
    6794:	0f ef       	ldi	r16, 0xFF	; 255
    6796:	1f ef       	ldi	r17, 0xFF	; 255
    6798:	c8 01       	movw	r24, r16
    679a:	df 91       	pop	r29
    679c:	cf 91       	pop	r28
    679e:	1f 91       	pop	r17
    67a0:	0f 91       	pop	r16
    67a2:	08 95       	ret

000067a4 <ungetc>:
    67a4:	9c 01       	movw	r18, r24
    67a6:	fb 01       	movw	r30, r22
    67a8:	83 81       	ldd	r24, Z+3	; 0x03
    67aa:	80 ff       	sbrs	r24, 0
    67ac:	11 c0       	rjmp	.+34     	; 0x67d0 <ungetc+0x2c>
    67ae:	86 fd       	sbrc	r24, 6
    67b0:	0f c0       	rjmp	.+30     	; 0x67d0 <ungetc+0x2c>
    67b2:	9f ef       	ldi	r25, 0xFF	; 255
    67b4:	2f 3f       	cpi	r18, 0xFF	; 255
    67b6:	39 07       	cpc	r19, r25
    67b8:	59 f0       	breq	.+22     	; 0x67d0 <ungetc+0x2c>
    67ba:	22 83       	std	Z+2, r18	; 0x02
    67bc:	80 64       	ori	r24, 0x40	; 64
    67be:	8f 7d       	andi	r24, 0xDF	; 223
    67c0:	83 83       	std	Z+3, r24	; 0x03
    67c2:	86 81       	ldd	r24, Z+6	; 0x06
    67c4:	97 81       	ldd	r25, Z+7	; 0x07
    67c6:	01 97       	sbiw	r24, 0x01	; 1
    67c8:	97 83       	std	Z+7, r25	; 0x07
    67ca:	86 83       	std	Z+6, r24	; 0x06
    67cc:	30 e0       	ldi	r19, 0x00	; 0
    67ce:	02 c0       	rjmp	.+4      	; 0x67d4 <ungetc+0x30>
    67d0:	2f ef       	ldi	r18, 0xFF	; 255
    67d2:	3f ef       	ldi	r19, 0xFF	; 255
    67d4:	c9 01       	movw	r24, r18
    67d6:	08 95       	ret

000067d8 <__ultoa_invert>:
    67d8:	fa 01       	movw	r30, r20
    67da:	aa 27       	eor	r26, r26
    67dc:	28 30       	cpi	r18, 0x08	; 8
    67de:	51 f1       	breq	.+84     	; 0x6834 <__ultoa_invert+0x5c>
    67e0:	20 31       	cpi	r18, 0x10	; 16
    67e2:	81 f1       	breq	.+96     	; 0x6844 <__ultoa_invert+0x6c>
    67e4:	e8 94       	clt
    67e6:	6f 93       	push	r22
    67e8:	6e 7f       	andi	r22, 0xFE	; 254
    67ea:	6e 5f       	subi	r22, 0xFE	; 254
    67ec:	7f 4f       	sbci	r23, 0xFF	; 255
    67ee:	8f 4f       	sbci	r24, 0xFF	; 255
    67f0:	9f 4f       	sbci	r25, 0xFF	; 255
    67f2:	af 4f       	sbci	r26, 0xFF	; 255
    67f4:	b1 e0       	ldi	r27, 0x01	; 1
    67f6:	3e d0       	rcall	.+124    	; 0x6874 <__ultoa_invert+0x9c>
    67f8:	b4 e0       	ldi	r27, 0x04	; 4
    67fa:	3c d0       	rcall	.+120    	; 0x6874 <__ultoa_invert+0x9c>
    67fc:	67 0f       	add	r22, r23
    67fe:	78 1f       	adc	r23, r24
    6800:	89 1f       	adc	r24, r25
    6802:	9a 1f       	adc	r25, r26
    6804:	a1 1d       	adc	r26, r1
    6806:	68 0f       	add	r22, r24
    6808:	79 1f       	adc	r23, r25
    680a:	8a 1f       	adc	r24, r26
    680c:	91 1d       	adc	r25, r1
    680e:	a1 1d       	adc	r26, r1
    6810:	6a 0f       	add	r22, r26
    6812:	71 1d       	adc	r23, r1
    6814:	81 1d       	adc	r24, r1
    6816:	91 1d       	adc	r25, r1
    6818:	a1 1d       	adc	r26, r1
    681a:	20 d0       	rcall	.+64     	; 0x685c <__ultoa_invert+0x84>
    681c:	09 f4       	brne	.+2      	; 0x6820 <__ultoa_invert+0x48>
    681e:	68 94       	set
    6820:	3f 91       	pop	r19
    6822:	2a e0       	ldi	r18, 0x0A	; 10
    6824:	26 9f       	mul	r18, r22
    6826:	11 24       	eor	r1, r1
    6828:	30 19       	sub	r19, r0
    682a:	30 5d       	subi	r19, 0xD0	; 208
    682c:	31 93       	st	Z+, r19
    682e:	de f6       	brtc	.-74     	; 0x67e6 <__ultoa_invert+0xe>
    6830:	cf 01       	movw	r24, r30
    6832:	08 95       	ret
    6834:	46 2f       	mov	r20, r22
    6836:	47 70       	andi	r20, 0x07	; 7
    6838:	40 5d       	subi	r20, 0xD0	; 208
    683a:	41 93       	st	Z+, r20
    683c:	b3 e0       	ldi	r27, 0x03	; 3
    683e:	0f d0       	rcall	.+30     	; 0x685e <__ultoa_invert+0x86>
    6840:	c9 f7       	brne	.-14     	; 0x6834 <__ultoa_invert+0x5c>
    6842:	f6 cf       	rjmp	.-20     	; 0x6830 <__ultoa_invert+0x58>
    6844:	46 2f       	mov	r20, r22
    6846:	4f 70       	andi	r20, 0x0F	; 15
    6848:	40 5d       	subi	r20, 0xD0	; 208
    684a:	4a 33       	cpi	r20, 0x3A	; 58
    684c:	18 f0       	brcs	.+6      	; 0x6854 <__ultoa_invert+0x7c>
    684e:	49 5d       	subi	r20, 0xD9	; 217
    6850:	31 fd       	sbrc	r19, 1
    6852:	40 52       	subi	r20, 0x20	; 32
    6854:	41 93       	st	Z+, r20
    6856:	02 d0       	rcall	.+4      	; 0x685c <__ultoa_invert+0x84>
    6858:	a9 f7       	brne	.-22     	; 0x6844 <__ultoa_invert+0x6c>
    685a:	ea cf       	rjmp	.-44     	; 0x6830 <__ultoa_invert+0x58>
    685c:	b4 e0       	ldi	r27, 0x04	; 4
    685e:	a6 95       	lsr	r26
    6860:	97 95       	ror	r25
    6862:	87 95       	ror	r24
    6864:	77 95       	ror	r23
    6866:	67 95       	ror	r22
    6868:	ba 95       	dec	r27
    686a:	c9 f7       	brne	.-14     	; 0x685e <__ultoa_invert+0x86>
    686c:	00 97       	sbiw	r24, 0x00	; 0
    686e:	61 05       	cpc	r22, r1
    6870:	71 05       	cpc	r23, r1
    6872:	08 95       	ret
    6874:	9b 01       	movw	r18, r22
    6876:	ac 01       	movw	r20, r24
    6878:	0a 2e       	mov	r0, r26
    687a:	06 94       	lsr	r0
    687c:	57 95       	ror	r21
    687e:	47 95       	ror	r20
    6880:	37 95       	ror	r19
    6882:	27 95       	ror	r18
    6884:	ba 95       	dec	r27
    6886:	c9 f7       	brne	.-14     	; 0x687a <__ultoa_invert+0xa2>
    6888:	62 0f       	add	r22, r18
    688a:	73 1f       	adc	r23, r19
    688c:	84 1f       	adc	r24, r20
    688e:	95 1f       	adc	r25, r21
    6890:	a0 1d       	adc	r26, r0
    6892:	08 95       	ret

00006894 <__ctype_isfalse>:
    6894:	99 27       	eor	r25, r25
    6896:	88 27       	eor	r24, r24

00006898 <__ctype_istrue>:
    6898:	08 95       	ret

0000689a <_exit>:
    689a:	f8 94       	cli

0000689c <__stop_program>:
    689c:	ff cf       	rjmp	.-2      	; 0x689c <__stop_program>
