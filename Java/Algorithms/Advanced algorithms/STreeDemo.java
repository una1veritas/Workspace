import java.awt.*;import java.applet.Applet;class PAIR {  int s;  int k;};class END_R {  boolean end_point;  int     r;};class SUBST {  int f;  int t;  public boolean equal(SUBST x) {    return (x.f == this.f && x.t == this.t);  }};class EDGE {  SUBST label;  int   state;  int   next;  EDGE() {    label = new SUBST();    next = -1;  } };class STATE {  int head;  int failure;  int X;  int Y;  int failure_X;  int failure_Y;   int subtreewidth;  STATE() {    head = -1;  }};class STree extends Panel implements Runnable {  STreeDemo graph;  public char P[];  public EDGE   Edge[];  public STATE  State[];  public int NumberofStates;  public int InitialState;  public int AuxiliaryState;  public int MaxState;  public int MaxEdge;  public int Index;  public int fail = 0;  public int Infty = 100000;  public boolean reference    = false;  public boolean suffix_links = false;  Thread relaxer;  STree(STreeDemo graph) {    this.graph = graph;  }  int NewState() {    if (NumberofStates >= MaxState) return 0;    State[++NumberofStates] = new STATE();    return NumberofStates;  }  int NewEdge() {    if (Index >= MaxEdge) return 0;    Edge[Index] = new EDGE();    return Index++;  }  int find_transition(int s, char c) {    if (s == AuxiliaryState) return 0;    for (int idx = State[s].head; idx >= 0; idx = Edge[idx].next) {      int f = Edge[idx].label.f;       if (f > 0 && P[f-1]==c) return idx;    }    return -1;      }  int make_new_transition(int s, SUBST c, int target) {    int tmp, nw;    nw = NewEdge();    tmp = State[s].head;    Edge[nw].label = c;    Edge[nw].state = target;    Edge[nw].next  = tmp;    State[s].head  = nw;    return 0;  }  END_R test_and_split(int s, int k, int p, char t)  {    END_R ret = new END_R();    int idx;    if (k <= p) {      idx = find_transition(s, P[k-1]);      int kk = Edge[idx].label.f ;      int pp = Edge[idx].label.t ;      int ss = Edge[idx].state ;      if (t == P[kk+p-k]) {        ret.end_point = true;        ret.r         = s;      } else {	int r = NewState();        Edge[idx].label.t = kk + p - k;        Edge[idx].state = r;        SUBST str = new SUBST();        str.f = kk + p - k + 1;        str.t = pp;        make_new_transition(r, str, ss);        ret.end_point = false;        ret.r         = r;      }    } else {      ret.end_point = (find_transition(s, t) >= 0);      ret.r = s;    }    return ret;  }  PAIR update(PAIR pair, int i) {    int oldr;    END_R end_r;    SUBST sub = new SUBST();    oldr = InitialState;    end_r = test_and_split(pair.s, pair.k, i-1, P[i-1]);    while (end_r.end_point == false) {      sub.f = i;      sub.t = Infty;      make_new_transition(end_r.r, sub, NewState());      if (oldr != InitialState) State[oldr].failure = end_r.r;      oldr = end_r.r;      pair = canonize(State[pair.s].failure, pair.k, i-1);      end_r= test_and_split(pair.s, pair.k, i-1, P[i-1]);    }    if (oldr != InitialState) {      State[oldr].failure = pair.s;    }    return pair;       }  PAIR canonize(int s, int k, int p) {    PAIR pair = new PAIR();    pair.s = s;    pair.k = k;    if (p >= pair.k) {      int idx = find_transition(pair.s, P[pair.k-1]);      int kk = Edge[idx].label.f;      int pp = Edge[idx].label.t;      int ss = Edge[idx].state;      while (pp - kk <= p - pair.k) {        pair.k += pp - kk + 1;        pair.s = ss;        if (pair.k <= p) {          idx = find_transition(pair.s, P[pair.k-1]);          kk = Edge[idx].label.f;          pp = Edge[idx].label.t;          ss = Edge[idx].state;        }      }    }    return pair;       }  int make_suffix_tree(String pat) {    int  m = pat.length();    P = new char[m];    char c;    SUBST sub = new SUBST();     pat.getChars(0, m, P, 0);     MaxState = 2*m+1;    MaxEdge  = 2*m+256;    State = new STATE[MaxState+1];    Edge  = new EDGE [MaxEdge];    Index = 0;    NumberofStates = -1;    AuxiliaryState = NewState();    InitialState = NewState();    for (c = 0; c < 256; c++) {      sub.f = -(c+1);      sub.t = -(c+1);      make_new_transition(AuxiliaryState, sub, InitialState);    }    State[InitialState].failure = AuxiliaryState;    PAIR pair = new PAIR();    pair.s = InitialState;    pair.k = 1;    for (int i = 0; i < m; ) {      i++;      pair = update(pair, i);      pair = canonize(pair.s, pair.k, i);    }    for (int idx = 0; idx < Index; idx++) {      if (Edge[idx].label.t == Infty) Edge[idx].label.t = m;    }    compute_positions(40, 40, 70);    return 0;  }  int subtreewidth(int s) {    int idx, total;    if ((idx = State[s].head) >= 0) {        total = 0;      do {        total += subtreewidth(Edge[idx].state);        idx = Edge[idx].next;      } while (idx >= 0);      State[s].subtreewidth = total;      return total;    } else {      State[s].subtreewidth = 1;      return 1;    }  }  void compute_positions(int off_x, int off_y, int step) {    int queue[] = new int[MaxState];    int Q_L, Q_R;    int state, s;    int idx;    int total;    subtreewidth(InitialState);    Q_L = Q_R = 0;    State[InitialState].X = off_x;    State[InitialState].Y = off_y;    queue[Q_R++] = InitialState;    while (Q_L < Q_R) {      state = queue[Q_L++];      total = 0;      for (idx = State[state].head; idx >= 0; idx = Edge[idx].next) {        s = Edge[idx].state;        State[s].X = State[state].X + step;        State[s].Y = State[state].Y + step*total;        queue[Q_R++] = s;        total += State[s].subtreewidth;      }    }    for (state = InitialState; state <= NumberofStates; state++) {      s = State[state].failure;      State[state].failure_X = (State[state].X +State[s].X)/2;      State[state].failure_Y = (State[state].Y +State[s].Y)/2 + 20;    }  }   public void run() {    while (true) {      repaint();      try {        Thread.sleep(10);      } catch (InterruptedException e) {        break;      }    }  }   private void DrawNode(Graphics g, int s) {    int r = 10;    g.setColor(Color.white);    g.fillOval(State[s].X-r, State[s].Y-r, 2*r, 2*r);    g.setColor(Color.black);    g.drawOval(State[s].X-r, State[s].Y-r, 2*r, 2*r);    g.drawString(""+s, State[s].X-5, State[s].Y+5);  }  private int MidiumValue(int a, int b, int m, int n) {    return (n*a + m*b)/(m+n);      }  private void DrawGotoEdge(Graphics g, int s, int t, SUBST label) {    int dx, dy;    int r = 10;    int w, h;    double ll;    w = State[t].X - State[s].X;    h = State[t].Y - State[s].Y;    ll = Math.sqrt(w*w+h*h);    dx = (int)Math.round( (r*w)/ll );    dy = (int)Math.round( (r*h)/ll );    if (reference) {      g.drawString("["+label.f+","+label.t+"]",         MidiumValue(State[s].X, State[t].X, 3, 4),        MidiumValue(State[s].Y, State[t].Y, 3, 4));    } else {      g.drawString(String.valueOf(P, label.f-1, label.t-label.f+1),        MidiumValue(State[s].X, State[t].X, 3, 4),        MidiumValue(State[s].Y, State[t].Y, 3, 4));    }    g.drawLine(State[s].X+dx, State[s].Y+dy, State[t].X-dx, State[t].Y-dy);   }  private boolean is_in_Circle(double x, double y, double a, double b, int r)  {    double w = x - a;    double h = y - b;    return (w*w + h*h <= (double)r*r); 	  }  private void DrawFailureEdge(Graphics g, int from, int to) {    int r = 10;    int x0 = State[from].X;    int y0 = State[from].Y;    int x1 = State[to  ].X;    int y1 = State[to  ].Y;    double w, h, ll;    int i,j;    spline s = new spline();    s.X[0] = (double)x0;     s.Y[0] = (double)y0;    s.X[1] = (double)State[from].failure_X;    s.Y[1] = (double)State[from].failure_Y;    s.X[2] = (double)x1;     s.Y[2] = (double)y1;    s.N = 3;    double xx[] = new double[11];    double yy[] = new double[11];    for (i=0; i <= 10; i++) {      s.spline(0.1*i);      xx[i] = Math.round(s.R[0]);      yy[i] = Math.round(s.R[1]);     }    for (i = 0; i < 10; i++) {      if (is_in_Circle(xx[i+1], yy[i+1], x0, y0, r) == false) break;    }    for (j = 10; j > 0; j--) {      if (is_in_Circle(xx[j-1], yy[j-1], x1, y1, r) == false) break;    }/*    w = xx[i+1]-xx[i];    h = yy[i+1]-yy[i];    ll= Math.sqrt(w*w+h*h);    xx[i] += (d*w)/ll;    yy[i] += (d*h)/ll;    w = xx[j] - xx[j-1];    h = yy[j] - yy[j-1];    ll= Math.sqrt(w*w+h*h);    xx[j] -= (d*w)/ll;    yy[j] -= (d*w)/ll;  */    i = 0; j = 10;    for (  ; i < j; i++) {      g.drawLine((int)xx[i], (int)yy[i], (int)xx[i+1], (int)yy[i+1]);    }    if (graph.Edit_Mode) {      g.fillRect(State[from].failure_X, State[from].failure_Y, 5, 5);    }  }  private boolean is_a_leaf(int state) {    return (State[state].head == -1);  }  Image offscreen;  Dimension offscreensize;  Graphics offgraphics;  public synchronized void update(Graphics g) {    Dimension d = size();    if ((offscreen == null) || (d.width != offscreensize.width) || (d.height != offscreensize.height)) {      offscreen = createImage(d.width, d.height);      offscreensize = d;      offgraphics = offscreen.getGraphics();      offgraphics.setFont(getFont());    }    offgraphics.setColor(getBackground());    offgraphics.fillRect(0, 0, d.width, d.height);    offgraphics.setColor(Color.black);    for (int t = InitialState; t <= NumberofStates; t++) {      DrawNode(offgraphics, t);      for (int idx = State[t].head; idx >= 0; idx = Edge[idx].next) {        int s = Edge[idx].state;        DrawGotoEdge(offgraphics, t, s, Edge[idx].label);      }      if (suffix_links && t > InitialState && !is_a_leaf(t)) {        offgraphics.setColor(Color.red);        DrawFailureEdge(offgraphics, t, State[t].failure);        offgraphics.setColor(Color.black);      }    }    for (int t = InitialState; t <= NumberofStates; t++) {      DrawNode(offgraphics, t);    }    g.drawImage(offscreen, 0, 0, null);  }   int PickUp = -1;  public synchronized boolean mouseDown(Event evt, int x, int y) {    if (graph.Edit_Mode == false) return true;    for (int s = InitialState; s <= NumberofStates; s++) {      int x0 = State[s].failure_X;      int y0 = State[s].failure_Y;      if (Math.abs(x0-x) <= 5 && Math.abs(y0-y) <= 5) {        PickUp = s;        State[PickUp].failure_X = x;        State[PickUp].failure_Y = y;        repaint();        return true;      }    }    PickUp = -1;    return true;  }  public synchronized boolean mouseDrag(Event evt, int x, int y) {    if (graph.Edit_Mode == false) return true;    if (PickUp != -1) {      State[PickUp].failure_X = x;      State[PickUp].failure_Y = y;    }    repaint();    return true;  }  public synchronized boolean mouseUp(Event evt, int x, int y) {    if (graph.Edit_Mode == false) return true;    if (PickUp != -1) {      State[PickUp].failure_X = x;      State[PickUp].failure_Y = y;    }    repaint();    return true;  }  public void start() {   relaxer = new Thread(this);   relaxer.start();  }   public void stop() {   relaxer.stop();  }}public class STreeDemo extends Applet {  TextField p_input;  STree stree;  boolean Edit_Mode = false;  boolean Running   = false;  public void init() {    setLayout(new BorderLayout());    stree = new STree(this);    add("Center", stree);    Panel p = new Panel();    add("North", p);    p.setLayout(new GridLayout(2,2));    p.add(p_input = new TextField("cacao"));    p.add(new Button("Build"));    p.add(new Checkbox("pointer pairs"));    p.add(new Checkbox("suffix links"));    stree.make_suffix_tree(p_input.getText());  }  public void start() {    stree.start();  }  public void stop() {    stree.stop();  }  public boolean action(Event evt, Object arg) {    if (evt.target instanceof Button) {      Edit_Mode = (arg.equals("Edit"));      if (arg.equals("Build")) {        stree.make_suffix_tree(p_input.getText());      }    } else if (evt.target instanceof Checkbox) {      Checkbox c = (Checkbox)(evt.target);      if (c.getLabel().equals("pointer pairs")) {        stree.reference = c.getState();      } else if (c.getLabel().equals("suffix links")) {        stree.suffix_links = c.getState();      }    }    return true;  }}