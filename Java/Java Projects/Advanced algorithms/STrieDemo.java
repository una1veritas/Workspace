import java.awt.*;import java.applet.Applet;class STATE {  int head;  int failure;  boolean explicit;  int X;  int Y;  int failure_X;  int failure_Y;   int subtreewidth;  STATE() {    head = -1;  }};class EDGE {  char	label;  int 	state;  int	next;  EDGE() {    next = -1;  }}; class STrie extends Panel implements Runnable {  STrieDemo graph;  public EDGE 	Edge[];  public STATE	State[];  public int 	NumberofStates;  public int 	InitialState;  public int 	AuxiliaryState;  public int 	MaxState;  public int 	MaxEdge;  public int 	Index;  public int 	fail = 0;  public boolean show_explicit = false;  public boolean suffix_links = false;  Thread relaxer;  STrie(STrieDemo graph) {    this.graph = graph;  }  int NewState() {    if (NumberofStates >= MaxState) return 0;    State[++NumberofStates] = new STATE();    return NumberofStates;  }  int NewEdge() {    if (Index >= MaxEdge) return 0;    Edge[Index] = new EDGE();    return Index++;  }    void initializeSTrie(int m) {    MaxState = m*m+1;    MaxEdge  = m*m+256;    State    = new STATE[MaxState+1];    Edge     = new EDGE [MaxEdge];    Index = 0;    NumberofStates = -1;    AuxiliaryState = NewState();    InitialState = NewState();  }  int GoTo(int state, char c) {    for (int idx = State[state].head; idx >= 0; idx = Edge[idx].next) {      if (Edge[idx].label == c) return Edge[idx].state;    }    return fail;      }  int make_a_transition(int state, char c, int target) {    int idx = NewEdge();    Edge[idx].label = c;    Edge[idx].state = target;    Edge[idx].next  = State[state].head;    State[state].head = idx;    return target;  }  int update_suffix_trie(int top, char c) {    int prev;    int newtop;    int s, nw;    prev = newtop = make_a_transition(top, c, NewState());    for (s = State[top].failure; (nw = GoTo(s, c)) == fail; s = State[s].failure) {      State[prev].failure = (prev = make_a_transition(s, c, NewState()));    }    State[prev].failure = nw;    return newtop;  }   int make_suffix_trie(String pat) {    int  m = pat.length();    char p[] = new char[m];    int top;    char c;    pat.getChars(0, m, p, 0);     initializeSTrie(m); 	    /* Initialization */	    State[InitialState].failure = AuxiliaryState;    for (c = 0; c < 256; c++) {      make_a_transition(AuxiliaryState, c, InitialState);    }    top = InitialState;    for (int i = 0; i < m; i++) {      top = update_suffix_trie(top, p[i]);    }    State[InitialState].explicit = true;    for (int s = InitialState+1; s <= NumberofStates; s++) {      int idx;      if ((idx = State[s].head) < 0 || Edge[idx].next >= 0) {        State[s].explicit = true;      } else {        State[s].explicit = false;      }    }    compute_positions(40, 40, 50);    return 0;  }  int subtreewidth(int state) {    int idx, total;    if ((idx = State[state].head) >= 0) {        total = 0;      do {        total += subtreewidth(Edge[idx].state);        idx = Edge[idx].next;      } while (idx >= 0);      State[state].subtreewidth = total;      return total;    } else {      State[state].subtreewidth = 1;      return 1;    }  }  void compute_positions(int off_x, int off_y, int step) {    int queue[] = new int[MaxState];    int Q_L, Q_R;    int state, s;    int idx;    int total;    subtreewidth(InitialState);    Q_L = Q_R = 0;    State[InitialState].X = off_x;    State[InitialState].Y = off_y;    queue[Q_R++] = InitialState;    while (Q_L < Q_R) {      state = queue[Q_L++];      total = 0;      for (idx = State[state].head; idx >= 0; idx = Edge[idx].next) {        s = Edge[idx].state;        State[s].X = State[state].X + step;        State[s].Y = State[state].Y + step*total;        queue[Q_R++] = s;        total += State[s].subtreewidth;      }    }    for (state = InitialState; state <= NumberofStates; state++) {      s = State[state].failure;      State[state].failure_X = (State[state].X+ State[s].X)/2;      State[state].failure_Y = (State[state].Y+ State[s].Y)/2 + 20;    }  }   public void run() {    while (true) {      repaint();      try {        Thread.sleep(10);      } catch (InterruptedException e) {        break;      }    }  }   private void DrawNode(Graphics g, int s) {    int r = 10;    if (show_explicit && State[s].explicit) {      g.setColor(Color.yellow);    } else {      g.setColor(Color.white);    }    g.fillOval(State[s].X-r, State[s].Y-r, 2*r, 2*r);    g.setColor(Color.black);    g.drawOval(State[s].X-r, State[s].Y-r, 2*r, 2*r);    g.drawString(""+s, State[s].X-5, State[s].Y+5);  }  private void DrawGotoEdge(Graphics g, int s, int t, char ch) {    int dx, dy;    int r = 10;    int w, h;    double ll;    w = State[t].X - State[s].X;    h = State[t].Y - State[s].Y;    ll = Math.sqrt(w*w+h*h);    dx = (int)Math.round( (r*w)/ll );    dy = (int)Math.round( (r*h)/ll );    g.drawString(""+ch, (State[s].X+State[t].X)/2, (State[s].Y+State[t].Y)/2);    g.drawLine(State[s].X+dx, State[s].Y+dy, State[t].X-dx, State[t].Y-dy);   }  private boolean is_in_Circle(double x, double y, double a, double b, int r)  {    double w = x - a;    double h = y - b;    return (w*w + h*h <= (double)r*r); 	  }  private void DrawFailureEdge(Graphics g, int from, int to) {    int r = 10;    int x0 = State[from].X;    int y0 = State[from].Y;    int x1 = State[to  ].X;    int y1 = State[to  ].Y;    double w, h, ll;    int i,j;    spline s = new spline();    s.X[0] = (double)x0;     s.Y[0] = (double)y0;    s.X[1] = (double)State[from].failure_X;     s.Y[1] = (double)State[from].failure_Y;    s.X[2] = (double)x1;     s.Y[2] = (double)y1;    s.N = 3;    double xx[] = new double[11];    double yy[] = new double[11];    for (i=0; i <= 10; i++) {      s.spline(0.1*i);      xx[i] = Math.round(s.R[0]);      yy[i] = Math.round(s.R[1]);     }    for (i = 0; i < 10; i++) {      if (is_in_Circle(xx[i+1], yy[i+1], x0, y0, r) == false) break;    }    for (j = 10; j > 0; j--) {      if (is_in_Circle(xx[j-1], yy[j-1], x1, y1, r) == false) break;    }/*    w = xx[i+1]-xx[i];    h = yy[i+1]-yy[i];    ll= Math.sqrt(w*w+h*h);    xx[i] += (d*w)/ll;    yy[i] += (d*h)/ll;    w = xx[j] - xx[j-1];    h = yy[j] - yy[j-1];    ll= Math.sqrt(w*w+h*h);    xx[j] -= (d*w)/ll;    yy[j] -= (d*w)/ll;  */    i = 0; j = 10;    for (  ; i < j; i++) {      g.drawLine((int)xx[i], (int)yy[i], (int)xx[i+1], (int)yy[i+1]);    }    if (graph.Edit_Mode) {      g.fillRect(State[from].failure_X, State[from].failure_Y, 5, 5);    }  }  Image offscreen;  Dimension offscreensize;  Graphics offgraphics;  public synchronized void update(Graphics g) {    Dimension d = size();    if ((offscreen == null) || (d.width != offscreensize.width) || (d.height != offscreensize.height)) {      offscreen = createImage(d.width, d.height);      offscreensize = d;      offgraphics = offscreen.getGraphics();      offgraphics.setFont(getFont());    }    offgraphics.setColor(getBackground());    offgraphics.fillRect(0, 0, d.width, d.height);    offgraphics.setColor(Color.black);    for (int t = InitialState; t <= NumberofStates; t++) {//      DrawNode(offgraphics, t);//      for (char c = 0; c < 256; c++) {        int s;        if ((s = GoTo(t, c)) == 0) continue;        DrawGotoEdge(offgraphics, t, s, c);      }      if (suffix_links && t > InitialState) {        offgraphics.setColor(Color.red);        DrawFailureEdge(offgraphics, t, State[t].failure);        offgraphics.setColor(Color.black);      }    }    for (int t = InitialState; t <= NumberofStates; t++) {      DrawNode(offgraphics, t);    }    g.drawImage(offscreen, 0, 0, null);  }   int PickUp = -1;  public synchronized boolean mouseDown(Event evt, int x, int y) {    if (graph.Edit_Mode == false) return true;    for (int s = InitialState; s <= NumberofStates; s++) {      int x0 = State[s].failure_X;       int y0 = State[s].failure_Y;      if (Math.abs(x0-x) <= 5 && Math.abs(y0-y) <= 5) {        PickUp = s;        State[PickUp].failure_X = x;        State[PickUp].failure_Y = y;        repaint();        return true;      }    }    PickUp = -1;    return true;  }  public synchronized boolean mouseDrag(Event evt, int x, int y) {    if (graph.Edit_Mode == false) return true;    if (PickUp != -1) {      State[PickUp].failure_X = x;      State[PickUp].failure_Y = y;    }    repaint();    return true;  }  public synchronized boolean mouseUp(Event evt, int x, int y) {    if (graph.Edit_Mode == false) return true;    if (PickUp != -1) {      State[PickUp].failure_X = x;      State[PickUp].failure_Y = y;    }    repaint();    return true;  }  public void start() {   relaxer = new Thread(this);   relaxer.start();  }   public void stop() {   relaxer.stop();  }}public class STrieDemo extends Applet {  TextField p_input;  STrie strie;  boolean Edit_Mode = false;  boolean Running   = false;  public void init() {    setLayout(new BorderLayout());    strie = new STrie(this);    add("Center", strie);    Panel p = new Panel();    add("North", p);    p.setLayout(new GridLayout(2,2));    p.add(p_input = new TextField("cacao"));    p.add(new Button("Build"));    p.add(new Button("Edit"));    p.add(new Button("Done"));    p.add(new Checkbox("explicit nodes"));    p.add(new Checkbox("suffix links"));    strie.make_suffix_trie(p_input.getText());  }  public void start() {    strie.start();  }  public void stop() {    strie.stop();  }  public boolean action(Event evt, Object arg) {    if (evt.target instanceof Button) {      Edit_Mode = (arg.equals("Edit"));      if (arg.equals("Build")) {        strie.make_suffix_trie(p_input.getText());      }    } else if (evt.target instanceof Checkbox) {      Checkbox c = (Checkbox)(evt.target);      if (c.getLabel().equals("explicit nodes")) {        strie.show_explicit = c.getState();      } else if (c.getLabel().equals("suffix links")) {        strie.suffix_links = c.getState();      }    }    return true;  }}