import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.util.Enumeration;//import java.util.StringTokenizer;import java.util.Vector;import java.util.regex.*;import java.lang.Math;/* * args[0] = coordinate : 座標ファイル  * args[1] = 1〜4 :分割法 1:kd木 2:     3:面積等分  4:quad tree * * */public class ApmMain {		public static void main(String[] args) {		String line, tokens[];		Vector pvec = new Vector();		//パターンデータを読み込み		long InputStart, InputEnd;		InputStart = System.currentTimeMillis();		try{			BufferedReader reader = new BufferedReader(new FileReader(args[0]));			int number = 0;			int scale = 3;			Pattern p = Pattern.compile(",");			while ((line = reader.readLine()) != null){//				StringTokenizer stk = new StringTokenizer(line,",");				tokens = p.split(line);				Integer dx = new Integer(tokens[0]); //stk.nextToken());				Integer dy = new Integer(tokens[1]); //stk.nextToken());				//	pvec.addElement(new Point(dx.intValue(),dy.intValue(),number));				pvec.addElement(new Point(dx.intValue()*scale,dy.intValue()*scale,number));								number++;			}	    	reader.close();		} catch(Exception e){			System.out.println("Error:パターンデータの読み込み");			System.out.println("      "+e);		}				//配列への格納		Point p[] = new Point[pvec.size()];		Enumeration e = pvec.elements();		for(int i = 0; i < p.length;i++){			p[i] = new Point((Point)e.nextElement());		}				//テキストデータの作成				InputEnd = System.currentTimeMillis();		//System.out.println("インプット:"+(InputEnd-InputStart)+"[msec]" + "- ApmMain.Main");		//近似照合		long MatchingStart, MatchingEnd;		int type = Integer.parseInt(args[1]);//分割法を決める		int grid = Integer.parseInt(args[2]);//グリッド幅		int pCutSize = Integer.parseInt(args[3]);//カット幅				MatchingStart = System.currentTimeMillis();				//グリットの幅、カット時の最大サイズの設定はここ		//Matching(p,100,10,type,args[0]);		Matching(p,grid,pCutSize,type,args[0]);		MatchingEnd = System.currentTimeMillis();		System.out.println("分割マッチング:"+(MatchingEnd-MatchingStart)+"[msec]" + "- ApmMain.Main");	}		static void Matching(Point[] p, int grid, int pCutSize, int type, String args){//		int n=0;		Matching2 m;				switch (type) {			case 1:				m = approximatematch(p, grid, pCutSize, 0);				OutputNodeCoord(m,args);				System.out.println("Finished a pure approx. matching.");				break;			/*				m = Partition2(p, grid, pCutSize, 0);				OutputNodeCoord(m,args);				break;				*/			case 2:				m = Partition(p, grid, pCutSize, 0);//kd木				OutputNodeCoord(m,args);				break;			case 3:				int p_maxx= p[0].x(),p_minx= p[0].x();				int p_maxy= p[0].y(),p_miny= p[0].y();				for(int i = 1; i < p.length;i++){					if(p_maxx < p[i].x()){p_maxx = p[i].x();}					if(p_minx > p[i].x()){p_minx = p[i].x();}					if(p_maxy < p[i].y()){p_maxy = p[i].y();}					if(p_miny > p[i].y()){p_miny = p[i].y();}				}				int cutx = (p_maxx-p_minx)/pCutSize+2;				int cuty = (p_maxy-p_miny)/pCutSize+2;				m = Partition3(p, grid, cutx,cuty,p_minx, p_miny, pCutSize, 0);//面積等分				//System.out.println("p="+p.length+"\tm="+m.size());				//for(int i=0;i<p.length;i++)				//	System.out.println(i+":coord="+m.toString(i));				OutputNodeCoord(m,args);				break;			default:				m = Partition4(p, grid, pCutSize);				//System.out.println("Partition4");				OutputNodeCoord(m,args);		}	}		//quad tree	static Matching2 Partition4(Point[] p, int grid, int size){				Matching2 out = new Matching2(p.length);		Matching2 temp = new Matching2(p.length);		int p_maxx= p[0].x(),p_minx= p[0].x();		int p_maxy= p[0].y(),p_miny= p[0].y();		for(int i = 1; i < p.length;i++){			if(p_maxx < p[i].x()){p_maxx = p[i].x();}			if(p_minx > p[i].x()){p_minx = p[i].x();}			if(p_maxy < p[i].y()){p_maxy = p[i].y();}			if(p_miny > p[i].y()){p_miny = p[i].y();}		}		double xWidth = (p_maxx - p_minx)/(double)size;		double yWidth = (p_maxy - p_miny)/(double)size;		int totalcount = 0;				for(int i=0;i < size;i++){			double yLowLimit = yWidth*i+p_miny;			double yHighLimit = yLowLimit + yWidth;			if(i == size -1){				yHighLimit = p_maxy+1;			}			temp.reset();			for(int j=0;j < size;j++){				double xLowLimit = xWidth*j+p_minx;				double xHighLimit = xLowLimit + xWidth;				if(j == size -1){					xHighLimit = p_maxx+1;				}				//System.out.println("("+xLowLimit+"-"+xHighLimit+","+yLowLimit+"-"+yHighLimit+")");				int count = 0;				for(int k=0; k < p.length;k++){					if(xLowLimit<= p[k].x() && p[k].x() < xHighLimit && yLowLimit <= p[k].y() && p[k].y() < yHighLimit){						count++;					}				}				totalcount += count;				if(count != 0){					Point p_part[] = new Point[count];					count = 0;					Matching2 m_part;					for(int k=0; k < p.length;k++){						if(xLowLimit<= p[k].x() && p[k].x() < xHighLimit && yLowLimit <= p[k].y() && p[k].y() < yHighLimit){							p_part[count] = new Point(p[k]);							count++;						}					}					if(p_part.length > 10){						//System.out.println("n="+n);						//System.out.println("さらに分割");						m_part = Partition4(p_part,grid,2);						//System.out.println("さらに分割　おわり");					}else{// 近似照合						m_part = Apm(p_part,grid);					}					if(m_part.size() != p_part.length){						//System.out.println("????????????????????????????????"+m_part.size() +","+p_part.length);					}					if(temp.gettxmax() >= m_part.gettxmin()){						temp.add(m_part,temp.gettxmax() - m_part.gettxmin()+grid,0);					}else{						temp.add(m_part);					}				}			}			if(out.gettymax() >= temp.gettymin()){				out.add(temp,0,out.gettymax() - temp.gettymin()+grid);			}else{				out.add(temp);			}		}		//System.out.println(totalcount+"!!!");		return out;	}		//面積で等分にきる	static Matching2 Partition3(Point[] p, int grid,int cutx, int cuty, int sx, int sy,int size, int rank){		long MatchingStart, MatchingEnd;		MatchingStart = System.currentTimeMillis();		Matching2 out = new Matching2(p.length);				if(rank == 1){//x軸の分割			for(int i = 0;i < size;i++){				int p_max,p_min;				p_min = (int)(cutx *i) + sx;				p_max = (int)(cutx *(i+1)) + sx;				int count=0;				for(int k=0; k < p.length;k++){					if(p_min< p[k].x() && p[k].x() <= p_max){						count++;					}				}				if(count != 0){					Point p_part[] = new Point[count];					count = 0;					for(int k=0; k < p.length;k++){						if(p_min< p[k].x() && p[k].x() <= p_max){							p_part[count] = new Point(p[k]);							count++;						}					}					Matching2 m_part = Partition3(p_part,grid,cutx,cuty,sx,sy,size,rank+1);					if(out.gettxmax() >= m_part.gettxmin()){						out.add(m_part,out.gettxmax() - m_part.gettxmin()+grid,0);					}else{						out.add(m_part);					}				}			}				System.out.println("out="+out.size());		}else if(rank == 0){			for(int i = 0;i < size;i++){				int p_max,p_min;				p_min = (int)(cuty *i) + sy;				p_max = (int)(cuty *(i+1)) + sy;								int count=0;//grid内にいくつあるか数える				for(int k=0; k < p.length;k++){					if(p_min< p[k].y() && p[k].y() <= p_max){						count++;					}				}				if(count != 0){					Point p_part[] = new Point[count];					count = 0;					for(int k=0; k < p.length;k++){//grid内の情報を入れる						if(p_min< p[k].y() && p[k].y() <= p_max){							p_part[count] = new Point(p[k]);							count++;						}					}					Matching2 m_part = Partition3(p_part,grid,cutx,cuty,sx,sy,size,rank+1);//さらに分割してみる					if(out.gettymax() >= m_part.gettymin()){						out.add(m_part,0,out.gettymax() - m_part.gettymin()+grid);					}else{						out.add(m_part);					}				}			}			System.out.println("out="+out.size());		}else{			if(p.length > 10){				//System.out.println(p.length +"：さらに分割");				int p_maxx= p[0].x(),p_minx= p[0].x();				int p_maxy= p[0].y(),p_miny= p[0].y();				for(int i = 1; i < p.length;i++){					if(p_maxx < p[i].x()){p_maxx = p[i].x();}					if(p_minx > p[i].x()){p_minx = p[i].x();}					if(p_maxy < p[i].y()){p_maxy = p[i].y();}					if(p_miny > p[i].y()){p_miny = p[i].y();}				}				int cut_x = (p_maxx-p_minx)/2+2;				int cut_y = (p_maxy-p_miny)/2+2;				out.add(Partition3(p,grid,cut_x, cut_y,p_minx,p_miny,2,0));				//System.out.println(p.length +"：さらに分割 終わり");			}else if(p.length == 0){							}else{//grid内を10以下までできたら、				int p_xmax= p[0].x(),p_ymax= p[0].y();				int p_xmin = p[0].x(),p_ymin = p[0].y();				for(int i = 1;i < p.length;i++){					if(p_xmin > p[i].x()){p_xmin = p[i].x();}					if(p_ymin > p[i].y()){p_ymin = p[i].y();}					if(p_xmax < p[i].x()){p_xmax = p[i].x();}					if(p_ymax < p[i].y()){p_ymax = p[i].y();}				}								int p_xWidth = p_xmax - p_xmin;				int p_yWidth = p_ymax - p_ymin;								if( p_xWidth / grid < p.length-1){					p_xWidth = (p.length-1) * grid;				}				if( p_yWidth / grid < p.length-1){					p_yWidth = (p.length-1) * grid;				}				p_xmin = (p_xmin / grid)* grid;				p_ymin = (p_ymin / grid)* grid;								Point t[] = makeGrid(p_xWidth, p_yWidth, p_xmin, p_ymin, grid);				//System.out.println("分割マッチング("+p.length+","+t.length+")  - ApmMain.Partition");				Hashapm apm = new Hashapm(t, p);				apm.makeList();				//apm.jikken();				apm.makeDP();				MatchingEnd = System.currentTimeMillis();				//System.out.println("  time: "+(MatchingEnd-MatchingStart)+"[msec]  - ApmMain.Partition");				out.add(apm.outTrace());			}		}		return out;	}			static Matching2 Partition2(Point[] p, int grid,int cut_size, int rank){		Matching2 out = new Matching2(p.length);		if(rank == 1){			X_quickSort(p,0,p.length-1);			Point2 p2 = new Point2(p);			int index = 0;			int size = p.length/cut_size;			for(int i = 0;i < cut_size;i++){				Point p_part[] = p2.get(index, size);				Matching2 m_part = Partition2(p_part,grid,cut_size,rank+1);				if(out.gettxmax() >= m_part.gettxmin()){					out.add(m_part,out.gettxmax() - m_part.gettxmin()+grid,0);				}else{					out.add(m_part);				}				index += size;			}			if(p.length%cut_size != 0){				Point p_part[] = p2.get(index, p.length%cut_size);				Matching2 m_part = Partition2(p_part,grid,2,rank+1);				if(out.gettxmax() >= m_part.gettxmin()){					out.add(m_part,out.gettxmax() - m_part.gettxmin()+grid,0);				}else{					out.add(m_part);				}			}		}else if(rank == 0){			Y_quickSort(p,0,p.length-1);			Point2 p2 = new Point2(p);			int index = 0;			int size = p.length/cut_size;			for(int i = 0;i < cut_size;i++){				Point p_part[] = p2.get(index, size);				Matching2 m_part = Partition2(p_part,grid,cut_size,rank+1);				if(out.gettymax() >= m_part.gettymin()){					out.add(m_part,0,out.gettymax() - m_part.gettymin()+grid);				}else{					out.add(m_part);				}				index += size;			}			if(p.length%cut_size != 0){				Point p_part[] = p2.get(index, p.length%cut_size);				//System.out.println(size);				Matching2 m_part = Partition2(p_part,grid,2,rank+1);				if(out.gettymax() >= m_part.gettymin()){					out.add(m_part,0,out.gettymax() - m_part.gettymin()+grid);				}else{					out.add(m_part);				}			}		}else{			long MatchingStart, MatchingEnd;			MatchingStart = System.currentTimeMillis();			int p_xmax= p[0].x();			int p_ymax= p[0].y();			int p_xmin = p[0].x();			int p_ymin = p[0].y();			for(int i = 1;i < p.length;i++){				if(p_xmin > p[i].x()){					p_xmin = p[i].x();				}				if(p_ymin > p[i].y()){					p_ymin = p[i].y();				}				if(p_xmax < p[i].x()){					p_xmax = p[i].x();				}				if(p_ymax < p[i].y()){					p_ymax = p[i].y();				}			}			int p_xWidth = p_xmax - p_xmin;			int p_yWidth = p_ymax - p_ymin;						if(p_xWidth / grid < p.length-1){				p_xWidth = (p.length-1) * grid;			}			if(p_yWidth / grid < p.length-1){				p_yWidth = (p.length-1) * grid;			}			p_xmin = (p_xmin / grid)* grid;			p_ymin = (p_ymin / grid)* grid;			Point t[] = new Point[(p_xWidth/grid+1) * (p_yWidth/grid+1)];			int t_count = 0;			for(int i = 0;i <= p_xWidth;i += grid){				for(int j = 0;j <= p_yWidth;j +=grid){					t[t_count] = new Point(i+p_xmin,j+p_ymin,t_count);					t_count++;				}			}			//System.out.println("分割マッチング("+p.length+","+t.length+")  - ApmMain.Partition");			Hashapm apm = new Hashapm(t, p);			apm.makeList();			//apm.jikken();			apm.makeDP();			MatchingEnd = System.currentTimeMillis();			//System.out.println("  time: "+(MatchingEnd-MatchingStart)+"[msec]  - ApmMain.Partition");			out.add(apm.outTrace());				}		return out;	}		//kd	static Matching2 Partition(Point[] p, int grid,int cut_size, int depth){		//System.out.println("depth:"+depth + "  size:" +p.length);		if(p.length > cut_size){//カットサイズより大きかったら分割：領域内のノードの数			int left = p.length/2;			int right = p.length  - p.length/2;			Point p1[] = new Point[left];			Point p2[] = new Point[right];			Matching2 m1,m2;			Matching2 out = new Matching2(p.length);			//x->y->x->y...と分割していく			if(depth % 2 == 0){				X_quickSort(p,0,p.length-1);								for(int i = 0; i < left;i++){					p1[i] = new Point(p[i]);				}								for(int i=left;i < p.length;i++){					p2[i - left] = new Point(p[i]);				}								m1 = Partition(p1,grid,cut_size,depth+1);				m2 = Partition(p2,grid,cut_size,depth+1);								out.add(m1);				if(out.gettymax() >= m2.gettymin()){					out.add(m2,out.gettxmax() - m2.gettxmin()+grid,0);				}else{					out.add(m2);				}			}else{				Y_quickSort(p,0,p.length-1);								for(int i = 0; i < left;i++){					p1[i] = new Point(p[i]);				}								for(int i=left;i < p.length;i++){					p2[i-left] = new Point(p[i]);				}				m1 = Partition(p1,grid,cut_size,depth+1);				m2 = Partition(p2,grid,cut_size,depth+1);				out.add(m1);				if(out.gettymax() >= m2.gettymin()){					out.add(m2,0,out.gettymax() - m2.gettymin()+grid);				}else{					out.add(m2);				}			}			return out;		}else{//小さい場合は照合			long MatchingStart, MatchingEnd;			MatchingStart = System.currentTimeMillis();			int p_xmax= p[0].x();			int p_ymax= p[0].y();			int p_xmin = p[0].x();			int p_ymin = p[0].y();			for(int i = 1;i < p.length;i++){				if(p_xmin > p[i].x()){					p_xmin = p[i].x();				}				if(p_ymin > p[i].y()){					p_ymin = p[i].y();				}				if(p_xmax < p[i].x()){					p_xmax = p[i].x();				}				if(p_ymax < p[i].y()){					p_ymax = p[i].y();				}			}			int p_xWidth = p_xmax - p_xmin;			int p_yWidth = p_ymax - p_ymin;						if(p_xWidth / grid < p.length-1){				p_xWidth = (p.length-1) * grid;			}			if(p_yWidth / grid < p.length-1){				p_yWidth = (p.length-1) * grid;			}			p_xmin = (p_xmin / grid)* grid;			p_ymin = (p_ymin / grid)* grid;			Point t[] = new Point[(p_xWidth/grid+1) * (p_yWidth/grid+1)];//Grid作成			int t_count = 0;			for(int i = 0;i <= p_xWidth;i += grid){				for(int j = 0;j <= p_yWidth;j +=grid){					t[t_count] = new Point(i+p_xmin,j+p_ymin,t_count);					t_count++;				}			}			Matching2 out = new Matching2(p.length);			//System.out.println("分割マッチング("+p.length+","+t.length+")  - ApmMain.Partition");			Hashapm apm = new Hashapm(t, p);			apm.makeList();			//apm.jikken();			apm.makeDP();			MatchingEnd = System.currentTimeMillis();			System.out.println("  time: "+(MatchingEnd-MatchingStart)+"[msec]  - ApmMain.Partition");			out.add(apm.outTrace());			return out;		}			}		//non-partitioning	static Matching2 approximatematch(Point[] p, int grid,int cut_size, int depth){		//System.out.println("depth:"+depth + "  size:" +p.length);		long MatchingStart, MatchingEnd;		MatchingStart = System.currentTimeMillis();		// identifying the bounding rect.		int p_xmax= p[0].x();		int p_ymax= p[0].y();		int p_xmin = p[0].x();		int p_ymin = p[0].y();		System.out.println("px: "+p[0].x()+"  py: "+p[0].y());		for(int i = 1;i < p.length;i++){			System.out.println("px: "+p[i].x()+"  py: "+p[i].y());			p_xmin = Math.min(p_xmin, p[i].x() );			p_ymin = Math.min(p_ymin, p[i].y() );			p_xmax = Math.max(p_xmax, p[i].x() );			p_ymax = Math.max(p_ymax, p[i].y() );		}		System.out.println();		//		int p_xWidth = p_xmax - p_xmin;		int p_yWidth = p_ymax - p_ymin;				if(p_xWidth / grid < p.length-1){			p_xWidth = (p.length-1) * grid;		}		if(p_yWidth / grid < p.length-1){			p_yWidth = (p.length-1) * grid;		}		p_xmin = (p_xmin / grid)* grid;		p_ymin = (p_ymin / grid)* grid;		Point t[] = new Point[(p_xWidth/grid+1) * (p_yWidth/grid+1)];//Grid作成		int t_count = 0;		for(int i = 0;i <= p_xWidth;i += grid){			for(int j = 0;j <= p_yWidth;j +=grid){				t[t_count] = new Point(i+p_xmin,j+p_ymin,t_count);				System.out.println("tx: "+t[t_count].x()+"  ty: "+t[t_count].y());				t_count++;			}		}		System.out.println();				Matching2 out = new Matching2(p.length);		//System.out.println("分割マッチング("+p.length+","+t.length+")  - ApmMain.Partition");		Hashapm apm = new Hashapm(t, p);		apm.makeList();		//apm.jikken();		apm.makeDP();		MatchingEnd = System.currentTimeMillis();		System.out.println("  time: "+(MatchingEnd-MatchingStart)+"[msec]  - ApmMain.Partition");		out.add(apm.outTrace());		return out;		}			static void Marge(Matching[] m, Matching[] m1, Matching[] m2){		int j = 0;				for(;j < m1.length;j++){			m[j] = m1[j];		}		for(;j < m.length;j++){			m[j] = m2[j-m1.length];		}	}		static void X_quickSort(Point[] arr, int left, int right){		if (left <= right) {			Point p = new Point(arr[(left+right) / 2]);			int l = left;			int r = right;			            while(l <= r) {            	while(arr[l].x() <= p.x()){            		if(arr[l].x() == p.x() && arr[l].y() >= p.y()){            			break;            		}            		l++;            	}            	while(arr[r].x() >= p.x()){            		if(arr[r].x() == p.x() && arr[r].y() <= p.y()){            			break;            		}            		r--;                }            	if (l <= r) {                    Point tmp = new Point(arr[l]);                    arr[l].renew(arr[r]);                    arr[r].renew(tmp);                    l++;                     r--;                }else{                }            }            X_quickSort(arr, left, r);            X_quickSort(arr, l, right);        }    }		static void Y_quickSort(Point[] arr, int left, int right){        if (left <= right) {            Point p = new Point(arr[(left+right) / 2]);            int l = left;            int r = right;                        while(l <= r) {            	while(arr[l].y() <= p.y()){            		if(arr[l].y() == p.y() && arr[l].x() >= p.x()){            			break;            		}            		l++;            	}                while(arr[r].y() >= p.y()){            		if(arr[r].y() == p.y() && arr[r].x() <= p.x()){            			break;            		}                	r--;                 }                                if (l <= r) {                    Point tmp = new Point(arr[l]);                    arr[l].renew(arr[r]);                    arr[r].renew(tmp);                    l++;                     r--;                }            }              Y_quickSort(arr, left, r);            Y_quickSort(arr, l, right);        }    }		static Point[] makeGrid(int p_xWidth, int p_yWidth, int p_xmin, int p_ymin, int grid){		Point t[] = new Point[(p_xWidth/grid+1)*(p_yWidth/grid+1)];		int t_count = 0;		for(int i = 0;i <= p_xWidth;i += grid){			for(int j = 0;j <= p_yWidth;j +=grid){				t[t_count] = new Point(i+p_xmin,j+p_ymin,t_count);				t_count++;			}		}		return t;	}		static Matching2 Apm(Point[] p, int grid){		long MatchingStart, MatchingEnd;		MatchingStart = System.currentTimeMillis();		int p_xmax= p[0].x();		int p_ymax= p[0].y();		int p_xmin = p[0].x();		int p_ymin = p[0].y();		for(int i = 1;i < p.length;i++){			if(p_xmin > p[i].x()){				p_xmin = p[i].x();			}			if(p_ymin > p[i].y()){				p_ymin = p[i].y();			}			if(p_xmax < p[i].x()){				p_xmax = p[i].x();			}			if(p_ymax < p[i].y()){				p_ymax = p[i].y();			}		}		int p_xWidth = p_xmax - p_xmin;		int p_yWidth = p_ymax - p_ymin;				if(p_xWidth / grid < p.length-1){			p_xWidth = (p.length-1) * grid;		}		if(p_yWidth / grid < p.length-1){			p_yWidth = (p.length-1) * grid;		}		p_xmin = (p_xmin / grid)* grid;		p_ymin = (p_ymin / grid)* grid;		Point t[] = new Point[(p_xWidth/grid+1) * (p_yWidth/grid+1)];		int t_count = 0;		for(int i = 0;i <= p_xWidth;i += grid){			for(int j = 0;j <= p_yWidth;j +=grid){				t[t_count] = new Point(i+p_xmin,j+p_ymin,t_count);				t_count++;			}		}		Matching2 out = new Matching2(p.length);		//System.out.println("分割マッチング("+p.length+","+t.length+")  - ApmMain.Apm");		Hashapm apm = new Hashapm(t, p);		apm.makeList();		//apm.jikken();		apm.makeDP();		MatchingEnd = System.currentTimeMillis();		//System.out.println("  time: "+(MatchingEnd-MatchingStart)+"[msec]  - ApmMain.Apm");		//System.out.println(apm.outTrace().length);		out.add(apm.outTrace(),p.length);				return out;	}		static void OutputNodeCoord(Matching2 m,String args){		/*		 //Draw用出力ファイル		 try{		 BufferedWriter bw = new BufferedWriter(new FileWriter("result.txt"));		 for(int i=0;i < m.size();i++){		 bw.write(m.toString(i)+"\n");		 }		 bw.close();		 } catch(Exception e){		 System.out.println("Error1:パターンデータの読み込み"+e);		 }		 */		//MATLAB用出力ファイル		try{			String line, tokens[];			Point[] old = new Point[m.size()];			int number=0;			int x,y;			BufferedReader reader = new BufferedReader(new FileReader(args));			Pattern p = Pattern.compile(",");			while ((line = reader.readLine()) != null){//				StringTokenizer stk = new StringTokenizer(line,",");				tokens = p.split(line);				x = Integer.parseInt(tokens[0]); //stk.nextToken());				y = Integer.parseInt(tokens[1]); //stk.nextToken());				old[number] = new Point(x*3,y*3,number);				number++;			}			reader.close();			            BufferedWriter bw = new BufferedWriter(new FileWriter("MATLAB_PMcoordinate.txt"));			for(int i=0;i < m.size();i++){				for(int j=0;j < m.size();j++){					if(old[i].x() == m.getp(j).x() && old[i].y() == m.getp(j).y()){						bw.write(m.gett(j).x()+"");						bw.write(",");						bw.write(m.gett(j).y()+"\n");						break;					}				}			}			bw.close();		}catch(Exception e){			e.printStackTrace();			System.out.println("Error2:パターンデータの読み込み"+e);		}	}}