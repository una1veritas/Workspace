
1-Key-Keyboard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000008b6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  00800060  000008b6  0000094a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000003f  00800064  00800064  0000094e  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  0000094e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000020b  00000000  00000000  0000098e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000c69  00000000  00000000  00000b99  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000004f3  00000000  00000000  00001802  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000077f  00000000  00000000  00001cf5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000080  00000000  00000000  00002474  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000004d4  00000000  00000000  000024f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000565  00000000  00000000  000029c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000118  00000000  00000000  00002f2d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	57 c0       	rjmp	.+174    	; 0xb0 <__ctors_end>
   2:	fa c2       	rjmp	.+1524   	; 0x5f8 <__vector_1>
   4:	70 c0       	rjmp	.+224    	; 0xe6 <__bad_interrupt>
   6:	6f c0       	rjmp	.+222    	; 0xe6 <__bad_interrupt>
   8:	6e c0       	rjmp	.+220    	; 0xe6 <__bad_interrupt>
   a:	6d c0       	rjmp	.+218    	; 0xe6 <__bad_interrupt>
   c:	6c c0       	rjmp	.+216    	; 0xe6 <__bad_interrupt>
   e:	6b c0       	rjmp	.+214    	; 0xe6 <__bad_interrupt>
  10:	6a c0       	rjmp	.+212    	; 0xe6 <__bad_interrupt>
  12:	69 c0       	rjmp	.+210    	; 0xe6 <__bad_interrupt>
  14:	68 c0       	rjmp	.+208    	; 0xe6 <__bad_interrupt>
  16:	67 c0       	rjmp	.+206    	; 0xe6 <__bad_interrupt>
  18:	66 c0       	rjmp	.+204    	; 0xe6 <__bad_interrupt>
  1a:	65 c0       	rjmp	.+202    	; 0xe6 <__bad_interrupt>
  1c:	64 c0       	rjmp	.+200    	; 0xe6 <__bad_interrupt>

0000001e <usbDescriptorHidReport>:
  1e:	05 01 09 06 a1 01 05 07 19 e0 29 e7 15 00 25 01     ..........)...%.
  2e:	75 01 95 08 81 02 95 01 75 08 25 65 19 00 29 65     u.......u.%e..)e
  3e:	81 00 c0                                            ...

00000041 <usbDescriptorString0>:
  41:	04 03 09 04                                         ....

00000045 <usbDescriptorStringVendor>:
  45:	18 03 66 00 6c 00 69 00 70 00 77 00 6f 00 72 00     ..f.l.i.p.w.o.r.
  55:	6b 00 2e 00 6e 00 6c 00                             k...n.l.

0000005d <usbDescriptorStringDevice>:
  5d:	1e 03 31 00 2d 00 4b 00 65 00 79 00 2d 00 4b 00     ..1.-.K.e.y.-.K.
  6d:	65 00 79 00 62 00 6f 00 61 00 72 00 64 00           e.y.b.o.a.r.d.

0000007b <usbDescriptorDevice>:
  7b:	12 01 10 01 00 00 00 08 42 42 31 e1 00 01 01 02     ........BB1.....
  8b:	00 01                                               ..

0000008d <usbDescriptorConfiguration>:
  8d:	09 02 22 00 01 01 00 80 19 09 04 00 00 01 03 00     ..".............
  9d:	00 00 09 21 01 01 00 01 22 23 00 07 05 81 03 08     ...!...."#......
  ad:	00 0a 00                                            ...

000000b0 <__ctors_end>:
  b0:	11 24       	eor	r1, r1
  b2:	1f be       	out	0x3f, r1	; 63
  b4:	cf e5       	ldi	r28, 0x5F	; 95
  b6:	d1 e0       	ldi	r29, 0x01	; 1
  b8:	de bf       	out	0x3e, r29	; 62
  ba:	cd bf       	out	0x3d, r28	; 61

000000bc <__do_copy_data>:
  bc:	10 e0       	ldi	r17, 0x00	; 0
  be:	a0 e6       	ldi	r26, 0x60	; 96
  c0:	b0 e0       	ldi	r27, 0x00	; 0
  c2:	e6 eb       	ldi	r30, 0xB6	; 182
  c4:	f8 e0       	ldi	r31, 0x08	; 8
  c6:	02 c0       	rjmp	.+4      	; 0xcc <.do_copy_data_start>

000000c8 <.do_copy_data_loop>:
  c8:	05 90       	lpm	r0, Z+
  ca:	0d 92       	st	X+, r0

000000cc <.do_copy_data_start>:
  cc:	a4 36       	cpi	r26, 0x64	; 100
  ce:	b1 07       	cpc	r27, r17
  d0:	d9 f7       	brne	.-10     	; 0xc8 <.do_copy_data_loop>

000000d2 <__do_clear_bss>:
  d2:	10 e0       	ldi	r17, 0x00	; 0
  d4:	a4 e6       	ldi	r26, 0x64	; 100
  d6:	b0 e0       	ldi	r27, 0x00	; 0
  d8:	01 c0       	rjmp	.+2      	; 0xdc <.do_clear_bss_start>

000000da <.do_clear_bss_loop>:
  da:	1d 92       	st	X+, r1

000000dc <.do_clear_bss_start>:
  dc:	a3 3a       	cpi	r26, 0xA3	; 163
  de:	b1 07       	cpc	r27, r17
  e0:	e1 f7       	brne	.-8      	; 0xda <.do_clear_bss_loop>
  e2:	39 d0       	rcall	.+114    	; 0x156 <main>
  e4:	e6 c3       	rjmp	.+1996   	; 0x8b2 <_exit>

000000e6 <__bad_interrupt>:
  e6:	8c cf       	rjmp	.-232    	; 0x0 <__vectors>

000000e8 <usbFunctionSetup>:
/* ------------------------ interface to USB driver ------------------------ */
/* -------------------------------------------------------------------------------- */

uchar	usbFunctionSetup(uchar data[8])
{
usbRequest_t    *rq = (void *)data;
  e8:	fc 01       	movw	r30, r24

    usbMsgPtr = reportBuffer;
  ea:	86 e6       	ldi	r24, 0x66	; 102
  ec:	90 e0       	ldi	r25, 0x00	; 0
  ee:	90 93 88 00 	sts	0x0088, r25
  f2:	80 93 87 00 	sts	0x0087, r24
    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
  f6:	80 81       	ld	r24, Z
  f8:	80 76       	andi	r24, 0x60	; 96
  fa:	80 32       	cpi	r24, 0x20	; 32
  fc:	51 f5       	brne	.+84     	; 0x152 <usbFunctionSetup+0x6a>
        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
  fe:	81 81       	ldd	r24, Z+1	; 0x01
 100:	81 30       	cpi	r24, 0x01	; 1
 102:	b1 f4       	brne	.+44     	; 0x130 <usbFunctionSetup+0x48>

static void buildReport(void)
{
uchar key = 0; //if not changed by the if-statement below, then send an empty report

    if(reportCount == 0){
 104:	90 91 69 00 	lds	r25, 0x0069
 108:	99 23       	and	r25, r25
 10a:	11 f0       	breq	.+4      	; 0x110 <usbFunctionSetup+0x28>
 10c:	80 e0       	ldi	r24, 0x00	; 0
 10e:	07 c0       	rjmp	.+14     	; 0x11e <usbFunctionSetup+0x36>
        if (buttonState == 1){ // if button is not pressed
 110:	80 91 6a 00 	lds	r24, 0x006A
 114:	81 30       	cpi	r24, 0x01	; 1
 116:	11 f0       	breq	.+4      	; 0x11c <usbFunctionSetup+0x34>
 118:	8f e2       	ldi	r24, 0x2F	; 47
 11a:	01 c0       	rjmp	.+2      	; 0x11e <usbFunctionSetup+0x36>
 11c:	80 e3       	ldi	r24, 0x30	; 48
		key = 0x2F;  // key = [
    	}
    }


	reportCount++;
 11e:	9f 5f       	subi	r25, 0xFF	; 255
 120:	90 93 69 00 	sts	0x0069, r25
    reportBuffer[0] = 0;    /* no modifiers */
 124:	10 92 66 00 	sts	0x0066, r1
    reportBuffer[1] = key;
 128:	80 93 67 00 	sts	0x0067, r24
 12c:	82 e0       	ldi	r24, 0x02	; 2
 12e:	08 95       	ret
    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
            /* we only have one report type, so don't look at wValue */
            buildReport();
            return sizeof(reportBuffer);
        }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
 130:	82 30       	cpi	r24, 0x02	; 2
 132:	41 f4       	brne	.+16     	; 0x144 <usbFunctionSetup+0x5c>
            usbMsgPtr = &idleRate;
 134:	88 e6       	ldi	r24, 0x68	; 104
 136:	90 e0       	ldi	r25, 0x00	; 0
 138:	90 93 88 00 	sts	0x0088, r25
 13c:	80 93 87 00 	sts	0x0087, r24
 140:	81 e0       	ldi	r24, 0x01	; 1
 142:	08 95       	ret
            return 1;
        }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
 144:	8a 30       	cpi	r24, 0x0A	; 10
 146:	29 f4       	brne	.+10     	; 0x152 <usbFunctionSetup+0x6a>
            idleRate = rq->wValue.bytes[1];
 148:	83 81       	ldd	r24, Z+3	; 0x03
 14a:	80 93 68 00 	sts	0x0068, r24
 14e:	80 e0       	ldi	r24, 0x00	; 0
 150:	08 95       	ret
 152:	80 e0       	ldi	r24, 0x00	; 0
        }
    }else{
        /* no vendor specific requests implemented */
    }
	return 0;
}
 154:	08 95       	ret

00000156 <main>:
/* ------------------------------------------------------------------------- */
/* --------------------------------- main ---------------------------------- */
/* ------------------------------------------------------------------------- */

int main(void)
{
 156:	0f 93       	push	r16
 158:	1f 93       	push	r17
 15a:	cf 93       	push	r28
 15c:	df 93       	push	r29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 15e:	e1 99       	sbic	0x1c, 1	; 28
 160:	fe cf       	rjmp	.-4      	; 0x15e <main+0x8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
 162:	1e ba       	out	0x1e, r1	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
 164:	e0 9a       	sbi	0x1c, 0	; 28
 166:	8d b3       	in	r24, 0x1d	; 29
uchar   i;
uchar   calibrationValue;

    calibrationValue = eeprom_read_byte(0); /* calibration value from last time */
    if(calibrationValue != 0xff){
 168:	8f 3f       	cpi	r24, 0xFF	; 255
 16a:	09 f0       	breq	.+2      	; 0x16e <__stack+0xf>
        OSCCAL = calibrationValue;
 16c:	81 bf       	out	0x31, r24	; 49
    }
    
	//odDebugInit();
    usbInit();
 16e:	c2 d0       	rcall	.+388    	; 0x2f4 <usbInit>
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
 170:	b8 9a       	sbi	0x17, 0	; 23
 172:	20 e0       	ldi	r18, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 174:	4d e1       	ldi	r20, 0x1D	; 29
 176:	50 e1       	ldi	r21, 0x10	; 16
 178:	04 c0       	rjmp	.+8      	; 0x182 <__stack+0x23>
    i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
        wdt_reset();
 17a:	a8 95       	wdr
 17c:	ca 01       	movw	r24, r20
 17e:	01 97       	sbiw	r24, 0x01	; 1
 180:	f1 f7       	brne	.-4      	; 0x17e <__stack+0x1f>
    
	//odDebugInit();
    usbInit();
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
    i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
 182:	21 50       	subi	r18, 0x01	; 1
 184:	d1 f7       	brne	.-12     	; 0x17a <__stack+0x1b>
        wdt_reset();
        _delay_ms(1);
    }
    usbDeviceConnect();
 186:	b8 98       	cbi	0x17, 0	; 23

    wdt_enable(WDTO_1S);
 188:	8e e0       	ldi	r24, 0x0E	; 14
 18a:	28 e1       	ldi	r18, 0x18	; 24
 18c:	30 e0       	ldi	r19, 0x00	; 0
 18e:	0f b6       	in	r0, 0x3f	; 63
 190:	f8 94       	cli
 192:	a8 95       	wdr
 194:	21 bd       	out	0x21, r18	; 33
 196:	0f be       	out	0x3f, r0	; 63
 198:	81 bd       	out	0x21, r24	; 33

	/* turn on internal pull-up resistor for the switch */
    BUTTON_PORT |= _BV(BUTTON_BIT);
 19a:	c3 9a       	sbi	0x18, 3	; 24

/* ------------------------------------------------------------------------- */

static void timerInit(void)
{
    TCCR1 = 0x0b;           /* select clock: 16.5M/1k -> overflow rate = 16.5M/256k = 62.94 Hz */
 19c:	8b e0       	ldi	r24, 0x0B	; 11
 19e:	80 bf       	out	0x30, r24	; 48
	/* turn on internal pull-up resistor for the switch */
    BUTTON_PORT |= _BV(BUTTON_BIT);

    timerInit();

    sei();
 1a0:	78 94       	sei
    reportBuffer[1] = key;
}

static void checkButtonChange(void) {
	
	uchar tempButtonValue = bit_is_clear(BUTTON_PIN, BUTTON_BIT); //status of switch is stored in tempButtonValue 
 1a2:	c1 e0       	ldi	r28, 0x01	; 1
 1a4:	d0 e0       	ldi	r29, 0x00	; 0
static void timerPoll(void)
{
	static unsigned int timerCnt;

    if(TIFR & (1 << TOV1)){
        TIFR = (1 << TOV1); /* clear overflow */
 1a6:	04 e0       	ldi	r16, 0x04	; 4
        if(++timerCnt >= 3){       // 3/63 sec delay for switch debouncing
			timerCnt = 0;
			debounceTimeIsOver = 1; 
 1a8:	11 e0       	ldi	r17, 0x01	; 1
    timerInit();

    sei();

    for(;;){    /* main event loop */
        wdt_reset();
 1aa:	a8 95       	wdr
        usbPoll();
 1ac:	d0 d0       	rcall	.+416    	; 0x34e <usbPoll>
		/* A USB keypress cycle is defined as a scancode being present in a report, and
		then absent from a later report. To press and release the Caps Lock key, instead of
		holding it down, we need to send the report with the Caps Lock scancode and
		then an empty report. */
		
		if(usbInterruptIsReady() && reportCount < 2){ /* we can send another key */
 1ae:	80 91 62 00 	lds	r24, 0x0062
 1b2:	84 ff       	sbrs	r24, 4
 1b4:	1a c0       	rjmp	.+52     	; 0x1ea <__stack+0x8b>
 1b6:	90 91 69 00 	lds	r25, 0x0069
 1ba:	92 30       	cpi	r25, 0x02	; 2
 1bc:	b0 f4       	brcc	.+44     	; 0x1ea <__stack+0x8b>

static void buildReport(void)
{
uchar key = 0; //if not changed by the if-statement below, then send an empty report

    if(reportCount == 0){
 1be:	99 23       	and	r25, r25
 1c0:	11 f0       	breq	.+4      	; 0x1c6 <__stack+0x67>
 1c2:	80 e0       	ldi	r24, 0x00	; 0
 1c4:	07 c0       	rjmp	.+14     	; 0x1d4 <__stack+0x75>
        if (buttonState == 1){ // if button is not pressed
 1c6:	80 91 6a 00 	lds	r24, 0x006A
 1ca:	81 30       	cpi	r24, 0x01	; 1
 1cc:	11 f0       	breq	.+4      	; 0x1d2 <__stack+0x73>
 1ce:	8f e2       	ldi	r24, 0x2F	; 47
 1d0:	01 c0       	rjmp	.+2      	; 0x1d4 <__stack+0x75>
 1d2:	80 e3       	ldi	r24, 0x30	; 48
		key = 0x2F;  // key = [
    	}
    }


	reportCount++;
 1d4:	9f 5f       	subi	r25, 0xFF	; 255
 1d6:	90 93 69 00 	sts	0x0069, r25
    reportBuffer[0] = 0;    /* no modifiers */
 1da:	10 92 66 00 	sts	0x0066, r1
    reportBuffer[1] = key;
 1de:	80 93 67 00 	sts	0x0067, r24
		holding it down, we need to send the report with the Caps Lock scancode and
		then an empty report. */
		
		if(usbInterruptIsReady() && reportCount < 2){ /* we can send another key */
        	buildReport();
           	usbSetInterrupt(reportBuffer, sizeof(reportBuffer));
 1e2:	86 e6       	ldi	r24, 0x66	; 102
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	62 e0       	ldi	r22, 0x02	; 2
 1e8:	8f d0       	rcall	.+286    	; 0x308 <usbSetInterrupt>
    reportBuffer[1] = key;
}

static void checkButtonChange(void) {
	
	uchar tempButtonValue = bit_is_clear(BUTTON_PIN, BUTTON_BIT); //status of switch is stored in tempButtonValue 
 1ea:	86 b3       	in	r24, 0x16	; 22
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	23 e0       	ldi	r18, 0x03	; 3
 1f0:	96 95       	lsr	r25
 1f2:	87 95       	ror	r24
 1f4:	2a 95       	dec	r18
 1f6:	e1 f7       	brne	.-8      	; 0x1f0 <__stack+0x91>
 1f8:	8c 27       	eor	r24, r28
 1fa:	9d 27       	eor	r25, r29
 1fc:	98 2f       	mov	r25, r24
 1fe:	91 70       	andi	r25, 0x01	; 1

	if (tempButtonValue != buttonState && debounceTimeIsOver == 1){ //if status has changed and the debounce-delay is over
 200:	80 91 6a 00 	lds	r24, 0x006A
 204:	98 17       	cp	r25, r24
 206:	51 f0       	breq	.+20     	; 0x21c <__stack+0xbd>
 208:	80 91 6b 00 	lds	r24, 0x006B
 20c:	81 30       	cpi	r24, 0x01	; 1
 20e:	31 f4       	brne	.+12     	; 0x21c <__stack+0xbd>
		buttonState = tempButtonValue;	// change buttonState to new state
 210:	90 93 6a 00 	sts	0x006A, r25
		debounceTimeIsOver = 0;	// debounce timer starts
 214:	10 92 6b 00 	sts	0x006B, r1
		reportCount = 0; // start report 
 218:	10 92 69 00 	sts	0x0069, r1
 */
static void timerPoll(void)
{
	static unsigned int timerCnt;

    if(TIFR & (1 << TOV1)){
 21c:	08 b6       	in	r0, 0x38	; 56
 21e:	02 fe       	sbrs	r0, 2
 220:	c4 cf       	rjmp	.-120    	; 0x1aa <__stack+0x4b>
        TIFR = (1 << TOV1); /* clear overflow */
 222:	08 bf       	out	0x38, r16	; 56
        if(++timerCnt >= 3){       // 3/63 sec delay for switch debouncing
 224:	80 91 64 00 	lds	r24, 0x0064
 228:	90 91 65 00 	lds	r25, 0x0065
 22c:	01 96       	adiw	r24, 0x01	; 1
 22e:	90 93 65 00 	sts	0x0065, r25
 232:	80 93 64 00 	sts	0x0064, r24
 236:	03 97       	sbiw	r24, 0x03	; 3
 238:	08 f4       	brcc	.+2      	; 0x23c <__stack+0xdd>
 23a:	b7 cf       	rjmp	.-146    	; 0x1aa <__stack+0x4b>
			timerCnt = 0;
 23c:	10 92 65 00 	sts	0x0065, r1
 240:	10 92 64 00 	sts	0x0064, r1
			debounceTimeIsOver = 1; 
 244:	10 93 6b 00 	sts	0x006B, r17
 248:	b0 cf       	rjmp	.-160    	; 0x1aa <__stack+0x4b>

0000024a <usbEventResetReady>:
ATTiny25, ATTiny45, ATTiny85), it may be useful to search for the optimum in
both regions.
*/

void    usbEventResetReady(void)
{
 24a:	df 92       	push	r13
 24c:	ef 92       	push	r14
 24e:	ff 92       	push	r15
 250:	0f 93       	push	r16
 252:	1f 93       	push	r17
 254:	cf 93       	push	r28
 256:	df 93       	push	r29
 258:	00 e0       	ldi	r16, 0x00	; 0
 25a:	30 e8       	ldi	r19, 0x80	; 128
 25c:	d3 2e       	mov	r13, r19
 25e:	ee 24       	eor	r14, r14
 260:	ff 24       	eor	r15, r15
uchar       trialValue = 0, optimumValue;
int         x, optimumDev, targetValue = (unsigned)(1499 * (double)F_CPU / 10.5e6 + 0.5);

    /* do a binary search: */
    do{
        OSCCAL = trialValue + step;
 262:	1d 2d       	mov	r17, r13
 264:	10 0f       	add	r17, r16
 266:	11 bf       	out	0x31, r17	; 49
        x = usbMeasureFrameLength();    /* proportional to current real frequency */
 268:	b4 d1       	rcall	.+872    	; 0x5d2 <usbMeasureFrameLength>
 26a:	ec 01       	movw	r28, r24
        if(x < targetValue)             /* frequency still too low */
 26c:	89 e0       	ldi	r24, 0x09	; 9
 26e:	c4 33       	cpi	r28, 0x34	; 52
 270:	d8 07       	cpc	r29, r24
 272:	0c f0       	brlt	.+2      	; 0x276 <usbEventResetReady+0x2c>
 274:	10 2f       	mov	r17, r16
            trialValue += step;
        step >>= 1;
 276:	d6 94       	lsr	r13
 278:	08 94       	sec
 27a:	e1 1c       	adc	r14, r1
 27c:	f1 1c       	adc	r15, r1
    }while(step > 0);
 27e:	88 e0       	ldi	r24, 0x08	; 8
 280:	e8 16       	cp	r14, r24
 282:	f1 04       	cpc	r15, r1
 284:	11 f0       	breq	.+4      	; 0x28a <usbEventResetReady+0x40>
 286:	01 2f       	mov	r16, r17
 288:	ec cf       	rjmp	.-40     	; 0x262 <usbEventResetReady+0x18>
    /* We have a precision of +/- 1 for optimum OSCCAL here */
    /* now do a neighborhood search for optimum value */
    optimumValue = trialValue;
    optimumDev = x; /* this is certainly far away from optimum */
    for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
 28a:	11 50       	subi	r17, 0x01	; 1
 28c:	11 bf       	out	0x31, r17	; 49
 28e:	1f 5f       	subi	r17, 0xFF	; 255
 290:	e1 2e       	mov	r14, r17
 292:	ff 24       	eor	r15, r15
 294:	08 94       	sec
 296:	e1 1c       	adc	r14, r1
 298:	f1 1c       	adc	r15, r1
 29a:	13 c0       	rjmp	.+38     	; 0x2c2 <usbEventResetReady+0x78>
        x = usbMeasureFrameLength() - targetValue;
 29c:	9a d1       	rcall	.+820    	; 0x5d2 <usbMeasureFrameLength>
 29e:	9c 01       	movw	r18, r24
 2a0:	24 53       	subi	r18, 0x34	; 52
 2a2:	39 40       	sbci	r19, 0x09	; 9
 2a4:	37 ff       	sbrs	r19, 7
 2a6:	03 c0       	rjmp	.+6      	; 0x2ae <usbEventResetReady+0x64>
 2a8:	30 95       	com	r19
 2aa:	21 95       	neg	r18
 2ac:	3f 4f       	sbci	r19, 0xFF	; 255
        if(x < 0)
            x = -x;
        if(x < optimumDev){
 2ae:	2c 17       	cp	r18, r28
 2b0:	3d 07       	cpc	r19, r29
 2b2:	14 f0       	brlt	.+4      	; 0x2b8 <usbEventResetReady+0x6e>
 2b4:	9e 01       	movw	r18, r28
 2b6:	01 c0       	rjmp	.+2      	; 0x2ba <usbEventResetReady+0x70>
            optimumDev = x;
            optimumValue = OSCCAL;
 2b8:	11 b7       	in	r17, 0x31	; 49
    }while(step > 0);
    /* We have a precision of +/- 1 for optimum OSCCAL here */
    /* now do a neighborhood search for optimum value */
    optimumValue = trialValue;
    optimumDev = x; /* this is certainly far away from optimum */
    for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
 2ba:	81 b7       	in	r24, 0x31	; 49
 2bc:	8f 5f       	subi	r24, 0xFF	; 255
 2be:	81 bf       	out	0x31, r24	; 49
 2c0:	e9 01       	movw	r28, r18
 2c2:	81 b7       	in	r24, 0x31	; 49
 2c4:	90 e0       	ldi	r25, 0x00	; 0
 2c6:	e8 16       	cp	r14, r24
 2c8:	f9 06       	cpc	r15, r25
 2ca:	44 f7       	brge	.-48     	; 0x29c <usbEventResetReady+0x52>
        if(x < optimumDev){
            optimumDev = x;
            optimumValue = OSCCAL;
        }
    }
    OSCCAL = optimumValue;
 2cc:	11 bf       	out	0x31, r17	; 49
*/

void    usbEventResetReady(void)
{
    calibrateOscillator();
    eeprom_write_byte(0, OSCCAL);   /* store the calibrated value in EEPROM */
 2ce:	81 b7       	in	r24, 0x31	; 49
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 2d0:	e1 99       	sbic	0x1c, 1	; 28
 2d2:	fe cf       	rjmp	.-4      	; 0x2d0 <usbEventResetReady+0x86>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 2d4:	1c ba       	out	0x1c, r1	; 28
#elif	defined(EEPM0) || defined(EEPM1)
# warning "Unknown EECR register, eeprom_write_byte() has become outdated."
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
 2d6:	1e ba       	out	0x1e, r1	; 30
#else
    EEAR = (size_t)__p;
#endif
    EEDR = __value;
 2d8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
 2da:	0f b6       	in	r0, 0x3f	; 63
 2dc:	f8 94       	cli
 2de:	e2 9a       	sbi	0x1c, 2	; 28
 2e0:	e1 9a       	sbi	0x1c, 1	; 28
 2e2:	0f be       	out	0x3f, r0	; 63
}
 2e4:	df 91       	pop	r29
 2e6:	cf 91       	pop	r28
 2e8:	1f 91       	pop	r17
 2ea:	0f 91       	pop	r16
 2ec:	ff 90       	pop	r15
 2ee:	ef 90       	pop	r14
 2f0:	df 90       	pop	r13
 2f2:	08 95       	ret

000002f4 <usbInit>:
/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbInit(void)
{
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
 2f4:	85 b7       	in	r24, 0x35	; 53
 2f6:	83 60       	ori	r24, 0x03	; 3
 2f8:	85 bf       	out	0x35, r24	; 53
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 2fa:	8b b7       	in	r24, 0x3b	; 59
 2fc:	80 64       	ori	r24, 0x40	; 64
 2fe:	8b bf       	out	0x3b, r24	; 59
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 300:	83 ec       	ldi	r24, 0xC3	; 195
 302:	80 93 79 00 	sts	0x0079, r24
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    usbResetDataToggling();
}
 306:	08 95       	ret

00000308 <usbSetInterrupt>:

/* ------------------------------------------------------------------------- */

#if USB_CFG_HAVE_INTRIN_ENDPOINT
USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
 308:	1f 93       	push	r17
 30a:	dc 01       	movw	r26, r24
 30c:	16 2f       	mov	r17, r22
#endif
#if 0   /* No runtime checks! Caller is responsible for valid data! */
    if(len > 8) /* interrupt transfers are limited to 8 bytes */
        len = 8;
#endif
    if(usbTxLen1 & 0x10){   /* packet buffer was empty */
 30e:	80 91 62 00 	lds	r24, 0x0062
 312:	84 ff       	sbrs	r24, 4
 314:	0a c0       	rjmp	.+20     	; 0x32a <usbSetInterrupt+0x22>
        usbTxBuf1[0] ^= USBPID_DATA0 ^ USBPID_DATA1;    /* toggle token */
 316:	80 91 79 00 	lds	r24, 0x0079
 31a:	98 e8       	ldi	r25, 0x88	; 136
 31c:	89 27       	eor	r24, r25
 31e:	80 93 79 00 	sts	0x0079, r24
 322:	91 2f       	mov	r25, r17
 324:	ea e7       	ldi	r30, 0x7A	; 122
 326:	f0 e0       	ldi	r31, 0x00	; 0
 328:	07 c0       	rjmp	.+14     	; 0x338 <usbSetInterrupt+0x30>
    }else{
        usbTxLen1 = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 32a:	8a e5       	ldi	r24, 0x5A	; 90
 32c:	80 93 62 00 	sts	0x0062, r24
 330:	f8 cf       	rjmp	.-16     	; 0x322 <usbSetInterrupt+0x1a>
    }
    p = usbTxBuf1 + 1;
    for(i=len;i--;)
        *p++ = *data++;
 332:	8d 91       	ld	r24, X+
 334:	81 93       	st	Z+, r24
 336:	91 50       	subi	r25, 0x01	; 1
        usbTxBuf1[0] ^= USBPID_DATA0 ^ USBPID_DATA1;    /* toggle token */
    }else{
        usbTxLen1 = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    }
    p = usbTxBuf1 + 1;
    for(i=len;i--;)
 338:	99 23       	and	r25, r25
 33a:	d9 f7       	brne	.-10     	; 0x332 <usbSetInterrupt+0x2a>
        *p++ = *data++;
    usbCrc16Append(&usbTxBuf1[1], len);
 33c:	8a e7       	ldi	r24, 0x7A	; 122
 33e:	90 e0       	ldi	r25, 0x00	; 0
 340:	61 2f       	mov	r22, r17
 342:	43 d1       	rcall	.+646    	; 0x5ca <usbCrc16Append>
    usbTxLen1 = len + 4;    /* len must be given including sync byte */
 344:	1c 5f       	subi	r17, 0xFC	; 252
 346:	10 93 62 00 	sts	0x0062, r17
    DBG2(0x21, usbTxBuf1, len + 3);
}
 34a:	1f 91       	pop	r17
 34c:	08 95       	ret

0000034e <usbPoll>:
}

/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbPoll(void)
{
 34e:	0f 93       	push	r16
 350:	1f 93       	push	r17
 352:	cf 93       	push	r28
 354:	df 93       	push	r29
schar   len;
uchar   i;

    if((len = usbRxLen) > 0){
 356:	90 91 89 00 	lds	r25, 0x0089
 35a:	19 16       	cp	r1, r25
 35c:	0c f0       	brlt	.+2      	; 0x360 <usbPoll+0x12>
 35e:	b7 c0       	rjmp	.+366    	; 0x4ce <usbPoll+0x180>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len - 3);
 360:	20 91 86 00 	lds	r18, 0x0086
    if(usbRxToken < 0x10){  /* endpoint number in usbRxToken */
        usbFunctionWriteOut(data, len);
        return; /* no reply expected, hence no usbMsgPtr, usbMsgFlags, usbMsgLen set */
    }
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
 364:	80 91 85 00 	lds	r24, 0x0085
 368:	8d 32       	cpi	r24, 0x2D	; 45
 36a:	09 f0       	breq	.+2      	; 0x36e <usbPoll+0x20>
 36c:	a6 c0       	rjmp	.+332    	; 0x4ba <usbPoll+0x16c>
        usbTxLen = USBPID_NAK;  /* abort pending transmit */
 36e:	8a e5       	ldi	r24, 0x5A	; 90
 370:	80 93 61 00 	sts	0x0061, r24
        if(len == 8){   /* Setup size must be always 8 bytes. Ignore otherwise. */
 374:	9b 30       	cpi	r25, 0x0B	; 11
 376:	09 f0       	breq	.+2      	; 0x37a <usbPoll+0x2c>
 378:	a0 c0       	rjmp	.+320    	; 0x4ba <usbPoll+0x16c>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len - 3);
 37a:	cc e0       	ldi	r28, 0x0C	; 12
 37c:	d0 e0       	ldi	r29, 0x00	; 0
 37e:	c2 1b       	sub	r28, r18
 380:	d1 09       	sbc	r29, r1
 382:	c3 57       	subi	r28, 0x73	; 115
 384:	df 4f       	sbci	r29, 0xFF	; 255
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
        usbTxLen = USBPID_NAK;  /* abort pending transmit */
        if(len == 8){   /* Setup size must be always 8 bytes. Ignore otherwise. */
            uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
            if(type == USBRQ_TYPE_STANDARD){
 386:	88 81       	ld	r24, Y
 388:	80 76       	andi	r24, 0x60	; 96
 38a:	09 f0       	breq	.+2      	; 0x38e <usbPoll+0x40>
 38c:	88 c0       	rjmp	.+272    	; 0x49e <usbPoll+0x150>
                #define SET_REPLY_LEN(len)  replyLen = (len); usbMsgPtr = replyData
                /* This macro ensures that replyLen and usbMsgPtr are always set in the same way.
                 * That allows optimization of common code in if() branches */
                uchar *replyData = usbTxBuf + 9; /* there is 3 bytes free space at the end of the buffer */
                replyData[0] = 0;   /* common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 38e:	10 92 77 00 	sts	0x0077, r1
                if(rq->bRequest == USBRQ_GET_STATUS){           /* 0 */
 392:	89 81       	ldd	r24, Y+1	; 0x01
 394:	88 23       	and	r24, r24
 396:	59 f4       	brne	.+22     	; 0x3ae <usbPoll+0x60>
#endif
#if USB_CFG_HAVE_INTRIN_ENDPOINT && USB_CFG_IMPLEMENT_HALT
                    if(recipient == USBRQ_RCPT_ENDPOINT && rq->wIndex.bytes[0] == 0x81)   /* request status for endpoint 1 */
                        replyData[0] = usbTxLen1 == USBPID_STALL;
#endif
                    replyData[1] = 0;
 398:	10 92 78 00 	sts	0x0078, r1
                    SET_REPLY_LEN(2);
 39c:	87 e7       	ldi	r24, 0x77	; 119
 39e:	90 e0       	ldi	r25, 0x00	; 0
 3a0:	90 93 88 00 	sts	0x0088, r25
 3a4:	80 93 87 00 	sts	0x0087, r24
 3a8:	90 e8       	ldi	r25, 0x80	; 128
 3aa:	22 e0       	ldi	r18, 0x02	; 2
 3ac:	7f c0       	rjmp	.+254    	; 0x4ac <usbPoll+0x15e>
                }else if(rq->bRequest == USBRQ_SET_ADDRESS){    /* 5 */
 3ae:	85 30       	cpi	r24, 0x05	; 5
 3b0:	21 f4       	brne	.+8      	; 0x3ba <usbPoll+0x6c>
                    usbNewDeviceAddr = rq->wValue.bytes[0];
 3b2:	8a 81       	ldd	r24, Y+2	; 0x02
 3b4:	80 93 8a 00 	sts	0x008A, r24
 3b8:	70 c0       	rjmp	.+224    	; 0x49a <usbPoll+0x14c>
#ifdef USB_SET_ADDRESS_HOOK
                    USB_SET_ADDRESS_HOOK();
#endif
                }else if(rq->bRequest == USBRQ_GET_DESCRIPTOR){ /* 6 */
 3ba:	86 30       	cpi	r24, 0x06	; 6
 3bc:	09 f0       	breq	.+2      	; 0x3c0 <usbPoll+0x72>
 3be:	52 c0       	rjmp	.+164    	; 0x464 <usbPoll+0x116>
                    flags = USB_FLG_MSGPTR_IS_ROM | USB_FLG_USE_DEFAULT_RW;
                    if(rq->wValue.bytes[1] == USBDESCR_DEVICE){ /* 1 */
 3c0:	8b 81       	ldd	r24, Y+3	; 0x03
 3c2:	81 30       	cpi	r24, 0x01	; 1
 3c4:	49 f4       	brne	.+18     	; 0x3d8 <usbPoll+0x8a>
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 3c6:	8b e7       	ldi	r24, 0x7B	; 123
 3c8:	90 e0       	ldi	r25, 0x00	; 0
 3ca:	90 93 88 00 	sts	0x0088, r25
 3ce:	80 93 87 00 	sts	0x0087, r24
 3d2:	90 ec       	ldi	r25, 0xC0	; 192
 3d4:	22 e1       	ldi	r18, 0x12	; 18
 3d6:	6a c0       	rjmp	.+212    	; 0x4ac <usbPoll+0x15e>
                    }else if(rq->wValue.bytes[1] == USBDESCR_CONFIG){   /* 2 */
 3d8:	82 30       	cpi	r24, 0x02	; 2
 3da:	49 f4       	brne	.+18     	; 0x3ee <usbPoll+0xa0>
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 3dc:	8d e8       	ldi	r24, 0x8D	; 141
 3de:	90 e0       	ldi	r25, 0x00	; 0
 3e0:	90 93 88 00 	sts	0x0088, r25
 3e4:	80 93 87 00 	sts	0x0087, r24
 3e8:	90 ec       	ldi	r25, 0xC0	; 192
 3ea:	22 e2       	ldi	r18, 0x22	; 34
 3ec:	5f c0       	rjmp	.+190    	; 0x4ac <usbPoll+0x15e>
                    }else if(rq->wValue.bytes[1] == USBDESCR_STRING){   /* 3 */
 3ee:	83 30       	cpi	r24, 0x03	; 3
 3f0:	19 f5       	brne	.+70     	; 0x438 <usbPoll+0xea>
#if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
                        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
                            flags &= ~USB_FLG_MSGPTR_IS_ROM;
                        replyLen = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
                        if(rq->wValue.bytes[0] == 0){   /* descriptor index */
 3f2:	8a 81       	ldd	r24, Y+2	; 0x02
 3f4:	88 23       	and	r24, r24
 3f6:	49 f4       	brne	.+18     	; 0x40a <usbPoll+0xbc>
                            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 3f8:	81 e4       	ldi	r24, 0x41	; 65
 3fa:	90 e0       	ldi	r25, 0x00	; 0
 3fc:	90 93 88 00 	sts	0x0088, r25
 400:	80 93 87 00 	sts	0x0087, r24
 404:	90 ec       	ldi	r25, 0xC0	; 192
 406:	24 e0       	ldi	r18, 0x04	; 4
 408:	51 c0       	rjmp	.+162    	; 0x4ac <usbPoll+0x15e>
                        }else if(rq->wValue.bytes[0] == 1){
 40a:	81 30       	cpi	r24, 0x01	; 1
 40c:	49 f4       	brne	.+18     	; 0x420 <usbPoll+0xd2>
                            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 40e:	85 e4       	ldi	r24, 0x45	; 69
 410:	90 e0       	ldi	r25, 0x00	; 0
 412:	90 93 88 00 	sts	0x0088, r25
 416:	80 93 87 00 	sts	0x0087, r24
 41a:	90 ec       	ldi	r25, 0xC0	; 192
 41c:	28 e1       	ldi	r18, 0x18	; 24
 41e:	46 c0       	rjmp	.+140    	; 0x4ac <usbPoll+0x15e>
                        }else if(rq->wValue.bytes[0] == 2){
 420:	82 30       	cpi	r24, 0x02	; 2
 422:	09 f0       	breq	.+2      	; 0x426 <usbPoll+0xd8>
 424:	41 c0       	rjmp	.+130    	; 0x4a8 <usbPoll+0x15a>
                            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 426:	8d e5       	ldi	r24, 0x5D	; 93
 428:	90 e0       	ldi	r25, 0x00	; 0
 42a:	90 93 88 00 	sts	0x0088, r25
 42e:	80 93 87 00 	sts	0x0087, r24
 432:	90 ec       	ldi	r25, 0xC0	; 192
 434:	2e e1       	ldi	r18, 0x1E	; 30
 436:	3a c0       	rjmp	.+116    	; 0x4ac <usbPoll+0x15e>
                        }else if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
                            replyLen = usbFunctionDescriptor(rq);
                        }
#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
                    }else if(rq->wValue.bytes[1] == USBDESCR_HID){          /* 0x21 */
 438:	81 32       	cpi	r24, 0x21	; 33
 43a:	49 f4       	brne	.+18     	; 0x44e <usbPoll+0x100>
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 43c:	8f e9       	ldi	r24, 0x9F	; 159
 43e:	90 e0       	ldi	r25, 0x00	; 0
 440:	90 93 88 00 	sts	0x0088, r25
 444:	80 93 87 00 	sts	0x0087, r24
 448:	90 ec       	ldi	r25, 0xC0	; 192
 44a:	29 e0       	ldi	r18, 0x09	; 9
 44c:	2f c0       	rjmp	.+94     	; 0x4ac <usbPoll+0x15e>
                    }else if(rq->wValue.bytes[1] == USBDESCR_HID_REPORT){   /* 0x22 */
 44e:	82 32       	cpi	r24, 0x22	; 34
 450:	59 f5       	brne	.+86     	; 0x4a8 <usbPoll+0x15a>
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 452:	8e e1       	ldi	r24, 0x1E	; 30
 454:	90 e0       	ldi	r25, 0x00	; 0
 456:	90 93 88 00 	sts	0x0088, r25
 45a:	80 93 87 00 	sts	0x0087, r24
 45e:	90 ec       	ldi	r25, 0xC0	; 192
 460:	23 e2       	ldi	r18, 0x23	; 35
 462:	24 c0       	rjmp	.+72     	; 0x4ac <usbPoll+0x15e>
#endif  /* USB_CFG_DESCR_PROPS_HID_REPORT */
                    }else if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
                        replyLen = usbFunctionDescriptor(rq);
                    }
                }else if(rq->bRequest == USBRQ_GET_CONFIGURATION){  /* 8 */
 464:	88 30       	cpi	r24, 0x08	; 8
 466:	19 f4       	brne	.+6      	; 0x46e <usbPoll+0x120>
                    replyData = &usbConfiguration;  /* send current configuration value */
                    SET_REPLY_LEN(1);
 468:	8c e8       	ldi	r24, 0x8C	; 140
 46a:	90 e0       	ldi	r25, 0x00	; 0
 46c:	0a c0       	rjmp	.+20     	; 0x482 <usbPoll+0x134>
                }else if(rq->bRequest == USBRQ_SET_CONFIGURATION){  /* 9 */
 46e:	89 30       	cpi	r24, 0x09	; 9
 470:	21 f4       	brne	.+8      	; 0x47a <usbPoll+0x12c>
                    usbConfiguration = rq->wValue.bytes[0];
 472:	8a 81       	ldd	r24, Y+2	; 0x02
 474:	80 93 8c 00 	sts	0x008C, r24
 478:	10 c0       	rjmp	.+32     	; 0x49a <usbPoll+0x14c>
                    usbResetStall();
                }else if(rq->bRequest == USBRQ_GET_INTERFACE){      /* 10 */
 47a:	8a 30       	cpi	r24, 0x0A	; 10
 47c:	49 f4       	brne	.+18     	; 0x490 <usbPoll+0x142>
                    SET_REPLY_LEN(1);
 47e:	87 e7       	ldi	r24, 0x77	; 119
 480:	90 e0       	ldi	r25, 0x00	; 0
 482:	90 93 88 00 	sts	0x0088, r25
 486:	80 93 87 00 	sts	0x0087, r24
 48a:	90 e8       	ldi	r25, 0x80	; 128
 48c:	21 e0       	ldi	r18, 0x01	; 1
 48e:	0e c0       	rjmp	.+28     	; 0x4ac <usbPoll+0x15e>
#if USB_CFG_HAVE_INTRIN_ENDPOINT
                }else if(rq->bRequest == USBRQ_SET_INTERFACE){      /* 11 */
 490:	8b 30       	cpi	r24, 0x0B	; 11
 492:	19 f4       	brne	.+6      	; 0x49a <usbPoll+0x14c>
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 494:	83 ec       	ldi	r24, 0xC3	; 195
 496:	80 93 79 00 	sts	0x0079, r24
 49a:	90 e8       	ldi	r25, 0x80	; 128
 49c:	06 c0       	rjmp	.+12     	; 0x4aa <usbPoll+0x15c>
                    /* 1: CLEAR_FEATURE, 3: SET_FEATURE, 7: SET_DESCRIPTOR */
                    /* 12: SYNCH_FRAME */
                }
                #undef SET_REPLY_LEN
            }else{  /* not a standard request -- must be vendor or class request */
                replyLen = usbFunctionSetup(data);
 49e:	ce 01       	movw	r24, r28
 4a0:	23 de       	rcall	.-954    	; 0xe8 <usbFunctionSetup>
 4a2:	28 2f       	mov	r18, r24
 4a4:	90 e8       	ldi	r25, 0x80	; 128
 4a6:	02 c0       	rjmp	.+4      	; 0x4ac <usbPoll+0x15e>
 4a8:	90 ec       	ldi	r25, 0xC0	; 192
 4aa:	20 e0       	ldi	r18, 0x00	; 0
                    replyLen = rq->wLength.bytes[0];    /* IN transfers only */
                }
                flags &= ~USB_FLG_USE_DEFAULT_RW;  /* we have no valid msg, use user supplied read/write functions */
            }else   /* The 'else' prevents that we limit a replyLen of 0xff to the maximum transfer len. */
#endif
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])  /* limit length to max */
 4ac:	8f 81       	ldd	r24, Y+7	; 0x07
 4ae:	88 23       	and	r24, r24
 4b0:	39 f4       	brne	.+14     	; 0x4c0 <usbPoll+0x172>
 4b2:	8e 81       	ldd	r24, Y+6	; 0x06
 4b4:	82 17       	cp	r24, r18
 4b6:	28 f0       	brcs	.+10     	; 0x4c2 <usbPoll+0x174>
 4b8:	03 c0       	rjmp	.+6      	; 0x4c0 <usbPoll+0x172>
 4ba:	90 e8       	ldi	r25, 0x80	; 128
 4bc:	80 e0       	ldi	r24, 0x00	; 0
 4be:	01 c0       	rjmp	.+2      	; 0x4c2 <usbPoll+0x174>
 4c0:	82 2f       	mov	r24, r18
            }
            flags = 0;    /* start with a DATA1 package, stay with user supplied write() function */
        }
#endif
    }
    usbMsgFlags = flags;
 4c2:	90 93 6d 00 	sts	0x006D, r25
    usbMsgLen = replyLen;
 4c6:	80 93 60 00 	sts	0x0060, r24
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len - 3);
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;       /* mark rx buffer as available */
 4ca:	10 92 89 00 	sts	0x0089, r1
#endif
    }
    if(usbTxLen & 0x10){ /* transmit system idle */
 4ce:	80 91 61 00 	lds	r24, 0x0061
 4d2:	84 ff       	sbrs	r24, 4
 4d4:	49 c0       	rjmp	.+146    	; 0x568 <usbPoll+0x21a>
        if(usbMsgLen != 0xff){  /* transmit data pending? */
 4d6:	80 91 60 00 	lds	r24, 0x0060
 4da:	8f 3f       	cpi	r24, 0xFF	; 255
 4dc:	09 f4       	brne	.+2      	; 0x4e0 <usbPoll+0x192>
 4de:	44 c0       	rjmp	.+136    	; 0x568 <usbPoll+0x21a>
 4e0:	18 2f       	mov	r17, r24
 4e2:	89 30       	cpi	r24, 0x09	; 9
 4e4:	08 f0       	brcs	.+2      	; 0x4e8 <usbPoll+0x19a>
 4e6:	18 e0       	ldi	r17, 0x08	; 8
uchar   wantLen, len, txLen, token;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
 4e8:	81 1b       	sub	r24, r17
 4ea:	80 93 60 00 	sts	0x0060, r24
    token = USBPID_DATA1;
    if(usbMsgFlags & USB_FLG_TX_PACKET)
 4ee:	80 91 6d 00 	lds	r24, 0x006D
 4f2:	80 fd       	sbrc	r24, 0
 4f4:	02 c0       	rjmp	.+4      	; 0x4fa <usbPoll+0x1ac>
 4f6:	0b e4       	ldi	r16, 0x4B	; 75
 4f8:	01 c0       	rjmp	.+2      	; 0x4fc <usbPoll+0x1ae>
 4fa:	03 ec       	ldi	r16, 0xC3	; 195
        token = USBPID_DATA0;
    usbMsgFlags++;
 4fc:	8f 5f       	subi	r24, 0xFF	; 255
 4fe:	80 93 6d 00 	sts	0x006D, r24
static uchar usbRead(uchar *data, uchar len)
{
#if USB_CFG_IMPLEMENT_FN_READ
    if(usbMsgFlags & USB_FLG_USE_DEFAULT_RW){
#endif
        uchar i = len, *r = usbMsgPtr;
 502:	20 91 87 00 	lds	r18, 0x0087
 506:	30 91 88 00 	lds	r19, 0x0088
        if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 50a:	86 fd       	sbrc	r24, 6
 50c:	05 c0       	rjmp	.+10     	; 0x518 <usbPoll+0x1ca>
 50e:	d9 01       	movw	r26, r18
 510:	91 2f       	mov	r25, r17
 512:	ef e6       	ldi	r30, 0x6F	; 111
 514:	f0 e0       	ldi	r31, 0x00	; 0
 516:	11 c0       	rjmp	.+34     	; 0x53a <usbPoll+0x1ec>
 518:	af e6       	ldi	r26, 0x6F	; 111
 51a:	b0 e0       	ldi	r27, 0x00	; 0
 51c:	80 e0       	ldi	r24, 0x00	; 0
 51e:	90 e0       	ldi	r25, 0x00	; 0
 520:	06 c0       	rjmp	.+12     	; 0x52e <usbPoll+0x1e0>
            while(i--){
                uchar c = PRG_RDB(r);    /* assign to char size variable to enforce byte ops */
 522:	f9 01       	movw	r30, r18
 524:	e8 0f       	add	r30, r24
 526:	f9 1f       	adc	r31, r25
 528:	e4 91       	lpm	r30, Z+
                *data++ = c;
 52a:	ed 93       	st	X+, r30
 52c:	01 96       	adiw	r24, 0x01	; 1
#if USB_CFG_IMPLEMENT_FN_READ
    if(usbMsgFlags & USB_FLG_USE_DEFAULT_RW){
#endif
        uchar i = len, *r = usbMsgPtr;
        if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
            while(i--){
 52e:	18 17       	cp	r17, r24
 530:	c1 f7       	brne	.-16     	; 0x522 <usbPoll+0x1d4>
 532:	05 c0       	rjmp	.+10     	; 0x53e <usbPoll+0x1f0>
                *data++ = c;
                r++;
            }
        }else{                  /* RAM data */
            while(i--)
                *data++ = *r++;
 534:	8d 91       	ld	r24, X+
 536:	81 93       	st	Z+, r24
 538:	91 50       	subi	r25, 0x01	; 1
                uchar c = PRG_RDB(r);    /* assign to char size variable to enforce byte ops */
                *data++ = c;
                r++;
            }
        }else{                  /* RAM data */
            while(i--)
 53a:	99 23       	and	r25, r25
 53c:	d9 f7       	brne	.-10     	; 0x534 <usbPoll+0x1e6>
 53e:	f9 01       	movw	r30, r18
 540:	e1 0f       	add	r30, r17
 542:	f1 1d       	adc	r31, r1
                *data++ = *r++;
        }
        usbMsgPtr = r;
 544:	f0 93 88 00 	sts	0x0088, r31
 548:	e0 93 87 00 	sts	0x0087, r30
    if(usbMsgFlags & USB_FLG_TX_PACKET)
        token = USBPID_DATA0;
    usbMsgFlags++;
    len = usbRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
 54c:	8f e6       	ldi	r24, 0x6F	; 111
 54e:	90 e0       	ldi	r25, 0x00	; 0
 550:	61 2f       	mov	r22, r17
 552:	3b d0       	rcall	.+118    	; 0x5ca <usbCrc16Append>
        txLen = len + 4;    /* length including sync byte */
        if(len < 8)         /* a partial package identifies end of message */
 554:	18 30       	cpi	r17, 0x08	; 8
 556:	19 f0       	breq	.+6      	; 0x55e <usbPoll+0x210>
            usbMsgLen = 0xff;
 558:	8f ef       	ldi	r24, 0xFF	; 255
 55a:	80 93 60 00 	sts	0x0060, r24
    }else{
        txLen = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = 0xff;
    }
    usbTxBuf[0] = token;
 55e:	00 93 6e 00 	sts	0x006E, r16
        token = USBPID_DATA0;
    usbMsgFlags++;
    len = usbRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
        txLen = len + 4;    /* length including sync byte */
 562:	1c 5f       	subi	r17, 0xFC	; 252
    }else{
        txLen = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = 0xff;
    }
    usbTxBuf[0] = token;
    usbTxLen = txLen;
 564:	10 93 61 00 	sts	0x0061, r17
 568:	9a e0       	ldi	r25, 0x0A	; 10
/* We want to do
 *     return (USBIN & USBMASK);
 * here, but the compiler does int-expansion acrobatics.
 * We can avoid this by assigning to a char-sized variable.
 */
    rval = USBIN & USBMASK;
 56a:	86 b3       	in	r24, 0x16	; 22
        if(usbMsgLen != 0xff){  /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 10; i > 0; i--){
        if(isNotSE0())
 56c:	85 70       	andi	r24, 0x05	; 5
 56e:	31 f4       	brne	.+12     	; 0x57c <usbPoll+0x22e>
    if(usbTxLen & 0x10){ /* transmit system idle */
        if(usbMsgLen != 0xff){  /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 10; i > 0; i--){
 570:	91 50       	subi	r25, 0x01	; 1
 572:	d9 f7       	brne	.-10     	; 0x56a <usbPoll+0x21c>
        if(isNotSE0())
            break;
    }
    if(i == 0){ /* RESET condition, called multiple times during reset */
        usbNewDeviceAddr = 0;
 574:	10 92 8a 00 	sts	0x008A, r1
        usbDeviceAddr = 0;
 578:	10 92 84 00 	sts	0x0084, r1

static inline void usbHandleResetHook(uchar notResetState)
{
#ifdef USB_RESET_HOOK
static uchar    wasReset;
uchar           isReset = !notResetState;
 57c:	10 e0       	ldi	r17, 0x00	; 0
 57e:	99 23       	and	r25, r25
 580:	09 f4       	brne	.+2      	; 0x584 <usbPoll+0x236>
 582:	11 e0       	ldi	r17, 0x01	; 1

    if(wasReset != isReset){
 584:	80 91 6c 00 	lds	r24, 0x006C
 588:	81 17       	cp	r24, r17
 58a:	29 f0       	breq	.+10     	; 0x596 <usbPoll+0x248>
        USB_RESET_HOOK(isReset);
 58c:	11 23       	and	r17, r17
 58e:	09 f4       	brne	.+2      	; 0x592 <usbPoll+0x244>
 590:	5c de       	rcall	.-840    	; 0x24a <usbEventResetReady>
        wasReset = isReset;
 592:	10 93 6c 00 	sts	0x006C, r17
        usbDeviceAddr = 0;
        usbResetStall();
        DBG1(0xff, 0, 0);
    }
    usbHandleResetHook(i);
}
 596:	df 91       	pop	r29
 598:	cf 91       	pop	r28
 59a:	1f 91       	pop	r17
 59c:	0f 91       	pop	r16
 59e:	08 95       	ret

000005a0 <usbCrc16>:
 5a0:	a8 2f       	mov	r26, r24
 5a2:	b9 2f       	mov	r27, r25
 5a4:	80 e0       	ldi	r24, 0x00	; 0
 5a6:	90 e0       	ldi	r25, 0x00	; 0
 5a8:	41 e0       	ldi	r20, 0x01	; 1
 5aa:	50 ea       	ldi	r21, 0xA0	; 160
 5ac:	60 95       	com	r22

000005ae <crcByteLoop>:
 5ae:	6f 5f       	subi	r22, 0xFF	; 255
 5b0:	58 f4       	brcc	.+22     	; 0x5c8 <crcReady>
 5b2:	2d 91       	ld	r18, X+
 5b4:	38 ef       	ldi	r19, 0xF8	; 248
 5b6:	82 27       	eor	r24, r18

000005b8 <crcBitLoop>:
 5b8:	97 95       	ror	r25
 5ba:	87 95       	ror	r24
 5bc:	10 f0       	brcs	.+4      	; 0x5c2 <crcNoXor>
 5be:	84 27       	eor	r24, r20
 5c0:	95 27       	eor	r25, r21

000005c2 <crcNoXor>:
 5c2:	3f 5f       	subi	r19, 0xFF	; 255
 5c4:	c8 f3       	brcs	.-14     	; 0x5b8 <crcBitLoop>
 5c6:	f3 cf       	rjmp	.-26     	; 0x5ae <crcByteLoop>

000005c8 <crcReady>:
 5c8:	08 95       	ret

000005ca <usbCrc16Append>:
 5ca:	ea df       	rcall	.-44     	; 0x5a0 <usbCrc16>
 5cc:	8d 93       	st	X+, r24
 5ce:	9d 93       	st	X+, r25
 5d0:	08 95       	ret

000005d2 <usbMeasureFrameLength>:
 5d2:	a6 e0       	ldi	r26, 0x06	; 6
 5d4:	88 27       	eor	r24, r24
 5d6:	99 27       	eor	r25, r25

000005d8 <usbMFTime16>:
 5d8:	aa 95       	dec	r26
 5da:	69 f0       	breq	.+26     	; 0x5f6 <usbMFTimeout>

000005dc <usbMFWaitStrobe>:
 5dc:	01 97       	sbiw	r24, 0x01	; 1
 5de:	e1 f3       	breq	.-8      	; 0x5d8 <usbMFTime16>
 5e0:	b0 99       	sbic	0x16, 0	; 22
 5e2:	fc cf       	rjmp	.-8      	; 0x5dc <usbMFWaitStrobe>

000005e4 <usbMFWaitIdle>:
 5e4:	b0 9b       	sbis	0x16, 0	; 22
 5e6:	fe cf       	rjmp	.-4      	; 0x5e4 <usbMFWaitIdle>
 5e8:	81 e0       	ldi	r24, 0x01	; 1
 5ea:	99 27       	eor	r25, r25

000005ec <usbMFWaitLoop>:
 5ec:	a6 b3       	in	r26, 0x16	; 22
 5ee:	01 96       	adiw	r24, 0x01	; 1
 5f0:	11 f0       	breq	.+4      	; 0x5f6 <usbMFTimeout>
 5f2:	a5 70       	andi	r26, 0x05	; 5
 5f4:	d9 f7       	brne	.-10     	; 0x5ec <usbMFWaitLoop>

000005f6 <usbMFTimeout>:
 5f6:	08 95       	ret

000005f8 <__vector_1>:
 5f8:	cf 93       	push	r28
 5fa:	cf b7       	in	r28, 0x3f	; 63
 5fc:	cf 93       	push	r28

000005fe <waitForJ>:
 5fe:	b0 9b       	sbis	0x16, 0	; 22
 600:	fe cf       	rjmp	.-4      	; 0x5fe <waitForJ>

00000602 <waitForK>:
 602:	b0 9b       	sbis	0x16, 0	; 22
 604:	0b c0       	rjmp	.+22     	; 0x61c <foundK>
 606:	b0 9b       	sbis	0x16, 0	; 22
 608:	09 c0       	rjmp	.+18     	; 0x61c <foundK>
 60a:	b0 9b       	sbis	0x16, 0	; 22
 60c:	07 c0       	rjmp	.+14     	; 0x61c <foundK>
 60e:	b0 9b       	sbis	0x16, 0	; 22
 610:	05 c0       	rjmp	.+10     	; 0x61c <foundK>
 612:	b0 9b       	sbis	0x16, 0	; 22
 614:	03 c0       	rjmp	.+6      	; 0x61c <foundK>
 616:	b0 9b       	sbis	0x16, 0	; 22
 618:	01 c0       	rjmp	.+2      	; 0x61c <foundK>
 61a:	d5 c0       	rjmp	.+426    	; 0x7c6 <sofError>

0000061c <foundK>:
 61c:	0f 92       	push	r0
 61e:	df 93       	push	r29
 620:	c0 91 86 00 	lds	r28, 0x0086
 624:	dd 27       	eor	r29, r29
 626:	c3 57       	subi	r28, 0x73	; 115
 628:	df 4f       	sbci	r29, 0xFF	; 255
 62a:	01 2e       	mov	r0, r17
 62c:	b0 9b       	sbis	0x16, 0	; 22
 62e:	03 c0       	rjmp	.+6      	; 0x636 <haveTwoBitsK>
 630:	df 91       	pop	r29
 632:	0f 90       	pop	r0
 634:	e6 cf       	rjmp	.-52     	; 0x602 <waitForK>

00000636 <haveTwoBitsK>:
 636:	2f 93       	push	r18
 638:	0f 93       	push	r16
 63a:	1f 93       	push	r17
 63c:	4f 93       	push	r20
 63e:	2f ef       	ldi	r18, 0xFF	; 255
 640:	4f 6f       	ori	r20, 0xFF	; 255
 642:	06 b3       	in	r16, 0x16	; 22
 644:	00 fb       	bst	r16, 0
 646:	20 f9       	bld	r18, 0
 648:	5f 93       	push	r21
 64a:	3f 93       	push	r19
 64c:	50 e0       	ldi	r21, 0x00	; 0
 64e:	3b e0       	ldi	r19, 0x0B	; 11
 650:	65 c0       	rjmp	.+202    	; 0x71c <rxbit1>

00000652 <continueWithBit5>:
 652:	16 b3       	in	r17, 0x16	; 22
 654:	01 26       	eor	r0, r17
 656:	50 29       	or	r21, r0
 658:	50 fd       	sbrc	r21, 0
 65a:	c8 95       	lpm
 65c:	56 b3       	in	r21, 0x16	; 22
 65e:	01 27       	eor	r16, r17
 660:	00 fb       	bst	r16, 0
 662:	25 f9       	bld	r18, 5
 664:	2f 73       	andi	r18, 0x3F	; 63
 666:	06 b3       	in	r16, 0x16	; 22
 668:	b1 f0       	breq	.+44     	; 0x696 <unstuff5>
 66a:	50 27       	eor	r21, r16
 66c:	10 27       	eor	r17, r16
 66e:	10 fb       	bst	r17, 0
 670:	26 f9       	bld	r18, 6

00000672 <didUnstuff6>:
 672:	06 b2       	in	r0, 0x16	; 22
 674:	22 30       	cpi	r18, 0x02	; 2
 676:	f0 f0       	brcs	.+60     	; 0x6b4 <unstuff6>

00000678 <didUnstuff5>:
 678:	00 c0       	rjmp	.+0      	; 0x67a <didUnstuff5+0x2>
 67a:	16 b3       	in	r17, 0x16	; 22
 67c:	01 27       	eor	r16, r17
 67e:	00 fb       	bst	r16, 0
 680:	27 f9       	bld	r18, 7

00000682 <didUnstuff7>:
 682:	01 26       	eor	r0, r17
 684:	50 29       	or	r21, r0
 686:	06 b2       	in	r0, 0x16	; 22
 688:	24 30       	cpi	r18, 0x04	; 4
 68a:	e8 f5       	brcc	.+122    	; 0x706 <rxLoop>

0000068c <unstuff7>:
 68c:	4f 77       	andi	r20, 0x7F	; 127
 68e:	20 68       	ori	r18, 0x80	; 128
 690:	16 b3       	in	r17, 0x16	; 22
 692:	00 00       	nop
 694:	f6 cf       	rjmp	.-20     	; 0x682 <didUnstuff7>

00000696 <unstuff5>:
 696:	50 27       	eor	r21, r16
 698:	4f 7d       	andi	r20, 0xDF	; 223
 69a:	20 62       	ori	r18, 0x20	; 32
 69c:	06 b2       	in	r0, 0x16	; 22
 69e:	10 2f       	mov	r17, r16
 6a0:	00 00       	nop
 6a2:	00 c0       	rjmp	.+0      	; 0x6a4 <unstuff5+0xe>
 6a4:	06 b3       	in	r16, 0x16	; 22
 6a6:	00 26       	eor	r0, r16
 6a8:	50 29       	or	r21, r0
 6aa:	10 27       	eor	r17, r16
 6ac:	10 fb       	bst	r17, 0
 6ae:	26 f9       	bld	r18, 6
 6b0:	06 b2       	in	r0, 0x16	; 22
 6b2:	e2 cf       	rjmp	.-60     	; 0x678 <didUnstuff5>

000006b4 <unstuff6>:
 6b4:	4f 7b       	andi	r20, 0xBF	; 191
 6b6:	06 b3       	in	r16, 0x16	; 22
 6b8:	20 64       	ori	r18, 0x40	; 64
 6ba:	00 c0       	rjmp	.+0      	; 0x6bc <unstuff6+0x8>
 6bc:	da cf       	rjmp	.-76     	; 0x672 <didUnstuff6>

000006be <unstuff0>:
 6be:	01 26       	eor	r0, r17
 6c0:	50 29       	or	r21, r0
 6c2:	15 70       	andi	r17, 0x05	; 5
 6c4:	06 b2       	in	r0, 0x16	; 22
 6c6:	69 f1       	breq	.+90     	; 0x722 <didUnstuff0>
 6c8:	4e 7f       	andi	r20, 0xFE	; 254
 6ca:	21 60       	ori	r18, 0x01	; 1
 6cc:	01 2f       	mov	r16, r17
 6ce:	16 b3       	in	r17, 0x16	; 22
 6d0:	28 c0       	rjmp	.+80     	; 0x722 <didUnstuff0>

000006d2 <unstuff1>:
 6d2:	00 26       	eor	r0, r16
 6d4:	50 29       	or	r21, r0
 6d6:	4d 7f       	andi	r20, 0xFD	; 253
 6d8:	06 b2       	in	r0, 0x16	; 22
 6da:	22 60       	ori	r18, 0x02	; 2
 6dc:	10 2f       	mov	r17, r16
 6de:	29 c0       	rjmp	.+82     	; 0x732 <didUnstuff1>

000006e0 <unstuff2>:
 6e0:	01 26       	eor	r0, r17
 6e2:	50 29       	or	r21, r0
 6e4:	4b 7f       	andi	r20, 0xFB	; 251
 6e6:	06 b2       	in	r0, 0x16	; 22
 6e8:	24 60       	ori	r18, 0x04	; 4
 6ea:	01 2f       	mov	r16, r17
 6ec:	2d c0       	rjmp	.+90     	; 0x748 <didUnstuff2>

000006ee <unstuff3>:
 6ee:	16 b3       	in	r17, 0x16	; 22
 6f0:	01 26       	eor	r0, r17
 6f2:	50 29       	or	r21, r0
 6f4:	47 7f       	andi	r20, 0xF7	; 247
 6f6:	28 60       	ori	r18, 0x08	; 8
 6f8:	00 00       	nop
 6fa:	06 b2       	in	r0, 0x16	; 22
 6fc:	2e c0       	rjmp	.+92     	; 0x75a <didUnstuff3>

000006fe <unstuff4>:
 6fe:	4f 7e       	andi	r20, 0xEF	; 239
 700:	06 b3       	in	r16, 0x16	; 22
 702:	20 61       	ori	r18, 0x10	; 16
 704:	30 c0       	rjmp	.+96     	; 0x766 <didUnstuff4>

00000706 <rxLoop>:
 706:	42 27       	eor	r20, r18
 708:	06 b3       	in	r16, 0x16	; 22
 70a:	49 93       	st	Y+, r20
 70c:	00 26       	eor	r0, r16
 70e:	50 29       	or	r21, r0
 710:	10 27       	eor	r17, r16
 712:	06 b2       	in	r0, 0x16	; 22
 714:	4f ef       	ldi	r20, 0xFF	; 255
 716:	10 fb       	bst	r17, 0
 718:	20 f9       	bld	r18, 0
 71a:	29 7f       	andi	r18, 0xF9	; 249

0000071c <rxbit1>:
 71c:	16 b3       	in	r17, 0x16	; 22
 71e:	79 f2       	breq	.-98     	; 0x6be <unstuff0>
 720:	15 70       	andi	r17, 0x05	; 5

00000722 <didUnstuff0>:
 722:	59 f1       	breq	.+86     	; 0x77a <se0>
 724:	01 26       	eor	r0, r17
 726:	50 29       	or	r21, r0
 728:	06 b2       	in	r0, 0x16	; 22
 72a:	01 27       	eor	r16, r17
 72c:	00 fb       	bst	r16, 0
 72e:	21 f9       	bld	r18, 1
 730:	23 7f       	andi	r18, 0xF3	; 243

00000732 <didUnstuff1>:
 732:	06 b3       	in	r16, 0x16	; 22
 734:	71 f2       	breq	.-100    	; 0x6d2 <unstuff1>
 736:	00 26       	eor	r0, r16
 738:	50 29       	or	r21, r0
 73a:	31 50       	subi	r19, 0x01	; 1
 73c:	d0 f0       	brcs	.+52     	; 0x772 <overflow>
 73e:	06 b2       	in	r0, 0x16	; 22
 740:	10 27       	eor	r17, r16
 742:	10 fb       	bst	r17, 0
 744:	22 f9       	bld	r18, 2
 746:	27 7e       	andi	r18, 0xE7	; 231

00000748 <didUnstuff2>:
 748:	16 b3       	in	r17, 0x16	; 22
 74a:	51 f2       	breq	.-108    	; 0x6e0 <unstuff2>
 74c:	01 26       	eor	r0, r17
 74e:	50 29       	or	r21, r0
 750:	01 27       	eor	r16, r17
 752:	00 fb       	bst	r16, 0
 754:	06 b2       	in	r0, 0x16	; 22
 756:	23 f9       	bld	r18, 3
 758:	2f 7c       	andi	r18, 0xCF	; 207

0000075a <didUnstuff3>:
 75a:	49 f2       	breq	.-110    	; 0x6ee <unstuff3>
 75c:	00 00       	nop
 75e:	06 b3       	in	r16, 0x16	; 22
 760:	10 27       	eor	r17, r16
 762:	10 fb       	bst	r17, 0
 764:	24 f9       	bld	r18, 4

00000766 <didUnstuff4>:
 766:	00 26       	eor	r0, r16
 768:	50 29       	or	r21, r0
 76a:	06 b2       	in	r0, 0x16	; 22
 76c:	2f 79       	andi	r18, 0x9F	; 159
 76e:	39 f2       	breq	.-114    	; 0x6fe <unstuff4>
 770:	70 cf       	rjmp	.-288    	; 0x652 <continueWithBit5>

00000772 <overflow>:
 772:	10 e4       	ldi	r17, 0x40	; 64
 774:	1a bf       	out	0x3a, r17	; 58

00000776 <ignorePacket>:
 776:	00 27       	eor	r16, r16
 778:	19 c0       	rjmp	.+50     	; 0x7ac <handleSetupOrOut>

0000077a <se0>:
 77a:	3b 50       	subi	r19, 0x0B	; 11
 77c:	31 95       	neg	r19
 77e:	c3 1b       	sub	r28, r19
 780:	d0 40       	sbci	r29, 0x00	; 0
 782:	10 e4       	ldi	r17, 0x40	; 64
 784:	1a bf       	out	0x3a, r17	; 58
 786:	08 81       	ld	r16, Y
 788:	03 3c       	cpi	r16, 0xC3	; 195
 78a:	09 f1       	breq	.+66     	; 0x7ce <handleData>
 78c:	0b 34       	cpi	r16, 0x4B	; 75
 78e:	f9 f0       	breq	.+62     	; 0x7ce <handleData>
 790:	20 91 84 00 	lds	r18, 0x0084
 794:	19 81       	ldd	r17, Y+1	; 0x01
 796:	11 0f       	add	r17, r17
 798:	12 13       	cpse	r17, r18
 79a:	ed cf       	rjmp	.-38     	; 0x776 <ignorePacket>
 79c:	4a 81       	ldd	r20, Y+2	; 0x02
 79e:	44 1f       	adc	r20, r20
 7a0:	09 36       	cpi	r16, 0x69	; 105
 7a2:	51 f1       	breq	.+84     	; 0x7f8 <handleIn>
 7a4:	0d 32       	cpi	r16, 0x2D	; 45
 7a6:	11 f0       	breq	.+4      	; 0x7ac <handleSetupOrOut>
 7a8:	01 3e       	cpi	r16, 0xE1	; 225
 7aa:	29 f7       	brne	.-54     	; 0x776 <ignorePacket>

000007ac <handleSetupOrOut>:
 7ac:	00 93 8b 00 	sts	0x008B, r16

000007b0 <doReturn>:
 7b0:	3f 91       	pop	r19
 7b2:	5f 91       	pop	r21
 7b4:	4f 91       	pop	r20
 7b6:	1f 91       	pop	r17
 7b8:	0f 91       	pop	r16
 7ba:	2f 91       	pop	r18
 7bc:	df 91       	pop	r29
 7be:	0f 90       	pop	r0
 7c0:	ca b7       	in	r28, 0x3a	; 58
 7c2:	c6 fd       	sbrc	r28, 6
 7c4:	1c cf       	rjmp	.-456    	; 0x5fe <waitForJ>

000007c6 <sofError>:
 7c6:	cf 91       	pop	r28
 7c8:	cf bf       	out	0x3f, r28	; 63
 7ca:	cf 91       	pop	r28
 7cc:	18 95       	reti

000007ce <handleData>:
 7ce:	00 91 8b 00 	lds	r16, 0x008B
 7d2:	00 23       	and	r16, r16
 7d4:	69 f3       	breq	.-38     	; 0x7b0 <doReturn>
 7d6:	10 91 89 00 	lds	r17, 0x0089
 7da:	11 23       	and	r17, r17
 7dc:	79 f5       	brne	.+94     	; 0x83c <sendNakAndReti>
 7de:	34 30       	cpi	r19, 0x04	; 4
 7e0:	7a f1       	brmi	.+94     	; 0x840 <sendAckAndReti>
 7e2:	30 93 89 00 	sts	0x0089, r19
 7e6:	00 93 85 00 	sts	0x0085, r16
 7ea:	10 91 86 00 	lds	r17, 0x0086
 7ee:	3b e0       	ldi	r19, 0x0B	; 11
 7f0:	31 1b       	sub	r19, r17
 7f2:	30 93 86 00 	sts	0x0086, r19
 7f6:	24 c0       	rjmp	.+72     	; 0x840 <sendAckAndReti>

000007f8 <handleIn>:
 7f8:	00 91 89 00 	lds	r16, 0x0089
 7fc:	01 30       	cpi	r16, 0x01	; 1
 7fe:	f4 f4       	brge	.+60     	; 0x83c <sendNakAndReti>
 800:	0a e5       	ldi	r16, 0x5A	; 90
 802:	4f 70       	andi	r20, 0x0F	; 15
 804:	49 f4       	brne	.+18     	; 0x818 <handleIn1>
 806:	30 91 61 00 	lds	r19, 0x0061
 80a:	34 fd       	sbrc	r19, 4
 80c:	1a c0       	rjmp	.+52     	; 0x842 <sendCntAndReti>
 80e:	00 93 61 00 	sts	0x0061, r16
 812:	ce e6       	ldi	r28, 0x6E	; 110
 814:	d0 e0       	ldi	r29, 0x00	; 0
 816:	19 c0       	rjmp	.+50     	; 0x84a <usbSendAndReti>

00000818 <handleIn1>:
 818:	30 91 62 00 	lds	r19, 0x0062
 81c:	34 fd       	sbrc	r19, 4
 81e:	11 c0       	rjmp	.+34     	; 0x842 <sendCntAndReti>
 820:	00 93 62 00 	sts	0x0062, r16
 824:	c9 e7       	ldi	r28, 0x79	; 121
 826:	d0 e0       	ldi	r29, 0x00	; 0
 828:	10 c0       	rjmp	.+32     	; 0x84a <usbSendAndReti>

0000082a <bitstuff7>:
 82a:	05 27       	eor	r16, r21
 82c:	10 e0       	ldi	r17, 0x00	; 0
 82e:	00 c0       	rjmp	.+0      	; 0x830 <bitstuff7+0x6>
 830:	21 c0       	rjmp	.+66     	; 0x874 <didStuff7>

00000832 <bitstuffN>:
 832:	05 27       	eor	r16, r21
 834:	10 e0       	ldi	r17, 0x00	; 0
 836:	c8 95       	lpm
 838:	08 bb       	out	0x18, r16	; 24
 83a:	14 c0       	rjmp	.+40     	; 0x864 <didStuffN>

0000083c <sendNakAndReti>:
 83c:	3a e5       	ldi	r19, 0x5A	; 90
 83e:	01 c0       	rjmp	.+2      	; 0x842 <sendCntAndReti>

00000840 <sendAckAndReti>:
 840:	32 ed       	ldi	r19, 0xD2	; 210

00000842 <sendCntAndReti>:
 842:	03 2e       	mov	r0, r19
 844:	c0 e0       	ldi	r28, 0x00	; 0
 846:	d0 e0       	ldi	r29, 0x00	; 0
 848:	32 e0       	ldi	r19, 0x02	; 2

0000084a <usbSendAndReti>:
 84a:	17 b3       	in	r17, 0x17	; 23
 84c:	15 60       	ori	r17, 0x05	; 5
 84e:	c0 9a       	sbi	0x18, 0	; 24
 850:	08 b3       	in	r16, 0x18	; 24
 852:	17 bb       	out	0x17, r17	; 23
 854:	55 e0       	ldi	r21, 0x05	; 5
 856:	20 e8       	ldi	r18, 0x80	; 128
 858:	4f ef       	ldi	r20, 0xFF	; 255

0000085a <bitloop>:
 85a:	20 ff       	sbrs	r18, 0
 85c:	05 27       	eor	r16, r21
 85e:	08 bb       	out	0x18, r16	; 24
 860:	27 95       	ror	r18
 862:	17 95       	ror	r17

00000864 <didStuffN>:
 864:	1c 3f       	cpi	r17, 0xFC	; 252
 866:	28 f7       	brcc	.-54     	; 0x832 <bitstuffN>
 868:	00 00       	nop
 86a:	45 52       	subi	r20, 0x25	; 37
 86c:	b0 f7       	brcc	.-20     	; 0x85a <bitloop>
 86e:	20 ff       	sbrs	r18, 0
 870:	05 27       	eor	r16, r21
 872:	27 95       	ror	r18

00000874 <didStuff7>:
 874:	08 bb       	out	0x18, r16	; 24
 876:	17 95       	ror	r17
 878:	1c 3f       	cpi	r17, 0xFC	; 252
 87a:	b8 f6       	brcc	.-82     	; 0x82a <bitstuff7>
 87c:	29 91       	ld	r18, Y+
 87e:	3a 95       	dec	r19
 880:	61 f7       	brne	.-40     	; 0x85a <bitloop>
 882:	0a 7f       	andi	r16, 0xFA	; 250
 884:	10 91 8a 00 	lds	r17, 0x008A
 888:	11 0f       	add	r17, r17
 88a:	08 bb       	out	0x18, r16	; 24
 88c:	c2 50       	subi	r28, 0x02	; 2
 88e:	d0 40       	sbci	r29, 0x00	; 0
 890:	11 f0       	breq	.+4      	; 0x896 <skipAddrAssign>
 892:	10 93 84 00 	sts	0x0084, r17

00000896 <skipAddrAssign>:
 896:	10 e4       	ldi	r17, 0x40	; 64
 898:	1a bf       	out	0x3a, r17	; 58
 89a:	01 60       	ori	r16, 0x01	; 1
 89c:	17 b3       	in	r17, 0x17	; 23
 89e:	1a 7f       	andi	r17, 0xFA	; 250
 8a0:	40 2f       	mov	r20, r16
 8a2:	4a 7f       	andi	r20, 0xFA	; 250
 8a4:	54 e0       	ldi	r21, 0x04	; 4

000008a6 <se0Delay>:
 8a6:	5a 95       	dec	r21
 8a8:	f1 f7       	brne	.-4      	; 0x8a6 <se0Delay>
 8aa:	08 bb       	out	0x18, r16	; 24
 8ac:	17 bb       	out	0x17, r17	; 23
 8ae:	48 bb       	out	0x18, r20	; 24
 8b0:	7f cf       	rjmp	.-258    	; 0x7b0 <doReturn>

000008b2 <_exit>:
 8b2:	f8 94       	cli

000008b4 <__stop_program>:
 8b4:	ff cf       	rjmp	.-2      	; 0x8b4 <__stop_program>
