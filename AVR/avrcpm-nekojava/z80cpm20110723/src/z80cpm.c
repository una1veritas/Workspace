/*----------------------------------------------------------------------*/
/* CP/M system on Z80CPU and AVR                           2011.7.11    */
/*                                for mega644P Fuse L:H:X = E6:D1:FF    */
/*                                                                      */
/*                                                      (C)neko Java    */
/*----------------------------------------------------------------------*/


#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <avr/eeprom.h>
#include "uart.h"
#include "diskio.h"
#include "z80cpm.h"


/*---------------------------------------------------------*/
/* global variables                                        */
/*---------------------------------------------------------*/

BYTE Block_buff[BLOCK_SIZE];	/* SDC block buffer */

volatile BYTE DMA_mode;		/* READ or WRITE or result */
volatile BYTE Adrl;
volatile BYTE Adrh;
volatile WORD Adr;
volatile BYTE Sect_no;
volatile BYTE Track_no_l;
volatile BYTE Track_no_h;
volatile WORD Track_no;
volatile DWORD Block_no;
volatile DWORD Pre_block_no;
volatile DWORD Sdc_clst_no;
volatile BYTE Buff_offset;

volatile BYTE F_unwritten;
volatile DWORD Pre_sdc_clst_no;
volatile WORD Write_back_timer;

volatile DSTATUS St;

volatile WORD Timer;		/* 100Hz increment timer */


/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/

ISR(TIMER2_COMPA_vect)
{
	Timer++;		/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */

}


/*---------------------------------------------------------*/

void IoInit ()
{
	PORTA = 0xFF;		 //ProtA :address bus
	DDRA  = 0;

	PORTB = 0b00000110;	 //PortB :Z80 control pins
	DDRB  = 0b00000111;

	PORTC = 0xFF;		 //ProtC :data bus
	DDRC  = 0;

	PORTD = 0b01111100;	 //PortD :Z80 control pins, address high byte latch
	DDRD  = 0b10000010;

	uart_init();		// Initialize UART driver

	cli();

	OCR2A = 195-1;		// Timer2: 100Hz interval (OC2), 195-1 at 20MHz
	TCCR2A = 2;		// CTC compA Mode
	TCCR2B = 7;		// 1/1024
	TIMSK2 = 0b00000010;	// Enable TC2.oc, interrupt

	/*------------------------------------------------------------------
	PCICR = _BV(PCIE3);	// pin change interrupt. PCINT24-31 enable.
	PCMSK3 = _BV(PCINT29) | _BV(PCINT30);	// IOREQ, BUSAK check.
	-------------------------------------------------------------------*/

}


/*---------------------------------------------------------*/

void nop_wait(WORD count)
{
	WORD i;
	for(i=0; i<count; i++){
		asm volatile("nop");
	}
}


void adr_set(WORD adr)
{
	BYTE high, low;
	high = (BYTE)(adr >> 8);
	low = (BYTE)(adr & 0x00FF);
	PORTA = high;
	CK_L(); asm volatile("nop"); asm volatile("nop");
	CK_H(); asm volatile("nop");
	PORTA = low;
	return;
}


void write_byte(WORD adr, BYTE dat)
{
	adr_set(adr);
	PORTC = dat;
	asm volatile("nop"); asm volatile("nop"); asm volatile("nop");
	WR_L(); asm volatile("nop"); asm volatile("nop"); asm volatile("nop");
	WR_H(); asm volatile("nop"); asm volatile("nop"); asm volatile("nop");
	return;
}


BYTE read_byte(WORD adr)
{
	BYTE dat;
	adr_set(adr);
	RD_L(); asm volatile("nop"); asm volatile("nop"); asm volatile("nop");
	dat = PINC;
	RD_H(); asm volatile("nop"); asm volatile("nop"); asm volatile("nop");
	return dat;
}


void ram_write(WORD adr, WORD size, BYTE *buff, BYTE offset)	// AVR buffer -> Z80 RAM
{
	WORD i;

	D_BUS_OUT();
	for(i=0; i<size; i++){
		write_byte(adr+i, buff[i+offset*SECT_SIZE]);
	}
	D_BUS_IN();

}


void ram_read(WORD adr, WORD size, BYTE *buff, BYTE offset)	// AVR buffer <- Z80 RAM
{
	WORD i;

	for(i=0; i<size; i++){
		buff[i+offset*SECT_SIZE] = read_byte(adr+i);
	}
}


void var_calc() // recalculation global variables 
{
	DWORD cpm_clst_no = 0;

	Adr = ((WORD)Adrh << 8) + (WORD)Adrl;

	Track_no_h = 0;
	Track_no = ((WORD)Track_no_h << 8) + (WORD)Track_no_l;

	Pre_block_no = Block_no;
	Pre_sdc_clst_no = Sdc_clst_no;

	cpm_clst_no = (DWORD)(Sect_no + Track_no * SECT_CNT);	//CPMの128バイト単位で見たクラスタNo.
	Block_no = cpm_clst_no / CPM_CLST_CNT_PER_BLOCK;	//SDCの書込単位でのブロックNo.
	Buff_offset = cpm_clst_no % CPM_CLST_CNT_PER_BLOCK;	// 0〜7(1ブロック1024バイト、1セクタ128バイトの場合)

	Sdc_clst_no = Block_no * SDC_CLST_CNT_PER_BLOCK;	//SDCのクラスタNo.(1クラスタ512バイト)
}


void sdc_write(){	// Z80 RAM -> AVR buffer -> SDC
	DRESULT rs;
	var_calc();
	if(Block_no != Pre_block_no){	//ブロックを移動した場合
		if(F_unwritten){	//未書込みの場合まず前のブロックをSDCへ書込んでから
			rs = disk_write (0, Block_buff, Pre_sdc_clst_no, SDC_CLST_CNT_PER_BLOCK);
			if(rs != RES_OK){
				DMA_mode = DMA_NG;
				St = STA_NOINIT;
				return;
			}
		}
		rs = disk_read (0, Block_buff, Sdc_clst_no, SDC_CLST_CNT_PER_BLOCK);	//SDCからバッファへ読込み
		if(rs != RES_OK){
			DMA_mode = DMA_NG;
			St = STA_NOINIT;
			return;
		}
	}
	ram_read(Adr, SECT_SIZE, Block_buff, Buff_offset);
	DMA_mode = DMA_OK;
	F_unwritten = 1;	//未書込みフラグをたてる
	Write_back_timer = 0;	//タイマをリセット
}


void sdc_read(){	// Z80 RAM <- AVR buffer <- SDC
	DRESULT rs;
	var_calc();
	if(Block_no != Pre_block_no){	//ブロックを移動した場合
		if(F_unwritten){	//未書込みの場合まず前のブロックをSDCへ書込んでから
			rs = disk_write (0, Block_buff, Pre_sdc_clst_no, SDC_CLST_CNT_PER_BLOCK);
			if(rs != RES_OK){
				DMA_mode = DMA_NG;
				St = STA_NOINIT;
				return;
			}
			F_unwritten = 0;	//未書込みフラグをおろす
		}
		rs = disk_read (0, Block_buff, Sdc_clst_no, SDC_CLST_CNT_PER_BLOCK);	//SDCからバッファへ読込み
		if(rs != RES_OK){
			DMA_mode = DMA_NG;
			St = STA_NOINIT;
			return;
		}
	}
	ram_write(Adr, SECT_SIZE, Block_buff, Buff_offset);
	DMA_mode = DMA_OK;
}


void rom_load(){	// AVR EEPROM -> Z80 RAM (for Z80 MONITOR program)

	BYTE count, i;
	WORD size;

	if(EEPROM_SIZE >= BLOCK_SIZE){
		count = EEPROM_SIZE/BLOCK_SIZE;
		size = BLOCK_SIZE;
	}else{
		count = 1;
		size = EEPROM_SIZE;
	}
	for(i=0; i<count; i++){
		eeprom_busy_wait();
		eeprom_read_block(Block_buff, (void *)(i*size), size); 
		eeprom_busy_wait();
		ram_write(i*size, size, Block_buff, 0);
	}
	Block_no = 0xFFFF; //ROMのプログラムがSDCを読む場合に備えて適当にずらしておく
	Sdc_clst_no = Block_no * SDC_CLST_CNT_PER_BLOCK;
	F_unwritten = 0;
}


void reset_proc(){	// SDC first sector -> Z80 RAM and reset

	DRESULT rs;

	AD_BUS_OUT();
	WR_H(); RD_H();
	RW_OUT(); asm volatile("nop");

	Block_no = 0;
	Sdc_clst_no = 0;
	Track_no_h= 0;
	F_unwritten = 0;

	sei();

	St = disk_initialize (0);

	if(St & STA_NOINIT){	// SDC読込みに失敗した場合はEEPROMからモニタプログラムをロードする
		rom_load();
	}else{
		rs = disk_read (0, Block_buff, Block_no, SDC_CLST_CNT_PER_BLOCK);	// get boot loader from SDC
		if(rs==RES_OK){
			ram_write(0x2000, SECT_SIZE, Block_buff, 0); // set boot loader to Z80 RAM
			Block_buff[0]=0xC3;	// jump vector set.
			Block_buff[1]=0x00;
			Block_buff[2]=0x20;
			ram_write(0, 3, Block_buff, 0);
		}else{
			rom_load();
		}

	}

	cli();

	RW_IN();
	AD_BUS_IN(); asm volatile("nop");

}


void write_back(){	//ライトバック
	DRESULT rs;

	rs = disk_write (0, Block_buff, Sdc_clst_no, SDC_CLST_CNT_PER_BLOCK);
	if(rs != RES_OK){
		DMA_mode = DMA_NG;
		St = STA_NOINIT;
		return;
	}
	DMA_mode = DMA_OK;
	F_unwritten = 0;	//未書込みフラグをおろす
	Write_back_timer = 0;	//タイマをリセット
}


/*---------------------------------------------------------*/
/* when received IOREQ or BUSAK signal from Z80            */
/*---------------------------------------------------------*/

/*-------------------------
ISR(PCINT3_vect)
{
	
}
--------------------------*/


void busak_proc()
{
	AD_BUS_OUT();
	WR_H(); RD_H();
	RW_OUT(); asm volatile("nop");

	if(DMA_mode == DMA_WRITE_BACK){
		write_back();
	}
	if(DMA_mode == DMA_WRITE){
		sdc_write();
	}
	if(DMA_mode == DMA_READ){
		sdc_read();
	}

	RW_IN();
	AD_BUS_IN(); asm volatile("nop");
}


void ioreq_proc()
{
	BYTE port_adr;

	port_adr = PINA;

	if(RD()==0 && WR()!=0){		// AVR port -> Z80
		D_BUS_OUT();
		switch (port_adr) {
		case CON_STS:
			if(uart_test()){
				PORTC = 0xFF;	// data exist
			}else{
				PORTC = 0;	// no data
			}
			break;
		case CON_IN:
			PORTC = uart_get();
			break;
		case DMA_RS:
			PORTC = DMA_mode;	// set DMA result
		}
	}
	if(WR()==0 && RD()!=0){		// AVR port <- Z80
		switch (port_adr) {
		case CON_OUT:
			uart_put(PINC);
			break;
		case TRACK_SEL_L:
			Track_no_l = PINC;
			break;
		case TRACK_SEL_H:
			Track_no_h = PINC;
			break;
		case SECTOR_SEL:
			Sect_no = PINC;
			break;
		case ADR_L:
			Adrl = PINC;
			break;
		case ADR_H:
			Adrh = PINC;
			break;
		case EXEC_DMA:
			DMA_mode = PINC;	// get read or write command
			if(St & STA_NOINIT){
				sei();
				St = disk_initialize (0);
				cli();
				if(St & STA_NOINIT){
					DMA_mode = DMA_NG;
					break;
				}
			}
			BUSRQ_L();		// DMA request
		}
	}
}


/*-----------------------------------------------------------------------*/
/* Main                                                                  */
/*-----------------------------------------------------------------------*/

int main (void)
{

	IoInit();
	WAIT_L();

	nop_wait(10);
	reset_proc(); 	// store boot-loader to Z80 RAM.
	RESET_H();	// Z80 start!

	for(;;){
		while(BUSAK()!=0 && IOREQ()!=0); // watching H to L edges
		if(IOREQ()==0){
			while(RD()!=0 && WR()!=0);
			ioreq_proc();
			WAIT_H();
			while(RD()==0);
			D_BUS_IN();
			while(IOREQ()==0);
			WAIT_L();
		}
		if(BUSAK()==0){
			sei();
			busak_proc();
			cli();
			BUSRQ_H();	// DMA end.
			while(BUSAK()==0);
		}
		if(DMA_mode != DMA_WRITE_BACK){
			if(F_unwritten){
				Write_back_timer++;
				if(Write_back_timer > 100){
					DMA_mode = DMA_WRITE_BACK;
					BUSRQ_L();
				}
			}
		}
	}
}
