###############################################################################
#                                                                             #
#                                                       19/Sep/2012  16:16:05 #
# IAR ANSI C/C++ Compiler V6.40.2.33884/W32 KICKSTART for ARM                 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32F4xx_StdPeriph_Driver #
#                    \src\stm32f4xx_dma.c                                     #
#    Command line =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32F4xx_StdPeriph_Driver #
#                    \src\stm32f4xx_dma.c -D USE_STDPERIPH_DRIVER -D          #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_USB_OTG_FS -lcN    #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\ -o                         #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\ --debug --endian=little     #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.4           #
#                    Kickstart\arm\INC\c\DLib_Config_Full.h" -I               #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM3 #
#                    2_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples #
#                    \DFU\EWARM\..\inc\ -I \\psf\Home\Documents\Eclipse\Works #
#                    pace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_De #
#                    vice_Examples\DFU\EWARM\..\..\..\..\Libraries\CMSIS\Devi #
#                    ce\ST\STM32F4xx\Include\ -I                              #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\  #
#                    -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB- #
#                    Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\E #
#                    WARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\in #
#                    c\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_U #
#                    SB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DF #
#                    U\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\C #
#                    lass\dfu\inc\ -I \\psf\Home\Documents\Eclipse\Workspace\ #
#                    ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_ #
#                    Examples\DFU\EWARM\..\..\..\..\Utilities\STM32_EVAL\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\Common\ -I            #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\    #
#                    -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.4                           #
#                    Kickstart\arm\CMSIS\Include\"                            #
#    List file    =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\stm32f4xx_dma.lst           #
#    Object file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\stm32f4xx_dma.o              #
#                                                                             #
#                                                                             #
###############################################################################

\\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_dma.c
      4            * @author  MCD Application Team
      5            * @version V1.0.2
      6            * @date    05-March-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Direct Memory Access controller (DMA):           
      9            *           - Initialization and Configuration
     10            *           - Data Counter
     11            *           - Double Buffer mode configuration and command  
     12            *           - Interrupts and flags management
     13            *           
     14            *  @verbatim
     15            *      
     16            *          ===================================================================      
     17            *                                 How to use this driver
     18            *          =================================================================== 
     19            *          1. Enable The DMA controller clock using RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA1, ENABLE)
     20            *             function for DMA1 or using RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA2, ENABLE)
     21            *             function for DMA2.
     22            *
     23            *          2. Enable and configure the peripheral to be connected to the DMA Stream
     24            *             (except for internal SRAM / FLASH memories: no initialization is 
     25            *             necessary). 
     26            *        
     27            *          3. For a given Stream, program the required configuration through following parameters:   
     28            *             Source and Destination addresses, Transfer Direction, Transfer size, Source and Destination 
     29            *             data formats, Circular or Normal mode, Stream Priority level, Source and Destination 
     30            *             Incrementation mode, FIFO mode and its Threshold (if needed), Burst mode for Source and/or 
     31            *             Destination (if needed) using the DMA_Init() function.
     32            *             To avoid filling un-nesecessary fields, you can call DMA_StructInit() function
     33            *             to initialize a given structure with default values (reset values), the modify
     34            *             only necessary fields (ie. Source and Destination addresses, Transfer size and Data Formats).
     35            *
     36            *          4. Enable the NVIC and the corresponding interrupt(s) using the function 
     37            *             DMA_ITConfig() if you need to use DMA interrupts. 
     38            *
     39            *          5. Optionally, if the Circular mode is enabled, you can use the Double buffer mode by configuring 
     40            *             the second Memory address and the first Memory to be used through the function 
     41            *             DMA_DoubleBufferModeConfig(). Then enable the Double buffer mode through the function
     42            *             DMA_DoubleBufferModeCmd(). These operations must be done before step 6.
     43            *    
     44            *          6. Enable the DMA stream using the DMA_Cmd() function. 
     45            *                
     46            *          7. Activate the needed Stream Request using PPP_DMACmd() function for
     47            *             any PPP peripheral except internal SRAM and FLASH (ie. SPI, USART ...)
     48            *             The function allowing this operation is provided in each PPP peripheral
     49            *             driver (ie. SPI_DMACmd for SPI peripheral).
     50            *             Once the Stream is enabled, it is not possible to modify its configuration
     51            *             unless the stream is stopped and disabled.
     52            *             After enabling the Stream, it is advised to monitor the EN bit status using
     53            *             the function DMA_GetCmdStatus(). In case of configuration errors or bus errors
     54            *             this bit will remain reset and all transfers on this Stream will remain on hold.      
     55            *
     56            *          8. Optionally, you can configure the number of data to be transferred
     57            *             when the Stream is disabled (ie. after each Transfer Complete event
     58            *             or when a Transfer Error occurs) using the function DMA_SetCurrDataCounter().
     59            *             And you can get the number of remaining data to be transferred using 
     60            *             the function DMA_GetCurrDataCounter() at run time (when the DMA Stream is
     61            *             enabled and running).  
     62            *                   
     63            *          9. To control DMA events you can use one of the following 
     64            *              two methods:
     65            *               a- Check on DMA Stream flags using the function DMA_GetFlagStatus().  
     66            *               b- Use DMA interrupts through the function DMA_ITConfig() at initialization
     67            *                  phase and DMA_GetITStatus() function into interrupt routines in
     68            *                  communication phase.  
     69            *              After checking on a flag you should clear it using DMA_ClearFlag()
     70            *              function. And after checking on an interrupt event you should 
     71            *              clear it using DMA_ClearITPendingBit() function.    
     72            *              
     73            *          10. Optionally, if Circular mode and Double Buffer mode are enabled, you can modify
     74            *              the Memory Addresses using the function DMA_MemoryTargetConfig(). Make sure that
     75            *              the Memory Address to be modified is not the one currently in use by DMA Stream.
     76            *              This condition can be monitored using the function DMA_GetCurrentMemoryTarget().
     77            *              
     78            *          11. Optionally, Pause-Resume operations may be performed:
     79            *              The DMA_Cmd() function may be used to perform Pause-Resume operation. When a 
     80            *              transfer is ongoing, calling this function to disable the Stream will cause the 
     81            *              transfer to be paused. All configuration registers and the number of remaining 
     82            *              data will be preserved. When calling again this function to re-enable the Stream, 
     83            *              the transfer will be resumed from the point where it was paused.          
     84            *                 
     85            * @note   Memory-to-Memory transfer is possible by setting the address of the memory into
     86            *         the Peripheral registers. In this mode, Circular mode and Double Buffer mode
     87            *         are not allowed.
     88            *  
     89            * @note   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is
     90            *         possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set
     91            *         Half-Word data size for the peripheral to access its data register and set Word data size
     92            *         for the Memory to gain in access time. Each two Half-words will be packed and written in
     93            *         a single access to a Word in the Memory).
     94            *    
     95            * @note  When FIFO is disabled, it is not allowed to configure different Data Sizes for Source
     96            *        and Destination. In this case the Peripheral Data Size will be applied to both Source
     97            *        and Destination.               
     98            *
     99            *  @endverbatim
    100            *                                  
    101            ******************************************************************************
    102            * @attention
    103            *
    104            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
    105            *
    106            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    107            * You may not use this file except in compliance with the License.
    108            * You may obtain a copy of the License at:
    109            *
    110            *        http://www.st.com/software_license_agreement_liberty_v2
    111            *
    112            * Unless required by applicable law or agreed to in writing, software 
    113            * distributed under the License is distributed on an "AS IS" BASIS, 
    114            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    115            * See the License for the specific language governing permissions and
    116            * limitations under the License.
    117            *
    118            ******************************************************************************
    119            */ 
    120          
    121          /* Includes ------------------------------------------------------------------*/
    122          #include "stm32f4xx_dma.h"
    123          #include "stm32f4xx_rcc.h"
    124          
    125          /** @addtogroup STM32F4xx_StdPeriph_Driver
    126            * @{
    127            */
    128          
    129          /** @defgroup DMA 
    130            * @brief DMA driver modules
    131            * @{
    132            */ 
    133          
    134          /* Private typedef -----------------------------------------------------------*/
    135          /* Private define ------------------------------------------------------------*/
    136          
    137          /* Masks Definition */
    138          #define TRANSFER_IT_ENABLE_MASK (uint32_t)(DMA_SxCR_TCIE | DMA_SxCR_HTIE | \
    139                                                     DMA_SxCR_TEIE | DMA_SxCR_DMEIE)
    140          
    141          #define DMA_Stream0_IT_MASK     (uint32_t)(DMA_LISR_FEIF0 | DMA_LISR_DMEIF0 | \
    142                                                     DMA_LISR_TEIF0 | DMA_LISR_HTIF0 | \
    143                                                     DMA_LISR_TCIF0)
    144          
    145          #define DMA_Stream1_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 6)
    146          #define DMA_Stream2_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 16)
    147          #define DMA_Stream3_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 22)
    148          #define DMA_Stream4_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK | (uint32_t)0x20000000)
    149          #define DMA_Stream5_IT_MASK     (uint32_t)(DMA_Stream1_IT_MASK | (uint32_t)0x20000000)
    150          #define DMA_Stream6_IT_MASK     (uint32_t)(DMA_Stream2_IT_MASK | (uint32_t)0x20000000)
    151          #define DMA_Stream7_IT_MASK     (uint32_t)(DMA_Stream3_IT_MASK | (uint32_t)0x20000000)
    152          #define TRANSFER_IT_MASK        (uint32_t)0x0F3C0F3C
    153          #define HIGH_ISR_MASK           (uint32_t)0x20000000
    154          #define RESERVED_MASK           (uint32_t)0x0F7D0F7D  
    155          
    156          /* Private macro -------------------------------------------------------------*/
    157          /* Private variables ---------------------------------------------------------*/
    158          /* Private function prototypes -----------------------------------------------*/
    159          /* Private functions ---------------------------------------------------------*/
    160          
    161          
    162          /** @defgroup DMA_Private_Functions
    163            * @{
    164            */
    165          
    166          /** @defgroup DMA_Group1 Initialization and Configuration functions
    167           *  @brief   Initialization and Configuration functions
    168           *
    169          @verbatim   
    170           ===============================================================================
    171                           Initialization and Configuration functions
    172           ===============================================================================  
    173          
    174            This subsection provides functions allowing to initialize the DMA Stream source
    175            and destination addresses, incrementation and data sizes, transfer direction, 
    176            buffer size, circular/normal mode selection, memory-to-memory mode selection 
    177            and Stream priority value.
    178            
    179            The DMA_Init() function follows the DMA configuration procedures as described in
    180            reference manual (RM0090) except the first point: waiting on EN bit to be reset.
    181            This condition should be checked by user application using the function DMA_GetCmdStatus()
    182            before calling the DMA_Init() function.
    183          
    184          @endverbatim
    185            * @{
    186            */
    187          
    188          /**
    189            * @brief  Deinitialize the DMAy Streamx registers to their default reset values.
    190            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    191            *         to 7 to select the DMA Stream.
    192            * @retval None
    193            */
    194          void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
    195          {
    196            /* Check the parameters */
    197            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    198          
    199            /* Disable the selected DMAy Streamx */
    200            DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
    201          
    202            /* Reset DMAy Streamx control register */
    203            DMAy_Streamx->CR  = 0;
    204            
    205            /* Reset DMAy Streamx Number of Data to Transfer register */
    206            DMAy_Streamx->NDTR = 0;
    207            
    208            /* Reset DMAy Streamx peripheral address register */
    209            DMAy_Streamx->PAR  = 0;
    210            
    211            /* Reset DMAy Streamx memory 0 address register */
    212            DMAy_Streamx->M0AR = 0;
    213          
    214            /* Reset DMAy Streamx memory 1 address register */
    215            DMAy_Streamx->M1AR = 0;
    216          
    217            /* Reset DMAy Streamx FIFO control register */
    218            DMAy_Streamx->FCR = (uint32_t)0x00000021; 
    219          
    220            /* Reset interrupt pending bits for the selected stream */
    221            if (DMAy_Streamx == DMA1_Stream0)
    222            {
    223              /* Reset interrupt pending bits for DMA1 Stream0 */
    224              DMA1->LIFCR = DMA_Stream0_IT_MASK;
    225            }
    226            else if (DMAy_Streamx == DMA1_Stream1)
    227            {
    228              /* Reset interrupt pending bits for DMA1 Stream1 */
    229              DMA1->LIFCR = DMA_Stream1_IT_MASK;
    230            }
    231            else if (DMAy_Streamx == DMA1_Stream2)
    232            {
    233              /* Reset interrupt pending bits for DMA1 Stream2 */
    234              DMA1->LIFCR = DMA_Stream2_IT_MASK;
    235            }
    236            else if (DMAy_Streamx == DMA1_Stream3)
    237            {
    238              /* Reset interrupt pending bits for DMA1 Stream3 */
    239              DMA1->LIFCR = DMA_Stream3_IT_MASK;
    240            }
    241            else if (DMAy_Streamx == DMA1_Stream4)
    242            {
    243              /* Reset interrupt pending bits for DMA1 Stream4 */
    244              DMA1->HIFCR = DMA_Stream4_IT_MASK;
    245            }
    246            else if (DMAy_Streamx == DMA1_Stream5)
    247            {
    248              /* Reset interrupt pending bits for DMA1 Stream5 */
    249              DMA1->HIFCR = DMA_Stream5_IT_MASK;
    250            }
    251            else if (DMAy_Streamx == DMA1_Stream6)
    252            {
    253              /* Reset interrupt pending bits for DMA1 Stream6 */
    254              DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
    255            }
    256            else if (DMAy_Streamx == DMA1_Stream7)
    257            {
    258              /* Reset interrupt pending bits for DMA1 Stream7 */
    259              DMA1->HIFCR = DMA_Stream7_IT_MASK;
    260            }
    261            else if (DMAy_Streamx == DMA2_Stream0)
    262            {
    263              /* Reset interrupt pending bits for DMA2 Stream0 */
    264              DMA2->LIFCR = DMA_Stream0_IT_MASK;
    265            }
    266            else if (DMAy_Streamx == DMA2_Stream1)
    267            {
    268              /* Reset interrupt pending bits for DMA2 Stream1 */
    269              DMA2->LIFCR = DMA_Stream1_IT_MASK;
    270            }
    271            else if (DMAy_Streamx == DMA2_Stream2)
    272            {
    273              /* Reset interrupt pending bits for DMA2 Stream2 */
    274              DMA2->LIFCR = DMA_Stream2_IT_MASK;
    275            }
    276            else if (DMAy_Streamx == DMA2_Stream3)
    277            {
    278              /* Reset interrupt pending bits for DMA2 Stream3 */
    279              DMA2->LIFCR = DMA_Stream3_IT_MASK;
    280            }
    281            else if (DMAy_Streamx == DMA2_Stream4)
    282            {
    283              /* Reset interrupt pending bits for DMA2 Stream4 */
    284              DMA2->HIFCR = DMA_Stream4_IT_MASK;
    285            }
    286            else if (DMAy_Streamx == DMA2_Stream5)
    287            {
    288              /* Reset interrupt pending bits for DMA2 Stream5 */
    289              DMA2->HIFCR = DMA_Stream5_IT_MASK;
    290            }
    291            else if (DMAy_Streamx == DMA2_Stream6)
    292            {
    293              /* Reset interrupt pending bits for DMA2 Stream6 */
    294              DMA2->HIFCR = DMA_Stream6_IT_MASK;
    295            }
    296            else 
    297            {
    298              if (DMAy_Streamx == DMA2_Stream7)
    299              {
    300                /* Reset interrupt pending bits for DMA2 Stream7 */
    301                DMA2->HIFCR = DMA_Stream7_IT_MASK;
    302              }
    303            }
    304          }
    305          
    306          /**
    307            * @brief  Initializes the DMAy Streamx according to the specified parameters in 
    308            *         the DMA_InitStruct structure.
    309            * @note   Before calling this function, it is recommended to check that the Stream 
    310            *         is actually disabled using the function DMA_GetCmdStatus().  
    311            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    312            *         to 7 to select the DMA Stream.
    313            * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
    314            *         the configuration information for the specified DMA Stream.  
    315            * @retval None
    316            */
    317          void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
    318          {
    319            uint32_t tmpreg = 0;
    320          
    321            /* Check the parameters */
    322            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    323            assert_param(IS_DMA_CHANNEL(DMA_InitStruct->DMA_Channel));
    324            assert_param(IS_DMA_DIRECTION(DMA_InitStruct->DMA_DIR));
    325            assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
    326            assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
    327            assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));
    328            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
    329            assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
    330            assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
    331            assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
    332            assert_param(IS_DMA_FIFO_MODE_STATE(DMA_InitStruct->DMA_FIFOMode));
    333            assert_param(IS_DMA_FIFO_THRESHOLD(DMA_InitStruct->DMA_FIFOThreshold));
    334            assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
    335            assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));
    336          
    337            /*------------------------- DMAy Streamx CR Configuration ------------------*/
    338            /* Get the DMAy_Streamx CR value */
    339            tmpreg = DMAy_Streamx->CR;
    340          
    341            /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
    342            tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    343                                   DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE | \
    344                                   DMA_SxCR_MINC | DMA_SxCR_PINC | DMA_SxCR_CIRC | \
    345                                   DMA_SxCR_DIR));
    346          
    347            /* Configure DMAy Streamx: */
    348            /* Set CHSEL bits according to DMA_CHSEL value */
    349            /* Set DIR bits according to DMA_DIR value */
    350            /* Set PINC bit according to DMA_PeripheralInc value */
    351            /* Set MINC bit according to DMA_MemoryInc value */
    352            /* Set PSIZE bits according to DMA_PeripheralDataSize value */
    353            /* Set MSIZE bits according to DMA_MemoryDataSize value */
    354            /* Set CIRC bit according to DMA_Mode value */
    355            /* Set PL bits according to DMA_Priority value */
    356            /* Set MBURST bits according to DMA_MemoryBurst value */
    357            /* Set PBURST bits according to DMA_PeripheralBurst value */
    358            tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
    359                      DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
    360                      DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
    361                      DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
    362                      DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
    363          
    364            /* Write to DMAy Streamx CR register */
    365            DMAy_Streamx->CR = tmpreg;
    366          
    367            /*------------------------- DMAy Streamx FCR Configuration -----------------*/
    368            /* Get the DMAy_Streamx FCR value */
    369            tmpreg = DMAy_Streamx->FCR;
    370          
    371            /* Clear DMDIS and FTH bits */
    372            tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
    373          
    374            /* Configure DMAy Streamx FIFO: 
    375              Set DMDIS bits according to DMA_FIFOMode value 
    376              Set FTH bits according to DMA_FIFOThreshold value */
    377            tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
    378          
    379            /* Write to DMAy Streamx CR */
    380            DMAy_Streamx->FCR = tmpreg;
    381          
    382            /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
    383            /* Write to DMAy Streamx NDTR register */
    384            DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
    385          
    386            /*------------------------- DMAy Streamx PAR Configuration -----------------*/
    387            /* Write to DMAy Streamx PAR */
    388            DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
    389          
    390            /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
    391            /* Write to DMAy Streamx M0AR */
    392            DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
    393          }
    394          
    395          /**
    396            * @brief  Fills each DMA_InitStruct member with its default value.
    397            * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will 
    398            *         be initialized.
    399            * @retval None
    400            */
    401          void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
    402          {
    403            /*-------------- Reset DMA init structure parameters values ----------------*/
    404            /* Initialize the DMA_Channel member */
    405            DMA_InitStruct->DMA_Channel = 0;
    406          
    407            /* Initialize the DMA_PeripheralBaseAddr member */
    408            DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
    409          
    410            /* Initialize the DMA_Memory0BaseAddr member */
    411            DMA_InitStruct->DMA_Memory0BaseAddr = 0;
    412          
    413            /* Initialize the DMA_DIR member */
    414            DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
    415          
    416            /* Initialize the DMA_BufferSize member */
    417            DMA_InitStruct->DMA_BufferSize = 0;
    418          
    419            /* Initialize the DMA_PeripheralInc member */
    420            DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    421          
    422            /* Initialize the DMA_MemoryInc member */
    423            DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
    424          
    425            /* Initialize the DMA_PeripheralDataSize member */
    426            DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    427          
    428            /* Initialize the DMA_MemoryDataSize member */
    429            DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    430          
    431            /* Initialize the DMA_Mode member */
    432            DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
    433          
    434            /* Initialize the DMA_Priority member */
    435            DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
    436          
    437            /* Initialize the DMA_FIFOMode member */
    438            DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
    439          
    440            /* Initialize the DMA_FIFOThreshold member */
    441            DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
    442          
    443            /* Initialize the DMA_MemoryBurst member */
    444            DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
    445          
    446            /* Initialize the DMA_PeripheralBurst member */
    447            DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
    448          }
    449          
    450          /**
    451            * @brief  Enables or disables the specified DMAy Streamx.
    452            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    453            *         to 7 to select the DMA Stream.
    454            * @param  NewState: new state of the DMAy Streamx. 
    455            *          This parameter can be: ENABLE or DISABLE.
    456            *
    457            * @note  This function may be used to perform Pause-Resume operation. When a
    458            *        transfer is ongoing, calling this function to disable the Stream will
    459            *        cause the transfer to be paused. All configuration registers and the
    460            *        number of remaining data will be preserved. When calling again this
    461            *        function to re-enable the Stream, the transfer will be resumed from
    462            *        the point where it was paused.          
    463            *    
    464            * @note  After configuring the DMA Stream (DMA_Init() function) and enabling the
    465            *        stream, it is recommended to check (or wait until) the DMA Stream is
    466            *        effectively enabled. A Stream may remain disabled if a configuration 
    467            *        parameter is wrong.
    468            *        After disabling a DMA Stream, it is also recommended to check (or wait
    469            *        until) the DMA Stream is effectively disabled. If a Stream is disabled 
    470            *        while a data transfer is ongoing, the current data will be transferred
    471            *        and the Stream will be effectively disabled only after the transfer of
    472            *        this single data is finished.            
    473            *    
    474            * @retval None
    475            */
    476          void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
    477          {
    478            /* Check the parameters */
    479            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    480            assert_param(IS_FUNCTIONAL_STATE(NewState));
    481          
    482            if (NewState != DISABLE)
    483            {
    484              /* Enable the selected DMAy Streamx by setting EN bit */
    485              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
    486            }
    487            else
    488            {
    489              /* Disable the selected DMAy Streamx by clearing EN bit */
    490              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
    491            }
    492          }
    493          
    494          /**
    495            * @brief  Configures, when the PINC (Peripheral Increment address mode) bit is
    496            *         set, if the peripheral address should be incremented with the data 
    497            *         size (configured with PSIZE bits) or by a fixed offset equal to 4
    498            *         (32-bit aligned addresses).
    499            *   
    500            * @note   This function has no effect if the Peripheral Increment mode is disabled.
    501            *     
    502            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    503            *          to 7 to select the DMA Stream.
    504            * @param  DMA_Pincos: specifies the Peripheral increment offset size.
    505            *          This parameter can be one of the following values:
    506            *            @arg DMA_PINCOS_Psize: Peripheral address increment is done  
    507            *                                   accordingly to PSIZE parameter.
    508            *            @arg DMA_PINCOS_WordAligned: Peripheral address increment offset is 
    509            *                                         fixed to 4 (32-bit aligned addresses). 
    510            * @retval None
    511            */
    512          void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos)
    513          {
    514            /* Check the parameters */
    515            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    516            assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));
    517          
    518            /* Check the needed Peripheral increment offset */
    519            if(DMA_Pincos != DMA_PINCOS_Psize)
    520            {
    521              /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    522              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
    523            }
    524            else
    525            {
    526              /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
    527              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
    528            }
    529          }
    530          
    531          /**
    532            * @brief  Configures, when the DMAy Streamx is disabled, the flow controller for
    533            *         the next transactions (Peripheral or Memory).
    534            *       
    535            * @note   Before enabling this feature, check if the used peripheral supports 
    536            *         the Flow Controller mode or not.    
    537            *  
    538            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    539            *          to 7 to select the DMA Stream.
    540            * @param  DMA_FlowCtrl: specifies the DMA flow controller.
    541            *          This parameter can be one of the following values:
    542            *            @arg DMA_FlowCtrl_Memory: DMAy_Streamx transactions flow controller is 
    543            *                                      the DMA controller.
    544            *            @arg DMA_FlowCtrl_Peripheral: DMAy_Streamx transactions flow controller 
    545            *                                          is the peripheral.    
    546            * @retval None
    547            */
    548          void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl)
    549          {
    550            /* Check the parameters */
    551            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    552            assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));
    553          
    554            /* Check the needed flow controller  */
    555            if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
    556            {
    557              /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    558              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
    559            }
    560            else
    561            {
    562              /* Clear the PFCTRL bit: Memory is the flow controller */
    563              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
    564            }
    565          }
    566          /**
    567            * @}
    568            */
    569          
    570          /** @defgroup DMA_Group2 Data Counter functions
    571           *  @brief   Data Counter functions 
    572           *
    573          @verbatim   
    574           ===============================================================================
    575                                     Data Counter functions
    576           ===============================================================================  
    577          
    578            This subsection provides function allowing to configure and read the buffer size
    579            (number of data to be transferred). 
    580          
    581            The DMA data counter can be written only when the DMA Stream is disabled 
    582            (ie. after transfer complete event).
    583          
    584            The following function can be used to write the Stream data counter value:
    585              - void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter);
    586          
    587          @note It is advised to use this function rather than DMA_Init() in situations where
    588                only the Data buffer needs to be reloaded.
    589          
    590          @note If the Source and Destination Data Sizes are different, then the value written in
    591                data counter, expressing the number of transfers, is relative to the number of 
    592                transfers from the Peripheral point of view.
    593                ie. If Memory data size is Word, Peripheral data size is Half-Words, then the value
    594                to be configured in the data counter is the number of Half-Words to be transferred
    595                from/to the peripheral.
    596          
    597            The DMA data counter can be read to indicate the number of remaining transfers for
    598            the relative DMA Stream. This counter is decremented at the end of each data 
    599            transfer and when the transfer is complete: 
    600             - If Normal mode is selected: the counter is set to 0.
    601             - If Circular mode is selected: the counter is reloaded with the initial value
    602               (configured before enabling the DMA Stream)
    603             
    604            The following function can be used to read the Stream data counter value:
    605               - uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx);
    606          
    607          @endverbatim
    608            * @{
    609            */
    610          
    611          /**
    612            * @brief  Writes the number of data units to be transferred on the DMAy Streamx.
    613            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    614            *          to 7 to select the DMA Stream.
    615            * @param  Counter: Number of data units to be transferred (from 0 to 65535) 
    616            *          Number of data items depends only on the Peripheral data format.
    617            *            
    618            * @note   If Peripheral data format is Bytes: number of data units is equal 
    619            *         to total number of bytes to be transferred.
    620            *           
    621            * @note   If Peripheral data format is Half-Word: number of data units is  
    622            *         equal to total number of bytes to be transferred / 2.
    623            *           
    624            * @note   If Peripheral data format is Word: number of data units is equal 
    625            *         to total  number of bytes to be transferred / 4.
    626            *      
    627            * @note   In Memory-to-Memory transfer mode, the memory buffer pointed by 
    628            *         DMAy_SxPAR register is considered as Peripheral.
    629            *      
    630            * @retval The number of remaining data units in the current DMAy Streamx transfer.
    631            */
    632          void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter)
    633          {
    634            /* Check the parameters */
    635            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    636          
    637            /* Write the number of data units to be transferred */
    638            DMAy_Streamx->NDTR = (uint16_t)Counter;
    639          }
    640          
    641          /**
    642            * @brief  Returns the number of remaining data units in the current DMAy Streamx transfer.
    643            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    644            *          to 7 to select the DMA Stream.
    645            * @retval The number of remaining data units in the current DMAy Streamx transfer.
    646            */
    647          uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx)
    648          {
    649            /* Check the parameters */
    650            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    651          
    652            /* Return the number of remaining data units for DMAy Streamx */
    653            return ((uint16_t)(DMAy_Streamx->NDTR));
    654          }
    655          /**
    656            * @}
    657            */
    658          
    659          /** @defgroup DMA_Group3 Double Buffer mode functions
    660           *  @brief   Double Buffer mode functions 
    661           *
    662          @verbatim   
    663           ===============================================================================
    664                                   Double Buffer mode functions
    665           ===============================================================================  
    666          
    667            This subsection provides function allowing to configure and control the double 
    668            buffer mode parameters.
    669            
    670            The Double Buffer mode can be used only when Circular mode is enabled.
    671            The Double Buffer mode cannot be used when transferring data from Memory to Memory.
    672            
    673            The Double Buffer mode allows to set two different Memory addresses from/to which
    674            the DMA controller will access alternatively (after completing transfer to/from target
    675            memory 0, it will start transfer to/from target memory 1).
    676            This allows to reduce software overhead for double buffering and reduce the CPU
    677            access time.
    678          
    679            Two functions must be called before calling the DMA_Init() function:
    680             - void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
    681                                          uint32_t DMA_CurrentMemory);
    682             - void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
    683             
    684            DMA_DoubleBufferModeConfig() is called to configure the Memory 1 base address and the first
    685            Memory target from/to which the transfer will start after enabling the DMA Stream.
    686            Then DMA_DoubleBufferModeCmd() must be called to enable the Double Buffer mode (or disable 
    687            it when it should not be used).
    688            
    689             
    690            Two functions can be called dynamically when the transfer is ongoing (or when the DMA Stream is 
    691            stopped) to modify on of the target Memories addresses or to check wich Memory target is currently
    692             used:
    693              - void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
    694                                      uint32_t DMA_MemoryTarget);
    695              - uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx);
    696          
    697            DMA_MemoryTargetConfig() can be called to modify the base address of one of the two target Memories.
    698            The Memory of which the base address will be modified must not be currently be used by the DMA Stream
    699            (ie. if the DMA Stream is currently transferring from Memory 1 then you can only modify base address
    700            of target Memory 0 and vice versa).
    701            To check this condition, it is recommended to use the function DMA_GetCurrentMemoryTarget() which
    702            returns the index of the Memory target currently in use by the DMA Stream.
    703          
    704          @endverbatim
    705            * @{
    706            */
    707            
    708          /**
    709            * @brief  Configures, when the DMAy Streamx is disabled, the double buffer mode 
    710            *         and the current memory target.
    711            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    712            *          to 7 to select the DMA Stream.
    713            * @param  Memory1BaseAddr: the base address of the second buffer (Memory 1)  
    714            * @param  DMA_CurrentMemory: specifies which memory will be first buffer for
    715            *         the transactions when the Stream will be enabled. 
    716            *          This parameter can be one of the following values:
    717            *            @arg DMA_Memory_0: Memory 0 is the current buffer.
    718            *            @arg DMA_Memory_1: Memory 1 is the current buffer.  
    719            *       
    720            * @note   Memory0BaseAddr is set by the DMA structure configuration in DMA_Init().
    721            *   
    722            * @retval None
    723            */
    724          void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
    725                                          uint32_t DMA_CurrentMemory)
    726          {  
    727            /* Check the parameters */
    728            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    729            assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));
    730          
    731            if (DMA_CurrentMemory != DMA_Memory_0)
    732            {
    733              /* Set Memory 1 as current memory address */
    734              DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
    735            }
    736            else
    737            {
    738              /* Set Memory 0 as current memory address */
    739              DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
    740            }
    741          
    742            /* Write to DMAy Streamx M1AR */
    743            DMAy_Streamx->M1AR = Memory1BaseAddr;
    744          }
    745          
    746          /**
    747            * @brief  Enables or disables the double buffer mode for the selected DMA stream.
    748            * @note   This function can be called only when the DMA Stream is disabled.  
    749            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    750            *          to 7 to select the DMA Stream.
    751            * @param  NewState: new state of the DMAy Streamx double buffer mode. 
    752            *          This parameter can be: ENABLE or DISABLE.
    753            * @retval None
    754            */
    755          void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
    756          {  
    757            /* Check the parameters */
    758            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    759            assert_param(IS_FUNCTIONAL_STATE(NewState));
    760          
    761            /* Configure the Double Buffer mode */
    762            if (NewState != DISABLE)
    763            {
    764              /* Enable the Double buffer mode */
    765              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
    766            }
    767            else
    768            {
    769              /* Disable the Double buffer mode */
    770              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
    771            }
    772          }
    773          
    774          /**
    775            * @brief  Configures the Memory address for the next buffer transfer in double
    776            *         buffer mode (for dynamic use). This function can be called when the
    777            *         DMA Stream is enabled and when the transfer is ongoing.  
    778            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    779            *          to 7 to select the DMA Stream.
    780            * @param  MemoryBaseAddr: The base address of the target memory buffer
    781            * @param  DMA_MemoryTarget: Next memory target to be used. 
    782            *         This parameter can be one of the following values:
    783            *            @arg DMA_Memory_0: To use the memory address 0
    784            *            @arg DMA_Memory_1: To use the memory address 1
    785            * 
    786            * @note    It is not allowed to modify the Base Address of a target Memory when
    787            *          this target is involved in the current transfer. ie. If the DMA Stream
    788            *          is currently transferring to/from Memory 1, then it not possible to
    789            *          modify Base address of Memory 1, but it is possible to modify Base
    790            *          address of Memory 0.
    791            *          To know which Memory is currently used, you can use the function
    792            *          DMA_GetCurrentMemoryTarget().             
    793            *  
    794            * @retval None
    795            */
    796          void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
    797                                     uint32_t DMA_MemoryTarget)
    798          {
    799            /* Check the parameters */
    800            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    801            assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
    802              
    803            /* Check the Memory target to be configured */
    804            if (DMA_MemoryTarget != DMA_Memory_0)
    805            {
    806              /* Write to DMAy Streamx M1AR */
    807              DMAy_Streamx->M1AR = MemoryBaseAddr;    
    808            }  
    809            else
    810            {
    811              /* Write to DMAy Streamx M0AR */
    812              DMAy_Streamx->M0AR = MemoryBaseAddr;  
    813            }
    814          }
    815          
    816          /**
    817            * @brief  Returns the current memory target used by double buffer transfer.
    818            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    819            *          to 7 to select the DMA Stream.
    820            * @retval The memory target number: 0 for Memory0 or 1 for Memory1. 
    821            */
    822          uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx)
    823          {
    824            uint32_t tmp = 0;
    825            
    826            /* Check the parameters */
    827            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    828          
    829            /* Get the current memory target */
    830            if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
    831            {
    832              /* Current memory buffer used is Memory 1 */
    833              tmp = 1;
    834            }  
    835            else
    836            {
    837              /* Current memory buffer used is Memory 0 */
    838              tmp = 0;    
    839            }
    840            return tmp;
    841          }
    842          /**
    843            * @}
    844            */
    845          
    846          /** @defgroup DMA_Group4 Interrupts and flags management functions
    847           *  @brief   Interrupts and flags management functions 
    848           *
    849          @verbatim   
    850           ===============================================================================
    851                            Interrupts and flags management functions
    852           ===============================================================================  
    853          
    854            This subsection provides functions allowing to
    855             - Check the DMA enable status
    856             - Check the FIFO status 
    857             - Configure the DMA Interrupts sources and check or clear the flags or pending bits status.   
    858             
    859           1. DMA Enable status:
    860             After configuring the DMA Stream (DMA_Init() function) and enabling the stream,
    861             it is recommended to check (or wait until) the DMA Stream is effectively enabled.
    862             A Stream may remain disabled if a configuration parameter is wrong.
    863             After disabling a DMA Stream, it is also recommended to check (or wait until) the DMA
    864             Stream is effectively disabled. If a Stream is disabled while a data transfer is ongoing, 
    865             the current data will be transferred and the Stream will be effectively disabled only after
    866             this data transfer completion.
    867             To monitor this state it is possible to use the following function:
    868               - FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx); 
    869           
    870           2. FIFO Status:
    871             It is possible to monitor the FIFO status when a transfer is ongoing using the following 
    872             function:
    873               - uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx); 
    874           
    875           3. DMA Interrupts and Flags:
    876            The user should identify which mode will be used in his application to manage the
    877            DMA controller events: Polling mode or Interrupt mode. 
    878              
    879            Polling Mode
    880            =============
    881              Each DMA stream can be managed through 4 event Flags:
    882              (x : DMA Stream number )
    883                 1. DMA_FLAG_FEIFx  : to indicate that a FIFO Mode Transfer Error event occurred.
    884                 2. DMA_FLAG_DMEIFx : to indicate that a Direct Mode Transfer Error event occurred.
    885                 3. DMA_FLAG_TEIFx  : to indicate that a Transfer Error event occurred.
    886                 4. DMA_FLAG_HTIFx  : to indicate that a Half-Transfer Complete event occurred.
    887                 5. DMA_FLAG_TCIFx  : to indicate that a Transfer Complete event occurred .       
    888          
    889             In this Mode it is advised to use the following functions:
    890                - FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
    891                - void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
    892          
    893            Interrupt Mode
    894            ===============
    895              Each DMA Stream can be managed through 4 Interrupts:
    896          
    897              Interrupt Source
    898              ----------------
    899                 1. DMA_IT_FEIFx  : specifies the interrupt source for the  FIFO Mode Transfer Error event.
    900                 2. DMA_IT_DMEIFx : specifies the interrupt source for the Direct Mode Transfer Error event.
    901                 3. DMA_IT_TEIFx  : specifies the interrupt source for the Transfer Error event.
    902                 4. DMA_IT_HTIFx  : specifies the interrupt source for the Half-Transfer Complete event.
    903                 5. DMA_IT_TCIFx  : specifies the interrupt source for the a Transfer Complete event. 
    904               
    905            In this Mode it is advised to use the following functions:
    906               - void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState);
    907               - ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
    908               - void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
    909          
    910          @endverbatim
    911            * @{
    912            */
    913          
    914          /**
    915            * @brief  Returns the status of EN bit for the specified DMAy Streamx.
    916            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    917            *          to 7 to select the DMA Stream.
    918            *   
    919            * @note    After configuring the DMA Stream (DMA_Init() function) and enabling
    920            *          the stream, it is recommended to check (or wait until) the DMA Stream
    921            *          is effectively enabled. A Stream may remain disabled if a configuration
    922            *          parameter is wrong.
    923            *          After disabling a DMA Stream, it is also recommended to check (or wait 
    924            *          until) the DMA Stream is effectively disabled. If a Stream is disabled
    925            *          while a data transfer is ongoing, the current data will be transferred
    926            *          and the Stream will be effectively disabled only after the transfer
    927            *          of this single data is finished.  
    928            *      
    929            * @retval Current state of the DMAy Streamx (ENABLE or DISABLE).
    930            */
    931          FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx)
    932          {
    933            FunctionalState state = DISABLE;
    934          
    935            /* Check the parameters */
    936            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    937          
    938            if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
    939            {
    940              /* The selected DMAy Streamx EN bit is set (DMA is still transferring) */
    941              state = ENABLE;
    942            }
    943            else
    944            {
    945              /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
    946                  all transfers are complete) */
    947              state = DISABLE;
    948            }
    949            return state;
    950          }
    951          
    952          /**
    953            * @brief  Returns the current DMAy Streamx FIFO filled level.
    954            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0 
    955            *         to 7 to select the DMA Stream.
    956            * @retval The FIFO filling state.
    957            *           - DMA_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
    958            *                                               and not empty.
    959            *           - DMA_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
    960            *           - DMA_FIFOStatus_HalfFull: if more than 1 half-full.
    961            *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
    962            *           - DMA_FIFOStatus_Empty: when FIFO is empty
    963            *           - DMA_FIFOStatus_Full: when FIFO is full
    964            */
    965          uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx)
    966          {
    967            uint32_t tmpreg = 0;
    968           
    969            /* Check the parameters */
    970            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    971            
    972            /* Get the FIFO level bits */
    973            tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
    974            
    975            return tmpreg;
    976          }
    977          
    978          /**
    979            * @brief  Checks whether the specified DMAy Streamx flag is set or not.
    980            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    981            *          to 7 to select the DMA Stream.
    982            * @param  DMA_FLAG: specifies the flag to check.
    983            *          This parameter can be one of the following values:
    984            *            @arg DMA_FLAG_TCIFx:  Streamx transfer complete flag
    985            *            @arg DMA_FLAG_HTIFx:  Streamx half transfer complete flag
    986            *            @arg DMA_FLAG_TEIFx:  Streamx transfer error flag
    987            *            @arg DMA_FLAG_DMEIFx: Streamx direct mode error flag
    988            *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
    989            *         Where x can be 0 to 7 to select the DMA Stream.
    990            * @retval The new state of DMA_FLAG (SET or RESET).
    991            */
    992          FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
    993          {
    994            FlagStatus bitstatus = RESET;
    995            DMA_TypeDef* DMAy;
    996            uint32_t tmpreg = 0;
    997          
    998            /* Check the parameters */
    999            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   1000            assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
   1001          
   1002            /* Determine the DMA to which belongs the stream */
   1003            if (DMAy_Streamx < DMA2_Stream0)
   1004            {
   1005              /* DMAy_Streamx belongs to DMA1 */
   1006              DMAy = DMA1; 
   1007            } 
   1008            else 
   1009            {
   1010              /* DMAy_Streamx belongs to DMA2 */
   1011              DMAy = DMA2; 
   1012            }
   1013          
   1014            /* Check if the flag is in HISR or LISR */
   1015            if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
   1016            {
   1017              /* Get DMAy HISR register value */
   1018              tmpreg = DMAy->HISR;
   1019            }
   1020            else
   1021            {
   1022              /* Get DMAy LISR register value */
   1023              tmpreg = DMAy->LISR;
   1024            }   
   1025           
   1026            /* Mask the reserved bits */
   1027            tmpreg &= (uint32_t)RESERVED_MASK;
   1028          
   1029            /* Check the status of the specified DMA flag */
   1030            if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
   1031            {
   1032              /* DMA_FLAG is set */
   1033              bitstatus = SET;
   1034            }
   1035            else
   1036            {
   1037              /* DMA_FLAG is reset */
   1038              bitstatus = RESET;
   1039            }
   1040          
   1041            /* Return the DMA_FLAG status */
   1042            return  bitstatus;
   1043          }
   1044          
   1045          /**
   1046            * @brief  Clears the DMAy Streamx's pending flags.
   1047            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1048            *          to 7 to select the DMA Stream.
   1049            * @param  DMA_FLAG: specifies the flag to clear.
   1050            *          This parameter can be any combination of the following values:
   1051            *            @arg DMA_FLAG_TCIFx:  Streamx transfer complete flag
   1052            *            @arg DMA_FLAG_HTIFx:  Streamx half transfer complete flag
   1053            *            @arg DMA_FLAG_TEIFx:  Streamx transfer error flag
   1054            *            @arg DMA_FLAG_DMEIFx: Streamx direct mode error flag
   1055            *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
   1056            *         Where x can be 0 to 7 to select the DMA Stream.   
   1057            * @retval None
   1058            */
   1059          void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
   1060          {
   1061            DMA_TypeDef* DMAy;
   1062          
   1063            /* Check the parameters */
   1064            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   1065            assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
   1066          
   1067            /* Determine the DMA to which belongs the stream */
   1068            if (DMAy_Streamx < DMA2_Stream0)
   1069            {
   1070              /* DMAy_Streamx belongs to DMA1 */
   1071              DMAy = DMA1; 
   1072            } 
   1073            else 
   1074            {
   1075              /* DMAy_Streamx belongs to DMA2 */
   1076              DMAy = DMA2; 
   1077            }
   1078          
   1079            /* Check if LIFCR or HIFCR register is targeted */
   1080            if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
   1081            {
   1082              /* Set DMAy HIFCR register clear flag bits */
   1083              DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
   1084            }
   1085            else 
   1086            {
   1087              /* Set DMAy LIFCR register clear flag bits */
   1088              DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
   1089            }    
   1090          }
   1091          
   1092          /**
   1093            * @brief  Enables or disables the specified DMAy Streamx interrupts.
   1094            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1095            *          to 7 to select the DMA Stream.
   1096            * @param DMA_IT: specifies the DMA interrupt sources to be enabled or disabled. 
   1097            *          This parameter can be any combination of the following values:
   1098            *            @arg DMA_IT_TC:  Transfer complete interrupt mask
   1099            *            @arg DMA_IT_HT:  Half transfer complete interrupt mask
   1100            *            @arg DMA_IT_TE:  Transfer error interrupt mask
   1101            *            @arg DMA_IT_FE:  FIFO error interrupt mask
   1102            * @param  NewState: new state of the specified DMA interrupts.
   1103            *          This parameter can be: ENABLE or DISABLE.
   1104            * @retval None
   1105            */
   1106          void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
   1107          {
   1108            /* Check the parameters */
   1109            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   1110            assert_param(IS_DMA_CONFIG_IT(DMA_IT));
   1111            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1112          
   1113            /* Check if the DMA_IT parameter contains a FIFO interrupt */
   1114            if ((DMA_IT & DMA_IT_FE) != 0)
   1115            {
   1116              if (NewState != DISABLE)
   1117              {
   1118                /* Enable the selected DMA FIFO interrupts */
   1119                DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
   1120              }    
   1121              else 
   1122              {
   1123                /* Disable the selected DMA FIFO interrupts */
   1124                DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
   1125              }
   1126            }
   1127          
   1128            /* Check if the DMA_IT parameter contains a Transfer interrupt */
   1129            if (DMA_IT != DMA_IT_FE)
   1130            {
   1131              if (NewState != DISABLE)
   1132              {
   1133                /* Enable the selected DMA transfer interrupts */
   1134                DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
   1135              }
   1136              else
   1137              {
   1138                /* Disable the selected DMA transfer interrupts */
   1139                DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
   1140              }    
   1141            }
   1142          }
   1143          
   1144          /**
   1145            * @brief  Checks whether the specified DMAy Streamx interrupt has occurred or not.
   1146            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1147            *          to 7 to select the DMA Stream.
   1148            * @param  DMA_IT: specifies the DMA interrupt source to check.
   1149            *          This parameter can be one of the following values:
   1150            *            @arg DMA_IT_TCIFx:  Streamx transfer complete interrupt
   1151            *            @arg DMA_IT_HTIFx:  Streamx half transfer complete interrupt
   1152            *            @arg DMA_IT_TEIFx:  Streamx transfer error interrupt
   1153            *            @arg DMA_IT_DMEIFx: Streamx direct mode error interrupt
   1154            *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
   1155            *         Where x can be 0 to 7 to select the DMA Stream.
   1156            * @retval The new state of DMA_IT (SET or RESET).
   1157            */
   1158          ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
   1159          {
   1160            ITStatus bitstatus = RESET;
   1161            DMA_TypeDef* DMAy;
   1162            uint32_t tmpreg = 0, enablestatus = 0;
   1163          
   1164            /* Check the parameters */
   1165            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   1166            assert_param(IS_DMA_GET_IT(DMA_IT));
   1167           
   1168            /* Determine the DMA to which belongs the stream */
   1169            if (DMAy_Streamx < DMA2_Stream0)
   1170            {
   1171              /* DMAy_Streamx belongs to DMA1 */
   1172              DMAy = DMA1; 
   1173            } 
   1174            else 
   1175            {
   1176              /* DMAy_Streamx belongs to DMA2 */
   1177              DMAy = DMA2; 
   1178            }
   1179          
   1180            /* Check if the interrupt enable bit is in the CR or FCR register */
   1181            if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
   1182            {
   1183              /* Get the interrupt enable position mask in CR register */
   1184              tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
   1185              
   1186              /* Check the enable bit in CR register */
   1187              enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
   1188            }
   1189            else 
   1190            {
   1191              /* Check the enable bit in FCR register */
   1192              enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
   1193            }
   1194           
   1195            /* Check if the interrupt pending flag is in LISR or HISR */
   1196            if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
   1197            {
   1198              /* Get DMAy HISR register value */
   1199              tmpreg = DMAy->HISR ;
   1200            }
   1201            else
   1202            {
   1203              /* Get DMAy LISR register value */
   1204              tmpreg = DMAy->LISR ;
   1205            } 
   1206          
   1207            /* mask all reserved bits */
   1208            tmpreg &= (uint32_t)RESERVED_MASK;
   1209          
   1210            /* Check the status of the specified DMA interrupt */
   1211            if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
   1212            {
   1213              /* DMA_IT is set */
   1214              bitstatus = SET;
   1215            }
   1216            else
   1217            {
   1218              /* DMA_IT is reset */
   1219              bitstatus = RESET;
   1220            }
   1221          
   1222            /* Return the DMA_IT status */
   1223            return  bitstatus;
   1224          }
   1225          
   1226          /**
   1227            * @brief  Clears the DMAy Streamx's interrupt pending bits.
   1228            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1229            *          to 7 to select the DMA Stream.
   1230            * @param  DMA_IT: specifies the DMA interrupt pending bit to clear.
   1231            *          This parameter can be any combination of the following values:
   1232            *            @arg DMA_IT_TCIFx:  Streamx transfer complete interrupt
   1233            *            @arg DMA_IT_HTIFx:  Streamx half transfer complete interrupt
   1234            *            @arg DMA_IT_TEIFx:  Streamx transfer error interrupt
   1235            *            @arg DMA_IT_DMEIFx: Streamx direct mode error interrupt
   1236            *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
   1237            *         Where x can be 0 to 7 to select the DMA Stream.
   1238            * @retval None
   1239            */
   1240          void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
   1241          {
   1242            DMA_TypeDef* DMAy;
   1243          
   1244            /* Check the parameters */
   1245            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   1246            assert_param(IS_DMA_CLEAR_IT(DMA_IT));
   1247          
   1248            /* Determine the DMA to which belongs the stream */
   1249            if (DMAy_Streamx < DMA2_Stream0)
   1250            {
   1251              /* DMAy_Streamx belongs to DMA1 */
   1252              DMAy = DMA1; 
   1253            } 
   1254            else 
   1255            {
   1256              /* DMAy_Streamx belongs to DMA2 */
   1257              DMAy = DMA2; 
   1258            }
   1259          
   1260            /* Check if LIFCR or HIFCR register is targeted */
   1261            if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
   1262            {
   1263              /* Set DMAy HIFCR register clear interrupt bits */
   1264              DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
   1265            }
   1266            else 
   1267            {
   1268              /* Set DMAy LIFCR register clear interrupt bits */
   1269              DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
   1270            }   
   1271          }
   1272          
   1273          /**
   1274            * @}
   1275            */
   1276          
   1277          /**
   1278            * @}
   1279            */
   1280          
   1281          /**
   1282            * @}
   1283            */
   1284          
   1285          /**
   1286            * @}
   1287            */
   1288          
   1289          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  DMA_ClearFlag
        0  DMA_ClearITPendingBit
        0  DMA_Cmd
       20  DMA_DeInit
        0  DMA_DoubleBufferModeCmd
        0  DMA_DoubleBufferModeConfig
        0  DMA_FlowControllerConfig
        0  DMA_GetCmdStatus
        0  DMA_GetCurrDataCounter
        0  DMA_GetCurrentMemoryTarget
        0  DMA_GetFIFOStatus
        0  DMA_GetFlagStatus
        8  DMA_GetITStatus
        0  DMA_ITConfig
        8  DMA_Init
        0  DMA_MemoryTargetConfig
        0  DMA_PeriphIncOffsetSizeConfig
        0  DMA_SetCurrDataCounter
        0  DMA_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_24
       4  ??DataTable5_25
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       6  ?Subroutine0
      26  DMA_ClearFlag
      26  DMA_ClearITPendingBit
      18  DMA_Cmd
     192  DMA_DeInit
      18  DMA_DoubleBufferModeCmd
      20  DMA_DoubleBufferModeConfig
      18  DMA_FlowControllerConfig
       2  DMA_GetCmdStatus
       6  DMA_GetCurrDataCounter
       6  DMA_GetCurrentMemoryTarget
       8  DMA_GetFIFOStatus
      34  DMA_GetFlagStatus
      62  DMA_GetITStatus
      44  DMA_ITConfig
      80  DMA_Init
      10  DMA_MemoryTargetConfig
      18  DMA_PeriphIncOffsetSizeConfig
       4  DMA_SetCurrDataCounter
      34  DMA_StructInit

 
 736 bytes in section .text
 
 736 bytes of CODE memory

Errors: none
Warnings: none
