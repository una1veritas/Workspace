###############################################################################
#                                                                             #
#                                                       19/Sep/2012  16:16:15 #
# IAR ANSI C/C++ Compiler V6.40.2.33884/W32 KICKSTART for ARM                 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32_USB_OTG_Driver\src\u #
#                    sb_core.c                                                #
#    Command line =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32_USB_OTG_Driver\src\u #
#                    sb_core.c -D USE_STDPERIPH_DRIVER -D STM32F4XX -D        #
#                    USE_STM324xG_EVAL -D USE_USB_OTG_FS -lcN                 #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\ -o                         #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\ --debug --endian=little     #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.4           #
#                    Kickstart\arm\INC\c\DLib_Config_Full.h" -I               #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM3 #
#                    2_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples #
#                    \DFU\EWARM\..\inc\ -I \\psf\Home\Documents\Eclipse\Works #
#                    pace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_De #
#                    vice_Examples\DFU\EWARM\..\..\..\..\Libraries\CMSIS\Devi #
#                    ce\ST\STM32F4xx\Include\ -I                              #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\  #
#                    -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB- #
#                    Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\E #
#                    WARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\in #
#                    c\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_U #
#                    SB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DF #
#                    U\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\C #
#                    lass\dfu\inc\ -I \\psf\Home\Documents\Eclipse\Workspace\ #
#                    ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_ #
#                    Examples\DFU\EWARM\..\..\..\..\Utilities\STM32_EVAL\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\Common\ -I            #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\    #
#                    -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.4                           #
#                    Kickstart\arm\CMSIS\Include\"                            #
#    List file    =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\usb_core.lst                #
#    Object file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\usb_core.o                   #
#                                                                             #
#                                                                             #
###############################################################################

\\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Libraries\STM32_USB_OTG_Driver\src\usb_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_core.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    19-March-2012
      7            * @brief   USB-OTG Core Layer
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usb_core.h"
     30          #include "usb_bsp.h"
     31          
     32          
     33          /** @addtogroup USB_OTG_DRIVER
     34          * @{
     35          */
     36          
     37          /** @defgroup USB_CORE 
     38          * @brief This file includes the USB-OTG Core Layer
     39          * @{
     40          */
     41          
     42          
     43          /** @defgroup USB_CORE_Private_Defines
     44          * @{
     45          */ 
     46          
     47          /**
     48          * @}
     49          */ 
     50          
     51          
     52          /** @defgroup USB_CORE_Private_TypesDefinitions
     53          * @{
     54          */ 
     55          /**
     56          * @}
     57          */ 
     58          
     59          
     60          
     61          /** @defgroup USB_CORE_Private_Macros
     62          * @{
     63          */ 
     64          /**
     65          * @}
     66          */ 
     67          
     68          
     69          /** @defgroup USB_CORE_Private_Variables
     70          * @{
     71          */ 
     72          /**
     73          * @}
     74          */ 
     75          
     76          
     77          /** @defgroup USB_CORE_Private_FunctionPrototypes
     78          * @{
     79          */ 
     80          /**
     81          * @}
     82          */ 
     83          
     84          
     85          /** @defgroup USB_CORE_Private_Functions
     86          * @{
     87          */ 
     88          
     89          /**
     90          * @brief  USB_OTG_EnableCommonInt
     91          *         Initializes the commmon interrupts, used in both device and modes
     92          * @param  pdev : Selected device
     93          * @retval None
     94          */
     95          static void USB_OTG_EnableCommonInt(USB_OTG_CORE_HANDLE *pdev)
     96          {
     97            USB_OTG_GINTMSK_TypeDef  int_mask;
     98            
     99            int_mask.d32 = 0;
    100            /* Clear any pending USB_OTG Interrupts */
    101          #ifndef USE_OTG_MODE
    102            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
    103          #endif
    104            /* Clear any pending interrupts */
    105            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
    106            /* Enable the interrupts in the INTMSK */
    107            int_mask.b.wkupintr = 1;
    108            int_mask.b.usbsuspend = 1; 
    109            
    110          #ifdef USE_OTG_MODE
    111            int_mask.b.otgintr = 1;
    112            int_mask.b.sessreqintr = 1;
    113            int_mask.b.conidstschng = 1;
    114          #endif
    115            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
    116          }
    117          
    118          /**
    119          * @brief  USB_OTG_CoreReset : Soft reset of the core
    120          * @param  pdev : Selected device
    121          * @retval USB_OTG_STS : status
    122          */
    123          static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
    124          {
    125            USB_OTG_STS status = USB_OTG_OK;
    126            __IO USB_OTG_GRSTCTL_TypeDef  greset;
    127            uint32_t count = 0;
    128            
    129            greset.d32 = 0;
    130            /* Wait for AHB master IDLE state. */
    131            do
    132            {
    133              USB_OTG_BSP_uDelay(3);
    134              greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
    135              if (++count > 200000)
    136              {
    137                return USB_OTG_OK;
    138              }
    139            }
    140            while (greset.b.ahbidle == 0);
    141            /* Core Soft Reset */
    142            count = 0;
    143            greset.b.csftrst = 1;
    144            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
    145            do
    146            {
    147              greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
    148              if (++count > 200000)
    149              {
    150                break;
    151              }
    152            }
    153            while (greset.b.csftrst == 1);
    154            /* Wait for 3 PHY Clocks*/
    155            USB_OTG_BSP_uDelay(3);
    156            return status;
    157          }
    158          
    159          /**
    160          * @brief  USB_OTG_WritePacket : Writes a packet into the Tx FIFO associated 
    161          *         with the EP
    162          * @param  pdev : Selected device
    163          * @param  src : source pointer
    164          * @param  ch_ep_num : end point number
    165          * @param  bytes : No. of bytes
    166          * @retval USB_OTG_STS : status
    167          */
    168          USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
    169                                          uint8_t             *src, 
    170                                          uint8_t             ch_ep_num, 
    171                                          uint16_t            len)
    172          {
    173            USB_OTG_STS status = USB_OTG_OK;
    174            if (pdev->cfg.dma_enable == 0)
    175            {
    176              uint32_t count32b= 0 , i= 0;
    177              __IO uint32_t *fifo;
    178              
    179              count32b =  (len + 3) / 4;
    180              fifo = pdev->regs.DFIFO[ch_ep_num];
    181              for (i = 0; i < count32b; i++, src+=4)
    182              {
    183                USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
    184              }
    185            }
    186            return status;
    187          }
    188          
    189          
    190          /**
    191          * @brief  USB_OTG_ReadPacket : Reads a packet from the Rx FIFO
    192          * @param  pdev : Selected device
    193          * @param  dest : Destination Pointer
    194          * @param  bytes : No. of bytes
    195          * @retval None
    196          */
    197          void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
    198                                   uint8_t *dest, 
    199                                   uint16_t len)
    200          {
    201            uint32_t i=0;
    202            uint32_t count32b = (len + 3) / 4;
    203            
    204            __IO uint32_t *fifo = pdev->regs.DFIFO[0];
    205            
    206            for ( i = 0; i < count32b; i++, dest += 4 )
    207            {
    208              *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
    209              
    210            }
    211            return ((void *)dest);
    212          }
    213          
    214          /**
    215          * @brief  USB_OTG_SelectCore 
    216          *         Initialize core registers address.
    217          * @param  pdev : Selected device
    218          * @param  coreID : USB OTG Core ID
    219          * @retval USB_OTG_STS : status
    220          */
    221          USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
    222                                         USB_OTG_CORE_ID_TypeDef coreID)
    223          {
    224            uint32_t i , baseAddress = 0;
    225            USB_OTG_STS status = USB_OTG_OK;
    226            
    227            pdev->cfg.dma_enable       = 0;
    228            
    229            /* at startup the core is in FS mode */
    230            pdev->cfg.speed            = USB_OTG_SPEED_FULL;
    231            pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
    232            
    233            /* initialize device cfg following its address */
    234            if (coreID == USB_OTG_FS_CORE_ID)
    235            {
    236              baseAddress                = USB_OTG_FS_BASE_ADDR;
    237              pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    238              pdev->cfg.host_channels    = 8 ;
    239              pdev->cfg.dev_endpoints    = 4 ;
    240              pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
    241              pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
    242              
    243          #ifdef USB_OTG_FS_SOF_OUTPUT_ENABLED    
    244              pdev->cfg.Sof_output       = 1;    
    245          #endif 
    246              
    247          #ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
    248              pdev->cfg.low_power        = 1;    
    249          #endif     
    250            }
    251            else if (coreID == USB_OTG_HS_CORE_ID)
    252            {
    253              baseAddress                = USB_OTG_HS_BASE_ADDR;
    254              pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    255              pdev->cfg.host_channels    = 12 ;
    256              pdev->cfg.dev_endpoints    = 6 ;
    257              pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
    258              
    259          #ifdef USB_OTG_ULPI_PHY_ENABLED
    260              pdev->cfg.phy_itface       = USB_OTG_ULPI_PHY;
    261          #else    
    262          #ifdef USB_OTG_EMBEDDED_PHY_ENABLED
    263              pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
    264          #endif  
    265          #endif      
    266              
    267          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
    268              pdev->cfg.dma_enable       = 1;    
    269          #endif
    270              
    271          #ifdef USB_OTG_HS_SOF_OUTPUT_ENABLED    
    272              pdev->cfg.Sof_output       = 1;    
    273          #endif 
    274              
    275          #ifdef USB_OTG_HS_LOW_PWR_MGMT_SUPPORT    
    276              pdev->cfg.low_power        = 1;    
    277          #endif 
    278              
    279            }
    280            
    281            pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    282              USB_OTG_CORE_GLOBAL_REGS_OFFSET);
    283            pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    284              USB_OTG_DEV_GLOBAL_REG_OFFSET);
    285            
    286            for (i = 0; i < pdev->cfg.dev_endpoints; i++)
    287            {
    288              pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
    289                (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
    290                  (i * USB_OTG_EP_REG_OFFSET));
    291              pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
    292                (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
    293                  (i * USB_OTG_EP_REG_OFFSET));
    294            }
    295            pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    296              USB_OTG_HOST_GLOBAL_REG_OFFSET);
    297            pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
    298            
    299            for (i = 0; i < pdev->cfg.host_channels; i++)
    300            {
    301              pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
    302                USB_OTG_HOST_CHAN_REGS_OFFSET + \
    303                  (i * USB_OTG_CHAN_REGS_OFFSET));
    304            }
    305            for (i = 0; i < pdev->cfg.host_channels; i++)
    306            {
    307              pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
    308                (i * USB_OTG_DATA_FIFO_SIZE));
    309            }
    310            pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
    311            
    312            return status;
    313          }
    314          
    315          
    316          /**
    317          * @brief  USB_OTG_CoreInit
    318          *         Initializes the USB_OTG controller registers and prepares the core
    319          *         device mode or host mode operation.
    320          * @param  pdev : Selected device
    321          * @retval USB_OTG_STS : status
    322          */
    323          USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
    324          {
    325            USB_OTG_STS status = USB_OTG_OK;
    326            USB_OTG_GUSBCFG_TypeDef  usbcfg;
    327            USB_OTG_GCCFG_TypeDef    gccfg;
    328            USB_OTG_GAHBCFG_TypeDef  ahbcfg;
    329            
    330            usbcfg.d32 = 0;
    331            gccfg.d32 = 0;
    332            ahbcfg.d32 = 0;
    333            
    334            
    335            
    336            if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
    337            {
    338              gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
    339              gccfg.b.pwdn = 0;
    340              
    341              if (pdev->cfg.Sof_output)
    342              {
    343                gccfg.b.sofouten = 1;   
    344              }
    345              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
    346              
    347              /* Init The ULPI Interface */
    348              usbcfg.d32 = 0;
    349              usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
    350              
    351              usbcfg.b.physel            = 0; /* HS Interface */
    352          #ifdef USB_OTG_INTERNAL_VBUS_ENABLED
    353              usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
    354          #else
    355          #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
    356              usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
    357          #endif
    358          #endif 
    359              usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
    360              
    361              usbcfg.b.ulpi_fsls = 0;
    362              usbcfg.b.ulpi_clk_sus_m = 0;
    363              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    364              
    365              /* Reset after a PHY select  */
    366              USB_OTG_CoreReset(pdev);
    367              
    368              if(pdev->cfg.dma_enable == 1)
    369              {
    370                
    371                ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
    372                ahbcfg.b.dmaenable = 1;
    373                USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
    374                
    375              }    
    376            }
    377            else /* FS interface (embedded Phy) */
    378            {
    379              
    380              usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
    381              usbcfg.b.physel  = 1; /* FS Interface */
    382              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    383              /* Reset after a PHY select and set Host mode */
    384              USB_OTG_CoreReset(pdev);
    385              /* Deactivate the power down*/
    386              gccfg.d32 = 0;
    387              gccfg.b.pwdn = 1;
    388              
    389              gccfg.b.vbussensingA = 1 ;
    390              gccfg.b.vbussensingB = 1 ;     
    391          #ifndef VBUS_SENSING_ENABLED
    392              gccfg.b.disablevbussensing = 1; 
    393          #endif    
    394              
    395              if(pdev->cfg.Sof_output)
    396              {
    397                gccfg.b.sofouten = 1;  
    398              }
    399              
    400              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
    401              USB_OTG_BSP_mDelay(20);
    402            }
    403            /* case the HS core is working in FS mode */
    404            if(pdev->cfg.dma_enable == 1)
    405            {
    406              
    407              ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
    408              ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
    409              ahbcfg.b.dmaenable = 1;
    410              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
    411              
    412            }
    413            /* initialize OTG features */
    414          #ifdef  USE_OTG_MODE
    415            usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
    416            usbcfg.b.hnpcap = 1;
    417            usbcfg.b.srpcap = 1;
    418            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    419            USB_OTG_EnableCommonInt(pdev);
    420          #endif
    421            return status;
    422          }
    423          /**
    424          * @brief  USB_OTG_EnableGlobalInt
    425          *         Enables the controller's Global Int in the AHB Config reg
    426          * @param  pdev : Selected device
    427          * @retval USB_OTG_STS : status
    428          */
    429          USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
    430          {
    431            USB_OTG_STS status = USB_OTG_OK;
    432            USB_OTG_GAHBCFG_TypeDef  ahbcfg;
    433            
    434            ahbcfg.d32 = 0;
    435            ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
    436            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
    437            return status;
    438          }
    439          
    440          
    441          /**
    442          * @brief  USB_OTG_DisableGlobalInt
    443          *         Enables the controller's Global Int in the AHB Config reg
    444          * @param  pdev : Selected device
    445          * @retval USB_OTG_STS : status
    446          */
    447          USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
    448          {
    449            USB_OTG_STS status = USB_OTG_OK;
    450            USB_OTG_GAHBCFG_TypeDef  ahbcfg;
    451            ahbcfg.d32 = 0;
    452            ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
    453            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
    454            return status;
    455          }
    456          
    457          
    458          /**
    459          * @brief  USB_OTG_FlushTxFifo : Flush a Tx FIFO
    460          * @param  pdev : Selected device
    461          * @param  num : FO num
    462          * @retval USB_OTG_STS : status
    463          */
    464          USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
    465          {
    466            USB_OTG_STS status = USB_OTG_OK;
    467            __IO USB_OTG_GRSTCTL_TypeDef  greset;
    468            
    469            uint32_t count = 0;
    470            greset.d32 = 0;
    471            greset.b.txfflsh = 1;
    472            greset.b.txfnum  = num;
    473            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
    474            do
    475            {
    476              greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
    477              if (++count > 200000)
    478              {
    479                break;
    480              }
    481            }
    482            while (greset.b.txfflsh == 1);
    483            /* Wait for 3 PHY Clocks*/
    484            USB_OTG_BSP_uDelay(3);
    485            return status;
    486          }
    487          
    488          
    489          /**
    490          * @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
    491          * @param  pdev : Selected device
    492          * @retval USB_OTG_STS : status
    493          */
    494          USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
    495          {
    496            USB_OTG_STS status = USB_OTG_OK;
    497            __IO USB_OTG_GRSTCTL_TypeDef  greset;
    498            uint32_t count = 0;
    499            
    500            greset.d32 = 0;
    501            greset.b.rxfflsh = 1;
    502            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
    503            do
    504            {
    505              greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
    506              if (++count > 200000)
    507              {
    508                break;
    509              }
    510            }
    511            while (greset.b.rxfflsh == 1);
    512            /* Wait for 3 PHY Clocks*/
    513            USB_OTG_BSP_uDelay(3);
    514            return status;
    515          }
    516          
    517          
    518          /**
    519          * @brief  USB_OTG_SetCurrentMode : Set ID line
    520          * @param  pdev : Selected device
    521          * @param  mode :  (Host/device)
    522          * @retval USB_OTG_STS : status
    523          */
    524          USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
    525          {
    526            USB_OTG_STS status = USB_OTG_OK;
    527            USB_OTG_GUSBCFG_TypeDef  usbcfg;
    528            
    529            usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
    530            
    531            usbcfg.b.force_host = 0;
    532            usbcfg.b.force_dev = 0;
    533            
    534            if ( mode == HOST_MODE)
    535            {
    536              usbcfg.b.force_host = 1;
    537            }
    538            else if ( mode == DEVICE_MODE)
    539            {
    540              usbcfg.b.force_dev = 1;
    541            }
    542            
    543            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    544            USB_OTG_BSP_mDelay(50);
    545            return status;
    546          }
    547          
    548          
    549          /**
    550          * @brief  USB_OTG_GetMode : Get current mode
    551          * @param  pdev : Selected device
    552          * @retval current mode
    553          */
    554          uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
    555          {
    556            return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
    557          }
    558          
    559          
    560          /**
    561          * @brief  USB_OTG_IsDeviceMode : Check if it is device mode
    562          * @param  pdev : Selected device
    563          * @retval num_in_ep
    564          */
    565          uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
    566          {
    567            return (USB_OTG_GetMode(pdev) != HOST_MODE);
    568          }
    569          
    570          
    571          /**
    572          * @brief  USB_OTG_IsHostMode : Check if it is host mode
    573          * @param  pdev : Selected device
    574          * @retval num_in_ep
    575          */
    576          uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
    577          {
    578            return (USB_OTG_GetMode(pdev) == HOST_MODE);
    579          }
    580          
    581          
    582          /**
    583          * @brief  USB_OTG_ReadCoreItr : returns the Core Interrupt register
    584          * @param  pdev : Selected device
    585          * @retval Status
    586          */
    587          uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
    588          {
    589            uint32_t v = 0;
    590            v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
    591            v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
    592            return v;
    593          }
    594          
    595          
    596          /**
    597          * @brief  USB_OTG_ReadOtgItr : returns the USB_OTG Interrupt register
    598          * @param  pdev : Selected device
    599          * @retval Status
    600          */
    601          uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
    602          {
    603            return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
    604          }
    605          
    606          #ifdef USE_HOST_MODE
    607          /**
    608          * @brief  USB_OTG_CoreInitHost : Initializes USB_OTG controller for host mode
    609          * @param  pdev : Selected device
    610          * @retval status
    611          */
    612          USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
    613          {
    614            USB_OTG_STS                     status = USB_OTG_OK;
    615            USB_OTG_FSIZ_TypeDef            nptxfifosize;
    616            USB_OTG_FSIZ_TypeDef            ptxfifosize;  
    617            USB_OTG_HCFG_TypeDef            hcfg;
    618            
    619          #ifdef USE_OTG_MODE
    620            USB_OTG_OTGCTL_TypeDef          gotgctl;
    621          #endif
    622            
    623            uint32_t                        i = 0;
    624            
    625            nptxfifosize.d32 = 0;  
    626            ptxfifosize.d32 = 0;
    627          #ifdef USE_OTG_MODE
    628            gotgctl.d32 = 0;
    629          #endif
    630            hcfg.d32 = 0;
    631            
    632            
    633            /* configure charge pump IO */
    634            USB_OTG_BSP_ConfigVBUS(pdev);
    635            
    636            /* Restart the Phy Clock */
    637            USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
    638            
    639            /* Initialize Host Configuration Register */
    640            if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
    641            {
    642              USB_OTG_InitFSLSPClkSel(pdev , HCFG_30_60_MHZ); 
    643            }
    644            else
    645            {
    646              USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); 
    647            }
    648            USB_OTG_ResetPort(pdev);
    649            
    650            hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
    651            hcfg.b.fslssupp = 0;
    652            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
    653            
    654            /* Configure data FIFO sizes */
    655            /* Rx FIFO */
    656          #ifdef USB_OTG_FS_CORE
    657            if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
    658            {
    659              /* set Rx FIFO size */
    660              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
    661              nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
    662              nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
    663              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
    664              
    665              ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
    666              ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
    667              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
    668            }
    669          #endif
    670          #ifdef USB_OTG_HS_CORE  
    671            if (pdev->cfg.coreID == USB_OTG_HS_CORE_ID)
    672            {
    673              /* set Rx FIFO size */
    674              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
    675              nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;   
    676              nptxfifosize.b.depth = TXH_NP_HS_FIFOSIZ;  
    677              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
    678              
    679              ptxfifosize.b.startaddr = RX_FIFO_HS_SIZE + TXH_NP_HS_FIFOSIZ;
    680              ptxfifosize.b.depth     = TXH_P_HS_FIFOSIZ;
    681              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
    682            }
    683          #endif  
    684            
    685          #ifdef USE_OTG_MODE
    686            /* Clear Host Set HNP Enable in the USB_OTG Control Register */
    687            gotgctl.b.hstsethnpen = 1;
    688            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
    689          #endif
    690            
    691            /* Make sure the FIFOs are flushed. */
    692            USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
    693            USB_OTG_FlushRxFifo(pdev);
    694            
    695            
    696            /* Clear all pending HC Interrupts */
    697            for (i = 0; i < pdev->cfg.host_channels; i++)
    698            {
    699              USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
    700              USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINTMSK, 0 );
    701            }
    702          #ifndef USE_OTG_MODE
    703            USB_OTG_DriveVbus(pdev, 1);
    704          #endif
    705            
    706            USB_OTG_EnableHostInt(pdev);
    707            return status;
    708          }
    709          
    710          /**
    711          * @brief  USB_OTG_IsEvenFrame 
    712          *         This function returns the frame number for sof packet
    713          * @param  pdev : Selected device
    714          * @retval Frame number
    715          */
    716          uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
    717          {
    718            return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
    719          }
    720          
    721          /**
    722          * @brief  USB_OTG_DriveVbus : set/reset vbus
    723          * @param  pdev : Selected device
    724          * @param  state : VBUS state
    725          * @retval None
    726          */
    727          void USB_OTG_DriveVbus (USB_OTG_CORE_HANDLE *pdev, uint8_t state)
    728          {
    729            USB_OTG_HPRT0_TypeDef     hprt0;
    730            
    731            hprt0.d32 = 0;
    732            
    733            /* enable disable the external charge pump */
    734            USB_OTG_BSP_DriveVBUS(pdev, state);
    735            
    736            /* Turn on the Host port power. */
    737            hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
    738            if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
    739            {
    740              hprt0.b.prtpwr = 1;
    741              USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
    742            }
    743            if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
    744            {
    745              hprt0.b.prtpwr = 0;
    746              USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
    747            }
    748            
    749            USB_OTG_BSP_mDelay(200);
    750          }
    751          /**
    752          * @brief  USB_OTG_EnableHostInt: Enables the Host mode interrupts
    753          * @param  pdev : Selected device
    754          * @retval USB_OTG_STS : status
    755          */
    756          USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
    757          {
    758            USB_OTG_STS       status = USB_OTG_OK;
    759            USB_OTG_GINTMSK_TypeDef  intmsk;
    760            intmsk.d32 = 0;
    761            /* Disable all interrupts. */
    762            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
    763            
    764            /* Clear any pending interrupts. */
    765            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
    766            
    767            /* Enable the common interrupts */
    768            USB_OTG_EnableCommonInt(pdev);
    769            
    770            if (pdev->cfg.dma_enable == 0)
    771            {  
    772              intmsk.b.rxstsqlvl  = 1;
    773            }  
    774            intmsk.b.portintr   = 1;
    775            intmsk.b.hcintr     = 1;
    776            intmsk.b.disconnect = 1;  
    777            intmsk.b.sofintr    = 1;  
    778            intmsk.b.incomplisoout  = 1; 
    779            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
    780            return status;
    781          }
    782          
    783          /**
    784          * @brief  USB_OTG_InitFSLSPClkSel : Initializes the FSLSPClkSel field of the 
    785          *         HCFG register on the PHY type
    786          * @param  pdev : Selected device
    787          * @param  freq : clock frequency
    788          * @retval None
    789          */
    790          void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
    791          {
    792            USB_OTG_HCFG_TypeDef   hcfg;
    793            
    794            hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
    795            hcfg.b.fslspclksel = freq;
    796            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
    797          }
    798          
    799          
    800          /**
    801          * @brief  USB_OTG_ReadHPRT0 : Reads HPRT0 to modify later
    802          * @param  pdev : Selected device
    803          * @retval HPRT0 value
    804          */
    805          uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
    806          {
    807            USB_OTG_HPRT0_TypeDef  hprt0;
    808            
    809            hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
    810            hprt0.b.prtena = 0;
    811            hprt0.b.prtconndet = 0;
    812            hprt0.b.prtenchng = 0;
    813            hprt0.b.prtovrcurrchng = 0;
    814            return hprt0.d32;
    815          }
    816          
    817          
    818          /**
    819          * @brief  USB_OTG_ReadHostAllChannels_intr : Register PCD Callbacks
    820          * @param  pdev : Selected device
    821          * @retval Status
    822          */
    823          uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
    824          {
    825            return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
    826          }
    827          
    828          
    829          /**
    830          * @brief  USB_OTG_ResetPort : Reset Host Port
    831          * @param  pdev : Selected device
    832          * @retval status
    833          * @note : (1)The application must wait at least 10 ms (+ 10 ms security)
    834          *   before clearing the reset bit.
    835          */
    836          uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
    837          {
    838            USB_OTG_HPRT0_TypeDef  hprt0;
    839            
    840            hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
    841            hprt0.b.prtrst = 1;
    842            USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
    843            USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
    844            hprt0.b.prtrst = 0;
    845            USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
    846            USB_OTG_BSP_mDelay (20);   
    847            return 1;
    848          }
    849          
    850          
    851          /**
    852          * @brief  USB_OTG_HC_Init : Prepares a host channel for transferring packets
    853          * @param  pdev : Selected device
    854          * @param  hc_num : channel number
    855          * @retval USB_OTG_STS : status
    856          */
    857          USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
    858          {
    859            USB_OTG_STS status = USB_OTG_OK;
    860            uint32_t intr_enable = 0;
    861            USB_OTG_HCINTMSK_TypeDef  hcintmsk;
    862            USB_OTG_GINTMSK_TypeDef    gintmsk;
    863            USB_OTG_HCCHAR_TypeDef     hcchar;
    864            USB_OTG_HCINTn_TypeDef     hcint;
    865            
    866            
    867            gintmsk.d32 = 0;
    868            hcintmsk.d32 = 0;
    869            hcchar.d32 = 0;
    870            
    871            /* Clear old interrupt conditions for this host channel. */
    872            hcint.d32 = 0xFFFFFFFF;
    873            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
    874            
    875            /* Enable channel interrupts required for this transfer. */
    876            hcintmsk.d32 = 0;
    877            
    878            if (pdev->cfg.dma_enable == 1)
    879            {
    880              hcintmsk.b.ahberr = 1;
    881            }
    882            
    883            switch (pdev->host.hc[hc_num].ep_type) 
    884            {
    885            case EP_TYPE_CTRL:
    886            case EP_TYPE_BULK:
    887              hcintmsk.b.xfercompl = 1;
    888              hcintmsk.b.stall = 1;
    889              hcintmsk.b.xacterr = 1;
    890              hcintmsk.b.datatglerr = 1;
    891              hcintmsk.b.nak = 1;  
    892              if (pdev->host.hc[hc_num].ep_is_in) 
    893              {
    894                hcintmsk.b.bblerr = 1;
    895              } 
    896              else 
    897              {
    898                hcintmsk.b.nyet = 1;
    899                if (pdev->host.hc[hc_num].do_ping) 
    900                {
    901                  hcintmsk.b.ack = 1;
    902                }
    903              }
    904              break;
    905            case EP_TYPE_INTR:
    906              hcintmsk.b.xfercompl = 1;
    907              hcintmsk.b.nak = 1;
    908              hcintmsk.b.stall = 1;
    909              hcintmsk.b.xacterr = 1;
    910              hcintmsk.b.datatglerr = 1;
    911              hcintmsk.b.frmovrun = 1;
    912              
    913              if (pdev->host.hc[hc_num].ep_is_in) 
    914              {
    915                hcintmsk.b.bblerr = 1;
    916              }
    917              
    918              break;
    919            case EP_TYPE_ISOC:
    920              hcintmsk.b.xfercompl = 1;
    921              hcintmsk.b.frmovrun = 1;
    922              hcintmsk.b.ack = 1;
    923              
    924              if (pdev->host.hc[hc_num].ep_is_in) 
    925              {
    926                hcintmsk.b.xacterr = 1;
    927                hcintmsk.b.bblerr = 1;
    928              }
    929              break;
    930            }
    931            
    932            
    933            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINTMSK, hcintmsk.d32);
    934            
    935            
    936            /* Enable the top level host channel interrupt. */
    937            intr_enable = (1 << hc_num);
    938            USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
    939            
    940            /* Make sure host channel interrupts are enabled. */
    941            gintmsk.b.hcintr = 1;
    942            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
    943            
    944            /* Program the HCCHAR register */
    945            hcchar.d32 = 0;
    946            hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
    947            hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
    948            hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
    949            hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
    950            hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
    951            hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
    952            if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
    953            {
    954              hcchar.b.oddfrm  = 1;
    955            }
    956            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
    957            return status;
    958          }
    959          
    960          
    961          /**
    962          * @brief  USB_OTG_HC_StartXfer : Start transfer
    963          * @param  pdev : Selected device
    964          * @param  hc_num : channel number
    965          * @retval USB_OTG_STS : status
    966          */
    967          USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
    968          {
    969            USB_OTG_STS status = USB_OTG_OK;
    970            USB_OTG_HCCHAR_TypeDef   hcchar;
    971            USB_OTG_HCTSIZn_TypeDef  hctsiz;
    972            USB_OTG_HNPTXSTS_TypeDef hnptxsts; 
    973            USB_OTG_HPTXSTS_TypeDef  hptxsts; 
    974            USB_OTG_GINTMSK_TypeDef  intmsk;
    975            uint16_t                 len_words = 0;   
    976            
    977            uint16_t num_packets;
    978            uint16_t max_hc_pkt_count;
    979            
    980            max_hc_pkt_count = 256;
    981            hctsiz.d32 = 0;
    982            hcchar.d32 = 0;
    983            intmsk.d32 = 0;
    984            
    985            /* Compute the expected number of packets associated to the transfer */
    986            if (pdev->host.hc[hc_num].xfer_len > 0)
    987            {
    988              num_packets = (pdev->host.hc[hc_num].xfer_len + \
    989                pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
    990              
    991              if (num_packets > max_hc_pkt_count)
    992              {
    993                num_packets = max_hc_pkt_count;
    994                pdev->host.hc[hc_num].xfer_len = num_packets * \
    995                  pdev->host.hc[hc_num].max_packet;
    996              }
    997            }
    998            else
    999            {
   1000              num_packets = 1;
   1001            }
   1002            if (pdev->host.hc[hc_num].ep_is_in)
   1003            {
   1004              pdev->host.hc[hc_num].xfer_len = num_packets * \
   1005                pdev->host.hc[hc_num].max_packet;
   1006            }
   1007            /* Initialize the HCTSIZn register */
   1008            hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
   1009            hctsiz.b.pktcnt = num_packets;
   1010            hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
   1011            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
   1012            
   1013            if (pdev->cfg.dma_enable == 1)
   1014            {
   1015              USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
   1016            }
   1017            
   1018            
   1019            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
   1020            hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
   1021            
   1022            /* Set host channel enable */
   1023            hcchar.b.chen = 1;
   1024            hcchar.b.chdis = 0;
   1025            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
   1026            
   1027            if (pdev->cfg.dma_enable == 0) /* Slave mode */
   1028            {  
   1029              if((pdev->host.hc[hc_num].ep_is_in == 0) && 
   1030                 (pdev->host.hc[hc_num].xfer_len > 0))
   1031              {
   1032                switch(pdev->host.hc[hc_num].ep_type) 
   1033                {
   1034                  /* Non periodic transfer */
   1035                case EP_TYPE_CTRL:
   1036                case EP_TYPE_BULK:
   1037                  
   1038                  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
   1039                  len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
   1040                  
   1041                  /* check if there is enough space in FIFO space */
   1042                  if(len_words > hnptxsts.b.nptxfspcavail)
   1043                  {
   1044                    /* need to process data in nptxfempty interrupt */
   1045                    intmsk.b.nptxfempty = 1;
   1046                    USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
   1047                  }
   1048                  
   1049                  break;
   1050                  /* Periodic transfer */
   1051                case EP_TYPE_INTR:
   1052                case EP_TYPE_ISOC:
   1053                  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
   1054                  len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
   1055                  /* check if there is enough space in FIFO space */
   1056                  if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
   1057                  {
   1058                    /* need to process data in ptxfempty interrupt */
   1059                    intmsk.b.ptxfempty = 1;
   1060                    USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
   1061                  }
   1062                  break;
   1063                  
   1064                default:
   1065                  break;
   1066                }
   1067                
   1068                /* Write packet into the Tx FIFO. */
   1069                USB_OTG_WritePacket(pdev, 
   1070                                    pdev->host.hc[hc_num].xfer_buff , 
   1071                                    hc_num, pdev->host.hc[hc_num].xfer_len);
   1072              }
   1073            }
   1074            return status;
   1075          }
   1076          
   1077          
   1078          /**
   1079          * @brief  USB_OTG_HC_Halt : Halt channel
   1080          * @param  pdev : Selected device
   1081          * @param  hc_num : channel number
   1082          * @retval USB_OTG_STS : status
   1083          */
   1084          USB_OTG_STS USB_OTG_HC_Halt(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
   1085          {
   1086            USB_OTG_STS status = USB_OTG_OK;
   1087            USB_OTG_HNPTXSTS_TypeDef            nptxsts;
   1088            USB_OTG_HPTXSTS_TypeDef             hptxsts;
   1089            USB_OTG_HCCHAR_TypeDef              hcchar;
   1090            
   1091            nptxsts.d32 = 0;
   1092            hptxsts.d32 = 0;
   1093            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
   1094            hcchar.b.chen = 1;
   1095            hcchar.b.chdis = 1;
   1096            
   1097            /* Check for space in the request queue to issue the halt. */
   1098            if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
   1099            {
   1100              nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
   1101              if (nptxsts.b.nptxqspcavail == 0)
   1102              {
   1103                hcchar.b.chen = 0;
   1104              }
   1105            }
   1106            else
   1107            {
   1108              hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
   1109              if (hptxsts.b.ptxqspcavail == 0)
   1110              {
   1111                hcchar.b.chen = 0;
   1112              }
   1113            }
   1114            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
   1115            return status;
   1116          }
   1117          
   1118          /**
   1119          * @brief  Issue a ping token
   1120          * @param  None
   1121          * @retval : None
   1122          */
   1123          USB_OTG_STS USB_OTG_HC_DoPing(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
   1124          {
   1125            USB_OTG_STS               status = USB_OTG_OK;
   1126            USB_OTG_HCCHAR_TypeDef    hcchar;
   1127            USB_OTG_HCTSIZn_TypeDef   hctsiz;  
   1128            
   1129            hctsiz.d32 = 0;
   1130            hctsiz.b.dopng = 1;
   1131            hctsiz.b.pktcnt = 1;
   1132            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
   1133            
   1134            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
   1135            hcchar.b.chen = 1;
   1136            hcchar.b.chdis = 0;
   1137            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
   1138            return status;  
   1139          }
   1140          
   1141          /**
   1142          * @brief  Stop the device and clean up fifo's
   1143          * @param  None
   1144          * @retval : None
   1145          */
   1146          void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
   1147          {
   1148            USB_OTG_HCCHAR_TypeDef  hcchar;
   1149            uint32_t                i;
   1150            
   1151            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
   1152            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
   1153            /* Flush out any leftover queued requests. */
   1154            
   1155            for (i = 0; i < pdev->cfg.host_channels; i++)
   1156            {
   1157              hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
   1158              hcchar.b.chen = 0;
   1159              hcchar.b.chdis = 1;
   1160              hcchar.b.epdir = 0;
   1161              USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
   1162            }
   1163            
   1164            /* Flush the FIFO */
   1165            USB_OTG_FlushRxFifo(pdev);
   1166            USB_OTG_FlushTxFifo(pdev ,  0x10 );  
   1167          }
   1168          #endif
   1169          #ifdef USE_DEVICE_MODE
   1170          /*         PCD Core Layer       */
   1171          
   1172          /**
   1173          * @brief  USB_OTG_InitDevSpeed :Initializes the DevSpd field of DCFG register 
   1174          *         depending the PHY type and the enumeration speed of the device.
   1175          * @param  pdev : Selected device
   1176          * @retval : None
   1177          */
   1178          void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
   1179          {
   1180            USB_OTG_DCFG_TypeDef   dcfg;
   1181            
   1182            dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
   1183            dcfg.b.devspd = speed;
   1184            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
   1185          }
   1186          
   1187          
   1188          /**
   1189          * @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
   1190          *         for device mode
   1191          * @param  pdev : Selected device
   1192          * @retval USB_OTG_STS : status
   1193          */
   1194          USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
   1195          {
   1196            USB_OTG_STS             status       = USB_OTG_OK;
   1197            USB_OTG_DEPCTL_TypeDef  depctl;
   1198            uint32_t i;
   1199            USB_OTG_DCFG_TypeDef    dcfg;
   1200            USB_OTG_FSIZ_TypeDef    nptxfifosize;
   1201            USB_OTG_FSIZ_TypeDef    txfifosize;
   1202            USB_OTG_DIEPMSK_TypeDef msk;
   1203            USB_OTG_DTHRCTL_TypeDef dthrctl;  
   1204            
   1205            depctl.d32 = 0;
   1206            dcfg.d32 = 0;
   1207            nptxfifosize.d32 = 0;
   1208            txfifosize.d32 = 0;
   1209            msk.d32 = 0;
   1210            
   1211            /* Restart the Phy Clock */
   1212            USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
   1213            /* Device configuration register */
   1214            dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
   1215            dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
   1216            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
   1217            
   1218          #ifdef USB_OTG_FS_CORE
   1219            if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
   1220            {  
   1221              
   1222              /* Set Full speed phy */
   1223              USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
   1224              
   1225              /* set Rx FIFO size */
   1226              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
   1227              
   1228              /* EP0 TX*/
   1229              nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
   1230              nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
   1231              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
   1232              
   1233              
   1234              /* EP1 TX*/
   1235              txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
   1236              txfifosize.b.depth = TX1_FIFO_FS_SIZE;
   1237              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
   1238              
   1239              
   1240              /* EP2 TX*/
   1241              txfifosize.b.startaddr += txfifosize.b.depth;
   1242              txfifosize.b.depth = TX2_FIFO_FS_SIZE;
   1243              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
   1244              
   1245              
   1246              /* EP3 TX*/  
   1247              txfifosize.b.startaddr += txfifosize.b.depth;
   1248              txfifosize.b.depth = TX3_FIFO_FS_SIZE;
   1249              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
   1250            }
   1251          #endif
   1252          #ifdef USB_OTG_HS_CORE
   1253            if(pdev->cfg.coreID == USB_OTG_HS_CORE_ID  )
   1254            {
   1255              
   1256              /* Set High speed phy */
   1257              
   1258              if(pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY)
   1259              {
   1260                USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH);
   1261              }
   1262              else /* set High speed phy in Full speed mode */
   1263              {
   1264                USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH_IN_FULL);
   1265              }
   1266              
   1267              /* set Rx FIFO size */
   1268              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
   1269              
   1270              /* EP0 TX*/
   1271              nptxfifosize.b.depth     = TX0_FIFO_HS_SIZE;
   1272              nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;
   1273              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
   1274              
   1275              
   1276              /* EP1 TX*/
   1277              txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
   1278              txfifosize.b.depth = TX1_FIFO_HS_SIZE;
   1279              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
   1280              
   1281              
   1282              /* EP2 TX*/
   1283              txfifosize.b.startaddr += txfifosize.b.depth;
   1284              txfifosize.b.depth = TX2_FIFO_HS_SIZE;
   1285              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
   1286              
   1287              
   1288              /* EP3 TX*/  
   1289              txfifosize.b.startaddr += txfifosize.b.depth;
   1290              txfifosize.b.depth = TX3_FIFO_HS_SIZE;
   1291              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
   1292              
   1293              /* EP4 TX*/
   1294              txfifosize.b.startaddr += txfifosize.b.depth;
   1295              txfifosize.b.depth = TX4_FIFO_HS_SIZE;
   1296              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[3], txfifosize.d32 );
   1297              
   1298              
   1299              /* EP5 TX*/  
   1300              txfifosize.b.startaddr += txfifosize.b.depth;
   1301              txfifosize.b.depth = TX5_FIFO_HS_SIZE;
   1302              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
   1303            }
   1304          #endif  
   1305            /* Flush the FIFOs */
   1306            USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
   1307            USB_OTG_FlushRxFifo(pdev);
   1308            /* Clear all pending Device Interrupts */
   1309            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
   1310            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
   1311            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
   1312            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
   1313            
   1314            for (i = 0; i < pdev->cfg.dev_endpoints; i++)
   1315            {
   1316              depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
   1317              if (depctl.b.epena)
   1318              {
   1319                depctl.d32 = 0;
   1320                depctl.b.epdis = 1;
   1321                depctl.b.snak = 1;
   1322              }
   1323              else
   1324              {
   1325                depctl.d32 = 0;
   1326              }
   1327              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
   1328              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
   1329              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
   1330            }
   1331            for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
   1332            {
   1333              USB_OTG_DEPCTL_TypeDef  depctl;
   1334              depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
   1335              if (depctl.b.epena)
   1336              {
   1337                depctl.d32 = 0;
   1338                depctl.b.epdis = 1;
   1339                depctl.b.snak = 1;
   1340              }
   1341              else
   1342              {
   1343                depctl.d32 = 0;
   1344              }
   1345              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
   1346              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
   1347              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
   1348            }
   1349            msk.d32 = 0;
   1350            msk.b.txfifoundrn = 1;
   1351            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
   1352            
   1353            if (pdev->cfg.dma_enable == 1)
   1354            {
   1355              dthrctl.d32 = 0;
   1356              dthrctl.b.non_iso_thr_en = 1;
   1357              dthrctl.b.iso_thr_en = 1;
   1358              dthrctl.b.tx_thr_len = 64;
   1359              dthrctl.b.rx_thr_en = 1;
   1360              dthrctl.b.rx_thr_len = 64;
   1361              USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
   1362            }
   1363            USB_OTG_EnableDevInt(pdev);
   1364            return status;
   1365          }
   1366          
   1367          
   1368          /**
   1369          * @brief  USB_OTG_EnableDevInt : Enables the Device mode interrupts
   1370          * @param  pdev : Selected device
   1371          * @retval USB_OTG_STS : status
   1372          */
   1373          USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
   1374          {
   1375            USB_OTG_STS status = USB_OTG_OK;
   1376            USB_OTG_GINTMSK_TypeDef  intmsk;
   1377            
   1378            intmsk.d32 = 0;
   1379            
   1380            /* Disable all interrupts. */
   1381            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
   1382            /* Clear any pending interrupts */
   1383            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
   1384            /* Enable the common interrupts */
   1385            USB_OTG_EnableCommonInt(pdev);
   1386            
   1387            if (pdev->cfg.dma_enable == 0)
   1388            {
   1389              intmsk.b.rxstsqlvl = 1;
   1390            }
   1391            
   1392            /* Enable interrupts matching to the Device mode ONLY */
   1393            intmsk.b.usbsuspend = 1;
   1394            intmsk.b.usbreset   = 1;
   1395            intmsk.b.enumdone   = 1;
   1396            intmsk.b.inepintr   = 1;
   1397            intmsk.b.outepintr  = 1;
   1398            intmsk.b.sofintr    = 1; 
   1399            
   1400            intmsk.b.incomplisoin    = 1; 
   1401            intmsk.b.incomplisoout    = 1;   
   1402          #ifdef VBUS_SENSING_ENABLED
   1403            intmsk.b.sessreqintr    = 1; 
   1404            intmsk.b.otgintr    = 1;    
   1405          #endif  
   1406            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
   1407            return status;
   1408          }
   1409          
   1410          
   1411          /**
   1412          * @brief  USB_OTG_GetDeviceSpeed
   1413          *         Get the device speed from the device status register
   1414          * @param  None
   1415          * @retval status
   1416          */
   1417          enum USB_OTG_SPEED USB_OTG_GetDeviceSpeed (USB_OTG_CORE_HANDLE *pdev)
   1418          {
   1419            USB_OTG_DSTS_TypeDef  dsts;
   1420            enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
   1421            
   1422            
   1423            dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   1424            
   1425            switch (dsts.b.enumspd)
   1426            {
   1427            case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
   1428              speed = USB_SPEED_HIGH;
   1429              break;
   1430            case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
   1431            case DSTS_ENUMSPD_FS_PHY_48MHZ:
   1432              speed = USB_SPEED_FULL;
   1433              break;
   1434              
   1435            case DSTS_ENUMSPD_LS_PHY_6MHZ:
   1436              speed = USB_SPEED_LOW;
   1437              break;
   1438            }
   1439            
   1440            return speed;
   1441          }
   1442          /**
   1443          * @brief  enables EP0 OUT to receive SETUP packets and configures EP0
   1444          *   for transmitting packets
   1445          * @param  None
   1446          * @retval USB_OTG_STS : status
   1447          */
   1448          USB_OTG_STS  USB_OTG_EP0Activate(USB_OTG_CORE_HANDLE *pdev)
   1449          {
   1450            USB_OTG_STS             status = USB_OTG_OK;
   1451            USB_OTG_DSTS_TypeDef    dsts;
   1452            USB_OTG_DEPCTL_TypeDef  diepctl;
   1453            USB_OTG_DCTL_TypeDef    dctl;
   1454            
   1455            dctl.d32 = 0;
   1456            /* Read the Device Status and Endpoint 0 Control registers */
   1457            dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   1458            diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
   1459            /* Set the MPS of the IN EP based on the enumeration speed */
   1460            switch (dsts.b.enumspd)
   1461            {
   1462            case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
   1463            case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
   1464            case DSTS_ENUMSPD_FS_PHY_48MHZ:
   1465              diepctl.b.mps = DEP0CTL_MPS_64;
   1466              break;
   1467            case DSTS_ENUMSPD_LS_PHY_6MHZ:
   1468              diepctl.b.mps = DEP0CTL_MPS_8;
   1469              break;
   1470            }
   1471            USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
   1472            dctl.b.cgnpinnak = 1;
   1473            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
   1474            return status;
   1475          }
   1476          
   1477          
   1478          /**
   1479          * @brief  USB_OTG_EPActivate : Activates an EP
   1480          * @param  pdev : Selected device
   1481          * @retval USB_OTG_STS : status
   1482          */
   1483          USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1484          {
   1485            USB_OTG_STS status = USB_OTG_OK;
   1486            USB_OTG_DEPCTL_TypeDef  depctl;
   1487            USB_OTG_DAINT_TypeDef  daintmsk;
   1488            __IO uint32_t *addr;
   1489            
   1490            
   1491            depctl.d32 = 0;
   1492            daintmsk.d32 = 0;
   1493            /* Read DEPCTLn register */
   1494            if (ep->is_in == 1)
   1495            {
   1496              addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
   1497              daintmsk.ep.in = 1 << ep->num;
   1498            }
   1499            else
   1500            {
   1501              addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
   1502              daintmsk.ep.out = 1 << ep->num;
   1503            }
   1504            /* If the EP is already active don't change the EP Control
   1505            * register. */
   1506            depctl.d32 = USB_OTG_READ_REG32(addr);
   1507            if (!depctl.b.usbactep)
   1508            {
   1509              depctl.b.mps    = ep->maxpacket;
   1510              depctl.b.eptype = ep->type;
   1511              depctl.b.txfnum = ep->tx_fifo_num;
   1512              depctl.b.setd0pid = 1;
   1513              depctl.b.usbactep = 1;
   1514              USB_OTG_WRITE_REG32(addr, depctl.d32);
   1515            }
   1516            /* Enable the Interrupt for this EP */
   1517          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
   1518            if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
   1519            {
   1520              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
   1521            }
   1522            else
   1523          #endif   
   1524              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
   1525            return status;
   1526          }
   1527          
   1528          
   1529          /**
   1530          * @brief  USB_OTG_EPDeactivate : Deactivates an EP
   1531          * @param  pdev : Selected device
   1532          * @retval USB_OTG_STS : status
   1533          */
   1534          USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1535          {
   1536            USB_OTG_STS status = USB_OTG_OK;
   1537            USB_OTG_DEPCTL_TypeDef  depctl;
   1538            USB_OTG_DAINT_TypeDef  daintmsk;
   1539            __IO uint32_t *addr;
   1540            
   1541            depctl.d32 = 0;
   1542            daintmsk.d32 = 0;  
   1543            /* Read DEPCTLn register */
   1544            if (ep->is_in == 1)
   1545            {
   1546              addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
   1547              daintmsk.ep.in = 1 << ep->num;
   1548            }
   1549            else
   1550            {
   1551              addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
   1552              daintmsk.ep.out = 1 << ep->num;
   1553            }
   1554            depctl.b.usbactep = 0;
   1555            USB_OTG_WRITE_REG32(addr, depctl.d32);
   1556            /* Disable the Interrupt for this EP */
   1557            
   1558          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
   1559            if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
   1560            {
   1561              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
   1562            }
   1563            else
   1564          #endif    
   1565              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
   1566            return status;
   1567          }
   1568          
   1569          
   1570          /**
   1571          * @brief  USB_OTG_EPStartXfer : Handle the setup for data xfer for an EP and 
   1572          *         starts the xfer
   1573          * @param  pdev : Selected device
   1574          * @retval USB_OTG_STS : status
   1575          */
   1576          USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1577          {
   1578            USB_OTG_STS status = USB_OTG_OK;
   1579            USB_OTG_DEPCTL_TypeDef     depctl;
   1580            USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
   1581            USB_OTG_DSTS_TypeDef       dsts;    
   1582            uint32_t fifoemptymsk = 0;  
   1583            
   1584            depctl.d32 = 0;
   1585            deptsiz.d32 = 0;
   1586            /* IN endpoint */
   1587            if (ep->is_in == 1)
   1588            {
   1589              depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
   1590              deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
   1591              /* Zero Length Packet? */
   1592              if (ep->xfer_len == 0)
   1593              {
   1594                deptsiz.b.xfersize = 0;
   1595                deptsiz.b.pktcnt = 1;
   1596              }
   1597              else
   1598              {
   1599                /* Program the transfer size and packet count
   1600                * as follows: xfersize = N * maxpacket +
   1601                * short_packet pktcnt = N + (short_packet
   1602                * exist ? 1 : 0)
   1603                */
   1604                deptsiz.b.xfersize = ep->xfer_len;
   1605                deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
   1606                
   1607                if (ep->type == EP_TYPE_ISOC)
   1608                {
   1609                  deptsiz.b.mc = 1;
   1610                }       
   1611              }
   1612              USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
   1613              
   1614              if (pdev->cfg.dma_enable == 1)
   1615              {
   1616                USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
   1617              }
   1618              else
   1619              {
   1620                if (ep->type != EP_TYPE_ISOC)
   1621                {
   1622                  /* Enable the Tx FIFO Empty Interrupt for this EP */
   1623                  if (ep->xfer_len > 0)
   1624                  {
   1625                    fifoemptymsk = 1 << ep->num;
   1626                    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
   1627                  }
   1628                }
   1629              }
   1630              
   1631              
   1632              if (ep->type == EP_TYPE_ISOC)
   1633              {
   1634                dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   1635                
   1636                if (((dsts.b.soffn)&0x1) == 0)
   1637                {
   1638                  depctl.b.setd1pid = 1;
   1639                }
   1640                else
   1641                {
   1642                  depctl.b.setd0pid = 1;
   1643                }
   1644              } 
   1645              
   1646              /* EP enable, IN data in FIFO */
   1647              depctl.b.cnak = 1;
   1648              depctl.b.epena = 1;
   1649              USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
   1650              
   1651              if (ep->type == EP_TYPE_ISOC)
   1652              {
   1653                USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
   1654              }    
   1655            }
   1656            else
   1657            {
   1658              /* OUT endpoint */
   1659              depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
   1660              deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
   1661              /* Program the transfer size and packet count as follows:
   1662              * pktcnt = N
   1663              * xfersize = N * maxpacket
   1664              */
   1665              if (ep->xfer_len == 0)
   1666              {
   1667                deptsiz.b.xfersize = ep->maxpacket;
   1668                deptsiz.b.pktcnt = 1;
   1669              }
   1670              else
   1671              {
   1672                deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
   1673                deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
   1674              }
   1675              USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
   1676              
   1677              if (pdev->cfg.dma_enable == 1)
   1678              {
   1679                USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
   1680              }
   1681              
   1682              if (ep->type == EP_TYPE_ISOC)
   1683              {
   1684                if (ep->even_odd_frame)
   1685                {
   1686                  depctl.b.setd1pid = 1;
   1687                }
   1688                else
   1689                {
   1690                  depctl.b.setd0pid = 1;
   1691                }
   1692              }
   1693              /* EP enable */
   1694              depctl.b.cnak = 1;
   1695              depctl.b.epena = 1;
   1696              USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
   1697            }
   1698            return status;
   1699          }
   1700          
   1701          
   1702          /**
   1703          * @brief  USB_OTG_EP0StartXfer : Handle the setup for a data xfer for EP0 and 
   1704          *         starts the xfer
   1705          * @param  pdev : Selected device
   1706          * @retval USB_OTG_STS : status
   1707          */
   1708          USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1709          {
   1710            USB_OTG_STS                 status = USB_OTG_OK;
   1711            USB_OTG_DEPCTL_TypeDef      depctl;
   1712            USB_OTG_DEP0XFRSIZ_TypeDef  deptsiz;
   1713            USB_OTG_INEPREGS          *in_regs;
   1714            uint32_t fifoemptymsk = 0;
   1715            
   1716            depctl.d32   = 0;
   1717            deptsiz.d32  = 0;
   1718            /* IN endpoint */
   1719            if (ep->is_in == 1)
   1720            {
   1721              in_regs = pdev->regs.INEP_REGS[0];
   1722              depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
   1723              deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
   1724              /* Zero Length Packet? */
   1725              if (ep->xfer_len == 0)
   1726              {
   1727                deptsiz.b.xfersize = 0;
   1728                deptsiz.b.pktcnt = 1;
   1729                
   1730              }
   1731              else
   1732              {
   1733                if (ep->xfer_len > ep->maxpacket)
   1734                {
   1735                  ep->xfer_len = ep->maxpacket;
   1736                  deptsiz.b.xfersize = ep->maxpacket;
   1737                }
   1738                else
   1739                {
   1740                  deptsiz.b.xfersize = ep->xfer_len;
   1741                }
   1742                deptsiz.b.pktcnt = 1;
   1743              }
   1744              USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
   1745              
   1746              if (pdev->cfg.dma_enable == 1)
   1747              {
   1748                USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
   1749              }
   1750              
   1751              /* EP enable, IN data in FIFO */
   1752              depctl.b.cnak = 1;
   1753              depctl.b.epena = 1;
   1754              USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
   1755              
   1756              
   1757              
   1758              if (pdev->cfg.dma_enable == 0)
   1759              {
   1760                /* Enable the Tx FIFO Empty Interrupt for this EP */
   1761                if (ep->xfer_len > 0)
   1762                {
   1763                  {
   1764                    fifoemptymsk |= 1 << ep->num;
   1765                    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
   1766                  }
   1767                }
   1768              }
   1769            }
   1770            else
   1771            {
   1772              /* OUT endpoint */
   1773              depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   1774              deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
   1775              /* Program the transfer size and packet count as follows:
   1776              * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
   1777              * pktcnt = N           */
   1778              if (ep->xfer_len == 0)
   1779              {
   1780                deptsiz.b.xfersize = ep->maxpacket;
   1781                deptsiz.b.pktcnt = 1;
   1782              }
   1783              else
   1784              {
   1785                ep->xfer_len = ep->maxpacket;
   1786                deptsiz.b.xfersize = ep->maxpacket;
   1787                deptsiz.b.pktcnt = 1;
   1788              }
   1789              USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
   1790              if (pdev->cfg.dma_enable == 1)
   1791              {
   1792                USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
   1793              }
   1794              /* EP enable */
   1795              depctl.b.cnak = 1;
   1796              depctl.b.epena = 1;
   1797              USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
   1798              
   1799            }
   1800            return status;
   1801          }
   1802          
   1803          
   1804          /**
   1805          * @brief  USB_OTG_EPSetStall : Set the EP STALL
   1806          * @param  pdev : Selected device
   1807          * @retval USB_OTG_STS : status
   1808          */
   1809          USB_OTG_STS USB_OTG_EPSetStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1810          {
   1811            USB_OTG_STS status = USB_OTG_OK;
   1812            USB_OTG_DEPCTL_TypeDef  depctl;
   1813            __IO uint32_t *depctl_addr;
   1814            
   1815            depctl.d32 = 0;
   1816            if (ep->is_in == 1)
   1817            {
   1818              depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
   1819              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   1820              /* set the disable and stall bits */
   1821              if (depctl.b.epena)
   1822              {
   1823                depctl.b.epdis = 1;
   1824              }
   1825              depctl.b.stall = 1;
   1826              USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
   1827            }
   1828            else
   1829            {
   1830              depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   1831              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   1832              /* set the stall bit */
   1833              depctl.b.stall = 1;
   1834              USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
   1835            }
   1836            return status;
   1837          }
   1838          
   1839          
   1840          /**
   1841          * @brief  Clear the EP STALL
   1842          * @param  pdev : Selected device
   1843          * @retval USB_OTG_STS : status
   1844          */
   1845          USB_OTG_STS USB_OTG_EPClearStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1846          {
   1847            USB_OTG_STS status = USB_OTG_OK;
   1848            USB_OTG_DEPCTL_TypeDef  depctl;
   1849            __IO uint32_t *depctl_addr;
   1850            
   1851            depctl.d32 = 0;
   1852            
   1853            if (ep->is_in == 1)
   1854            {
   1855              depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
   1856            }
   1857            else
   1858            {
   1859              depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   1860            }
   1861            depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   1862            /* clear the stall bits */
   1863            depctl.b.stall = 0;
   1864            if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
   1865            {
   1866              depctl.b.setd0pid = 1; /* DATA0 */
   1867            }
   1868            USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
   1869            return status;
   1870          }
   1871          
   1872          
   1873          /**
   1874          * @brief  USB_OTG_ReadDevAllOutEp_itr : returns OUT endpoint interrupt bits
   1875          * @param  pdev : Selected device
   1876          * @retval OUT endpoint interrupt bits
   1877          */
   1878          uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
   1879          {
   1880            uint32_t v;
   1881            v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
   1882            v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
   1883            return ((v & 0xffff0000) >> 16);
   1884          }
   1885          
   1886          
   1887          /**
   1888          * @brief  USB_OTG_ReadDevOutEP_itr : returns Device OUT EP Interrupt register
   1889          * @param  pdev : Selected device
   1890          * @param  ep : end point number
   1891          * @retval Device OUT EP Interrupt register
   1892          */
   1893          uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
   1894          {
   1895            uint32_t v;
   1896            v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
   1897            v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
   1898            return v;
   1899          }
   1900          
   1901          
   1902          /**
   1903          * @brief  USB_OTG_ReadDevAllInEPItr : Get int status register
   1904          * @param  pdev : Selected device
   1905          * @retval int status register
   1906          */
   1907          uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
   1908          {
   1909            uint32_t v;
   1910            v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
   1911            v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
   1912            return (v & 0xffff);
   1913          }
   1914          
   1915          /**
   1916          * @brief  configures EPO to receive SETUP packets
   1917          * @param  None
   1918          * @retval : None
   1919          */
   1920          void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
   1921          {
   1922            USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
   1923            doeptsize0.d32 = 0;
   1924            doeptsize0.b.supcnt = 3;
   1925            doeptsize0.b.pktcnt = 1;
   1926            doeptsize0.b.xfersize = 8 * 3;
   1927            USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
   1928            
   1929            if (pdev->cfg.dma_enable == 1)
   1930            {
   1931              USB_OTG_DEPCTL_TypeDef  doepctl;
   1932              doepctl.d32 = 0;
   1933              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
   1934                                  (uint32_t)&pdev->dev.setup_packet);
   1935              
   1936              /* EP enable */
   1937              doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
   1938              doepctl.b.epena = 1;
   1939              doepctl.d32 = 0x80008000;
   1940              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
   1941            }
   1942          }
   1943          
   1944          /**
   1945          * @brief  USB_OTG_RemoteWakeup : active remote wakeup signalling
   1946          * @param  None
   1947          * @retval : None
   1948          */
   1949          void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
   1950          {
   1951            
   1952            USB_OTG_DCTL_TypeDef     dctl;
   1953            USB_OTG_DSTS_TypeDef     dsts;
   1954            USB_OTG_PCGCCTL_TypeDef  power;  
   1955            
   1956            if (pdev->dev.DevRemoteWakeup) 
   1957            {
   1958              dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   1959              if(dsts.b.suspsts == 1)
   1960              {
   1961                if(pdev->cfg.low_power)
   1962                {
   1963                  /* un-gate USB Core clock */
   1964                  power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
   1965                  power.b.gatehclk = 0;
   1966                  power.b.stoppclk = 0;
   1967                  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
   1968                }   
   1969                /* active Remote wakeup signaling */
   1970                dctl.d32 = 0;
   1971                dctl.b.rmtwkupsig = 1;
   1972                USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, 0, dctl.d32);
   1973                USB_OTG_BSP_mDelay(5);
   1974                USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
   1975              }
   1976            }
   1977          }
   1978          
   1979          
   1980          /**
   1981          * @brief  USB_OTG_UngateClock : active USB Core clock
   1982          * @param  None
   1983          * @retval : None
   1984          */
   1985          void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
   1986          {
   1987            if(pdev->cfg.low_power)
   1988            {
   1989              
   1990              USB_OTG_DSTS_TypeDef     dsts;
   1991              USB_OTG_PCGCCTL_TypeDef  power; 
   1992              
   1993              dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   1994              
   1995              if(dsts.b.suspsts == 1)
   1996              {
   1997                /* un-gate USB Core clock */
   1998                power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
   1999                power.b.gatehclk = 0;
   2000                power.b.stoppclk = 0;
   2001                USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
   2002                
   2003              }
   2004            }
   2005          }
   2006          
   2007          /**
   2008          * @brief  Stop the device and clean up fifo's
   2009          * @param  None
   2010          * @retval : None
   2011          */
   2012          void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
   2013          {
   2014            uint32_t i;
   2015            
   2016            pdev->dev.device_status = 1;
   2017            
   2018            for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
   2019            {
   2020              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
   2021              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
   2022            }
   2023            
   2024            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
   2025            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
   2026            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
   2027            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
   2028            
   2029            /* Flush the FIFO */
   2030            USB_OTG_FlushRxFifo(pdev);
   2031            USB_OTG_FlushTxFifo(pdev ,  0x10 );  
   2032          }
   2033          
   2034          /**
   2035          * @brief  returns the EP Status
   2036          * @param  pdev : Selected device
   2037          *         ep : endpoint structure
   2038          * @retval : EP status
   2039          */
   2040          
   2041          uint32_t USB_OTG_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,USB_OTG_EP *ep)
   2042          {
   2043            USB_OTG_DEPCTL_TypeDef  depctl;
   2044            __IO uint32_t *depctl_addr;
   2045            uint32_t Status = 0;  
   2046            
   2047            depctl.d32 = 0;
   2048            if (ep->is_in == 1)
   2049            {
   2050              depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
   2051              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   2052              
   2053              if (depctl.b.stall == 1)  
   2054                Status = USB_OTG_EP_TX_STALL;
   2055              else if (depctl.b.naksts == 1)
   2056                Status = USB_OTG_EP_TX_NAK;
   2057              else 
   2058                Status = USB_OTG_EP_TX_VALID;     
   2059              
   2060            }
   2061            else
   2062            {
   2063              depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   2064              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   2065              if (depctl.b.stall == 1)  
   2066                Status = USB_OTG_EP_RX_STALL;
   2067              else if (depctl.b.naksts == 1)
   2068                Status = USB_OTG_EP_RX_NAK;
   2069              else 
   2070                Status = USB_OTG_EP_RX_VALID; 
   2071            } 
   2072            
   2073            /* Return the current status */
   2074            return Status;
   2075          }
   2076          
   2077          /**
   2078          * @brief  Set the EP Status
   2079          * @param  pdev : Selected device
   2080          *         Status : new Status
   2081          *         ep : EP structure
   2082          * @retval : None
   2083          */
   2084          void USB_OTG_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep , uint32_t Status)
   2085          {
   2086            USB_OTG_DEPCTL_TypeDef  depctl;
   2087            __IO uint32_t *depctl_addr;
   2088            
   2089            depctl.d32 = 0;
   2090            
   2091            /* Process for IN endpoint */
   2092            if (ep->is_in == 1)
   2093            {
   2094              depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
   2095              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   2096              
   2097              if (Status == USB_OTG_EP_TX_STALL)  
   2098              {
   2099                USB_OTG_EPSetStall(pdev, ep); return;
   2100              }
   2101              else if (Status == USB_OTG_EP_TX_NAK)
   2102                depctl.b.snak = 1;
   2103              else if (Status == USB_OTG_EP_TX_VALID)
   2104              {
   2105                if (depctl.b.stall == 1)
   2106                {  
   2107                  ep->even_odd_frame = 0;
   2108                  USB_OTG_EPClearStall(pdev, ep);
   2109                  return;
   2110                }      
   2111                depctl.b.cnak = 1;
   2112                depctl.b.usbactep = 1; 
   2113                depctl.b.epena = 1;
   2114              }
   2115              else if (Status == USB_OTG_EP_TX_DIS)
   2116                depctl.b.usbactep = 0;
   2117            } 
   2118            else /* Process for OUT endpoint */
   2119            {
   2120              depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   2121              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
   2122              
   2123              if (Status == USB_OTG_EP_RX_STALL)  {
   2124                depctl.b.stall = 1;
   2125              }
   2126              else if (Status == USB_OTG_EP_RX_NAK)
   2127                depctl.b.snak = 1;
   2128              else if (Status == USB_OTG_EP_RX_VALID)
   2129              {
   2130                if (depctl.b.stall == 1)
   2131                {  
   2132                  ep->even_odd_frame = 0;
   2133                  USB_OTG_EPClearStall(pdev, ep);
   2134                  return;
   2135                }  
   2136                depctl.b.cnak = 1;
   2137                depctl.b.usbactep = 1;    
   2138                depctl.b.epena = 1;
   2139              }
   2140              else if (Status == USB_OTG_EP_RX_DIS)
   2141              {
   2142                depctl.b.usbactep = 0;    
   2143              }
   2144            }
   2145            
   2146            USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
   2147          }
   2148          
   2149          #endif
   2150          /**
   2151          * @}
   2152          */ 
   2153          
   2154          /**
   2155          * @}
   2156          */ 
   2157          
   2158          /**
   2159          * @}
   2160          */
   2161          
   2162          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  USB_OTG_ActiveRemoteWakeup
              8 -> USB_OTG_BSP_mDelay
        8  USB_OTG_CoreInit
              8 -> USB_OTG_BSP_mDelay
              8 -> USB_OTG_CoreReset
       24  USB_OTG_CoreInitDev
             24 -> USB_OTG_EnableDevInt
             24 -> USB_OTG_FlushRxFifo
             24 -> USB_OTG_FlushTxFifo
             24 -> USB_OTG_InitDevSpeed
       24  USB_OTG_CoreReset
             24 -> USB_OTG_BSP_uDelay
        0  USB_OTG_DisableGlobalInt
        0  USB_OTG_EP0Activate
       28  USB_OTG_EP0StartXfer
        0  USB_OTG_EP0_OutStart
       12  USB_OTG_EPActivate
        0  USB_OTG_EPClearStall
        8  USB_OTG_EPDeactivate
        0  USB_OTG_EPSetStall
       24  USB_OTG_EPStartXfer
             24 -> USB_OTG_WritePacket
        8  USB_OTG_EnableDevInt
        0  USB_OTG_EnableGlobalInt
        8  USB_OTG_FlushRxFifo
              8 -> USB_OTG_BSP_uDelay
        8  USB_OTG_FlushTxFifo
              8 -> USB_OTG_BSP_uDelay
        0  USB_OTG_GetDeviceSpeed
        0  USB_OTG_GetEPStatus
        0  USB_OTG_GetMode
        0  USB_OTG_InitDevSpeed
        8  USB_OTG_IsDeviceMode
              8 -> USB_OTG_GetMode
        8  USB_OTG_IsHostMode
              8 -> USB_OTG_GetMode
        0  USB_OTG_ReadCoreItr
        0  USB_OTG_ReadDevAllInEPItr
        0  USB_OTG_ReadDevAllOutEp_itr
        0  USB_OTG_ReadDevOutEP_itr
        0  USB_OTG_ReadOtgItr
        8  USB_OTG_ReadPacket
       12  USB_OTG_SelectCore
        8  USB_OTG_SetCurrentMode
              8 -> USB_OTG_BSP_mDelay
        8  USB_OTG_SetEPStatus
              0 -> USB_OTG_EPClearStall
              8 -> USB_OTG_EPSetStall
        8  USB_OTG_StopDevice
              8 -> USB_OTG_FlushRxFifo
              0 -> USB_OTG_FlushTxFifo
        0  USB_OTG_UngateClock
       12  USB_OTG_WritePacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       6  ?Subroutine0
      10  ?Subroutine1
      12  ?Subroutine2
      62  USB_OTG_ActiveRemoteWakeup
     118  USB_OTG_CoreInit
     252  USB_OTG_CoreInitDev
      74  USB_OTG_CoreReset
       8  USB_OTG_DisableGlobalInt
      52  USB_OTG_EP0Activate
     208  USB_OTG_EP0StartXfer
      32  USB_OTG_EP0_OutStart
      96  USB_OTG_EPActivate
      40  USB_OTG_EPClearStall
      44  USB_OTG_EPDeactivate
      40  USB_OTG_EPSetStall
     290  USB_OTG_EPStartXfer
      52  USB_OTG_EnableDevInt
      10  USB_OTG_EnableGlobalInt
      32  USB_OTG_FlushRxFifo
      42  USB_OTG_FlushTxFifo
      40  USB_OTG_GetDeviceSpeed
      66  USB_OTG_GetEPStatus
      10  USB_OTG_GetMode
      18  USB_OTG_InitDevSpeed
      18  USB_OTG_IsDeviceMode
      14  USB_OTG_IsHostMode
      10  USB_OTG_ReadCoreItr
      12  USB_OTG_ReadDevAllInEPItr
      12  USB_OTG_ReadDevAllOutEp_itr
      16  USB_OTG_ReadDevOutEP_itr
       6  USB_OTG_ReadOtgItr
      36  USB_OTG_ReadPacket
     188  USB_OTG_SelectCore
      38  USB_OTG_SetCurrentMode
     108  USB_OTG_SetEPStatus
      74  USB_OTG_StopDevice
      28  USB_OTG_UngateClock
      42  USB_OTG_WritePacket

 
 2 256 bytes in section .text
 
 2 256 bytes of CODE memory

Errors: none
Warnings: none
