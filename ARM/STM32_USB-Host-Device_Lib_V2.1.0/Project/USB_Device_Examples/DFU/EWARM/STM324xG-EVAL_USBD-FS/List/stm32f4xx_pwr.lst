###############################################################################
#                                                                             #
#                                                       19/Sep/2012  16:16:09 #
# IAR ANSI C/C++ Compiler V6.40.2.33884/W32 KICKSTART for ARM                 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32F4xx_StdPeriph_Driver #
#                    \src\stm32f4xx_pwr.c                                     #
#    Command line =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32F4xx_StdPeriph_Driver #
#                    \src\stm32f4xx_pwr.c -D USE_STDPERIPH_DRIVER -D          #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_USB_OTG_FS -lcN    #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\ -o                         #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\ --debug --endian=little     #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.4           #
#                    Kickstart\arm\INC\c\DLib_Config_Full.h" -I               #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM3 #
#                    2_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples #
#                    \DFU\EWARM\..\inc\ -I \\psf\Home\Documents\Eclipse\Works #
#                    pace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_De #
#                    vice_Examples\DFU\EWARM\..\..\..\..\Libraries\CMSIS\Devi #
#                    ce\ST\STM32F4xx\Include\ -I                              #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\  #
#                    -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB- #
#                    Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\E #
#                    WARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\in #
#                    c\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_U #
#                    SB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DF #
#                    U\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\C #
#                    lass\dfu\inc\ -I \\psf\Home\Documents\Eclipse\Workspace\ #
#                    ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_ #
#                    Examples\DFU\EWARM\..\..\..\..\Utilities\STM32_EVAL\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\Common\ -I            #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\    #
#                    -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.4                           #
#                    Kickstart\arm\CMSIS\Include\"                            #
#    List file    =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\stm32f4xx_pwr.lst           #
#    Object file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\stm32f4xx_pwr.o              #
#                                                                             #
#                                                                             #
###############################################################################

\\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_pwr.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_pwr.c
      4            * @author  MCD Application Team
      5            * @version V1.0.2
      6            * @date    05-March-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Power Controller (PWR) peripheral:           
      9            *           - Backup Domain Access
     10            *           - PVD configuration
     11            *           - WakeUp pin configuration
     12            *           - Main and Backup Regulators configuration
     13            *           - FLASH Power Down configuration
     14            *           - Low Power modes configuration
     15            *           - Flags management
     16            *               
     17            ******************************************************************************
     18            * @attention
     19            *
     20            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     21            *
     22            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     23            * You may not use this file except in compliance with the License.
     24            * You may obtain a copy of the License at:
     25            *
     26            *        http://www.st.com/software_license_agreement_liberty_v2
     27            *
     28            * Unless required by applicable law or agreed to in writing, software 
     29            * distributed under the License is distributed on an "AS IS" BASIS, 
     30            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     31            * See the License for the specific language governing permissions and
     32            * limitations under the License.
     33            *
     34            ******************************************************************************
     35            */ 
     36          
     37          /* Includes ------------------------------------------------------------------*/
     38          #include "stm32f4xx_pwr.h"
     39          #include "stm32f4xx_rcc.h"
     40          
     41          /** @addtogroup STM32F4xx_StdPeriph_Driver
     42            * @{
     43            */
     44          
     45          /** @defgroup PWR 
     46            * @brief PWR driver modules
     47            * @{
     48            */ 
     49          
     50          /* Private typedef -----------------------------------------------------------*/
     51          /* Private define ------------------------------------------------------------*/
     52          /* --------- PWR registers bit address in the alias region ---------- */
     53          #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
     54          
     55          /* --- CR Register ---*/
     56          
     57          /* Alias word address of DBP bit */
     58          #define CR_OFFSET                (PWR_OFFSET + 0x00)
     59          #define DBP_BitNumber            0x08
     60          #define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
     61          
     62          /* Alias word address of PVDE bit */
     63          #define PVDE_BitNumber           0x04
     64          #define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
     65          
     66          /* Alias word address of FPDS bit */
     67          #define FPDS_BitNumber           0x09
     68          #define CR_FPDS_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (FPDS_BitNumber * 4))
     69          
     70          /* Alias word address of PMODE bit */
     71          #define PMODE_BitNumber           0x0E
     72          #define CR_PMODE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PMODE_BitNumber * 4))
     73          
     74          
     75          /* --- CSR Register ---*/
     76          
     77          /* Alias word address of EWUP bit */
     78          #define CSR_OFFSET               (PWR_OFFSET + 0x04)
     79          #define EWUP_BitNumber           0x08
     80          #define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
     81          
     82          /* Alias word address of BRE bit */
     83          #define BRE_BitNumber            0x09
     84          #define CSR_BRE_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (BRE_BitNumber * 4))
     85          
     86          /* ------------------ PWR registers bit mask ------------------------ */
     87          
     88          /* CR register bit mask */
     89          #define CR_DS_MASK               ((uint32_t)0xFFFFFFFC)
     90          #define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
     91          
     92          /* Private macro -------------------------------------------------------------*/
     93          /* Private variables ---------------------------------------------------------*/
     94          /* Private function prototypes -----------------------------------------------*/
     95          /* Private functions ---------------------------------------------------------*/
     96          
     97          /** @defgroup PWR_Private_Functions
     98            * @{
     99            */
    100          
    101          /** @defgroup PWR_Group1 Backup Domain Access function 
    102           *  @brief   Backup Domain Access function  
    103           *
    104          @verbatim   
    105           ===============================================================================
    106                                      Backup Domain Access function 
    107           ===============================================================================  
    108          
    109            After reset, the backup domain (RTC registers, RTC backup data 
    110            registers and backup SRAM) is protected against possible unwanted 
    111            write accesses. 
    112            To enable access to the RTC Domain and RTC registers, proceed as follows:
    113              - Enable the Power Controller (PWR) APB1 interface clock using the
    114                RCC_APB1PeriphClockCmd() function.
    115              - Enable access to RTC domain using the PWR_BackupAccessCmd() function.
    116          
    117          @endverbatim
    118            * @{
    119            */
    120          
    121          /**
    122            * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
    123            * @param  None
    124            * @retval None
    125            */
    126          void PWR_DeInit(void)
    127          {
    128            RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
    129            RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
    130          }
    131          
    132          /**
    133            * @brief  Enables or disables access to the backup domain (RTC registers, RTC 
    134            *         backup data registers and backup SRAM).
    135            * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
    136            *         Backup Domain Access should be kept enabled.
    137            * @param  NewState: new state of the access to the backup domain.
    138            *          This parameter can be: ENABLE or DISABLE.
    139            * @retval None
    140            */
    141          void PWR_BackupAccessCmd(FunctionalState NewState)
    142          {
    143            /* Check the parameters */
    144            assert_param(IS_FUNCTIONAL_STATE(NewState));
    145            
    146            *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
    147          }
    148          
    149          /**
    150            * @}
    151            */
    152          
    153          /** @defgroup PWR_Group2 PVD configuration functions
    154           *  @brief   PVD configuration functions 
    155           *
    156          @verbatim   
    157           ===============================================================================
    158                                     PVD configuration functions
    159           ===============================================================================  
    160          
    161           - The PVD is used to monitor the VDD power supply by comparing it to a threshold
    162             selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
    163           - A PVDO flag is available to indicate if VDD/VDDA is higher or lower than the 
    164             PVD threshold. This event is internally connected to the EXTI line16
    165             and can generate an interrupt if enabled through the EXTI registers.
    166           - The PVD is stopped in Standby mode.
    167          
    168          @endverbatim
    169            * @{
    170            */
    171          
    172          /**
    173            * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
    174            * @param  PWR_PVDLevel: specifies the PVD detection level
    175            *          This parameter can be one of the following values:
    176            *            @arg PWR_PVDLevel_0
    177            *            @arg PWR_PVDLevel_1
    178            *            @arg PWR_PVDLevel_2
    179            *            @arg PWR_PVDLevel_3
    180            *            @arg PWR_PVDLevel_4
    181            *            @arg PWR_PVDLevel_5
    182            *            @arg PWR_PVDLevel_6
    183            *            @arg PWR_PVDLevel_7
    184            * @note   Refer to the electrical characteristics of your device datasheet for
    185            *         more details about the voltage threshold corresponding to each 
    186            *         detection level.
    187            * @retval None
    188            */
    189          void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
    190          {
    191            uint32_t tmpreg = 0;
    192            
    193            /* Check the parameters */
    194            assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
    195            
    196            tmpreg = PWR->CR;
    197            
    198            /* Clear PLS[7:5] bits */
    199            tmpreg &= CR_PLS_MASK;
    200            
    201            /* Set PLS[7:5] bits according to PWR_PVDLevel value */
    202            tmpreg |= PWR_PVDLevel;
    203            
    204            /* Store the new value */
    205            PWR->CR = tmpreg;
    206          }
    207          
    208          /**
    209            * @brief  Enables or disables the Power Voltage Detector(PVD).
    210            * @param  NewState: new state of the PVD.
    211            *         This parameter can be: ENABLE or DISABLE.
    212            * @retval None
    213            */
    214          void PWR_PVDCmd(FunctionalState NewState)
    215          {
    216            /* Check the parameters */
    217            assert_param(IS_FUNCTIONAL_STATE(NewState));
    218            
    219            *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
    220          }
    221          
    222          /**
    223            * @}
    224            */
    225          
    226          /** @defgroup PWR_Group3 WakeUp pin configuration functions
    227           *  @brief   WakeUp pin configuration functions 
    228           *
    229          @verbatim   
    230           ===============================================================================
    231                              WakeUp pin configuration functions
    232           ===============================================================================  
    233          
    234           - WakeUp pin is used to wakeup the system from Standby mode. This pin is 
    235             forced in input pull down configuration and is active on rising edges.
    236           - There is only one WakeUp pin: WakeUp Pin 1 on PA.00.
    237          
    238          @endverbatim
    239            * @{
    240            */
    241          
    242          /**
    243            * @brief  Enables or disables the WakeUp Pin functionality.
    244            * @param  NewState: new state of the WakeUp Pin functionality.
    245            *         This parameter can be: ENABLE or DISABLE.
    246            * @retval None
    247            */
    248          void PWR_WakeUpPinCmd(FunctionalState NewState)
    249          {
    250            /* Check the parameters */  
    251            assert_param(IS_FUNCTIONAL_STATE(NewState));
    252          
    253            *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
    254          }
    255          
    256          /**
    257            * @}
    258            */
    259          
    260          /** @defgroup PWR_Group4 Main and Backup Regulators configuration functions
    261           *  @brief   Main and Backup Regulators configuration functions 
    262           *
    263          @verbatim   
    264           ===============================================================================
    265                              Main and Backup Regulators configuration functions
    266           ===============================================================================  
    267          
    268           - The backup domain includes 4 Kbytes of backup SRAM accessible only from the 
    269             CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is retained 
    270             even in Standby or VBAT mode when the low power backup regulator is enabled. 
    271             It can be considered as an internal EEPROM when VBAT is always present.
    272             You can use the PWR_BackupRegulatorCmd() function to enable the low power
    273             backup regulator and use the PWR_GetFlagStatus(PWR_FLAG_BRR) to check if it is
    274             ready or not. 
    275          
    276           - When the backup domain is supplied by VDD (analog switch connected to VDD) 
    277             the backup SRAM is powered from VDD which replaces the VBAT power supply to 
    278             save battery life.
    279          
    280           - The backup SRAM is not mass erased by an tamper event. It is read protected 
    281             to prevent confidential data, such as cryptographic private key, from being 
    282             accessed. The backup SRAM can be erased only through the Flash interface when
    283             a protection level change from level 1 to level 0 is requested. 
    284             Refer to the description of Read protection (RDP) in the Flash programming manual.
    285          
    286           - The main internal regulator can be configured to have a tradeoff between performance
    287             and power consumption when the device does not operate at the maximum frequency. 
    288             This is done through PWR_MainRegulatorModeConfig() function which configure VOS bit
    289             in PWR_CR register: 
    290                - When this bit is set (Regulator voltage output Scale 1 mode selected) the System
    291                  frequency can go up to 168 MHz. 
    292                - When this bit is reset (Regulator voltage output Scale 2 mode selected) the System
    293                  frequency can go up to 144 MHz. 
    294             Refer to the datasheets for more details.
    295                     
    296          @endverbatim
    297            * @{
    298            */
    299          
    300          /**
    301            * @brief  Enables or disables the Backup Regulator.
    302            * @param  NewState: new state of the Backup Regulator.
    303            *          This parameter can be: ENABLE or DISABLE.
    304            * @retval None
    305            */
    306          void PWR_BackupRegulatorCmd(FunctionalState NewState)
    307          {
    308            /* Check the parameters */
    309            assert_param(IS_FUNCTIONAL_STATE(NewState));
    310          
    311            *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
    312          }
    313          
    314          /**
    315            * @brief  Configures the main internal regulator output voltage.
    316            * @param  PWR_Regulator_Voltage: specifies the regulator output voltage to achieve
    317            *         a tradeoff between performance and power consumption when the device does
    318            *         not operate at the maximum frequency (refer to the datasheets for more details).
    319            *          This parameter can be one of the following values:
    320            *            @arg PWR_Regulator_Voltage_Scale1: Regulator voltage output Scale 1 mode, 
    321            *                                                System frequency up to 168 MHz. 
    322            *            @arg PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, 
    323            *                                                System frequency up to 144 MHz.    
    324            * @retval None
    325            */
    326          void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
    327          {
    328            /* Check the parameters */
    329            assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
    330          
    331            if (PWR_Regulator_Voltage == PWR_Regulator_Voltage_Scale2)
    332            {
    333              PWR->CR &= ~PWR_Regulator_Voltage_Scale1;
    334            }
    335            else
    336            {    
    337              PWR->CR |= PWR_Regulator_Voltage_Scale1;
    338            }
    339          }
    340          
    341          /**
    342            * @}
    343            */
    344          
    345          /** @defgroup PWR_Group5 FLASH Power Down configuration functions
    346           *  @brief   FLASH Power Down configuration functions 
    347           *
    348          @verbatim   
    349           ===============================================================================
    350                     FLASH Power Down configuration functions
    351           ===============================================================================  
    352          
    353           - By setting the FPDS bit in the PWR_CR register by using the PWR_FlashPowerDownCmd()
    354             function, the Flash memory also enters power down mode when the device enters 
    355             Stop mode. When the Flash memory is in power down mode, an additional startup 
    356             delay is incurred when waking up from Stop mode.
    357          
    358          @endverbatim
    359            * @{
    360            */
    361          
    362          /**
    363            * @brief  Enables or disables the Flash Power Down in STOP mode.
    364            * @param  NewState: new state of the Flash power mode.
    365            *          This parameter can be: ENABLE or DISABLE.
    366            * @retval None
    367            */
    368          void PWR_FlashPowerDownCmd(FunctionalState NewState)
    369          {
    370            /* Check the parameters */
    371            assert_param(IS_FUNCTIONAL_STATE(NewState));
    372          
    373            *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
    374          }
    375          
    376          /**
    377            * @}
    378            */
    379          
    380          /** @defgroup PWR_Group6 Low Power modes configuration functions
    381           *  @brief   Low Power modes configuration functions 
    382           *
    383          @verbatim   
    384           ===============================================================================
    385                              Low Power modes configuration functions
    386           ===============================================================================  
    387          
    388            The devices feature 3 low-power modes:
    389             - Sleep mode: Cortex-M4 core stopped, peripherals kept running.
    390             - Stop mode: all clocks are stopped, regulator running, regulator in low power mode
    391             - Standby mode: 1.2V domain powered off.
    392             
    393             Sleep mode
    394             ===========
    395              - Entry:
    396                - The Sleep mode is entered by using the __WFI() or __WFE() functions.
    397              - Exit:
    398                - Any peripheral interrupt acknowledged by the nested vectored interrupt 
    399                  controller (NVIC) can wake up the device from Sleep mode.
    400          
    401             Stop mode
    402             ==========
    403             In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,
    404             and the HSE RC oscillators are disabled. Internal SRAM and register contents 
    405             are preserved.
    406             The voltage regulator can be configured either in normal or low-power mode.
    407             To minimize the consumption In Stop mode, FLASH can be powered off before 
    408             entering the Stop mode. It can be switched on again by software after exiting 
    409             the Stop mode using the PWR_FlashPowerDownCmd() function. 
    410             
    411              - Entry:
    412                - The Stop mode is entered using the PWR_EnterSTOPMode(PWR_Regulator_LowPower,) 
    413                  function with regulator in LowPower or with Regulator ON.
    414              - Exit:
    415                - Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
    416                
    417             Standby mode
    418             ============
    419             The Standby mode allows to achieve the lowest power consumption. It is based 
    420             on the Cortex-M4 deepsleep mode, with the voltage regulator disabled. 
    421             The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and 
    422             the HSE oscillator are also switched off. SRAM and register contents are lost 
    423             except for the RTC registers, RTC backup registers, backup SRAM and Standby 
    424             circuitry.
    425             
    426             The voltage regulator is OFF.
    427                
    428              - Entry:
    429                - The Standby mode is entered using the PWR_EnterSTANDBYMode() function.
    430              - Exit:
    431                - WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
    432                  tamper event, time-stamp event, external reset in NRST pin, IWDG reset.              
    433          
    434             Auto-wakeup (AWU) from low-power mode
    435             =====================================
    436             The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC 
    437             Wakeup event, a tamper event, a time-stamp event, or a comparator event, 
    438             without depending on an external interrupt (Auto-wakeup mode).
    439          
    440             - RTC auto-wakeup (AWU) from the Stop mode
    441               ----------------------------------------
    442               
    443               - To wake up from the Stop mode with an RTC alarm event, it is necessary to:
    444                 - Configure the EXTI Line 17 to be sensitive to rising edges (Interrupt 
    445                   or Event modes) using the EXTI_Init() function.
    446                 - Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
    447                 - Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
    448                   and RTC_AlarmCmd() functions.
    449               - To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
    450                 is necessary to:
    451                 - Configure the EXTI Line 21 to be sensitive to rising edges (Interrupt 
    452                   or Event modes) using the EXTI_Init() function.
    453                 - Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
    454                   function
    455                 - Configure the RTC to detect the tamper or time stamp event using the
    456                   RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
    457                   functions.
    458               - To wake up from the Stop mode with an RTC WakeUp event, it is necessary to:
    459                 - Configure the EXTI Line 22 to be sensitive to rising edges (Interrupt 
    460                   or Event modes) using the EXTI_Init() function.
    461                 - Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
    462                 - Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(), 
    463                   RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
    464          
    465             - RTC auto-wakeup (AWU) from the Standby mode
    466               -------------------------------------------
    467               - To wake up from the Standby mode with an RTC alarm event, it is necessary to:
    468                 - Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
    469                 - Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
    470                   and RTC_AlarmCmd() functions.
    471               - To wake up from the Standby mode with an RTC Tamper or time stamp event, it 
    472                 is necessary to:
    473                 - Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
    474                   function
    475                 - Configure the RTC to detect the tamper or time stamp event using the
    476                   RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
    477                   functions.
    478               - To wake up from the Standby mode with an RTC WakeUp event, it is necessary to:
    479                 - Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
    480                 - Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(), 
    481                   RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
    482          
    483          @endverbatim
    484            * @{
    485            */
    486          
    487          /**
    488            * @brief  Enters STOP mode.
    489            *   
    490            * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
    491            * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
    492            *         the HSI RC oscillator is selected as system clock.
    493            * @note   When the voltage regulator operates in low power mode, an additional 
    494            *         startup delay is incurred when waking up from Stop mode. 
    495            *         By keeping the internal regulator ON during Stop mode, the consumption 
    496            *         is higher although the startup time is reduced.           
    497            *     
    498            * @param  PWR_Regulator: specifies the regulator state in STOP mode.
    499            *          This parameter can be one of the following values:
    500            *            @arg PWR_Regulator_ON: STOP mode with regulator ON
    501            *            @arg PWR_Regulator_LowPower: STOP mode with regulator in low power mode
    502            * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
    503            *          This parameter can be one of the following values:
    504            *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
    505            *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
    506            * @retval None
    507            */
    508          void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
    509          {
    510            uint32_t tmpreg = 0;
    511            
    512            /* Check the parameters */
    513            assert_param(IS_PWR_REGULATOR(PWR_Regulator));
    514            assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
    515            
    516            /* Select the regulator state in STOP mode ---------------------------------*/
    517            tmpreg = PWR->CR;
    518            /* Clear PDDS and LPDSR bits */
    519            tmpreg &= CR_DS_MASK;
    520            
    521            /* Set LPDSR bit according to PWR_Regulator value */
    522            tmpreg |= PWR_Regulator;
    523            
    524            /* Store the new value */
    525            PWR->CR = tmpreg;
    526            
    527            /* Set SLEEPDEEP bit of Cortex System Control Register */
    528            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
    529            
    530            /* Select STOP mode entry --------------------------------------------------*/
    531            if(PWR_STOPEntry == PWR_STOPEntry_WFI)
    532            {   
    533              /* Request Wait For Interrupt */
    534              __WFI();
    535            }
    536            else
    537            {
    538              /* Request Wait For Event */
    539              __WFE();
    540            }
    541            /* Reset SLEEPDEEP bit of Cortex System Control Register */
    542            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
    543          }
    544          
    545          /**
    546            * @brief  Enters STANDBY mode.
    547            * @note   In Standby mode, all I/O pins are high impedance except for:
    548            *          - Reset pad (still available) 
    549            *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC 
    550            *            Alarm out, or RTC clock calibration out.
    551            *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  
    552            *          - WKUP pin 1 (PA0) if enabled.       
    553            * @param  None
    554            * @retval None
    555            */
    556          void PWR_EnterSTANDBYMode(void)
    557          {
    558            /* Clear Wakeup flag */
    559            PWR->CR |= PWR_CR_CWUF;
    560            
    561            /* Select STANDBY mode */
    562            PWR->CR |= PWR_CR_PDDS;
    563            
    564            /* Set SLEEPDEEP bit of Cortex System Control Register */
    565            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
    566            
    567          /* This option is used to ensure that store operations are completed */
    568          #if defined ( __CC_ARM   )
    569            __force_stores();
    570          #endif
    571            /* Request Wait For Interrupt */
    572            __WFI();
    573          }
    574          
    575          /**
    576            * @}
    577            */
    578          
    579          /** @defgroup PWR_Group7 Flags management functions
    580           *  @brief   Flags management functions 
    581           *
    582          @verbatim   
    583           ===============================================================================
    584                                     Flags management functions
    585           ===============================================================================  
    586          
    587          @endverbatim
    588            * @{
    589            */
    590          
    591          /**
    592            * @brief  Checks whether the specified PWR flag is set or not.
    593            * @param  PWR_FLAG: specifies the flag to check.
    594            *          This parameter can be one of the following values:
    595            *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
    596            *                  was received from the WKUP pin or from the RTC alarm (Alarm A 
    597            *                  or Alarm B), RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
    598            *                  An additional wakeup event is detected if the WKUP pin is enabled 
    599            *                  (by setting the EWUP bit) when the WKUP pin level is already high.  
    600            *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
    601            *                  resumed from StandBy mode.    
    602            *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
    603            *                  by the PWR_PVDCmd() function. The PVD is stopped by Standby mode 
    604            *                  For this reason, this bit is equal to 0 after Standby or reset
    605            *                  until the PVDE bit is set.
    606            *            @arg PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset 
    607            *                  when the device wakes up from Standby mode or by a system reset 
    608            *                  or power reset.  
    609            *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
    610            *                 scaling output selection is ready. 
    611            * @retval The new state of PWR_FLAG (SET or RESET).
    612            */
    613          FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
    614          {
    615            FlagStatus bitstatus = RESET;
    616            
    617            /* Check the parameters */
    618            assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
    619            
    620            if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
    621            {
    622              bitstatus = SET;
    623            }
    624            else
    625            {
    626              bitstatus = RESET;
    627            }
    628            /* Return the flag status */
    629            return bitstatus;
    630          }
    631          
    632          /**
    633            * @brief  Clears the PWR's pending flags.
    634            * @param  PWR_FLAG: specifies the flag to clear.
    635            *          This parameter can be one of the following values:
    636            *            @arg PWR_FLAG_WU: Wake Up flag
    637            *            @arg PWR_FLAG_SB: StandBy flag
    638            * @retval None
    639            */
    640          void PWR_ClearFlag(uint32_t PWR_FLAG)
    641          {
    642            /* Check the parameters */
    643            assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
    644                   
    645            PWR->CR |=  PWR_FLAG << 2;
    646          }
    647          
    648          /**
    649            * @}
    650            */
    651          
    652          /**
    653            * @}
    654            */
    655          
    656          /**
    657            * @}
    658            */
    659          
    660          /**
    661            * @}
    662            */
    663          
    664          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  PWR_BackupAccessCmd
        0  PWR_BackupRegulatorCmd
        0  PWR_ClearFlag
        8  PWR_DeInit
             0 -> RCC_APB1PeriphResetCmd
             8 -> RCC_APB1PeriphResetCmd
        0  PWR_EnterSTANDBYMode
        0  PWR_EnterSTOPMode
        0  PWR_FlashPowerDownCmd
        0  PWR_GetFlagStatus
        0  PWR_MainRegulatorModeConfig
        0  PWR_PVDCmd
        0  PWR_PVDLevelConfig
        0  PWR_WakeUpPinCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       6  PWR_BackupAccessCmd
       6  PWR_BackupRegulatorCmd
      12  PWR_ClearFlag
      26  PWR_DeInit
      32  PWR_EnterSTANDBYMode
      40  PWR_EnterSTOPMode
       6  PWR_FlashPowerDownCmd
      16  PWR_GetFlagStatus
      20  PWR_MainRegulatorModeConfig
       6  PWR_PVDCmd
      14  PWR_PVDLevelConfig
       6  PWR_WakeUpPinCmd

 
 222 bytes in section .text
 
 222 bytes of CODE memory

Errors: none
Warnings: none
