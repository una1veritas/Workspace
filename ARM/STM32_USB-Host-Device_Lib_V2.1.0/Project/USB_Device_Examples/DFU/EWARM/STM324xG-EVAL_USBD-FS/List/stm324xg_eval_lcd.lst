###############################################################################
#                                                                             #
#                                                       19/Sep/2012  16:16:04 #
# IAR ANSI C/C++ Compiler V6.40.2.33884/W32 KICKSTART for ARM                 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Utilities\STM32_EVAL\STM3240_41_G_EV #
#                    AL\stm324xg_eval_lcd.c                                   #
#    Command line =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Utilities\STM32_EVAL\STM3240_41_G_EV #
#                    AL\stm324xg_eval_lcd.c -D USE_STDPERIPH_DRIVER -D        #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_USB_OTG_FS -lcN    #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\ -o                         #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\ --debug --endian=little     #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.4           #
#                    Kickstart\arm\INC\c\DLib_Config_Full.h" -I               #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM3 #
#                    2_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples #
#                    \DFU\EWARM\..\inc\ -I \\psf\Home\Documents\Eclipse\Works #
#                    pace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_De #
#                    vice_Examples\DFU\EWARM\..\..\..\..\Libraries\CMSIS\Devi #
#                    ce\ST\STM32F4xx\Include\ -I                              #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\  #
#                    -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB- #
#                    Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\E #
#                    WARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\in #
#                    c\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_U #
#                    SB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DF #
#                    U\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\C #
#                    lass\dfu\inc\ -I \\psf\Home\Documents\Eclipse\Workspace\ #
#                    ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_ #
#                    Examples\DFU\EWARM\..\..\..\..\Utilities\STM32_EVAL\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\Common\ -I            #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\    #
#                    -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.4                           #
#                    Kickstart\arm\CMSIS\Include\"                            #
#    List file    =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\stm324xg_eval_lcd.lst       #
#    Object file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\stm324xg_eval_lcd.o          #
#                                                                             #
#                                                                             #
###############################################################################

\\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Utilities\STM32_EVAL\STM3240_41_G_EVAL\stm324xg_eval_lcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm324xg_eval_lcd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.2
      6            * @date    05-March-2012
      7            * @brief   This file includes the LCD driver for AM-240320L8TNQW00H (LCD_ILI9320)
      8            *          and AM240320D5TOQW01H (LCD_ILI9325) Liquid Crystal Display Modules
      9            *          of STM324xG-EVAL evaluation board(MB786) RevB.
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     14            *
     15            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     16            * You may not use this file except in compliance with the License.
     17            * You may obtain a copy of the License at:
     18            *
     19            *        http://www.st.com/software_license_agreement_liberty_v2
     20            *
     21            * Unless required by applicable law or agreed to in writing, software 
     22            * distributed under the License is distributed on an "AS IS" BASIS, 
     23            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     24            * See the License for the specific language governing permissions and
     25            * limitations under the License.
     26            *
     27            ******************************************************************************
     28            */ 
     29          
     30          /* Includes ------------------------------------------------------------------*/
     31          #include "stm324xg_eval_lcd.h"
     32          #include "../Common/fonts.c"
     33          
     34          /** @addtogroup Utilities
     35            * @{
     36            */ 
     37          
     38          /** @addtogroup STM32_EVAL
     39            * @{
     40            */ 
     41          
     42          /** @addtogroup STM324xG_EVAL
     43            * @{
     44            */
     45              
     46          /** @defgroup STM324xG_EVAL_LCD 
     47            * @brief This file includes the LCD driver for AM-240320L8TNQW00H (LCD_ILI9320)
     48            *        and AM240320D5TOQW01H (LCD_ILI9325) Liquid Crystal Display Modules
     49            *        of STM324xG_EVAL board.
     50            * @{
     51            */ 
     52          
     53          /** @defgroup STM324xG_EVAL_LCD_Private_TypesDefinitions
     54            * @{
     55            */ 
     56          typedef struct
     57          {
     58            __IO uint16_t LCD_REG;
     59            __IO uint16_t LCD_RAM;
     60          } LCD_TypeDef;
     61          /**
     62            * @}
     63            */ 
     64          
     65          
     66          /** @defgroup STM324xG_EVAL_LCD_Private_Defines
     67            * @{
     68            */
     69          /* Note: LCD /CS is NE3 - Bank 3 of NOR/SRAM Bank 1~4 */
     70          #define LCD_BASE           ((uint32_t)(0x60000000 | 0x08000000))
     71          #define LCD                ((LCD_TypeDef *) LCD_BASE)
     72          #define MAX_POLY_CORNERS   200
     73          #define POLY_Y(Z)          ((int32_t)((Points + Z)->X))
     74          #define POLY_X(Z)          ((int32_t)((Points + Z)->Y))
     75          /**
     76            * @}
     77            */ 
     78          
     79          /** @defgroup STM324xG_EVAL_LCD_Private_Macros
     80            * @{
     81            */
     82          #define ABS(X)  ((X) > 0 ? (X) : -(X))     
     83          /**
     84            * @}
     85            */ 
     86              
     87          /** @defgroup STM324xG_EVAL_LCD_Private_Variables
     88            * @{
     89            */ 
     90          static sFONT *LCD_Currentfonts;
     91          
     92            /* Global variables to set the written text color */
     93          __IO uint16_t TextColor = 0x0000, BackColor = 0xFFFF;
     94            
     95          /**
     96            * @}
     97            */ 
     98          
     99          
    100          /** @defgroup STM324xG_EVAL_LCD_Private_FunctionPrototypes
    101            * @{
    102            */ 
    103          #ifndef USE_Delay
    104          static void delay(__IO uint32_t nCount);
    105          #endif /* USE_Delay*/
    106          static void PutPixel(int16_t x, int16_t y);
    107          static void LCD_PolyLineRelativeClosed(pPoint Points, uint16_t PointCount, uint16_t Closed);
    108          
    109          
    110          /**
    111            * @}
    112            */ 
    113          
    114          
    115          /** @defgroup STM324xG_EVAL_LCD_Private_Functions
    116            * @{
    117            */ 
    118          
    119          /**
    120            * @brief  DeInitializes the LCD.
    121            * @param  None
    122            * @retval None
    123            */
    124          void LCD_DeInit(void)
    125          { 
    126            GPIO_InitTypeDef GPIO_InitStructure;
    127          
    128            /*!< LCD Display Off */
    129            LCD_DisplayOff();
    130          
    131            /* BANK 3 (of NOR/SRAM Bank 1~4) is disabled */
    132            FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM3, ENABLE);
    133            
    134            /*!< LCD_SPI DeInit */
    135            FSMC_NORSRAMDeInit(FSMC_Bank1_NORSRAM3);
    136             
    137          /*-- GPIO Configuration ------------------------------------------------------*/
    138            /* SRAM Data lines configuration */
    139            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_8 | GPIO_Pin_9 |
    140                                          GPIO_Pin_10 | GPIO_Pin_14 | GPIO_Pin_15;
    141            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    142            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    143            GPIO_Init(GPIOD, &GPIO_InitStructure);
    144           
    145            GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_MCO);
    146            GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_MCO);
    147            GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_MCO);
    148            GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_MCO);
    149            GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_MCO);
    150            GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_MCO);
    151            GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_MCO);
    152          
    153          
    154            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
    155                                          GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | 
    156                                          GPIO_Pin_15;
    157          
    158            GPIO_Init(GPIOE, &GPIO_InitStructure);
    159          
    160            GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_MCO);
    161            GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_MCO);
    162            GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_MCO);
    163            GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_MCO);
    164            GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_MCO);
    165            GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_MCO);
    166            GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_MCO);
    167            GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_MCO);
    168            GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_MCO);
    169          
    170            /* SRAM Address lines configuration */
    171            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | 
    172                                          GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_12 | GPIO_Pin_13 | 
    173                                          GPIO_Pin_14 | GPIO_Pin_15;
    174            GPIO_Init(GPIOF, &GPIO_InitStructure);
    175            GPIO_PinAFConfig(GPIOF,GPIO_PinSource0, GPIO_AF_MCO);
    176            GPIO_PinAFConfig(GPIOF,GPIO_PinSource1, GPIO_AF_MCO);
    177            GPIO_PinAFConfig(GPIOF,GPIO_PinSource2, GPIO_AF_MCO);
    178            GPIO_PinAFConfig(GPIOF,GPIO_PinSource3, GPIO_AF_MCO);
    179            GPIO_PinAFConfig(GPIOF,GPIO_PinSource4, GPIO_AF_MCO);
    180            GPIO_PinAFConfig(GPIOF,GPIO_PinSource5, GPIO_AF_MCO);
    181            GPIO_PinAFConfig(GPIOF,GPIO_PinSource12, GPIO_AF_MCO);
    182            GPIO_PinAFConfig(GPIOF,GPIO_PinSource13, GPIO_AF_MCO);
    183            GPIO_PinAFConfig(GPIOF,GPIO_PinSource14, GPIO_AF_MCO);
    184            GPIO_PinAFConfig(GPIOF,GPIO_PinSource15, GPIO_AF_MCO);
    185          
    186          
    187            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | 
    188                                          GPIO_Pin_4 | GPIO_Pin_5;
    189          
    190            GPIO_Init(GPIOG, &GPIO_InitStructure);
    191          
    192            GPIO_PinAFConfig(GPIOG,GPIO_PinSource0, GPIO_AF_MCO);
    193            GPIO_PinAFConfig(GPIOG,GPIO_PinSource1, GPIO_AF_MCO);
    194            GPIO_PinAFConfig(GPIOG,GPIO_PinSource2, GPIO_AF_MCO);
    195            GPIO_PinAFConfig(GPIOG,GPIO_PinSource3, GPIO_AF_MCO);
    196            GPIO_PinAFConfig(GPIOG,GPIO_PinSource4, GPIO_AF_MCO);
    197            GPIO_PinAFConfig(GPIOG,GPIO_PinSource5, GPIO_AF_MCO);
    198          
    199            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13; 
    200          
    201            GPIO_Init(GPIOD, &GPIO_InitStructure);
    202          
    203            GPIO_PinAFConfig(GPIOD,GPIO_PinSource11, GPIO_AF_MCO);
    204            GPIO_PinAFConfig(GPIOD,GPIO_PinSource12, GPIO_AF_MCO);
    205            GPIO_PinAFConfig(GPIOD,GPIO_PinSource13, GPIO_AF_MCO);
    206          
    207            /* NOE and NWE configuration */  
    208            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 |GPIO_Pin_5;
    209          
    210            GPIO_Init(GPIOD, &GPIO_InitStructure);
    211            GPIO_PinAFConfig(GPIOD,GPIO_PinSource4, GPIO_AF_MCO);
    212            GPIO_PinAFConfig(GPIOD,GPIO_PinSource5, GPIO_AF_MCO);
    213          
    214            /* NE3 configuration */
    215            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; 
    216          
    217            GPIO_Init(GPIOG, &GPIO_InitStructure);
    218            GPIO_PinAFConfig(GPIOG, GPIO_PinSource12, GPIO_AF_MCO);
    219          
    220            /* NBL0, NBL1 configuration */
    221            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1; 
    222            GPIO_Init(GPIOE, &GPIO_InitStructure); 
    223          
    224            GPIO_PinAFConfig(GPIOE,GPIO_PinSource0, GPIO_AF_MCO);
    225            GPIO_PinAFConfig(GPIOE,GPIO_PinSource1, GPIO_AF_MCO);
    226          }
    227          
    228          /**
    229            * @brief  Initializes the LCD.
    230            * @param  None
    231            * @retval None
    232            */
    233          void STM324xG_LCD_Init(void)
    234          { 
    235            __IO uint32_t lcdid = 0;
    236            
    237          /* Configure the LCD Control pins --------------------------------------------*/
    238            LCD_CtrlLinesConfig();
    239          
    240          /* Configure the FSMC Parallel interface -------------------------------------*/
    241            LCD_FSMCConfig();
    242          
    243            _delay_(5); /* delay 50 ms */
    244          
    245            /* Read the LCD ID */
    246            lcdid = LCD_ReadReg(0x00);  
    247          
    248            /* Check if the LCD is ILI9320 Controller */
    249            if(lcdid == 0x9320)
    250            {
    251              /* Start Initial Sequence ------------------------------------------------*/
    252              LCD_WriteReg(LCD_REG_229,0x8000); /* Set the internal vcore voltage */
    253              LCD_WriteReg(LCD_REG_0,  0x0001); /* Start internal OSC. */
    254              LCD_WriteReg(LCD_REG_1,  0x0100); /* set SS and SM bit */
    255              LCD_WriteReg(LCD_REG_2,  0x0700); /* set 1 line inversion */
    256              LCD_WriteReg(LCD_REG_3,  0x1030); /* set GRAM write direction and BGR=1. */
    257              LCD_WriteReg(LCD_REG_4,  0x0000); /* Resize register */
    258              LCD_WriteReg(LCD_REG_8,  0x0202); /* set the back porch and front porch */
    259              LCD_WriteReg(LCD_REG_9,  0x0000); /* set non-display area refresh cycle ISC[3:0] */
    260              LCD_WriteReg(LCD_REG_10, 0x0000); /* FMARK function */
    261              LCD_WriteReg(LCD_REG_12, 0x0000); /* RGB interface setting */
    262              LCD_WriteReg(LCD_REG_13, 0x0000); /* Frame marker Position */
    263              LCD_WriteReg(LCD_REG_15, 0x0000); /* RGB interface polarity */
    264          
    265              /* Power On sequence -----------------------------------------------------*/
    266              LCD_WriteReg(LCD_REG_16, 0x0000); /* SAP, BT[3:0], AP, DSTB, SLP, STB */
    267              LCD_WriteReg(LCD_REG_17, 0x0000); /* DC1[2:0], DC0[2:0], VC[2:0] */
    268              LCD_WriteReg(LCD_REG_18, 0x0000); /* VREG1OUT voltage */
    269              LCD_WriteReg(LCD_REG_19, 0x0000); /* VDV[4:0] for VCOM amplitude */
    270              _delay_(20);                 /* Dis-charge capacitor power voltage (200ms) */
    271              LCD_WriteReg(LCD_REG_16, 0x17B0); /* SAP, BT[3:0], AP, DSTB, SLP, STB */
    272              LCD_WriteReg(LCD_REG_17, 0x0137); /* DC1[2:0], DC0[2:0], VC[2:0] */
    273              _delay_(5);                  /* Delay 50 ms */
    274              LCD_WriteReg(LCD_REG_18, 0x0139); /* VREG1OUT voltage */
    275              _delay_(5);                  /* Delay 50 ms */
    276              LCD_WriteReg(LCD_REG_19, 0x1d00); /* VDV[4:0] for VCOM amplitude */
    277              LCD_WriteReg(LCD_REG_41, 0x0013); /* VCM[4:0] for VCOMH */
    278              _delay_(5);                  /* Delay 50 ms */
    279              LCD_WriteReg(LCD_REG_32, 0x0000); /* GRAM horizontal Address */
    280              LCD_WriteReg(LCD_REG_33, 0x0000); /* GRAM Vertical Address */
    281          
    282              /* Adjust the Gamma Curve ------------------------------------------------*/
    283              LCD_WriteReg(LCD_REG_48, 0x0007);
    284              LCD_WriteReg(LCD_REG_49, 0x0007);
    285              LCD_WriteReg(LCD_REG_50, 0x0007);
    286              LCD_WriteReg(LCD_REG_53, 0x0007);
    287              LCD_WriteReg(LCD_REG_54, 0x0007);
    288              LCD_WriteReg(LCD_REG_55, 0x0700);
    289              LCD_WriteReg(LCD_REG_56, 0x0700);
    290              LCD_WriteReg(LCD_REG_57, 0x0700);
    291              LCD_WriteReg(LCD_REG_60, 0x0700);
    292              LCD_WriteReg(LCD_REG_61, 0x1F00);
    293            
    294              /* Set GRAM area ---------------------------------------------------------*/
    295              LCD_WriteReg(LCD_REG_80, 0x0000); /* Horizontal GRAM Start Address */
    296              LCD_WriteReg(LCD_REG_81, 0x00EF); /* Horizontal GRAM End Address */
    297              LCD_WriteReg(LCD_REG_82, 0x0000); /* Vertical GRAM Start Address */
    298              LCD_WriteReg(LCD_REG_83, 0x013F); /* Vertical GRAM End Address */
    299              LCD_WriteReg(LCD_REG_96,  0x2700); /* Gate Scan Line */
    300              LCD_WriteReg(LCD_REG_97,  0x0001); /* NDL,VLE, REV */
    301              LCD_WriteReg(LCD_REG_106, 0x0000); /* set scrolling line */
    302          
    303              /* Partial Display Control -----------------------------------------------*/
    304              LCD_WriteReg(LCD_REG_128, 0x0000);
    305              LCD_WriteReg(LCD_REG_129, 0x0000);
    306              LCD_WriteReg(LCD_REG_130, 0x0000);
    307              LCD_WriteReg(LCD_REG_131, 0x0000);
    308              LCD_WriteReg(LCD_REG_132, 0x0000);
    309              LCD_WriteReg(LCD_REG_133, 0x0000);
    310          
    311              /* Panel Control ---------------------------------------------------------*/
    312              LCD_WriteReg(LCD_REG_144, 0x0010);
    313              LCD_WriteReg(LCD_REG_146, 0x0000);
    314              LCD_WriteReg(LCD_REG_147, 0x0003);
    315              LCD_WriteReg(LCD_REG_149, 0x0110);
    316              LCD_WriteReg(LCD_REG_151, 0x0000);
    317              LCD_WriteReg(LCD_REG_152, 0x0000);
    318          
    319              /* Set GRAM write direction and BGR = 1 */
    320              /* I/D=01 (Horizontal : increment, Vertical : decrement) */
    321              /* AM=1 (address is updated in vertical writing direction) */
    322              LCD_WriteReg(LCD_REG_3, 0x1018);
    323          
    324              LCD_WriteReg(LCD_REG_7, 0x0173); /* 262K color and display ON */  
    325            }
    326            else if(lcdid == 0x9325) /* Check if the LCD is ILI9325 Controller */
    327            {
    328              /* Start Initial Sequence ------------------------------------------------*/
    329              LCD_WriteReg(LCD_REG_0, 0x0001); /* Start internal OSC. */
    330              LCD_WriteReg(LCD_REG_1, 0x0100); /* Set SS and SM bit */
    331              LCD_WriteReg(LCD_REG_2, 0x0700); /* Set 1 line inversion */
    332              LCD_WriteReg(LCD_REG_3, 0x1018); /* Set GRAM write direction and BGR=1. */
    333              LCD_WriteReg(LCD_REG_4, 0x0000); /* Resize register */
    334              LCD_WriteReg(LCD_REG_8, 0x0202); /* Set the back porch and front porch */
    335              LCD_WriteReg(LCD_REG_9, 0x0000); /* Set non-display area refresh cycle ISC[3:0] */
    336              LCD_WriteReg(LCD_REG_10, 0x0000); /* FMARK function */
    337              LCD_WriteReg(LCD_REG_12, 0x0000); /* RGB interface setting */
    338              LCD_WriteReg(LCD_REG_13, 0x0000); /* Frame marker Position */
    339              LCD_WriteReg(LCD_REG_15, 0x0000); /* RGB interface polarity */
    340          
    341              /* Power On sequence -----------------------------------------------------*/
    342              LCD_WriteReg(LCD_REG_16, 0x0000); /* SAP, BT[3:0], AP, DSTB, SLP, STB */
    343              LCD_WriteReg(LCD_REG_17, 0x0000); /* DC1[2:0], DC0[2:0], VC[2:0] */
    344              LCD_WriteReg(LCD_REG_18, 0x0000); /* VREG1OUT voltage */
    345              LCD_WriteReg(LCD_REG_19, 0x0000); /* VDV[4:0] for VCOM amplitude */
    346              _delay_(20);                      /* Dis-charge capacitor power voltage (200ms) */
    347              LCD_WriteReg(LCD_REG_16, 0x17B0); /* SAP, BT[3:0], AP, DSTB, SLP, STB */
    348              LCD_WriteReg(LCD_REG_17, 0x0137); /* DC1[2:0], DC0[2:0], VC[2:0] */
    349              _delay_(5);                       /* Delay 50 ms */
    350              LCD_WriteReg(LCD_REG_18, 0x0139); /* VREG1OUT voltage */
    351              _delay_(5);                       /* Delay 50 ms */
    352              LCD_WriteReg(LCD_REG_19, 0x1d00); /* VDV[4:0] for VCOM amplitude */
    353              LCD_WriteReg(LCD_REG_41, 0x0013); /* VCM[4:0] for VCOMH */
    354              _delay_(5);                       /* Delay 50 ms */
    355              LCD_WriteReg(LCD_REG_32, 0x0000); /* GRAM horizontal Address */
    356              LCD_WriteReg(LCD_REG_33, 0x0000); /* GRAM Vertical Address */
    357          
    358              /* Adjust the Gamma Curve (ILI9325)---------------------------------------*/
    359              LCD_WriteReg(LCD_REG_48, 0x0007);
    360              LCD_WriteReg(LCD_REG_49, 0x0302);
    361              LCD_WriteReg(LCD_REG_50, 0x0105);
    362              LCD_WriteReg(LCD_REG_53, 0x0206);
    363              LCD_WriteReg(LCD_REG_54, 0x0808);
    364              LCD_WriteReg(LCD_REG_55, 0x0206);
    365              LCD_WriteReg(LCD_REG_56, 0x0504);
    366              LCD_WriteReg(LCD_REG_57, 0x0007);
    367              LCD_WriteReg(LCD_REG_60, 0x0105);
    368              LCD_WriteReg(LCD_REG_61, 0x0808);
    369          
    370              /* Set GRAM area ---------------------------------------------------------*/
    371              LCD_WriteReg(LCD_REG_80, 0x0000); /* Horizontal GRAM Start Address */
    372              LCD_WriteReg(LCD_REG_81, 0x00EF); /* Horizontal GRAM End Address */
    373              LCD_WriteReg(LCD_REG_82, 0x0000); /* Vertical GRAM Start Address */
    374              LCD_WriteReg(LCD_REG_83, 0x013F); /* Vertical GRAM End Address */
    375          
    376              LCD_WriteReg(LCD_REG_96,  0xA700); /* Gate Scan Line(GS=1, scan direction is G320~G1) */
    377              LCD_WriteReg(LCD_REG_97,  0x0001); /* NDL,VLE, REV */
    378              LCD_WriteReg(LCD_REG_106, 0x0000); /* set scrolling line */
    379          
    380              /* Partial Display Control -----------------------------------------------*/
    381              LCD_WriteReg(LCD_REG_128, 0x0000);
    382              LCD_WriteReg(LCD_REG_129, 0x0000);
    383              LCD_WriteReg(LCD_REG_130, 0x0000);
    384              LCD_WriteReg(LCD_REG_131, 0x0000);
    385              LCD_WriteReg(LCD_REG_132, 0x0000);
    386              LCD_WriteReg(LCD_REG_133, 0x0000);
    387          
    388              /* Panel Control ---------------------------------------------------------*/
    389              LCD_WriteReg(LCD_REG_144, 0x0010);
    390              LCD_WriteReg(LCD_REG_146, 0x0000);
    391              LCD_WriteReg(LCD_REG_147, 0x0003);
    392              LCD_WriteReg(LCD_REG_149, 0x0110);
    393              LCD_WriteReg(LCD_REG_151, 0x0000);
    394              LCD_WriteReg(LCD_REG_152, 0x0000);
    395          
    396              /* set GRAM write direction and BGR = 1 */
    397              /* I/D=00 (Horizontal : increment, Vertical : decrement) */
    398              /* AM=1 (address is updated in vertical writing direction) */
    399              LCD_WriteReg(LCD_REG_3, 0x1018);
    400          
    401              LCD_WriteReg(LCD_REG_7, 0x0133); /* 262K color and display ON */ 
    402            }
    403            LCD_SetFont(&LCD_DEFAULT_FONT);
    404          }
    405          
    406          /**
    407            * @brief  Sets the LCD Text and Background colors.
    408            * @param  _TextColor: specifies the Text Color.
    409            * @param  _BackColor: specifies the Background Color.
    410            * @retval None
    411            */
    412          void LCD_SetColors(__IO uint16_t _TextColor, __IO uint16_t _BackColor)
    413          {
    414            TextColor = _TextColor; 
    415            BackColor = _BackColor;
    416          }
    417          
    418          /**
    419            * @brief  Gets the LCD Text and Background colors.
    420            * @param  _TextColor: pointer to the variable that will contain the Text 
    421                      Color.
    422            * @param  _BackColor: pointer to the variable that will contain the Background 
    423                      Color.
    424            * @retval None
    425            */
    426          void LCD_GetColors(__IO uint16_t *_TextColor, __IO uint16_t *_BackColor)
    427          {
    428            *_TextColor = TextColor; *_BackColor = BackColor;
    429          }
    430          
    431          /**
    432            * @brief  Sets the Text color.
    433            * @param  Color: specifies the Text color code RGB(5-6-5).
    434            * @retval None
    435            */
    436          void LCD_SetTextColor(__IO uint16_t Color)
    437          {
    438            TextColor = Color;
    439          }
    440          
    441          
    442          /**
    443            * @brief  Sets the Background color.
    444            * @param  Color: specifies the Background color code RGB(5-6-5).
    445            * @retval None
    446            */
    447          void LCD_SetBackColor(__IO uint16_t Color)
    448          {
    449            BackColor = Color;
    450          }
    451          
    452          /**
    453            * @brief  Sets the Text Font.
    454            * @param  fonts: specifies the font to be used.
    455            * @retval None
    456            */
    457          void LCD_SetFont(sFONT *fonts)
    458          {
    459            LCD_Currentfonts = fonts;
    460          }
    461          
    462          /**
    463            * @brief  Gets the Text Font.
    464            * @param  None.
    465            * @retval the used font.
    466            */
    467          sFONT *LCD_GetFont(void)
    468          {
    469            return LCD_Currentfonts;
    470          }
    471          
    472          /**
    473            * @brief  Clears the selected line.
    474            * @param  Line: the Line to be cleared.
    475            *   This parameter can be one of the following values:
    476            *     @arg Linex: where x can be 0..n
    477            * @retval None
    478            */
    479          void LCD_ClearLine(uint16_t Line)
    480          {
    481            uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;
    482            /* Send the string character by character on lCD */
    483            while (((refcolumn + 1)& 0xFFFF) >= LCD_Currentfonts->Width)
    484            {
    485              /* Display one character on LCD */
    486              LCD_DisplayChar(Line, refcolumn, ' ');
    487              /* Decrement the column position by 16 */
    488              refcolumn -= LCD_Currentfonts->Width;
    489            }
    490          }
    491          
    492          /**
    493            * @brief  Clears the hole LCD.
    494            * @param  Color: the color of the background.
    495            * @retval None
    496            */
    497          void LCD_Clear(uint16_t Color)
    498          {
    499            uint32_t index = 0;
    500            
    501            LCD_SetCursor(0x00, 0x013F); 
    502            LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    503            for(index = 0; index < 76800; index++)
    504            {
    505              LCD->LCD_RAM = Color;
    506            }  
    507          }
    508          
    509          /**
    510            * @brief  Sets the cursor position.
    511            * @param  Xpos: specifies the X position.
    512            * @param  Ypos: specifies the Y position. 
    513            * @retval None
    514            */
    515          void LCD_SetCursor(uint16_t Xpos, uint16_t Ypos)
    516          {
    517            LCD_WriteReg(LCD_REG_32, Xpos);
    518            LCD_WriteReg(LCD_REG_33, Ypos);
    519          }
    520          
    521          /**
    522            * @brief  Draws a character on LCD.
    523            * @param  Xpos: the Line where to display the character shape.
    524            * @param  Ypos: start column address.
    525            * @param  c: pointer to the character data.
    526            * @retval None
    527            */
    528          void LCD_DrawChar(uint16_t Xpos, uint16_t Ypos, const uint16_t *c)
    529          {
    530            uint32_t index = 0, i = 0;
    531            uint16_t  Xaddress = 0;
    532            Xaddress = Xpos;
    533            
    534            LCD_SetCursor(Xaddress, Ypos);
    535            
    536            for(index = 0; index < LCD_Currentfonts->Height; index++)
    537            {
    538              LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    539              for(i = 0; i < LCD_Currentfonts->Width; i++)
    540              {
    541            
    542                if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> i)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
    543                  (((c[index] & (0x1 << i)) == 0x00)&&(LCD_Currentfonts->Width > 12 )))
    544          
    545                {
    546                  LCD_WriteRAM(BackColor);
    547                }
    548                else
    549                {
    550                  LCD_WriteRAM(TextColor);
    551                } 
    552              }
    553              Xaddress++;
    554              LCD_SetCursor(Xaddress, Ypos);
    555            }
    556          }
    557          
    558          /**
    559            * @brief  Displays one character (16dots width, 24dots height).
    560            * @param  Line: the Line where to display the character shape .
    561            *   This parameter can be one of the following values:
    562            *     @arg Linex: where x can be 0..9
    563            * @param  Column: start column address.
    564            * @param  Ascii: character ascii code, must be between 0x20 and 0x7E.
    565            * @retval None
    566            */
    567          void LCD_DisplayChar(uint16_t Line, uint16_t Column, uint8_t Ascii)
    568          {
    569            Ascii -= 32;
    570            LCD_DrawChar(Line, Column, &LCD_Currentfonts->table[Ascii * LCD_Currentfonts->Height]);
    571          }
    572          
    573          /**
    574            * @brief  Displays a maximum of 20 char on the LCD.
    575            * @param  Line: the Line where to display the character shape .
    576            *   This parameter can be one of the following values:
    577            *     @arg Linex: where x can be 0..9
    578            * @param  *ptr: pointer to string to display on LCD.
    579            * @retval None
    580            */
    581          void LCD_DisplayStringLine(uint16_t Line, uint8_t *ptr)
    582          {
    583            uint16_t refcolumn = LCD_PIXEL_WIDTH - 1;
    584          
    585            /* Send the string character by character on lCD */
    586            while ((*ptr != 0) & (((refcolumn + 1) & 0xFFFF) >= LCD_Currentfonts->Width))
    587            {
    588              /* Display one character on LCD */
    589              LCD_DisplayChar(Line, refcolumn, *ptr);
    590              /* Decrement the column position by 16 */
    591              refcolumn -= LCD_Currentfonts->Width;
    592              /* Point on the next character */
    593              ptr++;
    594            }
    595          }
    596          
    597          /**
    598            * @brief  Sets a display window
    599            * @param  Xpos: specifies the X bottom left position.
    600            * @param  Ypos: specifies the Y bottom left position.
    601            * @param  Height: display window height.
    602            * @param  Width: display window width.
    603            * @retval None
    604            */
    605          void LCD_SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint8_t Height, uint16_t Width)
    606          {
    607            /* Horizontal GRAM Start Address */
    608            if(Xpos >= Height)
    609            {
    610              LCD_WriteReg(LCD_REG_80, (Xpos - Height + 1));
    611            }
    612            else
    613            {
    614              LCD_WriteReg(LCD_REG_80, 0);
    615            }
    616            /* Horizontal GRAM End Address */
    617            LCD_WriteReg(LCD_REG_81, Xpos);
    618            /* Vertical GRAM Start Address */
    619            if(Ypos >= Width)
    620            {
    621              LCD_WriteReg(LCD_REG_82, (Ypos - Width + 1));
    622            }  
    623            else
    624            {
    625              LCD_WriteReg(LCD_REG_82, 0);
    626            }
    627            /* Vertical GRAM End Address */
    628            LCD_WriteReg(LCD_REG_83, Ypos);
    629            LCD_SetCursor(Xpos, Ypos);
    630          }
    631          
    632          /**
    633            * @brief  Disables LCD Window mode.
    634            * @param  None
    635            * @retval None
    636            */
    637          void LCD_WindowModeDisable(void)
    638          {
    639            LCD_SetDisplayWindow(239, 0x13F, 240, 320);
    640            LCD_WriteReg(LCD_REG_3, 0x1018);    
    641          }
    642          
    643          /**
    644            * @brief  Displays a line.
    645            * @param Xpos: specifies the X position.
    646            * @param Ypos: specifies the Y position.
    647            * @param Length: line length.
    648            * @param Direction: line direction.
    649            *   This parameter can be one of the following values: Vertical or Horizontal.
    650            * @retval None
    651            */
    652          void LCD_DrawLine(uint16_t Xpos, uint16_t Ypos, uint16_t Length, uint8_t Direction)
    653          {
    654            uint32_t i = 0;
    655            
    656            LCD_SetCursor(Xpos, Ypos);
    657            if(Direction == LCD_DIR_HORIZONTAL)
    658            {
    659              LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    660              for(i = 0; i < Length; i++)
    661              {
    662                LCD_WriteRAM(TextColor);
    663              }
    664            }
    665            else
    666            {
    667              for(i = 0; i < Length; i++)
    668              {
    669                LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    670                LCD_WriteRAM(TextColor);
    671                Xpos++;
    672                LCD_SetCursor(Xpos, Ypos);
    673              }
    674            }
    675          }
    676          
    677          /**
    678            * @brief  Displays a rectangle.
    679            * @param  Xpos: specifies the X position.
    680            * @param  Ypos: specifies the Y position.
    681            * @param  Height: display rectangle height.
    682            * @param  Width: display rectangle width.
    683            * @retval None
    684            */
    685          void LCD_DrawRect(uint16_t Xpos, uint16_t Ypos, uint8_t Height, uint16_t Width)
    686          {
    687            LCD_DrawLine(Xpos, Ypos, Width, LCD_DIR_HORIZONTAL);
    688            LCD_DrawLine((Xpos + Height), Ypos, Width, LCD_DIR_HORIZONTAL);
    689            
    690            LCD_DrawLine(Xpos, Ypos, Height, LCD_DIR_VERTICAL);
    691            LCD_DrawLine(Xpos, (Ypos - Width + 1), Height, LCD_DIR_VERTICAL);
    692          }
    693          
    694          /**
    695            * @brief  Displays a circle.
    696            * @param  Xpos: specifies the X position.
    697            * @param  Ypos: specifies the Y position.
    698            * @param  Radius
    699            * @retval None
    700            */
    701          void LCD_DrawCircle(uint16_t Xpos, uint16_t Ypos, uint16_t Radius)
    702          {
    703            int32_t  D;/* Decision Variable */ 
    704            uint32_t  CurX;/* Current X Value */
    705            uint32_t  CurY;/* Current Y Value */ 
    706            
    707            D = 3 - (Radius << 1);
    708            CurX = 0;
    709            CurY = Radius;
    710            
    711            while (CurX <= CurY)
    712            {
    713              LCD_SetCursor(Xpos + CurX, Ypos + CurY);
    714              LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    715              LCD_WriteRAM(TextColor);
    716              LCD_SetCursor(Xpos + CurX, Ypos - CurY);
    717              LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    718              LCD_WriteRAM(TextColor);
    719              LCD_SetCursor(Xpos - CurX, Ypos + CurY);
    720              LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    721              LCD_WriteRAM(TextColor);
    722              LCD_SetCursor(Xpos - CurX, Ypos - CurY);
    723              LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    724              LCD_WriteRAM(TextColor);
    725              LCD_SetCursor(Xpos + CurY, Ypos + CurX);
    726              LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    727              LCD_WriteRAM(TextColor);
    728              LCD_SetCursor(Xpos + CurY, Ypos - CurX);
    729              LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    730              LCD_WriteRAM(TextColor);
    731              LCD_SetCursor(Xpos - CurY, Ypos + CurX);
    732              LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    733              LCD_WriteRAM(TextColor);
    734              LCD_SetCursor(Xpos - CurY, Ypos - CurX);
    735              LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    736              LCD_WriteRAM(TextColor);
    737              if (D < 0)
    738              { 
    739                D += (CurX << 2) + 6;
    740              }
    741              else
    742              {
    743                D += ((CurX - CurY) << 2) + 10;
    744                CurY--;
    745              }
    746              CurX++;
    747            }
    748          }
    749          
    750          /**
    751            * @brief  Displays a mono-color picture.
    752            * @param  Pict: pointer to the picture array.
    753            * @retval None
    754            */
    755          void LCD_DrawMonoPict(const uint32_t *Pict)
    756          {
    757            uint32_t index = 0, i = 0;
    758            LCD_SetCursor(0, (LCD_PIXEL_WIDTH - 1)); 
    759            LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
    760            for(index = 0; index < 2400; index++)
    761            {
    762              for(i = 0; i < 32; i++)
    763              {
    764                if((Pict[index] & (1 << i)) == 0x00)
    765                {
    766                  LCD_WriteRAM(BackColor);
    767                }
    768                else
    769                {
    770                  LCD_WriteRAM(TextColor);
    771                }
    772              }
    773            }
    774          }
    775          
    776          /**
    777            * @brief  Displays a bitmap picture loaded in the internal Flash.
    778            * @param  BmpAddress: Bmp picture address in the internal Flash.
    779            * @retval None
    780            */
    781          void LCD_WriteBMP(uint32_t BmpAddress)
    782          {
    783            uint32_t index = 0, size = 0;
    784            /* Read bitmap size */
    785            size = *(__IO uint16_t *) (BmpAddress + 2);
    786            size |= (*(__IO uint16_t *) (BmpAddress + 4)) << 16;
    787            /* Get bitmap data address offset */
    788            index = *(__IO uint16_t *) (BmpAddress + 10);
    789            index |= (*(__IO uint16_t *) (BmpAddress + 12)) << 16;
    790            size = (size - index)/2;
    791            BmpAddress += index;
    792            /* Set GRAM write direction and BGR = 1 */
    793            /* I/D=00 (Horizontal : decrement, Vertical : decrement) */
    794            /* AM=1 (address is updated in vertical writing direction) */
    795            LCD_WriteReg(LCD_REG_3, 0x1008);
    796           
    797            LCD_WriteRAM_Prepare();
    798           
    799            for(index = 0; index < size; index++)
    800            {
    801              LCD_WriteRAM(*(__IO uint16_t *)BmpAddress);
    802              BmpAddress += 2;
    803            }
    804           
    805            /* Set GRAM write direction and BGR = 1 */
    806            /* I/D = 01 (Horizontal : increment, Vertical : decrement) */
    807            /* AM = 1 (address is updated in vertical writing direction) */
    808            LCD_WriteReg(LCD_REG_3, 0x1018);
    809          }
    810          
    811          /**
    812            * @brief  Displays a full rectangle.
    813            * @param  Xpos: specifies the X position.
    814            * @param  Ypos: specifies the Y position.
    815            * @param  Height: rectangle height.
    816            * @param  Width: rectangle width.
    817            * @retval None
    818            */
    819          void LCD_DrawFullRect(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height)
    820          {
    821            LCD_SetTextColor(TextColor);
    822          
    823            LCD_DrawLine(Xpos, Ypos, Width, LCD_DIR_HORIZONTAL);
    824            LCD_DrawLine((Xpos + Height), Ypos, Width, LCD_DIR_HORIZONTAL);
    825            
    826            LCD_DrawLine(Xpos, Ypos, Height, LCD_DIR_VERTICAL);
    827            LCD_DrawLine(Xpos, (Ypos - Width + 1), Height, LCD_DIR_VERTICAL);
    828          
    829            Width -= 2;
    830            Height--;
    831            Ypos--;
    832          
    833            LCD_SetTextColor(BackColor);
    834          
    835            while(Height--)
    836            {
    837              LCD_DrawLine(++Xpos, Ypos, Width, LCD_DIR_HORIZONTAL);    
    838            }
    839          
    840            LCD_SetTextColor(TextColor);
    841          }
    842          
    843          /**
    844            * @brief  Displays a full circle.
    845            * @param  Xpos: specifies the X position.
    846            * @param  Ypos: specifies the Y position.
    847            * @param  Radius
    848            * @retval None
    849            */
    850          void LCD_DrawFullCircle(uint16_t Xpos, uint16_t Ypos, uint16_t Radius)
    851          {
    852            int32_t  D;    /* Decision Variable */ 
    853            uint32_t  CurX;/* Current X Value */
    854            uint32_t  CurY;/* Current Y Value */ 
    855            
    856            D = 3 - (Radius << 1);
    857          
    858            CurX = 0;
    859            CurY = Radius;
    860            
    861            LCD_SetTextColor(BackColor);
    862          
    863            while (CurX <= CurY)
    864            {
    865              if(CurY > 0) 
    866              {
    867                LCD_DrawLine(Xpos - CurX, Ypos + CurY, 2*CurY, LCD_DIR_HORIZONTAL);
    868                LCD_DrawLine(Xpos + CurX, Ypos + CurY, 2*CurY, LCD_DIR_HORIZONTAL);
    869              }
    870          
    871              if(CurX > 0) 
    872              {
    873                LCD_DrawLine(Xpos - CurY, Ypos + CurX, 2*CurX, LCD_DIR_HORIZONTAL);
    874                LCD_DrawLine(Xpos + CurY, Ypos + CurX, 2*CurX, LCD_DIR_HORIZONTAL);
    875              }
    876              if (D < 0)
    877              { 
    878                D += (CurX << 2) + 6;
    879              }
    880              else
    881              {
    882                D += ((CurX - CurY) << 2) + 10;
    883                CurY--;
    884              }
    885              CurX++;
    886            }
    887          
    888            LCD_SetTextColor(TextColor);
    889            LCD_DrawCircle(Xpos, Ypos, Radius);
    890          }
    891          
    892          /**
    893            * @brief  Displays an uni-line (between two points).
    894            * @param  x1: specifies the point 1 x position.
    895            * @param  y1: specifies the point 1 y position.
    896            * @param  x2: specifies the point 2 x position.
    897            * @param  y2: specifies the point 2 y position.
    898            * @retval None
    899            */
    900          void LCD_DrawUniLine(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2)
    901          {
    902            int16_t deltax = 0, deltay = 0, x = 0, y = 0, xinc1 = 0, xinc2 = 0, 
    903            yinc1 = 0, yinc2 = 0, den = 0, num = 0, numadd = 0, numpixels = 0, 
    904            curpixel = 0;
    905            
    906            deltax = ABS(x2 - x1);        /* The difference between the x's */
    907            deltay = ABS(y2 - y1);        /* The difference between the y's */
    908            x = x1;                       /* Start x off at the first pixel */
    909            y = y1;                       /* Start y off at the first pixel */
    910            
    911            if (x2 >= x1)                 /* The x-values are increasing */
    912            {
    913              xinc1 = 1;
    914              xinc2 = 1;
    915            }
    916            else                          /* The x-values are decreasing */
    917            {
    918              xinc1 = -1;
    919              xinc2 = -1;
    920            }
    921            
    922            if (y2 >= y1)                 /* The y-values are increasing */
    923            {
    924              yinc1 = 1;
    925              yinc2 = 1;
    926            }
    927            else                          /* The y-values are decreasing */
    928            {
    929              yinc1 = -1;
    930              yinc2 = -1;
    931            }
    932            
    933            if (deltax >= deltay)         /* There is at least one x-value for every y-value */
    934            {
    935              xinc1 = 0;                  /* Don't change the x when numerator >= denominator */
    936              yinc2 = 0;                  /* Don't change the y for every iteration */
    937              den = deltax;
    938              num = deltax / 2;
    939              numadd = deltay;
    940              numpixels = deltax;         /* There are more x-values than y-values */
    941            }
    942            else                          /* There is at least one y-value for every x-value */
    943            {
    944              xinc2 = 0;                  /* Don't change the x for every iteration */
    945              yinc1 = 0;                  /* Don't change the y when numerator >= denominator */
    946              den = deltay;
    947              num = deltay / 2;
    948              numadd = deltax;
    949              numpixels = deltay;         /* There are more y-values than x-values */
    950            }
    951            
    952            for (curpixel = 0; curpixel <= numpixels; curpixel++)
    953            {
    954              PutPixel(x, y);             /* Draw the current pixel */
    955              num += numadd;              /* Increase the numerator by the top of the fraction */
    956              if (num >= den)             /* Check if numerator >= denominator */
    957              {
    958                num -= den;               /* Calculate the new numerator value */
    959                x += xinc1;               /* Change the x as appropriate */
    960                y += yinc1;               /* Change the y as appropriate */
    961              }
    962              x += xinc2;                 /* Change the x as appropriate */
    963              y += yinc2;                 /* Change the y as appropriate */
    964            }
    965          }
    966          
    967          /**
    968            * @brief  Displays an poly-line (between many points).
    969            * @param  Points: pointer to the points array.
    970            * @param  PointCount: Number of points.
    971            * @retval None
    972            */
    973          void LCD_PolyLine(pPoint Points, uint16_t PointCount)
    974          {
    975            int16_t X = 0, Y = 0;
    976          
    977            if(PointCount < 2)
    978            {
    979              return;
    980            }
    981          
    982            while(--PointCount)
    983            {
    984              X = Points->X;
    985              Y = Points->Y;
    986              Points++;
    987              LCD_DrawUniLine(X, Y, Points->X, Points->Y);
    988            }
    989          }
    990          
    991          /**
    992            * @brief  Displays an relative poly-line (between many points).
    993            * @param  Points: pointer to the points array.
    994            * @param  PointCount: Number of points.
    995            * @param  Closed: specifies if the draw is closed or not.
    996            *           1: closed, 0 : not closed.
    997            * @retval None
    998            */
    999          static void LCD_PolyLineRelativeClosed(pPoint Points, uint16_t PointCount, uint16_t Closed)
   1000          {
   1001            int16_t X = 0, Y = 0;
   1002            pPoint First = Points;
   1003          
   1004            if(PointCount < 2)
   1005            {
   1006              return;
   1007            }  
   1008            X = Points->X;
   1009            Y = Points->Y;
   1010            while(--PointCount)
   1011            {
   1012              Points++;
   1013              LCD_DrawUniLine(X, Y, X + Points->X, Y + Points->Y);
   1014              X = X + Points->X;
   1015              Y = Y + Points->Y;
   1016            }
   1017            if(Closed)
   1018            {
   1019              LCD_DrawUniLine(First->X, First->Y, X, Y);
   1020            }  
   1021          }
   1022          
   1023          /**
   1024            * @brief  Displays a closed poly-line (between many points).
   1025            * @param  Points: pointer to the points array.
   1026            * @param  PointCount: Number of points.
   1027            * @retval None
   1028            */
   1029          void LCD_ClosedPolyLine(pPoint Points, uint16_t PointCount)
   1030          {
   1031            LCD_PolyLine(Points, PointCount);
   1032            LCD_DrawUniLine(Points->X, Points->Y, (Points+PointCount-1)->X, (Points+PointCount-1)->Y);
   1033          }
   1034          
   1035          /**
   1036            * @brief  Displays a relative poly-line (between many points).
   1037            * @param  Points: pointer to the points array.
   1038            * @param  PointCount: Number of points.
   1039            * @retval None
   1040            */
   1041          void LCD_PolyLineRelative(pPoint Points, uint16_t PointCount)
   1042          {
   1043            LCD_PolyLineRelativeClosed(Points, PointCount, 0);
   1044          }
   1045          
   1046          /**
   1047            * @brief  Displays a closed relative poly-line (between many points).
   1048            * @param  Points: pointer to the points array.
   1049            * @param  PointCount: Number of points.
   1050            * @retval None
   1051            */
   1052          void LCD_ClosedPolyLineRelative(pPoint Points, uint16_t PointCount)
   1053          {
   1054            LCD_PolyLineRelativeClosed(Points, PointCount, 1);
   1055          }
   1056          
   1057          
   1058          /**
   1059            * @brief  Displays a  full poly-line (between many points).
   1060            * @param  Points: pointer to the points array.
   1061            * @param  PointCount: Number of points.
   1062            * @retval None
   1063            */
   1064          void LCD_FillPolyLine(pPoint Points, uint16_t PointCount)
   1065          {
   1066            /*  public-domain code by Darel Rex Finley, 2007 */
   1067            uint16_t  nodes = 0, nodeX[MAX_POLY_CORNERS], pixelX = 0, pixelY = 0, i = 0,
   1068            j = 0, swap = 0;
   1069            uint16_t  IMAGE_LEFT = 0, IMAGE_RIGHT = 0, IMAGE_TOP = 0, IMAGE_BOTTOM = 0;
   1070          
   1071            IMAGE_LEFT = IMAGE_RIGHT = Points->X;
   1072            IMAGE_TOP= IMAGE_BOTTOM = Points->Y;
   1073          
   1074            for(i = 1; i < PointCount; i++)
   1075            {
   1076              pixelX = POLY_X(i);
   1077              if(pixelX < IMAGE_LEFT)
   1078              {
   1079                IMAGE_LEFT = pixelX;
   1080              }
   1081              if(pixelX > IMAGE_RIGHT)
   1082              {
   1083                IMAGE_RIGHT = pixelX;
   1084              }
   1085              
   1086              pixelY = POLY_Y(i);
   1087              if(pixelY < IMAGE_TOP)
   1088              { 
   1089                IMAGE_TOP = pixelY;
   1090              }
   1091              if(pixelY > IMAGE_BOTTOM)
   1092              {
   1093                IMAGE_BOTTOM = pixelY;
   1094              }
   1095            }
   1096            
   1097            LCD_SetTextColor(BackColor);  
   1098          
   1099            /*  Loop through the rows of the image. */
   1100            for (pixelY = IMAGE_TOP; pixelY < IMAGE_BOTTOM; pixelY++) 
   1101            {  
   1102              /* Build a list of nodes. */
   1103              nodes = 0; j = PointCount-1;
   1104          
   1105              for (i = 0; i < PointCount; i++) 
   1106              {
   1107                if (((POLY_Y(i)<(double) pixelY) && (POLY_Y(j)>=(double) pixelY)) || \
   1108                    ((POLY_Y(j)<(double) pixelY) && (POLY_Y(i)>=(double) pixelY)))
   1109                {
   1110                  nodeX[nodes++]=(int) (POLY_X(i)+((pixelY-POLY_Y(i))*(POLY_X(j)-POLY_X(i)))/(POLY_Y(j)-POLY_Y(i))); 
   1111                }
   1112                j = i; 
   1113              }
   1114            
   1115              /* Sort the nodes, via a simple "Bubble" sort. */
   1116              i = 0;
   1117              while (i < nodes-1) 
   1118              {
   1119                if (nodeX[i]>nodeX[i+1]) 
   1120                {
   1121                  swap = nodeX[i]; 
   1122                  nodeX[i] = nodeX[i+1]; 
   1123                  nodeX[i+1] = swap; 
   1124                  if(i)
   1125                  {
   1126                    i--; 
   1127                  }
   1128                }
   1129                else 
   1130                {
   1131                  i++;
   1132                }
   1133              }
   1134            
   1135              /*  Fill the pixels between node pairs. */
   1136              for (i = 0; i < nodes; i+=2) 
   1137              {
   1138                if(nodeX[i] >= IMAGE_RIGHT) 
   1139                {
   1140                  break;
   1141                }
   1142                if(nodeX[i+1] > IMAGE_LEFT) 
   1143                {
   1144                  if (nodeX[i] < IMAGE_LEFT)
   1145                  {
   1146                    nodeX[i]=IMAGE_LEFT;
   1147                  }
   1148                  if(nodeX[i+1] > IMAGE_RIGHT)
   1149                  {
   1150                    nodeX[i+1] = IMAGE_RIGHT;
   1151                  }
   1152                  LCD_SetTextColor(BackColor);
   1153                  LCD_DrawLine(pixelY, nodeX[i+1], nodeX[i+1] - nodeX[i], LCD_DIR_HORIZONTAL);
   1154                  LCD_SetTextColor(TextColor);
   1155                  PutPixel(pixelY, nodeX[i+1]);
   1156                  PutPixel(pixelY, nodeX[i]);
   1157                  /* for (j=nodeX[i]; j<nodeX[i+1]; j++) PutPixel(j,pixelY); */
   1158                }
   1159              }
   1160            } 
   1161          
   1162            /* draw the edges */
   1163            LCD_SetTextColor(TextColor);
   1164          }
   1165          
   1166          /**
   1167            * @brief  Writes to the selected LCD register.
   1168            * @param  LCD_Reg: address of the selected register.
   1169            * @param  LCD_RegValue: value to write to the selected register.
   1170            * @retval None
   1171            */
   1172          void LCD_WriteReg(uint8_t LCD_Reg, uint16_t LCD_RegValue)
   1173          {
   1174            /* Write 16-bit Index, then Write Reg */
   1175            LCD->LCD_REG = LCD_Reg;
   1176            /* Write 16-bit Reg */
   1177            LCD->LCD_RAM = LCD_RegValue;
   1178          }
   1179          
   1180          /**
   1181            * @brief  Reads the selected LCD Register.
   1182            * @param  LCD_Reg: address of the selected register.
   1183            * @retval LCD Register Value.
   1184            */
   1185          uint16_t LCD_ReadReg(uint8_t LCD_Reg)
   1186          {
   1187            /* Write 16-bit Index (then Read Reg) */
   1188            LCD->LCD_REG = LCD_Reg;
   1189            /* Read 16-bit Reg */
   1190            return (LCD->LCD_RAM);
   1191          }
   1192          
   1193          /**
   1194            * @brief  Prepare to write to the LCD RAM.
   1195            * @param  None
   1196            * @retval None
   1197            */
   1198          void LCD_WriteRAM_Prepare(void)
   1199          {
   1200            LCD->LCD_REG = LCD_REG_34;
   1201          }
   1202          
   1203          /**
   1204            * @brief  Writes to the LCD RAM.
   1205            * @param  RGB_Code: the pixel color in RGB mode (5-6-5).
   1206            * @retval None
   1207            */
   1208          void LCD_WriteRAM(uint16_t RGB_Code)
   1209          {
   1210            /* Write 16-bit GRAM Reg */
   1211            LCD->LCD_RAM = RGB_Code;
   1212          }
   1213          
   1214          /**
   1215            * @brief  Reads the LCD RAM.
   1216            * @param  None
   1217            * @retval LCD RAM Value.
   1218            */
   1219          uint16_t LCD_ReadRAM(void)
   1220          {
   1221            /* Write 16-bit Index (then Read Reg) */
   1222            LCD->LCD_REG = LCD_REG_34; /* Select GRAM Reg */
   1223            /* Read 16-bit Reg */
   1224            return LCD->LCD_RAM;
   1225          }
   1226          
   1227          /**
   1228            * @brief  Power on the LCD.
   1229            * @param  None
   1230            * @retval None
   1231            */
   1232          void LCD_PowerOn(void)
   1233          {
   1234          /* Power On sequence ---------------------------------------------------------*/
   1235            LCD_WriteReg(LCD_REG_16, 0x0000); /* SAP, BT[3:0], AP, DSTB, SLP, STB */
   1236            LCD_WriteReg(LCD_REG_17, 0x0000); /* DC1[2:0], DC0[2:0], VC[2:0] */
   1237            LCD_WriteReg(LCD_REG_18, 0x0000); /* VREG1OUT voltage */
   1238            LCD_WriteReg(LCD_REG_19, 0x0000); /* VDV[4:0] for VCOM amplitude*/
   1239            _delay_(20);                 /* Dis-charge capacitor power voltage (200ms) */
   1240            LCD_WriteReg(LCD_REG_16, 0x17B0); /* SAP, BT[3:0], AP, DSTB, SLP, STB */
   1241            LCD_WriteReg(LCD_REG_17, 0x0137); /* DC1[2:0], DC0[2:0], VC[2:0] */
   1242            _delay_(5);                  /* Delay 50 ms */
   1243            LCD_WriteReg(LCD_REG_18, 0x0139); /* VREG1OUT voltage */
   1244            _delay_(5);                  /* Delay 50 ms */
   1245            LCD_WriteReg(LCD_REG_19, 0x1d00); /* VDV[4:0] for VCOM amplitude */
   1246            LCD_WriteReg(LCD_REG_41, 0x0013); /* VCM[4:0] for VCOMH */
   1247            _delay_(5);                  /* Delay 50 ms */
   1248            LCD_WriteReg(LCD_REG_7, 0x0173);  /* 262K color and display ON */
   1249          }
   1250          
   1251          /**
   1252            * @brief  Enables the Display.
   1253            * @param  None
   1254            * @retval None
   1255            */
   1256          void LCD_DisplayOn(void)
   1257          {
   1258            /* Display On */
   1259            LCD_WriteReg(LCD_REG_7, 0x0173); /* 262K color and display ON */
   1260          }
   1261          
   1262          /**
   1263            * @brief  Disables the Display.
   1264            * @param  None
   1265            * @retval None
   1266            */
   1267          void LCD_DisplayOff(void)
   1268          {
   1269            /* Display Off */
   1270            LCD_WriteReg(LCD_REG_7, 0x0); 
   1271          }
   1272          
   1273          /**
   1274            * @brief  Configures LCD Control lines (FSMC Pins) in alternate function mode.
   1275            * @param  None
   1276            * @retval None
   1277            */
   1278          void LCD_CtrlLinesConfig(void)
   1279          {
   1280            GPIO_InitTypeDef GPIO_InitStructure;
   1281          
   1282            /* Enable GPIOD, GPIOE, GPIOF, GPIOG and AFIO clocks */
   1283            RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOG | RCC_AHB1Periph_GPIOE |
   1284                                   RCC_AHB1Periph_GPIOF, ENABLE);
   1285          
   1286          /*-- GPIO Configuration ------------------------------------------------------*/
   1287            /* SRAM Data lines,  NOE and NWE configuration */
   1288            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_8 | GPIO_Pin_9 |
   1289                                          GPIO_Pin_10 | GPIO_Pin_14 | GPIO_Pin_15 |
   1290                                          GPIO_Pin_4 |GPIO_Pin_5;;
   1291            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   1292            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   1293            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   1294            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   1295          
   1296            GPIO_Init(GPIOD, &GPIO_InitStructure);
   1297            GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
   1298            GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
   1299            GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
   1300            GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
   1301            GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);
   1302            GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);
   1303            GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
   1304            GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
   1305            GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
   1306          
   1307            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
   1308                                          GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | 
   1309                                          GPIO_Pin_15;
   1310            GPIO_Init(GPIOE, &GPIO_InitStructure);
   1311          
   1312            GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);
   1313            GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);
   1314            GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);
   1315            GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_FSMC);
   1316            GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_FSMC);
   1317            GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_FSMC);
   1318            GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_FSMC);
   1319            GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_FSMC);
   1320            GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_FSMC);
   1321          
   1322            /* SRAM Address lines configuration */
   1323            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
   1324            GPIO_Init(GPIOF, &GPIO_InitStructure);  
   1325            GPIO_PinAFConfig(GPIOF, GPIO_PinSource0, GPIO_AF_FSMC);	   
   1326          
   1327            /* NE3 configuration */
   1328            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; 
   1329          
   1330            GPIO_Init(GPIOG, &GPIO_InitStructure);
   1331            GPIO_PinAFConfig(GPIOG, GPIO_PinSource10, GPIO_AF_FSMC);
   1332          }
   1333          
   1334          /**
   1335            * @brief  Configures the Parallel interface (FSMC) for LCD(Parallel mode)
   1336            * @param  None
   1337            * @retval None
   1338            */
   1339          void LCD_FSMCConfig(void)
   1340          {
   1341            FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
   1342            FSMC_NORSRAMTimingInitTypeDef  p;
   1343             
   1344            /* Enable FSMC clock */
   1345            RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
   1346            
   1347          /*-- FSMC Configuration ------------------------------------------------------*/
   1348          /*----------------------- SRAM Bank 3 ----------------------------------------*/
   1349            /* FSMC_Bank1_NORSRAM4 configuration */
   1350            p.FSMC_AddressSetupTime = 5;
   1351            p.FSMC_AddressHoldTime = 0;
   1352            p.FSMC_DataSetupTime = 9;
   1353            p.FSMC_BusTurnAroundDuration = 0;
   1354            p.FSMC_CLKDivision = 0;
   1355            p.FSMC_DataLatency = 0;
   1356            p.FSMC_AccessMode = FSMC_AccessMode_A;
   1357            /* Color LCD configuration ------------------------------------
   1358               LCD configured as follow:
   1359                  - Data/Address MUX = Disable
   1360                  - Memory Type = SRAM
   1361                  - Data Width = 16bit
   1362                  - Write Operation = Enable
   1363                  - Extended Mode = Enable
   1364                  - Asynchronous Wait = Disable */
   1365          
   1366            FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM3;
   1367            FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
   1368            FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;
   1369            FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
   1370            FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
   1371            FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
   1372            FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
   1373            FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
   1374            FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
   1375            FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
   1376            FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
   1377            FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
   1378            FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
   1379            FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;
   1380            FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;
   1381          
   1382            FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);   
   1383          
   1384            /* Enable FSMC NOR/SRAM Bank3 */
   1385            FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM3, ENABLE);
   1386          }
   1387          
   1388          /**
   1389            * @brief  Displays a pixel.
   1390            * @param  x: pixel x.
   1391            * @param  y: pixel y.  
   1392            * @retval None
   1393            */
   1394          static void PutPixel(int16_t x, int16_t y)
   1395          { 
   1396            if(x < 0 || x > 239 || y < 0 || y > 319)
   1397            {
   1398              return;  
   1399            }
   1400            LCD_DrawLine(x, y, 1, LCD_DIR_HORIZONTAL);
   1401          }
   1402          
   1403          
   1404          #ifndef USE_Delay
   1405          /**
   1406            * @brief  Inserts a delay time.
   1407            * @param  nCount: specifies the delay time length.
   1408            * @retval None
   1409            */
   1410          static void delay(__IO uint32_t nCount)
   1411          {
   1412            __IO uint32_t index = 0; 
   1413            for(index = (100000 * nCount); index != 0; index--)
   1414            {
   1415            }
   1416          }
   1417          #endif /* USE_Delay*/
   1418          /**
   1419            * @}
   1420            */ 
   1421          
   1422          /**
   1423            * @}
   1424            */ 
   1425            
   1426          /**
   1427            * @}
   1428            */ 
   1429          
   1430          /**
   1431            * @}
   1432            */ 
   1433            
   1434          /**
   1435            * @}
   1436            */  
   1437          
   1438          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  LCD_Clear
               8 -> LCD_SetCursor
       16  LCD_ClearLine
              16 -> LCD_DisplayChar
       16  LCD_ClosedPolyLine
               0 -> LCD_DrawUniLine
              16 -> LCD_PolyLine
        0  LCD_ClosedPolyLineRelative
               0 -> LCD_PolyLineRelativeClosed
       16  LCD_CtrlLinesConfig
              16 -> GPIO_Init
              16 -> GPIO_PinAFConfig
              16 -> RCC_AHB1PeriphClockCmd
       24  LCD_DeInit
              24 -> FSMC_NORSRAMCmd
              24 -> FSMC_NORSRAMDeInit
              24 -> GPIO_Init
              24 -> GPIO_PinAFConfig
        8  LCD_DisplayChar
               0 -> LCD_DrawChar
        0  LCD_DisplayOff
        0  LCD_DisplayOn
       24  LCD_DisplayStringLine
              24 -> LCD_DisplayChar
       32  LCD_DrawChar
              32 -> LCD_SetCursor
       48  LCD_DrawCircle
              48 -> LCD_SetCursor
       48  LCD_DrawFullCircle
               0 -> LCD_DrawCircle
              48 -> LCD_DrawLine
       32  LCD_DrawFullRect
              32 -> LCD_DrawLine
       32  LCD_DrawLine
              32 -> LCD_SetCursor
       16  LCD_DrawMonoPict
              16 -> LCD_SetCursor
       24  LCD_DrawRect
               0 -> LCD_DrawLine
              24 -> LCD_DrawLine
       48  LCD_DrawUniLine
              48 -> PutPixel
       96  LCD_FSMCConfig
              96 -> FSMC_NORSRAMCmd
              96 -> FSMC_NORSRAMInit
              96 -> RCC_AHB3PeriphClockCmd
      472  LCD_FillPolyLine
             472 -> LCD_DrawLine
             472 -> PutPixel
             472 -> __aeabi_cdcmple
             472 -> __aeabi_cdrcmple
             472 -> __aeabi_i2d
             472 -> __aeabi_ui2d
        0  LCD_GetColors
        0  LCD_GetFont
       16  LCD_PolyLine
              16 -> LCD_DrawUniLine
        0  LCD_PolyLineRelative
               0 -> LCD_PolyLineRelativeClosed
       32  LCD_PolyLineRelativeClosed
               0 -> LCD_DrawUniLine
              32 -> LCD_DrawUniLine
        8  LCD_PowerOn
               8 -> delay
        0  LCD_ReadRAM
        0  LCD_ReadReg
        4  LCD_SetBackColor
        8  LCD_SetColors
        0  LCD_SetCursor
       16  LCD_SetDisplayWindow
               0 -> LCD_SetCursor
        0  LCD_SetFont
        4  LCD_SetTextColor
        8  LCD_WindowModeDisable
               8 -> LCD_SetDisplayWindow
        8  LCD_WriteBMP
        0  LCD_WriteRAM
        0  LCD_WriteRAM_Prepare
        0  LCD_WriteReg
        0  PutPixel
               0 -> LCD_DrawLine
       40  STM324xG_LCD_Init
              40 -> LCD_CtrlLinesConfig
              40 -> LCD_FSMCConfig
              40 -> delay
        8  delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable19
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       8  ??Subroutine28_0
       4  ??Subroutine29_0
       6  ?Subroutine0
      92  ?Subroutine1
      10  ?Subroutine10
      10  ?Subroutine11
      10  ?Subroutine12
       6  ?Subroutine13
      10  ?Subroutine14
      10  ?Subroutine15
      10  ?Subroutine16
      10  ?Subroutine17
      10  ?Subroutine18
      10  ?Subroutine19
      16  ?Subroutine2
       8  ?Subroutine20
      18  ?Subroutine21
       8  ?Subroutine22
      16  ?Subroutine23
      18  ?Subroutine24
      14  ?Subroutine25
       8  ?Subroutine26
      12  ?Subroutine27
      10  ?Subroutine3
       6  ?Subroutine4
      24  ?Subroutine5
      10  ?Subroutine6
      10  ?Subroutine7
      10  ?Subroutine8
      10  ?Subroutine9
    2304  ASCII12x12_Table
    4560  ASCII16x24_Table
    2304  ASCII8x12_Table
    1536  ASCII8x8_Table
       8  Font12x12
       8  Font8x12
       8  Font8x8
      34  LCD_Clear
      46  LCD_ClearLine
      34  LCD_ClosedPolyLine
       4  LCD_ClosedPolyLineRelative
     180  LCD_CtrlLinesConfig
     394  LCD_DeInit
      28  LCD_DisplayChar
      14  LCD_DisplayOff
      16  LCD_DisplayOn
      54  LCD_DisplayStringLine
     122  LCD_DrawChar
     184  LCD_DrawCircle
     148  LCD_DrawFullCircle
     146  LCD_DrawFullRect
      76  LCD_DrawLine
      64  LCD_DrawMonoPict
      64  LCD_DrawRect
     170  LCD_DrawUniLine
      98  LCD_FSMCConfig
     506  LCD_FillPolyLine
      14  LCD_GetColors
       8  LCD_GetFont
      42  LCD_PolyLine
       4  LCD_PolyLineRelative
     102  LCD_PolyLineRelativeClosed
      96  LCD_PowerOn
      12  LCD_ReadRAM
      10  LCD_ReadReg
      16  LCD_SetBackColor
      22  LCD_SetColors
      14  LCD_SetCursor
      68  LCD_SetDisplayWindow
       8  LCD_SetFont
      16  LCD_SetTextColor
      34  LCD_WindowModeDisable
      70  LCD_WriteBMP
       6  LCD_WriteRAM
      10  LCD_WriteRAM_Prepare
       4  LCD_WriteReg
      24  PutPixel
     718  STM324xG_LCD_Init
      16  TextColor
          BackColor
          LCD_Currentfonts
          Font16x24
      32  delay

 
     40 bytes in section .data
 10 704 bytes in section .rodata
  4 152 bytes in section .text
 
  4 152 bytes of CODE  memory
 10 704 bytes of CONST memory
     40 bytes of DATA  memory

Errors: none
Warnings: none
