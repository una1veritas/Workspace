###############################################################################
#                                                                             #
#                                                       19/Sep/2012  16:16:21 #
# IAR ANSI C/C++ Compiler V6.40.2.33884/W32 KICKSTART for ARM                 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32_USB_Device_Library\C #
#                    lass\dfu\src\usbd_dfu_mal.c                              #
#    Command line =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32_USB_Device_Library\C #
#                    lass\dfu\src\usbd_dfu_mal.c -D USE_STDPERIPH_DRIVER -D   #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_USB_OTG_FS -lcN    #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\ -o                         #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\ --debug --endian=little     #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.4           #
#                    Kickstart\arm\INC\c\DLib_Config_Full.h" -I               #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM3 #
#                    2_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples #
#                    \DFU\EWARM\..\inc\ -I \\psf\Home\Documents\Eclipse\Works #
#                    pace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_De #
#                    vice_Examples\DFU\EWARM\..\..\..\..\Libraries\CMSIS\Devi #
#                    ce\ST\STM32F4xx\Include\ -I                              #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\  #
#                    -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB- #
#                    Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\E #
#                    WARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\in #
#                    c\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_U #
#                    SB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DF #
#                    U\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\C #
#                    lass\dfu\inc\ -I \\psf\Home\Documents\Eclipse\Workspace\ #
#                    ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_ #
#                    Examples\DFU\EWARM\..\..\..\..\Utilities\STM32_EVAL\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\Common\ -I            #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\    #
#                    -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.4                           #
#                    Kickstart\arm\CMSIS\Include\"                            #
#    List file    =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\usbd_dfu_mal.lst            #
#    Object file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\usbd_dfu_mal.o               #
#                                                                             #
#                                                                             #
###############################################################################

\\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Libraries\STM32_USB_Device_Library\Class\dfu\src\usbd_dfu_mal.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_dfu_mal.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    19-March-2012
      7            * @brief   Generic media access Layer.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbd_dfu_mal.h"
     30          
     31          #include "usbd_flash_if.h"
     32          
     33          #ifdef DFU_MAL_SUPPORT_OTP
     34           #include "usbd_otp_if.h"
     35          #endif
     36          
     37          #ifdef DFU_MAL_SUPPORT_MEM
     38           #include "usbd_mem_if_template.h"
     39          #endif
     40          
     41          /* Private typedef -----------------------------------------------------------*/
     42          /* Private define ------------------------------------------------------------*/
     43          /* Private macro -------------------------------------------------------------*/
     44          /* Private variables ---------------------------------------------------------*/
     45          
     46          /* Global Memories callback and string descriptors reference tables.
     47             To add a new memory, modify the value of MAX_USED_MEDIA in usbd_dfu_mal.h
     48             and add the pointer to the callback structure in this table.
     49             Then add the pointer to the memory string descriptor in usbd_dfu_StringDesc table.
     50             No other operation is required. */
     51          DFU_MAL_Prop_TypeDef* tMALTab[MAX_USED_MEDIA] = {
     52              &DFU_Flash_cb
     53          #ifdef DFU_MAL_SUPPORT_OTP
     54            , &DFU_Otp_cb
     55          #endif
     56          #ifdef DFU_MAL_SUPPORT_MEM
     57            , &DFU_Mem_cb
     58          #endif
     59          };
     60          
     61          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     62            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
     63              #pragma data_alignment=4   
     64            #endif
     65          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
     66          
     67          __ALIGN_BEGIN const uint8_t* usbd_dfu_StringDesc[MAX_USED_MEDIA] __ALIGN_END  = {
     68              FLASH_IF_STRING
     69          #ifdef DFU_MAL_SUPPORT_OTP
     70            , OTP_IF_STRING
     71          #endif
     72          #ifdef DFU_MAL_SUPPORT_MEM
     73            , MEM_IF_STRING
     74          #endif
     75          };
     76          
     77          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     78            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
     79              #pragma data_alignment=4   
     80            #endif
     81          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
     82          /* RAM Buffer for Downloaded Data */
     83          __ALIGN_BEGIN uint8_t  MAL_Buffer[XFERSIZE] __ALIGN_END ; 
     84          
     85          /* Private function prototypes -----------------------------------------------*/
     86          static uint8_t  MAL_CheckAdd  (uint32_t Add);
     87          /* Private functions ---------------------------------------------------------*/
     88          
     89          /**
     90            * @brief  MAL_Init
     91            *         Initializes the Media on the STM32
     92            * @param  None
     93            * @retval Result of the opeartion (MAL_OK in all cases)
     94            */
     95          uint16_t MAL_Init(void)
     96          {
     97            uint32_t memIdx = 0;
     98            
     99            /* Init all supported memories */
    100            for(memIdx = 0; memIdx < MAX_USED_MEDIA; memIdx++)
    101            {
    102              /* If the check addres is positive, exit with the memory index */
    103              if (tMALTab[memIdx]->pMAL_Init != NULL)
    104              {
    105                tMALTab[memIdx]->pMAL_Init();
    106              }
    107            }
    108          
    109            return MAL_OK;
    110          }
    111          
    112          /**
    113            * @brief  MAL_DeInit
    114            *         DeInitializes the Media on the STM32
    115            * @param  None
    116            * @retval Result of the opeartion (MAL_OK in all cases)
    117            */
    118          uint16_t MAL_DeInit(void)
    119          {
    120            uint32_t memIdx = 0;
    121            
    122            /* Init all supported memories */
    123            for(memIdx = 0; memIdx < MAX_USED_MEDIA; memIdx++)
    124            {
    125              /* Check if the command is supported */
    126              if (tMALTab[memIdx]->pMAL_DeInit != NULL)
    127              {
    128                tMALTab[memIdx]->pMAL_DeInit();
    129              }
    130            }
    131          
    132            return MAL_OK;
    133          }
    134          
    135          /**
    136            * @brief  MAL_Erase
    137            *         Erase a sector of memory.
    138            * @param  Add: Sector address/code
    139            * @retval Result of the opeartion: MAL_OK if all operations are OK else MAL_FAIL
    140            */
    141          uint16_t MAL_Erase(uint32_t Add)
    142          {
    143            uint32_t memIdx = MAL_CheckAdd(Add);
    144           
    145            /* Check if the area is protected */
    146            if (DFU_MAL_IS_PROTECTED_AREA(Add))
    147            {
    148              return MAL_FAIL;
    149            }    
    150            
    151            if (memIdx < MAX_USED_MEDIA)
    152            {
    153              /* Check if the command is supported */
    154              if (tMALTab[memIdx]->pMAL_Erase != NULL)
    155              {
    156                return tMALTab[memIdx]->pMAL_Erase(Add);
    157              }
    158              else
    159              {
    160                return MAL_FAIL;
    161              }
    162            }
    163            else
    164            {
    165              return MAL_FAIL;
    166            }
    167          }
    168          
    169          /**
    170            * @brief  MAL_Write
    171            *         Write sectors of memory.
    172            * @param  Add: Sector address/code
    173            * @param  Len: Number of data to be written (in bytes)
    174            * @retval Result of the opeartion: MAL_OK if all operations are OK else MAL_FAIL
    175            */
    176          uint16_t MAL_Write (uint32_t Add, uint32_t Len)
    177          {
    178            uint32_t memIdx = MAL_CheckAdd(Add);
    179           
    180            /* Check if the area is protected */
    181            if (DFU_MAL_IS_PROTECTED_AREA(Add))
    182            {
    183              return MAL_FAIL;
    184            }   
    185            
    186            if (memIdx < MAX_USED_MEDIA)
    187            {
    188              /* Check if the command is supported */
    189              if (tMALTab[memIdx]->pMAL_Write != NULL)
    190              {
    191                return tMALTab[memIdx]->pMAL_Write(Add, Len);
    192              }
    193              else
    194              {
    195                return MAL_FAIL;
    196              }    
    197            }
    198            else
    199            {
    200              return MAL_FAIL;
    201            }
    202          }
    203          
    204          /**
    205            * @brief  MAL_Read
    206            *         Read sectors of memory.
    207            * @param  Add: Sector address/code
    208            * @param  Len: Number of data to be written (in bytes)
    209            * @retval Buffer pointer
    210            */
    211          uint8_t *MAL_Read (uint32_t Add, uint32_t Len)
    212          {
    213            uint32_t memIdx = MAL_CheckAdd(Add);
    214            
    215            if (memIdx < MAX_USED_MEDIA)
    216            {
    217              /* Check if the command is supported */
    218              if (tMALTab[memIdx]->pMAL_Read != NULL)
    219              {
    220                return tMALTab[memIdx]->pMAL_Read(Add, Len);
    221              }
    222              else
    223              {
    224                return MAL_Buffer;
    225              }     
    226            }
    227            else
    228            {
    229              return MAL_Buffer;
    230            }
    231          }
    232          
    233          /**
    234            * @brief  MAL_GetStatus
    235            *         Get the status of a given memory.
    236            * @param  Add: Sector address/code (allow to determine which memory will be addressed)
    237            * @param  Cmd: 0 for erase and 1 for write
    238            * @param  buffer: pointer to the buffer where the status data will be stored.
    239            * @retval Buffer pointer
    240            */
    241          uint16_t MAL_GetStatus(uint32_t Add , uint8_t Cmd, uint8_t *buffer)
    242          {
    243            uint32_t memIdx = MAL_CheckAdd(Add);
    244            
    245            if (memIdx < MAX_USED_MEDIA)
    246            {
    247              if (Cmd & 0x01)
    248              {
    249                SET_POLLING_TIMING(tMALTab[memIdx]->EraseTiming);
    250              }
    251              else
    252              {
    253                SET_POLLING_TIMING(tMALTab[memIdx]->WriteTiming);
    254              }
    255              
    256              return MAL_OK;
    257            }
    258            else
    259            {
    260              return MAL_FAIL;
    261            }
    262          }
    263          
    264          /**
    265            * @brief  MAL_CheckAdd
    266            *         Determine which memory should be managed.
    267            * @param  Add: Sector address/code (allow to determine which memory will be addressed)
    268            * @retval Index of the addressed memory.
    269            */
    270          static uint8_t  MAL_CheckAdd(uint32_t Add)
    271          {
    272            uint32_t memIdx = 0;
    273            
    274            /* Check with all supported memories */
    275            for(memIdx = 0; memIdx < MAX_USED_MEDIA; memIdx++)
    276            {
    277              /* If the check addres is positive, exit with the memory index */
    278              if (tMALTab[memIdx]->pMAL_CheckAdd(Add) == MAL_OK)
    279              {
    280                return memIdx;
    281              }
    282            }
    283            /* If no memory found, return MAX_USED_MEDIA */
    284            return (MAX_USED_MEDIA);
    285          }
    286          
    287          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  MAL_CheckAdd
             16 -- Indirect call
       16  MAL_DeInit
             16 -- Indirect call
        8  MAL_Erase
              0 -- Indirect call
              8 -> MAL_CheckAdd
       16  MAL_GetStatus
             16 -> MAL_CheckAdd
       16  MAL_Init
             16 -- Indirect call
       16  MAL_Read
              0 -- Indirect call
             16 -> MAL_CheckAdd
       16  MAL_Write
              0 -- Indirect call
             16 -> MAL_CheckAdd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      68  ?<Constant "@Internal Flash   /0x...">
      44  ?<Constant "@OTP Area   /0x1FFF78...">
       4  ??DataTable6
      34  MAL_CheckAdd
      28  MAL_DeInit
      46  MAL_Erase
      78  MAL_GetStatus
      28  MAL_Init
      42  MAL_Read
      50  MAL_Write
    1032  tMALTab
          MAL_Buffer
       8  usbd_dfu_StringDesc

 
 1 040 bytes in section .data
   112 bytes in section .rodata
   310 bytes in section .text
 
   310 bytes of CODE  memory
   112 bytes of CONST memory
 1 040 bytes of DATA  memory

Errors: none
Warnings: none
