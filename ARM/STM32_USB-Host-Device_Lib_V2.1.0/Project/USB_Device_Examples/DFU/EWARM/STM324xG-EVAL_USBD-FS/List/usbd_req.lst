###############################################################################
#                                                                             #
#                                                       19/Sep/2012  16:16:24 #
# IAR ANSI C/C++ Compiler V6.40.2.33884/W32 KICKSTART for ARM                 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32_USB_Device_Library\C #
#                    ore\src\usbd_req.c                                       #
#    Command line =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32_USB_Device_Library\C #
#                    ore\src\usbd_req.c -D USE_STDPERIPH_DRIVER -D STM32F4XX  #
#                    -D USE_STM324xG_EVAL -D USE_USB_OTG_FS -lcN              #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\ -o                         #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\ --debug --endian=little     #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.4           #
#                    Kickstart\arm\INC\c\DLib_Config_Full.h" -I               #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM3 #
#                    2_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples #
#                    \DFU\EWARM\..\inc\ -I \\psf\Home\Documents\Eclipse\Works #
#                    pace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_De #
#                    vice_Examples\DFU\EWARM\..\..\..\..\Libraries\CMSIS\Devi #
#                    ce\ST\STM32F4xx\Include\ -I                              #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\  #
#                    -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB- #
#                    Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\E #
#                    WARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\in #
#                    c\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_U #
#                    SB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DF #
#                    U\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\C #
#                    lass\dfu\inc\ -I \\psf\Home\Documents\Eclipse\Workspace\ #
#                    ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_ #
#                    Examples\DFU\EWARM\..\..\..\..\Utilities\STM32_EVAL\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\Common\ -I            #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\    #
#                    -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.4                           #
#                    Kickstart\arm\CMSIS\Include\"                            #
#    List file    =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\usbd_req.lst                #
#    Object file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\usbd_req.o                   #
#                                                                             #
#                                                                             #
###############################################################################

\\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Libraries\STM32_USB_Device_Library\Core\src\usbd_req.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_req.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    19-March-2012 
      7            * @brief   This file provides the standard USB requests following chapter 9.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbd_req.h"
     30          #include "usbd_ioreq.h"
     31          #include "usbd_desc.h"
     32          
     33          
     34          /** @addtogroup STM32_USB_OTG_DEVICE_LIBRARY
     35            * @{
     36            */
     37          
     38          
     39          /** @defgroup USBD_REQ 
     40            * @brief USB standard requests module
     41            * @{
     42            */ 
     43          
     44          /** @defgroup USBD_REQ_Private_TypesDefinitions
     45            * @{
     46            */ 
     47          /**
     48            * @}
     49            */ 
     50          
     51          
     52          /** @defgroup USBD_REQ_Private_Defines
     53            * @{
     54            */ 
     55          
     56          /**
     57            * @}
     58            */ 
     59          
     60          
     61          /** @defgroup USBD_REQ_Private_Macros
     62            * @{
     63            */ 
     64          /**
     65            * @}
     66            */ 
     67          
     68          
     69          /** @defgroup USBD_REQ_Private_Variables
     70            * @{
     71            */ 
     72          extern __IO USB_OTG_DCTL_TypeDef SET_TEST_MODE;
     73          
     74          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     75            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
     76              #pragma data_alignment=4   
     77            #endif
     78          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */  
     79          __ALIGN_BEGIN uint32_t USBD_ep_status __ALIGN_END  = 0; 
     80          
     81          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     82            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
     83              #pragma data_alignment=4   
     84            #endif
     85          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
     86          __ALIGN_BEGIN uint32_t  USBD_default_cfg __ALIGN_END  = 0;
     87          
     88          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     89            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
     90              #pragma data_alignment=4   
     91            #endif
     92          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
     93          __ALIGN_BEGIN uint32_t  USBD_cfg_status __ALIGN_END  = 0;  
     94          
     95          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     96            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
     97              #pragma data_alignment=4   
     98            #endif
     99          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    100          __ALIGN_BEGIN uint8_t USBD_StrDesc[USB_MAX_STR_DESC_SIZ] __ALIGN_END ;
    101          /**
    102            * @}
    103            */ 
    104          
    105          
    106          /** @defgroup USBD_REQ_Private_FunctionPrototypes
    107            * @{
    108            */ 
    109          static void USBD_GetDescriptor(USB_OTG_CORE_HANDLE  *pdev, 
    110                                         USB_SETUP_REQ *req);
    111          
    112          static void USBD_SetAddress(USB_OTG_CORE_HANDLE  *pdev, 
    113                                      USB_SETUP_REQ *req);
    114          
    115          static void USBD_SetConfig(USB_OTG_CORE_HANDLE  *pdev, 
    116                                     USB_SETUP_REQ *req);
    117          
    118          static void USBD_GetConfig(USB_OTG_CORE_HANDLE  *pdev, 
    119                                     USB_SETUP_REQ *req);
    120          
    121          static void USBD_GetStatus(USB_OTG_CORE_HANDLE  *pdev, 
    122                                     USB_SETUP_REQ *req);
    123          
    124          static void USBD_SetFeature(USB_OTG_CORE_HANDLE  *pdev, 
    125                                      USB_SETUP_REQ *req);
    126          
    127          static void USBD_ClrFeature(USB_OTG_CORE_HANDLE  *pdev, 
    128                                      USB_SETUP_REQ *req);
    129          
    130          static uint8_t USBD_GetLen(uint8_t *buf);
    131          /**
    132            * @}
    133            */ 
    134          
    135          
    136          /** @defgroup USBD_REQ_Private_Functions
    137            * @{
    138            */ 
    139          
    140          
    141          /**
    142          * @brief  USBD_StdDevReq
    143          *         Handle standard usb device requests
    144          * @param  pdev: device instance
    145          * @param  req: usb request
    146          * @retval status
    147          */
    148          USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
    149          {
    150            USBD_Status ret = USBD_OK;  
    151            
    152            switch (req->bRequest) 
    153            {
    154            case USB_REQ_GET_DESCRIPTOR: 
    155              
    156              USBD_GetDescriptor (pdev, req) ;
    157              break;
    158              
    159            case USB_REQ_SET_ADDRESS:                      
    160              USBD_SetAddress(pdev, req);
    161              break;
    162              
    163            case USB_REQ_SET_CONFIGURATION:                    
    164              USBD_SetConfig (pdev , req);
    165              break;
    166              
    167            case USB_REQ_GET_CONFIGURATION:                 
    168              USBD_GetConfig (pdev , req);
    169              break;
    170              
    171            case USB_REQ_GET_STATUS:                                  
    172              USBD_GetStatus (pdev , req);
    173              break;
    174              
    175              
    176            case USB_REQ_SET_FEATURE:   
    177              USBD_SetFeature (pdev , req);    
    178              break;
    179              
    180            case USB_REQ_CLEAR_FEATURE:                                   
    181              USBD_ClrFeature (pdev , req);
    182              break;
    183              
    184            default:  
    185              USBD_CtlError(pdev , req);
    186              break;
    187            }
    188            
    189            return ret;
    190          }
    191          
    192          /**
    193          * @brief  USBD_StdItfReq
    194          *         Handle standard usb interface requests
    195          * @param  pdev: USB OTG device instance
    196          * @param  req: usb request
    197          * @retval status
    198          */
    199          USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
    200          {
    201            USBD_Status ret = USBD_OK; 
    202            
    203            switch (pdev->dev.device_status) 
    204            {
    205            case USB_OTG_CONFIGURED:
    206              
    207              if (LOBYTE(req->wIndex) <= USBD_ITF_MAX_NUM) 
    208              {
    209                pdev->dev.class_cb->Setup (pdev, req); 
    210                
    211                if((req->wLength == 0)&& (ret == USBD_OK))
    212                {
    213                   USBD_CtlSendStatus(pdev);
    214                }
    215              } 
    216              else 
    217              {                                               
    218                 USBD_CtlError(pdev , req);
    219              }
    220              break;
    221              
    222            default:
    223               USBD_CtlError(pdev , req);
    224              break;
    225            }
    226            return ret;
    227          }
    228          
    229          /**
    230          * @brief  USBD_StdEPReq
    231          *         Handle standard usb endpoint requests
    232          * @param  pdev: USB OTG device instance
    233          * @param  req: usb request
    234          * @retval status
    235          */
    236          USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
    237          {
    238            
    239            uint8_t   ep_addr;
    240            USBD_Status ret = USBD_OK; 
    241            
    242            ep_addr  = LOBYTE(req->wIndex);   
    243            
    244            switch (req->bRequest) 
    245            {
    246              
    247            case USB_REQ_SET_FEATURE :
    248              
    249              switch (pdev->dev.device_status) 
    250              {
    251              case USB_OTG_ADDRESSED:          
    252                if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
    253                {
    254                  DCD_EP_Stall(pdev , ep_addr);
    255                }
    256                break;	
    257                
    258              case USB_OTG_CONFIGURED:   
    259                if (req->wValue == USB_FEATURE_EP_HALT)
    260                {
    261                  if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
    262                  { 
    263                    DCD_EP_Stall(pdev , ep_addr);
    264                    
    265                  }
    266                }
    267                pdev->dev.class_cb->Setup (pdev, req);   
    268                USBD_CtlSendStatus(pdev);
    269                
    270                break;
    271                
    272              default:                         
    273                USBD_CtlError(pdev , req);
    274                break;    
    275              }
    276              break;
    277              
    278            case USB_REQ_CLEAR_FEATURE :
    279              
    280              switch (pdev->dev.device_status) 
    281              {
    282              case USB_OTG_ADDRESSED:          
    283                if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
    284                {
    285                  DCD_EP_Stall(pdev , ep_addr);
    286                }
    287                break;	
    288                
    289              case USB_OTG_CONFIGURED:   
    290                if (req->wValue == USB_FEATURE_EP_HALT)
    291                {
    292                  if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
    293                  {        
    294                    DCD_EP_ClrStall(pdev , ep_addr);
    295                    pdev->dev.class_cb->Setup (pdev, req);
    296                  }
    297                  USBD_CtlSendStatus(pdev);
    298                }
    299                break;
    300                
    301              default:                         
    302                 USBD_CtlError(pdev , req);
    303                break;    
    304              }
    305              break;
    306              
    307            case USB_REQ_GET_STATUS:                  
    308              switch (pdev->dev.device_status) 
    309              {
    310              case USB_OTG_ADDRESSED:          
    311                if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
    312                {
    313                  DCD_EP_Stall(pdev , ep_addr);
    314                }
    315                break;	
    316                
    317              case USB_OTG_CONFIGURED:         
    318                
    319                
    320                if ((ep_addr & 0x80)== 0x80)
    321                {
    322                  if(pdev->dev.in_ep[ep_addr & 0x7F].is_stall)
    323                  {
    324                    USBD_ep_status = 0x0001;     
    325                  }
    326                  else
    327                  {
    328                    USBD_ep_status = 0x0000;  
    329                  }
    330                }
    331                else if ((ep_addr & 0x80)== 0x00)
    332                {
    333                  if(pdev->dev.out_ep[ep_addr].is_stall)
    334                  {
    335                    USBD_ep_status = 0x0001;     
    336                  }
    337                  
    338                  else 
    339                  {
    340                    USBD_ep_status = 0x0000;     
    341                  }      
    342                }
    343                USBD_CtlSendData (pdev,
    344                                  (uint8_t *)&USBD_ep_status,
    345                                  2);
    346                break;
    347                
    348              default:                         
    349                 USBD_CtlError(pdev , req);
    350                break;
    351              }
    352              break;
    353              
    354            default:
    355              break;
    356            }
    357            return ret;
    358          }
    359          /**
    360          * @brief  USBD_GetDescriptor
    361          *         Handle Get Descriptor requests
    362          * @param  pdev: device instance
    363          * @param  req: usb request
    364          * @retval status
    365          */
    366          static void USBD_GetDescriptor(USB_OTG_CORE_HANDLE  *pdev, 
    367                                         USB_SETUP_REQ *req)
    368          {
    369            uint16_t len;
    370            uint8_t *pbuf;
    371            
    372              
    373            switch (req->wValue >> 8)
    374            {
    375            case USB_DESC_TYPE_DEVICE:
    376              pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
    377              if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
    378              {                  
    379                len = 8;
    380              }
    381              break;
    382              
    383            case USB_DESC_TYPE_CONFIGURATION:
    384                pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
    385          #ifdef USB_OTG_HS_CORE
    386              if((pdev->cfg.speed == USB_OTG_SPEED_FULL )&&
    387                 (pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY))
    388              {
    389                pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    390              }
    391          #endif  
    392              pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    393              pdev->dev.pConfig_descriptor = pbuf;    
    394              break;
    395              
    396            case USB_DESC_TYPE_STRING:
    397              switch ((uint8_t)(req->wValue))
    398              {
    399              case USBD_IDX_LANGID_STR:
    400               pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
    401                break;
    402                
    403              case USBD_IDX_MFC_STR:
    404                pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
    405                break;
    406                
    407              case USBD_IDX_PRODUCT_STR:
    408                pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
    409                break;
    410                
    411              case USBD_IDX_SERIAL_STR:
    412                pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
    413                break;
    414                
    415              case USBD_IDX_CONFIG_STR:
    416                pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
    417                break;
    418                
    419              case USBD_IDX_INTERFACE_STR:
    420                pbuf = pdev->dev.usr_device->GetInterfaceStrDescriptor(pdev->cfg.speed, &len);
    421                break;
    422                
    423              default:
    424          #ifdef USB_SUPPORT_USER_STRING_DESC
    425                pbuf = pdev->dev.class_cb->GetUsrStrDescriptor(pdev->cfg.speed, (req->wValue) , &len);
    426                break;
    427          #else      
    428                 USBD_CtlError(pdev , req);
    429                return;
    430          #endif /* USBD_CtlError(pdev , req); */      
    431              }
    432              break;
    433            case USB_DESC_TYPE_DEVICE_QUALIFIER:                   
    434          #ifdef USB_OTG_HS_CORE
    435              if(pdev->cfg.speed == USB_OTG_SPEED_HIGH  )   
    436              {
    437                
    438                pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
    439                      
    440                USBD_DeviceQualifierDesc[4]= pbuf[14];
    441                USBD_DeviceQualifierDesc[5]= pbuf[15];
    442                USBD_DeviceQualifierDesc[6]= pbuf[16];
    443                
    444                pbuf = USBD_DeviceQualifierDesc;
    445                len  = USB_LEN_DEV_QUALIFIER_DESC;
    446                break;
    447              }
    448              else
    449              {
    450                USBD_CtlError(pdev , req);
    451                return;
    452              }
    453          #else
    454                USBD_CtlError(pdev , req);
    455                return;
    456          #endif    
    457          
    458            case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    459          #ifdef USB_OTG_HS_CORE   
    460          
    461              if(pdev->cfg.speed == USB_OTG_SPEED_HIGH  )   
    462              {
    463                pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    464                pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
    465                break; 
    466              }
    467              else
    468              {
    469                USBD_CtlError(pdev , req);
    470                return;
    471              }
    472          #else
    473                USBD_CtlError(pdev , req);
    474                return;
    475          #endif     
    476          
    477              
    478            default: 
    479               USBD_CtlError(pdev , req);
    480              return;
    481            }
    482            
    483            if((len != 0)&& (req->wLength != 0))
    484            {
    485              
    486              len = MIN(len , req->wLength);
    487              
    488              USBD_CtlSendData (pdev, 
    489                                pbuf,
    490                                len);
    491            }
    492            
    493          }
    494          
    495          /**
    496          * @brief  USBD_SetAddress
    497          *         Set device address
    498          * @param  pdev: device instance
    499          * @param  req: usb request
    500          * @retval status
    501          */
    502          static void USBD_SetAddress(USB_OTG_CORE_HANDLE  *pdev, 
    503                                      USB_SETUP_REQ *req)
    504          {
    505            uint8_t  dev_addr; 
    506            
    507            if ((req->wIndex == 0) && (req->wLength == 0)) 
    508            {
    509              dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    510              
    511              if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
    512              {
    513                USBD_CtlError(pdev , req);
    514              } 
    515              else 
    516              {
    517                pdev->dev.device_address = dev_addr;
    518                DCD_EP_SetAddress(pdev, dev_addr);               
    519                USBD_CtlSendStatus(pdev);                         
    520                
    521                if (dev_addr != 0) 
    522                {
    523                  pdev->dev.device_status  = USB_OTG_ADDRESSED;
    524                } 
    525                else 
    526                {
    527                  pdev->dev.device_status  = USB_OTG_DEFAULT; 
    528                }
    529              }
    530            } 
    531            else 
    532            {
    533               USBD_CtlError(pdev , req);                        
    534            } 
    535          }
    536          
    537          /**
    538          * @brief  USBD_SetConfig
    539          *         Handle Set device configuration request
    540          * @param  pdev: device instance
    541          * @param  req: usb request
    542          * @retval status
    543          */
    544          static void USBD_SetConfig(USB_OTG_CORE_HANDLE  *pdev, 
    545                                     USB_SETUP_REQ *req)
    546          {
    547            
    548            static uint8_t  cfgidx;
    549            
    550            cfgidx = (uint8_t)(req->wValue);                 
    551            
    552            if (cfgidx > USBD_CFG_MAX_NUM ) 
    553            {            
    554               USBD_CtlError(pdev , req);                              
    555            } 
    556            else 
    557            {
    558              switch (pdev->dev.device_status) 
    559              {
    560              case USB_OTG_ADDRESSED:
    561                if (cfgidx) 
    562                {                                			   							   							   				
    563                  pdev->dev.device_config = cfgidx;
    564                  pdev->dev.device_status = USB_OTG_CONFIGURED;
    565                  USBD_SetCfg(pdev , cfgidx);
    566                  USBD_CtlSendStatus(pdev);
    567                }
    568                else 
    569                {
    570                   USBD_CtlSendStatus(pdev);
    571                }
    572                break;
    573                
    574              case USB_OTG_CONFIGURED:
    575                if (cfgidx == 0) 
    576                {                           
    577                  pdev->dev.device_status = USB_OTG_ADDRESSED;
    578                  pdev->dev.device_config = cfgidx;          
    579                  USBD_ClrCfg(pdev , cfgidx);
    580                  USBD_CtlSendStatus(pdev);
    581                  
    582                } 
    583                else  if (cfgidx != pdev->dev.device_config) 
    584                {
    585                  /* Clear old configuration */
    586                  USBD_ClrCfg(pdev , pdev->dev.device_config);
    587                  
    588                  /* set new configuration */
    589                  pdev->dev.device_config = cfgidx;
    590                  USBD_SetCfg(pdev , cfgidx);
    591                  USBD_CtlSendStatus(pdev);
    592                }
    593                else
    594                {
    595                  USBD_CtlSendStatus(pdev);
    596                }
    597                break;
    598                
    599              default:					
    600                 USBD_CtlError(pdev , req);                     
    601                break;
    602              }
    603            }
    604          }
    605          
    606          /**
    607          * @brief  USBD_GetConfig
    608          *         Handle Get device configuration request
    609          * @param  pdev: device instance
    610          * @param  req: usb request
    611          * @retval status
    612          */
    613          static void USBD_GetConfig(USB_OTG_CORE_HANDLE  *pdev, 
    614                                     USB_SETUP_REQ *req)
    615          {
    616           
    617            if (req->wLength != 1) 
    618            {                   
    619               USBD_CtlError(pdev , req);
    620            }
    621            else 
    622            {
    623              switch (pdev->dev.device_status )  
    624              {
    625              case USB_OTG_ADDRESSED:                     
    626                
    627                USBD_CtlSendData (pdev, 
    628                                  (uint8_t *)&USBD_default_cfg,
    629                                  1);
    630                break;
    631                
    632              case USB_OTG_CONFIGURED:                   
    633                
    634                USBD_CtlSendData (pdev, 
    635                                  &pdev->dev.device_config,
    636                                  1);
    637                break;
    638                
    639              default:
    640                 USBD_CtlError(pdev , req);
    641                break;
    642              }
    643            }
    644          }
    645          
    646          /**
    647          * @brief  USBD_GetStatus
    648          *         Handle Get Status request
    649          * @param  pdev: device instance
    650          * @param  req: usb request
    651          * @retval status
    652          */
    653          static void USBD_GetStatus(USB_OTG_CORE_HANDLE  *pdev, 
    654                                     USB_SETUP_REQ *req)
    655          {
    656            
    657              
    658            switch (pdev->dev.device_status) 
    659            {
    660            case USB_OTG_ADDRESSED:
    661            case USB_OTG_CONFIGURED:
    662              
    663          #ifdef USBD_SELF_POWERED
    664              USBD_cfg_status = USB_CONFIG_SELF_POWERED;                                    
    665          #else
    666              USBD_cfg_status = 0x00;                                    
    667          #endif
    668                                
    669              if (pdev->dev.DevRemoteWakeup) 
    670              {
    671                USBD_cfg_status |= USB_CONFIG_REMOTE_WAKEUP;                                
    672              }
    673              
    674              USBD_CtlSendData (pdev, 
    675                                (uint8_t *)&USBD_cfg_status,
    676                                2);
    677              break;
    678              
    679            default :
    680              USBD_CtlError(pdev , req);                        
    681              break;
    682            }
    683          }
    684          
    685          
    686          /**
    687          * @brief  USBD_SetFeature
    688          *         Handle Set device feature request
    689          * @param  pdev: device instance
    690          * @param  req: usb request
    691          * @retval status
    692          */
    693          static void USBD_SetFeature(USB_OTG_CORE_HANDLE  *pdev, 
    694                                      USB_SETUP_REQ *req)
    695          {
    696          
    697            USB_OTG_DCTL_TypeDef     dctl;
    698            uint8_t test_mode = 0;
    699           
    700            if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
    701            {
    702              pdev->dev.DevRemoteWakeup = 1;  
    703              pdev->dev.class_cb->Setup (pdev, req);   
    704              USBD_CtlSendStatus(pdev);
    705            }
    706          
    707            else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
    708                     ((req->wIndex & 0xFF) == 0))
    709            {
    710              dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
    711              
    712              test_mode = req->wIndex >> 8;
    713              switch (test_mode) 
    714              {
    715              case 1: // TEST_J
    716                dctl.b.tstctl = 1;
    717                break;
    718                
    719              case 2: // TEST_K	
    720                dctl.b.tstctl = 2;
    721                break;
    722                
    723              case 3: // TEST_SE0_NAK
    724                dctl.b.tstctl = 3;
    725                break;
    726                
    727              case 4: // TEST_PACKET
    728                dctl.b.tstctl = 4;
    729                break;
    730                
    731              case 5: // TEST_FORCE_ENABLE
    732                dctl.b.tstctl = 5;
    733                break;
    734              }
    735              SET_TEST_MODE = dctl;
    736              pdev->dev.test_mode = 1;
    737              USBD_CtlSendStatus(pdev);
    738            }
    739          
    740          }
    741          
    742          
    743          /**
    744          * @brief  USBD_ClrFeature
    745          *         Handle clear device feature request
    746          * @param  pdev: device instance
    747          * @param  req: usb request
    748          * @retval status
    749          */
    750          static void USBD_ClrFeature(USB_OTG_CORE_HANDLE  *pdev, 
    751                                      USB_SETUP_REQ *req)
    752          {
    753            switch (pdev->dev.device_status)
    754            {
    755            case USB_OTG_ADDRESSED:
    756            case USB_OTG_CONFIGURED:
    757              if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    758              {
    759                pdev->dev.DevRemoteWakeup = 0; 
    760                pdev->dev.class_cb->Setup (pdev, req);   
    761                USBD_CtlSendStatus(pdev);
    762              }
    763              break;
    764              
    765            default :
    766               USBD_CtlError(pdev , req);
    767              break;
    768            }
    769          }
    770          
    771          /**
    772          * @brief  USBD_ParseSetupRequest 
    773          *         Copy buffer into setup structure
    774          * @param  pdev: device instance
    775          * @param  req: usb request
    776          * @retval None
    777          */
    778          
    779          void USBD_ParseSetupRequest( USB_OTG_CORE_HANDLE  *pdev,
    780                                      USB_SETUP_REQ *req)
    781          {
    782            req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
    783            req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
    784            req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
    785            req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
    786            req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
    787            
    788            pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
    789            pdev->dev.device_state = USB_OTG_EP0_SETUP;
    790          }
    791          
    792          /**
    793          * @brief  USBD_CtlError 
    794          *         Handle USB low level Error
    795          * @param  pdev: device instance
    796          * @param  req: usb request
    797          * @retval None
    798          */
    799          
    800          void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
    801                                      USB_SETUP_REQ *req)
    802          {
    803            
    804            DCD_EP_Stall(pdev , 0x80);
    805            DCD_EP_Stall(pdev , 0);
    806            USB_OTG_EP0_OutStart(pdev);  
    807          }
    808          
    809          
    810          /**
    811            * @brief  USBD_GetString
    812            *         Convert Ascii string into unicode one
    813            * @param  desc : descriptor buffer
    814            * @param  unicode : Formatted string buffer (unicode)
    815            * @param  len : descriptor length
    816            * @retval None
    817            */
    818          void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
    819          {
    820            uint8_t idx = 0;
    821            
    822            if (desc != NULL) 
    823            {
    824              *len =  USBD_GetLen(desc) * 2 + 2;    
    825              unicode[idx++] = *len;
    826              unicode[idx++] =  USB_DESC_TYPE_STRING;
    827              
    828              while (*desc != NULL) 
    829              {
    830                unicode[idx++] = *desc++;
    831                unicode[idx++] =  0x00;
    832              }
    833            } 
    834          }
    835          
    836          /**
    837            * @brief  USBD_GetLen
    838            *         return the string length
    839             * @param  buf : pointer to the ascii string buffer
    840            * @retval string length
    841            */
    842          static uint8_t USBD_GetLen(uint8_t *buf)
    843          {
    844              uint8_t  len = 0;
    845          
    846              while (*buf != NULL) 
    847              {
    848                  len++;
    849                  buf++;
    850              }
    851          
    852              return len;
    853          }
    854          /**
    855            * @}
    856            */ 
    857          
    858          
    859          /**
    860            * @}
    861            */ 
    862          
    863          
    864          /**
    865            * @}
    866            */ 
    867          
    868          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  USBD_CtlError
              8 -> DCD_EP_Stall
              0 -> USB_OTG_EP0_OutStart
       24  USBD_GetDescriptor
             24 -- Indirect call
             24 -> USBD_CtlError
             24 -> USBD_CtlSendData
       12  USBD_GetString
        8  USBD_ParseSetupRequest
       16  USBD_StdDevReq
             16 -- Indirect call
             16 -> DCD_EP_SetAddress
             16 -> USBD_ClrCfg
             16 -> USBD_CtlError
             16 -> USBD_CtlSendData
             16 -> USBD_CtlSendStatus
             16 -> USBD_GetDescriptor
             16 -> USBD_SetCfg
       16  USBD_StdEPReq
             16 -- Indirect call
             16 -> DCD_EP_ClrStall
             16 -> DCD_EP_Stall
             16 -> USBD_CtlError
             16 -> USBD_CtlSendData
             16 -> USBD_CtlSendStatus
       16  USBD_StdItfReq
             16 -- Indirect call
             16 -> USBD_CtlError
             16 -> USBD_CtlSendStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       6  ?Subroutine0
       8  ?Subroutine1
      26  USBD_CtlError
     224  USBD_GetDescriptor
      68  USBD_GetString
      60  USBD_ParseSetupRequest
     344  USBD_StdDevReq
     188  USBD_StdEPReq
      52  USBD_StdItfReq
     200  USBD_StrDesc
       4  USBD_ep_status
      12  cfgidx
          USBD_cfg_status
          USBD_default_cfg

 
 216 bytes in section .bss
 988 bytes in section .text
 
 988 bytes of CODE memory
 216 bytes of DATA memory

Errors: none
Warnings: none
