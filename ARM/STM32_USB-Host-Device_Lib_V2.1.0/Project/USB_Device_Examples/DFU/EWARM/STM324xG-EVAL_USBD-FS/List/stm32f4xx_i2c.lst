###############################################################################
#                                                                             #
#                                                       19/Sep/2012  16:16:09 #
# IAR ANSI C/C++ Compiler V6.40.2.33884/W32 KICKSTART for ARM                 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32F4xx_StdPeriph_Driver #
#                    \src\stm32f4xx_i2c.c                                     #
#    Command line =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Libraries\STM32F4xx_StdPeriph_Driver #
#                    \src\stm32f4xx_i2c.c -D USE_STDPERIPH_DRIVER -D          #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_USB_OTG_FS -lcN    #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\ -o                         #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\ --debug --endian=little     #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.4           #
#                    Kickstart\arm\INC\c\DLib_Config_Full.h" -I               #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM3 #
#                    2_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples #
#                    \DFU\EWARM\..\inc\ -I \\psf\Home\Documents\Eclipse\Works #
#                    pace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_De #
#                    vice_Examples\DFU\EWARM\..\..\..\..\Libraries\CMSIS\Devi #
#                    ce\ST\STM32F4xx\Include\ -I                              #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\  #
#                    -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB- #
#                    Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\E #
#                    WARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\in #
#                    c\ -I \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_U #
#                    SB-Host-Device_Lib_V2.1.0\Project\USB_Device_Examples\DF #
#                    U\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\C #
#                    lass\dfu\inc\ -I \\psf\Home\Documents\Eclipse\Workspace\ #
#                    ARM\STM32_USB-Host-Device_Lib_V2.1.0\Project\USB_Device_ #
#                    Examples\DFU\EWARM\..\..\..\..\Utilities\STM32_EVAL\ -I  #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\Common\ -I            #
#                    \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\    #
#                    -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.4                           #
#                    Kickstart\arm\CMSIS\Include\"                            #
#    List file    =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\List\stm32f4xx_i2c.lst           #
#    Object file  =  \\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Hos #
#                    t-Device_Lib_V2.1.0\Project\USB_Device_Examples\DFU\EWAR #
#                    M\STM324xG-EVAL_USBD-FS\Obj\stm32f4xx_i2c.o              #
#                                                                             #
#                                                                             #
###############################################################################

\\psf\Home\Documents\Eclipse\Workspace\ARM\STM32_USB-Host-Device_Lib_V2.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.0.2
      6            * @date    05-March-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Inter-integrated circuit (I2C)
      9            *           - Initialization and Configuration
     10            *           - Data transfers
     11            *           - PEC management
     12            *           - DMA transfers management
     13            *           - Interrupts, events and flags management 
     14            *           
     15            *  @verbatim
     16            *    
     17            *          ===================================================================
     18            *                                 How to use this driver
     19            *          ===================================================================
     20            *          1. Enable peripheral clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2Cx, ENABLE)
     21            *             function for I2C1, I2C2 or I2C3.
     22            *
     23            *          2. Enable SDA, SCL  and SMBA (when used) GPIO clocks using 
     24            *             RCC_AHBPeriphClockCmd() function. 
     25            *
     26            *          3. Peripherals alternate function: 
     27            *                 - Connect the pin to the desired peripherals' Alternate 
     28            *                   Function (AF) using GPIO_PinAFConfig() function
     29            *                 - Configure the desired pin in alternate function by:
     30            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     31            *                 - Select the type, pull-up/pull-down and output speed via 
     32            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     33            *                 - Call GPIO_Init() function
     34            *                 Recommended configuration is Push-Pull, Pull-up, Open-Drain.
     35            *                 Add an external pull up if necessary (typically 4.7 KOhm).      
     36            *        
     37            *          4. Program the Mode, duty cycle , Own address, Ack, Speed and Acknowledged
     38            *             Address using the I2C_Init() function.
     39            *
     40            *          5. Optionally you can enable/configure the following parameters without
     41            *             re-initialization (i.e there is no need to call again I2C_Init() function):
     42            *              - Enable the acknowledge feature using I2C_AcknowledgeConfig() function
     43            *              - Enable the dual addressing mode using I2C_DualAddressCmd() function
     44            *              - Enable the general call using the I2C_GeneralCallCmd() function
     45            *              - Enable the clock stretching using I2C_StretchClockCmd() function
     46            *              - Enable the fast mode duty cycle using the I2C_FastModeDutyCycleConfig()
     47            *                function.
     48            *              - Configure the NACK position for Master Receiver mode in case of 
     49            *                2 bytes reception using the function I2C_NACKPositionConfig().  
     50            *              - Enable the PEC Calculation using I2C_CalculatePEC() function
     51            *              - For SMBus Mode: 
     52            *                   - Enable the Address Resolution Protocol (ARP) using I2C_ARPCmd() function
     53            *                   - Configure the SMBusAlert pin using I2C_SMBusAlertConfig() function
     54            *
     55            *          6. Enable the NVIC and the corresponding interrupt using the function 
     56            *             I2C_ITConfig() if you need to use interrupt mode. 
     57            *
     58            *          7. When using the DMA mode 
     59            *                   - Configure the DMA using DMA_Init() function
     60            *                   - Active the needed channel Request using I2C_DMACmd() or
     61            *                     I2C_DMALastTransferCmd() function.
     62            *              @note When using DMA mode, I2C interrupts may be used at the same time to
     63            *                    control the communication flow (Start/Stop/Ack... events and errors).
     64            * 
     65            *          8. Enable the I2C using the I2C_Cmd() function.
     66            * 
     67            *          9. Enable the DMA using the DMA_Cmd() function when using DMA mode in the 
     68            *             transfers. 
     69            *
     70            *  @endverbatim
     71            *  
     72            ******************************************************************************
     73            * @attention
     74            *
     75            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     76            *
     77            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     78            * You may not use this file except in compliance with the License.
     79            * You may obtain a copy of the License at:
     80            *
     81            *        http://www.st.com/software_license_agreement_liberty_v2
     82            *
     83            * Unless required by applicable law or agreed to in writing, software 
     84            * distributed under the License is distributed on an "AS IS" BASIS, 
     85            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     86            * See the License for the specific language governing permissions and
     87            * limitations under the License.
     88            *
     89            ******************************************************************************
     90            */ 
     91          
     92          /* Includes ------------------------------------------------------------------*/
     93          #include "stm32f4xx_i2c.h"
     94          #include "stm32f4xx_rcc.h"
     95          
     96          /** @addtogroup STM32F4xx_StdPeriph_Driver
     97            * @{
     98            */
     99          
    100          /** @defgroup I2C 
    101            * @brief I2C driver modules
    102            * @{
    103            */ 
    104          
    105          /* Private typedef -----------------------------------------------------------*/
    106          /* Private define ------------------------------------------------------------*/
    107          
    108          #define CR1_CLEAR_MASK    ((uint16_t)0xFBF5)      /*<! I2C registers Masks */
    109          #define FLAG_MASK         ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */
    110          #define ITEN_MASK         ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */
    111          
    112          /* Private macro -------------------------------------------------------------*/
    113          /* Private variables ---------------------------------------------------------*/
    114          /* Private function prototypes -----------------------------------------------*/
    115          /* Private functions ---------------------------------------------------------*/
    116          
    117          /** @defgroup I2C_Private_Functions
    118            * @{
    119            */
    120          
    121          /** @defgroup I2C_Group1 Initialization and Configuration functions
    122           *  @brief   Initialization and Configuration functions 
    123           *
    124          @verbatim   
    125           ===============================================================================
    126                             Initialization and Configuration functions
    127           ===============================================================================  
    128          
    129          @endverbatim
    130            * @{
    131            */
    132          
    133          /**
    134            * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
    135            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    136            * @retval None
    137            */
    138          void I2C_DeInit(I2C_TypeDef* I2Cx)
    139          {
    140            /* Check the parameters */
    141            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    142          
    143            if (I2Cx == I2C1)
    144            {
    145              /* Enable I2C1 reset state */
    146              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
    147              /* Release I2C1 from reset state */
    148              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
    149            }
    150            else if (I2Cx == I2C2)
    151            {
    152              /* Enable I2C2 reset state */
    153              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
    154              /* Release I2C2 from reset state */
    155              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
    156            }
    157            else 
    158            {
    159              if (I2Cx == I2C3)
    160              {
    161                /* Enable I2C3 reset state */
    162                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
    163                /* Release I2C3 from reset state */
    164                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
    165              }
    166            }
    167          }
    168          
    169          /**
    170            * @brief  Initializes the I2Cx peripheral according to the specified 
    171            *         parameters in the I2C_InitStruct.
    172            *           
    173            * @note   To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency 
    174            *         (I2C peripheral input clock) must be a multiple of 10 MHz.  
    175            *           
    176            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    177            * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
    178            *         the configuration information for the specified I2C peripheral.
    179            * @retval None
    180            */
    181          void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
    182          {
    183            uint16_t tmpreg = 0, freqrange = 0;
    184            uint16_t result = 0x04;
    185            uint32_t pclk1 = 8000000;
    186            RCC_ClocksTypeDef  rcc_clocks;
    187            /* Check the parameters */
    188            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    189            assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
    190            assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
    191            assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
    192            assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
    193            assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
    194            assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
    195          
    196          /*---------------------------- I2Cx CR2 Configuration ------------------------*/
    197            /* Get the I2Cx CR2 value */
    198            tmpreg = I2Cx->CR2;
    199            /* Clear frequency FREQ[5:0] bits */
    200            tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
    201            /* Get pclk1 frequency value */
    202            RCC_GetClocksFreq(&rcc_clocks);
    203            pclk1 = rcc_clocks.PCLK1_Frequency;
    204            /* Set frequency bits depending on pclk1 value */
    205            freqrange = (uint16_t)(pclk1 / 1000000);
    206            tmpreg |= freqrange;
    207            /* Write to I2Cx CR2 */
    208            I2Cx->CR2 = tmpreg;
    209          
    210          /*---------------------------- I2Cx CCR Configuration ------------------------*/
    211            /* Disable the selected I2C peripheral to configure TRISE */
    212            I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
    213            /* Reset tmpreg value */
    214            /* Clear F/S, DUTY and CCR[11:0] bits */
    215            tmpreg = 0;
    216          
    217            /* Configure speed in standard mode */
    218            if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
    219            {
    220              /* Standard mode speed calculate */
    221              result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
    222              /* Test if CCR value is under 0x4*/
    223              if (result < 0x04)
    224              {
    225                /* Set minimum allowed value */
    226                result = 0x04;  
    227              }
    228              /* Set speed value for standard mode */
    229              tmpreg |= result;	  
    230              /* Set Maximum Rise Time for standard mode */
    231              I2Cx->TRISE = freqrange + 1; 
    232            }
    233            /* Configure speed in fast mode */
    234            /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
    235               input clock) must be a multiple of 10 MHz */
    236            else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
    237            {
    238              if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
    239              {
    240                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    241                result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
    242              }
    243              else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    244              {
    245                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    246                result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
    247                /* Set DUTY bit */
    248                result |= I2C_DutyCycle_16_9;
    249              }
    250          
    251              /* Test if CCR value is under 0x1*/
    252              if ((result & I2C_CCR_CCR) == 0)
    253              {
    254                /* Set minimum allowed value */
    255                result |= (uint16_t)0x0001;  
    256              }
    257              /* Set speed value and set F/S bit for fast mode */
    258              tmpreg |= (uint16_t)(result | I2C_CCR_FS);
    259              /* Set Maximum Rise Time for fast mode */
    260              I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
    261            }
    262          
    263            /* Write to I2Cx CCR */
    264            I2Cx->CCR = tmpreg;
    265            /* Enable the selected I2C peripheral */
    266            I2Cx->CR1 |= I2C_CR1_PE;
    267          
    268          /*---------------------------- I2Cx CR1 Configuration ------------------------*/
    269            /* Get the I2Cx CR1 value */
    270            tmpreg = I2Cx->CR1;
    271            /* Clear ACK, SMBTYPE and  SMBUS bits */
    272            tmpreg &= CR1_CLEAR_MASK;
    273            /* Configure I2Cx: mode and acknowledgement */
    274            /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
    275            /* Set ACK bit according to I2C_Ack value */
    276            tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
    277            /* Write to I2Cx CR1 */
    278            I2Cx->CR1 = tmpreg;
    279          
    280          /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
    281            /* Set I2Cx Own Address1 and acknowledged address */
    282            I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
    283          }
    284          
    285          /**
    286            * @brief  Fills each I2C_InitStruct member with its default value.
    287            * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
    288            * @retval None
    289            */
    290          void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
    291          {
    292          /*---------------- Reset I2C init structure parameters values ----------------*/
    293            /* initialize the I2C_ClockSpeed member */
    294            I2C_InitStruct->I2C_ClockSpeed = 5000;
    295            /* Initialize the I2C_Mode member */
    296            I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
    297            /* Initialize the I2C_DutyCycle member */
    298            I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
    299            /* Initialize the I2C_OwnAddress1 member */
    300            I2C_InitStruct->I2C_OwnAddress1 = 0;
    301            /* Initialize the I2C_Ack member */
    302            I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
    303            /* Initialize the I2C_AcknowledgedAddress member */
    304            I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    305          }
    306          
    307          /**
    308            * @brief  Enables or disables the specified I2C peripheral.
    309            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    310            * @param  NewState: new state of the I2Cx peripheral. 
    311            *          This parameter can be: ENABLE or DISABLE.
    312            * @retval None
    313            */
    314          void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    315          {
    316            /* Check the parameters */
    317            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    318            assert_param(IS_FUNCTIONAL_STATE(NewState));
    319            if (NewState != DISABLE)
    320            {
    321              /* Enable the selected I2C peripheral */
    322              I2Cx->CR1 |= I2C_CR1_PE;
    323            }
    324            else
    325            {
    326              /* Disable the selected I2C peripheral */
    327              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
    328            }
    329          }
    330          
    331          /**
    332            * @brief  Generates I2Cx communication START condition.
    333            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    334            * @param  NewState: new state of the I2C START condition generation.
    335            *          This parameter can be: ENABLE or DISABLE.
    336            * @retval None.
    337            */
    338          void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
    339          {
    340            /* Check the parameters */
    341            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    342            assert_param(IS_FUNCTIONAL_STATE(NewState));
    343            if (NewState != DISABLE)
    344            {
    345              /* Generate a START condition */
    346              I2Cx->CR1 |= I2C_CR1_START;
    347            }
    348            else
    349            {
    350              /* Disable the START condition generation */
    351              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
    352            }
    353          }
    354          
    355          /**
    356            * @brief  Generates I2Cx communication STOP condition.
    357            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    358            * @param  NewState: new state of the I2C STOP condition generation.
    359            *          This parameter can be: ENABLE or DISABLE.
    360            * @retval None.
    361            */
    362          void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
    363          {
    364            /* Check the parameters */
    365            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    366            assert_param(IS_FUNCTIONAL_STATE(NewState));
    367            if (NewState != DISABLE)
    368            {
    369              /* Generate a STOP condition */
    370              I2Cx->CR1 |= I2C_CR1_STOP;
    371            }
    372            else
    373            {
    374              /* Disable the STOP condition generation */
    375              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
    376            }
    377          }
    378          
    379          /**
    380            * @brief  Transmits the address byte to select the slave device.
    381            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    382            * @param  Address: specifies the slave address which will be transmitted
    383            * @param  I2C_Direction: specifies whether the I2C device will be a Transmitter
    384            *         or a Receiver. 
    385            *          This parameter can be one of the following values
    386            *            @arg I2C_Direction_Transmitter: Transmitter mode
    387            *            @arg I2C_Direction_Receiver: Receiver mode
    388            * @retval None.
    389            */
    390          void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
    391          {
    392            /* Check the parameters */
    393            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    394            assert_param(IS_I2C_DIRECTION(I2C_Direction));
    395            /* Test on the direction to set/reset the read/write bit */
    396            if (I2C_Direction != I2C_Direction_Transmitter)
    397            {
    398              /* Set the address bit0 for read */
    399              Address |= I2C_OAR1_ADD0;
    400            }
    401            else
    402            {
    403              /* Reset the address bit0 for write */
    404              Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
    405            }
    406            /* Send the address */
    407            I2Cx->DR = Address;
    408          }
    409          
    410          /**
    411            * @brief  Enables or disables the specified I2C acknowledge feature.
    412            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    413            * @param  NewState: new state of the I2C Acknowledgement.
    414            *          This parameter can be: ENABLE or DISABLE.
    415            * @retval None.
    416            */
    417          void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
    418          {
    419            /* Check the parameters */
    420            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    421            assert_param(IS_FUNCTIONAL_STATE(NewState));
    422            if (NewState != DISABLE)
    423            {
    424              /* Enable the acknowledgement */
    425              I2Cx->CR1 |= I2C_CR1_ACK;
    426            }
    427            else
    428            {
    429              /* Disable the acknowledgement */
    430              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
    431            }
    432          }
    433          
    434          /**
    435            * @brief  Configures the specified I2C own address2.
    436            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    437            * @param  Address: specifies the 7bit I2C own address2.
    438            * @retval None.
    439            */
    440          void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
    441          {
    442            uint16_t tmpreg = 0;
    443          
    444            /* Check the parameters */
    445            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    446          
    447            /* Get the old register value */
    448            tmpreg = I2Cx->OAR2;
    449          
    450            /* Reset I2Cx Own address2 bit [7:1] */
    451            tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
    452          
    453            /* Set I2Cx Own address2 */
    454            tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
    455          
    456            /* Store the new register value */
    457            I2Cx->OAR2 = tmpreg;
    458          }
    459          
    460          /**
    461            * @brief  Enables or disables the specified I2C dual addressing mode.
    462            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    463            * @param  NewState: new state of the I2C dual addressing mode.
    464            *          This parameter can be: ENABLE or DISABLE.
    465            * @retval None
    466            */
    467          void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    468          {
    469            /* Check the parameters */
    470            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    471            assert_param(IS_FUNCTIONAL_STATE(NewState));
    472            if (NewState != DISABLE)
    473            {
    474              /* Enable dual addressing mode */
    475              I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
    476            }
    477            else
    478            {
    479              /* Disable dual addressing mode */
    480              I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
    481            }
    482          }
    483          
    484          /**
    485            * @brief  Enables or disables the specified I2C general call feature.
    486            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    487            * @param  NewState: new state of the I2C General call.
    488            *          This parameter can be: ENABLE or DISABLE.
    489            * @retval None
    490            */
    491          void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    492          {
    493            /* Check the parameters */
    494            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    495            assert_param(IS_FUNCTIONAL_STATE(NewState));
    496            if (NewState != DISABLE)
    497            {
    498              /* Enable generall call */
    499              I2Cx->CR1 |= I2C_CR1_ENGC;
    500            }
    501            else
    502            {
    503              /* Disable generall call */
    504              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
    505            }
    506          }
    507          
    508          /**
    509            * @brief  Enables or disables the specified I2C software reset.
    510            * @note   When software reset is enabled, the I2C IOs are released (this can
    511            *         be useful to recover from bus errors).  
    512            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    513            * @param  NewState: new state of the I2C software reset.
    514            *          This parameter can be: ENABLE or DISABLE.
    515            * @retval None
    516            */
    517          void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    518          {
    519            /* Check the parameters */
    520            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    521            assert_param(IS_FUNCTIONAL_STATE(NewState));
    522            if (NewState != DISABLE)
    523            {
    524              /* Peripheral under reset */
    525              I2Cx->CR1 |= I2C_CR1_SWRST;
    526            }
    527            else
    528            {
    529              /* Peripheral not under reset */
    530              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
    531            }
    532          }
    533          
    534          /**
    535            * @brief  Enables or disables the specified I2C Clock stretching.
    536            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    537            * @param  NewState: new state of the I2Cx Clock stretching.
    538            *          This parameter can be: ENABLE or DISABLE.
    539            * @retval None
    540            */
    541          void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    542          {
    543            /* Check the parameters */
    544            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    545            assert_param(IS_FUNCTIONAL_STATE(NewState));
    546            if (NewState == DISABLE)
    547            {
    548              /* Enable the selected I2C Clock stretching */
    549              I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
    550            }
    551            else
    552            {
    553              /* Disable the selected I2C Clock stretching */
    554              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
    555            }
    556          }
    557          
    558          /**
    559            * @brief  Selects the specified I2C fast mode duty cycle.
    560            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    561            * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
    562            *          This parameter can be one of the following values:
    563            *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    564            *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    565            * @retval None
    566            */
    567          void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
    568          {
    569            /* Check the parameters */
    570            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    571            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    572            if (I2C_DutyCycle != I2C_DutyCycle_16_9)
    573            {
    574              /* I2C fast mode Tlow/Thigh=2 */
    575              I2Cx->CCR &= I2C_DutyCycle_2;
    576            }
    577            else
    578            {
    579              /* I2C fast mode Tlow/Thigh=16/9 */
    580              I2Cx->CCR |= I2C_DutyCycle_16_9;
    581            }
    582          }
    583          
    584          /**
    585            * @brief  Selects the specified I2C NACK position in master receiver mode.
    586            * @note   This function is useful in I2C Master Receiver mode when the number
    587            *         of data to be received is equal to 2. In this case, this function 
    588            *         should be called (with parameter I2C_NACKPosition_Next) before data 
    589            *         reception starts,as described in the 2-byte reception procedure 
    590            *         recommended in Reference Manual in Section: Master receiver.                
    591            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    592            * @param  I2C_NACKPosition: specifies the NACK position. 
    593            *          This parameter can be one of the following values:
    594            *            @arg I2C_NACKPosition_Next: indicates that the next byte will be the last
    595            *                                        received byte.  
    596            *            @arg I2C_NACKPosition_Current: indicates that current byte is the last 
    597            *                                           received byte.
    598            *            
    599            * @note    This function configures the same bit (POS) as I2C_PECPositionConfig() 
    600            *          but is intended to be used in I2C mode while I2C_PECPositionConfig() 
    601            *          is intended to used in SMBUS mode. 
    602            *            
    603            * @retval None
    604            */
    605          void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
    606          {
    607            /* Check the parameters */
    608            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    609            assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
    610            
    611            /* Check the input parameter */
    612            if (I2C_NACKPosition == I2C_NACKPosition_Next)
    613            {
    614              /* Next byte in shift register is the last received byte */
    615              I2Cx->CR1 |= I2C_NACKPosition_Next;
    616            }
    617            else
    618            {
    619              /* Current byte in shift register is the last received byte */
    620              I2Cx->CR1 &= I2C_NACKPosition_Current;
    621            }
    622          }
    623          
    624          /**
    625            * @brief  Drives the SMBusAlert pin high or low for the specified I2C.
    626            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    627            * @param  I2C_SMBusAlert: specifies SMBAlert pin level. 
    628            *          This parameter can be one of the following values:
    629            *            @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
    630            *            @arg I2C_SMBusAlert_High: SMBAlert pin driven high
    631            * @retval None
    632            */
    633          void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
    634          {
    635            /* Check the parameters */
    636            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    637            assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
    638            if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
    639            {
    640              /* Drive the SMBusAlert pin Low */
    641              I2Cx->CR1 |= I2C_SMBusAlert_Low;
    642            }
    643            else
    644            {
    645              /* Drive the SMBusAlert pin High  */
    646              I2Cx->CR1 &= I2C_SMBusAlert_High;
    647            }
    648          }
    649          
    650          /**
    651            * @brief  Enables or disables the specified I2C ARP.
    652            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    653            * @param  NewState: new state of the I2Cx ARP. 
    654            *          This parameter can be: ENABLE or DISABLE.
    655            * @retval None
    656            */
    657          void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    658          {
    659            /* Check the parameters */
    660            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    661            assert_param(IS_FUNCTIONAL_STATE(NewState));
    662            if (NewState != DISABLE)
    663            {
    664              /* Enable the selected I2C ARP */
    665              I2Cx->CR1 |= I2C_CR1_ENARP;
    666            }
    667            else
    668            {
    669              /* Disable the selected I2C ARP */
    670              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
    671            }
    672          }
    673          /**
    674            * @}
    675            */
    676          
    677          /** @defgroup I2C_Group2 Data transfers functions
    678           *  @brief   Data transfers functions 
    679           *
    680          @verbatim   
    681           ===============================================================================
    682                                  Data transfers functions
    683           ===============================================================================  
    684          
    685          @endverbatim
    686            * @{
    687            */
    688          
    689          /**
    690            * @brief  Sends a data byte through the I2Cx peripheral.
    691            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    692            * @param  Data: Byte to be transmitted..
    693            * @retval None
    694            */
    695          void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
    696          {
    697            /* Check the parameters */
    698            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    699            /* Write in the DR register the data to be sent */
    700            I2Cx->DR = Data;
    701          }
    702          
    703          /**
    704            * @brief  Returns the most recent received data by the I2Cx peripheral.
    705            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    706            * @retval The value of the received data.
    707            */
    708          uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
    709          {
    710            /* Check the parameters */
    711            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    712            /* Return the data in the DR register */
    713            return (uint8_t)I2Cx->DR;
    714          }
    715          
    716          /**
    717            * @}
    718            */
    719          
    720          /** @defgroup I2C_Group3 PEC management functions
    721           *  @brief   PEC management functions 
    722           *
    723          @verbatim   
    724           ===============================================================================
    725                                   PEC management functions
    726           ===============================================================================  
    727          
    728          @endverbatim
    729            * @{
    730            */
    731          
    732          /**
    733            * @brief  Enables or disables the specified I2C PEC transfer.
    734            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    735            * @param  NewState: new state of the I2C PEC transmission.
    736            *          This parameter can be: ENABLE or DISABLE.
    737            * @retval None
    738            */
    739          void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    740          {
    741            /* Check the parameters */
    742            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    743            assert_param(IS_FUNCTIONAL_STATE(NewState));
    744            if (NewState != DISABLE)
    745            {
    746              /* Enable the selected I2C PEC transmission */
    747              I2Cx->CR1 |= I2C_CR1_PEC;
    748            }
    749            else
    750            {
    751              /* Disable the selected I2C PEC transmission */
    752              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
    753            }
    754          }
    755          
    756          /**
    757            * @brief  Selects the specified I2C PEC position.
    758            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    759            * @param  I2C_PECPosition: specifies the PEC position. 
    760            *          This parameter can be one of the following values:
    761            *            @arg I2C_PECPosition_Next: indicates that the next byte is PEC
    762            *            @arg I2C_PECPosition_Current: indicates that current byte is PEC
    763            *       
    764            * @note    This function configures the same bit (POS) as I2C_NACKPositionConfig()
    765            *          but is intended to be used in SMBUS mode while I2C_NACKPositionConfig() 
    766            *          is intended to used in I2C mode.
    767            *                
    768            * @retval None
    769            */
    770          void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
    771          {
    772            /* Check the parameters */
    773            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    774            assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
    775            if (I2C_PECPosition == I2C_PECPosition_Next)
    776            {
    777              /* Next byte in shift register is PEC */
    778              I2Cx->CR1 |= I2C_PECPosition_Next;
    779            }
    780            else
    781            {
    782              /* Current byte in shift register is PEC */
    783              I2Cx->CR1 &= I2C_PECPosition_Current;
    784            }
    785          }
    786          
    787          /**
    788            * @brief  Enables or disables the PEC value calculation of the transferred bytes.
    789            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    790            * @param  NewState: new state of the I2Cx PEC value calculation.
    791            *          This parameter can be: ENABLE or DISABLE.
    792            * @retval None
    793            */
    794          void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    795          {
    796            /* Check the parameters */
    797            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    798            assert_param(IS_FUNCTIONAL_STATE(NewState));
    799            if (NewState != DISABLE)
    800            {
    801              /* Enable the selected I2C PEC calculation */
    802              I2Cx->CR1 |= I2C_CR1_ENPEC;
    803            }
    804            else
    805            {
    806              /* Disable the selected I2C PEC calculation */
    807              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
    808            }
    809          }
    810          
    811          /**
    812            * @brief  Returns the PEC value for the specified I2C.
    813            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    814            * @retval The PEC value.
    815            */
    816          uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
    817          {
    818            /* Check the parameters */
    819            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    820            /* Return the selected I2C PEC value */
    821            return ((I2Cx->SR2) >> 8);
    822          }
    823          
    824          /**
    825            * @}
    826            */
    827          
    828          /** @defgroup I2C_Group4 DMA transfers management functions
    829           *  @brief   DMA transfers management functions 
    830           *
    831          @verbatim   
    832           ===============================================================================
    833                                   DMA transfers management functions
    834           ===============================================================================  
    835            This section provides functions allowing to configure the I2C DMA channels 
    836            requests.
    837            
    838          @endverbatim
    839            * @{
    840            */
    841          
    842          /**
    843            * @brief  Enables or disables the specified I2C DMA requests.
    844            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    845            * @param  NewState: new state of the I2C DMA transfer.
    846            *          This parameter can be: ENABLE or DISABLE.
    847            * @retval None
    848            */
    849          void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    850          {
    851            /* Check the parameters */
    852            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    853            assert_param(IS_FUNCTIONAL_STATE(NewState));
    854            if (NewState != DISABLE)
    855            {
    856              /* Enable the selected I2C DMA requests */
    857              I2Cx->CR2 |= I2C_CR2_DMAEN;
    858            }
    859            else
    860            {
    861              /* Disable the selected I2C DMA requests */
    862              I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
    863            }
    864          }
    865          
    866          /**
    867            * @brief  Specifies that the next DMA transfer is the last one.
    868            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    869            * @param  NewState: new state of the I2C DMA last transfer.
    870            *          This parameter can be: ENABLE or DISABLE.
    871            * @retval None
    872            */
    873          void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    874          {
    875            /* Check the parameters */
    876            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    877            assert_param(IS_FUNCTIONAL_STATE(NewState));
    878            if (NewState != DISABLE)
    879            {
    880              /* Next DMA transfer is the last transfer */
    881              I2Cx->CR2 |= I2C_CR2_LAST;
    882            }
    883            else
    884            {
    885              /* Next DMA transfer is not the last transfer */
    886              I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
    887            }
    888          }
    889          
    890          /**
    891            * @}
    892            */
    893          
    894          /** @defgroup I2C_Group5 Interrupts events and flags management functions
    895           *  @brief   Interrupts, events and flags management functions
    896           *
    897          @verbatim   
    898           ===============================================================================
    899                          Interrupts, events and flags management functions
    900           ===============================================================================  
    901            This section provides functions allowing to configure the I2C Interrupts 
    902            sources and check or clear the flags or pending bits status.
    903            The user should identify which mode will be used in his application to manage 
    904            the communication: Polling mode, Interrupt mode or DMA mode. 
    905          
    906           ===============================================================================
    907                                    I2C State Monitoring Functions                    
    908           ===============================================================================   
    909            This I2C driver provides three different ways for I2C state monitoring
    910            depending on the application requirements and constraints:
    911                   
    912             
    913               1. Basic state monitoring (Using I2C_CheckEvent() function)
    914               -----------------------------------------------------------
    915                  It compares the status registers (SR1 and SR2) content to a given event
    916                  (can be the combination of one or more flags).
    917                  It returns SUCCESS if the current status includes the given flags 
    918                  and returns ERROR if one or more flags are missing in the current status.
    919          
    920                    - When to use
    921                       - This function is suitable for most applications as well as for startup 
    922                         activity since the events are fully described in the product reference 
    923                         manual (RM0090).
    924                       - It is also suitable for users who need to define their own events.
    925          
    926                    - Limitations
    927                       - If an error occurs (ie. error flags are set besides to the monitored 
    928                         flags), the I2C_CheckEvent() function may return SUCCESS despite 
    929                         the communication hold or corrupted real state. 
    930                         In this case, it is advised to use error interrupts to monitor 
    931                         the error events and handle them in the interrupt IRQ handler.
    932                   
    933               @note 
    934                   For error management, it is advised to use the following functions:
    935                     - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
    936                     - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
    937                       Where x is the peripheral instance (I2C1, I2C2 ...)
    938                     - I2C_GetFlagStatus() or I2C_GetITStatus()  to be called into the 
    939                       I2Cx_ER_IRQHandler() function in order to determine which error occurred.
    940                     - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd() 
    941                       and/or I2C_GenerateStop() in order to clear the error flag and source 
    942                       and return to correct  communication status.
    943                       
    944           
    945               2. Advanced state monitoring (Using the function I2C_GetLastEvent())
    946               -------------------------------------------------------------------- 
    947                  Using the function I2C_GetLastEvent() which returns the image of both status 
    948                  registers in a single word (uint32_t) (Status Register 2 value is shifted left 
    949                  by 16 bits and concatenated to Status Register 1).
    950          
    951                    - When to use
    952                       - This function is suitable for the same applications above but it 
    953                         allows to overcome the mentioned limitation of I2C_GetFlagStatus() 
    954                         function.
    955                       - The returned value could be compared to events already defined in 
    956                         the library (stm32f4xx_i2c.h) or to custom values defined by user.
    957                         This function is suitable when multiple flags are monitored at the 
    958                         same time.
    959                       - At the opposite of I2C_CheckEvent() function, this function allows 
    960                         user to choose when an event is accepted (when all events flags are 
    961                         set and no other flags are set or just when the needed flags are set 
    962                         like I2C_CheckEvent() function.
    963          
    964                    - Limitations
    965                       - User may need to define his own events.
    966                       - Same remark concerning the error management is applicable for this 
    967                         function if user decides to check only regular communication flags 
    968                         (and ignores error flags).
    969                
    970           
    971               3. Flag-based state monitoring (Using the function I2C_GetFlagStatus())
    972               -----------------------------------------------------------------------
    973               
    974                Using the function I2C_GetFlagStatus() which simply returns the status of 
    975                one single flag (ie. I2C_FLAG_RXNE ...). 
    976          
    977                    - When to use
    978                       - This function could be used for specific applications or in debug 
    979                         phase.
    980                       - It is suitable when only one flag checking is needed (most I2C 
    981                         events are monitored through multiple flags).
    982                    - Limitations: 
    983                       - When calling this function, the Status register is accessed. 
    984                         Some flags are cleared when the status register is accessed. 
    985                         So checking the status of one Flag, may clear other ones.
    986                       - Function may need to be called twice or more in order to monitor 
    987                         one single event.
    988           
    989             For detailed description of Events, please refer to section I2C_Events in 
    990             stm32f4xx_i2c.h file.
    991                 
    992          @endverbatim
    993            * @{
    994            */
    995             
    996          /**
    997            * @brief  Reads the specified I2C register and returns its value.
    998            * @param  I2C_Register: specifies the register to read.
    999            *          This parameter can be one of the following values:
   1000            *            @arg I2C_Register_CR1:  CR1 register.
   1001            *            @arg I2C_Register_CR2:   CR2 register.
   1002            *            @arg I2C_Register_OAR1:  OAR1 register.
   1003            *            @arg I2C_Register_OAR2:  OAR2 register.
   1004            *            @arg I2C_Register_DR:    DR register.
   1005            *            @arg I2C_Register_SR1:   SR1 register.
   1006            *            @arg I2C_Register_SR2:   SR2 register.
   1007            *            @arg I2C_Register_CCR:   CCR register.
   1008            *            @arg I2C_Register_TRISE: TRISE register.
   1009            * @retval The value of the read register.
   1010            */
   1011          uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
   1012          {
   1013            __IO uint32_t tmp = 0;
   1014          
   1015            /* Check the parameters */
   1016            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1017            assert_param(IS_I2C_REGISTER(I2C_Register));
   1018          
   1019            tmp = (uint32_t) I2Cx;
   1020            tmp += I2C_Register;
   1021          
   1022            /* Return the selected register value */
   1023            return (*(__IO uint16_t *) tmp);
   1024          }
   1025          
   1026          /**
   1027            * @brief  Enables or disables the specified I2C interrupts.
   1028            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1029            * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
   1030            *          This parameter can be any combination of the following values:
   1031            *            @arg I2C_IT_BUF: Buffer interrupt mask
   1032            *            @arg I2C_IT_EVT: Event interrupt mask
   1033            *            @arg I2C_IT_ERR: Error interrupt mask
   1034            * @param  NewState: new state of the specified I2C interrupts.
   1035            *          This parameter can be: ENABLE or DISABLE.
   1036            * @retval None
   1037            */
   1038          void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
   1039          {
   1040            /* Check the parameters */
   1041            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1042            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1043            assert_param(IS_I2C_CONFIG_IT(I2C_IT));
   1044            
   1045            if (NewState != DISABLE)
   1046            {
   1047              /* Enable the selected I2C interrupts */
   1048              I2Cx->CR2 |= I2C_IT;
   1049            }
   1050            else
   1051            {
   1052              /* Disable the selected I2C interrupts */
   1053              I2Cx->CR2 &= (uint16_t)~I2C_IT;
   1054            }
   1055          }
   1056          
   1057          /*
   1058           ===============================================================================
   1059                                    1. Basic state monitoring                    
   1060           ===============================================================================  
   1061           */
   1062          
   1063          /**
   1064            * @brief  Checks whether the last I2Cx Event is equal to the one passed
   1065            *         as parameter.
   1066            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1067            * @param  I2C_EVENT: specifies the event to be checked. 
   1068            *          This parameter can be one of the following values:
   1069            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1
   1070            *            @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1
   1071            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED: EV1
   1072            *            @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED: EV1
   1073            *            @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1
   1074            *            @arg I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2
   1075            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF): EV2
   1076            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2
   1077            *            @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3
   1078            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF): EV3
   1079            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3
   1080            *            @arg I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2
   1081            *            @arg I2C_EVENT_SLAVE_STOP_DETECTED: EV4
   1082            *            @arg I2C_EVENT_MASTER_MODE_SELECT: EV5
   1083            *            @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6     
   1084            *            @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6
   1085            *            @arg I2C_EVENT_MASTER_BYTE_RECEIVED: EV7
   1086            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8
   1087            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2
   1088            *            @arg I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
   1089            *     
   1090            * @note   For detailed description of Events, please refer to section I2C_Events
   1091            *         in stm32f4xx_i2c.h file.
   1092            *    
   1093            * @retval An ErrorStatus enumeration value:
   1094            *           - SUCCESS: Last event is equal to the I2C_EVENT
   1095            *           - ERROR: Last event is different from the I2C_EVENT
   1096            */
   1097          ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
   1098          {
   1099            uint32_t lastevent = 0;
   1100            uint32_t flag1 = 0, flag2 = 0;
   1101            ErrorStatus status = ERROR;
   1102          
   1103            /* Check the parameters */
   1104            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1105            assert_param(IS_I2C_EVENT(I2C_EVENT));
   1106          
   1107            /* Read the I2Cx status register */
   1108            flag1 = I2Cx->SR1;
   1109            flag2 = I2Cx->SR2;
   1110            flag2 = flag2 << 16;
   1111          
   1112            /* Get the last event value from I2C status register */
   1113            lastevent = (flag1 | flag2) & FLAG_MASK;
   1114          
   1115            /* Check whether the last event contains the I2C_EVENT */
   1116            if ((lastevent & I2C_EVENT) == I2C_EVENT)
   1117            {
   1118              /* SUCCESS: last event is equal to I2C_EVENT */
   1119              status = SUCCESS;
   1120            }
   1121            else
   1122            {
   1123              /* ERROR: last event is different from I2C_EVENT */
   1124              status = ERROR;
   1125            }
   1126            /* Return status */
   1127            return status;
   1128          }
   1129          
   1130          /*
   1131           ===============================================================================
   1132                                    2. Advanced state monitoring                   
   1133           ===============================================================================  
   1134           */
   1135          
   1136          /**
   1137            * @brief  Returns the last I2Cx Event.
   1138            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1139            *     
   1140            * @note   For detailed description of Events, please refer to section I2C_Events
   1141            *         in stm32f4xx_i2c.h file.
   1142            *    
   1143            * @retval The last event
   1144            */
   1145          uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
   1146          {
   1147            uint32_t lastevent = 0;
   1148            uint32_t flag1 = 0, flag2 = 0;
   1149          
   1150            /* Check the parameters */
   1151            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1152          
   1153            /* Read the I2Cx status register */
   1154            flag1 = I2Cx->SR1;
   1155            flag2 = I2Cx->SR2;
   1156            flag2 = flag2 << 16;
   1157          
   1158            /* Get the last event value from I2C status register */
   1159            lastevent = (flag1 | flag2) & FLAG_MASK;
   1160          
   1161            /* Return status */
   1162            return lastevent;
   1163          }
   1164          
   1165          /*
   1166           ===============================================================================
   1167                                    3. Flag-based state monitoring                   
   1168           ===============================================================================  
   1169           */
   1170          
   1171          /**
   1172            * @brief  Checks whether the specified I2C flag is set or not.
   1173            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1174            * @param  I2C_FLAG: specifies the flag to check. 
   1175            *          This parameter can be one of the following values:
   1176            *            @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
   1177            *            @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
   1178            *            @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
   1179            *            @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
   1180            *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
   1181            *            @arg I2C_FLAG_BUSY: Bus busy flag
   1182            *            @arg I2C_FLAG_MSL: Master/Slave flag
   1183            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1184            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1185            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1186            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1187            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1188            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1189            *            @arg I2C_FLAG_BERR: Bus error flag
   1190            *            @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
   1191            *            @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
   1192            *            @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1193            *            @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1194            *            @arg I2C_FLAG_BTF: Byte transfer finished flag
   1195            *            @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"
   1196            *                                Address matched flag (Slave mode)"ENDAD"
   1197            *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1198            * @retval The new state of I2C_FLAG (SET or RESET).
   1199            */
   1200          FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
   1201          {
   1202            FlagStatus bitstatus = RESET;
   1203            __IO uint32_t i2creg = 0, i2cxbase = 0;
   1204          
   1205            /* Check the parameters */
   1206            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1207            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   1208          
   1209            /* Get the I2Cx peripheral base address */
   1210            i2cxbase = (uint32_t)I2Cx;
   1211            
   1212            /* Read flag register index */
   1213            i2creg = I2C_FLAG >> 28;
   1214            
   1215            /* Get bit[23:0] of the flag */
   1216            I2C_FLAG &= FLAG_MASK;
   1217            
   1218            if(i2creg != 0)
   1219            {
   1220              /* Get the I2Cx SR1 register address */
   1221              i2cxbase += 0x14;
   1222            }
   1223            else
   1224            {
   1225              /* Flag in I2Cx SR2 Register */
   1226              I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
   1227              /* Get the I2Cx SR2 register address */
   1228              i2cxbase += 0x18;
   1229            }
   1230            
   1231            if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
   1232            {
   1233              /* I2C_FLAG is set */
   1234              bitstatus = SET;
   1235            }
   1236            else
   1237            {
   1238              /* I2C_FLAG is reset */
   1239              bitstatus = RESET;
   1240            }
   1241            
   1242            /* Return the I2C_FLAG status */
   1243            return  bitstatus;
   1244          }
   1245          
   1246          /**
   1247            * @brief  Clears the I2Cx's pending flags.
   1248            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1249            * @param  I2C_FLAG: specifies the flag to clear. 
   1250            *          This parameter can be any combination of the following values:
   1251            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1252            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1253            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1254            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1255            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1256            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1257            *            @arg I2C_FLAG_BERR: Bus error flag
   1258            *   
   1259            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
   1260            *          to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
   1261            *          to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1262            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1263            *          operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
   1264            *          second byte of the address in DR register.
   1265            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1266            *          operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
   1267            *          read/write to I2C_DR register (I2C_SendData()).
   1268            * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
   1269            *          I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
   1270            *          I2C_SR2 register ((void)(I2Cx->SR2)).
   1271            * @note   SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
   1272            *          register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
   1273            *          register (I2C_SendData()).
   1274            *  
   1275            * @retval None
   1276            */
   1277          void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
   1278          {
   1279            uint32_t flagpos = 0;
   1280            /* Check the parameters */
   1281            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1282            assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   1283            /* Get the I2C flag position */
   1284            flagpos = I2C_FLAG & FLAG_MASK;
   1285            /* Clear the selected I2C flag */
   1286            I2Cx->SR1 = (uint16_t)~flagpos;
   1287          }
   1288          
   1289          /**
   1290            * @brief  Checks whether the specified I2C interrupt has occurred or not.
   1291            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1292            * @param  I2C_IT: specifies the interrupt source to check. 
   1293            *          This parameter can be one of the following values:
   1294            *            @arg I2C_IT_SMBALERT: SMBus Alert flag
   1295            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag
   1296            *            @arg I2C_IT_PECERR: PEC error in reception flag
   1297            *            @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1298            *            @arg I2C_IT_AF: Acknowledge failure flag
   1299            *            @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1300            *            @arg I2C_IT_BERR: Bus error flag
   1301            *            @arg I2C_IT_TXE: Data register empty flag (Transmitter)
   1302            *            @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
   1303            *            @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
   1304            *            @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1305            *            @arg I2C_IT_BTF: Byte transfer finished flag
   1306            *            @arg I2C_IT_ADDR: Address sent flag (Master mode) "ADSL"
   1307            *                              Address matched flag (Slave mode)"ENDAD"
   1308            *            @arg I2C_IT_SB: Start bit flag (Master mode)
   1309            * @retval The new state of I2C_IT (SET or RESET).
   1310            */
   1311          ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
   1312          {
   1313            ITStatus bitstatus = RESET;
   1314            uint32_t enablestatus = 0;
   1315          
   1316            /* Check the parameters */
   1317            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1318            assert_param(IS_I2C_GET_IT(I2C_IT));
   1319          
   1320            /* Check if the interrupt source is enabled or not */
   1321            enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
   1322            
   1323            /* Get bit[23:0] of the flag */
   1324            I2C_IT &= FLAG_MASK;
   1325          
   1326            /* Check the status of the specified I2C flag */
   1327            if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
   1328            {
   1329              /* I2C_IT is set */
   1330              bitstatus = SET;
   1331            }
   1332            else
   1333            {
   1334              /* I2C_IT is reset */
   1335              bitstatus = RESET;
   1336            }
   1337            /* Return the I2C_IT status */
   1338            return  bitstatus;
   1339          }
   1340          
   1341          /**
   1342            * @brief  Clears the I2Cx's interrupt pending bits.
   1343            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1344            * @param  I2C_IT: specifies the interrupt pending bit to clear. 
   1345            *          This parameter can be any combination of the following values:
   1346            *            @arg I2C_IT_SMBALERT: SMBus Alert interrupt
   1347            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1348            *            @arg I2C_IT_PECERR: PEC error in reception  interrupt
   1349            *            @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
   1350            *            @arg I2C_IT_AF: Acknowledge failure interrupt
   1351            *            @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
   1352            *            @arg I2C_IT_BERR: Bus error interrupt
   1353            * 
   1354            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
   1355            *          to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1356            *          I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1357            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1358            *          operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second 
   1359            *          byte of the address in I2C_DR register.
   1360            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1361            *          operation to I2C_SR1 register (I2C_GetITStatus()) followed by a 
   1362            *          read/write to I2C_DR register (I2C_SendData()).
   1363            * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
   1364            *          I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to 
   1365            *          I2C_SR2 register ((void)(I2Cx->SR2)).
   1366            * @note   SB (Start Bit) is cleared by software sequence: a read operation to 
   1367            *          I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1368            *          I2C_DR register (I2C_SendData()).
   1369            * @retval None
   1370            */
   1371          void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
   1372          {
   1373            uint32_t flagpos = 0;
   1374            /* Check the parameters */
   1375            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1376            assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   1377          
   1378            /* Get the I2C flag position */
   1379            flagpos = I2C_IT & FLAG_MASK;
   1380          
   1381            /* Clear the selected I2C flag */
   1382            I2Cx->SR1 = (uint16_t)~flagpos;
   1383          }
   1384          
   1385          /**
   1386            * @}
   1387            */
   1388          
   1389          /**
   1390            * @}
   1391            */ 
   1392          
   1393          /**
   1394            * @}
   1395            */ 
   1396          
   1397          /**
   1398            * @}
   1399            */ 
   1400          
   1401          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  I2C_ARPCmd
        0  I2C_AcknowledgeConfig
        0  I2C_CalculatePEC
        0  I2C_CheckEvent
        0  I2C_ClearFlag
        0  I2C_ClearITPendingBit
        0  I2C_Cmd
        0  I2C_DMACmd
        0  I2C_DMALastTransferCmd
        8  I2C_DeInit
              0 -> RCC_APB1PeriphResetCmd
              8 -> RCC_APB1PeriphResetCmd
        0  I2C_DualAddressCmd
        0  I2C_FastModeDutyCycleConfig
        0  I2C_GeneralCallCmd
        0  I2C_GenerateSTART
        0  I2C_GenerateSTOP
        8  I2C_GetFlagStatus
        0  I2C_GetITStatus
        0  I2C_GetLastEvent
        0  I2C_GetPEC
        0  I2C_ITConfig
       32  I2C_Init
             32 -> RCC_GetClocksFreq
        0  I2C_NACKPositionConfig
        0  I2C_OwnAddress2Config
        0  I2C_PECPositionConfig
        4  I2C_ReadRegister
        0  I2C_ReceiveData
        0  I2C_SMBusAlertConfig
        0  I2C_Send7bitAddress
        0  I2C_SendData
        0  I2C_SoftwareResetCmd
        0  I2C_StretchClockCmd
        0  I2C_StructInit
        0  I2C_TransmitPEC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       6  ?Subroutine0
      20  I2C_ARPCmd
      20  I2C_AcknowledgeConfig
      20  I2C_CalculatePEC
      26  I2C_CheckEvent
       2  I2C_ClearFlag
       2  I2C_ClearITPendingBit
      20  I2C_Cmd
      20  I2C_DMACmd
      20  I2C_DMALastTransferCmd
      82  I2C_DeInit
      20  I2C_DualAddressCmd
      22  I2C_FastModeDutyCycleConfig
      20  I2C_GeneralCallCmd
      20  I2C_GenerateSTART
      20  I2C_GenerateSTOP
      52  I2C_GetFlagStatus
      26  I2C_GetITStatus
      14  I2C_GetLastEvent
       6  I2C_GetPEC
      16  I2C_ITConfig
     176  I2C_Init
      22  I2C_NACKPositionConfig
      18  I2C_OwnAddress2Config
      22  I2C_PECPositionConfig
      24  I2C_ReadRegister
       6  I2C_ReceiveData
      22  I2C_SMBusAlertConfig
      16  I2C_Send7bitAddress
       4  I2C_SendData
      18  I2C_SoftwareResetCmd
      20  I2C_StretchClockCmd
      30  I2C_StructInit
      20  I2C_TransmitPEC

 
 872 bytes in section .text
 
 872 bytes of CODE memory

Errors: none
Warnings: none
