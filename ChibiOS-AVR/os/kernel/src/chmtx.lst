   1               		.file	"chmtx.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	chMtxInit
  12               	chMtxInit:
  13               	.LFB7:
  14               		.file 1 "../../os/kernel/src/chmtx.c"
   1:../../os/kernel/src/chmtx.c **** /*
   2:../../os/kernel/src/chmtx.c ****     ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
   3:../../os/kernel/src/chmtx.c ****                  2011,2012 Giovanni Di Sirio.
   4:../../os/kernel/src/chmtx.c **** 
   5:../../os/kernel/src/chmtx.c ****     This file is part of ChibiOS/RT.
   6:../../os/kernel/src/chmtx.c **** 
   7:../../os/kernel/src/chmtx.c ****     ChibiOS/RT is free software; you can redistribute it and/or modify
   8:../../os/kernel/src/chmtx.c ****     it under the terms of the GNU General Public License as published by
   9:../../os/kernel/src/chmtx.c ****     the Free Software Foundation; either version 3 of the License, or
  10:../../os/kernel/src/chmtx.c ****     (at your option) any later version.
  11:../../os/kernel/src/chmtx.c **** 
  12:../../os/kernel/src/chmtx.c ****     ChibiOS/RT is distributed in the hope that it will be useful,
  13:../../os/kernel/src/chmtx.c ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../os/kernel/src/chmtx.c ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../os/kernel/src/chmtx.c ****     GNU General Public License for more details.
  16:../../os/kernel/src/chmtx.c **** 
  17:../../os/kernel/src/chmtx.c ****     You should have received a copy of the GNU General Public License
  18:../../os/kernel/src/chmtx.c ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  19:../../os/kernel/src/chmtx.c **** */
  20:../../os/kernel/src/chmtx.c **** 
  21:../../os/kernel/src/chmtx.c **** /**
  22:../../os/kernel/src/chmtx.c ****  * @file    chmtx.c
  23:../../os/kernel/src/chmtx.c ****  * @brief   Mutexes code.
  24:../../os/kernel/src/chmtx.c ****  *
  25:../../os/kernel/src/chmtx.c ****  * @addtogroup mutexes
  26:../../os/kernel/src/chmtx.c ****  * @details Mutexes related APIs and services.
  27:../../os/kernel/src/chmtx.c ****  *
  28:../../os/kernel/src/chmtx.c ****  *          <h2>Operation mode</h2>
  29:../../os/kernel/src/chmtx.c ****  *          A mutex is a threads synchronization object that can be in two
  30:../../os/kernel/src/chmtx.c ****  *          distinct states:
  31:../../os/kernel/src/chmtx.c ****  *          - Not owned (unlocked).
  32:../../os/kernel/src/chmtx.c ****  *          - Owned by a thread (locked).
  33:../../os/kernel/src/chmtx.c ****  *          .
  34:../../os/kernel/src/chmtx.c ****  *          Operations defined for mutexes:
  35:../../os/kernel/src/chmtx.c ****  *          - <b>Lock</b>: The mutex is checked, if the mutex is not owned by
  36:../../os/kernel/src/chmtx.c ****  *            some other thread then it is associated to the locking thread
  37:../../os/kernel/src/chmtx.c ****  *            else the thread is queued on the mutex in a list ordered by
  38:../../os/kernel/src/chmtx.c ****  *            priority.
  39:../../os/kernel/src/chmtx.c ****  *          - <b>Unlock</b>: The mutex is released by the owner and the highest
  40:../../os/kernel/src/chmtx.c ****  *            priority thread waiting in the queue, if any, is resumed and made
  41:../../os/kernel/src/chmtx.c ****  *            owner of the mutex.
  42:../../os/kernel/src/chmtx.c ****  *          .
  43:../../os/kernel/src/chmtx.c ****  *          <h2>Constraints</h2>
  44:../../os/kernel/src/chmtx.c ****  *          In ChibiOS/RT the Unlock operations are always performed in
  45:../../os/kernel/src/chmtx.c ****  *          lock-reverse order. The unlock API does not even have a parameter,
  46:../../os/kernel/src/chmtx.c ****  *          the mutex to unlock is selected from an internal, per-thread, stack
  47:../../os/kernel/src/chmtx.c ****  *          of owned mutexes. This both improves the performance and is
  48:../../os/kernel/src/chmtx.c ****  *          required for an efficient implementation of the priority
  49:../../os/kernel/src/chmtx.c ****  *          inheritance mechanism.
  50:../../os/kernel/src/chmtx.c ****  *
  51:../../os/kernel/src/chmtx.c ****  *          <h2>The priority inversion problem</h2>
  52:../../os/kernel/src/chmtx.c ****  *          The mutexes in ChibiOS/RT implements the <b>full</b> priority
  53:../../os/kernel/src/chmtx.c ****  *          inheritance mechanism in order handle the priority inversion
  54:../../os/kernel/src/chmtx.c ****  *          problem.<br>
  55:../../os/kernel/src/chmtx.c ****  *          When a thread is queued on a mutex, any thread, directly or
  56:../../os/kernel/src/chmtx.c ****  *          indirectly, holding the mutex gains the same priority of the
  57:../../os/kernel/src/chmtx.c ****  *          waiting thread (if their priority was not already equal or higher).
  58:../../os/kernel/src/chmtx.c ****  *          The mechanism works with any number of nested mutexes and any
  59:../../os/kernel/src/chmtx.c ****  *          number of involved threads. The algorithm complexity (worst case)
  60:../../os/kernel/src/chmtx.c ****  *          is N with N equal to the number of nested mutexes.
  61:../../os/kernel/src/chmtx.c ****  * @pre     In order to use the mutex APIs the @p CH_USE_MUTEXES option
  62:../../os/kernel/src/chmtx.c ****  *          must be enabled in @p chconf.h.
  63:../../os/kernel/src/chmtx.c ****  * @post    Enabling mutexes requires 5-12 (depending on the architecture)
  64:../../os/kernel/src/chmtx.c ****  *          extra bytes in the @p Thread structure.
  65:../../os/kernel/src/chmtx.c ****  * @{
  66:../../os/kernel/src/chmtx.c ****  */
  67:../../os/kernel/src/chmtx.c **** 
  68:../../os/kernel/src/chmtx.c **** #include "ch.h"
  69:../../os/kernel/src/chmtx.c **** 
  70:../../os/kernel/src/chmtx.c **** #if CH_USE_MUTEXES || defined(__DOXYGEN__)
  71:../../os/kernel/src/chmtx.c **** 
  72:../../os/kernel/src/chmtx.c **** /**
  73:../../os/kernel/src/chmtx.c ****  * @brief   Initializes s @p Mutex structure.
  74:../../os/kernel/src/chmtx.c ****  *
  75:../../os/kernel/src/chmtx.c ****  * @param[out] mp       pointer to a @p Mutex structure
  76:../../os/kernel/src/chmtx.c ****  *
  77:../../os/kernel/src/chmtx.c ****  * @init
  78:../../os/kernel/src/chmtx.c ****  */
  79:../../os/kernel/src/chmtx.c **** void chMtxInit(Mutex *mp) {
  15               		.loc 1 79 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 FC01      		movw r30,r24
  80:../../os/kernel/src/chmtx.c **** 
  81:../../os/kernel/src/chmtx.c ****   chDbgCheck(mp != NULL, "chMtxInit");
  82:../../os/kernel/src/chmtx.c **** 
  83:../../os/kernel/src/chmtx.c ****   queue_init(&mp->m_queue);
  23               		.loc 1 83 0
  24 0002 8283      		std Z+2,r24
  25 0004 F383      		std Z+3,r31
  26 0006 8083      		st Z,r24
  27 0008 F183      		std Z+1,r31
  84:../../os/kernel/src/chmtx.c ****   mp->m_owner = NULL;
  28               		.loc 1 84 0
  29 000a 1582      		std Z+5,__zero_reg__
  30 000c 1482      		std Z+4,__zero_reg__
  31 000e 0895      		ret
  32               		.cfi_endproc
  33               	.LFE7:
  35               	.global	chMtxLockS
  37               	chMtxLockS:
  38               	.LFB9:
  85:../../os/kernel/src/chmtx.c **** }
  86:../../os/kernel/src/chmtx.c **** 
  87:../../os/kernel/src/chmtx.c **** /**
  88:../../os/kernel/src/chmtx.c ****  * @brief   Locks the specified mutex.
  89:../../os/kernel/src/chmtx.c ****  * @post    The mutex is locked and inserted in the per-thread stack of owned
  90:../../os/kernel/src/chmtx.c ****  *          mutexes.
  91:../../os/kernel/src/chmtx.c ****  *
  92:../../os/kernel/src/chmtx.c ****  * @param[in] mp        pointer to the @p Mutex structure
  93:../../os/kernel/src/chmtx.c ****  *
  94:../../os/kernel/src/chmtx.c ****  * @api
  95:../../os/kernel/src/chmtx.c ****  */
  96:../../os/kernel/src/chmtx.c **** void chMtxLock(Mutex *mp) {
  97:../../os/kernel/src/chmtx.c **** 
  98:../../os/kernel/src/chmtx.c ****   chSysLock();
  99:../../os/kernel/src/chmtx.c **** 
 100:../../os/kernel/src/chmtx.c ****   chMtxLockS(mp);
 101:../../os/kernel/src/chmtx.c **** 
 102:../../os/kernel/src/chmtx.c ****   chSysUnlock();
 103:../../os/kernel/src/chmtx.c **** }
 104:../../os/kernel/src/chmtx.c **** 
 105:../../os/kernel/src/chmtx.c **** /**
 106:../../os/kernel/src/chmtx.c ****  * @brief   Locks the specified mutex.
 107:../../os/kernel/src/chmtx.c ****  * @post    The mutex is locked and inserted in the per-thread stack of owned
 108:../../os/kernel/src/chmtx.c ****  *          mutexes.
 109:../../os/kernel/src/chmtx.c ****  *
 110:../../os/kernel/src/chmtx.c ****  * @param[in] mp        pointer to the @p Mutex structure
 111:../../os/kernel/src/chmtx.c ****  *
 112:../../os/kernel/src/chmtx.c ****  * @sclass
 113:../../os/kernel/src/chmtx.c ****  */
 114:../../os/kernel/src/chmtx.c **** void chMtxLockS(Mutex *mp) {
  39               		.loc 1 114 0
  40               		.cfi_startproc
  41               	.LVL1:
  42 0010 0F93      		push r16
  43               	.LCFI0:
  44               		.cfi_def_cfa_offset 3
  45               		.cfi_offset 16, -2
  46 0012 1F93      		push r17
  47               	.LCFI1:
  48               		.cfi_def_cfa_offset 4
  49               		.cfi_offset 17, -3
  50 0014 CF93      		push r28
  51               	.LCFI2:
  52               		.cfi_def_cfa_offset 5
  53               		.cfi_offset 28, -4
  54 0016 DF93      		push r29
  55               	.LCFI3:
  56               		.cfi_def_cfa_offset 6
  57               		.cfi_offset 29, -5
  58               	/* prologue: function */
  59               	/* frame size = 0 */
  60               	/* stack size = 4 */
  61               	.L__stack_usage = 4
  62 0018 8C01      		movw r16,r24
 115:../../os/kernel/src/chmtx.c ****   Thread *ctp = currp;
  63               		.loc 1 115 0
  64 001a C091 0000 		lds r28,rlist+11
  65 001e D091 0000 		lds r29,rlist+11+1
  66               	.LVL2:
 116:../../os/kernel/src/chmtx.c **** 
 117:../../os/kernel/src/chmtx.c ****   chDbgCheckClassS();
 118:../../os/kernel/src/chmtx.c ****   chDbgCheck(mp != NULL, "chMtxLockS");
 119:../../os/kernel/src/chmtx.c **** 
 120:../../os/kernel/src/chmtx.c ****   /* Is the mutex already locked? */
 121:../../os/kernel/src/chmtx.c ****   if (mp->m_owner != NULL) {
  67               		.loc 1 121 0
  68 0022 DC01      		movw r26,r24
  69 0024 1496      		adiw r26,4
  70 0026 ED91      		ld r30,X+
  71 0028 FC91      		ld r31,X
  72 002a 1597      		sbiw r26,4+1
  73 002c 3097      		sbiw r30,0
  74 002e 01F4      		brne .+2
  75 0030 00C0      		rjmp .L3
  76               	.LVL3:
  77               	.LBB27:
 122:../../os/kernel/src/chmtx.c ****     /* Priority inheritance protocol; explores the thread-mutex dependencies
 123:../../os/kernel/src/chmtx.c ****        boosting the priority of all the affected threads to equal the priority
 124:../../os/kernel/src/chmtx.c ****        of the running thread requesting the mutex.*/
 125:../../os/kernel/src/chmtx.c ****     Thread *tp = mp->m_owner;
 126:../../os/kernel/src/chmtx.c ****     /* Does the running thread have higher priority than the mutex
 127:../../os/kernel/src/chmtx.c ****        owning thread? */
 128:../../os/kernel/src/chmtx.c ****     while (tp->p_prio < ctp->p_prio) {
  78               		.loc 1 128 0 discriminator 1
  79 0032 4C81      		ldd r20,Y+4
  80 0034 8481      		ldd r24,Z+4
  81               	.LVL4:
  82 0036 8417      		cp r24,r20
  83 0038 00F4      		brsh .L5
  84               	.L20:
 129:../../os/kernel/src/chmtx.c ****       /* Make priority of thread tp match the running thread's priority.*/
 130:../../os/kernel/src/chmtx.c ****       tp->p_prio = ctp->p_prio;
  85               		.loc 1 130 0
  86 003a 4483      		std Z+4,r20
 131:../../os/kernel/src/chmtx.c ****       /* The following states need priority queues reordering.*/
 132:../../os/kernel/src/chmtx.c ****       switch (tp->p_state) {
  87               		.loc 1 132 0
  88 003c 8585      		ldd r24,Z+13
  89 003e 8430      		cpi r24,lo8(4)
  90 0040 01F4      		brne .+2
  91 0042 00C0      		rjmp .L7
  92 0044 8530      		cpi r24,lo8(5)
  93 0046 01F0      		breq .L8
  94 0048 8823      		tst r24
  95 004a 01F0      		breq .L6
  96               	.LVL5:
  97               	.L5:
  98               		.file 2 "../../os/kernel/include/chinline.h"
   1:../../os/kernel/include/chinline.h **** /*
   2:../../os/kernel/include/chinline.h ****     ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
   3:../../os/kernel/include/chinline.h ****                  2011,2012 Giovanni Di Sirio.
   4:../../os/kernel/include/chinline.h **** 
   5:../../os/kernel/include/chinline.h ****     This file is part of ChibiOS/RT.
   6:../../os/kernel/include/chinline.h **** 
   7:../../os/kernel/include/chinline.h ****     ChibiOS/RT is free software; you can redistribute it and/or modify
   8:../../os/kernel/include/chinline.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/kernel/include/chinline.h ****     the Free Software Foundation; either version 3 of the License, or
  10:../../os/kernel/include/chinline.h ****     (at your option) any later version.
  11:../../os/kernel/include/chinline.h **** 
  12:../../os/kernel/include/chinline.h ****     ChibiOS/RT is distributed in the hope that it will be useful,
  13:../../os/kernel/include/chinline.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../os/kernel/include/chinline.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../os/kernel/include/chinline.h ****     GNU General Public License for more details.
  16:../../os/kernel/include/chinline.h **** 
  17:../../os/kernel/include/chinline.h ****     You should have received a copy of the GNU General Public License
  18:../../os/kernel/include/chinline.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  19:../../os/kernel/include/chinline.h **** */
  20:../../os/kernel/include/chinline.h **** 
  21:../../os/kernel/include/chinline.h **** /**
  22:../../os/kernel/include/chinline.h ****  * @file    chinline.h
  23:../../os/kernel/include/chinline.h ****  * @brief   Kernel inlined functions.
  24:../../os/kernel/include/chinline.h ****  * @details In this file there are a set of inlined functions if the
  25:../../os/kernel/include/chinline.h ****  *          @p CH_OPTIMIZE_SPEED is enabled.
  26:../../os/kernel/include/chinline.h ****  */
  27:../../os/kernel/include/chinline.h **** 
  28:../../os/kernel/include/chinline.h **** #ifndef _CHINLINE_H_
  29:../../os/kernel/include/chinline.h **** #define _CHINLINE_H_
  30:../../os/kernel/include/chinline.h **** 
  31:../../os/kernel/include/chinline.h **** /* If the performance code path has been chosen then all the following
  32:../../os/kernel/include/chinline.h ****    functions are inlined into the various kernel modules.*/
  33:../../os/kernel/include/chinline.h **** #if CH_OPTIMIZE_SPEED
  34:../../os/kernel/include/chinline.h **** static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {
  35:../../os/kernel/include/chinline.h **** 
  36:../../os/kernel/include/chinline.h ****   Thread *cp = (Thread *)tqp;
  99               		.loc 2 36 0
 100 004c F801      		movw r30,r16
 101               	.LVL6:
 102               	.L18:
 103               	.LBB28:
 104               	.LBB29:
  37:../../os/kernel/include/chinline.h ****   do {
  38:../../os/kernel/include/chinline.h ****     cp = cp->p_next;
 105               		.loc 2 38 0
 106 004e 0190      		ld __tmp_reg__,Z+
 107 0050 F081      		ld r31,Z
 108 0052 E02D      		mov r30,__tmp_reg__
 109               	.LVL7:
  39:../../os/kernel/include/chinline.h ****   } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
 110               		.loc 2 39 0
 111 0054 0E17      		cp r16,r30
 112 0056 1F07      		cpc r17,r31
 113 0058 01F0      		breq .L19
 114 005a 9481      		ldd r25,Z+4
 115 005c 8C81      		ldd r24,Y+4
 116 005e 9817      		cp r25,r24
 117 0060 00F4      		brsh .L18
 118               	.L19:
  40:../../os/kernel/include/chinline.h ****   tp->p_next = cp;
 119               		.loc 2 40 0
 120 0062 F983      		std Y+1,r31
 121 0064 E883      		st Y,r30
  41:../../os/kernel/include/chinline.h ****   tp->p_prev = cp->p_prev;
 122               		.loc 2 41 0
 123 0066 A281      		ldd r26,Z+2
 124 0068 B381      		ldd r27,Z+3
 125 006a BB83      		std Y+3,r27
 126 006c AA83      		std Y+2,r26
  42:../../os/kernel/include/chinline.h ****   tp->p_prev->p_next = cp->p_prev = tp;
 127               		.loc 2 42 0
 128 006e D383      		std Z+3,r29
 129 0070 C283      		std Z+2,r28
 130 0072 CD93      		st X+,r28
 131 0074 DC93      		st X,r29
 132               	.LBE29:
 133               	.LBE28:
 133:../../os/kernel/src/chmtx.c ****       case THD_STATE_WTMTX:
 134:../../os/kernel/src/chmtx.c ****         /* Re-enqueues the mutex owner with its new priority.*/
 135:../../os/kernel/src/chmtx.c ****         prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
 136:../../os/kernel/src/chmtx.c ****         tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
 137:../../os/kernel/src/chmtx.c ****         continue;
 138:../../os/kernel/src/chmtx.c **** #if CH_USE_CONDVARS |                                                       \
 139:../../os/kernel/src/chmtx.c ****     (CH_USE_SEMAPHORES && CH_USE_SEMAPHORES_PRIORITY) |                     \
 140:../../os/kernel/src/chmtx.c ****     (CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY)
 141:../../os/kernel/src/chmtx.c **** #if CH_USE_CONDVARS
 142:../../os/kernel/src/chmtx.c ****       case THD_STATE_WTCOND:
 143:../../os/kernel/src/chmtx.c **** #endif
 144:../../os/kernel/src/chmtx.c **** #if CH_USE_SEMAPHORES && CH_USE_SEMAPHORES_PRIORITY
 145:../../os/kernel/src/chmtx.c ****       case THD_STATE_WTSEM:
 146:../../os/kernel/src/chmtx.c **** #endif
 147:../../os/kernel/src/chmtx.c **** #if CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY
 148:../../os/kernel/src/chmtx.c ****       case THD_STATE_SNDMSGQ:
 149:../../os/kernel/src/chmtx.c **** #endif
 150:../../os/kernel/src/chmtx.c ****         /* Re-enqueues tp with its new priority on the queue.*/
 151:../../os/kernel/src/chmtx.c ****         prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
 152:../../os/kernel/src/chmtx.c ****         break;
 153:../../os/kernel/src/chmtx.c **** #endif
 154:../../os/kernel/src/chmtx.c ****       case THD_STATE_READY:
 155:../../os/kernel/src/chmtx.c **** #if CH_DBG_ENABLE_ASSERTS
 156:../../os/kernel/src/chmtx.c ****         /* Prevents an assertion in chSchReadyI().*/
 157:../../os/kernel/src/chmtx.c ****         tp->p_state = THD_STATE_CURRENT;
 158:../../os/kernel/src/chmtx.c **** #endif
 159:../../os/kernel/src/chmtx.c ****         /* Re-enqueues tp with its new priority on the ready list.*/
 160:../../os/kernel/src/chmtx.c ****         chSchReadyI(dequeue(tp));
 161:../../os/kernel/src/chmtx.c ****         break;
 162:../../os/kernel/src/chmtx.c ****       }
 163:../../os/kernel/src/chmtx.c ****       break;
 164:../../os/kernel/src/chmtx.c ****     }
 165:../../os/kernel/src/chmtx.c ****     /* Sleep on the mutex.*/
 166:../../os/kernel/src/chmtx.c ****     prio_insert(ctp, &mp->m_queue);
 167:../../os/kernel/src/chmtx.c ****     ctp->p_u.wtobjp = mp;
 134               		.loc 1 167 0
 135 0076 1B8B      		std Y+19,r17
 136 0078 0A8B      		std Y+18,r16
 168:../../os/kernel/src/chmtx.c ****     chSchGoSleepS(THD_STATE_WTMTX);
 137               		.loc 1 168 0
 138 007a 84E0      		ldi r24,lo8(4)
 139               	/* epilogue start */
 140               	.LBE27:
 169:../../os/kernel/src/chmtx.c ****     /* It is assumed that the thread performing the unlock operation assigns
 170:../../os/kernel/src/chmtx.c ****        the mutex to this thread.*/
 171:../../os/kernel/src/chmtx.c ****     chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
 172:../../os/kernel/src/chmtx.c ****     chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
 173:../../os/kernel/src/chmtx.c ****   }
 174:../../os/kernel/src/chmtx.c ****   else {
 175:../../os/kernel/src/chmtx.c ****     /* It was not owned, inserted in the owned mutexes list.*/
 176:../../os/kernel/src/chmtx.c ****     mp->m_owner = ctp;
 177:../../os/kernel/src/chmtx.c ****     mp->m_next = ctp->p_mtxlist;
 178:../../os/kernel/src/chmtx.c ****     ctp->p_mtxlist = mp;
 179:../../os/kernel/src/chmtx.c ****   }
 180:../../os/kernel/src/chmtx.c **** }
 141               		.loc 1 180 0
 142 007c DF91      		pop r29
 143 007e CF91      		pop r28
 144               	.LVL8:
 145 0080 1F91      		pop r17
 146 0082 0F91      		pop r16
 147               	.LVL9:
 148               	.LBB42:
 168:../../os/kernel/src/chmtx.c ****     chSchGoSleepS(THD_STATE_WTMTX);
 149               		.loc 1 168 0
 150 0084 0C94 0000 		jmp chSchGoSleepS
 151               	.LVL10:
 152               	.L6:
 153               	.LBB30:
 154               	.LBB31:
  43:../../os/kernel/include/chinline.h **** }
  44:../../os/kernel/include/chinline.h **** 
  45:../../os/kernel/include/chinline.h **** static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {
  46:../../os/kernel/include/chinline.h **** 
  47:../../os/kernel/include/chinline.h ****   tp->p_next = (Thread *)tqp;
  48:../../os/kernel/include/chinline.h ****   tp->p_prev = tqp->p_prev;
  49:../../os/kernel/include/chinline.h ****   tp->p_prev->p_next = tqp->p_prev = tp;
  50:../../os/kernel/include/chinline.h **** }
  51:../../os/kernel/include/chinline.h **** 
  52:../../os/kernel/include/chinline.h **** static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  53:../../os/kernel/include/chinline.h ****   Thread *tp = tqp->p_next;
  54:../../os/kernel/include/chinline.h **** 
  55:../../os/kernel/include/chinline.h ****   (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
  56:../../os/kernel/include/chinline.h ****   return tp;
  57:../../os/kernel/include/chinline.h **** }
  58:../../os/kernel/include/chinline.h **** 
  59:../../os/kernel/include/chinline.h **** static INLINE Thread *lifo_remove(ThreadsQueue *tqp) {
  60:../../os/kernel/include/chinline.h ****   Thread *tp = tqp->p_prev;
  61:../../os/kernel/include/chinline.h **** 
  62:../../os/kernel/include/chinline.h ****   (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  63:../../os/kernel/include/chinline.h ****   return tp;
  64:../../os/kernel/include/chinline.h **** }
  65:../../os/kernel/include/chinline.h **** 
  66:../../os/kernel/include/chinline.h **** static INLINE Thread *dequeue(Thread *tp) {
  67:../../os/kernel/include/chinline.h **** 
  68:../../os/kernel/include/chinline.h ****   tp->p_prev->p_next = tp->p_next;
 155               		.loc 2 68 0
 156 0088 2281      		ldd r18,Z+2
 157 008a 3381      		ldd r19,Z+3
 158 008c 8081      		ld r24,Z
 159 008e 9181      		ldd r25,Z+1
 160 0090 D901      		movw r26,r18
 161 0092 8D93      		st X+,r24
 162 0094 9C93      		st X,r25
  69:../../os/kernel/include/chinline.h ****   tp->p_next->p_prev = tp->p_prev;
 163               		.loc 2 69 0
 164 0096 8081      		ld r24,Z
 165 0098 9181      		ldd r25,Z+1
 166 009a DC01      		movw r26,r24
 167 009c 1396      		adiw r26,2+1
 168 009e 3C93      		st X,r19
 169 00a0 2E93      		st -X,r18
 170 00a2 1297      		sbiw r26,2
 171               	.LBE31:
 172               	.LBE30:
 160:../../os/kernel/src/chmtx.c ****         chSchReadyI(dequeue(tp));
 173               		.loc 1 160 0
 174 00a4 CF01      		movw r24,r30
 175 00a6 0E94 0000 		call chSchReadyI
 176               	.LVL11:
 161:../../os/kernel/src/chmtx.c ****         break;
 177               		.loc 1 161 0
 178 00aa 00C0      		rjmp .L5
 179               	.LVL12:
 180               	.L8:
 151:../../os/kernel/src/chmtx.c ****         prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
 181               		.loc 1 151 0
 182 00ac 8289      		ldd r24,Z+18
 183 00ae 9389      		ldd r25,Z+19
 184               	.LVL13:
 185               	.LBB32:
 186               	.LBB33:
  68:../../os/kernel/include/chinline.h ****   tp->p_prev->p_next = tp->p_next;
 187               		.loc 2 68 0
 188 00b0 6281      		ldd r22,Z+2
 189 00b2 7381      		ldd r23,Z+3
 190 00b4 2081      		ld r18,Z
 191 00b6 3181      		ldd r19,Z+1
 192 00b8 DB01      		movw r26,r22
 193 00ba 2D93      		st X+,r18
 194 00bc 3C93      		st X,r19
 195               		.loc 2 69 0
 196 00be 2081      		ld r18,Z
 197 00c0 3181      		ldd r19,Z+1
 198 00c2 D901      		movw r26,r18
 199 00c4 1396      		adiw r26,2+1
 200 00c6 7C93      		st X,r23
 201 00c8 6E93      		st -X,r22
 202 00ca 1297      		sbiw r26,2
 203               	.LVL14:
  36:../../os/kernel/include/chinline.h ****   Thread *cp = (Thread *)tqp;
 204               		.loc 2 36 0
 205 00cc DC01      		movw r26,r24
 206               	.LVL15:
 207               	.L15:
 208               	.LBE33:
 209               	.LBE32:
 210               	.LBB34:
 211               	.LBB35:
  38:../../os/kernel/include/chinline.h ****     cp = cp->p_next;
 212               		.loc 2 38 0
 213 00ce 0D90      		ld __tmp_reg__,X+
 214 00d0 BC91      		ld r27,X
 215 00d2 A02D      		mov r26,__tmp_reg__
 216               	.LVL16:
  39:../../os/kernel/include/chinline.h ****   } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
 217               		.loc 2 39 0
 218 00d4 8A17      		cp r24,r26
 219 00d6 9B07      		cpc r25,r27
 220 00d8 01F0      		breq .L16
 221 00da 1496      		adiw r26,4
 222 00dc 2C91      		ld r18,X
 223 00de 1497      		sbiw r26,4
 224 00e0 2417      		cp r18,r20
 225 00e2 00F4      		brsh .L15
 226               	.L16:
  40:../../os/kernel/include/chinline.h ****   tp->p_next = cp;
 227               		.loc 2 40 0
 228 00e4 B183      		std Z+1,r27
 229 00e6 A083      		st Z,r26
  41:../../os/kernel/include/chinline.h ****   tp->p_prev = cp->p_prev;
 230               		.loc 2 41 0
 231 00e8 1296      		adiw r26,2
 232 00ea 8D91      		ld r24,X+
 233 00ec 9C91      		ld r25,X
 234 00ee 1397      		sbiw r26,2+1
 235               	.LVL17:
 236 00f0 9383      		std Z+3,r25
 237 00f2 8283      		std Z+2,r24
  42:../../os/kernel/include/chinline.h ****   tp->p_prev->p_next = cp->p_prev = tp;
 238               		.loc 2 42 0
 239 00f4 1396      		adiw r26,2+1
 240 00f6 FC93      		st X,r31
 241 00f8 EE93      		st -X,r30
 242 00fa 1297      		sbiw r26,2
 243 00fc DC01      		movw r26,r24
 244               	.LVL18:
 245 00fe ED93      		st X+,r30
 246 0100 FC93      		st X,r31
 247 0102 00C0      		rjmp .L5
 248               	.LVL19:
 249               	.L7:
 250               	.LBE35:
 251               	.LBE34:
 135:../../os/kernel/src/chmtx.c ****         prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
 252               		.loc 1 135 0
 253 0104 8289      		ldd r24,Z+18
 254 0106 9389      		ldd r25,Z+19
 255               	.LVL20:
 256               	.LBB36:
 257               	.LBB37:
  68:../../os/kernel/include/chinline.h ****   tp->p_prev->p_next = tp->p_next;
 258               		.loc 2 68 0
 259 0108 6281      		ldd r22,Z+2
 260 010a 7381      		ldd r23,Z+3
 261 010c 2081      		ld r18,Z
 262 010e 3181      		ldd r19,Z+1
 263 0110 DB01      		movw r26,r22
 264 0112 2D93      		st X+,r18
 265 0114 3C93      		st X,r19
 266               		.loc 2 69 0
 267 0116 2081      		ld r18,Z
 268 0118 3181      		ldd r19,Z+1
 269 011a D901      		movw r26,r18
 270 011c 1396      		adiw r26,2+1
 271 011e 7C93      		st X,r23
 272 0120 6E93      		st -X,r22
 273 0122 1297      		sbiw r26,2
 274               	.LVL21:
 135:../../os/kernel/src/chmtx.c ****         prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
 275               		.loc 1 135 0
 276 0124 DC01      		movw r26,r24
 277               	.LVL22:
 278               	.L12:
 279               	.LBE37:
 280               	.LBE36:
 281               	.LBB38:
 282               	.LBB39:
  38:../../os/kernel/include/chinline.h ****     cp = cp->p_next;
 283               		.loc 2 38 0
 284 0126 0D90      		ld __tmp_reg__,X+
 285 0128 BC91      		ld r27,X
 286 012a A02D      		mov r26,__tmp_reg__
 287               	.LVL23:
  39:../../os/kernel/include/chinline.h ****   } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
 288               		.loc 2 39 0
 289 012c 8A17      		cp r24,r26
 290 012e 9B07      		cpc r25,r27
 291 0130 01F0      		breq .L26
 292 0132 1496      		adiw r26,4
 293 0134 2C91      		ld r18,X
 294 0136 1497      		sbiw r26,4
 295 0138 2417      		cp r18,r20
 296 013a 00F4      		brsh .L12
 297               	.LVL24:
 298               	.L13:
  40:../../os/kernel/include/chinline.h ****   tp->p_next = cp;
 299               		.loc 2 40 0
 300 013c B183      		std Z+1,r27
 301 013e A083      		st Z,r26
  41:../../os/kernel/include/chinline.h ****   tp->p_prev = cp->p_prev;
 302               		.loc 2 41 0
 303 0140 1296      		adiw r26,2
 304 0142 2D91      		ld r18,X+
 305 0144 3C91      		ld r19,X
 306 0146 1397      		sbiw r26,2+1
 307 0148 3383      		std Z+3,r19
 308 014a 2283      		std Z+2,r18
  42:../../os/kernel/include/chinline.h ****   tp->p_prev->p_next = cp->p_prev = tp;
 309               		.loc 2 42 0
 310 014c 1396      		adiw r26,2+1
 311 014e FC93      		st X,r31
 312 0150 EE93      		st -X,r30
 313 0152 1297      		sbiw r26,2
 314 0154 D901      		movw r26,r18
 315 0156 ED93      		st X+,r30
 316 0158 FC93      		st X,r31
 317               	.LBE39:
 318               	.LBE38:
 136:../../os/kernel/src/chmtx.c ****         tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
 319               		.loc 1 136 0
 320 015a DC01      		movw r26,r24
 321 015c 1496      		adiw r26,4
 322 015e ED91      		ld r30,X+
 323 0160 FC91      		ld r31,X
 324 0162 1597      		sbiw r26,4+1
 325               	.LVL25:
 128:../../os/kernel/src/chmtx.c ****     while (tp->p_prio < ctp->p_prio) {
 326               		.loc 1 128 0
 327 0164 4C81      		ldd r20,Y+4
 328 0166 8481      		ldd r24,Z+4
 329               	.LVL26:
 330 0168 8417      		cp r24,r20
 331 016a 00F4      		brsh .+2
 332 016c 00C0      		rjmp .L20
 333               	.LVL27:
 334 016e 00C0      		rjmp .L5
 335               	.LVL28:
 336               	.L3:
 337               	.LBE42:
 176:../../os/kernel/src/chmtx.c ****     mp->m_owner = ctp;
 338               		.loc 1 176 0
 339 0170 FC01      		movw r30,r24
 340 0172 D583      		std Z+5,r29
 341 0174 C483      		std Z+4,r28
 177:../../os/kernel/src/chmtx.c ****     mp->m_next = ctp->p_mtxlist;
 342               		.loc 1 177 0
 343 0176 8D8D      		ldd r24,Y+29
 344 0178 9E8D      		ldd r25,Y+30
 345 017a 9783      		std Z+7,r25
 346 017c 8683      		std Z+6,r24
 178:../../os/kernel/src/chmtx.c ****     ctp->p_mtxlist = mp;
 347               		.loc 1 178 0
 348 017e 1E8F      		std Y+30,r17
 349 0180 0D8F      		std Y+29,r16
 350               	/* epilogue start */
 351               		.loc 1 180 0
 352 0182 DF91      		pop r29
 353 0184 CF91      		pop r28
 354               	.LVL29:
 355 0186 1F91      		pop r17
 356 0188 0F91      		pop r16
 357               	.LVL30:
 358 018a 0895      		ret
 359               	.LVL31:
 360               	.L26:
 361               	.LBB43:
 362               	.LBB41:
 363               	.LBB40:
  39:../../os/kernel/include/chinline.h ****   } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
 364               		.loc 2 39 0
 365 018c DC01      		movw r26,r24
 366               	.LVL32:
 367 018e 00C0      		rjmp .L13
 368               	.LBE40:
 369               	.LBE41:
 370               	.LBE43:
 371               		.cfi_endproc
 372               	.LFE9:
 374               	.global	chMtxLock
 376               	chMtxLock:
 377               	.LFB8:
  96:../../os/kernel/src/chmtx.c **** void chMtxLock(Mutex *mp) {
 378               		.loc 1 96 0
 379               		.cfi_startproc
 380               	.LVL33:
 381               	/* prologue: function */
 382               	/* frame size = 0 */
 383               	/* stack size = 0 */
 384               	.L__stack_usage = 0
  98:../../os/kernel/src/chmtx.c ****   chSysLock();
 385               		.loc 1 98 0
 386               	/* #APP */
 387               	 ;  98 "../../os/kernel/src/chmtx.c" 1
 388 0190 F894      		cli
 389               	 ;  0 "" 2
 100:../../os/kernel/src/chmtx.c ****   chMtxLockS(mp);
 390               		.loc 1 100 0
 391               	/* #NOAPP */
 392 0192 0E94 0000 		call chMtxLockS
 393               	.LVL34:
 102:../../os/kernel/src/chmtx.c ****   chSysUnlock();
 394               		.loc 1 102 0
 395               	/* #APP */
 396               	 ;  102 "../../os/kernel/src/chmtx.c" 1
 397 0196 7894      		sei
 398               	 ;  0 "" 2
 399               	/* #NOAPP */
 400 0198 0895      		ret
 401               		.cfi_endproc
 402               	.LFE8:
 404               	.global	chMtxTryLock
 406               	chMtxTryLock:
 407               	.LFB10:
 181:../../os/kernel/src/chmtx.c **** 
 182:../../os/kernel/src/chmtx.c **** /**
 183:../../os/kernel/src/chmtx.c ****  * @brief   Tries to lock a mutex.
 184:../../os/kernel/src/chmtx.c ****  * @details This function attempts to lock a mutex, if the mutex is already
 185:../../os/kernel/src/chmtx.c ****  *          locked by another thread then the function exits without waiting.
 186:../../os/kernel/src/chmtx.c ****  * @post    The mutex is locked and inserted in the per-thread stack of owned
 187:../../os/kernel/src/chmtx.c ****  *          mutexes.
 188:../../os/kernel/src/chmtx.c ****  * @note    This function does not have any overhead related to the
 189:../../os/kernel/src/chmtx.c ****  *          priority inheritance mechanism because it does not try to
 190:../../os/kernel/src/chmtx.c ****  *          enter a sleep state.
 191:../../os/kernel/src/chmtx.c ****  *
 192:../../os/kernel/src/chmtx.c ****  * @param[in] mp        pointer to the @p Mutex structure
 193:../../os/kernel/src/chmtx.c ****  * @return              The operation status.
 194:../../os/kernel/src/chmtx.c ****  * @retval TRUE         if the mutex has been successfully acquired
 195:../../os/kernel/src/chmtx.c ****  * @retval FALSE        if the lock attempt failed.
 196:../../os/kernel/src/chmtx.c ****  *
 197:../../os/kernel/src/chmtx.c ****  * @api
 198:../../os/kernel/src/chmtx.c ****  */
 199:../../os/kernel/src/chmtx.c **** bool_t chMtxTryLock(Mutex *mp) {
 408               		.loc 1 199 0
 409               		.cfi_startproc
 410               	.LVL35:
 411               	/* prologue: function */
 412               	/* frame size = 0 */
 413               	/* stack size = 0 */
 414               	.L__stack_usage = 0
 200:../../os/kernel/src/chmtx.c ****   bool_t b;
 201:../../os/kernel/src/chmtx.c **** 
 202:../../os/kernel/src/chmtx.c ****   chSysLock();
 415               		.loc 1 202 0
 416               	/* #APP */
 417               	 ;  202 "../../os/kernel/src/chmtx.c" 1
 418 019a F894      		cli
 419               	 ;  0 "" 2
 420               	.LVL36:
 421               	/* #NOAPP */
 422               	.LBB44:
 423               	.LBB45:
 203:../../os/kernel/src/chmtx.c **** 
 204:../../os/kernel/src/chmtx.c ****   b = chMtxTryLockS(mp);
 205:../../os/kernel/src/chmtx.c **** 
 206:../../os/kernel/src/chmtx.c ****   chSysUnlock();
 207:../../os/kernel/src/chmtx.c ****   return b;
 208:../../os/kernel/src/chmtx.c **** }
 209:../../os/kernel/src/chmtx.c **** 
 210:../../os/kernel/src/chmtx.c **** /**
 211:../../os/kernel/src/chmtx.c ****  * @brief   Tries to lock a mutex.
 212:../../os/kernel/src/chmtx.c ****  * @details This function attempts to lock a mutex, if the mutex is already
 213:../../os/kernel/src/chmtx.c ****  *          taken by another thread then the function exits without waiting.
 214:../../os/kernel/src/chmtx.c ****  * @post    The mutex is locked and inserted in the per-thread stack of owned
 215:../../os/kernel/src/chmtx.c ****  *          mutexes.
 216:../../os/kernel/src/chmtx.c ****  * @note    This function does not have any overhead related to the
 217:../../os/kernel/src/chmtx.c ****  *          priority inheritance mechanism because it does not try to
 218:../../os/kernel/src/chmtx.c ****  *          enter a sleep state.
 219:../../os/kernel/src/chmtx.c ****  *
 220:../../os/kernel/src/chmtx.c ****  * @param[in] mp        pointer to the @p Mutex structure
 221:../../os/kernel/src/chmtx.c ****  * @return              The operation status.
 222:../../os/kernel/src/chmtx.c ****  * @retval TRUE         if the mutex has been successfully acquired
 223:../../os/kernel/src/chmtx.c ****  * @retval FALSE        if the lock attempt failed.
 224:../../os/kernel/src/chmtx.c ****  *
 225:../../os/kernel/src/chmtx.c ****  * @sclass
 226:../../os/kernel/src/chmtx.c ****  */
 227:../../os/kernel/src/chmtx.c **** bool_t chMtxTryLockS(Mutex *mp) {
 228:../../os/kernel/src/chmtx.c **** 
 229:../../os/kernel/src/chmtx.c ****   chDbgCheckClassS();
 230:../../os/kernel/src/chmtx.c ****   chDbgCheck(mp != NULL, "chMtxTryLockS");
 231:../../os/kernel/src/chmtx.c **** 
 232:../../os/kernel/src/chmtx.c ****   if (mp->m_owner != NULL)
 424               		.loc 1 232 0
 425 019c DC01      		movw r26,r24
 426 019e 1496      		adiw r26,4
 427 01a0 2D91      		ld r18,X+
 428 01a2 3C91      		ld r19,X
 429 01a4 1597      		sbiw r26,4+1
 430 01a6 232B      		or r18,r19
 431 01a8 01F0      		breq .L31
 233:../../os/kernel/src/chmtx.c ****     return FALSE;
 432               		.loc 1 233 0
 433 01aa 80E0      		ldi r24,0
 434               	.LVL37:
 435               	.LBE45:
 436               	.LBE44:
 206:../../os/kernel/src/chmtx.c ****   chSysUnlock();
 437               		.loc 1 206 0
 438               	/* #APP */
 439               	 ;  206 "../../os/kernel/src/chmtx.c" 1
 440 01ac 7894      		sei
 441               	 ;  0 "" 2
 208:../../os/kernel/src/chmtx.c **** }
 442               		.loc 1 208 0
 443               	/* #NOAPP */
 444 01ae 0895      		ret
 445               	.LVL38:
 446               	.L31:
 447               	.LBB47:
 448               	.LBB46:
 234:../../os/kernel/src/chmtx.c ****   mp->m_owner = currp;
 449               		.loc 1 234 0
 450 01b0 E091 0000 		lds r30,rlist+11
 451 01b4 F091 0000 		lds r31,rlist+11+1
 452 01b8 1596      		adiw r26,4+1
 453 01ba FC93      		st X,r31
 454 01bc EE93      		st -X,r30
 455 01be 1497      		sbiw r26,4
 235:../../os/kernel/src/chmtx.c ****   mp->m_next = currp->p_mtxlist;
 456               		.loc 1 235 0
 457 01c0 258D      		ldd r18,Z+29
 458 01c2 368D      		ldd r19,Z+30
 459 01c4 1796      		adiw r26,6+1
 460 01c6 3C93      		st X,r19
 461 01c8 2E93      		st -X,r18
 462 01ca 1697      		sbiw r26,6
 236:../../os/kernel/src/chmtx.c ****   currp->p_mtxlist = mp;
 463               		.loc 1 236 0
 464 01cc 968F      		std Z+30,r25
 465 01ce 858F      		std Z+29,r24
 237:../../os/kernel/src/chmtx.c ****   return TRUE;
 466               		.loc 1 237 0
 467 01d0 81E0      		ldi r24,lo8(1)
 468               	.LVL39:
 469               	.LBE46:
 470               	.LBE47:
 206:../../os/kernel/src/chmtx.c ****   chSysUnlock();
 471               		.loc 1 206 0
 472               	/* #APP */
 473               	 ;  206 "../../os/kernel/src/chmtx.c" 1
 474 01d2 7894      		sei
 475               	 ;  0 "" 2
 208:../../os/kernel/src/chmtx.c **** }
 476               		.loc 1 208 0
 477               	/* #NOAPP */
 478 01d4 0895      		ret
 479               		.cfi_endproc
 480               	.LFE10:
 482               	.global	chMtxTryLockS
 484               	chMtxTryLockS:
 485               	.LFB11:
 227:../../os/kernel/src/chmtx.c **** bool_t chMtxTryLockS(Mutex *mp) {
 486               		.loc 1 227 0
 487               		.cfi_startproc
 488               	.LVL40:
 489               	/* prologue: function */
 490               	/* frame size = 0 */
 491               	/* stack size = 0 */
 492               	.L__stack_usage = 0
 232:../../os/kernel/src/chmtx.c ****   if (mp->m_owner != NULL)
 493               		.loc 1 232 0
 494 01d6 DC01      		movw r26,r24
 495 01d8 1496      		adiw r26,4
 496 01da 2D91      		ld r18,X+
 497 01dc 3C91      		ld r19,X
 498 01de 1597      		sbiw r26,4+1
 499 01e0 232B      		or r18,r19
 500 01e2 01F0      		breq .L35
 233:../../os/kernel/src/chmtx.c ****     return FALSE;
 501               		.loc 1 233 0
 502 01e4 80E0      		ldi r24,0
 503               	.LVL41:
 238:../../os/kernel/src/chmtx.c **** }
 504               		.loc 1 238 0
 505 01e6 0895      		ret
 506               	.LVL42:
 507               	.L35:
 234:../../os/kernel/src/chmtx.c ****   mp->m_owner = currp;
 508               		.loc 1 234 0
 509 01e8 E091 0000 		lds r30,rlist+11
 510 01ec F091 0000 		lds r31,rlist+11+1
 511 01f0 1596      		adiw r26,4+1
 512 01f2 FC93      		st X,r31
 513 01f4 EE93      		st -X,r30
 514 01f6 1497      		sbiw r26,4
 235:../../os/kernel/src/chmtx.c ****   mp->m_next = currp->p_mtxlist;
 515               		.loc 1 235 0
 516 01f8 258D      		ldd r18,Z+29
 517 01fa 368D      		ldd r19,Z+30
 518 01fc 1796      		adiw r26,6+1
 519 01fe 3C93      		st X,r19
 520 0200 2E93      		st -X,r18
 521 0202 1697      		sbiw r26,6
 236:../../os/kernel/src/chmtx.c ****   currp->p_mtxlist = mp;
 522               		.loc 1 236 0
 523 0204 968F      		std Z+30,r25
 524 0206 858F      		std Z+29,r24
 237:../../os/kernel/src/chmtx.c ****   return TRUE;
 525               		.loc 1 237 0
 526 0208 81E0      		ldi r24,lo8(1)
 527               	.LVL43:
 528 020a 0895      		ret
 529               		.cfi_endproc
 530               	.LFE11:
 532               	.global	chMtxUnlock
 534               	chMtxUnlock:
 535               	.LFB12:
 239:../../os/kernel/src/chmtx.c **** 
 240:../../os/kernel/src/chmtx.c **** /**
 241:../../os/kernel/src/chmtx.c ****  * @brief   Unlocks the next owned mutex in reverse lock order.
 242:../../os/kernel/src/chmtx.c ****  * @pre     The invoking thread <b>must</b> have at least one owned mutex.
 243:../../os/kernel/src/chmtx.c ****  * @post    The mutex is unlocked and removed from the per-thread stack of
 244:../../os/kernel/src/chmtx.c ****  *          owned mutexes.
 245:../../os/kernel/src/chmtx.c ****  *
 246:../../os/kernel/src/chmtx.c ****  * @return              A pointer to the unlocked mutex.
 247:../../os/kernel/src/chmtx.c ****  *
 248:../../os/kernel/src/chmtx.c ****  * @api
 249:../../os/kernel/src/chmtx.c ****  */
 250:../../os/kernel/src/chmtx.c **** Mutex *chMtxUnlock(void) {
 536               		.loc 1 250 0
 537               		.cfi_startproc
 538 020c CF93      		push r28
 539               	.LCFI4:
 540               		.cfi_def_cfa_offset 3
 541               		.cfi_offset 28, -2
 542 020e DF93      		push r29
 543               	.LCFI5:
 544               		.cfi_def_cfa_offset 4
 545               		.cfi_offset 29, -3
 546               	/* prologue: function */
 547               	/* frame size = 0 */
 548               	/* stack size = 2 */
 549               	.L__stack_usage = 2
 251:../../os/kernel/src/chmtx.c ****   Thread *ctp = currp;
 550               		.loc 1 251 0
 551 0210 8091 0000 		lds r24,rlist+11
 552 0214 9091 0000 		lds r25,rlist+11+1
 553               	.LVL44:
 252:../../os/kernel/src/chmtx.c ****   Mutex *ump, *mp;
 253:../../os/kernel/src/chmtx.c **** 
 254:../../os/kernel/src/chmtx.c ****   chSysLock();
 554               		.loc 1 254 0
 555               	/* #APP */
 556               	 ;  254 "../../os/kernel/src/chmtx.c" 1
 557 0218 F894      		cli
 558               	 ;  0 "" 2
 255:../../os/kernel/src/chmtx.c ****   chDbgAssert(ctp->p_mtxlist != NULL,
 256:../../os/kernel/src/chmtx.c ****               "chMtxUnlock(), #1",
 257:../../os/kernel/src/chmtx.c ****               "owned mutexes list empty");
 258:../../os/kernel/src/chmtx.c ****   chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
 259:../../os/kernel/src/chmtx.c ****               "chMtxUnlock(), #2",
 260:../../os/kernel/src/chmtx.c ****               "ownership failure");
 261:../../os/kernel/src/chmtx.c ****   /* Removes the top Mutex from the Thread's owned mutexes list and marks it
 262:../../os/kernel/src/chmtx.c ****      as not owned.*/
 263:../../os/kernel/src/chmtx.c ****   ump = ctp->p_mtxlist;
 559               		.loc 1 263 0
 560               	/* #NOAPP */
 561 021a DC01      		movw r26,r24
 562 021c 5D96      		adiw r26,29
 563 021e CD91      		ld r28,X+
 564 0220 DC91      		ld r29,X
 565 0222 5E97      		sbiw r26,29+1
 566               	.LVL45:
 264:../../os/kernel/src/chmtx.c ****   ctp->p_mtxlist = ump->m_next;
 567               		.loc 1 264 0
 568 0224 EE81      		ldd r30,Y+6
 569 0226 FF81      		ldd r31,Y+7
 570 0228 5E96      		adiw r26,29+1
 571 022a FC93      		st X,r31
 572 022c EE93      		st -X,r30
 573 022e 5D97      		sbiw r26,29
 265:../../os/kernel/src/chmtx.c ****   /* If a thread is waiting on the mutex then the fun part begins.*/
 266:../../os/kernel/src/chmtx.c ****   if (chMtxQueueNotEmptyS(ump)) {
 574               		.loc 1 266 0
 575 0230 2881      		ld r18,Y
 576 0232 3981      		ldd r19,Y+1
 577 0234 2C17      		cp r18,r28
 578 0236 3D07      		cpc r19,r29
 579 0238 01F0      		breq .L37
 580               	.LBB48:
 267:../../os/kernel/src/chmtx.c ****     Thread *tp;
 268:../../os/kernel/src/chmtx.c **** 
 269:../../os/kernel/src/chmtx.c ****     /* Recalculates the optimal thread priority by scanning the owned
 270:../../os/kernel/src/chmtx.c ****        mutexes list.*/
 271:../../os/kernel/src/chmtx.c ****     tprio_t newprio = ctp->p_realprio;
 581               		.loc 1 271 0
 582 023a 5F96      		adiw r26,31
 583 023c 3C91      		ld r19,X
 584               	.LVL46:
 272:../../os/kernel/src/chmtx.c ****     mp = ctp->p_mtxlist;
 273:../../os/kernel/src/chmtx.c ****     while (mp != NULL) {
 585               		.loc 1 273 0
 586 023e 3097      		sbiw r30,0
 587 0240 01F0      		breq .L38
 588               	.L45:
 274:../../os/kernel/src/chmtx.c ****       /* If the highest priority thread waiting in the mutexes list has a
 275:../../os/kernel/src/chmtx.c ****          greater priority than the current thread base priority then the final
 276:../../os/kernel/src/chmtx.c ****          priority will have at least that priority.*/
 277:../../os/kernel/src/chmtx.c ****       if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
 589               		.loc 1 277 0
 590 0242 A081      		ld r26,Z
 591 0244 B181      		ldd r27,Z+1
 592 0246 AE17      		cp r26,r30
 593 0248 BF07      		cpc r27,r31
 594 024a 01F0      		breq .L39
 595               		.loc 1 277 0 is_stmt 0 discriminator 1
 596 024c 1496      		adiw r26,4
 597 024e 2C91      		ld r18,X
 598 0250 3217      		cp r19,r18
 599 0252 00F4      		brsh .L39
 600 0254 322F      		mov r19,r18
 601               	.LVL47:
 602               	.L39:
 278:../../os/kernel/src/chmtx.c ****         newprio = mp->m_queue.p_next->p_prio;
 279:../../os/kernel/src/chmtx.c ****       mp = mp->m_next;
 603               		.loc 1 279 0 is_stmt 1
 604 0256 0680      		ldd __tmp_reg__,Z+6
 605 0258 F781      		ldd r31,Z+7
 606 025a E02D      		mov r30,__tmp_reg__
 607               	.LVL48:
 273:../../os/kernel/src/chmtx.c ****     while (mp != NULL) {
 608               		.loc 1 273 0
 609 025c 3097      		sbiw r30,0
 610 025e 01F4      		brne .L45
 611               	.L38:
 280:../../os/kernel/src/chmtx.c ****     }
 281:../../os/kernel/src/chmtx.c ****     /* Assigns to the current thread the highest priority among all the
 282:../../os/kernel/src/chmtx.c ****        waiting threads.*/
 283:../../os/kernel/src/chmtx.c ****     ctp->p_prio = newprio;
 612               		.loc 1 283 0
 613 0260 FC01      		movw r30,r24
 614               	.LVL49:
 615 0262 3483      		std Z+4,r19
 616               	.LVL50:
 617               	.LBB49:
 618               	.LBB50:
  53:../../os/kernel/include/chinline.h ****   Thread *tp = tqp->p_next;
 619               		.loc 2 53 0
 620 0264 E881      		ld r30,Y
 621 0266 F981      		ldd r31,Y+1
 622               	.LVL51:
  55:../../os/kernel/include/chinline.h ****   (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 623               		.loc 2 55 0
 624 0268 A081      		ld r26,Z
 625 026a B181      		ldd r27,Z+1
 626 026c B983      		std Y+1,r27
 627 026e A883      		st Y,r26
 628 0270 1396      		adiw r26,2+1
 629 0272 DC93      		st X,r29
 630 0274 CE93      		st -X,r28
 631 0276 1297      		sbiw r26,2
 632               	.LBE50:
 633               	.LBE49:
 284:../../os/kernel/src/chmtx.c ****     /* Awakens the highest priority thread waiting for the unlocked mutex and
 285:../../os/kernel/src/chmtx.c ****        assigns the mutex to it.*/
 286:../../os/kernel/src/chmtx.c ****     tp = fifo_remove(&ump->m_queue);
 287:../../os/kernel/src/chmtx.c ****     ump->m_owner = tp;
 634               		.loc 1 287 0
 635 0278 FD83      		std Y+5,r31
 636 027a EC83      		std Y+4,r30
 288:../../os/kernel/src/chmtx.c ****     ump->m_next = tp->p_mtxlist;
 637               		.loc 1 288 0
 638 027c 858D      		ldd r24,Z+29
 639 027e 968D      		ldd r25,Z+30
 640               	.LVL52:
 641 0280 9F83      		std Y+7,r25
 642 0282 8E83      		std Y+6,r24
 289:../../os/kernel/src/chmtx.c ****     tp->p_mtxlist = ump;
 643               		.loc 1 289 0
 644 0284 D68F      		std Z+30,r29
 645 0286 C58F      		std Z+29,r28
 290:../../os/kernel/src/chmtx.c ****     chSchWakeupS(tp, RDY_OK);
 646               		.loc 1 290 0
 647 0288 60E0      		ldi r22,0
 648 028a 70E0      		ldi r23,0
 649 028c CF01      		movw r24,r30
 650 028e 0E94 0000 		call chSchWakeupS
 651               	.LVL53:
 652               	.LBE48:
 291:../../os/kernel/src/chmtx.c ****   }
 292:../../os/kernel/src/chmtx.c ****   else
 293:../../os/kernel/src/chmtx.c ****     ump->m_owner = NULL;
 294:../../os/kernel/src/chmtx.c ****   chSysUnlock();
 653               		.loc 1 294 0
 654               	/* #APP */
 655               	 ;  294 "../../os/kernel/src/chmtx.c" 1
 656 0292 7894      		sei
 657               	 ;  0 "" 2
 295:../../os/kernel/src/chmtx.c ****   return ump;
 296:../../os/kernel/src/chmtx.c **** }
 658               		.loc 1 296 0
 659               	/* #NOAPP */
 660 0294 CE01      		movw r24,r28
 661               	/* epilogue start */
 662 0296 DF91      		pop r29
 663 0298 CF91      		pop r28
 664               	.LVL54:
 665 029a 0895      		ret
 666               	.LVL55:
 667               	.L37:
 293:../../os/kernel/src/chmtx.c ****     ump->m_owner = NULL;
 668               		.loc 1 293 0
 669 029c 1D82      		std Y+5,__zero_reg__
 670 029e 1C82      		std Y+4,__zero_reg__
 294:../../os/kernel/src/chmtx.c ****   chSysUnlock();
 671               		.loc 1 294 0
 672               	/* #APP */
 673               	 ;  294 "../../os/kernel/src/chmtx.c" 1
 674 02a0 7894      		sei
 675               	 ;  0 "" 2
 676               		.loc 1 296 0
 677               	/* #NOAPP */
 678 02a2 CE01      		movw r24,r28
 679               	.LVL56:
 680               	/* epilogue start */
 681 02a4 DF91      		pop r29
 682 02a6 CF91      		pop r28
 683               	.LVL57:
 684 02a8 0895      		ret
 685               		.cfi_endproc
 686               	.LFE12:
 688               	.global	chMtxUnlockS
 690               	chMtxUnlockS:
 691               	.LFB13:
 297:../../os/kernel/src/chmtx.c **** 
 298:../../os/kernel/src/chmtx.c **** /**
 299:../../os/kernel/src/chmtx.c ****  * @brief   Unlocks the next owned mutex in reverse lock order.
 300:../../os/kernel/src/chmtx.c ****  * @pre     The invoking thread <b>must</b> have at least one owned mutex.
 301:../../os/kernel/src/chmtx.c ****  * @post    The mutex is unlocked and removed from the per-thread stack of
 302:../../os/kernel/src/chmtx.c ****  *          owned mutexes.
 303:../../os/kernel/src/chmtx.c ****  * @post    This function does not reschedule so a call to a rescheduling
 304:../../os/kernel/src/chmtx.c ****  *          function must be performed before unlocking the kernel.
 305:../../os/kernel/src/chmtx.c ****  *
 306:../../os/kernel/src/chmtx.c ****  * @return              A pointer to the unlocked mutex.
 307:../../os/kernel/src/chmtx.c ****  *
 308:../../os/kernel/src/chmtx.c ****  * @sclass
 309:../../os/kernel/src/chmtx.c ****  */
 310:../../os/kernel/src/chmtx.c **** Mutex *chMtxUnlockS(void) {
 692               		.loc 1 310 0
 693               		.cfi_startproc
 694 02aa CF93      		push r28
 695               	.LCFI6:
 696               		.cfi_def_cfa_offset 3
 697               		.cfi_offset 28, -2
 698 02ac DF93      		push r29
 699               	.LCFI7:
 700               		.cfi_def_cfa_offset 4
 701               		.cfi_offset 29, -3
 702               	/* prologue: function */
 703               	/* frame size = 0 */
 704               	/* stack size = 2 */
 705               	.L__stack_usage = 2
 311:../../os/kernel/src/chmtx.c ****   Thread *ctp = currp;
 706               		.loc 1 311 0
 707 02ae 8091 0000 		lds r24,rlist+11
 708 02b2 9091 0000 		lds r25,rlist+11+1
 709               	.LVL58:
 312:../../os/kernel/src/chmtx.c ****   Mutex *ump, *mp;
 313:../../os/kernel/src/chmtx.c **** 
 314:../../os/kernel/src/chmtx.c ****   chDbgCheckClassS();
 315:../../os/kernel/src/chmtx.c ****   chDbgAssert(ctp->p_mtxlist != NULL,
 316:../../os/kernel/src/chmtx.c ****               "chMtxUnlockS(), #1",
 317:../../os/kernel/src/chmtx.c ****               "owned mutexes list empty");
 318:../../os/kernel/src/chmtx.c ****   chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
 319:../../os/kernel/src/chmtx.c ****               "chMtxUnlockS(), #2",
 320:../../os/kernel/src/chmtx.c ****               "ownership failure");
 321:../../os/kernel/src/chmtx.c **** 
 322:../../os/kernel/src/chmtx.c ****   /* Removes the top Mutex from the owned mutexes list and marks it as not
 323:../../os/kernel/src/chmtx.c ****      owned.*/
 324:../../os/kernel/src/chmtx.c ****   ump = ctp->p_mtxlist;
 710               		.loc 1 324 0
 711 02b6 DC01      		movw r26,r24
 712 02b8 5D96      		adiw r26,29
 713 02ba CD91      		ld r28,X+
 714 02bc DC91      		ld r29,X
 715 02be 5E97      		sbiw r26,29+1
 716               	.LVL59:
 325:../../os/kernel/src/chmtx.c ****   ctp->p_mtxlist = ump->m_next;
 717               		.loc 1 325 0
 718 02c0 EE81      		ldd r30,Y+6
 719 02c2 FF81      		ldd r31,Y+7
 720 02c4 5E96      		adiw r26,29+1
 721 02c6 FC93      		st X,r31
 722 02c8 EE93      		st -X,r30
 723 02ca 5D97      		sbiw r26,29
 326:../../os/kernel/src/chmtx.c ****   /* If a thread is waiting on the mutex then the fun part begins.*/
 327:../../os/kernel/src/chmtx.c ****   if (chMtxQueueNotEmptyS(ump)) {
 724               		.loc 1 327 0
 725 02cc 2881      		ld r18,Y
 726 02ce 3981      		ldd r19,Y+1
 727 02d0 2C17      		cp r18,r28
 728 02d2 3D07      		cpc r19,r29
 729 02d4 01F0      		breq .L49
 730               	.LBB51:
 328:../../os/kernel/src/chmtx.c ****     Thread *tp;
 329:../../os/kernel/src/chmtx.c **** 
 330:../../os/kernel/src/chmtx.c ****     /* Recalculates the optimal thread priority by scanning the owned
 331:../../os/kernel/src/chmtx.c ****        mutexes list.*/
 332:../../os/kernel/src/chmtx.c ****     tprio_t newprio = ctp->p_realprio;
 731               		.loc 1 332 0
 732 02d6 5F96      		adiw r26,31
 733 02d8 3C91      		ld r19,X
 734               	.LVL60:
 333:../../os/kernel/src/chmtx.c ****     mp = ctp->p_mtxlist;
 334:../../os/kernel/src/chmtx.c ****     while (mp != NULL) {
 735               		.loc 1 334 0
 736 02da 3097      		sbiw r30,0
 737 02dc 01F0      		breq .L50
 738               	.L57:
 335:../../os/kernel/src/chmtx.c ****       /* If the highest priority thread waiting in the mutexes list has a
 336:../../os/kernel/src/chmtx.c ****          greater priority than the current thread base priority then the final
 337:../../os/kernel/src/chmtx.c ****          priority will have at least that priority.*/
 338:../../os/kernel/src/chmtx.c ****       if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
 739               		.loc 1 338 0
 740 02de A081      		ld r26,Z
 741 02e0 B181      		ldd r27,Z+1
 742 02e2 AE17      		cp r26,r30
 743 02e4 BF07      		cpc r27,r31
 744 02e6 01F0      		breq .L51
 745               		.loc 1 338 0 is_stmt 0 discriminator 1
 746 02e8 1496      		adiw r26,4
 747 02ea 2C91      		ld r18,X
 748 02ec 3217      		cp r19,r18
 749 02ee 00F4      		brsh .L51
 750 02f0 322F      		mov r19,r18
 751               	.LVL61:
 752               	.L51:
 339:../../os/kernel/src/chmtx.c ****         newprio = mp->m_queue.p_next->p_prio;
 340:../../os/kernel/src/chmtx.c ****       mp = mp->m_next;
 753               		.loc 1 340 0 is_stmt 1
 754 02f2 0680      		ldd __tmp_reg__,Z+6
 755 02f4 F781      		ldd r31,Z+7
 756 02f6 E02D      		mov r30,__tmp_reg__
 757               	.LVL62:
 334:../../os/kernel/src/chmtx.c ****     while (mp != NULL) {
 758               		.loc 1 334 0
 759 02f8 3097      		sbiw r30,0
 760 02fa 01F4      		brne .L57
 761               	.L50:
 341:../../os/kernel/src/chmtx.c ****     }
 342:../../os/kernel/src/chmtx.c ****     ctp->p_prio = newprio;
 762               		.loc 1 342 0
 763 02fc FC01      		movw r30,r24
 764               	.LVL63:
 765 02fe 3483      		std Z+4,r19
 766               	.LVL64:
 767               	.LBB52:
 768               	.LBB53:
  53:../../os/kernel/include/chinline.h ****   Thread *tp = tqp->p_next;
 769               		.loc 2 53 0
 770 0300 E881      		ld r30,Y
 771 0302 F981      		ldd r31,Y+1
 772               	.LVL65:
  55:../../os/kernel/include/chinline.h ****   (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 773               		.loc 2 55 0
 774 0304 A081      		ld r26,Z
 775 0306 B181      		ldd r27,Z+1
 776 0308 B983      		std Y+1,r27
 777 030a A883      		st Y,r26
 778 030c 1396      		adiw r26,2+1
 779 030e DC93      		st X,r29
 780 0310 CE93      		st -X,r28
 781 0312 1297      		sbiw r26,2
 782               	.LBE53:
 783               	.LBE52:
 343:../../os/kernel/src/chmtx.c ****     /* Awakens the highest priority thread waiting for the unlocked mutex and
 344:../../os/kernel/src/chmtx.c ****        assigns the mutex to it.*/
 345:../../os/kernel/src/chmtx.c ****     tp = fifo_remove(&ump->m_queue);
 346:../../os/kernel/src/chmtx.c ****     ump->m_owner = tp;
 784               		.loc 1 346 0
 785 0314 FD83      		std Y+5,r31
 786 0316 EC83      		std Y+4,r30
 347:../../os/kernel/src/chmtx.c ****     ump->m_next = tp->p_mtxlist;
 787               		.loc 1 347 0
 788 0318 858D      		ldd r24,Z+29
 789 031a 968D      		ldd r25,Z+30
 790               	.LVL66:
 791 031c 9F83      		std Y+7,r25
 792 031e 8E83      		std Y+6,r24
 348:../../os/kernel/src/chmtx.c ****     tp->p_mtxlist = ump;
 793               		.loc 1 348 0
 794 0320 D68F      		std Z+30,r29
 795 0322 C58F      		std Z+29,r28
 349:../../os/kernel/src/chmtx.c ****     chSchReadyI(tp);
 796               		.loc 1 349 0
 797 0324 CF01      		movw r24,r30
 798 0326 0E94 0000 		call chSchReadyI
 799               	.LVL67:
 800               	.LBE51:
 350:../../os/kernel/src/chmtx.c ****   }
 351:../../os/kernel/src/chmtx.c ****   else
 352:../../os/kernel/src/chmtx.c ****     ump->m_owner = NULL;
 353:../../os/kernel/src/chmtx.c ****   return ump;
 354:../../os/kernel/src/chmtx.c **** }
 801               		.loc 1 354 0
 802 032a CE01      		movw r24,r28
 803               	/* epilogue start */
 804 032c DF91      		pop r29
 805 032e CF91      		pop r28
 806               	.LVL68:
 807 0330 0895      		ret
 808               	.LVL69:
 809               	.L49:
 352:../../os/kernel/src/chmtx.c ****     ump->m_owner = NULL;
 810               		.loc 1 352 0
 811 0332 1D82      		std Y+5,__zero_reg__
 812 0334 1C82      		std Y+4,__zero_reg__
 813               		.loc 1 354 0
 814 0336 CE01      		movw r24,r28
 815               	.LVL70:
 816               	/* epilogue start */
 817 0338 DF91      		pop r29
 818 033a CF91      		pop r28
 819               	.LVL71:
 820 033c 0895      		ret
 821               		.cfi_endproc
 822               	.LFE13:
 824               	.global	chMtxUnlockAll
 826               	chMtxUnlockAll:
 827               	.LFB14:
 355:../../os/kernel/src/chmtx.c **** 
 356:../../os/kernel/src/chmtx.c **** /**
 357:../../os/kernel/src/chmtx.c ****  * @brief   Unlocks all the mutexes owned by the invoking thread.
 358:../../os/kernel/src/chmtx.c ****  * @post    The stack of owned mutexes is emptied and all the found
 359:../../os/kernel/src/chmtx.c ****  *          mutexes are unlocked.
 360:../../os/kernel/src/chmtx.c ****  * @note    This function is <b>MUCH MORE</b> efficient than releasing the
 361:../../os/kernel/src/chmtx.c ****  *          mutexes one by one and not just because the call overhead,
 362:../../os/kernel/src/chmtx.c ****  *          this function does not have any overhead related to the priority
 363:../../os/kernel/src/chmtx.c ****  *          inheritance mechanism.
 364:../../os/kernel/src/chmtx.c ****  *
 365:../../os/kernel/src/chmtx.c ****  * @api
 366:../../os/kernel/src/chmtx.c ****  */
 367:../../os/kernel/src/chmtx.c **** void chMtxUnlockAll(void) {
 828               		.loc 1 367 0
 829               		.cfi_startproc
 830 033e 0F93      		push r16
 831               	.LCFI8:
 832               		.cfi_def_cfa_offset 3
 833               		.cfi_offset 16, -2
 834 0340 1F93      		push r17
 835               	.LCFI9:
 836               		.cfi_def_cfa_offset 4
 837               		.cfi_offset 17, -3
 838 0342 CF93      		push r28
 839               	.LCFI10:
 840               		.cfi_def_cfa_offset 5
 841               		.cfi_offset 28, -4
 842 0344 DF93      		push r29
 843               	.LCFI11:
 844               		.cfi_def_cfa_offset 6
 845               		.cfi_offset 29, -5
 846               	/* prologue: function */
 847               	/* frame size = 0 */
 848               	/* stack size = 4 */
 849               	.L__stack_usage = 4
 368:../../os/kernel/src/chmtx.c ****   Thread *ctp = currp;
 850               		.loc 1 368 0
 851 0346 0091 0000 		lds r16,rlist+11
 852 034a 1091 0000 		lds r17,rlist+11+1
 853               	.LVL72:
 369:../../os/kernel/src/chmtx.c **** 
 370:../../os/kernel/src/chmtx.c ****   chSysLock();
 854               		.loc 1 370 0
 855               	/* #APP */
 856               	 ;  370 "../../os/kernel/src/chmtx.c" 1
 857 034e F894      		cli
 858               	 ;  0 "" 2
 371:../../os/kernel/src/chmtx.c ****   if (ctp->p_mtxlist != NULL) {
 859               		.loc 1 371 0
 860               	/* #NOAPP */
 861 0350 D801      		movw r26,r16
 862 0352 5D96      		adiw r26,29
 863 0354 ED91      		ld r30,X+
 864 0356 FC91      		ld r31,X
 865 0358 5E97      		sbiw r26,29+1
 866 035a 3097      		sbiw r30,0
 867 035c 01F4      		brne .L67
 868 035e 00C0      		rjmp .L61
 869               	.LVL73:
 870               	.L71:
 871               	.LBB54:
 872               	.LBB55:
 873               	.LBB56:
 874               	.LBB57:
  55:../../os/kernel/include/chinline.h ****   (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 875               		.loc 2 55 0
 876 0360 8D91      		ld r24,X+
 877 0362 9C91      		ld r25,X
 878 0364 1197      		sbiw r26,1
 879 0366 9183      		std Z+1,r25
 880 0368 8083      		st Z,r24
 881 036a EC01      		movw r28,r24
 882 036c FB83      		std Y+3,r31
 883 036e EA83      		std Y+2,r30
 884               	.LBE57:
 885               	.LBE56:
 372:../../os/kernel/src/chmtx.c ****     do {
 373:../../os/kernel/src/chmtx.c ****       Mutex *ump = ctp->p_mtxlist;
 374:../../os/kernel/src/chmtx.c ****       ctp->p_mtxlist = ump->m_next;
 375:../../os/kernel/src/chmtx.c ****       if (chMtxQueueNotEmptyS(ump)) {
 376:../../os/kernel/src/chmtx.c ****         Thread *tp = fifo_remove(&ump->m_queue);
 377:../../os/kernel/src/chmtx.c ****         ump->m_owner = tp;
 886               		.loc 1 377 0
 887 0370 B583      		std Z+5,r27
 888 0372 A483      		std Z+4,r26
 378:../../os/kernel/src/chmtx.c ****         ump->m_next = tp->p_mtxlist;
 889               		.loc 1 378 0
 890 0374 5D96      		adiw r26,29
 891 0376 8D91      		ld r24,X+
 892 0378 9C91      		ld r25,X
 893 037a 5E97      		sbiw r26,29+1
 894 037c 9783      		std Z+7,r25
 895 037e 8683      		std Z+6,r24
 379:../../os/kernel/src/chmtx.c ****         tp->p_mtxlist = ump;
 896               		.loc 1 379 0
 897 0380 5E96      		adiw r26,29+1
 898 0382 FC93      		st X,r31
 899 0384 EE93      		st -X,r30
 900 0386 5D97      		sbiw r26,29
 380:../../os/kernel/src/chmtx.c ****         chSchReadyI(tp);
 901               		.loc 1 380 0
 902 0388 CD01      		movw r24,r26
 903 038a 0E94 0000 		call chSchReadyI
 904               	.LVL74:
 905               	.LBE55:
 906               	.LBE54:
 381:../../os/kernel/src/chmtx.c ****       }
 382:../../os/kernel/src/chmtx.c ****       else
 383:../../os/kernel/src/chmtx.c ****         ump->m_owner = NULL;
 384:../../os/kernel/src/chmtx.c ****     } while (ctp->p_mtxlist != NULL);
 907               		.loc 1 384 0
 908 038e D801      		movw r26,r16
 909 0390 5D96      		adiw r26,29
 910 0392 ED91      		ld r30,X+
 911 0394 FC91      		ld r31,X
 912 0396 5E97      		sbiw r26,29+1
 913 0398 3097      		sbiw r30,0
 914 039a 01F0      		breq .L70
 915               	.L67:
 916               	.LVL75:
 917               	.LBB58:
 374:../../os/kernel/src/chmtx.c ****       ctp->p_mtxlist = ump->m_next;
 918               		.loc 1 374 0
 919 039c 8681      		ldd r24,Z+6
 920 039e 9781      		ldd r25,Z+7
 921 03a0 E801      		movw r28,r16
 922 03a2 9E8F      		std Y+30,r25
 923 03a4 8D8F      		std Y+29,r24
 375:../../os/kernel/src/chmtx.c ****       if (chMtxQueueNotEmptyS(ump)) {
 924               		.loc 1 375 0
 925 03a6 A081      		ld r26,Z
 926 03a8 B181      		ldd r27,Z+1
 927 03aa AE17      		cp r26,r30
 928 03ac BF07      		cpc r27,r31
 929 03ae 01F4      		brne .L71
 383:../../os/kernel/src/chmtx.c ****         ump->m_owner = NULL;
 930               		.loc 1 383 0
 931 03b0 1582      		std Z+5,__zero_reg__
 932 03b2 1482      		std Z+4,__zero_reg__
 933               	.LBE58:
 934               		.loc 1 384 0
 935 03b4 D801      		movw r26,r16
 936 03b6 5D96      		adiw r26,29
 937 03b8 ED91      		ld r30,X+
 938 03ba FC91      		ld r31,X
 939 03bc 5E97      		sbiw r26,29+1
 940               	.LVL76:
 941 03be 3097      		sbiw r30,0
 942 03c0 01F4      		brne .L67
 943               	.L70:
 385:../../os/kernel/src/chmtx.c ****     ctp->p_prio = ctp->p_realprio;
 944               		.loc 1 385 0
 945 03c2 5F96      		adiw r26,31
 946 03c4 8C91      		ld r24,X
 947 03c6 5F97      		sbiw r26,31
 948 03c8 1496      		adiw r26,4
 949 03ca 8C93      		st X,r24
 386:../../os/kernel/src/chmtx.c ****     chSchRescheduleS();
 950               		.loc 1 386 0
 951 03cc 0E94 0000 		call chSchRescheduleS
 952               	.LVL77:
 953               	.L61:
 387:../../os/kernel/src/chmtx.c ****   }
 388:../../os/kernel/src/chmtx.c ****   chSysUnlock();
 954               		.loc 1 388 0
 955               	/* #APP */
 956               	 ;  388 "../../os/kernel/src/chmtx.c" 1
 957 03d0 7894      		sei
 958               	 ;  0 "" 2
 959               	/* epilogue start */
 389:../../os/kernel/src/chmtx.c **** }
 960               		.loc 1 389 0
 961               	/* #NOAPP */
 962 03d2 DF91      		pop r29
 963 03d4 CF91      		pop r28
 964 03d6 1F91      		pop r17
 965 03d8 0F91      		pop r16
 966               	.LVL78:
 967 03da 0895      		ret
 968               		.cfi_endproc
 969               	.LFE14:
 971               	.Letext0:
 972               		.file 3 "/usr/local/cross/lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
 973               		.file 4 "../../os/ports/GCC/AVR/chtypes.h"
 974               		.file 5 "../../os/kernel/include/chlists.h"
 975               		.file 6 "../../os/kernel/include/chthreads.h"
 976               		.file 7 "../../os/ports/GCC/AVR/chcore.h"
 977               		.file 8 "../../os/kernel/include/chschd.h"
 978               		.file 9 "../../os/kernel/include/chmtx.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 chmtx.c
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:4      *ABS*:000000000000003f __SREG__
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:12     .text:0000000000000000 chMtxInit
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:37     .text:0000000000000010 chMtxLockS
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:376    .text:0000000000000190 chMtxLock
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:406    .text:000000000000019a chMtxTryLock
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:484    .text:00000000000001d6 chMtxTryLockS
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:534    .text:000000000000020c chMtxUnlock
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:690    .text:00000000000002aa chMtxUnlockS
/var/folders/5n/p_75w94d66l9ssrldxqdhh700000gn/T//ccI33rAT.s:826    .text:000000000000033e chMtxUnlockAll

UNDEFINED SYMBOLS
rlist
chSchGoSleepS
chSchReadyI
chSchWakeupS
chSchRescheduleS
