
ch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000008ae  00800200  0000682c  000068c0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000682c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000004d7  00800aae  00800aae  0000716e  2**0
                  ALLOC
  3 .stab         00002b98  00000000  00000000  00007170  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000efa  00000000  00000000  00009d08  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000ac02  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000006f0  00000000  00000000  0000ac13  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00016f93  00000000  00000000  0000b303  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00004c7f  00000000  00000000  00022296  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00003c21  00000000  00000000  00026f15  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001e44  00000000  00000000  0002ab38  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001c86  00000000  00000000  0002c97c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000075a9  00000000  00000000  0002e602  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000330  00000000  00000000  00035bab  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 83 00 	jmp	0x106	; 0x106 <__ctors_end>
       4:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
       8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
       c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      10:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      14:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      18:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      1c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      20:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      24:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      28:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      2c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      30:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      34:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      38:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      3c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      40:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      44:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      48:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      4c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      50:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      54:	0c 94 a4 00 	jmp	0x148	; 0x148 <__vector_21>
      58:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      5c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      60:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      64:	0c 94 ca 2d 	jmp	0x5b94	; 0x5b94 <__vector_25>
      68:	0c 94 0e 2e 	jmp	0x5c1c	; 0x5c1c <__vector_26>
      6c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      70:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      74:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      78:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      7c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      80:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      84:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      88:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      8c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      90:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      94:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      98:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      9c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      a0:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      a4:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      a8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      ac:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      b0:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      b4:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      b8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      bc:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      c0:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      c4:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      c8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      cc:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      d0:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      d4:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      d8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      dc:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      e0:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>

000000e4 <__c.1844>:
      e4:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

000000f4 <__c.1850>:
      f4:	45 46 47 65 66 67 00                                EFGefg.

000000fb <__c.1977>:
      fb:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

00000106 <__ctors_end>:
     106:	11 24       	eor	r1, r1
     108:	1f be       	out	0x3f, r1	; 63
     10a:	cf ef       	ldi	r28, 0xFF	; 255
     10c:	d1 e2       	ldi	r29, 0x21	; 33
     10e:	de bf       	out	0x3e, r29	; 62
     110:	cd bf       	out	0x3d, r28	; 61

00000112 <__do_copy_data>:
     112:	1a e0       	ldi	r17, 0x0A	; 10
     114:	a0 e0       	ldi	r26, 0x00	; 0
     116:	b2 e0       	ldi	r27, 0x02	; 2
     118:	ec e2       	ldi	r30, 0x2C	; 44
     11a:	f8 e6       	ldi	r31, 0x68	; 104
     11c:	00 e0       	ldi	r16, 0x00	; 0
     11e:	0b bf       	out	0x3b, r16	; 59
     120:	02 c0       	rjmp	.+4      	; 0x126 <__do_copy_data+0x14>
     122:	07 90       	elpm	r0, Z+
     124:	0d 92       	st	X+, r0
     126:	ae 3a       	cpi	r26, 0xAE	; 174
     128:	b1 07       	cpc	r27, r17
     12a:	d9 f7       	brne	.-10     	; 0x122 <__do_copy_data+0x10>

0000012c <__do_clear_bss>:
     12c:	1f e0       	ldi	r17, 0x0F	; 15
     12e:	ae ea       	ldi	r26, 0xAE	; 174
     130:	ba e0       	ldi	r27, 0x0A	; 10
     132:	01 c0       	rjmp	.+2      	; 0x136 <.do_clear_bss_start>

00000134 <.do_clear_bss_loop>:
     134:	1d 92       	st	X+, r1

00000136 <.do_clear_bss_start>:
     136:	a5 38       	cpi	r26, 0x85	; 133
     138:	b1 07       	cpc	r27, r17
     13a:	e1 f7       	brne	.-8      	; 0x134 <.do_clear_bss_loop>
     13c:	0e 94 62 2f 	call	0x5ec4	; 0x5ec4 <main>
     140:	0c 94 14 34 	jmp	0x6828	; 0x6828 <_exit>

00000144 <__bad_interrupt>:
     144:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000148 <__vector_21>:


/**
 * @brief   Timer0 interrupt handler.
 */
CH_IRQ_HANDLER(TIMER0_COMPA_vect) {
     148:	1f 92       	push	r1
     14a:	0f 92       	push	r0
     14c:	0f b6       	in	r0, 0x3f	; 63
     14e:	0f 92       	push	r0
     150:	11 24       	eor	r1, r1
     152:	0b b6       	in	r0, 0x3b	; 59
     154:	0f 92       	push	r0
     156:	2f 93       	push	r18
     158:	3f 93       	push	r19
     15a:	4f 93       	push	r20
     15c:	5f 93       	push	r21
     15e:	6f 93       	push	r22
     160:	7f 93       	push	r23
     162:	8f 93       	push	r24
     164:	9f 93       	push	r25
     166:	af 93       	push	r26
     168:	bf 93       	push	r27
     16a:	ef 93       	push	r30
     16c:	ff 93       	push	r31

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
  chSysTimerHandlerI();
     16e:	0e 94 3b 01 	call	0x276	; 0x276 <chSysTimerHandlerI>
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
     172:	0e 94 42 03 	call	0x684	; 0x684 <chSchIsPreemptionRequired>
     176:	81 11       	cpse	r24, r1
     178:	0e 94 e2 03 	call	0x7c4	; 0x7c4 <chSchDoReschedule>
}
     17c:	ff 91       	pop	r31
     17e:	ef 91       	pop	r30
     180:	bf 91       	pop	r27
     182:	af 91       	pop	r26
     184:	9f 91       	pop	r25
     186:	8f 91       	pop	r24
     188:	7f 91       	pop	r23
     18a:	6f 91       	pop	r22
     18c:	5f 91       	pop	r21
     18e:	4f 91       	pop	r20
     190:	3f 91       	pop	r19
     192:	2f 91       	pop	r18
     194:	0f 90       	pop	r0
     196:	0b be       	out	0x3b, r0	; 59
     198:	0f 90       	pop	r0
     19a:	0f be       	out	0x3f, r0	; 63
     19c:	0f 90       	pop	r0
     19e:	1f 90       	pop	r1
     1a0:	18 95       	reti

000001a2 <port_switch>:
#if !defined(__DOXYGEN__)
__attribute__((naked, weak))
#endif
void port_switch(Thread *ntp, Thread *otp) {

  asm volatile ("push    r2");
     1a2:	2f 92       	push	r2
  asm volatile ("push    r3");
     1a4:	3f 92       	push	r3
  asm volatile ("push    r4");
     1a6:	4f 92       	push	r4
  asm volatile ("push    r5");
     1a8:	5f 92       	push	r5
  asm volatile ("push    r6");
     1aa:	6f 92       	push	r6
  asm volatile ("push    r7");
     1ac:	7f 92       	push	r7
  asm volatile ("push    r8");
     1ae:	8f 92       	push	r8
  asm volatile ("push    r9");
     1b0:	9f 92       	push	r9
  asm volatile ("push    r10");
     1b2:	af 92       	push	r10
  asm volatile ("push    r11");
     1b4:	bf 92       	push	r11
  asm volatile ("push    r12");
     1b6:	cf 92       	push	r12
  asm volatile ("push    r13");
     1b8:	df 92       	push	r13
  asm volatile ("push    r14");
     1ba:	ef 92       	push	r14
  asm volatile ("push    r15");
     1bc:	ff 92       	push	r15
  asm volatile ("push    r16");
     1be:	0f 93       	push	r16
  asm volatile ("push    r17");
     1c0:	1f 93       	push	r17
  asm volatile ("push    r28");
     1c2:	cf 93       	push	r28
  asm volatile ("push    r29");
     1c4:	df 93       	push	r29

  asm volatile ("movw    r30, r22");
     1c6:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
     1c8:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
     1ca:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
     1cc:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
     1ce:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
     1d0:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
     1d2:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
     1d4:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
     1d6:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
     1d8:	0e be       	out	0x3e, r0	; 62

  asm volatile ("pop     r29");
     1da:	df 91       	pop	r29
  asm volatile ("pop     r28");
     1dc:	cf 91       	pop	r28
  asm volatile ("pop     r17");
     1de:	1f 91       	pop	r17
  asm volatile ("pop     r16");
     1e0:	0f 91       	pop	r16
  asm volatile ("pop     r15");
     1e2:	ff 90       	pop	r15
  asm volatile ("pop     r14");
     1e4:	ef 90       	pop	r14
  asm volatile ("pop     r13");
     1e6:	df 90       	pop	r13
  asm volatile ("pop     r12");
     1e8:	cf 90       	pop	r12
  asm volatile ("pop     r11");
     1ea:	bf 90       	pop	r11
  asm volatile ("pop     r10");
     1ec:	af 90       	pop	r10
  asm volatile ("pop     r9");
     1ee:	9f 90       	pop	r9
  asm volatile ("pop     r8");
     1f0:	8f 90       	pop	r8
  asm volatile ("pop     r7");
     1f2:	7f 90       	pop	r7
  asm volatile ("pop     r6");
     1f4:	6f 90       	pop	r6
  asm volatile ("pop     r5");
     1f6:	5f 90       	pop	r5
  asm volatile ("pop     r4");
     1f8:	4f 90       	pop	r4
  asm volatile ("pop     r3");
     1fa:	3f 90       	pop	r3
  asm volatile ("pop     r2");
     1fc:	2f 90       	pop	r2
  asm volatile ("ret");
     1fe:	08 95       	ret

00000200 <port_halt>:
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void port_halt(void) {

  port_disable();
     200:	f8 94       	cli
     202:	ff cf       	rjmp	.-2      	; 0x202 <port_halt+0x2>

00000204 <_port_thread_start>:
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
     204:	78 94       	sei
  asm volatile ("movw    r24, r4");
     206:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
     208:	f1 01       	movw	r30, r2
  asm volatile ("icall");
     20a:	09 95       	icall
  asm volatile ("call    chThdExit");
     20c:	0e 94 05 05 	call	0xa0a	; 0xa0a <chThdExit>
     210:	08 95       	ret

00000212 <_idle_thread>:
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
     212:	e0 91 3c 0c 	lds	r30, 0x0C3C
     216:	f0 91 3d 0c 	lds	r31, 0x0C3D
     21a:	8c e5       	ldi	r24, 0x5C	; 92
     21c:	94 e0       	ldi	r25, 0x04	; 4
     21e:	94 87       	std	Z+12, r25	; 0x0c
     220:	83 87       	std	Z+11, r24	; 0x0b
     222:	ff cf       	rjmp	.-2      	; 0x222 <_idle_thread+0x10>

00000224 <chSysInit>:
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
     224:	0f 93       	push	r16
     226:	1f 93       	push	r17
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
     228:	0e 94 65 02 	call	0x4ca	; 0x4ca <_scheduler_init>
  _vt_init();
     22c:	0e 94 90 01 	call	0x320	; 0x320 <_vt_init>
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
     230:	60 e4       	ldi	r22, 0x40	; 64
     232:	8e ea       	ldi	r24, 0xAE	; 174
     234:	9a e0       	ldi	r25, 0x0A	; 10
     236:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <_thread_init>
     23a:	90 93 3d 0c 	sts	0x0C3D, r25
     23e:	80 93 3c 0c 	sts	0x0C3C, r24
  currp->p_state = THD_STATE_CURRENT;
     242:	21 e0       	ldi	r18, 0x01	; 1
     244:	fc 01       	movw	r30, r24
     246:	25 87       	std	Z+13, r18	; 0x0d
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
     248:	78 94       	sei

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
     24a:	e0 91 3c 0c 	lds	r30, 0x0C3C
     24e:	f0 91 3d 0c 	lds	r31, 0x0C3D
     252:	87 e7       	ldi	r24, 0x77	; 119
     254:	92 e0       	ldi	r25, 0x02	; 2
     256:	94 87       	std	Z+12, r25	; 0x0c
     258:	83 87       	std	Z+11, r24	; 0x0b

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
     25a:	00 e0       	ldi	r16, 0x00	; 0
     25c:	10 e0       	ldi	r17, 0x00	; 0
     25e:	29 e0       	ldi	r18, 0x09	; 9
     260:	31 e0       	ldi	r19, 0x01	; 1
     262:	41 e0       	ldi	r20, 0x01	; 1
     264:	6f e6       	ldi	r22, 0x6F	; 111
     266:	70 e0       	ldi	r23, 0x00	; 0
     268:	8a eb       	ldi	r24, 0xBA	; 186
     26a:	9b e0       	ldi	r25, 0x0B	; 11
     26c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
     270:	1f 91       	pop	r17
     272:	0f 91       	pop	r16
     274:	08 95       	ret

00000276 <chSysTimerHandlerI>:
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     276:	0f 93       	push	r16
     278:	1f 93       	push	r17
     27a:	cf 93       	push	r28
     27c:	df 93       	push	r29

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
     27e:	e0 91 3c 0c 	lds	r30, 0x0C3C
     282:	f0 91 3d 0c 	lds	r31, 0x0C3D
     286:	87 85       	ldd	r24, Z+15	; 0x0f
     288:	88 23       	and	r24, r24
     28a:	11 f0       	breq	.+4      	; 0x290 <chSysTimerHandlerI+0x1a>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
     28c:	81 50       	subi	r24, 0x01	; 1
     28e:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
     290:	80 89       	ldd	r24, Z+16	; 0x10
     292:	91 89       	ldd	r25, Z+17	; 0x11
     294:	01 96       	adiw	r24, 0x01	; 1
     296:	91 8b       	std	Z+17, r25	; 0x11
     298:	80 8b       	std	Z+16, r24	; 0x10
#endif
  chVTDoTickI();
     29a:	80 91 2f 0c 	lds	r24, 0x0C2F
     29e:	90 91 30 0c 	lds	r25, 0x0C30
     2a2:	01 96       	adiw	r24, 0x01	; 1
     2a4:	90 93 30 0c 	sts	0x0C30, r25
     2a8:	80 93 2f 0c 	sts	0x0C2F, r24
     2ac:	a0 91 29 0c 	lds	r26, 0x0C29
     2b0:	b0 91 2a 0c 	lds	r27, 0x0C2A
     2b4:	8c e0       	ldi	r24, 0x0C	; 12
     2b6:	a9 32       	cpi	r26, 0x29	; 41
     2b8:	b8 07       	cpc	r27, r24
     2ba:	69 f1       	breq	.+90     	; 0x316 <chSysTimerHandlerI+0xa0>
     2bc:	14 96       	adiw	r26, 0x04	; 4
     2be:	8d 91       	ld	r24, X+
     2c0:	9c 91       	ld	r25, X
     2c2:	15 97       	sbiw	r26, 0x05	; 5
     2c4:	01 97       	sbiw	r24, 0x01	; 1
     2c6:	15 96       	adiw	r26, 0x05	; 5
     2c8:	9c 93       	st	X, r25
     2ca:	8e 93       	st	-X, r24
     2cc:	14 97       	sbiw	r26, 0x04	; 4
     2ce:	89 2b       	or	r24, r25
     2d0:	11 f5       	brne	.+68     	; 0x316 <chSysTimerHandlerI+0xa0>
     2d2:	09 e2       	ldi	r16, 0x29	; 41
     2d4:	1c e0       	ldi	r17, 0x0C	; 12
     2d6:	16 96       	adiw	r26, 0x06	; 6
     2d8:	ed 91       	ld	r30, X+
     2da:	fc 91       	ld	r31, X
     2dc:	17 97       	sbiw	r26, 0x07	; 7
     2de:	17 96       	adiw	r26, 0x07	; 7
     2e0:	1c 92       	st	X, r1
     2e2:	1e 92       	st	-X, r1
     2e4:	16 97       	sbiw	r26, 0x06	; 6
     2e6:	cd 91       	ld	r28, X+
     2e8:	dc 91       	ld	r29, X
     2ea:	11 97       	sbiw	r26, 0x01	; 1
     2ec:	1b 83       	std	Y+3, r17	; 0x03
     2ee:	0a 83       	std	Y+2, r16	; 0x02
     2f0:	d0 93 2a 0c 	sts	0x0C2A, r29
     2f4:	c0 93 29 0c 	sts	0x0C29, r28
     2f8:	18 96       	adiw	r26, 0x08	; 8
     2fa:	8d 91       	ld	r24, X+
     2fc:	9c 91       	ld	r25, X
     2fe:	19 97       	sbiw	r26, 0x09	; 9
     300:	09 95       	icall
     302:	a0 91 29 0c 	lds	r26, 0x0C29
     306:	b0 91 2a 0c 	lds	r27, 0x0C2A
     30a:	14 96       	adiw	r26, 0x04	; 4
     30c:	8d 91       	ld	r24, X+
     30e:	9c 91       	ld	r25, X
     310:	15 97       	sbiw	r26, 0x05	; 5
     312:	89 2b       	or	r24, r25
     314:	01 f3       	breq	.-64     	; 0x2d6 <chSysTimerHandlerI+0x60>
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	1f 91       	pop	r17
     31c:	0f 91       	pop	r16
     31e:	08 95       	ret

00000320 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
     320:	e9 e2       	ldi	r30, 0x29	; 41
     322:	fc e0       	ldi	r31, 0x0C	; 12
     324:	f0 93 2c 0c 	sts	0x0C2C, r31
     328:	e0 93 2b 0c 	sts	0x0C2B, r30
     32c:	f1 83       	std	Z+1, r31	; 0x01
     32e:	e0 83       	st	Z, r30
  vtlist.vt_time = (systime_t)-1;
     330:	8f ef       	ldi	r24, 0xFF	; 255
     332:	9f ef       	ldi	r25, 0xFF	; 255
     334:	90 93 2e 0c 	sts	0x0C2E, r25
     338:	80 93 2d 0c 	sts	0x0C2D, r24
  vtlist.vt_systime = 0;
     33c:	10 92 30 0c 	sts	0x0C30, r1
     340:	10 92 2f 0c 	sts	0x0C2F, r1
     344:	08 95       	ret

00000346 <chVTSetI>:
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
     346:	cf 93       	push	r28
     348:	df 93       	push	r29
     34a:	dc 01       	movw	r26, r24

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
     34c:	19 96       	adiw	r26, 0x09	; 9
     34e:	3c 93       	st	X, r19
     350:	2e 93       	st	-X, r18
     352:	18 97       	sbiw	r26, 0x08	; 8
  vtp->vt_func = vtfunc;
     354:	17 96       	adiw	r26, 0x07	; 7
     356:	5c 93       	st	X, r21
     358:	4e 93       	st	-X, r20
     35a:	16 97       	sbiw	r26, 0x06	; 6
  p = vtlist.vt_next;
     35c:	e0 91 29 0c 	lds	r30, 0x0C29
     360:	f0 91 2a 0c 	lds	r31, 0x0C2A
  while (p->vt_time < time) {
     364:	24 81       	ldd	r18, Z+4	; 0x04
     366:	35 81       	ldd	r19, Z+5	; 0x05
     368:	26 17       	cp	r18, r22
     36a:	37 07       	cpc	r19, r23
     36c:	50 f4       	brcc	.+20     	; 0x382 <chVTSetI+0x3c>
    time -= p->vt_time;
     36e:	62 1b       	sub	r22, r18
     370:	73 0b       	sbc	r23, r19
    p = p->vt_next;
     372:	01 90       	ld	r0, Z+
     374:	f0 81       	ld	r31, Z
     376:	e0 2d       	mov	r30, r0
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
     378:	24 81       	ldd	r18, Z+4	; 0x04
     37a:	35 81       	ldd	r19, Z+5	; 0x05
     37c:	26 17       	cp	r18, r22
     37e:	37 07       	cpc	r19, r23
     380:	b0 f3       	brcs	.-20     	; 0x36e <chVTSetI+0x28>
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
     382:	11 96       	adiw	r26, 0x01	; 1
     384:	fc 93       	st	X, r31
     386:	ee 93       	st	-X, r30
     388:	c2 81       	ldd	r28, Z+2	; 0x02
     38a:	d3 81       	ldd	r29, Z+3	; 0x03
     38c:	13 96       	adiw	r26, 0x03	; 3
     38e:	dc 93       	st	X, r29
     390:	ce 93       	st	-X, r28
     392:	12 97       	sbiw	r26, 0x02	; 2
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
     394:	b3 83       	std	Z+3, r27	; 0x03
     396:	a2 83       	std	Z+2, r26	; 0x02
     398:	b9 83       	std	Y+1, r27	; 0x01
     39a:	a8 83       	st	Y, r26
  vtp->vt_time = time;
     39c:	15 96       	adiw	r26, 0x05	; 5
     39e:	7c 93       	st	X, r23
     3a0:	6e 93       	st	-X, r22
     3a2:	14 97       	sbiw	r26, 0x04	; 4
  if (p != (void *)&vtlist)
     3a4:	8c e0       	ldi	r24, 0x0C	; 12
     3a6:	e9 32       	cpi	r30, 0x29	; 41
     3a8:	f8 07       	cpc	r31, r24
     3aa:	31 f0       	breq	.+12     	; 0x3b8 <chVTSetI+0x72>
    p->vt_time -= time;
     3ac:	84 81       	ldd	r24, Z+4	; 0x04
     3ae:	95 81       	ldd	r25, Z+5	; 0x05
     3b0:	86 1b       	sub	r24, r22
     3b2:	97 0b       	sbc	r25, r23
     3b4:	95 83       	std	Z+5, r25	; 0x05
     3b6:	84 83       	std	Z+4, r24	; 0x04
}
     3b8:	df 91       	pop	r29
     3ba:	cf 91       	pop	r28
     3bc:	08 95       	ret

000003be <chVTResetI>:
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
     3be:	cf 93       	push	r28
     3c0:	df 93       	push	r29
     3c2:	fc 01       	movw	r30, r24
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
     3c4:	a0 81       	ld	r26, Z
     3c6:	b1 81       	ldd	r27, Z+1	; 0x01
     3c8:	8c e0       	ldi	r24, 0x0C	; 12
     3ca:	a9 32       	cpi	r26, 0x29	; 41
     3cc:	b8 07       	cpc	r27, r24
     3ce:	61 f0       	breq	.+24     	; 0x3e8 <chVTResetI+0x2a>
    vtp->vt_next->vt_time += vtp->vt_time;
     3d0:	14 96       	adiw	r26, 0x04	; 4
     3d2:	8d 91       	ld	r24, X+
     3d4:	9c 91       	ld	r25, X
     3d6:	15 97       	sbiw	r26, 0x05	; 5
     3d8:	24 81       	ldd	r18, Z+4	; 0x04
     3da:	35 81       	ldd	r19, Z+5	; 0x05
     3dc:	82 0f       	add	r24, r18
     3de:	93 1f       	adc	r25, r19
     3e0:	15 96       	adiw	r26, 0x05	; 5
     3e2:	9c 93       	st	X, r25
     3e4:	8e 93       	st	-X, r24
     3e6:	14 97       	sbiw	r26, 0x04	; 4
  vtp->vt_prev->vt_next = vtp->vt_next;
     3e8:	c2 81       	ldd	r28, Z+2	; 0x02
     3ea:	d3 81       	ldd	r29, Z+3	; 0x03
     3ec:	b9 83       	std	Y+1, r27	; 0x01
     3ee:	a8 83       	st	Y, r26
  vtp->vt_next->vt_prev = vtp->vt_prev;
     3f0:	a0 81       	ld	r26, Z
     3f2:	b1 81       	ldd	r27, Z+1	; 0x01
     3f4:	13 96       	adiw	r26, 0x03	; 3
     3f6:	dc 93       	st	X, r29
     3f8:	ce 93       	st	-X, r28
     3fa:	12 97       	sbiw	r26, 0x02	; 2
  vtp->vt_func = (vtfunc_t)NULL;
     3fc:	17 82       	std	Z+7, r1	; 0x07
     3fe:	16 82       	std	Z+6, r1	; 0x06
}
     400:	df 91       	pop	r29
     402:	cf 91       	pop	r28
     404:	08 95       	ret

00000406 <chTimeIsWithin>:
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
     406:	20 91 2f 0c 	lds	r18, 0x0C2F
     40a:	30 91 30 0c 	lds	r19, 0x0C30
  return end > start ? (time >= start) && (time < end) :
     40e:	86 17       	cp	r24, r22
     410:	97 07       	cpc	r25, r23
     412:	50 f4       	brcc	.+20     	; 0x428 <chTimeIsWithin+0x22>
     414:	28 17       	cp	r18, r24
     416:	39 07       	cpc	r19, r25
     418:	28 f0       	brcs	.+10     	; 0x424 <chTimeIsWithin+0x1e>
                       (time >= start) || (time < end);
     41a:	81 e0       	ldi	r24, 0x01	; 1
     41c:	26 17       	cp	r18, r22
     41e:	37 07       	cpc	r19, r23
     420:	08 f4       	brcc	.+2      	; 0x424 <chTimeIsWithin+0x1e>
}
     422:	08 95       	ret
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
                       (time >= start) || (time < end);
     424:	80 e0       	ldi	r24, 0x00	; 0
     426:	08 95       	ret
     428:	28 17       	cp	r18, r24
     42a:	39 07       	cpc	r19, r25
     42c:	b0 f3       	brcs	.-20     	; 0x41a <chTimeIsWithin+0x14>
     42e:	81 e0       	ldi	r24, 0x01	; 1
}
     430:	08 95       	ret

00000432 <wakeup>:

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
     432:	cf 93       	push	r28
     434:	df 93       	push	r29
     436:	dc 01       	movw	r26, r24
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
  switch (tp->p_state) {
     438:	1d 96       	adiw	r26, 0x0d	; 13
     43a:	8c 91       	ld	r24, X
     43c:	1d 97       	sbiw	r26, 0x0d	; 13
     43e:	83 30       	cpi	r24, 0x03	; 3
     440:	71 f1       	breq	.+92     	; 0x49e <wakeup+0x6c>
     442:	40 f1       	brcs	.+80     	; 0x494 <wakeup+0x62>
     444:	85 30       	cpi	r24, 0x05	; 5
     446:	91 f1       	breq	.+100    	; 0x4ac <wakeup+0x7a>
     448:	8d 30       	cpi	r24, 0x0D	; 13
     44a:	81 f1       	breq	.+96     	; 0x4ac <wakeup+0x7a>
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
     44c:	8f ef       	ldi	r24, 0xFF	; 255
     44e:	9f ef       	ldi	r25, 0xFF	; 255
     450:	53 96       	adiw	r26, 0x13	; 19
     452:	9c 93       	st	X, r25
     454:	8e 93       	st	-X, r24
     456:	52 97       	sbiw	r26, 0x12	; 18
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     458:	1d 96       	adiw	r26, 0x0d	; 13
     45a:	1c 92       	st	X, r1
     45c:	1d 97       	sbiw	r26, 0x0d	; 13
     45e:	14 96       	adiw	r26, 0x04	; 4
     460:	9c 91       	ld	r25, X
     462:	14 97       	sbiw	r26, 0x04	; 4
  cp = (Thread *)&rlist.r_queue;
     464:	e1 e3       	ldi	r30, 0x31	; 49
     466:	fc e0       	ldi	r31, 0x0C	; 12
  do {
    cp = cp->p_next;
     468:	01 90       	ld	r0, Z+
     46a:	f0 81       	ld	r31, Z
     46c:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     46e:	84 81       	ldd	r24, Z+4	; 0x04
     470:	89 17       	cp	r24, r25
     472:	d0 f7       	brcc	.-12     	; 0x468 <wakeup+0x36>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     474:	11 96       	adiw	r26, 0x01	; 1
     476:	fc 93       	st	X, r31
     478:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     47a:	c2 81       	ldd	r28, Z+2	; 0x02
     47c:	d3 81       	ldd	r29, Z+3	; 0x03
     47e:	13 96       	adiw	r26, 0x03	; 3
     480:	dc 93       	st	X, r29
     482:	ce 93       	st	-X, r28
     484:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     486:	b3 83       	std	Z+3, r27	; 0x03
     488:	a2 83       	std	Z+2, r26	; 0x02
     48a:	b9 83       	std	Y+1, r27	; 0x01
     48c:	a8 83       	st	Y, r26
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromIsr();
}
     48e:	df 91       	pop	r29
     490:	cf 91       	pop	r28
     492:	08 95       	ret
 */
static void wakeup(void *p) {
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
  switch (tp->p_state) {
     494:	81 11       	cpse	r24, r1
     496:	da cf       	rjmp	.-76     	; 0x44c <wakeup+0x1a>
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromIsr();
}
     498:	df 91       	pop	r29
     49a:	cf 91       	pop	r28
     49c:	08 95       	ret
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
     49e:	52 96       	adiw	r26, 0x12	; 18
     4a0:	ed 91       	ld	r30, X+
     4a2:	fc 91       	ld	r31, X
     4a4:	53 97       	sbiw	r26, 0x13	; 19
     4a6:	84 81       	ldd	r24, Z+4	; 0x04
     4a8:	8f 5f       	subi	r24, 0xFF	; 255
     4aa:	84 83       	std	Z+4, r24	; 0x04
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     4ac:	12 96       	adiw	r26, 0x02	; 2
     4ae:	ed 91       	ld	r30, X+
     4b0:	fc 91       	ld	r31, X
     4b2:	13 97       	sbiw	r26, 0x03	; 3
     4b4:	8d 91       	ld	r24, X+
     4b6:	9c 91       	ld	r25, X
     4b8:	11 97       	sbiw	r26, 0x01	; 1
     4ba:	91 83       	std	Z+1, r25	; 0x01
     4bc:	80 83       	st	Z, r24
  tp->p_next->p_prev = tp->p_prev;
     4be:	cd 91       	ld	r28, X+
     4c0:	dc 91       	ld	r29, X
     4c2:	11 97       	sbiw	r26, 0x01	; 1
     4c4:	fb 83       	std	Y+3, r31	; 0x03
     4c6:	ea 83       	std	Y+2, r30	; 0x02
     4c8:	c1 cf       	rjmp	.-126    	; 0x44c <wakeup+0x1a>

000004ca <_scheduler_init>:
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
     4ca:	e1 e3       	ldi	r30, 0x31	; 49
     4cc:	fc e0       	ldi	r31, 0x0C	; 12
     4ce:	f0 93 34 0c 	sts	0x0C34, r31
     4d2:	e0 93 33 0c 	sts	0x0C33, r30
     4d6:	f1 83       	std	Z+1, r31	; 0x01
     4d8:	e0 83       	st	Z, r30
  rlist.r_prio = NOPRIO;
     4da:	10 92 35 0c 	sts	0x0C35, r1
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
     4de:	f0 93 3b 0c 	sts	0x0C3B, r31
     4e2:	e0 93 3a 0c 	sts	0x0C3A, r30
     4e6:	f0 93 39 0c 	sts	0x0C39, r31
     4ea:	e0 93 38 0c 	sts	0x0C38, r30
     4ee:	08 95       	ret

000004f0 <chSchReadyI>:
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
     4f0:	cf 93       	push	r28
     4f2:	df 93       	push	r29
     4f4:	dc 01       	movw	r26, r24
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     4f6:	1d 96       	adiw	r26, 0x0d	; 13
     4f8:	1c 92       	st	X, r1
     4fa:	1d 97       	sbiw	r26, 0x0d	; 13
     4fc:	14 96       	adiw	r26, 0x04	; 4
     4fe:	9c 91       	ld	r25, X
     500:	14 97       	sbiw	r26, 0x04	; 4
  cp = (Thread *)&rlist.r_queue;
     502:	e1 e3       	ldi	r30, 0x31	; 49
     504:	fc e0       	ldi	r31, 0x0C	; 12
  do {
    cp = cp->p_next;
     506:	01 90       	ld	r0, Z+
     508:	f0 81       	ld	r31, Z
     50a:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     50c:	84 81       	ldd	r24, Z+4	; 0x04
     50e:	89 17       	cp	r24, r25
     510:	d0 f7       	brcc	.-12     	; 0x506 <chSchReadyI+0x16>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     512:	11 96       	adiw	r26, 0x01	; 1
     514:	fc 93       	st	X, r31
     516:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     518:	c2 81       	ldd	r28, Z+2	; 0x02
     51a:	d3 81       	ldd	r29, Z+3	; 0x03
     51c:	13 96       	adiw	r26, 0x03	; 3
     51e:	dc 93       	st	X, r29
     520:	ce 93       	st	-X, r28
     522:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     524:	b3 83       	std	Z+3, r27	; 0x03
     526:	a2 83       	std	Z+2, r26	; 0x02
     528:	b9 83       	std	Y+1, r27	; 0x01
     52a:	a8 83       	st	Y, r26
  return tp;
}
     52c:	cd 01       	movw	r24, r26
     52e:	df 91       	pop	r29
     530:	cf 91       	pop	r28
     532:	08 95       	ret

00000534 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
     538:	2c e3       	ldi	r18, 0x3C	; 60
     53a:	3c e0       	ldi	r19, 0x0C	; 12
     53c:	d9 01       	movw	r26, r18
     53e:	6d 91       	ld	r22, X+
     540:	7c 91       	ld	r23, X
     542:	fb 01       	movw	r30, r22
     544:	85 87       	std	Z+13, r24	; 0x0d
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
     546:	84 e1       	ldi	r24, 0x14	; 20
     548:	87 87       	std	Z+15, r24	; 0x0f
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     54a:	e1 e3       	ldi	r30, 0x31	; 49
     54c:	fc e0       	ldi	r31, 0x0C	; 12
     54e:	80 81       	ld	r24, Z
     550:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     552:	dc 01       	movw	r26, r24
     554:	cd 91       	ld	r28, X+
     556:	dc 91       	ld	r29, X
     558:	11 97       	sbiw	r26, 0x01	; 1
     55a:	d1 83       	std	Z+1, r29	; 0x01
     55c:	c0 83       	st	Z, r28
     55e:	fb 83       	std	Y+3, r31	; 0x03
     560:	ea 83       	std	Y+2, r30	; 0x02
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
     562:	f9 01       	movw	r30, r18
     564:	91 83       	std	Z+1, r25	; 0x01
     566:	80 83       	st	Z, r24
  currp->p_state = THD_STATE_CURRENT;
     568:	21 e0       	ldi	r18, 0x01	; 1
     56a:	1d 96       	adiw	r26, 0x0d	; 13
     56c:	2c 93       	st	X, r18
  chSysSwitch(currp, otp);
}
     56e:	df 91       	pop	r29
     570:	cf 91       	pop	r28
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
  chSysSwitch(currp, otp);
     572:	0c 94 d1 00 	jmp	0x1a2	; 0x1a2 <port_switch>

00000576 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
     576:	1f 93       	push	r17
     578:	cf 93       	push	r28
     57a:	df 93       	push	r29
     57c:	cd b7       	in	r28, 0x3d	; 61
     57e:	de b7       	in	r29, 0x3e	; 62
     580:	2a 97       	sbiw	r28, 0x0a	; 10
     582:	0f b6       	in	r0, 0x3f	; 63
     584:	f8 94       	cli
     586:	de bf       	out	0x3e, r29	; 62
     588:	0f be       	out	0x3f, r0	; 63
     58a:	cd bf       	out	0x3d, r28	; 61
     58c:	18 2f       	mov	r17, r24

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
     58e:	6f 3f       	cpi	r22, 0xFF	; 255
     590:	8f ef       	ldi	r24, 0xFF	; 255
     592:	78 07       	cpc	r23, r24
     594:	29 f1       	breq	.+74     	; 0x5e0 <chSchGoSleepTimeoutS+0x6a>
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
     596:	20 91 3c 0c 	lds	r18, 0x0C3C
     59a:	30 91 3d 0c 	lds	r19, 0x0C3D
     59e:	49 e1       	ldi	r20, 0x19	; 25
     5a0:	52 e0       	ldi	r21, 0x02	; 2
     5a2:	ce 01       	movw	r24, r28
     5a4:	01 96       	adiw	r24, 0x01	; 1
     5a6:	0e 94 a3 01 	call	0x346	; 0x346 <chVTSetI>
    chSchGoSleepS(newstate);
     5aa:	81 2f       	mov	r24, r17
     5ac:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
     5b0:	8f 81       	ldd	r24, Y+7	; 0x07
     5b2:	98 85       	ldd	r25, Y+8	; 0x08
     5b4:	89 2b       	or	r24, r25
     5b6:	21 f0       	breq	.+8      	; 0x5c0 <chSchGoSleepTimeoutS+0x4a>
      chVTResetI(&vt);
     5b8:	ce 01       	movw	r24, r28
     5ba:	01 96       	adiw	r24, 0x01	; 1
     5bc:	0e 94 df 01 	call	0x3be	; 0x3be <chVTResetI>
  }
  else
    chSchGoSleepS(newstate);
  return currp->p_u.rdymsg;
     5c0:	e0 91 3c 0c 	lds	r30, 0x0C3C
     5c4:	f0 91 3d 0c 	lds	r31, 0x0C3D
}
     5c8:	82 89       	ldd	r24, Z+18	; 0x12
     5ca:	93 89       	ldd	r25, Z+19	; 0x13
     5cc:	2a 96       	adiw	r28, 0x0a	; 10
     5ce:	0f b6       	in	r0, 0x3f	; 63
     5d0:	f8 94       	cli
     5d2:	de bf       	out	0x3e, r29	; 62
     5d4:	0f be       	out	0x3f, r0	; 63
     5d6:	cd bf       	out	0x3d, r28	; 61
     5d8:	df 91       	pop	r29
     5da:	cf 91       	pop	r28
     5dc:	1f 91       	pop	r17
     5de:	08 95       	ret
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt))
      chVTResetI(&vt);
  }
  else
    chSchGoSleepS(newstate);
     5e0:	81 2f       	mov	r24, r17
     5e2:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
     5e6:	ec cf       	rjmp	.-40     	; 0x5c0 <chSchGoSleepTimeoutS+0x4a>

000005e8 <chSchWakeupS>:
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
     5e8:	cf 93       	push	r28
     5ea:	df 93       	push	r29
     5ec:	dc 01       	movw	r26, r24

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
     5ee:	53 96       	adiw	r26, 0x13	; 19
     5f0:	7c 93       	st	X, r23
     5f2:	6e 93       	st	-X, r22
     5f4:	52 97       	sbiw	r26, 0x12	; 18
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
     5f6:	14 96       	adiw	r26, 0x04	; 4
     5f8:	2c 91       	ld	r18, X
     5fa:	14 97       	sbiw	r26, 0x04	; 4
     5fc:	c0 91 3c 0c 	lds	r28, 0x0C3C
     600:	d0 91 3d 0c 	lds	r29, 0x0C3D
     604:	9c 81       	ldd	r25, Y+4	; 0x04
     606:	92 17       	cp	r25, r18
     608:	d8 f0       	brcs	.+54     	; 0x640 <chSchWakeupS+0x58>
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     60a:	1d 96       	adiw	r26, 0x0d	; 13
     60c:	1c 92       	st	X, r1
     60e:	1d 97       	sbiw	r26, 0x0d	; 13
  cp = (Thread *)&rlist.r_queue;
     610:	e1 e3       	ldi	r30, 0x31	; 49
     612:	fc e0       	ldi	r31, 0x0C	; 12
  do {
    cp = cp->p_next;
     614:	01 90       	ld	r0, Z+
     616:	f0 81       	ld	r31, Z
     618:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     61a:	84 81       	ldd	r24, Z+4	; 0x04
     61c:	82 17       	cp	r24, r18
     61e:	d0 f7       	brcc	.-12     	; 0x614 <chSchWakeupS+0x2c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     620:	11 96       	adiw	r26, 0x01	; 1
     622:	fc 93       	st	X, r31
     624:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     626:	c2 81       	ldd	r28, Z+2	; 0x02
     628:	d3 81       	ldd	r29, Z+3	; 0x03
     62a:	13 96       	adiw	r26, 0x03	; 3
     62c:	dc 93       	st	X, r29
     62e:	ce 93       	st	-X, r28
     630:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     632:	b3 83       	std	Z+3, r27	; 0x03
     634:	a2 83       	std	Z+2, r26	; 0x02
     636:	b9 83       	std	Y+1, r27	; 0x01
     638:	a8 83       	st	Y, r26
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	08 95       	ret
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     640:	1d 86       	std	Y+13, r1	; 0x0d
  cp = (Thread *)&rlist.r_queue;
     642:	e1 e3       	ldi	r30, 0x31	; 49
     644:	fc e0       	ldi	r31, 0x0C	; 12
  do {
    cp = cp->p_next;
     646:	01 90       	ld	r0, Z+
     648:	f0 81       	ld	r31, Z
     64a:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     64c:	84 81       	ldd	r24, Z+4	; 0x04
     64e:	89 17       	cp	r24, r25
     650:	d0 f7       	brcc	.-12     	; 0x646 <chSchWakeupS+0x5e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     652:	f9 83       	std	Y+1, r31	; 0x01
     654:	e8 83       	st	Y, r30
  tp->p_prev = cp->p_prev;
     656:	82 81       	ldd	r24, Z+2	; 0x02
     658:	93 81       	ldd	r25, Z+3	; 0x03
     65a:	9b 83       	std	Y+3, r25	; 0x03
     65c:	8a 83       	std	Y+2, r24	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     65e:	d3 83       	std	Z+3, r29	; 0x03
     660:	c2 83       	std	Z+2, r28	; 0x02
     662:	fc 01       	movw	r30, r24
     664:	d1 83       	std	Z+1, r29	; 0x01
     666:	c0 83       	st	Z, r28
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
     668:	b0 93 3d 0c 	sts	0x0C3D, r27
     66c:	a0 93 3c 0c 	sts	0x0C3C, r26
    ntp->p_state = THD_STATE_CURRENT;
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	1d 96       	adiw	r26, 0x0d	; 13
     674:	8c 93       	st	X, r24
     676:	1d 97       	sbiw	r26, 0x0d	; 13
    chSysSwitch(ntp, otp);
     678:	be 01       	movw	r22, r28
     67a:	cd 01       	movw	r24, r26
  }
}
     67c:	df 91       	pop	r29
     67e:	cf 91       	pop	r28
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
     680:	0c 94 d1 00 	jmp	0x1a2	; 0x1a2 <port_switch>

00000684 <chSchIsPreemptionRequired>:
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_ISPREEMPTIONREQUIRED) || defined(__DOXYGEN__)
bool_t chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&rlist.r_queue);
     684:	e0 91 31 0c 	lds	r30, 0x0C31
     688:	f0 91 32 0c 	lds	r31, 0x0C32
     68c:	24 81       	ldd	r18, Z+4	; 0x04
  tprio_t p2 = currp->p_prio;
     68e:	e0 91 3c 0c 	lds	r30, 0x0C3C
     692:	f0 91 3d 0c 	lds	r31, 0x0C3D
     696:	94 81       	ldd	r25, Z+4	; 0x04
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
     698:	87 85       	ldd	r24, Z+15	; 0x0f
     69a:	81 11       	cpse	r24, r1
     69c:	04 c0       	rjmp	.+8      	; 0x6a6 <chSchIsPreemptionRequired+0x22>
     69e:	81 e0       	ldi	r24, 0x01	; 1
     6a0:	29 17       	cp	r18, r25
     6a2:	20 f0       	brcs	.+8      	; 0x6ac <chSchIsPreemptionRequired+0x28>
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
     6a4:	08 95       	ret
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
     6a6:	81 e0       	ldi	r24, 0x01	; 1
     6a8:	92 17       	cp	r25, r18
     6aa:	e0 f3       	brcs	.-8      	; 0x6a4 <chSchIsPreemptionRequired+0x20>
     6ac:	80 e0       	ldi	r24, 0x00	; 0
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
     6ae:	08 95       	ret

000006b0 <chSchDoRescheduleBehind>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
     6b0:	cf 93       	push	r28
     6b2:	df 93       	push	r29
  Thread *otp;

  otp = currp;
     6b4:	a0 91 3c 0c 	lds	r26, 0x0C3C
     6b8:	b0 91 3d 0c 	lds	r27, 0x0C3D
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     6bc:	80 91 31 0c 	lds	r24, 0x0C31
     6c0:	90 91 32 0c 	lds	r25, 0x0C32

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     6c4:	ec 01       	movw	r28, r24
     6c6:	e8 81       	ld	r30, Y
     6c8:	f9 81       	ldd	r31, Y+1	; 0x01
     6ca:	f0 93 32 0c 	sts	0x0C32, r31
     6ce:	e0 93 31 0c 	sts	0x0C31, r30
     6d2:	21 e3       	ldi	r18, 0x31	; 49
     6d4:	3c e0       	ldi	r19, 0x0C	; 12
     6d6:	33 83       	std	Z+3, r19	; 0x03
     6d8:	22 83       	std	Z+2, r18	; 0x02
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
     6da:	90 93 3d 0c 	sts	0x0C3D, r25
     6de:	80 93 3c 0c 	sts	0x0C3C, r24
  currp->p_state = THD_STATE_CURRENT;
     6e2:	21 e0       	ldi	r18, 0x01	; 1
     6e4:	2d 87       	std	Y+13, r18	; 0x0d
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
     6e6:	24 e1       	ldi	r18, 0x14	; 20
     6e8:	1f 96       	adiw	r26, 0x0f	; 15
     6ea:	2c 93       	st	X, r18
     6ec:	1f 97       	sbiw	r26, 0x0f	; 15
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     6ee:	1d 96       	adiw	r26, 0x0d	; 13
     6f0:	1c 92       	st	X, r1
     6f2:	1d 97       	sbiw	r26, 0x0d	; 13
     6f4:	14 96       	adiw	r26, 0x04	; 4
     6f6:	3c 91       	ld	r19, X
     6f8:	14 97       	sbiw	r26, 0x04	; 4
     6fa:	fc 01       	movw	r30, r24
     6fc:	03 c0       	rjmp	.+6      	; 0x704 <chSchDoRescheduleBehind+0x54>
     6fe:	01 90       	ld	r0, Z+
     700:	f0 81       	ld	r31, Z
     702:	e0 2d       	mov	r30, r0
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
     704:	24 81       	ldd	r18, Z+4	; 0x04
     706:	23 17       	cp	r18, r19
     708:	d0 f7       	brcc	.-12     	; 0x6fe <chSchDoRescheduleBehind+0x4e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     70a:	11 96       	adiw	r26, 0x01	; 1
     70c:	fc 93       	st	X, r31
     70e:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     710:	c2 81       	ldd	r28, Z+2	; 0x02
     712:	d3 81       	ldd	r29, Z+3	; 0x03
     714:	13 96       	adiw	r26, 0x03	; 3
     716:	dc 93       	st	X, r29
     718:	ce 93       	st	-X, r28
     71a:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     71c:	b3 83       	std	Z+3, r27	; 0x03
     71e:	a2 83       	std	Z+2, r26	; 0x02
     720:	b9 83       	std	Y+1, r27	; 0x01
     722:	a8 83       	st	Y, r26
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
     724:	bd 01       	movw	r22, r26
}
     726:	df 91       	pop	r29
     728:	cf 91       	pop	r28
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
     72a:	0c 94 d1 00 	jmp	0x1a2	; 0x1a2 <port_switch>

0000072e <chSchDoRescheduleAhead>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
     72e:	cf 93       	push	r28
     730:	df 93       	push	r29
  Thread *otp, *cp;

  otp = currp;
     732:	a0 91 3c 0c 	lds	r26, 0x0C3C
     736:	b0 91 3d 0c 	lds	r27, 0x0C3D
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     73a:	80 91 31 0c 	lds	r24, 0x0C31
     73e:	90 91 32 0c 	lds	r25, 0x0C32

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     742:	ec 01       	movw	r28, r24
     744:	e8 81       	ld	r30, Y
     746:	f9 81       	ldd	r31, Y+1	; 0x01
     748:	f0 93 32 0c 	sts	0x0C32, r31
     74c:	e0 93 31 0c 	sts	0x0C31, r30
     750:	21 e3       	ldi	r18, 0x31	; 49
     752:	3c e0       	ldi	r19, 0x0C	; 12
     754:	33 83       	std	Z+3, r19	; 0x03
     756:	22 83       	std	Z+2, r18	; 0x02
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
     758:	90 93 3d 0c 	sts	0x0C3D, r25
     75c:	80 93 3c 0c 	sts	0x0C3C, r24
  currp->p_state = THD_STATE_CURRENT;
     760:	21 e0       	ldi	r18, 0x01	; 1
     762:	2d 87       	std	Y+13, r18	; 0x0d

  otp->p_state = THD_STATE_READY;
     764:	1d 96       	adiw	r26, 0x0d	; 13
     766:	1c 92       	st	X, r1
     768:	1d 97       	sbiw	r26, 0x0d	; 13
     76a:	14 96       	adiw	r26, 0x04	; 4
     76c:	3c 91       	ld	r19, X
     76e:	14 97       	sbiw	r26, 0x04	; 4
     770:	fc 01       	movw	r30, r24
     772:	03 c0       	rjmp	.+6      	; 0x77a <chSchDoRescheduleAhead+0x4c>
     774:	01 90       	ld	r0, Z+
     776:	f0 81       	ld	r31, Z
     778:	e0 2d       	mov	r30, r0
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
     77a:	24 81       	ldd	r18, Z+4	; 0x04
     77c:	32 17       	cp	r19, r18
     77e:	d0 f3       	brcs	.-12     	; 0x774 <chSchDoRescheduleAhead+0x46>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
     780:	11 96       	adiw	r26, 0x01	; 1
     782:	fc 93       	st	X, r31
     784:	ee 93       	st	-X, r30
  otp->p_prev = cp->p_prev;
     786:	c2 81       	ldd	r28, Z+2	; 0x02
     788:	d3 81       	ldd	r29, Z+3	; 0x03
     78a:	13 96       	adiw	r26, 0x03	; 3
     78c:	dc 93       	st	X, r29
     78e:	ce 93       	st	-X, r28
     790:	12 97       	sbiw	r26, 0x02	; 2
  otp->p_prev->p_next = cp->p_prev = otp;
     792:	b3 83       	std	Z+3, r27	; 0x03
     794:	a2 83       	std	Z+2, r26	; 0x02
     796:	b9 83       	std	Y+1, r27	; 0x01
     798:	a8 83       	st	Y, r26

  chSysSwitch(currp, otp);
     79a:	bd 01       	movw	r22, r26
}
     79c:	df 91       	pop	r29
     79e:	cf 91       	pop	r28
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
     7a0:	0c 94 d1 00 	jmp	0x1a2	; 0x1a2 <port_switch>

000007a4 <chSchRescheduleS>:
#if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI())
     7a4:	a0 91 31 0c 	lds	r26, 0x0C31
     7a8:	b0 91 32 0c 	lds	r27, 0x0C32
     7ac:	e0 91 3c 0c 	lds	r30, 0x0C3C
     7b0:	f0 91 3d 0c 	lds	r31, 0x0C3D
     7b4:	14 96       	adiw	r26, 0x04	; 4
     7b6:	9c 91       	ld	r25, X
     7b8:	84 81       	ldd	r24, Z+4	; 0x04
     7ba:	89 17       	cp	r24, r25
     7bc:	08 f0       	brcs	.+2      	; 0x7c0 <chSchRescheduleS+0x1c>
     7be:	08 95       	ret
    chSchDoRescheduleAhead();
     7c0:	0c 94 97 03 	jmp	0x72e	; 0x72e <chSchDoRescheduleAhead>

000007c4 <chSchDoReschedule>:
void chSchDoReschedule(void) {

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
     7c4:	e0 91 3c 0c 	lds	r30, 0x0C3C
     7c8:	f0 91 3d 0c 	lds	r31, 0x0C3D
     7cc:	87 85       	ldd	r24, Z+15	; 0x0f
     7ce:	81 11       	cpse	r24, r1
    chSchDoRescheduleBehind();
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
     7d0:	0c 94 97 03 	jmp	0x72e	; 0x72e <chSchDoRescheduleAhead>
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
     7d4:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <chSchDoRescheduleBehind>

000007d8 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {
     7d8:	cf 93       	push	r28
     7da:	df 93       	push	r29
     7dc:	fc 01       	movw	r30, r24

  tp->p_prio = prio;
     7de:	64 83       	std	Z+4, r22	; 0x04
  tp->p_state = THD_STATE_SUSPENDED;
     7e0:	82 e0       	ldi	r24, 0x02	; 2
     7e2:	85 87       	std	Z+13, r24	; 0x0d
  tp->p_flags = THD_MEM_MODE_STATIC;
     7e4:	16 86       	std	Z+14, r1	; 0x0e
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
     7e6:	84 e1       	ldi	r24, 0x14	; 20
     7e8:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
     7ea:	67 8f       	std	Z+31, r22	; 0x1f
  tp->p_mtxlist = NULL;
     7ec:	16 8e       	std	Z+30, r1	; 0x1e
     7ee:	15 8e       	std	Z+29, r1	; 0x1d
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
     7f0:	14 8e       	std	Z+28, r1	; 0x1c
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
     7f2:	11 8a       	std	Z+17, r1	; 0x11
     7f4:	10 8a       	std	Z+16, r1	; 0x10
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
     7f6:	14 86       	std	Z+12, r1	; 0x0c
     7f8:	13 86       	std	Z+11, r1	; 0x0b
  REG_INSERT(tp);
     7fa:	81 e3       	ldi	r24, 0x31	; 49
     7fc:	9c e0       	ldi	r25, 0x0C	; 12
     7fe:	90 87       	std	Z+8, r25	; 0x08
     800:	87 83       	std	Z+7, r24	; 0x07
     802:	ca e3       	ldi	r28, 0x3A	; 58
     804:	dc e0       	ldi	r29, 0x0C	; 12
     806:	a8 81       	ld	r26, Y
     808:	b9 81       	ldd	r27, Y+1	; 0x01
     80a:	b2 87       	std	Z+10, r27	; 0x0a
     80c:	a1 87       	std	Z+9, r26	; 0x09
     80e:	f9 83       	std	Y+1, r31	; 0x01
     810:	e8 83       	st	Y, r30
     812:	18 96       	adiw	r26, 0x08	; 8
     814:	fc 93       	st	X, r31
     816:	ee 93       	st	-X, r30
     818:	17 97       	sbiw	r26, 0x07	; 7
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
     81a:	cf 01       	movw	r24, r30
     81c:	44 96       	adiw	r24, 0x14	; 20
     81e:	95 8b       	std	Z+21, r25	; 0x15
     820:	84 8b       	std	Z+20, r24	; 0x14
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
     822:	cf 01       	movw	r24, r30
     824:	46 96       	adiw	r24, 0x16	; 22
     826:	91 8f       	std	Z+25, r25	; 0x19
     828:	80 8f       	std	Z+24, r24	; 0x18
     82a:	97 8b       	std	Z+23, r25	; 0x17
     82c:	86 8b       	std	Z+22, r24	; 0x16
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
}
     82e:	cf 01       	movw	r24, r30
     830:	df 91       	pop	r29
     832:	cf 91       	pop	r28
     834:	08 95       	ret

00000836 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
     836:	0f 93       	push	r16
     838:	1f 93       	push	r17
     83a:	cf 93       	push	r28
     83c:	df 93       	push	r29
     83e:	fc 01       	movw	r30, r24
  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
     840:	66 51       	subi	r22, 0x16	; 22
     842:	71 09       	sbc	r23, r1
     844:	68 0f       	add	r22, r24
     846:	79 1f       	adc	r23, r25
     848:	76 83       	std	Z+6, r23	; 0x06
     84a:	65 83       	std	Z+5, r22	; 0x05
     84c:	db 01       	movw	r26, r22
     84e:	52 96       	adiw	r26, 0x12	; 18
     850:	2c 93       	st	X, r18
     852:	a5 81       	ldd	r26, Z+5	; 0x05
     854:	b6 81       	ldd	r27, Z+6	; 0x06
     856:	51 96       	adiw	r26, 0x11	; 17
     858:	3c 93       	st	X, r19
     85a:	a5 81       	ldd	r26, Z+5	; 0x05
     85c:	b6 81       	ldd	r27, Z+6	; 0x06
     85e:	50 96       	adiw	r26, 0x10	; 16
     860:	0c 93       	st	X, r16
     862:	a5 81       	ldd	r26, Z+5	; 0x05
     864:	b6 81       	ldd	r27, Z+6	; 0x06
     866:	1f 96       	adiw	r26, 0x0f	; 15
     868:	1c 93       	st	X, r17
     86a:	a5 81       	ldd	r26, Z+5	; 0x05
     86c:	b6 81       	ldd	r27, Z+6	; 0x06
     86e:	53 96       	adiw	r26, 0x13	; 19
     870:	1c 92       	st	X, r1
     872:	a5 81       	ldd	r26, Z+5	; 0x05
     874:	b6 81       	ldd	r27, Z+6	; 0x06
     876:	82 e0       	ldi	r24, 0x02	; 2
     878:	91 e0       	ldi	r25, 0x01	; 1
     87a:	54 96       	adiw	r26, 0x14	; 20
     87c:	9c 93       	st	X, r25
     87e:	a5 81       	ldd	r26, Z+5	; 0x05
     880:	b6 81       	ldd	r27, Z+6	; 0x06
     882:	55 96       	adiw	r26, 0x15	; 21
     884:	8c 93       	st	X, r24
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
     886:	44 83       	std	Z+4, r20	; 0x04
  tp->p_state = THD_STATE_SUSPENDED;
     888:	82 e0       	ldi	r24, 0x02	; 2
     88a:	85 87       	std	Z+13, r24	; 0x0d
  tp->p_flags = THD_MEM_MODE_STATIC;
     88c:	16 86       	std	Z+14, r1	; 0x0e
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
     88e:	84 e1       	ldi	r24, 0x14	; 20
     890:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
     892:	47 8f       	std	Z+31, r20	; 0x1f
  tp->p_mtxlist = NULL;
     894:	16 8e       	std	Z+30, r1	; 0x1e
     896:	15 8e       	std	Z+29, r1	; 0x1d
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
     898:	14 8e       	std	Z+28, r1	; 0x1c
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
     89a:	11 8a       	std	Z+17, r1	; 0x11
     89c:	10 8a       	std	Z+16, r1	; 0x10
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
     89e:	14 86       	std	Z+12, r1	; 0x0c
     8a0:	13 86       	std	Z+11, r1	; 0x0b
  REG_INSERT(tp);
     8a2:	81 e3       	ldi	r24, 0x31	; 49
     8a4:	9c e0       	ldi	r25, 0x0C	; 12
     8a6:	90 87       	std	Z+8, r25	; 0x08
     8a8:	87 83       	std	Z+7, r24	; 0x07
     8aa:	ca e3       	ldi	r28, 0x3A	; 58
     8ac:	dc e0       	ldi	r29, 0x0C	; 12
     8ae:	a8 81       	ld	r26, Y
     8b0:	b9 81       	ldd	r27, Y+1	; 0x01
     8b2:	b2 87       	std	Z+10, r27	; 0x0a
     8b4:	a1 87       	std	Z+9, r26	; 0x09
     8b6:	f9 83       	std	Y+1, r31	; 0x01
     8b8:	e8 83       	st	Y, r30
     8ba:	18 96       	adiw	r26, 0x08	; 8
     8bc:	fc 93       	st	X, r31
     8be:	ee 93       	st	-X, r30
     8c0:	17 97       	sbiw	r26, 0x07	; 7
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
     8c2:	cf 01       	movw	r24, r30
     8c4:	44 96       	adiw	r24, 0x14	; 20
     8c6:	95 8b       	std	Z+21, r25	; 0x15
     8c8:	84 8b       	std	Z+20, r24	; 0x14
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
     8ca:	cf 01       	movw	r24, r30
     8cc:	46 96       	adiw	r24, 0x16	; 22
     8ce:	91 8f       	std	Z+25, r25	; 0x19
     8d0:	80 8f       	std	Z+24, r24	; 0x18
     8d2:	97 8b       	std	Z+23, r25	; 0x17
     8d4:	86 8b       	std	Z+22, r24	; 0x16
  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
  return _thread_init(tp, prio);
}
     8d6:	cf 01       	movw	r24, r30
     8d8:	df 91       	pop	r29
     8da:	cf 91       	pop	r28
     8dc:	1f 91       	pop	r17
     8de:	0f 91       	pop	r16
     8e0:	08 95       	ret

000008e2 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
     8e2:	0f 93       	push	r16
     8e4:	1f 93       	push	r17
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
     8e6:	f8 94       	cli
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
     8e8:	0e 94 1b 04 	call	0x836	; 0x836 <chThdCreateI>
     8ec:	8c 01       	movw	r16, r24
     8ee:	60 e0       	ldi	r22, 0x00	; 0
     8f0:	70 e0       	ldi	r23, 0x00	; 0
     8f2:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
  chSysUnlock();
     8f6:	78 94       	sei
  return tp;
}
     8f8:	c8 01       	movw	r24, r16
     8fa:	1f 91       	pop	r17
     8fc:	0f 91       	pop	r16
     8fe:	08 95       	ret

00000900 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
     900:	cf 93       	push	r28
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");

  chSysLock();
     902:	f8 94       	cli
#if CH_USE_MUTEXES
  oldprio = currp->p_realprio;
     904:	e0 91 3c 0c 	lds	r30, 0x0C3C
     908:	f0 91 3d 0c 	lds	r31, 0x0C3D
     90c:	c7 8d       	ldd	r28, Z+31	; 0x1f
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
     90e:	94 81       	ldd	r25, Z+4	; 0x04
     910:	c9 17       	cp	r28, r25
     912:	11 f0       	breq	.+4      	; 0x918 <chThdSetPriority+0x18>
     914:	98 17       	cp	r25, r24
     916:	08 f4       	brcc	.+2      	; 0x91a <chThdSetPriority+0x1a>
    currp->p_prio = newprio;
     918:	84 83       	std	Z+4, r24	; 0x04
  currp->p_realprio = newprio;
     91a:	87 8f       	std	Z+31, r24	; 0x1f
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
     91c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  chSysUnlock();
     920:	78 94       	sei
  return oldprio;
}
     922:	8c 2f       	mov	r24, r28
     924:	cf 91       	pop	r28
     926:	08 95       	ret

00000928 <chThdResume>:
 * @param[in] tp        pointer to the thread
 * @return              The pointer to the thread.
 *
 * @api
 */
Thread *chThdResume(Thread *tp) {
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	d8 2f       	mov	r29, r24
     92e:	c9 2f       	mov	r28, r25

  chSysLock();
     930:	f8 94       	cli
  chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
              "chThdResume(), #1",
              "thread not in THD_STATE_SUSPENDED state");
  chSchWakeupS(tp, RDY_OK);
     932:	60 e0       	ldi	r22, 0x00	; 0
     934:	70 e0       	ldi	r23, 0x00	; 0
     936:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
  chSysUnlock();
     93a:	78 94       	sei
  return tp;
}
     93c:	8d 2f       	mov	r24, r29
     93e:	9c 2f       	mov	r25, r28
     940:	df 91       	pop	r29
     942:	cf 91       	pop	r28
     944:	08 95       	ret

00000946 <chThdTerminate>:
 *
 * @api
 */
void chThdTerminate(Thread *tp) {

  chSysLock();
     946:	f8 94       	cli
  tp->p_flags |= THD_TERMINATE;
     948:	fc 01       	movw	r30, r24
     94a:	26 85       	ldd	r18, Z+14	; 0x0e
     94c:	24 60       	ori	r18, 0x04	; 4
     94e:	26 87       	std	Z+14, r18	; 0x0e
  chSysUnlock();
     950:	78 94       	sei
     952:	08 95       	ret

00000954 <chThdSleep>:
 */
void chThdSleep(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
     954:	f8 94       	cli
  chThdSleepS(time);
     956:	bc 01       	movw	r22, r24
     958:	86 e0       	ldi	r24, 0x06	; 6
     95a:	0e 94 bb 02 	call	0x576	; 0x576 <chSchGoSleepTimeoutS>
  chSysUnlock();
     95e:	78 94       	sei
     960:	08 95       	ret

00000962 <chThdSleepUntil>:
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
     962:	f8 94       	cli
  if ((time -= chTimeNow()) > 0)
     964:	20 91 2f 0c 	lds	r18, 0x0C2F
     968:	30 91 30 0c 	lds	r19, 0x0C30
     96c:	82 1b       	sub	r24, r18
     96e:	93 0b       	sbc	r25, r19
     970:	21 f0       	breq	.+8      	; 0x97a <chThdSleepUntil+0x18>
    chThdSleepS(time);
     972:	bc 01       	movw	r22, r24
     974:	86 e0       	ldi	r24, 0x06	; 6
     976:	0e 94 bb 02 	call	0x576	; 0x576 <chSchGoSleepTimeoutS>
  chSysUnlock();
     97a:	78 94       	sei
     97c:	08 95       	ret

0000097e <chThdYield>:
 *
 * @api
 */
void chThdYield(void) {

  chSysLock();
     97e:	f8 94       	cli
  chSchDoYieldS();
     980:	a0 91 31 0c 	lds	r26, 0x0C31
     984:	b0 91 32 0c 	lds	r27, 0x0C32
     988:	e0 91 3c 0c 	lds	r30, 0x0C3C
     98c:	f0 91 3d 0c 	lds	r31, 0x0C3D
     990:	14 96       	adiw	r26, 0x04	; 4
     992:	9c 91       	ld	r25, X
     994:	84 81       	ldd	r24, Z+4	; 0x04
     996:	98 17       	cp	r25, r24
     998:	10 f0       	brcs	.+4      	; 0x99e <chThdYield+0x20>
     99a:	0e 94 58 03 	call	0x6b0	; 0x6b0 <chSchDoRescheduleBehind>
  chSysUnlock();
     99e:	78 94       	sei
     9a0:	08 95       	ret

000009a2 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
     9a2:	0f 93       	push	r16
     9a4:	1f 93       	push	r17
     9a6:	cf 93       	push	r28
     9a8:	df 93       	push	r29
  Thread *tp = currp;
     9aa:	c0 91 3c 0c 	lds	r28, 0x0C3C
     9ae:	d0 91 3d 0c 	lds	r29, 0x0C3D

  tp->p_u.exitcode = msg;
     9b2:	9b 8b       	std	Y+19, r25	; 0x13
     9b4:	8a 8b       	std	Y+18, r24	; 0x12
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
     9b6:	8c 89       	ldd	r24, Y+20	; 0x14
     9b8:	9d 89       	ldd	r25, Y+21	; 0x15
     9ba:	8e 01       	movw	r16, r28
     9bc:	0c 5e       	subi	r16, 0xEC	; 236
     9be:	1f 4f       	sbci	r17, 0xFF	; 255
     9c0:	80 17       	cp	r24, r16
     9c2:	91 07       	cpc	r25, r17
     9c4:	61 f0       	breq	.+24     	; 0x9de <chThdExitS+0x3c>
}

static INLINE Thread *list_remove(ThreadsList *tlp) {

  Thread *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
     9c6:	fc 01       	movw	r30, r24
     9c8:	20 81       	ld	r18, Z
     9ca:	31 81       	ldd	r19, Z+1	; 0x01
     9cc:	3d 8b       	std	Y+21, r19	; 0x15
     9ce:	2c 8b       	std	Y+20, r18	; 0x14
    chSchReadyI(list_remove(&tp->p_waiting));
     9d0:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
     9d4:	8c 89       	ldd	r24, Y+20	; 0x14
     9d6:	9d 89       	ldd	r25, Y+21	; 0x15
     9d8:	80 17       	cp	r24, r16
     9da:	91 07       	cpc	r25, r17
     9dc:	a1 f7       	brne	.-24     	; 0x9c6 <chThdExitS+0x24>
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
     9de:	8e 85       	ldd	r24, Y+14	; 0x0e
     9e0:	83 70       	andi	r24, 0x03	; 3
     9e2:	61 f4       	brne	.+24     	; 0x9fc <chThdExitS+0x5a>
    REG_REMOVE(tp);
     9e4:	e9 85       	ldd	r30, Y+9	; 0x09
     9e6:	fa 85       	ldd	r31, Y+10	; 0x0a
     9e8:	8f 81       	ldd	r24, Y+7	; 0x07
     9ea:	98 85       	ldd	r25, Y+8	; 0x08
     9ec:	90 87       	std	Z+8, r25	; 0x08
     9ee:	87 83       	std	Z+7, r24	; 0x07
     9f0:	af 81       	ldd	r26, Y+7	; 0x07
     9f2:	b8 85       	ldd	r27, Y+8	; 0x08
     9f4:	1a 96       	adiw	r26, 0x0a	; 10
     9f6:	fc 93       	st	X, r31
     9f8:	ee 93       	st	-X, r30
     9fa:	19 97       	sbiw	r26, 0x09	; 9
#endif
  chSchGoSleepS(THD_STATE_FINAL);
     9fc:	8e e0       	ldi	r24, 0x0E	; 14
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
     9fe:	df 91       	pop	r29
     a00:	cf 91       	pop	r28
     a02:	1f 91       	pop	r17
     a04:	0f 91       	pop	r16
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    REG_REMOVE(tp);
#endif
  chSchGoSleepS(THD_STATE_FINAL);
     a06:	0c 94 9a 02 	jmp	0x534	; 0x534 <chSchGoSleepS>

00000a0a <chThdExit>:
 *
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
     a0a:	f8 94       	cli
  chThdExitS(msg);
     a0c:	0c 94 d1 04 	jmp	0x9a2	; 0x9a2 <chThdExitS>

00000a10 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(Thread *tp) {
     a10:	cf 93       	push	r28
     a12:	df 93       	push	r29
     a14:	ec 01       	movw	r28, r24
  msg_t msg;

  chDbgCheck(tp != NULL, "chThdWait");

  chSysLock();
     a16:	f8 94       	cli
  chDbgAssert(tp != currp, "chThdWait(), #1", "waiting self");
#if CH_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "chThdWait(), #2", "not referenced");
#endif
  if (tp->p_state != THD_STATE_FINAL) {
     a18:	8d 85       	ldd	r24, Y+13	; 0x0d
     a1a:	8e 30       	cpi	r24, 0x0E	; 14
     a1c:	69 f0       	breq	.+26     	; 0xa38 <chThdWait+0x28>
    list_insert(currp, &tp->p_waiting);
     a1e:	e0 91 3c 0c 	lds	r30, 0x0C3C
     a22:	f0 91 3d 0c 	lds	r31, 0x0C3D
  return tp;
}

static INLINE void list_insert(Thread *tp, ThreadsList *tlp) {

  tp->p_next = tlp->p_next;
     a26:	8c 89       	ldd	r24, Y+20	; 0x14
     a28:	9d 89       	ldd	r25, Y+21	; 0x15
     a2a:	91 83       	std	Z+1, r25	; 0x01
     a2c:	80 83       	st	Z, r24
  tlp->p_next = tp;
     a2e:	fd 8b       	std	Y+21, r31	; 0x15
     a30:	ec 8b       	std	Y+20, r30	; 0x14
    chSchGoSleepS(THD_STATE_WTEXIT);
     a32:	87 e0       	ldi	r24, 0x07	; 7
     a34:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
     a38:	8a 89       	ldd	r24, Y+18	; 0x12
     a3a:	9b 89       	ldd	r25, Y+19	; 0x13
  chSysUnlock();
     a3c:	78 94       	sei
#if CH_USE_DYNAMIC
  chThdRelease(tp);
#endif
  return msg;
}
     a3e:	df 91       	pop	r29
     a40:	cf 91       	pop	r28
     a42:	08 95       	ret

00000a44 <chRegFirstThread>:
 * @api
 */
Thread *chRegFirstThread(void) {
  Thread *tp;

  chSysLock();
     a44:	f8 94       	cli
  tp = rlist.r_newer;
     a46:	e8 e3       	ldi	r30, 0x38	; 56
     a48:	fc e0       	ldi	r31, 0x0C	; 12
     a4a:	80 81       	ld	r24, Z
     a4c:	91 81       	ldd	r25, Z+1	; 0x01
#if CH_USE_DYNAMIC
  tp->p_refs++;
#endif
  chSysUnlock();
     a4e:	78 94       	sei
  return tp;
}
     a50:	08 95       	ret

00000a52 <chRegNextThread>:
 * @api
 */
Thread *chRegNextThread(Thread *tp) {
  Thread *ntp;

  chSysLock();
     a52:	f8 94       	cli
  ntp = tp->p_newer;
     a54:	fc 01       	movw	r30, r24
     a56:	27 81       	ldd	r18, Z+7	; 0x07
     a58:	30 85       	ldd	r19, Z+8	; 0x08
  if (ntp == (Thread *)&rlist)
     a5a:	fc e0       	ldi	r31, 0x0C	; 12
     a5c:	21 33       	cpi	r18, 0x31	; 49
     a5e:	3f 07       	cpc	r19, r31
     a60:	19 f0       	breq	.+6      	; 0xa68 <chRegNextThread+0x16>
    chDbgAssert(ntp->p_refs < 255, "chRegNextThread(), #1",
                "too many references");
    ntp->p_refs++;
  }
#endif
  chSysUnlock();
     a62:	78 94       	sei
#if CH_USE_DYNAMIC
  chThdRelease(tp);
#endif
  return ntp;
}
     a64:	c9 01       	movw	r24, r18
     a66:	08 95       	ret
  Thread *ntp;

  chSysLock();
  ntp = tp->p_newer;
  if (ntp == (Thread *)&rlist)
    ntp = NULL;
     a68:	20 e0       	ldi	r18, 0x00	; 0
     a6a:	30 e0       	ldi	r19, 0x00	; 0
     a6c:	fa cf       	rjmp	.-12     	; 0xa62 <chRegNextThread+0x10>

00000a6e <chSemInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemInit(Semaphore *sp, cnt_t n) {
     a6e:	fc 01       	movw	r30, r24

  chDbgCheck((sp != NULL) && (n >= 0), "chSemInit");

  queue_init(&sp->s_queue);
     a70:	82 83       	std	Z+2, r24	; 0x02
     a72:	f3 83       	std	Z+3, r31	; 0x03
     a74:	80 83       	st	Z, r24
     a76:	f1 83       	std	Z+1, r31	; 0x01
  sp->s_cnt = n;
     a78:	64 83       	std	Z+4, r22	; 0x04
     a7a:	08 95       	ret

00000a7c <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(Semaphore *sp, cnt_t n) {
     a7c:	ff 92       	push	r15
     a7e:	0f 93       	push	r16
     a80:	1f 93       	push	r17
     a82:	cf 93       	push	r28
     a84:	df 93       	push	r29
     a86:	ec 01       	movw	r28, r24
  cnt_t cnt;

  chDbgCheckClassI();
  chDbgCheck((sp != NULL) && (n >= 0), "chSemResetI");
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
     a88:	fc 80       	ldd	r15, Y+4	; 0x04
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemResetI(), #1",
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
     a8a:	6c 83       	std	Y+4, r22	; 0x04
  while (++cnt <= 0)
     a8c:	f3 94       	inc	r15
     a8e:	1f 14       	cp	r1, r15
     a90:	b4 f0       	brlt	.+44     	; 0xabe <chSemResetI+0x42>
    chSchReadyI(lifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_RESET;
     a92:	0e ef       	ldi	r16, 0xFE	; 254
     a94:	1f ef       	ldi	r17, 0xFF	; 255
  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
  return tp;
}

static INLINE Thread *lifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_prev;
     a96:	8a 81       	ldd	r24, Y+2	; 0x02
     a98:	9b 81       	ldd	r25, Y+3	; 0x03

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
     a9a:	dc 01       	movw	r26, r24
     a9c:	12 96       	adiw	r26, 0x02	; 2
     a9e:	ed 91       	ld	r30, X+
     aa0:	fc 91       	ld	r31, X
     aa2:	13 97       	sbiw	r26, 0x03	; 3
     aa4:	fb 83       	std	Y+3, r31	; 0x03
     aa6:	ea 83       	std	Y+2, r30	; 0x02
     aa8:	d1 83       	std	Z+1, r29	; 0x01
     aaa:	c0 83       	st	Z, r28
     aac:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
     ab0:	fc 01       	movw	r30, r24
     ab2:	13 8b       	std	Z+19, r17	; 0x13
     ab4:	02 8b       	std	Z+18, r16	; 0x12
              "chSemResetI(), #1",
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= 0)
     ab6:	f3 94       	inc	r15
     ab8:	f1 e0       	ldi	r31, 0x01	; 1
     aba:	ff 12       	cpse	r15, r31
     abc:	ec cf       	rjmp	.-40     	; 0xa96 <chSemResetI+0x1a>
    chSchReadyI(lifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_RESET;
}
     abe:	df 91       	pop	r29
     ac0:	cf 91       	pop	r28
     ac2:	1f 91       	pop	r17
     ac4:	0f 91       	pop	r16
     ac6:	ff 90       	pop	r15
     ac8:	08 95       	ret

00000aca <chSemReset>:
 *
 * @api
 */
void chSemReset(Semaphore *sp, cnt_t n) {

  chSysLock();
     aca:	f8 94       	cli
  chSemResetI(sp, n);
     acc:	0e 94 3e 05 	call	0xa7c	; 0xa7c <chSemResetI>
  chSchRescheduleS();
     ad0:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  chSysUnlock();
     ad4:	78 94       	sei
     ad6:	08 95       	ret

00000ad8 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(Semaphore *sp) {
     ad8:	cf 93       	push	r28
     ada:	df 93       	push	r29
     adc:	fc 01       	movw	r30, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
     ade:	84 81       	ldd	r24, Z+4	; 0x04
     ae0:	81 50       	subi	r24, 0x01	; 1
     ae2:	84 83       	std	Z+4, r24	; 0x04
     ae4:	87 fd       	sbrc	r24, 7
     ae6:	06 c0       	rjmp	.+12     	; 0xaf4 <chSemWaitS+0x1c>
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
    return currp->p_u.rdymsg;
  }
  return RDY_OK;
     ae8:	20 e0       	ldi	r18, 0x00	; 0
     aea:	30 e0       	ldi	r19, 0x00	; 0
}
     aec:	c9 01       	movw	r24, r18
     aee:	df 91       	pop	r29
     af0:	cf 91       	pop	r28
     af2:	08 95       	ret
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    currp->p_u.wtobjp = sp;
     af4:	a0 91 3c 0c 	lds	r26, 0x0C3C
     af8:	b0 91 3d 0c 	lds	r27, 0x0C3D
     afc:	53 96       	adiw	r26, 0x13	; 19
     afe:	fc 93       	st	X, r31
     b00:	ee 93       	st	-X, r30
     b02:	52 97       	sbiw	r26, 0x12	; 18
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
     b04:	11 96       	adiw	r26, 0x01	; 1
     b06:	fc 93       	st	X, r31
     b08:	ee 93       	st	-X, r30
  tp->p_prev = tqp->p_prev;
     b0a:	c2 81       	ldd	r28, Z+2	; 0x02
     b0c:	d3 81       	ldd	r29, Z+3	; 0x03
     b0e:	13 96       	adiw	r26, 0x03	; 3
     b10:	dc 93       	st	X, r29
     b12:	ce 93       	st	-X, r28
     b14:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = tqp->p_prev = tp;
     b16:	b3 83       	std	Z+3, r27	; 0x03
     b18:	a2 83       	std	Z+2, r26	; 0x02
     b1a:	b9 83       	std	Y+1, r27	; 0x01
     b1c:	a8 83       	st	Y, r26
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
     b1e:	83 e0       	ldi	r24, 0x03	; 3
     b20:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
    return currp->p_u.rdymsg;
     b24:	e0 91 3c 0c 	lds	r30, 0x0C3C
     b28:	f0 91 3d 0c 	lds	r31, 0x0C3D
     b2c:	22 89       	ldd	r18, Z+18	; 0x12
     b2e:	33 89       	ldd	r19, Z+19	; 0x13
  }
  return RDY_OK;
}
     b30:	c9 01       	movw	r24, r18
     b32:	df 91       	pop	r29
     b34:	cf 91       	pop	r28
     b36:	08 95       	ret

00000b38 <chSemWait>:
 * @api
 */
msg_t chSemWait(Semaphore *sp) {
  msg_t msg;

  chSysLock();
     b38:	f8 94       	cli
  msg = chSemWaitS(sp);
     b3a:	0e 94 6c 05 	call	0xad8	; 0xad8 <chSemWaitS>
  chSysUnlock();
     b3e:	78 94       	sei
  return msg;
}
     b40:	08 95       	ret

00000b42 <chSemWaitTimeoutS>:
 * @retval RDY_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(Semaphore *sp, systime_t time) {
     b42:	cf 93       	push	r28
     b44:	df 93       	push	r29
     b46:	fc 01       	movw	r30, r24

  chDbgCheckClassS();
  chDbgCheck(sp != NULL, "chSemWaitTimeoutS");
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
     b48:	94 81       	ldd	r25, Z+4	; 0x04
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
     b4a:	89 2f       	mov	r24, r25
     b4c:	81 50       	subi	r24, 0x01	; 1
     b4e:	84 83       	std	Z+4, r24	; 0x04
     b50:	87 fd       	sbrc	r24, 7
     b52:	06 c0       	rjmp	.+12     	; 0xb60 <chSemWaitTimeoutS+0x1e>
    }
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
  }
  return RDY_OK;
     b54:	20 e0       	ldi	r18, 0x00	; 0
     b56:	30 e0       	ldi	r19, 0x00	; 0
}
     b58:	c9 01       	movw	r24, r18
     b5a:	df 91       	pop	r29
     b5c:	cf 91       	pop	r28
     b5e:	08 95       	ret
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
     b60:	61 15       	cp	r22, r1
     b62:	71 05       	cpc	r23, r1
     b64:	d1 f0       	breq	.+52     	; 0xb9a <chSemWaitTimeoutS+0x58>
      sp->s_cnt++;
      return RDY_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
     b66:	a0 91 3c 0c 	lds	r26, 0x0C3C
     b6a:	b0 91 3d 0c 	lds	r27, 0x0C3D
     b6e:	53 96       	adiw	r26, 0x13	; 19
     b70:	fc 93       	st	X, r31
     b72:	ee 93       	st	-X, r30
     b74:	52 97       	sbiw	r26, 0x12	; 18
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
     b76:	11 96       	adiw	r26, 0x01	; 1
     b78:	fc 93       	st	X, r31
     b7a:	ee 93       	st	-X, r30
  tp->p_prev = tqp->p_prev;
     b7c:	c2 81       	ldd	r28, Z+2	; 0x02
     b7e:	d3 81       	ldd	r29, Z+3	; 0x03
     b80:	13 96       	adiw	r26, 0x03	; 3
     b82:	dc 93       	st	X, r29
     b84:	ce 93       	st	-X, r28
     b86:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = tqp->p_prev = tp;
     b88:	b3 83       	std	Z+3, r27	; 0x03
     b8a:	a2 83       	std	Z+2, r26	; 0x02
     b8c:	b9 83       	std	Y+1, r27	; 0x01
     b8e:	a8 83       	st	Y, r26
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
     b90:	83 e0       	ldi	r24, 0x03	; 3
  }
  return RDY_OK;
}
     b92:	df 91       	pop	r29
     b94:	cf 91       	pop	r28
      sp->s_cnt++;
      return RDY_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
     b96:	0c 94 bb 02 	jmp	0x576	; 0x576 <chSchGoSleepTimeoutS>
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
     b9a:	94 83       	std	Z+4, r25	; 0x04
      return RDY_TIMEOUT;
     b9c:	2f ef       	ldi	r18, 0xFF	; 255
     b9e:	3f ef       	ldi	r19, 0xFF	; 255
     ba0:	db cf       	rjmp	.-74     	; 0xb58 <chSemWaitTimeoutS+0x16>

00000ba2 <chSemWaitTimeout>:
 * @api
 */
msg_t chSemWaitTimeout(Semaphore *sp, systime_t time) {
  msg_t msg;

  chSysLock();
     ba2:	f8 94       	cli
  msg = chSemWaitTimeoutS(sp, time);
     ba4:	0e 94 a1 05 	call	0xb42	; 0xb42 <chSemWaitTimeoutS>
  chSysUnlock();
     ba8:	78 94       	sei
  return msg;
}
     baa:	08 95       	ret

00000bac <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p Semaphore structure
 *
 * @api
 */
void chSemSignal(Semaphore *sp) {
     bac:	cf 93       	push	r28
     bae:	df 93       	push	r29
     bb0:	fc 01       	movw	r30, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemSignal(), #1",
              "inconsistent semaphore");

  chSysLock();
     bb2:	f8 94       	cli
  if (++sp->s_cnt <= 0)
     bb4:	84 81       	ldd	r24, Z+4	; 0x04
     bb6:	8f 5f       	subi	r24, 0xFF	; 255
     bb8:	84 83       	std	Z+4, r24	; 0x04
     bba:	18 16       	cp	r1, r24
     bbc:	24 f4       	brge	.+8      	; 0xbc6 <chSemSignal+0x1a>
    chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
  chSysUnlock();
     bbe:	78 94       	sei
}
     bc0:	df 91       	pop	r29
     bc2:	cf 91       	pop	r28
     bc4:	08 95       	ret
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     bc6:	80 81       	ld	r24, Z
     bc8:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     bca:	ec 01       	movw	r28, r24
     bcc:	a8 81       	ld	r26, Y
     bce:	b9 81       	ldd	r27, Y+1	; 0x01
     bd0:	b1 83       	std	Z+1, r27	; 0x01
     bd2:	a0 83       	st	Z, r26
     bd4:	13 96       	adiw	r26, 0x03	; 3
     bd6:	fc 93       	st	X, r31
     bd8:	ee 93       	st	-X, r30
     bda:	12 97       	sbiw	r26, 0x02	; 2
              "chSemSignal(), #1",
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= 0)
    chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
     bdc:	60 e0       	ldi	r22, 0x00	; 0
     bde:	70 e0       	ldi	r23, 0x00	; 0
     be0:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
  chSysUnlock();
     be4:	78 94       	sei
}
     be6:	df 91       	pop	r29
     be8:	cf 91       	pop	r28
     bea:	08 95       	ret

00000bec <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p Semaphore structure
 *
 * @iclass
 */
void chSemSignalI(Semaphore *sp) {
     bec:	cf 93       	push	r28
     bee:	df 93       	push	r29
     bf0:	fc 01       	movw	r30, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemSignalI(), #1",
              "inconsistent semaphore");

  if (++sp->s_cnt <= 0) {
     bf2:	84 81       	ldd	r24, Z+4	; 0x04
     bf4:	8f 5f       	subi	r24, 0xFF	; 255
     bf6:	84 83       	std	Z+4, r24	; 0x04
     bf8:	18 16       	cp	r1, r24
     bfa:	1c f4       	brge	.+6      	; 0xc02 <chSemSignalI+0x16>
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
    chSchReadyI(tp);
  }
}
     bfc:	df 91       	pop	r29
     bfe:	cf 91       	pop	r28
     c00:	08 95       	ret
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     c02:	80 81       	ld	r24, Z
     c04:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     c06:	ec 01       	movw	r28, r24
     c08:	a8 81       	ld	r26, Y
     c0a:	b9 81       	ldd	r27, Y+1	; 0x01
     c0c:	b1 83       	std	Z+1, r27	; 0x01
     c0e:	a0 83       	st	Z, r26
     c10:	13 96       	adiw	r26, 0x03	; 3
     c12:	fc 93       	st	X, r31
     c14:	ee 93       	st	-X, r30
     c16:	12 97       	sbiw	r26, 0x02	; 2

  if (++sp->s_cnt <= 0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
     c18:	1b 8a       	std	Y+19, r1	; 0x13
     c1a:	1a 8a       	std	Y+18, r1	; 0x12
    chSchReadyI(tp);
  }
}
     c1c:	df 91       	pop	r29
     c1e:	cf 91       	pop	r28
  if (++sp->s_cnt <= 0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
    chSchReadyI(tp);
     c20:	0c 94 78 02 	jmp	0x4f0	; 0x4f0 <chSchReadyI>

00000c24 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(Semaphore *sp, cnt_t n) {
     c24:	1f 93       	push	r17
     c26:	cf 93       	push	r28
     c28:	df 93       	push	r29
     c2a:	ec 01       	movw	r28, r24
     c2c:	16 2f       	mov	r17, r22
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     c2e:	16 16       	cp	r1, r22
     c30:	1c f0       	brlt	.+6      	; 0xc38 <chSemAddCounterI+0x14>
     c32:	17 c0       	rjmp	.+46     	; 0xc62 <chSemAddCounterI+0x3e>
    if (++sp->s_cnt <= 0)
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
    n--;
     c34:	11 50       	subi	r17, 0x01	; 1
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     c36:	a9 f0       	breq	.+42     	; 0xc62 <chSemAddCounterI+0x3e>
    if (++sp->s_cnt <= 0)
     c38:	8c 81       	ldd	r24, Y+4	; 0x04
     c3a:	8f 5f       	subi	r24, 0xFF	; 255
     c3c:	8c 83       	std	Y+4, r24	; 0x04
     c3e:	18 16       	cp	r1, r24
     c40:	cc f3       	brlt	.-14     	; 0xc34 <chSemAddCounterI+0x10>
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     c42:	88 81       	ld	r24, Y
     c44:	99 81       	ldd	r25, Y+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     c46:	dc 01       	movw	r26, r24
     c48:	ed 91       	ld	r30, X+
     c4a:	fc 91       	ld	r31, X
     c4c:	f9 83       	std	Y+1, r31	; 0x01
     c4e:	e8 83       	st	Y, r30
     c50:	d3 83       	std	Z+3, r29	; 0x03
     c52:	c2 83       	std	Z+2, r28	; 0x02
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
     c54:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
     c58:	fc 01       	movw	r30, r24
     c5a:	13 8a       	std	Z+19, r1	; 0x13
     c5c:	12 8a       	std	Z+18, r1	; 0x12
    n--;
     c5e:	11 50       	subi	r17, 0x01	; 1
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     c60:	59 f7       	brne	.-42     	; 0xc38 <chSemAddCounterI+0x14>
    if (++sp->s_cnt <= 0)
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
    n--;
  }
}
     c62:	df 91       	pop	r29
     c64:	cf 91       	pop	r28
     c66:	1f 91       	pop	r17
     c68:	08 95       	ret

00000c6a <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(Semaphore *sps, Semaphore *spw) {
     c6a:	0f 93       	push	r16
     c6c:	1f 93       	push	r17
     c6e:	cf 93       	push	r28
     c70:	df 93       	push	r29
     c72:	fc 01       	movw	r30, r24
     c74:	eb 01       	movw	r28, r22
  chDbgAssert(((spw->s_cnt >= 0) && isempty(&spw->s_queue)) ||
              ((spw->s_cnt < 0) && notempty(&spw->s_queue)),
              "chSemSignalWait(), #2",
              "inconsistent semaphore");

  chSysLock();
     c76:	f8 94       	cli
  if (++sps->s_cnt <= 0)
     c78:	84 81       	ldd	r24, Z+4	; 0x04
     c7a:	8f 5f       	subi	r24, 0xFF	; 255
     c7c:	84 83       	std	Z+4, r24	; 0x04
     c7e:	18 16       	cp	r1, r24
     c80:	9c f5       	brge	.+102    	; 0xce8 <chSemSignalWait+0x7e>
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
  if (--spw->s_cnt < 0) {
     c82:	8c 81       	ldd	r24, Y+4	; 0x04
     c84:	81 50       	subi	r24, 0x01	; 1
     c86:	8c 83       	std	Y+4, r24	; 0x04
     c88:	87 fd       	sbrc	r24, 7
     c8a:	0b c0       	rjmp	.+22     	; 0xca2 <chSemSignalWait+0x38>
    ctp->p_u.wtobjp = spw;
    chSchGoSleepS(THD_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
     c8c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
    msg = RDY_OK;
     c90:	20 e0       	ldi	r18, 0x00	; 0
     c92:	30 e0       	ldi	r19, 0x00	; 0
  }
  chSysUnlock();
     c94:	78 94       	sei
  return msg;
}
     c96:	c9 01       	movw	r24, r18
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	08 95       	ret

  chSysLock();
  if (++sps->s_cnt <= 0)
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
  if (--spw->s_cnt < 0) {
    Thread *ctp = currp;
     ca2:	00 91 3c 0c 	lds	r16, 0x0C3C
     ca6:	10 91 3d 0c 	lds	r17, 0x0C3D
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
     caa:	d8 01       	movw	r26, r16
     cac:	11 96       	adiw	r26, 0x01	; 1
     cae:	dc 93       	st	X, r29
     cb0:	ce 93       	st	-X, r28
  tp->p_prev = tqp->p_prev;
     cb2:	ea 81       	ldd	r30, Y+2	; 0x02
     cb4:	fb 81       	ldd	r31, Y+3	; 0x03
     cb6:	13 96       	adiw	r26, 0x03	; 3
     cb8:	fc 93       	st	X, r31
     cba:	ee 93       	st	-X, r30
     cbc:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = tqp->p_prev = tp;
     cbe:	1b 83       	std	Y+3, r17	; 0x03
     cc0:	0a 83       	std	Y+2, r16	; 0x02
     cc2:	11 83       	std	Z+1, r17	; 0x01
     cc4:	00 83       	st	Z, r16
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtobjp = spw;
     cc6:	53 96       	adiw	r26, 0x13	; 19
     cc8:	dc 93       	st	X, r29
     cca:	ce 93       	st	-X, r28
     ccc:	52 97       	sbiw	r26, 0x12	; 18
    chSchGoSleepS(THD_STATE_WTSEM);
     cce:	83 e0       	ldi	r24, 0x03	; 3
     cd0:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
     cd4:	f8 01       	movw	r30, r16
     cd6:	22 89       	ldd	r18, Z+18	; 0x12
     cd8:	33 89       	ldd	r19, Z+19	; 0x13
  }
  else {
    chSchRescheduleS();
    msg = RDY_OK;
  }
  chSysUnlock();
     cda:	78 94       	sei
  return msg;
}
     cdc:	c9 01       	movw	r24, r18
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	1f 91       	pop	r17
     ce4:	0f 91       	pop	r16
     ce6:	08 95       	ret
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     ce8:	80 81       	ld	r24, Z
     cea:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     cec:	dc 01       	movw	r26, r24
     cee:	2d 91       	ld	r18, X+
     cf0:	3c 91       	ld	r19, X
     cf2:	31 83       	std	Z+1, r19	; 0x01
     cf4:	20 83       	st	Z, r18
     cf6:	d9 01       	movw	r26, r18
     cf8:	13 96       	adiw	r26, 0x03	; 3
     cfa:	fc 93       	st	X, r31
     cfc:	ee 93       	st	-X, r30
     cfe:	12 97       	sbiw	r26, 0x02	; 2
              "chSemSignalWait(), #2",
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= 0)
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
     d00:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
     d04:	fc 01       	movw	r30, r24
     d06:	13 8a       	std	Z+19, r1	; 0x13
     d08:	12 8a       	std	Z+18, r1	; 0x12
     d0a:	bb cf       	rjmp	.-138    	; 0xc82 <chSemSignalWait+0x18>

00000d0c <chMtxInit>:
 *
 * @param[out] mp       pointer to a @p Mutex structure
 *
 * @init
 */
void chMtxInit(Mutex *mp) {
     d0c:	fc 01       	movw	r30, r24

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
     d0e:	82 83       	std	Z+2, r24	; 0x02
     d10:	f3 83       	std	Z+3, r31	; 0x03
     d12:	80 83       	st	Z, r24
     d14:	f1 83       	std	Z+1, r31	; 0x01
  mp->m_owner = NULL;
     d16:	15 82       	std	Z+5, r1	; 0x05
     d18:	14 82       	std	Z+4, r1	; 0x04
     d1a:	08 95       	ret

00000d1c <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @sclass
 */
void chMtxLockS(Mutex *mp) {
     d1c:	0f 93       	push	r16
     d1e:	1f 93       	push	r17
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
     d24:	8c 01       	movw	r16, r24
  Thread *ctp = currp;
     d26:	c0 91 3c 0c 	lds	r28, 0x0C3C
     d2a:	d0 91 3d 0c 	lds	r29, 0x0C3D

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxLockS");

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
     d2e:	dc 01       	movw	r26, r24
     d30:	14 96       	adiw	r26, 0x04	; 4
     d32:	ed 91       	ld	r30, X+
     d34:	fc 91       	ld	r31, X
     d36:	15 97       	sbiw	r26, 0x05	; 5
     d38:	30 97       	sbiw	r30, 0x00	; 0
     d3a:	09 f4       	brne	.+2      	; 0xd3e <chMtxLockS+0x22>
     d3c:	9f c0       	rjmp	.+318    	; 0xe7c <chMtxLockS+0x160>
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
     d3e:	4c 81       	ldd	r20, Y+4	; 0x04
     d40:	84 81       	ldd	r24, Z+4	; 0x04
     d42:	84 17       	cp	r24, r20
     d44:	48 f4       	brcc	.+18     	; 0xd58 <chMtxLockS+0x3c>
      /* Make priority of thread tp match the running thread's priority.*/
      tp->p_prio = ctp->p_prio;
     d46:	44 83       	std	Z+4, r20	; 0x04
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
     d48:	85 85       	ldd	r24, Z+13	; 0x0d
     d4a:	84 30       	cpi	r24, 0x04	; 4
     d4c:	09 f4       	brne	.+2      	; 0xd50 <chMtxLockS+0x34>
     d4e:	60 c0       	rjmp	.+192    	; 0xe10 <chMtxLockS+0xf4>
     d50:	85 30       	cpi	r24, 0x05	; 5
     d52:	91 f1       	breq	.+100    	; 0xdb8 <chMtxLockS+0x9c>
     d54:	88 23       	and	r24, r24
     d56:	f1 f0       	breq	.+60     	; 0xd94 <chMtxLockS+0x78>
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
     d58:	f8 01       	movw	r30, r16
  do {
    cp = cp->p_next;
     d5a:	01 90       	ld	r0, Z+
     d5c:	f0 81       	ld	r31, Z
     d5e:	e0 2d       	mov	r30, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     d60:	0e 17       	cp	r16, r30
     d62:	1f 07       	cpc	r17, r31
     d64:	21 f0       	breq	.+8      	; 0xd6e <chMtxLockS+0x52>
     d66:	94 81       	ldd	r25, Z+4	; 0x04
     d68:	8c 81       	ldd	r24, Y+4	; 0x04
     d6a:	98 17       	cp	r25, r24
     d6c:	b0 f7       	brcc	.-20     	; 0xd5a <chMtxLockS+0x3e>
  tp->p_next = cp;
     d6e:	f9 83       	std	Y+1, r31	; 0x01
     d70:	e8 83       	st	Y, r30
  tp->p_prev = cp->p_prev;
     d72:	a2 81       	ldd	r26, Z+2	; 0x02
     d74:	b3 81       	ldd	r27, Z+3	; 0x03
     d76:	bb 83       	std	Y+3, r27	; 0x03
     d78:	aa 83       	std	Y+2, r26	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     d7a:	d3 83       	std	Z+3, r29	; 0x03
     d7c:	c2 83       	std	Z+2, r28	; 0x02
     d7e:	cd 93       	st	X+, r28
     d80:	dc 93       	st	X, r29
      }
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
    ctp->p_u.wtobjp = mp;
     d82:	1b 8b       	std	Y+19, r17	; 0x13
     d84:	0a 8b       	std	Y+18, r16	; 0x12
    chSchGoSleepS(THD_STATE_WTMTX);
     d86:	84 e0       	ldi	r24, 0x04	; 4
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
     d88:	df 91       	pop	r29
     d8a:	cf 91       	pop	r28
     d8c:	1f 91       	pop	r17
     d8e:	0f 91       	pop	r16
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
    ctp->p_u.wtobjp = mp;
    chSchGoSleepS(THD_STATE_WTMTX);
     d90:	0c 94 9a 02 	jmp	0x534	; 0x534 <chSchGoSleepS>
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     d94:	22 81       	ldd	r18, Z+2	; 0x02
     d96:	33 81       	ldd	r19, Z+3	; 0x03
     d98:	80 81       	ld	r24, Z
     d9a:	91 81       	ldd	r25, Z+1	; 0x01
     d9c:	d9 01       	movw	r26, r18
     d9e:	8d 93       	st	X+, r24
     da0:	9c 93       	st	X, r25
  tp->p_next->p_prev = tp->p_prev;
     da2:	80 81       	ld	r24, Z
     da4:	91 81       	ldd	r25, Z+1	; 0x01
     da6:	dc 01       	movw	r26, r24
     da8:	13 96       	adiw	r26, 0x03	; 3
     daa:	3c 93       	st	X, r19
     dac:	2e 93       	st	-X, r18
     dae:	12 97       	sbiw	r26, 0x02	; 2
#if CH_DBG_ENABLE_ASSERTS
        /* Prevents an assertion in chSchReadyI().*/
        tp->p_state = THD_STATE_CURRENT;
#endif
        /* Re-enqueues tp with its new priority on the ready list.*/
        chSchReadyI(dequeue(tp));
     db0:	cf 01       	movw	r24, r30
     db2:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
        break;
     db6:	d0 cf       	rjmp	.-96     	; 0xd58 <chMtxLockS+0x3c>
#endif
#if CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY
      case THD_STATE_SNDMSGQ:
#endif
        /* Re-enqueues tp with its new priority on the queue.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
     db8:	82 89       	ldd	r24, Z+18	; 0x12
     dba:	93 89       	ldd	r25, Z+19	; 0x13
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     dbc:	62 81       	ldd	r22, Z+2	; 0x02
     dbe:	73 81       	ldd	r23, Z+3	; 0x03
     dc0:	20 81       	ld	r18, Z
     dc2:	31 81       	ldd	r19, Z+1	; 0x01
     dc4:	db 01       	movw	r26, r22
     dc6:	2d 93       	st	X+, r18
     dc8:	3c 93       	st	X, r19
  tp->p_next->p_prev = tp->p_prev;
     dca:	20 81       	ld	r18, Z
     dcc:	31 81       	ldd	r19, Z+1	; 0x01
     dce:	d9 01       	movw	r26, r18
     dd0:	13 96       	adiw	r26, 0x03	; 3
     dd2:	7c 93       	st	X, r23
     dd4:	6e 93       	st	-X, r22
     dd6:	12 97       	sbiw	r26, 0x02	; 2
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
     dd8:	dc 01       	movw	r26, r24
  do {
    cp = cp->p_next;
     dda:	0d 90       	ld	r0, X+
     ddc:	bc 91       	ld	r27, X
     dde:	a0 2d       	mov	r26, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     de0:	8a 17       	cp	r24, r26
     de2:	9b 07       	cpc	r25, r27
     de4:	29 f0       	breq	.+10     	; 0xdf0 <chMtxLockS+0xd4>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	2c 91       	ld	r18, X
     dea:	14 97       	sbiw	r26, 0x04	; 4
     dec:	24 17       	cp	r18, r20
     dee:	a8 f7       	brcc	.-22     	; 0xdda <chMtxLockS+0xbe>
  tp->p_next = cp;
     df0:	b1 83       	std	Z+1, r27	; 0x01
     df2:	a0 83       	st	Z, r26
  tp->p_prev = cp->p_prev;
     df4:	12 96       	adiw	r26, 0x02	; 2
     df6:	8d 91       	ld	r24, X+
     df8:	9c 91       	ld	r25, X
     dfa:	13 97       	sbiw	r26, 0x03	; 3
     dfc:	93 83       	std	Z+3, r25	; 0x03
     dfe:	82 83       	std	Z+2, r24	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     e00:	13 96       	adiw	r26, 0x03	; 3
     e02:	fc 93       	st	X, r31
     e04:	ee 93       	st	-X, r30
     e06:	12 97       	sbiw	r26, 0x02	; 2
     e08:	dc 01       	movw	r26, r24
     e0a:	ed 93       	st	X+, r30
     e0c:	fc 93       	st	X, r31
     e0e:	a4 cf       	rjmp	.-184    	; 0xd58 <chMtxLockS+0x3c>
      tp->p_prio = ctp->p_prio;
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
      case THD_STATE_WTMTX:
        /* Re-enqueues the mutex owner with its new priority.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
     e10:	82 89       	ldd	r24, Z+18	; 0x12
     e12:	93 89       	ldd	r25, Z+19	; 0x13
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     e14:	62 81       	ldd	r22, Z+2	; 0x02
     e16:	73 81       	ldd	r23, Z+3	; 0x03
     e18:	20 81       	ld	r18, Z
     e1a:	31 81       	ldd	r19, Z+1	; 0x01
     e1c:	db 01       	movw	r26, r22
     e1e:	2d 93       	st	X+, r18
     e20:	3c 93       	st	X, r19
  tp->p_next->p_prev = tp->p_prev;
     e22:	20 81       	ld	r18, Z
     e24:	31 81       	ldd	r19, Z+1	; 0x01
     e26:	d9 01       	movw	r26, r18
     e28:	13 96       	adiw	r26, 0x03	; 3
     e2a:	7c 93       	st	X, r23
     e2c:	6e 93       	st	-X, r22
     e2e:	12 97       	sbiw	r26, 0x02	; 2
     e30:	dc 01       	movw	r26, r24
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
     e32:	0d 90       	ld	r0, X+
     e34:	bc 91       	ld	r27, X
     e36:	a0 2d       	mov	r26, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     e38:	8a 17       	cp	r24, r26
     e3a:	9b 07       	cpc	r25, r27
     e3c:	69 f1       	breq	.+90     	; 0xe98 <chMtxLockS+0x17c>
     e3e:	14 96       	adiw	r26, 0x04	; 4
     e40:	2c 91       	ld	r18, X
     e42:	14 97       	sbiw	r26, 0x04	; 4
     e44:	24 17       	cp	r18, r20
     e46:	a8 f7       	brcc	.-22     	; 0xe32 <chMtxLockS+0x116>
  tp->p_next = cp;
     e48:	b1 83       	std	Z+1, r27	; 0x01
     e4a:	a0 83       	st	Z, r26
  tp->p_prev = cp->p_prev;
     e4c:	12 96       	adiw	r26, 0x02	; 2
     e4e:	2d 91       	ld	r18, X+
     e50:	3c 91       	ld	r19, X
     e52:	13 97       	sbiw	r26, 0x03	; 3
     e54:	33 83       	std	Z+3, r19	; 0x03
     e56:	22 83       	std	Z+2, r18	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     e58:	13 96       	adiw	r26, 0x03	; 3
     e5a:	fc 93       	st	X, r31
     e5c:	ee 93       	st	-X, r30
     e5e:	12 97       	sbiw	r26, 0x02	; 2
     e60:	d9 01       	movw	r26, r18
     e62:	ed 93       	st	X+, r30
     e64:	fc 93       	st	X, r31
        tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
     e66:	dc 01       	movw	r26, r24
     e68:	14 96       	adiw	r26, 0x04	; 4
     e6a:	ed 91       	ld	r30, X+
     e6c:	fc 91       	ld	r31, X
     e6e:	15 97       	sbiw	r26, 0x05	; 5
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
     e70:	4c 81       	ldd	r20, Y+4	; 0x04
     e72:	84 81       	ldd	r24, Z+4	; 0x04
     e74:	84 17       	cp	r24, r20
     e76:	08 f4       	brcc	.+2      	; 0xe7a <chMtxLockS+0x15e>
     e78:	66 cf       	rjmp	.-308    	; 0xd46 <chMtxLockS+0x2a>
     e7a:	6e cf       	rjmp	.-292    	; 0xd58 <chMtxLockS+0x3c>
    chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
    chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
  }
  else {
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
     e7c:	fc 01       	movw	r30, r24
     e7e:	d5 83       	std	Z+5, r29	; 0x05
     e80:	c4 83       	std	Z+4, r28	; 0x04
    mp->m_next = ctp->p_mtxlist;
     e82:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e84:	9e 8d       	ldd	r25, Y+30	; 0x1e
     e86:	97 83       	std	Z+7, r25	; 0x07
     e88:	86 83       	std	Z+6, r24	; 0x06
    ctp->p_mtxlist = mp;
     e8a:	1e 8f       	std	Y+30, r17	; 0x1e
     e8c:	0d 8f       	std	Y+29, r16	; 0x1d
  }
}
     e8e:	df 91       	pop	r29
     e90:	cf 91       	pop	r28
     e92:	1f 91       	pop	r17
     e94:	0f 91       	pop	r16
     e96:	08 95       	ret
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     e98:	dc 01       	movw	r26, r24
     e9a:	d6 cf       	rjmp	.-84     	; 0xe48 <chMtxLockS+0x12c>

00000e9c <chMtxLock>:
 *
 * @api
 */
void chMtxLock(Mutex *mp) {

  chSysLock();
     e9c:	f8 94       	cli

  chMtxLockS(mp);
     e9e:	0e 94 8e 06 	call	0xd1c	; 0xd1c <chMtxLockS>

  chSysUnlock();
     ea2:	78 94       	sei
     ea4:	08 95       	ret

00000ea6 <chMtxTryLock>:
 * @api
 */
bool_t chMtxTryLock(Mutex *mp) {
  bool_t b;

  chSysLock();
     ea6:	f8 94       	cli
bool_t chMtxTryLockS(Mutex *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
     ea8:	dc 01       	movw	r26, r24
     eaa:	14 96       	adiw	r26, 0x04	; 4
     eac:	2d 91       	ld	r18, X+
     eae:	3c 91       	ld	r19, X
     eb0:	15 97       	sbiw	r26, 0x05	; 5
     eb2:	23 2b       	or	r18, r19
     eb4:	19 f0       	breq	.+6      	; 0xebc <chMtxTryLock+0x16>
    return FALSE;
     eb6:	80 e0       	ldi	r24, 0x00	; 0

  chSysLock();

  b = chMtxTryLockS(mp);

  chSysUnlock();
     eb8:	78 94       	sei
  return b;
}
     eba:	08 95       	ret
  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
    return FALSE;
  mp->m_owner = currp;
     ebc:	e0 91 3c 0c 	lds	r30, 0x0C3C
     ec0:	f0 91 3d 0c 	lds	r31, 0x0C3D
     ec4:	15 96       	adiw	r26, 0x05	; 5
     ec6:	fc 93       	st	X, r31
     ec8:	ee 93       	st	-X, r30
     eca:	14 97       	sbiw	r26, 0x04	; 4
  mp->m_next = currp->p_mtxlist;
     ecc:	25 8d       	ldd	r18, Z+29	; 0x1d
     ece:	36 8d       	ldd	r19, Z+30	; 0x1e
     ed0:	17 96       	adiw	r26, 0x07	; 7
     ed2:	3c 93       	st	X, r19
     ed4:	2e 93       	st	-X, r18
     ed6:	16 97       	sbiw	r26, 0x06	; 6
  currp->p_mtxlist = mp;
     ed8:	96 8f       	std	Z+30, r25	; 0x1e
     eda:	85 8f       	std	Z+29, r24	; 0x1d
  return TRUE;
     edc:	81 e0       	ldi	r24, 0x01	; 1

  chSysLock();

  b = chMtxTryLockS(mp);

  chSysUnlock();
     ede:	78 94       	sei
  return b;
}
     ee0:	08 95       	ret

00000ee2 <chMtxTryLockS>:
bool_t chMtxTryLockS(Mutex *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
     ee2:	dc 01       	movw	r26, r24
     ee4:	14 96       	adiw	r26, 0x04	; 4
     ee6:	2d 91       	ld	r18, X+
     ee8:	3c 91       	ld	r19, X
     eea:	15 97       	sbiw	r26, 0x05	; 5
     eec:	23 2b       	or	r18, r19
     eee:	11 f0       	breq	.+4      	; 0xef4 <chMtxTryLockS+0x12>
    return FALSE;
     ef0:	80 e0       	ldi	r24, 0x00	; 0
  mp->m_owner = currp;
  mp->m_next = currp->p_mtxlist;
  currp->p_mtxlist = mp;
  return TRUE;
}
     ef2:	08 95       	ret
  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
    return FALSE;
  mp->m_owner = currp;
     ef4:	e0 91 3c 0c 	lds	r30, 0x0C3C
     ef8:	f0 91 3d 0c 	lds	r31, 0x0C3D
     efc:	15 96       	adiw	r26, 0x05	; 5
     efe:	fc 93       	st	X, r31
     f00:	ee 93       	st	-X, r30
     f02:	14 97       	sbiw	r26, 0x04	; 4
  mp->m_next = currp->p_mtxlist;
     f04:	25 8d       	ldd	r18, Z+29	; 0x1d
     f06:	36 8d       	ldd	r19, Z+30	; 0x1e
     f08:	17 96       	adiw	r26, 0x07	; 7
     f0a:	3c 93       	st	X, r19
     f0c:	2e 93       	st	-X, r18
     f0e:	16 97       	sbiw	r26, 0x06	; 6
  currp->p_mtxlist = mp;
     f10:	96 8f       	std	Z+30, r25	; 0x1e
     f12:	85 8f       	std	Z+29, r24	; 0x1d
  return TRUE;
     f14:	81 e0       	ldi	r24, 0x01	; 1
     f16:	08 95       	ret

00000f18 <chMtxUnlock>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @api
 */
Mutex *chMtxUnlock(void) {
     f18:	cf 93       	push	r28
     f1a:	df 93       	push	r29
  Thread *ctp = currp;
     f1c:	80 91 3c 0c 	lds	r24, 0x0C3C
     f20:	90 91 3d 0c 	lds	r25, 0x0C3D
  Mutex *ump, *mp;

  chSysLock();
     f24:	f8 94       	cli
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
              "chMtxUnlock(), #2",
              "ownership failure");
  /* Removes the top Mutex from the Thread's owned mutexes list and marks it
     as not owned.*/
  ump = ctp->p_mtxlist;
     f26:	dc 01       	movw	r26, r24
     f28:	5d 96       	adiw	r26, 0x1d	; 29
     f2a:	cd 91       	ld	r28, X+
     f2c:	dc 91       	ld	r29, X
     f2e:	5e 97       	sbiw	r26, 0x1e	; 30
  ctp->p_mtxlist = ump->m_next;
     f30:	ee 81       	ldd	r30, Y+6	; 0x06
     f32:	ff 81       	ldd	r31, Y+7	; 0x07
     f34:	5e 96       	adiw	r26, 0x1e	; 30
     f36:	fc 93       	st	X, r31
     f38:	ee 93       	st	-X, r30
     f3a:	5d 97       	sbiw	r26, 0x1d	; 29
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
     f3c:	28 81       	ld	r18, Y
     f3e:	39 81       	ldd	r19, Y+1	; 0x01
     f40:	2c 17       	cp	r18, r28
     f42:	3d 07       	cpc	r19, r29
     f44:	89 f1       	breq	.+98     	; 0xfa8 <chMtxUnlock+0x90>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
     f46:	5f 96       	adiw	r26, 0x1f	; 31
     f48:	3c 91       	ld	r19, X
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     f4a:	30 97       	sbiw	r30, 0x00	; 0
     f4c:	79 f0       	breq	.+30     	; 0xf6c <chMtxUnlock+0x54>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
     f4e:	a0 81       	ld	r26, Z
     f50:	b1 81       	ldd	r27, Z+1	; 0x01
     f52:	ae 17       	cp	r26, r30
     f54:	bf 07       	cpc	r27, r31
     f56:	29 f0       	breq	.+10     	; 0xf62 <chMtxUnlock+0x4a>
     f58:	14 96       	adiw	r26, 0x04	; 4
     f5a:	2c 91       	ld	r18, X
     f5c:	32 17       	cp	r19, r18
     f5e:	08 f4       	brcc	.+2      	; 0xf62 <chMtxUnlock+0x4a>
     f60:	32 2f       	mov	r19, r18
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
     f62:	06 80       	ldd	r0, Z+6	; 0x06
     f64:	f7 81       	ldd	r31, Z+7	; 0x07
     f66:	e0 2d       	mov	r30, r0

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     f68:	30 97       	sbiw	r30, 0x00	; 0
     f6a:	89 f7       	brne	.-30     	; 0xf4e <chMtxUnlock+0x36>
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    /* Assigns to the current thread the highest priority among all the
       waiting threads.*/
    ctp->p_prio = newprio;
     f6c:	fc 01       	movw	r30, r24
     f6e:	34 83       	std	Z+4, r19	; 0x04
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     f70:	e8 81       	ld	r30, Y
     f72:	f9 81       	ldd	r31, Y+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     f74:	a0 81       	ld	r26, Z
     f76:	b1 81       	ldd	r27, Z+1	; 0x01
     f78:	b9 83       	std	Y+1, r27	; 0x01
     f7a:	a8 83       	st	Y, r26
     f7c:	13 96       	adiw	r26, 0x03	; 3
     f7e:	dc 93       	st	X, r29
     f80:	ce 93       	st	-X, r28
     f82:	12 97       	sbiw	r26, 0x02	; 2
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    ump->m_owner = tp;
     f84:	fd 83       	std	Y+5, r31	; 0x05
     f86:	ec 83       	std	Y+4, r30	; 0x04
    ump->m_next = tp->p_mtxlist;
     f88:	85 8d       	ldd	r24, Z+29	; 0x1d
     f8a:	96 8d       	ldd	r25, Z+30	; 0x1e
     f8c:	9f 83       	std	Y+7, r25	; 0x07
     f8e:	8e 83       	std	Y+6, r24	; 0x06
    tp->p_mtxlist = ump;
     f90:	d6 8f       	std	Z+30, r29	; 0x1e
     f92:	c5 8f       	std	Z+29, r28	; 0x1d
    chSchWakeupS(tp, RDY_OK);
     f94:	60 e0       	ldi	r22, 0x00	; 0
     f96:	70 e0       	ldi	r23, 0x00	; 0
     f98:	cf 01       	movw	r24, r30
     f9a:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
  }
  else
    ump->m_owner = NULL;
  chSysUnlock();
     f9e:	78 94       	sei
  return ump;
}
     fa0:	ce 01       	movw	r24, r28
     fa2:	df 91       	pop	r29
     fa4:	cf 91       	pop	r28
     fa6:	08 95       	ret
    ump->m_next = tp->p_mtxlist;
    tp->p_mtxlist = ump;
    chSchWakeupS(tp, RDY_OK);
  }
  else
    ump->m_owner = NULL;
     fa8:	1d 82       	std	Y+5, r1	; 0x05
     faa:	1c 82       	std	Y+4, r1	; 0x04
  chSysUnlock();
     fac:	78 94       	sei
  return ump;
}
     fae:	ce 01       	movw	r24, r28
     fb0:	df 91       	pop	r29
     fb2:	cf 91       	pop	r28
     fb4:	08 95       	ret

00000fb6 <chMtxUnlockS>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @sclass
 */
Mutex *chMtxUnlockS(void) {
     fb6:	cf 93       	push	r28
     fb8:	df 93       	push	r29
  Thread *ctp = currp;
     fba:	80 91 3c 0c 	lds	r24, 0x0C3C
     fbe:	90 91 3d 0c 	lds	r25, 0x0C3D
              "chMtxUnlockS(), #2",
              "ownership failure");

  /* Removes the top Mutex from the owned mutexes list and marks it as not
     owned.*/
  ump = ctp->p_mtxlist;
     fc2:	dc 01       	movw	r26, r24
     fc4:	5d 96       	adiw	r26, 0x1d	; 29
     fc6:	cd 91       	ld	r28, X+
     fc8:	dc 91       	ld	r29, X
     fca:	5e 97       	sbiw	r26, 0x1e	; 30
  ctp->p_mtxlist = ump->m_next;
     fcc:	ee 81       	ldd	r30, Y+6	; 0x06
     fce:	ff 81       	ldd	r31, Y+7	; 0x07
     fd0:	5e 96       	adiw	r26, 0x1e	; 30
     fd2:	fc 93       	st	X, r31
     fd4:	ee 93       	st	-X, r30
     fd6:	5d 97       	sbiw	r26, 0x1d	; 29
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
     fd8:	28 81       	ld	r18, Y
     fda:	39 81       	ldd	r19, Y+1	; 0x01
     fdc:	2c 17       	cp	r18, r28
     fde:	3d 07       	cpc	r19, r29
     fe0:	71 f1       	breq	.+92     	; 0x103e <chMtxUnlockS+0x88>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
     fe2:	5f 96       	adiw	r26, 0x1f	; 31
     fe4:	3c 91       	ld	r19, X
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     fe6:	30 97       	sbiw	r30, 0x00	; 0
     fe8:	79 f0       	breq	.+30     	; 0x1008 <chMtxUnlockS+0x52>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
     fea:	a0 81       	ld	r26, Z
     fec:	b1 81       	ldd	r27, Z+1	; 0x01
     fee:	ae 17       	cp	r26, r30
     ff0:	bf 07       	cpc	r27, r31
     ff2:	29 f0       	breq	.+10     	; 0xffe <chMtxUnlockS+0x48>
     ff4:	14 96       	adiw	r26, 0x04	; 4
     ff6:	2c 91       	ld	r18, X
     ff8:	32 17       	cp	r19, r18
     ffa:	08 f4       	brcc	.+2      	; 0xffe <chMtxUnlockS+0x48>
     ffc:	32 2f       	mov	r19, r18
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
     ffe:	06 80       	ldd	r0, Z+6	; 0x06
    1000:	f7 81       	ldd	r31, Z+7	; 0x07
    1002:	e0 2d       	mov	r30, r0

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
    1004:	30 97       	sbiw	r30, 0x00	; 0
    1006:	89 f7       	brne	.-30     	; 0xfea <chMtxUnlockS+0x34>
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    ctp->p_prio = newprio;
    1008:	fc 01       	movw	r30, r24
    100a:	34 83       	std	Z+4, r19	; 0x04
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
    100c:	e8 81       	ld	r30, Y
    100e:	f9 81       	ldd	r31, Y+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    1010:	a0 81       	ld	r26, Z
    1012:	b1 81       	ldd	r27, Z+1	; 0x01
    1014:	b9 83       	std	Y+1, r27	; 0x01
    1016:	a8 83       	st	Y, r26
    1018:	13 96       	adiw	r26, 0x03	; 3
    101a:	dc 93       	st	X, r29
    101c:	ce 93       	st	-X, r28
    101e:	12 97       	sbiw	r26, 0x02	; 2
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    ump->m_owner = tp;
    1020:	fd 83       	std	Y+5, r31	; 0x05
    1022:	ec 83       	std	Y+4, r30	; 0x04
    ump->m_next = tp->p_mtxlist;
    1024:	85 8d       	ldd	r24, Z+29	; 0x1d
    1026:	96 8d       	ldd	r25, Z+30	; 0x1e
    1028:	9f 83       	std	Y+7, r25	; 0x07
    102a:	8e 83       	std	Y+6, r24	; 0x06
    tp->p_mtxlist = ump;
    102c:	d6 8f       	std	Z+30, r29	; 0x1e
    102e:	c5 8f       	std	Z+29, r28	; 0x1d
    chSchReadyI(tp);
    1030:	cf 01       	movw	r24, r30
    1032:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
  }
  else
    ump->m_owner = NULL;
  return ump;
}
    1036:	ce 01       	movw	r24, r28
    1038:	df 91       	pop	r29
    103a:	cf 91       	pop	r28
    103c:	08 95       	ret
    ump->m_next = tp->p_mtxlist;
    tp->p_mtxlist = ump;
    chSchReadyI(tp);
  }
  else
    ump->m_owner = NULL;
    103e:	1d 82       	std	Y+5, r1	; 0x05
    1040:	1c 82       	std	Y+4, r1	; 0x04
  return ump;
}
    1042:	ce 01       	movw	r24, r28
    1044:	df 91       	pop	r29
    1046:	cf 91       	pop	r28
    1048:	08 95       	ret

0000104a <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
    104a:	0f 93       	push	r16
    104c:	1f 93       	push	r17
    104e:	cf 93       	push	r28
    1050:	df 93       	push	r29
  Thread *ctp = currp;
    1052:	00 91 3c 0c 	lds	r16, 0x0C3C
    1056:	10 91 3d 0c 	lds	r17, 0x0C3D

  chSysLock();
    105a:	f8 94       	cli
  if (ctp->p_mtxlist != NULL) {
    105c:	d8 01       	movw	r26, r16
    105e:	5d 96       	adiw	r26, 0x1d	; 29
    1060:	ed 91       	ld	r30, X+
    1062:	fc 91       	ld	r31, X
    1064:	5e 97       	sbiw	r26, 0x1e	; 30
    1066:	30 97       	sbiw	r30, 0x00	; 0
    1068:	f9 f4       	brne	.+62     	; 0x10a8 <chMtxUnlockAll+0x5e>
    106a:	38 c0       	rjmp	.+112    	; 0x10dc <chMtxUnlockAll+0x92>
    106c:	8d 91       	ld	r24, X+
    106e:	9c 91       	ld	r25, X
    1070:	11 97       	sbiw	r26, 0x01	; 1
    1072:	91 83       	std	Z+1, r25	; 0x01
    1074:	80 83       	st	Z, r24
    1076:	ec 01       	movw	r28, r24
    1078:	fb 83       	std	Y+3, r31	; 0x03
    107a:	ea 83       	std	Y+2, r30	; 0x02
    do {
      Mutex *ump = ctp->p_mtxlist;
      ctp->p_mtxlist = ump->m_next;
      if (chMtxQueueNotEmptyS(ump)) {
        Thread *tp = fifo_remove(&ump->m_queue);
        ump->m_owner = tp;
    107c:	b5 83       	std	Z+5, r27	; 0x05
    107e:	a4 83       	std	Z+4, r26	; 0x04
        ump->m_next = tp->p_mtxlist;
    1080:	5d 96       	adiw	r26, 0x1d	; 29
    1082:	8d 91       	ld	r24, X+
    1084:	9c 91       	ld	r25, X
    1086:	5e 97       	sbiw	r26, 0x1e	; 30
    1088:	97 83       	std	Z+7, r25	; 0x07
    108a:	86 83       	std	Z+6, r24	; 0x06
        tp->p_mtxlist = ump;
    108c:	5e 96       	adiw	r26, 0x1e	; 30
    108e:	fc 93       	st	X, r31
    1090:	ee 93       	st	-X, r30
    1092:	5d 97       	sbiw	r26, 0x1d	; 29
        chSchReadyI(tp);
    1094:	cd 01       	movw	r24, r26
    1096:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
      }
      else
        ump->m_owner = NULL;
    } while (ctp->p_mtxlist != NULL);
    109a:	d8 01       	movw	r26, r16
    109c:	5d 96       	adiw	r26, 0x1d	; 29
    109e:	ed 91       	ld	r30, X+
    10a0:	fc 91       	ld	r31, X
    10a2:	5e 97       	sbiw	r26, 0x1e	; 30
    10a4:	30 97       	sbiw	r30, 0x00	; 0
    10a6:	99 f0       	breq	.+38     	; 0x10ce <chMtxUnlockAll+0x84>

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      Mutex *ump = ctp->p_mtxlist;
      ctp->p_mtxlist = ump->m_next;
    10a8:	86 81       	ldd	r24, Z+6	; 0x06
    10aa:	97 81       	ldd	r25, Z+7	; 0x07
    10ac:	e8 01       	movw	r28, r16
    10ae:	9e 8f       	std	Y+30, r25	; 0x1e
    10b0:	8d 8f       	std	Y+29, r24	; 0x1d
      if (chMtxQueueNotEmptyS(ump)) {
    10b2:	a0 81       	ld	r26, Z
    10b4:	b1 81       	ldd	r27, Z+1	; 0x01
    10b6:	ae 17       	cp	r26, r30
    10b8:	bf 07       	cpc	r27, r31
    10ba:	c1 f6       	brne	.-80     	; 0x106c <chMtxUnlockAll+0x22>
        ump->m_next = tp->p_mtxlist;
        tp->p_mtxlist = ump;
        chSchReadyI(tp);
      }
      else
        ump->m_owner = NULL;
    10bc:	15 82       	std	Z+5, r1	; 0x05
    10be:	14 82       	std	Z+4, r1	; 0x04
    } while (ctp->p_mtxlist != NULL);
    10c0:	d8 01       	movw	r26, r16
    10c2:	5d 96       	adiw	r26, 0x1d	; 29
    10c4:	ed 91       	ld	r30, X+
    10c6:	fc 91       	ld	r31, X
    10c8:	5e 97       	sbiw	r26, 0x1e	; 30
    10ca:	30 97       	sbiw	r30, 0x00	; 0
    10cc:	69 f7       	brne	.-38     	; 0x10a8 <chMtxUnlockAll+0x5e>
    ctp->p_prio = ctp->p_realprio;
    10ce:	5f 96       	adiw	r26, 0x1f	; 31
    10d0:	8c 91       	ld	r24, X
    10d2:	5f 97       	sbiw	r26, 0x1f	; 31
    10d4:	14 96       	adiw	r26, 0x04	; 4
    10d6:	8c 93       	st	X, r24
    chSchRescheduleS();
    10d8:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  }
  chSysUnlock();
    10dc:	78 94       	sei
}
    10de:	df 91       	pop	r29
    10e0:	cf 91       	pop	r28
    10e2:	1f 91       	pop	r17
    10e4:	0f 91       	pop	r16
    10e6:	08 95       	ret

000010e8 <chCondInit>:
 *
 * @param[out] cp       pointer to a @p CondVar structure
 *
 * @init
 */
void chCondInit(CondVar *cp) {
    10e8:	fc 01       	movw	r30, r24

  chDbgCheck(cp != NULL, "chCondInit");

  queue_init(&cp->c_queue);
    10ea:	82 83       	std	Z+2, r24	; 0x02
    10ec:	f3 83       	std	Z+3, r31	; 0x03
    10ee:	80 83       	st	Z, r24
    10f0:	f1 83       	std	Z+1, r31	; 0x01
    10f2:	08 95       	ret

000010f4 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @api
 */
void chCondSignal(CondVar *cp) {
    10f4:	cf 93       	push	r28
    10f6:	df 93       	push	r29
    10f8:	fc 01       	movw	r30, r24

  chDbgCheck(cp != NULL, "chCondSignal");

  chSysLock();
    10fa:	f8 94       	cli
  if (notempty(&cp->c_queue))
    10fc:	80 81       	ld	r24, Z
    10fe:	91 81       	ldd	r25, Z+1	; 0x01
    1100:	8e 17       	cp	r24, r30
    1102:	9f 07       	cpc	r25, r31
    1104:	69 f0       	breq	.+26     	; 0x1120 <chCondSignal+0x2c>
    1106:	ec 01       	movw	r28, r24
    1108:	a8 81       	ld	r26, Y
    110a:	b9 81       	ldd	r27, Y+1	; 0x01
    110c:	b1 83       	std	Z+1, r27	; 0x01
    110e:	a0 83       	st	Z, r26
    1110:	13 96       	adiw	r26, 0x03	; 3
    1112:	fc 93       	st	X, r31
    1114:	ee 93       	st	-X, r30
    1116:	12 97       	sbiw	r26, 0x02	; 2
    chSchWakeupS(fifo_remove(&cp->c_queue), RDY_OK);
    1118:	60 e0       	ldi	r22, 0x00	; 0
    111a:	70 e0       	ldi	r23, 0x00	; 0
    111c:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
  chSysUnlock();
    1120:	78 94       	sei
}
    1122:	df 91       	pop	r29
    1124:	cf 91       	pop	r28
    1126:	08 95       	ret

00001128 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @iclass
 */
void chCondSignalI(CondVar *cp) {
    1128:	cf 93       	push	r28
    112a:	df 93       	push	r29
    112c:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(cp != NULL, "chCondSignalI");

  if (notempty(&cp->c_queue))
    112e:	80 81       	ld	r24, Z
    1130:	91 81       	ldd	r25, Z+1	; 0x01
    1132:	8e 17       	cp	r24, r30
    1134:	9f 07       	cpc	r25, r31
    1136:	71 f0       	breq	.+28     	; 0x1154 <chCondSignalI+0x2c>
    1138:	ec 01       	movw	r28, r24
    113a:	a8 81       	ld	r26, Y
    113c:	b9 81       	ldd	r27, Y+1	; 0x01
    113e:	b1 83       	std	Z+1, r27	; 0x01
    1140:	a0 83       	st	Z, r26
    1142:	13 96       	adiw	r26, 0x03	; 3
    1144:	fc 93       	st	X, r31
    1146:	ee 93       	st	-X, r30
    1148:	12 97       	sbiw	r26, 0x02	; 2
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_OK;
    114a:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
    114e:	fc 01       	movw	r30, r24
    1150:	13 8a       	std	Z+19, r1	; 0x13
    1152:	12 8a       	std	Z+18, r1	; 0x12
}
    1154:	df 91       	pop	r29
    1156:	cf 91       	pop	r28
    1158:	08 95       	ret

0000115a <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @iclass
 */
void chCondBroadcastI(CondVar *cp) {
    115a:	0f 93       	push	r16
    115c:	1f 93       	push	r17
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
    1162:	ec 01       	movw	r28, r24
  chDbgCheck(cp != NULL, "chCondBroadcastI");

  /* Empties the condition variable queue and inserts all the Threads into the
     ready list in FIFO order. The wakeup message is set to @p RDY_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (cp->c_queue.p_next != (void *)&cp->c_queue)
    1164:	88 81       	ld	r24, Y
    1166:	99 81       	ldd	r25, Y+1	; 0x01
    1168:	8c 17       	cp	r24, r28
    116a:	9d 07       	cpc	r25, r29
    116c:	99 f0       	breq	.+38     	; 0x1194 <chCondBroadcastI+0x3a>
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_RESET;
    116e:	0e ef       	ldi	r16, 0xFE	; 254
    1170:	1f ef       	ldi	r17, 0xFF	; 255
    1172:	dc 01       	movw	r26, r24
    1174:	ed 91       	ld	r30, X+
    1176:	fc 91       	ld	r31, X
    1178:	f9 83       	std	Y+1, r31	; 0x01
    117a:	e8 83       	st	Y, r30
    117c:	d3 83       	std	Z+3, r29	; 0x03
    117e:	c2 83       	std	Z+2, r28	; 0x02
    1180:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
    1184:	fc 01       	movw	r30, r24
    1186:	13 8b       	std	Z+19, r17	; 0x13
    1188:	02 8b       	std	Z+18, r16	; 0x12
  chDbgCheck(cp != NULL, "chCondBroadcastI");

  /* Empties the condition variable queue and inserts all the Threads into the
     ready list in FIFO order. The wakeup message is set to @p RDY_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (cp->c_queue.p_next != (void *)&cp->c_queue)
    118a:	88 81       	ld	r24, Y
    118c:	99 81       	ldd	r25, Y+1	; 0x01
    118e:	8c 17       	cp	r24, r28
    1190:	9d 07       	cpc	r25, r29
    1192:	79 f7       	brne	.-34     	; 0x1172 <chCondBroadcastI+0x18>
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_RESET;
}
    1194:	df 91       	pop	r29
    1196:	cf 91       	pop	r28
    1198:	1f 91       	pop	r17
    119a:	0f 91       	pop	r16
    119c:	08 95       	ret

0000119e <chCondBroadcast>:
 *
 * @api
 */
void chCondBroadcast(CondVar *cp) {

  chSysLock();
    119e:	f8 94       	cli
  chCondBroadcastI(cp);
    11a0:	0e 94 ad 08 	call	0x115a	; 0x115a <chCondBroadcastI>
  chSchRescheduleS();
    11a4:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  chSysUnlock();
    11a8:	78 94       	sei
    11aa:	08 95       	ret

000011ac <chCondWaitS>:
 * @retval RDY_RESET    if the condvar has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(CondVar *cp) {
    11ac:	ef 92       	push	r14
    11ae:	ff 92       	push	r15
    11b0:	0f 93       	push	r16
    11b2:	1f 93       	push	r17
    11b4:	cf 93       	push	r28
    11b6:	df 93       	push	r29
    11b8:	7c 01       	movw	r14, r24
  Thread *ctp = currp;
    11ba:	c0 91 3c 0c 	lds	r28, 0x0C3C
    11be:	d0 91 3d 0c 	lds	r29, 0x0C3D
  chDbgCheck(cp != NULL, "chCondWaitS");
  chDbgAssert(ctp->p_mtxlist != NULL,
              "chCondWaitS(), #1",
              "not owning a mutex");

  mp = chMtxUnlockS();
    11c2:	0e 94 db 07 	call	0xfb6	; 0xfb6 <chMtxUnlockS>
    11c6:	8c 01       	movw	r16, r24
  ctp->p_u.wtobjp = cp;
    11c8:	ea 8a       	std	Y+18, r14	; 0x12
    11ca:	fb 8a       	std	Y+19, r15	; 0x13
  prio_insert(ctp, &cp->c_queue);
    11cc:	d7 01       	movw	r26, r14
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
    11ce:	f7 01       	movw	r30, r14
    11d0:	04 c0       	rjmp	.+8      	; 0x11da <chCondWaitS+0x2e>
  do {
    cp = cp->p_next;
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    11d2:	94 81       	ldd	r25, Z+4	; 0x04
    11d4:	8c 81       	ldd	r24, Y+4	; 0x04
    11d6:	98 17       	cp	r25, r24
    11d8:	28 f1       	brcs	.+74     	; 0x1224 <chCondWaitS+0x78>
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
    11da:	01 90       	ld	r0, Z+
    11dc:	f0 81       	ld	r31, Z
    11de:	e0 2d       	mov	r30, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    11e0:	ae 17       	cp	r26, r30
    11e2:	bf 07       	cpc	r27, r31
    11e4:	b1 f7       	brne	.-20     	; 0x11d2 <chCondWaitS+0x26>
  tp->p_next = cp;
    11e6:	b9 83       	std	Y+1, r27	; 0x01
    11e8:	a8 83       	st	Y, r26
  tp->p_prev = cp->p_prev;
    11ea:	12 96       	adiw	r26, 0x02	; 2
    11ec:	ed 91       	ld	r30, X+
    11ee:	fc 91       	ld	r31, X
    11f0:	13 97       	sbiw	r26, 0x03	; 3
    11f2:	fb 83       	std	Y+3, r31	; 0x03
    11f4:	ea 83       	std	Y+2, r30	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
    11f6:	13 96       	adiw	r26, 0x03	; 3
    11f8:	dc 93       	st	X, r29
    11fa:	ce 93       	st	-X, r28
    11fc:	12 97       	sbiw	r26, 0x02	; 2
    11fe:	d1 83       	std	Z+1, r29	; 0x01
    1200:	c0 83       	st	Z, r28
  chSchGoSleepS(THD_STATE_WTCOND);
    1202:	85 e0       	ldi	r24, 0x05	; 5
    1204:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
    1208:	fa 88       	ldd	r15, Y+18	; 0x12
    120a:	cb 89       	ldd	r28, Y+19	; 0x13
  chMtxLockS(mp);
    120c:	c8 01       	movw	r24, r16
    120e:	0e 94 8e 06 	call	0xd1c	; 0xd1c <chMtxLockS>
  return msg;
}
    1212:	8f 2d       	mov	r24, r15
    1214:	9c 2f       	mov	r25, r28
    1216:	df 91       	pop	r29
    1218:	cf 91       	pop	r28
    121a:	1f 91       	pop	r17
    121c:	0f 91       	pop	r16
    121e:	ff 90       	pop	r15
    1220:	ef 90       	pop	r14
    1222:	08 95       	ret
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    1224:	df 01       	movw	r26, r30
    1226:	df cf       	rjmp	.-66     	; 0x11e6 <chCondWaitS+0x3a>

00001228 <chCondWait>:
 * @api
 */
msg_t chCondWait(CondVar *cp) {
  msg_t msg;

  chSysLock();
    1228:	f8 94       	cli
  msg = chCondWaitS(cp);
    122a:	0e 94 d6 08 	call	0x11ac	; 0x11ac <chCondWaitS>
  chSysUnlock();
    122e:	78 94       	sei
  return msg;
}
    1230:	08 95       	ret

00001232 <chCondWaitTimeoutS>:
 * @retval RDY_TIMEOUT  if the condvar has not been signaled within the
 *                      specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(CondVar *cp, systime_t time) {
    1232:	ef 92       	push	r14
    1234:	ff 92       	push	r15
    1236:	0f 93       	push	r16
    1238:	1f 93       	push	r17
    123a:	cf 93       	push	r28
    123c:	df 93       	push	r29
    123e:	00 d0       	rcall	.+0      	; 0x1240 <chCondWaitTimeoutS+0xe>
    1240:	cd b7       	in	r28, 0x3d	; 61
    1242:	de b7       	in	r29, 0x3e	; 62
    1244:	7c 01       	movw	r14, r24
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE), "chCondWaitTimeoutS");
  chDbgAssert(currp->p_mtxlist != NULL,
              "chCondWaitTimeoutS(), #1",
              "not owning a mutex");

  mp = chMtxUnlockS();
    1246:	69 83       	std	Y+1, r22	; 0x01
    1248:	7a 83       	std	Y+2, r23	; 0x02
    124a:	0e 94 db 07 	call	0xfb6	; 0xfb6 <chMtxUnlockS>
    124e:	8c 01       	movw	r16, r24
  currp->p_u.wtobjp = cp;
    1250:	40 91 3c 0c 	lds	r20, 0x0C3C
    1254:	50 91 3d 0c 	lds	r21, 0x0C3D
    1258:	da 01       	movw	r26, r20
    125a:	52 96       	adiw	r26, 0x12	; 18
    125c:	ec 92       	st	X, r14
    125e:	52 97       	sbiw	r26, 0x12	; 18
    1260:	53 96       	adiw	r26, 0x13	; 19
    1262:	fc 92       	st	X, r15
  prio_insert(currp, &cp->c_queue);
    1264:	97 01       	movw	r18, r14
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
    1266:	f7 01       	movw	r30, r14
    1268:	7a 81       	ldd	r23, Y+2	; 0x02
    126a:	69 81       	ldd	r22, Y+1	; 0x01
  do {
    cp = cp->p_next;
    126c:	01 90       	ld	r0, Z+
    126e:	f0 81       	ld	r31, Z
    1270:	e0 2d       	mov	r30, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    1272:	2e 17       	cp	r18, r30
    1274:	3f 07       	cpc	r19, r31
    1276:	31 f0       	breq	.+12     	; 0x1284 <chCondWaitTimeoutS+0x52>
    1278:	94 81       	ldd	r25, Z+4	; 0x04
    127a:	da 01       	movw	r26, r20
    127c:	14 96       	adiw	r26, 0x04	; 4
    127e:	8c 91       	ld	r24, X
    1280:	98 17       	cp	r25, r24
    1282:	a0 f7       	brcc	.-24     	; 0x126c <chCondWaitTimeoutS+0x3a>
  tp->p_next = cp;
    1284:	da 01       	movw	r26, r20
    1286:	11 96       	adiw	r26, 0x01	; 1
    1288:	fc 93       	st	X, r31
    128a:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
    128c:	82 81       	ldd	r24, Z+2	; 0x02
    128e:	93 81       	ldd	r25, Z+3	; 0x03
    1290:	13 96       	adiw	r26, 0x03	; 3
    1292:	9c 93       	st	X, r25
    1294:	8e 93       	st	-X, r24
    1296:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
    1298:	53 83       	std	Z+3, r21	; 0x03
    129a:	42 83       	std	Z+2, r20	; 0x02
    129c:	fc 01       	movw	r30, r24
    129e:	51 83       	std	Z+1, r21	; 0x01
    12a0:	40 83       	st	Z, r20
  msg = chSchGoSleepTimeoutS(THD_STATE_WTCOND, time);
    12a2:	85 e0       	ldi	r24, 0x05	; 5
    12a4:	0e 94 bb 02 	call	0x576	; 0x576 <chSchGoSleepTimeoutS>
    12a8:	7c 01       	movw	r14, r24
  if (msg != RDY_TIMEOUT)
    12aa:	8f 3f       	cpi	r24, 0xFF	; 255
    12ac:	ff ef       	ldi	r31, 0xFF	; 255
    12ae:	9f 07       	cpc	r25, r31
    12b0:	19 f0       	breq	.+6      	; 0x12b8 <chCondWaitTimeoutS+0x86>
    chMtxLockS(mp);
    12b2:	c8 01       	movw	r24, r16
    12b4:	0e 94 8e 06 	call	0xd1c	; 0xd1c <chMtxLockS>
  return msg;
}
    12b8:	c7 01       	movw	r24, r14
    12ba:	0f 90       	pop	r0
    12bc:	0f 90       	pop	r0
    12be:	df 91       	pop	r29
    12c0:	cf 91       	pop	r28
    12c2:	1f 91       	pop	r17
    12c4:	0f 91       	pop	r16
    12c6:	ff 90       	pop	r15
    12c8:	ef 90       	pop	r14
    12ca:	08 95       	ret

000012cc <chCondWaitTimeout>:
 * @api
 */
msg_t chCondWaitTimeout(CondVar *cp, systime_t time) {
  msg_t msg;

  chSysLock();
    12cc:	f8 94       	cli
  msg = chCondWaitTimeoutS(cp, time);
    12ce:	0e 94 19 09 	call	0x1232	; 0x1232 <chCondWaitTimeoutS>
  chSysUnlock();
    12d2:	78 94       	sei
  return msg;
}
    12d4:	08 95       	ret

000012d6 <chEvtRegisterMask>:
 * @param[in] mask      the mask of event flags to be ORed to the thread when
 *                      the event source is broadcasted
 *
 * @api
 */
void chEvtRegisterMask(EventSource *esp, EventListener *elp, eventmask_t mask) {
    12d6:	fb 01       	movw	r30, r22

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtRegisterMask");

  chSysLock();
    12d8:	f8 94       	cli
  elp->el_next     = esp->es_next;
    12da:	dc 01       	movw	r26, r24
    12dc:	2d 91       	ld	r18, X+
    12de:	3c 91       	ld	r19, X
    12e0:	11 97       	sbiw	r26, 0x01	; 1
    12e2:	31 83       	std	Z+1, r19	; 0x01
    12e4:	20 83       	st	Z, r18
  esp->es_next     = elp;
    12e6:	6d 93       	st	X+, r22
    12e8:	7c 93       	st	X, r23
  elp->el_listener = currp;
    12ea:	80 91 3c 0c 	lds	r24, 0x0C3C
    12ee:	90 91 3d 0c 	lds	r25, 0x0C3D
    12f2:	93 83       	std	Z+3, r25	; 0x03
    12f4:	82 83       	std	Z+2, r24	; 0x02
  elp->el_mask     = mask;
    12f6:	44 83       	std	Z+4, r20	; 0x04
  elp->el_flags    = 0;
    12f8:	15 82       	std	Z+5, r1	; 0x05
  chSysUnlock();
    12fa:	78 94       	sei
    12fc:	08 95       	ret

000012fe <chEvtUnregister>:
  EventListener *p;

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
  chSysLock();
    12fe:	f8 94       	cli
void chEvtUnregister(EventSource *esp, EventListener *elp) {
  EventListener *p;

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
    1300:	fc 01       	movw	r30, r24
  chSysLock();
  while (p->el_next != (EventListener *)esp) {
    1302:	01 c0       	rjmp	.+2      	; 0x1306 <chEvtUnregister+0x8>
    if (p->el_next == elp) {
    1304:	f9 01       	movw	r30, r18

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
  chSysLock();
  while (p->el_next != (EventListener *)esp) {
    1306:	20 81       	ld	r18, Z
    1308:	31 81       	ldd	r19, Z+1	; 0x01
    130a:	28 17       	cp	r18, r24
    130c:	39 07       	cpc	r19, r25
    130e:	41 f0       	breq	.+16     	; 0x1320 <chEvtUnregister+0x22>
    if (p->el_next == elp) {
    1310:	62 17       	cp	r22, r18
    1312:	73 07       	cpc	r23, r19
    1314:	b9 f7       	brne	.-18     	; 0x1304 <chEvtUnregister+0x6>
      p->el_next = elp->el_next;
    1316:	db 01       	movw	r26, r22
    1318:	8d 91       	ld	r24, X+
    131a:	9c 91       	ld	r25, X
    131c:	91 83       	std	Z+1, r25	; 0x01
    131e:	80 83       	st	Z, r24
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
    1320:	78 94       	sei
    1322:	08 95       	ret

00001324 <chEvtGetAndClearEvents>:
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t mask) {
  eventmask_t m;

  chSysLock();
    1324:	f8 94       	cli

  m = currp->p_epending & mask;
    1326:	e0 91 3c 0c 	lds	r30, 0x0C3C
    132a:	f0 91 3d 0c 	lds	r31, 0x0C3D
    132e:	24 8d       	ldd	r18, Z+28	; 0x1c
  currp->p_epending &= ~mask;
    1330:	98 2f       	mov	r25, r24
    1332:	90 95       	com	r25
    1334:	92 23       	and	r25, r18
    1336:	94 8f       	std	Z+28, r25	; 0x1c

  chSysUnlock();
    1338:	78 94       	sei
  return m;
}
    133a:	82 23       	and	r24, r18
    133c:	08 95       	ret

0000133e <chEvtAddEvents>:
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t mask) {

  chSysLock();
    133e:	f8 94       	cli

  mask = (currp->p_epending |= mask);
    1340:	e0 91 3c 0c 	lds	r30, 0x0C3C
    1344:	f0 91 3d 0c 	lds	r31, 0x0C3D
    1348:	94 8d       	ldd	r25, Z+28	; 0x1c
    134a:	89 2b       	or	r24, r25
    134c:	84 8f       	std	Z+28, r24	; 0x1c

  chSysUnlock();
    134e:	78 94       	sei
  return mask;
}
    1350:	08 95       	ret

00001352 <chEvtGetAndClearFlags>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
flagsmask_t chEvtGetAndClearFlags(EventListener *elp) {
    1352:	fc 01       	movw	r30, r24
  flagsmask_t flags;

  chSysLock();
    1354:	f8 94       	cli

  flags = elp->el_flags;
    1356:	85 81       	ldd	r24, Z+5	; 0x05
  elp->el_flags = 0;
    1358:	15 82       	std	Z+5, r1	; 0x05

  chSysUnlock();
    135a:	78 94       	sei
  return flags;
}
    135c:	08 95       	ret

0000135e <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(Thread *tp, eventmask_t mask) {
    135e:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
    1360:	84 8d       	ldd	r24, Z+28	; 0x1c
    1362:	68 2b       	or	r22, r24
    1364:	64 8f       	std	Z+28, r22	; 0x1c
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
    1366:	85 85       	ldd	r24, Z+13	; 0x0d
    1368:	88 30       	cpi	r24, 0x08	; 8
    136a:	71 f0       	breq	.+28     	; 0x1388 <chEvtSignalI+0x2a>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
    136c:	89 30       	cpi	r24, 0x09	; 9
    136e:	09 f0       	breq	.+2      	; 0x1372 <chEvtSignalI+0x14>
    1370:	08 95       	ret
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    1372:	82 89       	ldd	r24, Z+18	; 0x12
    1374:	68 23       	and	r22, r24

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
    1376:	86 13       	cpse	r24, r22
    1378:	fb cf       	rjmp	.-10     	; 0x1370 <chEvtSignalI+0x12>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
    137a:	cf 01       	movw	r24, r30
    137c:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
    1380:	fc 01       	movw	r30, r24
    1382:	13 8a       	std	Z+19, r1	; 0x13
    1384:	12 8a       	std	Z+18, r1	; 0x12
    1386:	08 95       	ret
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
    1388:	82 89       	ldd	r24, Z+18	; 0x12
    138a:	86 23       	and	r24, r22
  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
    138c:	b1 f7       	brne	.-20     	; 0x137a <chEvtSignalI+0x1c>
    138e:	08 95       	ret

00001390 <chEvtSignal>:
 */
void chEvtSignal(Thread *tp, eventmask_t mask) {

  chDbgCheck(tp != NULL, "chEvtSignal");

  chSysLock();
    1390:	f8 94       	cli
  chEvtSignalI(tp, mask);
    1392:	0e 94 af 09 	call	0x135e	; 0x135e <chEvtSignalI>
  chSchRescheduleS();
    1396:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  chSysUnlock();
    139a:	78 94       	sei
    139c:	08 95       	ret

0000139e <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p EventSource structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(EventSource *esp, flagsmask_t flags) {
    139e:	ff 92       	push	r15
    13a0:	0f 93       	push	r16
    13a2:	1f 93       	push	r17
    13a4:	cf 93       	push	r28
    13a6:	df 93       	push	r29
    13a8:	8c 01       	movw	r16, r24
    13aa:	f6 2e       	mov	r15, r22
  EventListener *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
    13ac:	fc 01       	movw	r30, r24
    13ae:	c0 81       	ld	r28, Z
    13b0:	d1 81       	ldd	r29, Z+1	; 0x01
  while (elp != (EventListener *)esp) {
    13b2:	8c 17       	cp	r24, r28
    13b4:	9d 07       	cpc	r25, r29
    13b6:	71 f0       	breq	.+28     	; 0x13d4 <chEvtBroadcastFlagsI+0x36>
    elp->el_flags |= flags;
    13b8:	8d 81       	ldd	r24, Y+5	; 0x05
    13ba:	8f 29       	or	r24, r15
    13bc:	8d 83       	std	Y+5, r24	; 0x05
    chEvtSignalI(elp->el_listener, elp->el_mask);
    13be:	6c 81       	ldd	r22, Y+4	; 0x04
    13c0:	8a 81       	ldd	r24, Y+2	; 0x02
    13c2:	9b 81       	ldd	r25, Y+3	; 0x03
    13c4:	0e 94 af 09 	call	0x135e	; 0x135e <chEvtSignalI>
    elp = elp->el_next;
    13c8:	09 90       	ld	r0, Y+
    13ca:	d8 81       	ld	r29, Y
    13cc:	c0 2d       	mov	r28, r0

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
  while (elp != (EventListener *)esp) {
    13ce:	0c 17       	cp	r16, r28
    13d0:	1d 07       	cpc	r17, r29
    13d2:	91 f7       	brne	.-28     	; 0x13b8 <chEvtBroadcastFlagsI+0x1a>
    elp->el_flags |= flags;
    chEvtSignalI(elp->el_listener, elp->el_mask);
    elp = elp->el_next;
  }
}
    13d4:	df 91       	pop	r29
    13d6:	cf 91       	pop	r28
    13d8:	1f 91       	pop	r17
    13da:	0f 91       	pop	r16
    13dc:	ff 90       	pop	r15
    13de:	08 95       	ret

000013e0 <chEvtBroadcastFlags>:
 *
 * @api
 */
void chEvtBroadcastFlags(EventSource *esp, flagsmask_t flags) {

  chSysLock();
    13e0:	f8 94       	cli
  chEvtBroadcastFlagsI(esp, flags);
    13e2:	0e 94 cf 09 	call	0x139e	; 0x139e <chEvtBroadcastFlagsI>
  chSchRescheduleS();
    13e6:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  chSysUnlock();
    13ea:	78 94       	sei
    13ec:	08 95       	ret

000013ee <chEvtGetAndClearFlagsI>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
flagsmask_t chEvtGetAndClearFlagsI(EventListener *elp) {
    13ee:	fc 01       	movw	r30, r24
  flagsmask_t flags;

  flags = elp->el_flags;
    13f0:	85 81       	ldd	r24, Z+5	; 0x05
  elp->el_flags = 0;
    13f2:	15 82       	std	Z+5, r1	; 0x05

  return flags;
}
    13f4:	08 95       	ret

000013f6 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t mask) {
    13f6:	ef 92       	push	r14
    13f8:	ff 92       	push	r15
    13fa:	0f 93       	push	r16
    13fc:	1f 93       	push	r17
    13fe:	cf 93       	push	r28
    1400:	df 93       	push	r29
    1402:	8c 01       	movw	r16, r24
    1404:	e6 2e       	mov	r14, r22
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    1406:	66 23       	and	r22, r22
    1408:	01 f1       	breq	.+64     	; 0x144a <chEvtDispatch+0x54>
    140a:	f1 2c       	mov	r15, r1
    if (mask & EVENT_MASK(eid)) {
    140c:	c1 e0       	ldi	r28, 0x01	; 1
    140e:	d0 e0       	ldi	r29, 0x00	; 0
    1410:	03 c0       	rjmp	.+6      	; 0x1418 <chEvtDispatch+0x22>
                  "chEvtDispatch(), #1",
                  "null handler");
      mask &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
    1412:	f3 94       	inc	r15
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    1414:	ee 20       	and	r14, r14
    1416:	c9 f0       	breq	.+50     	; 0x144a <chEvtDispatch+0x54>
    if (mask & EVENT_MASK(eid)) {
    1418:	9e 01       	movw	r18, r28
    141a:	0f 2c       	mov	r0, r15
    141c:	01 c0       	rjmp	.+2      	; 0x1420 <chEvtDispatch+0x2a>
    141e:	22 0f       	add	r18, r18
    1420:	0a 94       	dec	r0
    1422:	ea f7       	brpl	.-6      	; 0x141e <chEvtDispatch+0x28>
    1424:	8e 2d       	mov	r24, r14
    1426:	82 23       	and	r24, r18
    1428:	a1 f3       	breq	.-24     	; 0x1412 <chEvtDispatch+0x1c>
      chDbgAssert(handlers[eid] != NULL,
                  "chEvtDispatch(), #1",
                  "null handler");
      mask &= ~EVENT_MASK(eid);
    142a:	20 95       	com	r18
    142c:	e2 22       	and	r14, r18
      handlers[eid](eid);
    142e:	ef 2d       	mov	r30, r15
    1430:	f0 e0       	ldi	r31, 0x00	; 0
    1432:	ee 0f       	add	r30, r30
    1434:	ff 1f       	adc	r31, r31
    1436:	e0 0f       	add	r30, r16
    1438:	f1 1f       	adc	r31, r17
    143a:	01 90       	ld	r0, Z+
    143c:	f0 81       	ld	r31, Z
    143e:	e0 2d       	mov	r30, r0
    1440:	8f 2d       	mov	r24, r15
    1442:	09 95       	icall
    }
    eid++;
    1444:	f3 94       	inc	r15
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    1446:	e1 10       	cpse	r14, r1
    1448:	e7 cf       	rjmp	.-50     	; 0x1418 <chEvtDispatch+0x22>
      mask &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
    144a:	df 91       	pop	r29
    144c:	cf 91       	pop	r28
    144e:	1f 91       	pop	r17
    1450:	0f 91       	pop	r16
    1452:	ff 90       	pop	r15
    1454:	ef 90       	pop	r14
    1456:	08 95       	ret

00001458 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest id served and cleared event.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t mask) {
    1458:	1f 93       	push	r17
    145a:	cf 93       	push	r28
    145c:	df 93       	push	r29
    145e:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    1460:	c0 91 3c 0c 	lds	r28, 0x0C3C
    1464:	d0 91 3d 0c 	lds	r29, 0x0C3D
  eventmask_t m;

  chSysLock();
    1468:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    146a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    146c:	98 2f       	mov	r25, r24
    146e:	92 23       	and	r25, r18
    1470:	39 f4       	brne	.+14     	; 0x1480 <chEvtWaitOne+0x28>
    ctp->p_u.ewmask = mask;
    1472:	8a 8b       	std	Y+18, r24	; 0x12
    chSchGoSleepS(THD_STATE_WTOREVT);
    1474:	88 e0       	ldi	r24, 0x08	; 8
    1476:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
    m = ctp->p_epending & mask;
    147a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    147c:	91 2f       	mov	r25, r17
    147e:	92 23       	and	r25, r18
  }
  m &= -m;
    1480:	89 2f       	mov	r24, r25
    1482:	81 95       	neg	r24
    1484:	89 23       	and	r24, r25
  ctp->p_epending &= ~m;
    1486:	98 2f       	mov	r25, r24
    1488:	90 95       	com	r25
    148a:	92 23       	and	r25, r18
    148c:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    148e:	78 94       	sei
  return m;
}
    1490:	df 91       	pop	r29
    1492:	cf 91       	pop	r28
    1494:	1f 91       	pop	r17
    1496:	08 95       	ret

00001498 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
    1498:	1f 93       	push	r17
    149a:	cf 93       	push	r28
    149c:	df 93       	push	r29
    149e:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    14a0:	c0 91 3c 0c 	lds	r28, 0x0C3C
    14a4:	d0 91 3d 0c 	lds	r29, 0x0C3D
  eventmask_t m;

  chSysLock();
    14a8:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    14aa:	2c 8d       	ldd	r18, Y+28	; 0x1c
    14ac:	82 23       	and	r24, r18
    14ae:	39 f4       	brne	.+14     	; 0x14be <chEvtWaitAny+0x26>
    ctp->p_u.ewmask = mask;
    14b0:	1a 8b       	std	Y+18, r17	; 0x12
    chSchGoSleepS(THD_STATE_WTOREVT);
    14b2:	88 e0       	ldi	r24, 0x08	; 8
    14b4:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
    m = ctp->p_epending & mask;
    14b8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    14ba:	81 2f       	mov	r24, r17
    14bc:	82 23       	and	r24, r18
  }
  ctp->p_epending &= ~m;
    14be:	98 2f       	mov	r25, r24
    14c0:	90 95       	com	r25
    14c2:	92 23       	and	r25, r18
    14c4:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    14c6:	78 94       	sei
  return m;
}
    14c8:	df 91       	pop	r29
    14ca:	cf 91       	pop	r28
    14cc:	1f 91       	pop	r17
    14ce:	08 95       	ret

000014d0 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t mask) {
    14d0:	1f 93       	push	r17
    14d2:	cf 93       	push	r28
    14d4:	df 93       	push	r29
    14d6:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    14d8:	c0 91 3c 0c 	lds	r28, 0x0C3C
    14dc:	d0 91 3d 0c 	lds	r29, 0x0C3D

  chSysLock();
    14e0:	f8 94       	cli

  if ((ctp->p_epending & mask) != mask) {
    14e2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    14e4:	89 23       	and	r24, r25
    14e6:	81 17       	cp	r24, r17
    14e8:	29 f0       	breq	.+10     	; 0x14f4 <chEvtWaitAll+0x24>
    ctp->p_u.ewmask = mask;
    14ea:	1a 8b       	std	Y+18, r17	; 0x12
    chSchGoSleepS(THD_STATE_WTANDEVT);
    14ec:	89 e0       	ldi	r24, 0x09	; 9
    14ee:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
    14f2:	9c 8d       	ldd	r25, Y+28	; 0x1c
  }
  ctp->p_epending &= ~mask;
    14f4:	81 2f       	mov	r24, r17
    14f6:	80 95       	com	r24
    14f8:	89 23       	and	r24, r25
    14fa:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    14fc:	78 94       	sei
  return mask;
}
    14fe:	81 2f       	mov	r24, r17
    1500:	df 91       	pop	r29
    1502:	cf 91       	pop	r28
    1504:	1f 91       	pop	r17
    1506:	08 95       	ret

00001508 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest id served and cleared event.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t mask, systime_t time) {
    1508:	0f 93       	push	r16
    150a:	1f 93       	push	r17
    150c:	cf 93       	push	r28
    150e:	df 93       	push	r29
    1510:	08 2f       	mov	r16, r24
  Thread *ctp = currp;
    1512:	c0 91 3c 0c 	lds	r28, 0x0C3C
    1516:	d0 91 3d 0c 	lds	r29, 0x0C3D
  eventmask_t m;

  chSysLock();
    151a:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    151c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    151e:	18 2f       	mov	r17, r24
    1520:	19 23       	and	r17, r25
    1522:	99 f4       	brne	.+38     	; 0x154a <chEvtWaitOneTimeout+0x42>
    if (TIME_IMMEDIATE == time) {
    1524:	61 15       	cp	r22, r1
    1526:	71 05       	cpc	r23, r1
    1528:	39 f4       	brne	.+14     	; 0x1538 <chEvtWaitOneTimeout+0x30>
    m = ctp->p_epending & mask;
  }
  m &= -m;
  ctp->p_epending &= ~m;

  chSysUnlock();
    152a:	78 94       	sei
  return m;
}
    152c:	81 2f       	mov	r24, r17
    152e:	df 91       	pop	r29
    1530:	cf 91       	pop	r28
    1532:	1f 91       	pop	r17
    1534:	0f 91       	pop	r16
    1536:	08 95       	ret
  if ((m = (ctp->p_epending & mask)) == 0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    1538:	8a 8b       	std	Y+18, r24	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
    153a:	88 e0       	ldi	r24, 0x08	; 8
    153c:	0e 94 bb 02 	call	0x576	; 0x576 <chSchGoSleepTimeoutS>
    1540:	97 fd       	sbrc	r25, 7
    1542:	f3 cf       	rjmp	.-26     	; 0x152a <chEvtWaitOneTimeout+0x22>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & mask;
    1544:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1546:	10 2f       	mov	r17, r16
    1548:	19 23       	and	r17, r25
  }
  m &= -m;
    154a:	81 2f       	mov	r24, r17
    154c:	81 95       	neg	r24
    154e:	18 23       	and	r17, r24
  ctp->p_epending &= ~m;
    1550:	81 2f       	mov	r24, r17
    1552:	80 95       	com	r24
    1554:	89 23       	and	r24, r25
    1556:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    1558:	78 94       	sei
  return m;
}
    155a:	81 2f       	mov	r24, r17
    155c:	df 91       	pop	r29
    155e:	cf 91       	pop	r28
    1560:	1f 91       	pop	r17
    1562:	0f 91       	pop	r16
    1564:	08 95       	ret

00001566 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t time) {
    1566:	0f 93       	push	r16
    1568:	1f 93       	push	r17
    156a:	cf 93       	push	r28
    156c:	df 93       	push	r29
    156e:	08 2f       	mov	r16, r24
  Thread *ctp = currp;
    1570:	c0 91 3c 0c 	lds	r28, 0x0C3C
    1574:	d0 91 3d 0c 	lds	r29, 0x0C3D
  eventmask_t m;

  chSysLock();
    1578:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    157a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    157c:	18 2f       	mov	r17, r24
    157e:	19 23       	and	r17, r25
    1580:	99 f4       	brne	.+38     	; 0x15a8 <chEvtWaitAnyTimeout+0x42>
    if (TIME_IMMEDIATE == time) {
    1582:	61 15       	cp	r22, r1
    1584:	71 05       	cpc	r23, r1
    1586:	39 f4       	brne	.+14     	; 0x1596 <chEvtWaitAnyTimeout+0x30>
    }
    m = ctp->p_epending & mask;
  }
  ctp->p_epending &= ~m;

  chSysUnlock();
    1588:	78 94       	sei
  return m;
}
    158a:	81 2f       	mov	r24, r17
    158c:	df 91       	pop	r29
    158e:	cf 91       	pop	r28
    1590:	1f 91       	pop	r17
    1592:	0f 91       	pop	r16
    1594:	08 95       	ret
  if ((m = (ctp->p_epending & mask)) == 0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    1596:	8a 8b       	std	Y+18, r24	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
    1598:	88 e0       	ldi	r24, 0x08	; 8
    159a:	0e 94 bb 02 	call	0x576	; 0x576 <chSchGoSleepTimeoutS>
    159e:	97 fd       	sbrc	r25, 7
    15a0:	f3 cf       	rjmp	.-26     	; 0x1588 <chEvtWaitAnyTimeout+0x22>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & mask;
    15a2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    15a4:	10 2f       	mov	r17, r16
    15a6:	19 23       	and	r17, r25
  }
  ctp->p_epending &= ~m;
    15a8:	81 2f       	mov	r24, r17
    15aa:	80 95       	com	r24
    15ac:	89 23       	and	r24, r25
    15ae:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    15b0:	78 94       	sei
  return m;
}
    15b2:	81 2f       	mov	r24, r17
    15b4:	df 91       	pop	r29
    15b6:	cf 91       	pop	r28
    15b8:	1f 91       	pop	r17
    15ba:	0f 91       	pop	r16
    15bc:	08 95       	ret

000015be <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t mask, systime_t time) {
    15be:	1f 93       	push	r17
    15c0:	cf 93       	push	r28
    15c2:	df 93       	push	r29
    15c4:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    15c6:	c0 91 3c 0c 	lds	r28, 0x0C3C
    15ca:	d0 91 3d 0c 	lds	r29, 0x0C3D

  chSysLock();
    15ce:	f8 94       	cli

  if ((ctp->p_epending & mask) != mask) {
    15d0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15d2:	91 2f       	mov	r25, r17
    15d4:	98 23       	and	r25, r24
    15d6:	91 17       	cp	r25, r17
    15d8:	89 f0       	breq	.+34     	; 0x15fc <chEvtWaitAllTimeout+0x3e>
    if (TIME_IMMEDIATE == time) {
    15da:	61 15       	cp	r22, r1
    15dc:	71 05       	cpc	r23, r1
    15de:	39 f4       	brne	.+14     	; 0x15ee <chEvtWaitAllTimeout+0x30>
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    if (chSchGoSleepTimeoutS(THD_STATE_WTANDEVT, time) < RDY_OK) {
      chSysUnlock();
    15e0:	78 94       	sei
      return (eventmask_t)0;
    15e2:	10 e0       	ldi	r17, 0x00	; 0
  }
  ctp->p_epending &= ~mask;

  chSysUnlock();
  return mask;
}
    15e4:	81 2f       	mov	r24, r17
    15e6:	df 91       	pop	r29
    15e8:	cf 91       	pop	r28
    15ea:	1f 91       	pop	r17
    15ec:	08 95       	ret
  if ((ctp->p_epending & mask) != mask) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    15ee:	1a 8b       	std	Y+18, r17	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTANDEVT, time) < RDY_OK) {
    15f0:	89 e0       	ldi	r24, 0x09	; 9
    15f2:	0e 94 bb 02 	call	0x576	; 0x576 <chSchGoSleepTimeoutS>
    15f6:	97 fd       	sbrc	r25, 7
    15f8:	f3 cf       	rjmp	.-26     	; 0x15e0 <chEvtWaitAllTimeout+0x22>
    15fa:	8c 8d       	ldd	r24, Y+28	; 0x1c
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~mask;
    15fc:	91 2f       	mov	r25, r17
    15fe:	90 95       	com	r25
    1600:	98 23       	and	r25, r24
    1602:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    1604:	78 94       	sei
  return mask;
}
    1606:	81 2f       	mov	r24, r17
    1608:	df 91       	pop	r29
    160a:	cf 91       	pop	r28
    160c:	1f 91       	pop	r17
    160e:	08 95       	ret

00001610 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(Thread *tp, msg_t msg) {
    1610:	cf 93       	push	r28
    1612:	df 93       	push	r29
    1614:	fc 01       	movw	r30, r24
  Thread *ctp = currp;
    1616:	c0 91 3c 0c 	lds	r28, 0x0C3C
    161a:	d0 91 3d 0c 	lds	r29, 0x0C3D

  chDbgCheck(tp != NULL, "chMsgSend");

  chSysLock();
    161e:	f8 94       	cli
  ctp->p_msg = msg;
    1620:	7b 8f       	std	Y+27, r23	; 0x1b
    1622:	6a 8f       	std	Y+26, r22	; 0x1a
  ctp->p_u.wtobjp = &tp->p_msgqueue;
    1624:	46 96       	adiw	r24, 0x16	; 22
    1626:	9b 8b       	std	Y+19, r25	; 0x13
    1628:	8a 8b       	std	Y+18, r24	; 0x12
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
    162a:	99 83       	std	Y+1, r25	; 0x01
    162c:	88 83       	st	Y, r24
  tp->p_prev = tqp->p_prev;
    162e:	a0 8d       	ldd	r26, Z+24	; 0x18
    1630:	b1 8d       	ldd	r27, Z+25	; 0x19
    1632:	bb 83       	std	Y+3, r27	; 0x03
    1634:	aa 83       	std	Y+2, r26	; 0x02
  tp->p_prev->p_next = tqp->p_prev = tp;
    1636:	d1 8f       	std	Z+25, r29	; 0x19
    1638:	c0 8f       	std	Z+24, r28	; 0x18
    163a:	cd 93       	st	X+, r28
    163c:	dc 93       	st	X, r29
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == THD_STATE_WTMSG)
    163e:	85 85       	ldd	r24, Z+13	; 0x0d
    1640:	8c 30       	cpi	r24, 0x0C	; 12
    1642:	49 f0       	breq	.+18     	; 0x1656 <chMsgSend+0x46>
    chSchReadyI(tp);
  chSchGoSleepS(THD_STATE_SNDMSGQ);
    1644:	8a e0       	ldi	r24, 0x0A	; 10
    1646:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
    164a:	8a 89       	ldd	r24, Y+18	; 0x12
    164c:	9b 89       	ldd	r25, Y+19	; 0x13
  chSysUnlock();
    164e:	78 94       	sei
  return msg;
}
    1650:	df 91       	pop	r29
    1652:	cf 91       	pop	r28
    1654:	08 95       	ret
  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == THD_STATE_WTMSG)
    chSchReadyI(tp);
    1656:	cf 01       	movw	r24, r30
    1658:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
    165c:	f3 cf       	rjmp	.-26     	; 0x1644 <chMsgSend+0x34>

0000165e <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
Thread *chMsgWait(void) {
    165e:	cf 93       	push	r28
    1660:	df 93       	push	r29
  Thread *tp;

  chSysLock();
    1662:	f8 94       	cli
  if (!chMsgIsPendingI(currp))
    1664:	a0 91 3c 0c 	lds	r26, 0x0C3C
    1668:	b0 91 3d 0c 	lds	r27, 0x0C3D
    166c:	56 96       	adiw	r26, 0x16	; 22
    166e:	ed 91       	ld	r30, X+
    1670:	fc 91       	ld	r31, X
    1672:	57 97       	sbiw	r26, 0x17	; 23
    1674:	cd 01       	movw	r24, r26
    1676:	46 96       	adiw	r24, 0x16	; 22
    1678:	e8 17       	cp	r30, r24
    167a:	f9 07       	cpc	r31, r25
    167c:	79 f0       	breq	.+30     	; 0x169c <chMsgWait+0x3e>
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    167e:	c0 81       	ld	r28, Z
    1680:	d1 81       	ldd	r29, Z+1	; 0x01
    1682:	57 96       	adiw	r26, 0x17	; 23
    1684:	dc 93       	st	X, r29
    1686:	ce 93       	st	-X, r28
    1688:	56 97       	sbiw	r26, 0x16	; 22
    168a:	9b 83       	std	Y+3, r25	; 0x03
    168c:	8a 83       	std	Y+2, r24	; 0x02
    chSchGoSleepS(THD_STATE_WTMSG);
  tp = fifo_remove(&currp->p_msgqueue);
  tp->p_state = THD_STATE_SNDMSG;
    168e:	8b e0       	ldi	r24, 0x0B	; 11
    1690:	85 87       	std	Z+13, r24	; 0x0d
  chSysUnlock();
    1692:	78 94       	sei
  return tp;
}
    1694:	cf 01       	movw	r24, r30
    1696:	df 91       	pop	r29
    1698:	cf 91       	pop	r28
    169a:	08 95       	ret
Thread *chMsgWait(void) {
  Thread *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp))
    chSchGoSleepS(THD_STATE_WTMSG);
    169c:	8c e0       	ldi	r24, 0x0C	; 12
    169e:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
    16a2:	a0 91 3c 0c 	lds	r26, 0x0C3C
    16a6:	b0 91 3d 0c 	lds	r27, 0x0C3D
    16aa:	56 96       	adiw	r26, 0x16	; 22
    16ac:	ed 91       	ld	r30, X+
    16ae:	fc 91       	ld	r31, X
    16b0:	57 97       	sbiw	r26, 0x17	; 23
    16b2:	cd 01       	movw	r24, r26
    16b4:	46 96       	adiw	r24, 0x16	; 22
    16b6:	e3 cf       	rjmp	.-58     	; 0x167e <chMsgWait+0x20>

000016b8 <chMsgRelease>:
 *
 * @api
 */
void chMsgRelease(Thread *tp, msg_t msg) {

  chSysLock();
    16b8:	f8 94       	cli
  chDbgAssert(tp->p_state == THD_STATE_SNDMSG,
              "chMsgRelease(), #1", "invalid state");
  chMsgReleaseS(tp, msg);
    16ba:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
  chSysUnlock();
    16be:	78 94       	sei
    16c0:	08 95       	ret

000016c2 <chMBInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBInit(Mailbox *mbp, msg_t *buf, cnt_t n) {
    16c2:	cf 93       	push	r28
    16c4:	df 93       	push	r29
    16c6:	ec 01       	movw	r28, r24

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0), "chMBInit");

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
    16c8:	7f 83       	std	Y+7, r23	; 0x07
    16ca:	6e 83       	std	Y+6, r22	; 0x06
    16cc:	7d 83       	std	Y+5, r23	; 0x05
    16ce:	6c 83       	std	Y+4, r22	; 0x04
    16d0:	79 83       	std	Y+1, r23	; 0x01
    16d2:	68 83       	st	Y, r22
  mbp->mb_top = &buf[n];
    16d4:	24 2f       	mov	r18, r20
    16d6:	22 0f       	add	r18, r18
    16d8:	33 0b       	sbc	r19, r19
    16da:	26 0f       	add	r18, r22
    16dc:	37 1f       	adc	r19, r23
    16de:	3b 83       	std	Y+3, r19	; 0x03
    16e0:	2a 83       	std	Y+2, r18	; 0x02
  chSemInit(&mbp->mb_emptysem, n);
    16e2:	64 2f       	mov	r22, r20
    16e4:	0d 96       	adiw	r24, 0x0d	; 13
    16e6:	0e 94 37 05 	call	0xa6e	; 0xa6e <chSemInit>
  chSemInit(&mbp->mb_fullsem, 0);
    16ea:	60 e0       	ldi	r22, 0x00	; 0
    16ec:	ce 01       	movw	r24, r28
    16ee:	08 96       	adiw	r24, 0x08	; 8
}
    16f0:	df 91       	pop	r29
    16f2:	cf 91       	pop	r28
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0), "chMBInit");

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
  mbp->mb_top = &buf[n];
  chSemInit(&mbp->mb_emptysem, n);
  chSemInit(&mbp->mb_fullsem, 0);
    16f4:	0c 94 37 05 	jmp	0xa6e	; 0xa6e <chSemInit>

000016f8 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized Mailbox object
 *
 * @api
 */
void chMBReset(Mailbox *mbp) {
    16f8:	cf 93       	push	r28
    16fa:	df 93       	push	r29
    16fc:	ec 01       	movw	r28, r24

  chDbgCheck(mbp != NULL, "chMBReset");

  chSysLock();
    16fe:	f8 94       	cli
  mbp->mb_wrptr = mbp->mb_rdptr = mbp->mb_buffer;
    1700:	88 81       	ld	r24, Y
    1702:	99 81       	ldd	r25, Y+1	; 0x01
    1704:	9f 83       	std	Y+7, r25	; 0x07
    1706:	8e 83       	std	Y+6, r24	; 0x06
    1708:	9d 83       	std	Y+5, r25	; 0x05
    170a:	8c 83       	std	Y+4, r24	; 0x04
  chSemResetI(&mbp->mb_emptysem, mbp->mb_top - mbp->mb_buffer);
    170c:	6a 81       	ldd	r22, Y+2	; 0x02
    170e:	7b 81       	ldd	r23, Y+3	; 0x03
    1710:	68 1b       	sub	r22, r24
    1712:	79 0b       	sbc	r23, r25
    1714:	75 95       	asr	r23
    1716:	67 95       	ror	r22
    1718:	ce 01       	movw	r24, r28
    171a:	0d 96       	adiw	r24, 0x0d	; 13
    171c:	0e 94 3e 05 	call	0xa7c	; 0xa7c <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, 0);
    1720:	60 e0       	ldi	r22, 0x00	; 0
    1722:	ce 01       	movw	r24, r28
    1724:	08 96       	adiw	r24, 0x08	; 8
    1726:	0e 94 3e 05 	call	0xa7c	; 0xa7c <chSemResetI>
  chSchRescheduleS();
    172a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  chSysUnlock();
    172e:	78 94       	sei
}
    1730:	df 91       	pop	r29
    1732:	cf 91       	pop	r28
    1734:	08 95       	ret

00001736 <chMBPostS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(Mailbox *mbp, msg_t msg, systime_t time) {
    1736:	ef 92       	push	r14
    1738:	ff 92       	push	r15
    173a:	0f 93       	push	r16
    173c:	1f 93       	push	r17
    173e:	cf 93       	push	r28
    1740:	df 93       	push	r29
    1742:	ec 01       	movw	r28, r24
    1744:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL, "chMBPostS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
    1746:	ba 01       	movw	r22, r20
    1748:	0d 96       	adiw	r24, 0x0d	; 13
    174a:	0e 94 a1 05 	call	0xb42	; 0xb42 <chSemWaitTimeoutS>
    174e:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    1750:	00 97       	sbiw	r24, 0x00	; 0
    1752:	89 f4       	brne	.+34     	; 0x1776 <chMBPostS+0x40>
    *mbp->mb_wrptr++ = msg;
    1754:	ec 81       	ldd	r30, Y+4	; 0x04
    1756:	fd 81       	ldd	r31, Y+5	; 0x05
    1758:	e1 92       	st	Z+, r14
    175a:	f1 92       	st	Z+, r15
    175c:	fd 83       	std	Y+5, r31	; 0x05
    175e:	ec 83       	std	Y+4, r30	; 0x04
    if (mbp->mb_wrptr >= mbp->mb_top)
    1760:	8a 81       	ldd	r24, Y+2	; 0x02
    1762:	9b 81       	ldd	r25, Y+3	; 0x03
    1764:	e8 17       	cp	r30, r24
    1766:	f9 07       	cpc	r31, r25
    1768:	70 f4       	brcc	.+28     	; 0x1786 <chMBPostS+0x50>
      mbp->mb_wrptr = mbp->mb_buffer;
    chSemSignalI(&mbp->mb_fullsem);
    176a:	ce 01       	movw	r24, r28
    176c:	08 96       	adiw	r24, 0x08	; 8
    176e:	0e 94 f6 05 	call	0xbec	; 0xbec <chSemSignalI>
    chSchRescheduleS();
    1772:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  }
  return rdymsg;
}
    1776:	c8 01       	movw	r24, r16
    1778:	df 91       	pop	r29
    177a:	cf 91       	pop	r28
    177c:	1f 91       	pop	r17
    177e:	0f 91       	pop	r16
    1780:	ff 90       	pop	r15
    1782:	ef 90       	pop	r14
    1784:	08 95       	ret

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == RDY_OK) {
    *mbp->mb_wrptr++ = msg;
    if (mbp->mb_wrptr >= mbp->mb_top)
      mbp->mb_wrptr = mbp->mb_buffer;
    1786:	88 81       	ld	r24, Y
    1788:	99 81       	ldd	r25, Y+1	; 0x01
    178a:	9d 83       	std	Y+5, r25	; 0x05
    178c:	8c 83       	std	Y+4, r24	; 0x04
    178e:	ed cf       	rjmp	.-38     	; 0x176a <chMBPostS+0x34>

00001790 <chMBPost>:
 * @api
 */
msg_t chMBPost(Mailbox *mbp, msg_t msg, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    1790:	f8 94       	cli
  rdymsg = chMBPostS(mbp, msg, time);
    1792:	0e 94 9b 0b 	call	0x1736	; 0x1736 <chMBPostS>
  chSysUnlock();
    1796:	78 94       	sei
  return rdymsg;
}
    1798:	08 95       	ret

0000179a <chMBPostI>:
 * @retval RDY_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(Mailbox *mbp, msg_t msg) {
    179a:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    179c:	81 89       	ldd	r24, Z+17	; 0x11
    179e:	18 16       	cp	r1, r24
    17a0:	d4 f4       	brge	.+52     	; 0x17d6 <chMBPostI+0x3c>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
    17a2:	81 50       	subi	r24, 0x01	; 1
    17a4:	81 8b       	std	Z+17, r24	; 0x11
  *mbp->mb_wrptr++ = msg;
    17a6:	a4 81       	ldd	r26, Z+4	; 0x04
    17a8:	b5 81       	ldd	r27, Z+5	; 0x05
    17aa:	6d 93       	st	X+, r22
    17ac:	7d 93       	st	X+, r23
    17ae:	b5 83       	std	Z+5, r27	; 0x05
    17b0:	a4 83       	std	Z+4, r26	; 0x04
  if (mbp->mb_wrptr >= mbp->mb_top)
    17b2:	82 81       	ldd	r24, Z+2	; 0x02
    17b4:	93 81       	ldd	r25, Z+3	; 0x03
    17b6:	a8 17       	cp	r26, r24
    17b8:	b9 07       	cpc	r27, r25
    17ba:	40 f4       	brcc	.+16     	; 0x17cc <chMBPostI+0x32>
    mbp->mb_wrptr = mbp->mb_buffer;
  chSemSignalI(&mbp->mb_fullsem);
    17bc:	cf 01       	movw	r24, r30
    17be:	08 96       	adiw	r24, 0x08	; 8
    17c0:	0e 94 f6 05 	call	0xbec	; 0xbec <chSemSignalI>
  return RDY_OK;
    17c4:	20 e0       	ldi	r18, 0x00	; 0
    17c6:	30 e0       	ldi	r19, 0x00	; 0
}
    17c8:	c9 01       	movw	r24, r18
    17ca:	08 95       	ret
  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top)
    mbp->mb_wrptr = mbp->mb_buffer;
    17cc:	80 81       	ld	r24, Z
    17ce:	91 81       	ldd	r25, Z+1	; 0x01
    17d0:	95 83       	std	Z+5, r25	; 0x05
    17d2:	84 83       	std	Z+4, r24	; 0x04
    17d4:	f3 cf       	rjmp	.-26     	; 0x17bc <chMBPostI+0x22>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
    17d6:	2f ef       	ldi	r18, 0xFF	; 255
    17d8:	3f ef       	ldi	r19, 0xFF	; 255
    17da:	f6 cf       	rjmp	.-20     	; 0x17c8 <chMBPostI+0x2e>

000017dc <chMBPostAheadS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(Mailbox *mbp, msg_t msg, systime_t time) {
    17dc:	ef 92       	push	r14
    17de:	ff 92       	push	r15
    17e0:	0f 93       	push	r16
    17e2:	1f 93       	push	r17
    17e4:	cf 93       	push	r28
    17e6:	df 93       	push	r29
    17e8:	ec 01       	movw	r28, r24
    17ea:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL, "chMBPostAheadS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
    17ec:	ba 01       	movw	r22, r20
    17ee:	0d 96       	adiw	r24, 0x0d	; 13
    17f0:	0e 94 a1 05 	call	0xb42	; 0xb42 <chSemWaitTimeoutS>
    17f4:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    17f6:	00 97       	sbiw	r24, 0x00	; 0
    17f8:	91 f4       	brne	.+36     	; 0x181e <chMBPostAheadS+0x42>
    if (--mbp->mb_rdptr < mbp->mb_buffer)
    17fa:	ee 81       	ldd	r30, Y+6	; 0x06
    17fc:	ff 81       	ldd	r31, Y+7	; 0x07
    17fe:	32 97       	sbiw	r30, 0x02	; 2
    1800:	ff 83       	std	Y+7, r31	; 0x07
    1802:	ee 83       	std	Y+6, r30	; 0x06
    1804:	88 81       	ld	r24, Y
    1806:	99 81       	ldd	r25, Y+1	; 0x01
    1808:	e8 17       	cp	r30, r24
    180a:	f9 07       	cpc	r31, r25
    180c:	80 f0       	brcs	.+32     	; 0x182e <chMBPostAheadS+0x52>
      mbp->mb_rdptr = mbp->mb_top - 1;
    *mbp->mb_rdptr = msg;
    180e:	f1 82       	std	Z+1, r15	; 0x01
    1810:	e0 82       	st	Z, r14
    chSemSignalI(&mbp->mb_fullsem);
    1812:	ce 01       	movw	r24, r28
    1814:	08 96       	adiw	r24, 0x08	; 8
    1816:	0e 94 f6 05 	call	0xbec	; 0xbec <chSemSignalI>
    chSchRescheduleS();
    181a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  }
  return rdymsg;
}
    181e:	c8 01       	movw	r24, r16
    1820:	df 91       	pop	r29
    1822:	cf 91       	pop	r28
    1824:	1f 91       	pop	r17
    1826:	0f 91       	pop	r16
    1828:	ff 90       	pop	r15
    182a:	ef 90       	pop	r14
    182c:	08 95       	ret
  chDbgCheck(mbp != NULL, "chMBPostAheadS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == RDY_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer)
      mbp->mb_rdptr = mbp->mb_top - 1;
    182e:	ea 81       	ldd	r30, Y+2	; 0x02
    1830:	fb 81       	ldd	r31, Y+3	; 0x03
    1832:	32 97       	sbiw	r30, 0x02	; 2
    1834:	ff 83       	std	Y+7, r31	; 0x07
    1836:	ee 83       	std	Y+6, r30	; 0x06
    1838:	ea cf       	rjmp	.-44     	; 0x180e <chMBPostAheadS+0x32>

0000183a <chMBPostAhead>:
 * @api
 */
msg_t chMBPostAhead(Mailbox *mbp, msg_t msg, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    183a:	f8 94       	cli
  rdymsg = chMBPostAheadS(mbp, msg, time);
    183c:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <chMBPostAheadS>
  chSysUnlock();
    1840:	78 94       	sei
  return rdymsg;
}
    1842:	08 95       	ret

00001844 <chMBPostAheadI>:
 * @retval RDY_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(Mailbox *mbp, msg_t msg) {
    1844:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostAheadI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    1846:	81 89       	ldd	r24, Z+17	; 0x11
    1848:	18 16       	cp	r1, r24
    184a:	e4 f4       	brge	.+56     	; 0x1884 <chMBPostAheadI+0x40>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
    184c:	81 50       	subi	r24, 0x01	; 1
    184e:	81 8b       	std	Z+17, r24	; 0x11
  if (--mbp->mb_rdptr < mbp->mb_buffer)
    1850:	a6 81       	ldd	r26, Z+6	; 0x06
    1852:	b7 81       	ldd	r27, Z+7	; 0x07
    1854:	12 97       	sbiw	r26, 0x02	; 2
    1856:	b7 83       	std	Z+7, r27	; 0x07
    1858:	a6 83       	std	Z+6, r26	; 0x06
    185a:	80 81       	ld	r24, Z
    185c:	91 81       	ldd	r25, Z+1	; 0x01
    185e:	a8 17       	cp	r26, r24
    1860:	b9 07       	cpc	r27, r25
    1862:	50 f0       	brcs	.+20     	; 0x1878 <chMBPostAheadI+0x34>
    mbp->mb_rdptr = mbp->mb_top - 1;
  *mbp->mb_rdptr = msg;
    1864:	6d 93       	st	X+, r22
    1866:	7c 93       	st	X, r23
  chSemSignalI(&mbp->mb_fullsem);
    1868:	cf 01       	movw	r24, r30
    186a:	08 96       	adiw	r24, 0x08	; 8
    186c:	0e 94 f6 05 	call	0xbec	; 0xbec <chSemSignalI>
  return RDY_OK;
    1870:	20 e0       	ldi	r18, 0x00	; 0
    1872:	30 e0       	ldi	r19, 0x00	; 0
}
    1874:	c9 01       	movw	r24, r18
    1876:	08 95       	ret

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer)
    mbp->mb_rdptr = mbp->mb_top - 1;
    1878:	a2 81       	ldd	r26, Z+2	; 0x02
    187a:	b3 81       	ldd	r27, Z+3	; 0x03
    187c:	12 97       	sbiw	r26, 0x02	; 2
    187e:	b7 83       	std	Z+7, r27	; 0x07
    1880:	a6 83       	std	Z+6, r26	; 0x06
    1882:	f0 cf       	rjmp	.-32     	; 0x1864 <chMBPostAheadI+0x20>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostAheadI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
    1884:	2f ef       	ldi	r18, 0xFF	; 255
    1886:	3f ef       	ldi	r19, 0xFF	; 255
    1888:	f5 cf       	rjmp	.-22     	; 0x1874 <chMBPostAheadI+0x30>

0000188a <chMBFetchS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(Mailbox *mbp, msg_t *msgp, systime_t time) {
    188a:	ef 92       	push	r14
    188c:	ff 92       	push	r15
    188e:	0f 93       	push	r16
    1890:	1f 93       	push	r17
    1892:	cf 93       	push	r28
    1894:	df 93       	push	r29
    1896:	ec 01       	movw	r28, r24
    1898:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
    189a:	ba 01       	movw	r22, r20
    189c:	08 96       	adiw	r24, 0x08	; 8
    189e:	0e 94 a1 05 	call	0xb42	; 0xb42 <chSemWaitTimeoutS>
    18a2:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    18a4:	00 97       	sbiw	r24, 0x00	; 0
    18a6:	a1 f4       	brne	.+40     	; 0x18d0 <chMBFetchS+0x46>
    *msgp = *mbp->mb_rdptr++;
    18a8:	ee 81       	ldd	r30, Y+6	; 0x06
    18aa:	ff 81       	ldd	r31, Y+7	; 0x07
    18ac:	81 91       	ld	r24, Z+
    18ae:	91 91       	ld	r25, Z+
    18b0:	d7 01       	movw	r26, r14
    18b2:	8d 93       	st	X+, r24
    18b4:	9c 93       	st	X, r25
    18b6:	ff 83       	std	Y+7, r31	; 0x07
    18b8:	ee 83       	std	Y+6, r30	; 0x06
    if (mbp->mb_rdptr >= mbp->mb_top)
    18ba:	8a 81       	ldd	r24, Y+2	; 0x02
    18bc:	9b 81       	ldd	r25, Y+3	; 0x03
    18be:	e8 17       	cp	r30, r24
    18c0:	f9 07       	cpc	r31, r25
    18c2:	70 f4       	brcc	.+28     	; 0x18e0 <chMBFetchS+0x56>
      mbp->mb_rdptr = mbp->mb_buffer;
    chSemSignalI(&mbp->mb_emptysem);
    18c4:	ce 01       	movw	r24, r28
    18c6:	0d 96       	adiw	r24, 0x0d	; 13
    18c8:	0e 94 f6 05 	call	0xbec	; 0xbec <chSemSignalI>
    chSchRescheduleS();
    18cc:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  }
  return rdymsg;
}
    18d0:	c8 01       	movw	r24, r16
    18d2:	df 91       	pop	r29
    18d4:	cf 91       	pop	r28
    18d6:	1f 91       	pop	r17
    18d8:	0f 91       	pop	r16
    18da:	ff 90       	pop	r15
    18dc:	ef 90       	pop	r14
    18de:	08 95       	ret

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == RDY_OK) {
    *msgp = *mbp->mb_rdptr++;
    if (mbp->mb_rdptr >= mbp->mb_top)
      mbp->mb_rdptr = mbp->mb_buffer;
    18e0:	88 81       	ld	r24, Y
    18e2:	99 81       	ldd	r25, Y+1	; 0x01
    18e4:	9f 83       	std	Y+7, r25	; 0x07
    18e6:	8e 83       	std	Y+6, r24	; 0x06
    18e8:	ed cf       	rjmp	.-38     	; 0x18c4 <chMBFetchS+0x3a>

000018ea <chMBFetch>:
 * @api
 */
msg_t chMBFetch(Mailbox *mbp, msg_t *msgp, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    18ea:	f8 94       	cli
  rdymsg = chMBFetchS(mbp, msgp, time);
    18ec:	0e 94 45 0c 	call	0x188a	; 0x188a <chMBFetchS>
  chSysUnlock();
    18f0:	78 94       	sei
  return rdymsg;
}
    18f2:	08 95       	ret

000018f4 <chMBFetchI>:
 * @retval RDY_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(Mailbox *mbp, msg_t *msgp) {
    18f4:	cf 93       	push	r28
    18f6:	df 93       	push	r29
    18f8:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchI");

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    18fa:	84 85       	ldd	r24, Z+12	; 0x0c
    18fc:	18 16       	cp	r1, r24
    18fe:	fc f4       	brge	.+62     	; 0x193e <chMBFetchI+0x4a>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_fullsem);
    1900:	81 50       	subi	r24, 0x01	; 1
    1902:	84 87       	std	Z+12, r24	; 0x0c
  *msgp = *mbp->mb_rdptr++;
    1904:	a6 81       	ldd	r26, Z+6	; 0x06
    1906:	b7 81       	ldd	r27, Z+7	; 0x07
    1908:	8d 91       	ld	r24, X+
    190a:	9d 91       	ld	r25, X+
    190c:	eb 01       	movw	r28, r22
    190e:	99 83       	std	Y+1, r25	; 0x01
    1910:	88 83       	st	Y, r24
    1912:	b7 83       	std	Z+7, r27	; 0x07
    1914:	a6 83       	std	Z+6, r26	; 0x06
  if (mbp->mb_rdptr >= mbp->mb_top)
    1916:	82 81       	ldd	r24, Z+2	; 0x02
    1918:	93 81       	ldd	r25, Z+3	; 0x03
    191a:	a8 17       	cp	r26, r24
    191c:	b9 07       	cpc	r27, r25
    191e:	50 f4       	brcc	.+20     	; 0x1934 <chMBFetchI+0x40>
    mbp->mb_rdptr = mbp->mb_buffer;
  chSemSignalI(&mbp->mb_emptysem);
    1920:	cf 01       	movw	r24, r30
    1922:	0d 96       	adiw	r24, 0x0d	; 13
    1924:	0e 94 f6 05 	call	0xbec	; 0xbec <chSemSignalI>
  return RDY_OK;
    1928:	20 e0       	ldi	r18, 0x00	; 0
    192a:	30 e0       	ldi	r19, 0x00	; 0
}
    192c:	c9 01       	movw	r24, r18
    192e:	df 91       	pop	r29
    1930:	cf 91       	pop	r28
    1932:	08 95       	ret
  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top)
    mbp->mb_rdptr = mbp->mb_buffer;
    1934:	80 81       	ld	r24, Z
    1936:	91 81       	ldd	r25, Z+1	; 0x01
    1938:	97 83       	std	Z+7, r25	; 0x07
    193a:	86 83       	std	Z+6, r24	; 0x06
    193c:	f1 cf       	rjmp	.-30     	; 0x1920 <chMBFetchI+0x2c>

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchI");

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    return RDY_TIMEOUT;
    193e:	2f ef       	ldi	r18, 0xFF	; 255
    1940:	3f ef       	ldi	r19, 0xFF	; 255
    1942:	f4 cf       	rjmp	.-24     	; 0x192c <chMBFetchI+0x38>

00001944 <qwait>:
 *                      released from threads queue.
 * @retval Q_OK         is the normal exit, thread signaled.
 * @retval Q_RESET      if the queue has been reset.
 * @retval Q_TIMEOUT    if the queue operation timed out.
 */
static msg_t qwait(GenericQueue *qp, systime_t time) {
    1944:	cf 93       	push	r28
    1946:	df 93       	push	r29

  if (TIME_IMMEDIATE == time)
    1948:	61 15       	cp	r22, r1
    194a:	71 05       	cpc	r23, r1
    194c:	b1 f0       	breq	.+44     	; 0x197a <qwait+0x36>
    return Q_TIMEOUT;
  currp->p_u.wtobjp = qp;
    194e:	e0 91 3c 0c 	lds	r30, 0x0C3C
    1952:	f0 91 3d 0c 	lds	r31, 0x0C3D
    1956:	93 8b       	std	Z+19, r25	; 0x13
    1958:	82 8b       	std	Z+18, r24	; 0x12
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
    195a:	91 83       	std	Z+1, r25	; 0x01
    195c:	80 83       	st	Z, r24
  tp->p_prev = tqp->p_prev;
    195e:	ec 01       	movw	r28, r24
    1960:	aa 81       	ldd	r26, Y+2	; 0x02
    1962:	bb 81       	ldd	r27, Y+3	; 0x03
    1964:	b3 83       	std	Z+3, r27	; 0x03
    1966:	a2 83       	std	Z+2, r26	; 0x02
  tp->p_prev->p_next = tqp->p_prev = tp;
    1968:	fb 83       	std	Y+3, r31	; 0x03
    196a:	ea 83       	std	Y+2, r30	; 0x02
    196c:	ed 93       	st	X+, r30
    196e:	fc 93       	st	X, r31
  queue_insert(currp, &qp->q_waiting);
  return chSchGoSleepTimeoutS(THD_STATE_WTQUEUE, time);
    1970:	8d e0       	ldi	r24, 0x0D	; 13
}
    1972:	df 91       	pop	r29
    1974:	cf 91       	pop	r28

  if (TIME_IMMEDIATE == time)
    return Q_TIMEOUT;
  currp->p_u.wtobjp = qp;
  queue_insert(currp, &qp->q_waiting);
  return chSchGoSleepTimeoutS(THD_STATE_WTQUEUE, time);
    1976:	0c 94 bb 02 	jmp	0x576	; 0x576 <chSchGoSleepTimeoutS>
}
    197a:	8f ef       	ldi	r24, 0xFF	; 255
    197c:	9f ef       	ldi	r25, 0xFF	; 255
    197e:	df 91       	pop	r29
    1980:	cf 91       	pop	r28
    1982:	08 95       	ret

00001984 <chIQInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQInit(InputQueue *iqp, uint8_t *bp, size_t size, qnotify_t infy,
              void *link) {
    1984:	0f 93       	push	r16
    1986:	1f 93       	push	r17
    1988:	fc 01       	movw	r30, r24

  queue_init(&iqp->q_waiting);
    198a:	82 83       	std	Z+2, r24	; 0x02
    198c:	f3 83       	std	Z+3, r31	; 0x03
    198e:	80 83       	st	Z, r24
    1990:	f1 83       	std	Z+1, r31	; 0x01
  iqp->q_counter = 0;
    1992:	15 82       	std	Z+5, r1	; 0x05
    1994:	14 82       	std	Z+4, r1	; 0x04
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
    1996:	73 87       	std	Z+11, r23	; 0x0b
    1998:	62 87       	std	Z+10, r22	; 0x0a
    199a:	75 87       	std	Z+13, r23	; 0x0d
    199c:	64 87       	std	Z+12, r22	; 0x0c
    199e:	77 83       	std	Z+7, r23	; 0x07
    19a0:	66 83       	std	Z+6, r22	; 0x06
  iqp->q_top = bp + size;
    19a2:	46 0f       	add	r20, r22
    19a4:	57 1f       	adc	r21, r23
    19a6:	51 87       	std	Z+9, r21	; 0x09
    19a8:	40 87       	std	Z+8, r20	; 0x08
  iqp->q_notify = infy;
    19aa:	37 87       	std	Z+15, r19	; 0x0f
    19ac:	26 87       	std	Z+14, r18	; 0x0e
  iqp->q_link = link;
    19ae:	11 8b       	std	Z+17, r17	; 0x11
    19b0:	00 8b       	std	Z+16, r16	; 0x10
}
    19b2:	1f 91       	pop	r17
    19b4:	0f 91       	pop	r16
    19b6:	08 95       	ret

000019b8 <chIQResetI>:
 *
 * @param[in] iqp       pointer to an @p InputQueue structure
 *
 * @iclass
 */
void chIQResetI(InputQueue *iqp) {
    19b8:	0f 93       	push	r16
    19ba:	1f 93       	push	r17
    19bc:	cf 93       	push	r28
    19be:	df 93       	push	r29
    19c0:	ec 01       	movw	r28, r24

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
    19c2:	8e 81       	ldd	r24, Y+6	; 0x06
    19c4:	9f 81       	ldd	r25, Y+7	; 0x07
    19c6:	9b 87       	std	Y+11, r25	; 0x0b
    19c8:	8a 87       	std	Y+10, r24	; 0x0a
    19ca:	9d 87       	std	Y+13, r25	; 0x0d
    19cc:	8c 87       	std	Y+12, r24	; 0x0c
  iqp->q_counter = 0;
    19ce:	1d 82       	std	Y+5, r1	; 0x05
    19d0:	1c 82       	std	Y+4, r1	; 0x04
  while (notempty(&iqp->q_waiting))
    19d2:	88 81       	ld	r24, Y
    19d4:	99 81       	ldd	r25, Y+1	; 0x01
    19d6:	8c 17       	cp	r24, r28
    19d8:	9d 07       	cpc	r25, r29
    19da:	99 f0       	breq	.+38     	; 0x1a02 <chIQResetI+0x4a>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_RESET;
    19dc:	0e ef       	ldi	r16, 0xFE	; 254
    19de:	1f ef       	ldi	r17, 0xFF	; 255
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    19e0:	dc 01       	movw	r26, r24
    19e2:	ed 91       	ld	r30, X+
    19e4:	fc 91       	ld	r31, X
    19e6:	f9 83       	std	Y+1, r31	; 0x01
    19e8:	e8 83       	st	Y, r30
    19ea:	d3 83       	std	Z+3, r29	; 0x03
    19ec:	c2 83       	std	Z+2, r28	; 0x02
    19ee:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
    19f2:	fc 01       	movw	r30, r24
    19f4:	13 8b       	std	Z+19, r17	; 0x13
    19f6:	02 8b       	std	Z+18, r16	; 0x12

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
  while (notempty(&iqp->q_waiting))
    19f8:	88 81       	ld	r24, Y
    19fa:	99 81       	ldd	r25, Y+1	; 0x01
    19fc:	8c 17       	cp	r24, r28
    19fe:	9d 07       	cpc	r25, r29
    1a00:	79 f7       	brne	.-34     	; 0x19e0 <chIQResetI+0x28>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_RESET;
}
    1a02:	df 91       	pop	r29
    1a04:	cf 91       	pop	r28
    1a06:	1f 91       	pop	r17
    1a08:	0f 91       	pop	r16
    1a0a:	08 95       	ret

00001a0c <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(InputQueue *iqp, uint8_t b) {
    1a0c:	cf 93       	push	r28
    1a0e:	df 93       	push	r29
    1a10:	fc 01       	movw	r30, r24

  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
    1a12:	a2 85       	ldd	r26, Z+10	; 0x0a
    1a14:	b3 85       	ldd	r27, Z+11	; 0x0b
    1a16:	84 85       	ldd	r24, Z+12	; 0x0c
    1a18:	95 85       	ldd	r25, Z+13	; 0x0d
    1a1a:	a8 17       	cp	r26, r24
    1a1c:	b9 07       	cpc	r27, r25
    1a1e:	a9 f1       	breq	.+106    	; 0x1a8a <chIQPutI+0x7e>
    1a20:	84 81       	ldd	r24, Z+4	; 0x04
    1a22:	95 81       	ldd	r25, Z+5	; 0x05
    return Q_FULL;

  iqp->q_counter++;
    1a24:	01 96       	adiw	r24, 0x01	; 1
    1a26:	95 83       	std	Z+5, r25	; 0x05
    1a28:	84 83       	std	Z+4, r24	; 0x04
  *iqp->q_wrptr++ = b;
    1a2a:	6d 93       	st	X+, r22
    1a2c:	b3 87       	std	Z+11, r27	; 0x0b
    1a2e:	a2 87       	std	Z+10, r26	; 0x0a
  if (iqp->q_wrptr >= iqp->q_top)
    1a30:	80 85       	ldd	r24, Z+8	; 0x08
    1a32:	91 85       	ldd	r25, Z+9	; 0x09
    1a34:	a8 17       	cp	r26, r24
    1a36:	b9 07       	cpc	r27, r25
    1a38:	c8 f4       	brcc	.+50     	; 0x1a6c <chIQPutI+0x60>
    iqp->q_wrptr = iqp->q_buffer;

  if (notempty(&iqp->q_waiting))
    1a3a:	80 81       	ld	r24, Z
    1a3c:	91 81       	ldd	r25, Z+1	; 0x01
    1a3e:	8e 17       	cp	r24, r30
    1a40:	9f 07       	cpc	r25, r31
    1a42:	e9 f0       	breq	.+58     	; 0x1a7e <chIQPutI+0x72>
    1a44:	ec 01       	movw	r28, r24
    1a46:	a8 81       	ld	r26, Y
    1a48:	b9 81       	ldd	r27, Y+1	; 0x01
    1a4a:	b1 83       	std	Z+1, r27	; 0x01
    1a4c:	a0 83       	st	Z, r26
    1a4e:	13 96       	adiw	r26, 0x03	; 3
    1a50:	fc 93       	st	X, r31
    1a52:	ee 93       	st	-X, r30
    1a54:	12 97       	sbiw	r26, 0x02	; 2
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;
    1a56:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
    1a5a:	fc 01       	movw	r30, r24
    1a5c:	13 8a       	std	Z+19, r1	; 0x13
    1a5e:	12 8a       	std	Z+18, r1	; 0x12

  return Q_OK;
    1a60:	20 e0       	ldi	r18, 0x00	; 0
    1a62:	30 e0       	ldi	r19, 0x00	; 0
}
    1a64:	c9 01       	movw	r24, r18
    1a66:	df 91       	pop	r29
    1a68:	cf 91       	pop	r28
    1a6a:	08 95       	ret
    return Q_FULL;

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top)
    iqp->q_wrptr = iqp->q_buffer;
    1a6c:	86 81       	ldd	r24, Z+6	; 0x06
    1a6e:	97 81       	ldd	r25, Z+7	; 0x07
    1a70:	93 87       	std	Z+11, r25	; 0x0b
    1a72:	82 87       	std	Z+10, r24	; 0x0a

  if (notempty(&iqp->q_waiting))
    1a74:	80 81       	ld	r24, Z
    1a76:	91 81       	ldd	r25, Z+1	; 0x01
    1a78:	8e 17       	cp	r24, r30
    1a7a:	9f 07       	cpc	r25, r31
    1a7c:	19 f7       	brne	.-58     	; 0x1a44 <chIQPutI+0x38>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;

  return Q_OK;
    1a7e:	20 e0       	ldi	r18, 0x00	; 0
    1a80:	30 e0       	ldi	r19, 0x00	; 0
}
    1a82:	c9 01       	movw	r24, r18
    1a84:	df 91       	pop	r29
    1a86:	cf 91       	pop	r28
    1a88:	08 95       	ret
 */
msg_t chIQPutI(InputQueue *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
    1a8a:	84 81       	ldd	r24, Z+4	; 0x04
    1a8c:	95 81       	ldd	r25, Z+5	; 0x05
    1a8e:	89 2b       	or	r24, r25
    1a90:	19 f4       	brne	.+6      	; 0x1a98 <chIQPutI+0x8c>
    1a92:	80 e0       	ldi	r24, 0x00	; 0
    1a94:	90 e0       	ldi	r25, 0x00	; 0
    1a96:	c6 cf       	rjmp	.-116    	; 0x1a24 <chIQPutI+0x18>
    return Q_FULL;
    1a98:	2c ef       	ldi	r18, 0xFC	; 252
    1a9a:	3f ef       	ldi	r19, 0xFF	; 255
    1a9c:	e3 cf       	rjmp	.-58     	; 0x1a64 <chIQPutI+0x58>

00001a9e <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(InputQueue *iqp, systime_t time) {
    1a9e:	0f 93       	push	r16
    1aa0:	1f 93       	push	r17
    1aa2:	cf 93       	push	r28
    1aa4:	df 93       	push	r29
    1aa6:	ec 01       	movw	r28, r24
    1aa8:	8b 01       	movw	r16, r22
  uint8_t b;

  chSysLock();
    1aaa:	f8 94       	cli
  if (iqp->q_notify)
    1aac:	ee 85       	ldd	r30, Y+14	; 0x0e
    1aae:	ff 85       	ldd	r31, Y+15	; 0x0f
    1ab0:	30 97       	sbiw	r30, 0x00	; 0
    1ab2:	09 f0       	breq	.+2      	; 0x1ab6 <chIQGetTimeout+0x18>
    iqp->q_notify(iqp);
    1ab4:	09 95       	icall

  while (chIQIsEmptyI(iqp)) {
    1ab6:	8c 81       	ldd	r24, Y+4	; 0x04
    1ab8:	9d 81       	ldd	r25, Y+5	; 0x05
    1aba:	00 97       	sbiw	r24, 0x00	; 0
    1abc:	71 f4       	brne	.+28     	; 0x1ada <chIQGetTimeout+0x3c>
    msg_t msg;
    if ((msg = qwait((GenericQueue *)iqp, time)) < Q_OK) {
    1abe:	b8 01       	movw	r22, r16
    1ac0:	ce 01       	movw	r24, r28
    1ac2:	0e 94 a2 0c 	call	0x1944	; 0x1944 <qwait>
    1ac6:	9c 01       	movw	r18, r24
    1ac8:	97 ff       	sbrs	r25, 7
    1aca:	f5 cf       	rjmp	.-22     	; 0x1ab6 <chIQGetTimeout+0x18>
      chSysUnlock();
    1acc:	78 94       	sei
  if (iqp->q_rdptr >= iqp->q_top)
    iqp->q_rdptr = iqp->q_buffer;

  chSysUnlock();
  return b;
}
    1ace:	c9 01       	movw	r24, r18
    1ad0:	df 91       	pop	r29
    1ad2:	cf 91       	pop	r28
    1ad4:	1f 91       	pop	r17
    1ad6:	0f 91       	pop	r16
    1ad8:	08 95       	ret
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
    1ada:	01 97       	sbiw	r24, 0x01	; 1
    1adc:	9d 83       	std	Y+5, r25	; 0x05
    1ade:	8c 83       	std	Y+4, r24	; 0x04
  b = *iqp->q_rdptr++;
    1ae0:	ec 85       	ldd	r30, Y+12	; 0x0c
    1ae2:	fd 85       	ldd	r31, Y+13	; 0x0d
    1ae4:	21 91       	ld	r18, Z+
    1ae6:	fd 87       	std	Y+13, r31	; 0x0d
    1ae8:	ec 87       	std	Y+12, r30	; 0x0c
  if (iqp->q_rdptr >= iqp->q_top)
    1aea:	88 85       	ldd	r24, Y+8	; 0x08
    1aec:	99 85       	ldd	r25, Y+9	; 0x09
    1aee:	e8 17       	cp	r30, r24
    1af0:	f9 07       	cpc	r31, r25
    1af2:	20 f0       	brcs	.+8      	; 0x1afc <chIQGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
    1af4:	8e 81       	ldd	r24, Y+6	; 0x06
    1af6:	9f 81       	ldd	r25, Y+7	; 0x07
    1af8:	9d 87       	std	Y+13, r25	; 0x0d
    1afa:	8c 87       	std	Y+12, r24	; 0x0c

  chSysUnlock();
    1afc:	78 94       	sei
  return b;
    1afe:	30 e0       	ldi	r19, 0x00	; 0
}
    1b00:	c9 01       	movw	r24, r18
    1b02:	df 91       	pop	r29
    1b04:	cf 91       	pop	r28
    1b06:	1f 91       	pop	r17
    1b08:	0f 91       	pop	r16
    1b0a:	08 95       	ret

00001b0c <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
    1b0c:	8f 92       	push	r8
    1b0e:	9f 92       	push	r9
    1b10:	af 92       	push	r10
    1b12:	bf 92       	push	r11
    1b14:	cf 92       	push	r12
    1b16:	df 92       	push	r13
    1b18:	ef 92       	push	r14
    1b1a:	ff 92       	push	r15
    1b1c:	0f 93       	push	r16
    1b1e:	1f 93       	push	r17
    1b20:	cf 93       	push	r28
    1b22:	df 93       	push	r29
    1b24:	ec 01       	movw	r28, r24
    1b26:	5b 01       	movw	r10, r22
    1b28:	4a 01       	movw	r8, r20
    1b2a:	89 01       	movw	r16, r18
  qnotify_t nfy = iqp->q_notify;
    1b2c:	ce 84       	ldd	r12, Y+14	; 0x0e
    1b2e:	df 84       	ldd	r13, Y+15	; 0x0f
  size_t r = 0;

  chDbgCheck(n > 0, "chIQReadTimeout");

  chSysLock();
    1b30:	f8 94       	cli
 * @api
 */
size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
    1b32:	e1 2c       	mov	r14, r1
    1b34:	f1 2c       	mov	r15, r1

  chDbgCheck(n > 0, "chIQReadTimeout");

  chSysLock();
  while (TRUE) {
    if (nfy)
    1b36:	c1 14       	cp	r12, r1
    1b38:	d1 04       	cpc	r13, r1
    1b3a:	19 f0       	breq	.+6      	; 0x1b42 <chIQReadTimeout+0x36>
      nfy(iqp);
    1b3c:	ce 01       	movw	r24, r28
    1b3e:	f6 01       	movw	r30, r12
    1b40:	09 95       	icall

    while (chIQIsEmptyI(iqp)) {
    1b42:	8c 81       	ldd	r24, Y+4	; 0x04
    1b44:	9d 81       	ldd	r25, Y+5	; 0x05
    1b46:	00 97       	sbiw	r24, 0x00	; 0
    1b48:	a9 f4       	brne	.+42     	; 0x1b74 <chIQReadTimeout+0x68>
      if (qwait((GenericQueue *)iqp, time) != Q_OK) {
    1b4a:	b8 01       	movw	r22, r16
    1b4c:	ce 01       	movw	r24, r28
    1b4e:	0e 94 a2 0c 	call	0x1944	; 0x1944 <qwait>
    1b52:	89 2b       	or	r24, r25
    1b54:	b1 f3       	breq	.-20     	; 0x1b42 <chIQReadTimeout+0x36>
        chSysUnlock();
    1b56:	78 94       	sei
    if (--n == 0)
      return r;

    chSysLock();
  }
}
    1b58:	c7 01       	movw	r24, r14
    1b5a:	df 91       	pop	r29
    1b5c:	cf 91       	pop	r28
    1b5e:	1f 91       	pop	r17
    1b60:	0f 91       	pop	r16
    1b62:	ff 90       	pop	r15
    1b64:	ef 90       	pop	r14
    1b66:	df 90       	pop	r13
    1b68:	cf 90       	pop	r12
    1b6a:	bf 90       	pop	r11
    1b6c:	af 90       	pop	r10
    1b6e:	9f 90       	pop	r9
    1b70:	8f 90       	pop	r8
    1b72:	08 95       	ret
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
    1b74:	01 97       	sbiw	r24, 0x01	; 1
    1b76:	9d 83       	std	Y+5, r25	; 0x05
    1b78:	8c 83       	std	Y+4, r24	; 0x04
    *bp++ = *iqp->q_rdptr++;
    1b7a:	ec 85       	ldd	r30, Y+12	; 0x0c
    1b7c:	fd 85       	ldd	r31, Y+13	; 0x0d
    1b7e:	81 91       	ld	r24, Z+
    1b80:	d5 01       	movw	r26, r10
    1b82:	8d 93       	st	X+, r24
    1b84:	5d 01       	movw	r10, r26
    1b86:	fd 87       	std	Y+13, r31	; 0x0d
    1b88:	ec 87       	std	Y+12, r30	; 0x0c
    if (iqp->q_rdptr >= iqp->q_top)
    1b8a:	88 85       	ldd	r24, Y+8	; 0x08
    1b8c:	99 85       	ldd	r25, Y+9	; 0x09
    1b8e:	e8 17       	cp	r30, r24
    1b90:	f9 07       	cpc	r31, r25
    1b92:	48 f4       	brcc	.+18     	; 0x1ba6 <chIQReadTimeout+0x9a>
      iqp->q_rdptr = iqp->q_buffer;

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    1b94:	78 94       	sei
    r++;
    1b96:	bf ef       	ldi	r27, 0xFF	; 255
    1b98:	eb 1a       	sub	r14, r27
    1b9a:	fb 0a       	sbc	r15, r27
    if (--n == 0)
    1b9c:	8e 14       	cp	r8, r14
    1b9e:	9f 04       	cpc	r9, r15
    1ba0:	d9 f2       	breq	.-74     	; 0x1b58 <chIQReadTimeout+0x4c>
      return r;

    chSysLock();
    1ba2:	f8 94       	cli
  }
    1ba4:	c8 cf       	rjmp	.-112    	; 0x1b36 <chIQReadTimeout+0x2a>
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
    if (iqp->q_rdptr >= iqp->q_top)
      iqp->q_rdptr = iqp->q_buffer;
    1ba6:	8e 81       	ldd	r24, Y+6	; 0x06
    1ba8:	9f 81       	ldd	r25, Y+7	; 0x07
    1baa:	9d 87       	std	Y+13, r25	; 0x0d
    1bac:	8c 87       	std	Y+12, r24	; 0x0c
    1bae:	f2 cf       	rjmp	.-28     	; 0x1b94 <chIQReadTimeout+0x88>

00001bb0 <chOQInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQInit(OutputQueue *oqp, uint8_t *bp, size_t size, qnotify_t onfy,
              void *link) {
    1bb0:	0f 93       	push	r16
    1bb2:	1f 93       	push	r17
    1bb4:	fc 01       	movw	r30, r24

  queue_init(&oqp->q_waiting);
    1bb6:	82 83       	std	Z+2, r24	; 0x02
    1bb8:	f3 83       	std	Z+3, r31	; 0x03
    1bba:	80 83       	st	Z, r24
    1bbc:	f1 83       	std	Z+1, r31	; 0x01
  oqp->q_counter = size;
    1bbe:	55 83       	std	Z+5, r21	; 0x05
    1bc0:	44 83       	std	Z+4, r20	; 0x04
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
    1bc2:	73 87       	std	Z+11, r23	; 0x0b
    1bc4:	62 87       	std	Z+10, r22	; 0x0a
    1bc6:	75 87       	std	Z+13, r23	; 0x0d
    1bc8:	64 87       	std	Z+12, r22	; 0x0c
    1bca:	77 83       	std	Z+7, r23	; 0x07
    1bcc:	66 83       	std	Z+6, r22	; 0x06
  oqp->q_top = bp + size;
    1bce:	64 0f       	add	r22, r20
    1bd0:	75 1f       	adc	r23, r21
    1bd2:	71 87       	std	Z+9, r23	; 0x09
    1bd4:	60 87       	std	Z+8, r22	; 0x08
  oqp->q_notify = onfy;
    1bd6:	37 87       	std	Z+15, r19	; 0x0f
    1bd8:	26 87       	std	Z+14, r18	; 0x0e
  oqp->q_link = link;
    1bda:	11 8b       	std	Z+17, r17	; 0x11
    1bdc:	00 8b       	std	Z+16, r16	; 0x10
}
    1bde:	1f 91       	pop	r17
    1be0:	0f 91       	pop	r16
    1be2:	08 95       	ret

00001be4 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p OutputQueue structure
 *
 * @iclass
 */
void chOQResetI(OutputQueue *oqp) {
    1be4:	0f 93       	push	r16
    1be6:	1f 93       	push	r17
    1be8:	cf 93       	push	r28
    1bea:	df 93       	push	r29
    1bec:	ec 01       	movw	r28, r24

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
    1bee:	2e 81       	ldd	r18, Y+6	; 0x06
    1bf0:	3f 81       	ldd	r19, Y+7	; 0x07
    1bf2:	3b 87       	std	Y+11, r19	; 0x0b
    1bf4:	2a 87       	std	Y+10, r18	; 0x0a
    1bf6:	3d 87       	std	Y+13, r19	; 0x0d
    1bf8:	2c 87       	std	Y+12, r18	; 0x0c
  oqp->q_counter = chQSizeI(oqp);
    1bfa:	88 85       	ldd	r24, Y+8	; 0x08
    1bfc:	99 85       	ldd	r25, Y+9	; 0x09
    1bfe:	82 1b       	sub	r24, r18
    1c00:	93 0b       	sbc	r25, r19
    1c02:	9d 83       	std	Y+5, r25	; 0x05
    1c04:	8c 83       	std	Y+4, r24	; 0x04
  while (notempty(&oqp->q_waiting))
    1c06:	88 81       	ld	r24, Y
    1c08:	99 81       	ldd	r25, Y+1	; 0x01
    1c0a:	8c 17       	cp	r24, r28
    1c0c:	9d 07       	cpc	r25, r29
    1c0e:	99 f0       	breq	.+38     	; 0x1c36 <chOQResetI+0x52>
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_RESET;
    1c10:	0e ef       	ldi	r16, 0xFE	; 254
    1c12:	1f ef       	ldi	r17, 0xFF	; 255
    1c14:	dc 01       	movw	r26, r24
    1c16:	ed 91       	ld	r30, X+
    1c18:	fc 91       	ld	r31, X
    1c1a:	f9 83       	std	Y+1, r31	; 0x01
    1c1c:	e8 83       	st	Y, r30
    1c1e:	d3 83       	std	Z+3, r29	; 0x03
    1c20:	c2 83       	std	Z+2, r28	; 0x02
    1c22:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
    1c26:	fc 01       	movw	r30, r24
    1c28:	13 8b       	std	Z+19, r17	; 0x13
    1c2a:	02 8b       	std	Z+18, r16	; 0x12

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeI(oqp);
  while (notempty(&oqp->q_waiting))
    1c2c:	88 81       	ld	r24, Y
    1c2e:	99 81       	ldd	r25, Y+1	; 0x01
    1c30:	8c 17       	cp	r24, r28
    1c32:	9d 07       	cpc	r25, r29
    1c34:	79 f7       	brne	.-34     	; 0x1c14 <chOQResetI+0x30>
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_RESET;
}
    1c36:	df 91       	pop	r29
    1c38:	cf 91       	pop	r28
    1c3a:	1f 91       	pop	r17
    1c3c:	0f 91       	pop	r16
    1c3e:	08 95       	ret

00001c40 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(OutputQueue *oqp, uint8_t b, systime_t time) {
    1c40:	ff 92       	push	r15
    1c42:	0f 93       	push	r16
    1c44:	1f 93       	push	r17
    1c46:	cf 93       	push	r28
    1c48:	df 93       	push	r29
    1c4a:	ec 01       	movw	r28, r24
    1c4c:	f6 2e       	mov	r15, r22
    1c4e:	8a 01       	movw	r16, r20

  chSysLock();
    1c50:	f8 94       	cli
  while (chOQIsFullI(oqp)) {
    1c52:	8c 81       	ldd	r24, Y+4	; 0x04
    1c54:	9d 81       	ldd	r25, Y+5	; 0x05
    1c56:	00 97       	sbiw	r24, 0x00	; 0
    1c58:	79 f4       	brne	.+30     	; 0x1c78 <chOQPutTimeout+0x38>
    msg_t msg;

    if ((msg = qwait((GenericQueue *)oqp, time)) < Q_OK) {
    1c5a:	b8 01       	movw	r22, r16
    1c5c:	ce 01       	movw	r24, r28
    1c5e:	0e 94 a2 0c 	call	0x1944	; 0x1944 <qwait>
    1c62:	9c 01       	movw	r18, r24
    1c64:	97 ff       	sbrs	r25, 7
    1c66:	f5 cf       	rjmp	.-22     	; 0x1c52 <chOQPutTimeout+0x12>
      chSysUnlock();
    1c68:	78 94       	sei
  if (oqp->q_notify)
    oqp->q_notify(oqp);

  chSysUnlock();
  return Q_OK;
}
    1c6a:	c9 01       	movw	r24, r18
    1c6c:	df 91       	pop	r29
    1c6e:	cf 91       	pop	r28
    1c70:	1f 91       	pop	r17
    1c72:	0f 91       	pop	r16
    1c74:	ff 90       	pop	r15
    1c76:	08 95       	ret
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
    1c78:	01 97       	sbiw	r24, 0x01	; 1
    1c7a:	9d 83       	std	Y+5, r25	; 0x05
    1c7c:	8c 83       	std	Y+4, r24	; 0x04
  *oqp->q_wrptr++ = b;
    1c7e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c80:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c82:	f1 92       	st	Z+, r15
    1c84:	fb 87       	std	Y+11, r31	; 0x0b
    1c86:	ea 87       	std	Y+10, r30	; 0x0a
  if (oqp->q_wrptr >= oqp->q_top)
    1c88:	88 85       	ldd	r24, Y+8	; 0x08
    1c8a:	99 85       	ldd	r25, Y+9	; 0x09
    1c8c:	e8 17       	cp	r30, r24
    1c8e:	f9 07       	cpc	r31, r25
    1c90:	20 f0       	brcs	.+8      	; 0x1c9a <chOQPutTimeout+0x5a>
    oqp->q_wrptr = oqp->q_buffer;
    1c92:	8e 81       	ldd	r24, Y+6	; 0x06
    1c94:	9f 81       	ldd	r25, Y+7	; 0x07
    1c96:	9b 87       	std	Y+11, r25	; 0x0b
    1c98:	8a 87       	std	Y+10, r24	; 0x0a

  if (oqp->q_notify)
    1c9a:	ee 85       	ldd	r30, Y+14	; 0x0e
    1c9c:	ff 85       	ldd	r31, Y+15	; 0x0f
    1c9e:	30 97       	sbiw	r30, 0x00	; 0
    1ca0:	11 f0       	breq	.+4      	; 0x1ca6 <chOQPutTimeout+0x66>
    oqp->q_notify(oqp);
    1ca2:	ce 01       	movw	r24, r28
    1ca4:	09 95       	icall

  chSysUnlock();
    1ca6:	78 94       	sei
  return Q_OK;
    1ca8:	20 e0       	ldi	r18, 0x00	; 0
    1caa:	30 e0       	ldi	r19, 0x00	; 0
}
    1cac:	c9 01       	movw	r24, r18
    1cae:	df 91       	pop	r29
    1cb0:	cf 91       	pop	r28
    1cb2:	1f 91       	pop	r17
    1cb4:	0f 91       	pop	r16
    1cb6:	ff 90       	pop	r15
    1cb8:	08 95       	ret

00001cba <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(OutputQueue *oqp) {
    1cba:	1f 93       	push	r17
    1cbc:	cf 93       	push	r28
    1cbe:	df 93       	push	r29
    1cc0:	fc 01       	movw	r30, r24
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
    1cc2:	a4 85       	ldd	r26, Z+12	; 0x0c
    1cc4:	b5 85       	ldd	r27, Z+13	; 0x0d
    1cc6:	82 85       	ldd	r24, Z+10	; 0x0a
    1cc8:	93 85       	ldd	r25, Z+11	; 0x0b
    1cca:	8a 17       	cp	r24, r26
    1ccc:	9b 07       	cpc	r25, r27
    1cce:	61 f1       	breq	.+88     	; 0x1d28 <chOQGetI+0x6e>
    1cd0:	84 81       	ldd	r24, Z+4	; 0x04
    1cd2:	95 81       	ldd	r25, Z+5	; 0x05
    return Q_EMPTY;

  oqp->q_counter++;
    1cd4:	01 96       	adiw	r24, 0x01	; 1
    1cd6:	95 83       	std	Z+5, r25	; 0x05
    1cd8:	84 83       	std	Z+4, r24	; 0x04
  b = *oqp->q_rdptr++;
    1cda:	1d 91       	ld	r17, X+
    1cdc:	b5 87       	std	Z+13, r27	; 0x0d
    1cde:	a4 87       	std	Z+12, r26	; 0x0c
  if (oqp->q_rdptr >= oqp->q_top)
    1ce0:	80 85       	ldd	r24, Z+8	; 0x08
    1ce2:	91 85       	ldd	r25, Z+9	; 0x09
    1ce4:	a8 17       	cp	r26, r24
    1ce6:	b9 07       	cpc	r27, r25
    1ce8:	d0 f4       	brcc	.+52     	; 0x1d1e <chOQGetI+0x64>
    oqp->q_rdptr = oqp->q_buffer;

  if (notempty(&oqp->q_waiting))
    1cea:	80 81       	ld	r24, Z
    1cec:	91 81       	ldd	r25, Z+1	; 0x01
    1cee:	8e 17       	cp	r24, r30
    1cf0:	9f 07       	cpc	r25, r31
    1cf2:	71 f0       	breq	.+28     	; 0x1d10 <chOQGetI+0x56>
    1cf4:	ec 01       	movw	r28, r24
    1cf6:	a8 81       	ld	r26, Y
    1cf8:	b9 81       	ldd	r27, Y+1	; 0x01
    1cfa:	b1 83       	std	Z+1, r27	; 0x01
    1cfc:	a0 83       	st	Z, r26
    1cfe:	13 96       	adiw	r26, 0x03	; 3
    1d00:	fc 93       	st	X, r31
    1d02:	ee 93       	st	-X, r30
    1d04:	12 97       	sbiw	r26, 0x02	; 2
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_OK;
    1d06:	0e 94 78 02 	call	0x4f0	; 0x4f0 <chSchReadyI>
    1d0a:	fc 01       	movw	r30, r24
    1d0c:	13 8a       	std	Z+19, r1	; 0x13
    1d0e:	12 8a       	std	Z+18, r1	; 0x12

  return b;
    1d10:	21 2f       	mov	r18, r17
    1d12:	30 e0       	ldi	r19, 0x00	; 0
}
    1d14:	c9 01       	movw	r24, r18
    1d16:	df 91       	pop	r29
    1d18:	cf 91       	pop	r28
    1d1a:	1f 91       	pop	r17
    1d1c:	08 95       	ret
    return Q_EMPTY;

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top)
    oqp->q_rdptr = oqp->q_buffer;
    1d1e:	86 81       	ldd	r24, Z+6	; 0x06
    1d20:	97 81       	ldd	r25, Z+7	; 0x07
    1d22:	95 87       	std	Z+13, r25	; 0x0d
    1d24:	84 87       	std	Z+12, r24	; 0x0c
    1d26:	e1 cf       	rjmp	.-62     	; 0x1cea <chOQGetI+0x30>
msg_t chOQGetI(OutputQueue *oqp) {
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
    1d28:	84 81       	ldd	r24, Z+4	; 0x04
    1d2a:	95 81       	ldd	r25, Z+5	; 0x05
    1d2c:	89 2b       	or	r24, r25
    1d2e:	19 f4       	brne	.+6      	; 0x1d36 <chOQGetI+0x7c>
    1d30:	80 e0       	ldi	r24, 0x00	; 0
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	cf cf       	rjmp	.-98     	; 0x1cd4 <chOQGetI+0x1a>
    return Q_EMPTY;
    1d36:	2d ef       	ldi	r18, 0xFD	; 253
    1d38:	3f ef       	ldi	r19, 0xFF	; 255
    1d3a:	ec cf       	rjmp	.-40     	; 0x1d14 <chOQGetI+0x5a>

00001d3c <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
    1d3c:	8f 92       	push	r8
    1d3e:	9f 92       	push	r9
    1d40:	af 92       	push	r10
    1d42:	bf 92       	push	r11
    1d44:	cf 92       	push	r12
    1d46:	df 92       	push	r13
    1d48:	ef 92       	push	r14
    1d4a:	ff 92       	push	r15
    1d4c:	0f 93       	push	r16
    1d4e:	1f 93       	push	r17
    1d50:	cf 93       	push	r28
    1d52:	df 93       	push	r29
    1d54:	ec 01       	movw	r28, r24
    1d56:	7b 01       	movw	r14, r22
    1d58:	4a 01       	movw	r8, r20
    1d5a:	59 01       	movw	r10, r18
  qnotify_t nfy = oqp->q_notify;
    1d5c:	ce 84       	ldd	r12, Y+14	; 0x0e
    1d5e:	df 84       	ldd	r13, Y+15	; 0x0f
  size_t w = 0;

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
    1d60:	f8 94       	cli
 * @api
 */
size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
    1d62:	00 e0       	ldi	r16, 0x00	; 0
    1d64:	10 e0       	ldi	r17, 0x00	; 0

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
  while (TRUE) {
    while (chOQIsFullI(oqp)) {
    1d66:	8c 81       	ldd	r24, Y+4	; 0x04
    1d68:	9d 81       	ldd	r25, Y+5	; 0x05
    1d6a:	00 97       	sbiw	r24, 0x00	; 0
    1d6c:	31 f1       	breq	.+76     	; 0x1dba <chOQWriteTimeout+0x7e>
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    1d6e:	01 97       	sbiw	r24, 0x01	; 1
    1d70:	9d 83       	std	Y+5, r25	; 0x05
    1d72:	8c 83       	std	Y+4, r24	; 0x04
    *oqp->q_wrptr++ = *bp++;
    1d74:	f7 01       	movw	r30, r14
    1d76:	81 91       	ld	r24, Z+
    1d78:	7f 01       	movw	r14, r30
    1d7a:	aa 85       	ldd	r26, Y+10	; 0x0a
    1d7c:	bb 85       	ldd	r27, Y+11	; 0x0b
    1d7e:	8d 93       	st	X+, r24
    1d80:	bb 87       	std	Y+11, r27	; 0x0b
    1d82:	aa 87       	std	Y+10, r26	; 0x0a
    if (oqp->q_wrptr >= oqp->q_top)
    1d84:	88 85       	ldd	r24, Y+8	; 0x08
    1d86:	99 85       	ldd	r25, Y+9	; 0x09
    1d88:	a8 17       	cp	r26, r24
    1d8a:	b9 07       	cpc	r27, r25
    1d8c:	20 f0       	brcs	.+8      	; 0x1d96 <chOQWriteTimeout+0x5a>
      oqp->q_wrptr = oqp->q_buffer;
    1d8e:	8e 81       	ldd	r24, Y+6	; 0x06
    1d90:	9f 81       	ldd	r25, Y+7	; 0x07
    1d92:	9b 87       	std	Y+11, r25	; 0x0b
    1d94:	8a 87       	std	Y+10, r24	; 0x0a

    if (nfy)
    1d96:	c1 14       	cp	r12, r1
    1d98:	d1 04       	cpc	r13, r1
    1d9a:	19 f0       	breq	.+6      	; 0x1da2 <chOQWriteTimeout+0x66>
      nfy(oqp);
    1d9c:	ce 01       	movw	r24, r28
    1d9e:	f6 01       	movw	r30, r12
    1da0:	09 95       	icall

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    1da2:	78 94       	sei
    w++;
    1da4:	0f 5f       	subi	r16, 0xFF	; 255
    1da6:	1f 4f       	sbci	r17, 0xFF	; 255
    if (--n == 0)
    1da8:	f1 e0       	ldi	r31, 0x01	; 1
    1daa:	8f 1a       	sub	r8, r31
    1dac:	91 08       	sbc	r9, r1
    1dae:	61 f0       	breq	.+24     	; 0x1dc8 <chOQWriteTimeout+0x8c>
      return w;
    chSysLock();
    1db0:	f8 94       	cli

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
  while (TRUE) {
    while (chOQIsFullI(oqp)) {
    1db2:	8c 81       	ldd	r24, Y+4	; 0x04
    1db4:	9d 81       	ldd	r25, Y+5	; 0x05
    1db6:	00 97       	sbiw	r24, 0x00	; 0
    1db8:	d1 f6       	brne	.-76     	; 0x1d6e <chOQWriteTimeout+0x32>
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
    1dba:	b5 01       	movw	r22, r10
    1dbc:	ce 01       	movw	r24, r28
    1dbe:	0e 94 a2 0c 	call	0x1944	; 0x1944 <qwait>
    1dc2:	89 2b       	or	r24, r25
    1dc4:	81 f2       	breq	.-96     	; 0x1d66 <chOQWriteTimeout+0x2a>
        chSysUnlock();
    1dc6:	78 94       	sei
    w++;
    if (--n == 0)
      return w;
    chSysLock();
  }
}
    1dc8:	c8 01       	movw	r24, r16
    1dca:	df 91       	pop	r29
    1dcc:	cf 91       	pop	r28
    1dce:	1f 91       	pop	r17
    1dd0:	0f 91       	pop	r16
    1dd2:	ff 90       	pop	r15
    1dd4:	ef 90       	pop	r14
    1dd6:	df 90       	pop	r13
    1dd8:	cf 90       	pop	r12
    1dda:	bf 90       	pop	r11
    1ddc:	af 90       	pop	r10
    1dde:	9f 90       	pop	r9
    1de0:	8f 90       	pop	r8
    1de2:	08 95       	ret

00001de4 <tmr>:

static VirtualTimer vt;
static void tmr(void *p) {
  (void)p;

  test_timer_done = TRUE;
    1de4:	81 e0       	ldi	r24, 0x01	; 1
    1de6:	80 93 3e 0c 	sts	0x0C3E, r24
    1dea:	08 95       	ret

00001dec <print_line>:
    tcp->teardown();

  test_wait_threads();
}

static void print_line(void) {
    1dec:	cf 93       	push	r28
    1dee:	df 93       	push	r29
    1df0:	cc e4       	ldi	r28, 0x4C	; 76
    1df2:	d0 e0       	ldi	r29, 0x00	; 0
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
    1df4:	80 91 ce 0a 	lds	r24, 0x0ACE
    1df8:	90 91 cf 0a 	lds	r25, 0x0ACF
    1dfc:	dc 01       	movw	r26, r24
    1dfe:	ed 91       	ld	r30, X+
    1e00:	fc 91       	ld	r31, X
    1e02:	04 80       	ldd	r0, Z+4	; 0x04
    1e04:	f5 81       	ldd	r31, Z+5	; 0x05
    1e06:	e0 2d       	mov	r30, r0
    1e08:	6d e2       	ldi	r22, 0x2D	; 45
    1e0a:	09 95       	icall
    1e0c:	21 97       	sbiw	r28, 0x01	; 1
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
    1e0e:	91 f7       	brne	.-28     	; 0x1df4 <print_line+0x8>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
    1e10:	80 91 ce 0a 	lds	r24, 0x0ACE
    1e14:	90 91 cf 0a 	lds	r25, 0x0ACF
    1e18:	dc 01       	movw	r26, r24
    1e1a:	ed 91       	ld	r30, X+
    1e1c:	fc 91       	ld	r31, X
    1e1e:	01 90       	ld	r0, Z+
    1e20:	f0 81       	ld	r31, Z
    1e22:	e0 2d       	mov	r30, r0
    1e24:	42 e0       	ldi	r20, 0x02	; 2
    1e26:	50 e0       	ldi	r21, 0x00	; 0
    1e28:	61 e6       	ldi	r22, 0x61	; 97
    1e2a:	74 e0       	ldi	r23, 0x04	; 4
}
    1e2c:	df 91       	pop	r29
    1e2e:	cf 91       	pop	r28
static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
    1e30:	09 94       	ijmp

00001e32 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
    1e32:	8f 92       	push	r8
    1e34:	9f 92       	push	r9
    1e36:	af 92       	push	r10
    1e38:	bf 92       	push	r11
    1e3a:	ef 92       	push	r14
    1e3c:	ff 92       	push	r15
    1e3e:	0f 93       	push	r16
    1e40:	1f 93       	push	r17
    1e42:	cf 93       	push	r28
    1e44:	df 93       	push	r29
    1e46:	cd b7       	in	r28, 0x3d	; 61
    1e48:	de b7       	in	r29, 0x3e	; 62
    1e4a:	60 97       	sbiw	r28, 0x10	; 16
    1e4c:	0f b6       	in	r0, 0x3f	; 63
    1e4e:	f8 94       	cli
    1e50:	de bf       	out	0x3e, r29	; 62
    1e52:	0f be       	out	0x3f, r0	; 63
    1e54:	cd bf       	out	0x3d, r28	; 61
  char buf[16], *p;

  if (!n)
    1e56:	61 15       	cp	r22, r1
    1e58:	71 05       	cpc	r23, r1
    1e5a:	81 05       	cpc	r24, r1
    1e5c:	91 05       	cpc	r25, r1
    1e5e:	09 f4       	brne	.+2      	; 0x1e62 <test_printn+0x30>
    1e60:	45 c0       	rjmp	.+138    	; 0x1eec <test_printn+0xba>
    1e62:	ee 24       	eor	r14, r14
    1e64:	e3 94       	inc	r14
    1e66:	f1 2c       	mov	r15, r1
    1e68:	ec 0e       	add	r14, r28
    1e6a:	fd 1e       	adc	r15, r29
    1e6c:	87 01       	movw	r16, r14
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    1e6e:	3a e0       	ldi	r19, 0x0A	; 10
    1e70:	83 2e       	mov	r8, r19
    1e72:	91 2c       	mov	r9, r1
    1e74:	a1 2c       	mov	r10, r1
    1e76:	b1 2c       	mov	r11, r1
    1e78:	a5 01       	movw	r20, r10
    1e7a:	94 01       	movw	r18, r8
    1e7c:	0e 94 ea 32 	call	0x65d4	; 0x65d4 <__udivmodsi4>
    1e80:	a6 2f       	mov	r26, r22
    1e82:	a0 5d       	subi	r26, 0xD0	; 208
    1e84:	f8 01       	movw	r30, r16
    1e86:	a1 93       	st	Z+, r26
    1e88:	8f 01       	movw	r16, r30
    1e8a:	b9 01       	movw	r22, r18
    1e8c:	ca 01       	movw	r24, r20

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
    1e8e:	61 15       	cp	r22, r1
    1e90:	71 05       	cpc	r23, r1
    1e92:	81 05       	cpc	r24, r1
    1e94:	91 05       	cpc	r25, r1
    1e96:	81 f7       	brne	.-32     	; 0x1e78 <test_printn+0x46>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
    1e98:	ee 16       	cp	r14, r30
    1e9a:	ff 06       	cpc	r15, r31
    1e9c:	b0 f4       	brcc	.+44     	; 0x1eca <test_printn+0x98>
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
    1e9e:	01 50       	subi	r16, 0x01	; 1
    1ea0:	11 09       	sbc	r17, r1
    1ea2:	03 c0       	rjmp	.+6      	; 0x1eaa <test_printn+0x78>
    1ea4:	f8 01       	movw	r30, r16
    1ea6:	a2 91       	ld	r26, -Z
    1ea8:	8f 01       	movw	r16, r30
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
      chSequentialStreamPut(chp, *--p);
    1eaa:	80 91 ce 0a 	lds	r24, 0x0ACE
    1eae:	90 91 cf 0a 	lds	r25, 0x0ACF
    1eb2:	fc 01       	movw	r30, r24
    1eb4:	20 81       	ld	r18, Z
    1eb6:	31 81       	ldd	r19, Z+1	; 0x01
    1eb8:	f9 01       	movw	r30, r18
    1eba:	24 81       	ldd	r18, Z+4	; 0x04
    1ebc:	35 81       	ldd	r19, Z+5	; 0x05
    1ebe:	6a 2f       	mov	r22, r26
    1ec0:	f9 01       	movw	r30, r18
    1ec2:	09 95       	icall
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
    1ec4:	0e 15       	cp	r16, r14
    1ec6:	1f 05       	cpc	r17, r15
    1ec8:	69 f7       	brne	.-38     	; 0x1ea4 <test_printn+0x72>
      chSequentialStreamPut(chp, *--p);
  }
}
    1eca:	60 96       	adiw	r28, 0x10	; 16
    1ecc:	0f b6       	in	r0, 0x3f	; 63
    1ece:	f8 94       	cli
    1ed0:	de bf       	out	0x3e, r29	; 62
    1ed2:	0f be       	out	0x3f, r0	; 63
    1ed4:	cd bf       	out	0x3d, r28	; 61
    1ed6:	df 91       	pop	r29
    1ed8:	cf 91       	pop	r28
    1eda:	1f 91       	pop	r17
    1edc:	0f 91       	pop	r16
    1ede:	ff 90       	pop	r15
    1ee0:	ef 90       	pop	r14
    1ee2:	bf 90       	pop	r11
    1ee4:	af 90       	pop	r10
    1ee6:	9f 90       	pop	r9
    1ee8:	8f 90       	pop	r8
    1eea:	08 95       	ret
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
    1eec:	80 91 ce 0a 	lds	r24, 0x0ACE
    1ef0:	90 91 cf 0a 	lds	r25, 0x0ACF
    1ef4:	dc 01       	movw	r26, r24
    1ef6:	ed 91       	ld	r30, X+
    1ef8:	fc 91       	ld	r31, X
    1efa:	04 80       	ldd	r0, Z+4	; 0x04
    1efc:	f5 81       	ldd	r31, Z+5	; 0x05
    1efe:	e0 2d       	mov	r30, r0
    1f00:	60 e3       	ldi	r22, 0x30	; 48
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
      chSequentialStreamPut(chp, *--p);
  }
}
    1f02:	60 96       	adiw	r28, 0x10	; 16
    1f04:	0f b6       	in	r0, 0x3f	; 63
    1f06:	f8 94       	cli
    1f08:	de bf       	out	0x3e, r29	; 62
    1f0a:	0f be       	out	0x3f, r0	; 63
    1f0c:	cd bf       	out	0x3d, r28	; 61
    1f0e:	df 91       	pop	r29
    1f10:	cf 91       	pop	r28
    1f12:	1f 91       	pop	r17
    1f14:	0f 91       	pop	r16
    1f16:	ff 90       	pop	r15
    1f18:	ef 90       	pop	r14
    1f1a:	bf 90       	pop	r11
    1f1c:	af 90       	pop	r10
    1f1e:	9f 90       	pop	r9
    1f20:	8f 90       	pop	r8
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
    1f22:	09 94       	ijmp

00001f24 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
    1f24:	cf 93       	push	r28
    1f26:	df 93       	push	r29

  while (*msgp)
    1f28:	dc 01       	movw	r26, r24
    1f2a:	6c 91       	ld	r22, X
    1f2c:	66 23       	and	r22, r22
    1f2e:	81 f0       	breq	.+32     	; 0x1f50 <test_print+0x2c>
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
    1f30:	ec 01       	movw	r28, r24
    1f32:	21 96       	adiw	r28, 0x01	; 1

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
    1f34:	80 91 ce 0a 	lds	r24, 0x0ACE
    1f38:	90 91 cf 0a 	lds	r25, 0x0ACF
    1f3c:	dc 01       	movw	r26, r24
    1f3e:	ed 91       	ld	r30, X+
    1f40:	fc 91       	ld	r31, X
    1f42:	04 80       	ldd	r0, Z+4	; 0x04
    1f44:	f5 81       	ldd	r31, Z+5	; 0x05
    1f46:	e0 2d       	mov	r30, r0
    1f48:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    1f4a:	69 91       	ld	r22, Y+
    1f4c:	61 11       	cpse	r22, r1
    1f4e:	f2 cf       	rjmp	.-28     	; 0x1f34 <test_print+0x10>
    chSequentialStreamPut(chp, *msgp++);
}
    1f50:	df 91       	pop	r29
    1f52:	cf 91       	pop	r28
    1f54:	08 95       	ret

00001f56 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
    1f56:	cf 93       	push	r28
    1f58:	df 93       	push	r29
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    1f5a:	dc 01       	movw	r26, r24
    1f5c:	6c 91       	ld	r22, X
    1f5e:	66 23       	and	r22, r22
    1f60:	81 f0       	breq	.+32     	; 0x1f82 <test_println+0x2c>
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
    1f62:	ec 01       	movw	r28, r24
    1f64:	21 96       	adiw	r28, 0x01	; 1
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
    1f66:	80 91 ce 0a 	lds	r24, 0x0ACE
    1f6a:	90 91 cf 0a 	lds	r25, 0x0ACF
    1f6e:	dc 01       	movw	r26, r24
    1f70:	ed 91       	ld	r30, X+
    1f72:	fc 91       	ld	r31, X
    1f74:	04 80       	ldd	r0, Z+4	; 0x04
    1f76:	f5 81       	ldd	r31, Z+5	; 0x05
    1f78:	e0 2d       	mov	r30, r0
    1f7a:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    1f7c:	69 91       	ld	r22, Y+
    1f7e:	61 11       	cpse	r22, r1
    1f80:	f2 cf       	rjmp	.-28     	; 0x1f66 <test_println+0x10>
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
    1f82:	80 91 ce 0a 	lds	r24, 0x0ACE
    1f86:	90 91 cf 0a 	lds	r25, 0x0ACF
    1f8a:	dc 01       	movw	r26, r24
    1f8c:	ed 91       	ld	r30, X+
    1f8e:	fc 91       	ld	r31, X
    1f90:	01 90       	ld	r0, Z+
    1f92:	f0 81       	ld	r31, Z
    1f94:	e0 2d       	mov	r30, r0
    1f96:	42 e0       	ldi	r20, 0x02	; 2
    1f98:	50 e0       	ldi	r21, 0x00	; 0
    1f9a:	61 e6       	ldi	r22, 0x61	; 97
    1f9c:	74 e0       	ldi	r23, 0x04	; 4
}
    1f9e:	df 91       	pop	r29
    1fa0:	cf 91       	pop	r28
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
    1fa2:	09 94       	ijmp

00001fa4 <test_emit_token>:
 *
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {

  chSysLock();
    1fa4:	f8 94       	cli
  *tokp++ = token;
    1fa6:	e0 91 d0 0a 	lds	r30, 0x0AD0
    1faa:	f0 91 d1 0a 	lds	r31, 0x0AD1
    1fae:	81 93       	st	Z+, r24
    1fb0:	f0 93 d1 0a 	sts	0x0AD1, r31
    1fb4:	e0 93 d0 0a 	sts	0x0AD0, r30
  chSysUnlock();
    1fb8:	78 94       	sei
    1fba:	08 95       	ret

00001fbc <_test_fail>:
/*
 * Assertions.
 */
bool_t _test_fail(unsigned point) {

  local_fail = TRUE;
    1fbc:	21 e0       	ldi	r18, 0x01	; 1
    1fbe:	20 93 d2 0a 	sts	0x0AD2, r18
  global_fail = TRUE;
    1fc2:	20 93 d3 0a 	sts	0x0AD3, r18
  failpoint = point;
    1fc6:	90 93 d5 0a 	sts	0x0AD5, r25
    1fca:	80 93 d4 0a 	sts	0x0AD4, r24
  return TRUE;
}
    1fce:	81 e0       	ldi	r24, 0x01	; 1
    1fd0:	08 95       	ret

00001fd2 <_test_assert>:

bool_t _test_assert(unsigned point, bool_t condition) {

  if (!condition)
    1fd2:	61 11       	cpse	r22, r1
    1fd4:	0b c0       	rjmp	.+22     	; 0x1fec <_test_assert+0x1a>
/*
 * Assertions.
 */
bool_t _test_fail(unsigned point) {

  local_fail = TRUE;
    1fd6:	21 e0       	ldi	r18, 0x01	; 1
    1fd8:	20 93 d2 0a 	sts	0x0AD2, r18
  global_fail = TRUE;
    1fdc:	20 93 d3 0a 	sts	0x0AD3, r18
  failpoint = point;
    1fe0:	90 93 d5 0a 	sts	0x0AD5, r25
    1fe4:	80 93 d4 0a 	sts	0x0AD4, r24
}

bool_t _test_assert(unsigned point, bool_t condition) {

  if (!condition)
    return _test_fail(point);
    1fe8:	81 e0       	ldi	r24, 0x01	; 1
    1fea:	08 95       	ret
  return FALSE;
    1fec:	80 e0       	ldi	r24, 0x00	; 0
}
    1fee:	08 95       	ret

00001ff0 <_test_assert_sequence>:

bool_t _test_assert_sequence(unsigned point, char *expected) {
    1ff0:	fb 01       	movw	r30, r22
    1ff2:	40 91 d0 0a 	lds	r20, 0x0AD0
    1ff6:	50 91 d1 0a 	lds	r21, 0x0AD1
    1ffa:	26 ed       	ldi	r18, 0xD6	; 214
    1ffc:	3a e0       	ldi	r19, 0x0A	; 10
  char *cp = tokens_buffer;
  while (cp < tokp) {
    1ffe:	06 c0       	rjmp	.+12     	; 0x200c <_test_assert_sequence+0x1c>
    2000:	2f 5f       	subi	r18, 0xFF	; 255
    2002:	3f 4f       	sbci	r19, 0xFF	; 255
    if (*cp++ != *expected++)
    2004:	61 91       	ld	r22, Z+
    2006:	7c 91       	ld	r23, X
    2008:	76 13       	cpse	r23, r22
    200a:	0f c0       	rjmp	.+30     	; 0x202a <_test_assert_sequence+0x3a>
    200c:	d9 01       	movw	r26, r18
  return FALSE;
}

bool_t _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
    200e:	24 17       	cp	r18, r20
    2010:	35 07       	cpc	r19, r21
    2012:	b0 f3       	brcs	.-20     	; 0x2000 <_test_assert_sequence+0x10>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
    2014:	20 81       	ld	r18, Z
    2016:	21 11       	cpse	r18, r1
    2018:	08 c0       	rjmp	.+16     	; 0x202a <_test_assert_sequence+0x3a>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
    201a:	86 ed       	ldi	r24, 0xD6	; 214
    201c:	9a e0       	ldi	r25, 0x0A	; 10
    201e:	90 93 d1 0a 	sts	0x0AD1, r25
    2022:	80 93 d0 0a 	sts	0x0AD0, r24
     return _test_fail(point);
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
    2026:	80 e0       	ldi	r24, 0x00	; 0
}
    2028:	08 95       	ret
/*
 * Assertions.
 */
bool_t _test_fail(unsigned point) {

  local_fail = TRUE;
    202a:	21 e0       	ldi	r18, 0x01	; 1
    202c:	20 93 d2 0a 	sts	0x0AD2, r18
  global_fail = TRUE;
    2030:	20 93 d3 0a 	sts	0x0AD3, r18
  failpoint = point;
    2034:	90 93 d5 0a 	sts	0x0AD5, r25
    2038:	80 93 d4 0a 	sts	0x0AD4, r24
  while (cp < tokp) {
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
    return _test_fail(point);
    203c:	81 e0       	ldi	r24, 0x01	; 1
    203e:	08 95       	ret

00002040 <_test_assert_time_window>:
  clear_tokens();
  return FALSE;
}

bool_t _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
    2040:	cf 93       	push	r28
    2042:	df 93       	push	r29
    2044:	ec 01       	movw	r28, r24
    2046:	cb 01       	movw	r24, r22

  return _test_assert(point, chTimeIsWithin(start, end));
    2048:	ba 01       	movw	r22, r20
    204a:	0e 94 03 02 	call	0x406	; 0x406 <chTimeIsWithin>
  return TRUE;
}

bool_t _test_assert(unsigned point, bool_t condition) {

  if (!condition)
    204e:	81 11       	cpse	r24, r1
    2050:	0c c0       	rjmp	.+24     	; 0x206a <_test_assert_time_window+0x2a>
/*
 * Assertions.
 */
bool_t _test_fail(unsigned point) {

  local_fail = TRUE;
    2052:	81 e0       	ldi	r24, 0x01	; 1
    2054:	80 93 d2 0a 	sts	0x0AD2, r24
  global_fail = TRUE;
    2058:	80 93 d3 0a 	sts	0x0AD3, r24
  failpoint = point;
    205c:	d0 93 d5 0a 	sts	0x0AD5, r29
    2060:	c0 93 d4 0a 	sts	0x0AD4, r28
}

bool_t _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chTimeIsWithin(start, end));
}
    2064:	df 91       	pop	r29
    2066:	cf 91       	pop	r28
    2068:	08 95       	ret

bool_t _test_assert(unsigned point, bool_t condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
    206a:	80 e0       	ldi	r24, 0x00	; 0
}

bool_t _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chTimeIsWithin(start, end));
}
    206c:	df 91       	pop	r29
    206e:	cf 91       	pop	r28
    2070:	08 95       	ret

00002072 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
    2072:	cf 93       	push	r28
    2074:	df 93       	push	r29
    2076:	cf e3       	ldi	r28, 0x3F	; 63
    2078:	dc e0       	ldi	r29, 0x0C	; 12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
    207a:	89 91       	ld	r24, Y+
    207c:	99 91       	ld	r25, Y+
    207e:	00 97       	sbiw	r24, 0x00	; 0
    2080:	11 f0       	breq	.+4      	; 0x2086 <test_terminate_threads+0x14>
      chThdTerminate(threads[i]);
    2082:	0e 94 a3 04 	call	0x946	; 0x946 <chThdTerminate>
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    2086:	8c e0       	ldi	r24, 0x0C	; 12
    2088:	c9 34       	cpi	r28, 0x49	; 73
    208a:	d8 07       	cpc	r29, r24
    208c:	b1 f7       	brne	.-20     	; 0x207a <test_terminate_threads+0x8>
    if (threads[i])
      chThdTerminate(threads[i]);
}
    208e:	df 91       	pop	r29
    2090:	cf 91       	pop	r28
    2092:	08 95       	ret

00002094 <test_wait_threads>:

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
    2094:	cf 93       	push	r28
    2096:	df 93       	push	r29
    2098:	cf e3       	ldi	r28, 0x3F	; 63
    209a:	dc e0       	ldi	r29, 0x0C	; 12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
    209c:	88 81       	ld	r24, Y
    209e:	99 81       	ldd	r25, Y+1	; 0x01
    20a0:	00 97       	sbiw	r24, 0x00	; 0
    20a2:	21 f0       	breq	.+8      	; 0x20ac <test_wait_threads+0x18>
      chThdWait(threads[i]);
    20a4:	0e 94 08 05 	call	0xa10	; 0xa10 <chThdWait>
      threads[i] = NULL;
    20a8:	19 82       	std	Y+1, r1	; 0x01
    20aa:	18 82       	st	Y, r1
    20ac:	22 96       	adiw	r28, 0x02	; 2
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    20ae:	8c e0       	ldi	r24, 0x0C	; 12
    20b0:	c9 34       	cpi	r28, 0x49	; 73
    20b2:	d8 07       	cpc	r29, r24
    20b4:	99 f7       	brne	.-26     	; 0x209c <test_wait_threads+0x8>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
    20b6:	df 91       	pop	r29
    20b8:	cf 91       	pop	r28
    20ba:	08 95       	ret

000020bc <test_cpu_pulse>:
 * @param[in] duration      CPU pulse duration in milliseconds
 */
void test_cpu_pulse(unsigned duration) {
  systime_t start, end, now;

  start = chThdSelf()->p_time;
    20bc:	e0 91 3c 0c 	lds	r30, 0x0C3C
    20c0:	f0 91 3d 0c 	lds	r31, 0x0C3D
    20c4:	20 89       	ldd	r18, Z+16	; 0x10
    20c6:	31 89       	ldd	r19, Z+17	; 0x11
  end = start + MS2ST(duration);
    20c8:	a9 01       	movw	r20, r18
    20ca:	4f 5f       	subi	r20, 0xFF	; 255
    20cc:	5f 4f       	sbci	r21, 0xFF	; 255
    20ce:	a0 e0       	ldi	r26, 0x00	; 0
    20d0:	b0 e0       	ldi	r27, 0x00	; 0
    20d2:	01 97       	sbiw	r24, 0x01	; 1
    20d4:	a1 09       	sbc	r26, r1
    20d6:	b1 09       	sbc	r27, r1
    20d8:	48 0f       	add	r20, r24
    20da:	59 1f       	adc	r21, r25
  do {
    now = chThdSelf()->p_time;
    20dc:	80 89       	ldd	r24, Z+16	; 0x10
    20de:	91 89       	ldd	r25, Z+17	; 0x11
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  }
  while (end > start ? (now >= start) && (now < end) :
    20e0:	24 17       	cp	r18, r20
    20e2:	35 07       	cpc	r19, r21
    20e4:	38 f4       	brcc	.+14     	; 0x20f4 <test_cpu_pulse+0x38>
    20e6:	82 17       	cp	r24, r18
    20e8:	93 07       	cpc	r25, r19
    20ea:	50 f0       	brcs	.+20     	; 0x2100 <test_cpu_pulse+0x44>
    20ec:	84 17       	cp	r24, r20
    20ee:	95 07       	cpc	r25, r21
    20f0:	a8 f3       	brcs	.-22     	; 0x20dc <test_cpu_pulse+0x20>
    20f2:	08 95       	ret
                       (now >= start) || (now < end));
    20f4:	82 17       	cp	r24, r18
    20f6:	93 07       	cpc	r25, r19
    20f8:	88 f7       	brcc	.-30     	; 0x20dc <test_cpu_pulse+0x20>
    20fa:	84 17       	cp	r24, r20
    20fc:	95 07       	cpc	r25, r21
    20fe:	70 f3       	brcs	.-36     	; 0x20dc <test_cpu_pulse+0x20>
    2100:	08 95       	ret

00002102 <test_wait_tick>:
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {

  chThdSleep(1);
    2102:	81 e0       	ldi	r24, 0x01	; 1
    2104:	90 e0       	ldi	r25, 0x00	; 0
    2106:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  return chTimeNow();
    210a:	20 91 2f 0c 	lds	r18, 0x0C2F
    210e:	30 91 30 0c 	lds	r19, 0x0C30
}
    2112:	c9 01       	movw	r24, r18
    2114:	08 95       	ret

00002116 <test_start_timer>:
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
  test_timer_done = FALSE;
    2116:	10 92 3e 0c 	sts	0x0C3E, r1
  chVTSet(&vt, duration, tmr, NULL);
    211a:	f8 94       	cli
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
    211c:	a0 e0       	ldi	r26, 0x00	; 0
    211e:	b0 e0       	ldi	r27, 0x00	; 0
    2120:	01 97       	sbiw	r24, 0x01	; 1
    2122:	a1 09       	sbc	r26, r1
    2124:	b1 09       	sbc	r27, r1
    2126:	bc 01       	movw	r22, r24
    2128:	6f 5f       	subi	r22, 0xFF	; 255
    212a:	7f 4f       	sbci	r23, 0xFF	; 255
  test_timer_done = FALSE;
  chVTSet(&vt, duration, tmr, NULL);
    212c:	20 e0       	ldi	r18, 0x00	; 0
    212e:	30 e0       	ldi	r19, 0x00	; 0
    2130:	42 ef       	ldi	r20, 0xF2	; 242
    2132:	5e e0       	ldi	r21, 0x0E	; 14
    2134:	86 ee       	ldi	r24, 0xE6	; 230
    2136:	9a e0       	ldi	r25, 0x0A	; 10
    2138:	0e 94 a3 01 	call	0x346	; 0x346 <chVTSetI>
    213c:	78 94       	sei
    213e:	08 95       	ret

00002140 <TestThread>:
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 * @return              A failure boolean value.
 */
msg_t TestThread(void *p) {
    2140:	4f 92       	push	r4
    2142:	5f 92       	push	r5
    2144:	6f 92       	push	r6
    2146:	7f 92       	push	r7
    2148:	8f 92       	push	r8
    214a:	9f 92       	push	r9
    214c:	af 92       	push	r10
    214e:	bf 92       	push	r11
    2150:	cf 92       	push	r12
    2152:	df 92       	push	r13
    2154:	ef 92       	push	r14
    2156:	ff 92       	push	r15
    2158:	0f 93       	push	r16
    215a:	1f 93       	push	r17
    215c:	cf 93       	push	r28
    215e:	df 93       	push	r29
  int i, j;

  chp = p;
    2160:	90 93 cf 0a 	sts	0x0ACF, r25
    2164:	80 93 ce 0a 	sts	0x0ACE, r24
  test_println("");
    2168:	83 e6       	ldi	r24, 0x63	; 99
    216a:	94 e0       	ldi	r25, 0x04	; 4
    216c:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
  test_println("*** ChibiOS/RT test suite");
    2170:	84 e6       	ldi	r24, 0x64	; 100
    2172:	94 e0       	ldi	r25, 0x04	; 4
    2174:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
  test_println("***");
    2178:	8e e7       	ldi	r24, 0x7E	; 126
    217a:	94 e0       	ldi	r25, 0x04	; 4
    217c:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    2180:	c3 e8       	ldi	r28, 0x83	; 131
    2182:	d4 e0       	ldi	r29, 0x04	; 4
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2184:	6a e2       	ldi	r22, 0x2A	; 42
    chSequentialStreamPut(chp, *msgp++);
    2186:	80 91 ce 0a 	lds	r24, 0x0ACE
    218a:	90 91 cf 0a 	lds	r25, 0x0ACF
    218e:	dc 01       	movw	r26, r24
    2190:	ed 91       	ld	r30, X+
    2192:	fc 91       	ld	r31, X
    2194:	04 80       	ldd	r0, Z+4	; 0x04
    2196:	f5 81       	ldd	r31, Z+5	; 0x05
    2198:	e0 2d       	mov	r30, r0
    219a:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    219c:	69 91       	ld	r22, Y+
    219e:	61 11       	cpse	r22, r1
    21a0:	f2 cf       	rjmp	.-28     	; 0x2186 <TestThread+0x46>
  chp = p;
  test_println("");
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
    21a2:	87 ee       	ldi	r24, 0xE7	; 231
    21a4:	94 e0       	ldi	r25, 0x04	; 4
    21a6:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    21aa:	c6 ef       	ldi	r28, 0xF6	; 246
    21ac:	d4 e0       	ldi	r29, 0x04	; 4
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    21ae:	6a e2       	ldi	r22, 0x2A	; 42
    chSequentialStreamPut(chp, *msgp++);
    21b0:	80 91 ce 0a 	lds	r24, 0x0ACE
    21b4:	90 91 cf 0a 	lds	r25, 0x0ACF
    21b8:	dc 01       	movw	r26, r24
    21ba:	ed 91       	ld	r30, X+
    21bc:	fc 91       	ld	r31, X
    21be:	04 80       	ldd	r0, Z+4	; 0x04
    21c0:	f5 81       	ldd	r31, Z+5	; 0x05
    21c2:	e0 2d       	mov	r30, r0
    21c4:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    21c6:	69 91       	ld	r22, Y+
    21c8:	61 11       	cpse	r22, r1
    21ca:	f2 cf       	rjmp	.-28     	; 0x21b0 <TestThread+0x70>
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
    21cc:	88 e0       	ldi	r24, 0x08	; 8
    21ce:	95 e0       	ldi	r25, 0x05	; 5
    21d0:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    21d4:	c0 e2       	ldi	r28, 0x20	; 32
    21d6:	d5 e0       	ldi	r29, 0x05	; 5
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    21d8:	6a e2       	ldi	r22, 0x2A	; 42
    chSequentialStreamPut(chp, *msgp++);
    21da:	80 91 ce 0a 	lds	r24, 0x0ACE
    21de:	90 91 cf 0a 	lds	r25, 0x0ACF
    21e2:	dc 01       	movw	r26, r24
    21e4:	ed 91       	ld	r30, X+
    21e6:	fc 91       	ld	r31, X
    21e8:	04 80       	ldd	r0, Z+4	; 0x04
    21ea:	f5 81       	ldd	r31, Z+5	; 0x05
    21ec:	e0 2d       	mov	r30, r0
    21ee:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    21f0:	69 91       	ld	r22, Y+
    21f2:	61 11       	cpse	r22, r1
    21f4:	f2 cf       	rjmp	.-28     	; 0x21da <TestThread+0x9a>
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#ifdef CH_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(CH_COMPILER_NAME);
    21f6:	82 e3       	ldi	r24, 0x32	; 50
    21f8:	95 e0       	ldi	r25, 0x05	; 5
    21fa:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    21fe:	cd e3       	ldi	r28, 0x3D	; 61
    2200:	d5 e0       	ldi	r29, 0x05	; 5
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2202:	6a e2       	ldi	r22, 0x2A	; 42
    chSequentialStreamPut(chp, *msgp++);
    2204:	80 91 ce 0a 	lds	r24, 0x0ACE
    2208:	90 91 cf 0a 	lds	r25, 0x0ACF
    220c:	dc 01       	movw	r26, r24
    220e:	ed 91       	ld	r30, X+
    2210:	fc 91       	ld	r31, X
    2212:	04 80       	ldd	r0, Z+4	; 0x04
    2214:	f5 81       	ldd	r31, Z+5	; 0x05
    2216:	e0 2d       	mov	r30, r0
    2218:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    221a:	69 91       	ld	r22, Y+
    221c:	61 11       	cpse	r22, r1
    221e:	f2 cf       	rjmp	.-28     	; 0x2204 <__stack+0x5>
#ifdef CH_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(CH_COMPILER_NAME);
#endif
  test_print("*** Architecture: ");
  test_println(CH_ARCHITECTURE_NAME);
    2220:	86 e6       	ldi	r24, 0x66	; 102
    2222:	95 e0       	ldi	r25, 0x05	; 5
    2224:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    2228:	c0 e5       	ldi	r28, 0x50	; 80
    222a:	d5 e0       	ldi	r29, 0x05	; 5
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    222c:	6a e2       	ldi	r22, 0x2A	; 42
    chSequentialStreamPut(chp, *msgp++);
    222e:	80 91 ce 0a 	lds	r24, 0x0ACE
    2232:	90 91 cf 0a 	lds	r25, 0x0ACF
    2236:	dc 01       	movw	r26, r24
    2238:	ed 91       	ld	r30, X+
    223a:	fc 91       	ld	r31, X
    223c:	04 80       	ldd	r0, Z+4	; 0x04
    223e:	f5 81       	ldd	r31, Z+5	; 0x05
    2240:	e0 2d       	mov	r30, r0
    2242:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2244:	69 91       	ld	r22, Y+
    2246:	61 11       	cpse	r22, r1
    2248:	f2 cf       	rjmp	.-28     	; 0x222e <__stack+0x2f>
#endif
  test_print("*** Architecture: ");
  test_println(CH_ARCHITECTURE_NAME);
#ifdef CH_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
  test_println(CH_CORE_VARIANT_NAME);
    224a:	82 e6       	ldi	r24, 0x62	; 98
    224c:	95 e0       	ldi	r25, 0x05	; 5
    224e:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    2252:	cb e6       	ldi	r28, 0x6B	; 107
    2254:	d5 e0       	ldi	r29, 0x05	; 5
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2256:	6a e2       	ldi	r22, 0x2A	; 42
    chSequentialStreamPut(chp, *msgp++);
    2258:	80 91 ce 0a 	lds	r24, 0x0ACE
    225c:	90 91 cf 0a 	lds	r25, 0x0ACF
    2260:	dc 01       	movw	r26, r24
    2262:	ed 91       	ld	r30, X+
    2264:	fc 91       	ld	r31, X
    2266:	04 80       	ldd	r0, Z+4	; 0x04
    2268:	f5 81       	ldd	r31, Z+5	; 0x05
    226a:	e0 2d       	mov	r30, r0
    226c:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    226e:	69 91       	ld	r22, Y+
    2270:	61 11       	cpse	r22, r1
    2272:	f2 cf       	rjmp	.-28     	; 0x2258 <__stack+0x59>
  test_print("*** Core Variant: ");
  test_println(CH_CORE_VARIANT_NAME);
#endif
#ifdef CH_PORT_INFO
  test_print("*** Port Info:    ");
  test_println(CH_PORT_INFO);
    2274:	8d e7       	ldi	r24, 0x7D	; 125
    2276:	95 e0       	ldi	r25, 0x05	; 5
    2278:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    227c:	c3 e8       	ldi	r28, 0x83	; 131
    227e:	d5 e0       	ldi	r29, 0x05	; 5
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2280:	6a e2       	ldi	r22, 0x2A	; 42
    chSequentialStreamPut(chp, *msgp++);
    2282:	80 91 ce 0a 	lds	r24, 0x0ACE
    2286:	90 91 cf 0a 	lds	r25, 0x0ACF
    228a:	dc 01       	movw	r26, r24
    228c:	ed 91       	ld	r30, X+
    228e:	fc 91       	ld	r31, X
    2290:	04 80       	ldd	r0, Z+4	; 0x04
    2292:	f5 81       	ldd	r31, Z+5	; 0x05
    2294:	e0 2d       	mov	r30, r0
    2296:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2298:	69 91       	ld	r22, Y+
    229a:	61 11       	cpse	r22, r1
    229c:	f2 cf       	rjmp	.-28     	; 0x2282 <__stack+0x83>
  test_print("*** Port Info:    ");
  test_println(CH_PORT_INFO);
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
    229e:	85 e9       	ldi	r24, 0x95	; 149
    22a0:	95 e0       	ldi	r25, 0x05	; 5
    22a2:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    22a6:	cd e9       	ldi	r28, 0x9D	; 157
    22a8:	d5 e0       	ldi	r29, 0x05	; 5
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    22aa:	6a e2       	ldi	r22, 0x2A	; 42
    chSequentialStreamPut(chp, *msgp++);
    22ac:	80 91 ce 0a 	lds	r24, 0x0ACE
    22b0:	90 91 cf 0a 	lds	r25, 0x0ACF
    22b4:	dc 01       	movw	r26, r24
    22b6:	ed 91       	ld	r30, X+
    22b8:	fc 91       	ld	r31, X
    22ba:	04 80       	ldd	r0, Z+4	; 0x04
    22bc:	f5 81       	ldd	r31, Z+5	; 0x05
    22be:	e0 2d       	mov	r30, r0
    22c0:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    22c2:	69 91       	ld	r22, Y+
    22c4:	61 11       	cpse	r22, r1
    22c6:	f2 cf       	rjmp	.-28     	; 0x22ac <__stack+0xad>
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
    22c8:	85 e9       	ldi	r24, 0x95	; 149
    22ca:	94 e0       	ldi	r25, 0x04	; 4
    22cc:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
#endif
  test_println("");
    22d0:	83 e6       	ldi	r24, 0x63	; 99
    22d2:	94 e0       	ldi	r25, 0x04	; 4
    22d4:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>

  global_fail = FALSE;
    22d8:	10 92 d3 0a 	sts	0x0AD3, r1
    22dc:	59 e9       	ldi	r21, 0x99	; 153
    22de:	45 2e       	mov	r4, r21
    22e0:	52 e0       	ldi	r21, 0x02	; 2
    22e2:	55 2e       	mov	r5, r21
  i = 0;
  while (patterns[i]) {
    22e4:	81 2c       	mov	r8, r1
    22e6:	91 2c       	mov	r9, r1
    22e8:	54 01       	movw	r10, r8
    22ea:	83 94       	inc	r8
    22ec:	0f ea       	ldi	r16, 0xAF	; 175
    22ee:	12 e0       	ldi	r17, 0x02	; 2
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
    22f0:	76 ed       	ldi	r23, 0xD6	; 214
    22f2:	67 2e       	mov	r6, r23
    22f4:	7a e0       	ldi	r23, 0x0A	; 10
    22f6:	77 2e       	mov	r7, r23
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    22f8:	c1 2c       	mov	r12, r1
    22fa:	d1 2c       	mov	r13, r1
    22fc:	76 01       	movw	r14, r12
    22fe:	c3 94       	inc	r12

  global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
    2300:	f8 01       	movw	r30, r16
    2302:	80 81       	ld	r24, Z
    2304:	91 81       	ldd	r25, Z+1	; 0x01
    2306:	89 2b       	or	r24, r25
    2308:	09 f4       	brne	.+2      	; 0x230c <__stack+0x10d>
    230a:	df c0       	rjmp	.+446    	; 0x24ca <__stack+0x2cb>
      print_line();
    230c:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <print_line>
    2310:	c3 ea       	ldi	r28, 0xA3	; 163
    2312:	d4 e0       	ldi	r29, 0x04	; 4
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2314:	6d e2       	ldi	r22, 0x2D	; 45
    chSequentialStreamPut(chp, *msgp++);
    2316:	80 91 ce 0a 	lds	r24, 0x0ACE
    231a:	90 91 cf 0a 	lds	r25, 0x0ACF
    231e:	dc 01       	movw	r26, r24
    2320:	ed 91       	ld	r30, X+
    2322:	fc 91       	ld	r31, X
    2324:	04 80       	ldd	r0, Z+4	; 0x04
    2326:	f5 81       	ldd	r31, Z+5	; 0x05
    2328:	e0 2d       	mov	r30, r0
    232a:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    232c:	69 91       	ld	r22, Y+
    232e:	61 11       	cpse	r22, r1
    2330:	f2 cf       	rjmp	.-28     	; 0x2316 <__stack+0x117>
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
    2332:	c5 01       	movw	r24, r10
    2334:	b4 01       	movw	r22, r8
    2336:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
    233a:	80 91 ce 0a 	lds	r24, 0x0ACE
    233e:	90 91 cf 0a 	lds	r25, 0x0ACF
    2342:	dc 01       	movw	r26, r24
    2344:	ed 91       	ld	r30, X+
    2346:	fc 91       	ld	r31, X
    2348:	04 80       	ldd	r0, Z+4	; 0x04
    234a:	f5 81       	ldd	r31, Z+5	; 0x05
    234c:	e0 2d       	mov	r30, r0
    234e:	6e e2       	ldi	r22, 0x2E	; 46
    2350:	09 95       	icall
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
    2352:	c7 01       	movw	r24, r14
    2354:	b6 01       	movw	r22, r12
    2356:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
    235a:	c0 eb       	ldi	r28, 0xB0	; 176
    235c:	d5 e0       	ldi	r29, 0x05	; 5
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    235e:	60 e2       	ldi	r22, 0x20	; 32
    chSequentialStreamPut(chp, *msgp++);
    2360:	80 91 ce 0a 	lds	r24, 0x0ACE
    2364:	90 91 cf 0a 	lds	r25, 0x0ACF
    2368:	dc 01       	movw	r26, r24
    236a:	ed 91       	ld	r30, X+
    236c:	fc 91       	ld	r31, X
    236e:	04 80       	ldd	r0, Z+4	; 0x04
    2370:	f5 81       	ldd	r31, Z+5	; 0x05
    2372:	e0 2d       	mov	r30, r0
    2374:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2376:	69 91       	ld	r22, Y+
    2378:	61 11       	cpse	r22, r1
    237a:	f2 cf       	rjmp	.-28     	; 0x2360 <__stack+0x161>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
    237c:	d8 01       	movw	r26, r16
    237e:	ed 91       	ld	r30, X+
    2380:	fc 91       	ld	r31, X
    2382:	c0 81       	ld	r28, Z
    2384:	d1 81       	ldd	r29, Z+1	; 0x01
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2386:	68 81       	ld	r22, Y
    2388:	66 23       	and	r22, r22
    238a:	79 f0       	breq	.+30     	; 0x23aa <__stack+0x1ab>
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 * @return              A failure boolean value.
 */
msg_t TestThread(void *p) {
    238c:	21 96       	adiw	r28, 0x01	; 1
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
    238e:	80 91 ce 0a 	lds	r24, 0x0ACE
    2392:	90 91 cf 0a 	lds	r25, 0x0ACF
    2396:	dc 01       	movw	r26, r24
    2398:	ed 91       	ld	r30, X+
    239a:	fc 91       	ld	r31, X
    239c:	04 80       	ldd	r0, Z+4	; 0x04
    239e:	f5 81       	ldd	r31, Z+5	; 0x05
    23a0:	e0 2d       	mov	r30, r0
    23a2:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    23a4:	69 91       	ld	r22, Y+
    23a6:	61 11       	cpse	r22, r1
    23a8:	f2 cf       	rjmp	.-28     	; 0x238e <__stack+0x18f>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
      test_println(")");
    23aa:	89 ec       	ldi	r24, 0xC9	; 201
    23ac:	94 e0       	ldi	r25, 0x04	; 4
    23ae:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
    23b2:	88 ec       	ldi	r24, 0xC8	; 200
    23b4:	90 e0       	ldi	r25, 0x00	; 0
    23b6:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
#endif
      execute_test(patterns[i][j]);
    23ba:	f8 01       	movw	r30, r16
    23bc:	c1 91       	ld	r28, Z+
    23be:	d1 91       	ld	r29, Z+
    23c0:	8f 01       	movw	r16, r30
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
    23c2:	70 92 d1 0a 	sts	0x0AD1, r7
    23c6:	60 92 d0 0a 	sts	0x0AD0, r6
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
    23ca:	10 92 d2 0a 	sts	0x0AD2, r1
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
    23ce:	10 92 40 0c 	sts	0x0C40, r1
    23d2:	10 92 3f 0c 	sts	0x0C3F, r1
    23d6:	10 92 42 0c 	sts	0x0C42, r1
    23da:	10 92 41 0c 	sts	0x0C41, r1
    23de:	10 92 44 0c 	sts	0x0C44, r1
    23e2:	10 92 43 0c 	sts	0x0C43, r1
    23e6:	10 92 46 0c 	sts	0x0C46, r1
    23ea:	10 92 45 0c 	sts	0x0C45, r1
    23ee:	10 92 48 0c 	sts	0x0C48, r1
    23f2:	10 92 47 0c 	sts	0x0C47, r1

  if (tcp->setup != NULL)
    23f6:	ea 81       	ldd	r30, Y+2	; 0x02
    23f8:	fb 81       	ldd	r31, Y+3	; 0x03
    23fa:	30 97       	sbiw	r30, 0x00	; 0
    23fc:	09 f0       	breq	.+2      	; 0x2400 <__stack+0x201>
    tcp->setup();
    23fe:	09 95       	icall
  tcp->execute();
    2400:	ee 81       	ldd	r30, Y+6	; 0x06
    2402:	ff 81       	ldd	r31, Y+7	; 0x07
    2404:	09 95       	icall
  if (tcp->teardown != NULL)
    2406:	ec 81       	ldd	r30, Y+4	; 0x04
    2408:	fd 81       	ldd	r31, Y+5	; 0x05
    240a:	30 97       	sbiw	r30, 0x00	; 0
    240c:	09 f0       	breq	.+2      	; 0x2410 <__stack+0x211>
    tcp->teardown();
    240e:	09 95       	icall

  test_wait_threads();
    2410:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
    2414:	80 91 d2 0a 	lds	r24, 0x0AD2
    2418:	88 23       	and	r24, r24
    241a:	09 f4       	brne	.+2      	; 0x241e <__stack+0x21f>
    241c:	9a c0       	rjmp	.+308    	; 0x2552 <__stack+0x353>
    241e:	c2 eb       	ldi	r28, 0xB2	; 178
    2420:	d4 e0       	ldi	r29, 0x04	; 4
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2422:	6d e2       	ldi	r22, 0x2D	; 45
    chSequentialStreamPut(chp, *msgp++);
    2424:	80 91 ce 0a 	lds	r24, 0x0ACE
    2428:	90 91 cf 0a 	lds	r25, 0x0ACF
    242c:	dc 01       	movw	r26, r24
    242e:	ed 91       	ld	r30, X+
    2430:	fc 91       	ld	r31, X
    2432:	04 80       	ldd	r0, Z+4	; 0x04
    2434:	f5 81       	ldd	r31, Z+5	; 0x05
    2436:	e0 2d       	mov	r30, r0
    2438:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    243a:	69 91       	ld	r22, Y+
    243c:	61 11       	cpse	r22, r1
    243e:	f2 cf       	rjmp	.-28     	; 0x2424 <__stack+0x225>
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
    2440:	60 91 d4 0a 	lds	r22, 0x0AD4
    2444:	70 91 d5 0a 	lds	r23, 0x0AD5
    2448:	80 e0       	ldi	r24, 0x00	; 0
    244a:	90 e0       	ldi	r25, 0x00	; 0
    244c:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
    2450:	c3 eb       	ldi	r28, 0xB3	; 179
    2452:	d5 e0       	ldi	r29, 0x05	; 5
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    2454:	60 e2       	ldi	r22, 0x20	; 32
    chSequentialStreamPut(chp, *msgp++);
    2456:	80 91 ce 0a 	lds	r24, 0x0ACE
    245a:	90 91 cf 0a 	lds	r25, 0x0ACF
    245e:	dc 01       	movw	r26, r24
    2460:	ed 91       	ld	r30, X+
    2462:	fc 91       	ld	r31, X
    2464:	04 80       	ldd	r0, Z+4	; 0x04
    2466:	f5 81       	ldd	r31, Z+5	; 0x05
    2468:	e0 2d       	mov	r30, r0
    246a:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    246c:	69 91       	ld	r22, Y+
    246e:	61 11       	cpse	r22, r1
    2470:	f2 cf       	rjmp	.-28     	; 0x2456 <__stack+0x257>
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
    2472:	80 91 d0 0a 	lds	r24, 0x0AD0
    2476:	90 91 d1 0a 	lds	r25, 0x0AD1
    247a:	86 5d       	subi	r24, 0xD6	; 214
    247c:	9a 40       	sbci	r25, 0x0A	; 10
    247e:	b1 f0       	breq	.+44     	; 0x24ac <__stack+0x2ad>
    2480:	a8 f0       	brcs	.+42     	; 0x24ac <__stack+0x2ad>
    2482:	c6 ed       	ldi	r28, 0xD6	; 214
    2484:	da e0       	ldi	r29, 0x0A	; 10
    chSequentialStreamPut(chp, *cp++);
    2486:	80 91 ce 0a 	lds	r24, 0x0ACE
    248a:	90 91 cf 0a 	lds	r25, 0x0ACF
    248e:	69 91       	ld	r22, Y+
    2490:	dc 01       	movw	r26, r24
    2492:	ed 91       	ld	r30, X+
    2494:	fc 91       	ld	r31, X
    2496:	04 80       	ldd	r0, Z+4	; 0x04
    2498:	f5 81       	ldd	r31, Z+5	; 0x05
    249a:	e0 2d       	mov	r30, r0
    249c:	09 95       	icall
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
    249e:	80 91 d0 0a 	lds	r24, 0x0AD0
    24a2:	90 91 d1 0a 	lds	r25, 0x0AD1
    24a6:	c8 17       	cp	r28, r24
    24a8:	d9 07       	cpc	r29, r25
    24aa:	68 f3       	brcs	.-38     	; 0x2486 <__stack+0x287>
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
        test_print(" [");
        print_tokens();
        test_println("])");
    24ac:	88 ec       	ldi	r24, 0xC8	; 200
    24ae:	94 e0       	ldi	r25, 0x04	; 4
    24b0:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    24b4:	bf ef       	ldi	r27, 0xFF	; 255
    24b6:	cb 1a       	sub	r12, r27
    24b8:	db 0a       	sbc	r13, r27
    24ba:	eb 0a       	sbc	r14, r27
    24bc:	fb 0a       	sbc	r15, r27

  global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
    24be:	f8 01       	movw	r30, r16
    24c0:	80 81       	ld	r24, Z
    24c2:	91 81       	ldd	r25, Z+1	; 0x01
    24c4:	89 2b       	or	r24, r25
    24c6:	09 f0       	breq	.+2      	; 0x24ca <__stack+0x2cb>
    24c8:	21 cf       	rjmp	.-446    	; 0x230c <__stack+0x10d>
#endif
  test_println("");

  global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    24ca:	d2 01       	movw	r26, r4
    24cc:	0d 91       	ld	r16, X+
    24ce:	1d 91       	ld	r17, X+
    24d0:	2d 01       	movw	r4, r26
    24d2:	bf ef       	ldi	r27, 0xFF	; 255
    24d4:	8b 1a       	sub	r8, r27
    24d6:	9b 0a       	sbc	r9, r27
    24d8:	ab 0a       	sbc	r10, r27
    24da:	bb 0a       	sbc	r11, r27
    24dc:	01 15       	cp	r16, r1
    24de:	11 05       	cpc	r17, r1
    24e0:	09 f0       	breq	.+2      	; 0x24e4 <__stack+0x2e5>
    24e2:	0a cf       	rjmp	.-492    	; 0x22f8 <__stack+0xf9>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
    24e4:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <print_line>
  test_println("");
    24e8:	83 e6       	ldi	r24, 0x63	; 99
    24ea:	94 e0       	ldi	r25, 0x04	; 4
    24ec:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    24f0:	c6 eb       	ldi	r28, 0xB6	; 182
    24f2:	d5 e0       	ldi	r29, 0x05	; 5
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    24f4:	66 e4       	ldi	r22, 0x46	; 70
    chSequentialStreamPut(chp, *msgp++);
    24f6:	80 91 ce 0a 	lds	r24, 0x0ACE
    24fa:	90 91 cf 0a 	lds	r25, 0x0ACF
    24fe:	dc 01       	movw	r26, r24
    2500:	ed 91       	ld	r30, X+
    2502:	fc 91       	ld	r31, X
    2504:	04 80       	ldd	r0, Z+4	; 0x04
    2506:	f5 81       	ldd	r31, Z+5	; 0x05
    2508:	e0 2d       	mov	r30, r0
    250a:	09 95       	icall
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    250c:	69 91       	ld	r22, Y+
    250e:	61 11       	cpse	r22, r1
    2510:	f2 cf       	rjmp	.-28     	; 0x24f6 <__stack+0x2f7>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (global_fail)
    2512:	80 91 d3 0a 	lds	r24, 0x0AD3
    2516:	81 11       	cpse	r24, r1
    2518:	21 c0       	rjmp	.+66     	; 0x255c <__stack+0x35d>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
    251a:	87 ed       	ldi	r24, 0xD7	; 215
    251c:	94 e0       	ldi	r25, 0x04	; 4
    251e:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>

  return (msg_t)global_fail;
    2522:	80 91 d3 0a 	lds	r24, 0x0AD3
    2526:	28 2f       	mov	r18, r24
    2528:	33 27       	eor	r19, r19
    252a:	27 fd       	sbrc	r18, 7
    252c:	30 95       	com	r19
}
    252e:	93 2f       	mov	r25, r19
    2530:	df 91       	pop	r29
    2532:	cf 91       	pop	r28
    2534:	1f 91       	pop	r17
    2536:	0f 91       	pop	r16
    2538:	ff 90       	pop	r15
    253a:	ef 90       	pop	r14
    253c:	df 90       	pop	r13
    253e:	cf 90       	pop	r12
    2540:	bf 90       	pop	r11
    2542:	af 90       	pop	r10
    2544:	9f 90       	pop	r9
    2546:	8f 90       	pop	r8
    2548:	7f 90       	pop	r7
    254a:	6f 90       	pop	r6
    254c:	5f 90       	pop	r5
    254e:	4f 90       	pop	r4
    2550:	08 95       	ret
        test_print(" [");
        print_tokens();
        test_println("])");
      }
      else
        test_println("--- Result: SUCCESS");
    2552:	8b ec       	ldi	r24, 0xCB	; 203
    2554:	94 e0       	ldi	r25, 0x04	; 4
    2556:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    255a:	ac cf       	rjmp	.-168    	; 0x24b4 <__stack+0x2b5>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (global_fail)
    test_println("FAILURE");
    255c:	8f ed       	ldi	r24, 0xDF	; 223
    255e:	94 e0       	ldi	r25, 0x04	; 4
    2560:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
    2564:	de cf       	rjmp	.-68     	; 0x2522 <__stack+0x323>

00002566 <thd3_execute>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
    2566:	cf 92       	push	r12
    2568:	df 92       	push	r13
    256a:	ef 92       	push	r14
    256c:	ff 92       	push	r15
    256e:	0f 93       	push	r16
    2570:	1f 93       	push	r17
    2572:	cf 93       	push	r28
    2574:	df 93       	push	r29
  tprio_t prio, p1;

  prio = chThdGetPriority();
    2576:	e0 91 3c 0c 	lds	r30, 0x0C3C
    257a:	f0 91 3d 0c 	lds	r31, 0x0C3D
    257e:	d4 80       	ldd	r13, Z+4	; 0x04
  p1 = chThdSetPriority(prio + 1);
    2580:	cd 2c       	mov	r12, r13
    2582:	c3 94       	inc	r12
    2584:	8c 2d       	mov	r24, r12
    2586:	0e 94 80 04 	call	0x900	; 0x900 <chThdSetPriority>
    258a:	f8 2e       	mov	r15, r24
  test_assert(1, p1 == prio,
    258c:	61 e0       	ldi	r22, 0x01	; 1
    258e:	8d 11       	cpse	r24, r13
    2590:	60 e0       	ldi	r22, 0x00	; 0
    2592:	81 e0       	ldi	r24, 0x01	; 1
    2594:	90 e0       	ldi	r25, 0x00	; 0
    2596:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    259a:	88 23       	and	r24, r24
    259c:	49 f0       	breq	.+18     	; 0x25b0 <thd3_execute+0x4a>
  chSysLock();
  chThdSelf()->p_prio = prio;
  chThdSelf()->p_realprio = prio;
  chSysUnlock();
#endif
}
    259e:	df 91       	pop	r29
    25a0:	cf 91       	pop	r28
    25a2:	1f 91       	pop	r17
    25a4:	0f 91       	pop	r16
    25a6:	ff 90       	pop	r15
    25a8:	ef 90       	pop	r14
    25aa:	df 90       	pop	r13
    25ac:	cf 90       	pop	r12
    25ae:	08 95       	ret

  prio = chThdGetPriority();
  p1 = chThdSetPriority(prio + 1);
  test_assert(1, p1 == prio,
              "unexpected returned priority level");
  test_assert(2, chThdGetPriority() == prio + 1,
    25b0:	0d 2d       	mov	r16, r13
    25b2:	10 e0       	ldi	r17, 0x00	; 0
    25b4:	e8 01       	movw	r28, r16
    25b6:	21 96       	adiw	r28, 0x01	; 1
    25b8:	e0 91 3c 0c 	lds	r30, 0x0C3C
    25bc:	f0 91 3d 0c 	lds	r31, 0x0C3D
    25c0:	24 81       	ldd	r18, Z+4	; 0x04
    25c2:	30 e0       	ldi	r19, 0x00	; 0
    25c4:	61 e0       	ldi	r22, 0x01	; 1
    25c6:	2c 17       	cp	r18, r28
    25c8:	3d 07       	cpc	r19, r29
    25ca:	09 f0       	breq	.+2      	; 0x25ce <thd3_execute+0x68>
    25cc:	60 e0       	ldi	r22, 0x00	; 0
    25ce:	82 e0       	ldi	r24, 0x02	; 2
    25d0:	90 e0       	ldi	r25, 0x00	; 0
    25d2:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    25d6:	81 11       	cpse	r24, r1
    25d8:	e2 cf       	rjmp	.-60     	; 0x259e <thd3_execute+0x38>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
    25da:	8f 2d       	mov	r24, r15
    25dc:	0e 94 80 04 	call	0x900	; 0x900 <chThdSetPriority>
  test_assert(3, p1 == prio + 1,
    25e0:	28 2f       	mov	r18, r24
    25e2:	30 e0       	ldi	r19, 0x00	; 0
    25e4:	61 e0       	ldi	r22, 0x01	; 1
    25e6:	c2 17       	cp	r28, r18
    25e8:	d3 07       	cpc	r29, r19
    25ea:	09 f0       	breq	.+2      	; 0x25ee <thd3_execute+0x88>
    25ec:	60 e0       	ldi	r22, 0x00	; 0
    25ee:	83 e0       	ldi	r24, 0x03	; 3
    25f0:	90 e0       	ldi	r25, 0x00	; 0
    25f2:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    25f6:	81 11       	cpse	r24, r1
    25f8:	d2 cf       	rjmp	.-92     	; 0x259e <thd3_execute+0x38>
              "unexpected returned priority level");
  test_assert(4, chThdGetPriority() == prio,
    25fa:	e0 91 3c 0c 	lds	r30, 0x0C3C
    25fe:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2602:	61 e0       	ldi	r22, 0x01	; 1
    2604:	84 81       	ldd	r24, Z+4	; 0x04
    2606:	8d 11       	cpse	r24, r13
    2608:	60 e0       	ldi	r22, 0x00	; 0
    260a:	84 e0       	ldi	r24, 0x04	; 4
    260c:	90 e0       	ldi	r25, 0x00	; 0
    260e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2612:	81 11       	cpse	r24, r1
    2614:	c4 cf       	rjmp	.-120    	; 0x259e <thd3_execute+0x38>
              "unexpected priority level");

#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
    2616:	f8 94       	cli
  chThdSelf()->p_prio += 2;
    2618:	e0 91 3c 0c 	lds	r30, 0x0C3C
    261c:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2620:	84 81       	ldd	r24, Z+4	; 0x04
    2622:	8e 5f       	subi	r24, 0xFE	; 254
    2624:	84 83       	std	Z+4, r24	; 0x04
  chSysUnlock();
    2626:	78 94       	sei
  test_assert(5, chThdGetPriority() == prio + 2,
    2628:	78 01       	movw	r14, r16
    262a:	82 e0       	ldi	r24, 0x02	; 2
    262c:	e8 0e       	add	r14, r24
    262e:	f1 1c       	adc	r15, r1
    2630:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2634:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2638:	84 81       	ldd	r24, Z+4	; 0x04
    263a:	90 e0       	ldi	r25, 0x00	; 0
    263c:	61 e0       	ldi	r22, 0x01	; 1
    263e:	8e 15       	cp	r24, r14
    2640:	9f 05       	cpc	r25, r15
    2642:	09 f0       	breq	.+2      	; 0x2646 <thd3_execute+0xe0>
    2644:	60 e0       	ldi	r22, 0x00	; 0
    2646:	85 e0       	ldi	r24, 0x05	; 5
    2648:	90 e0       	ldi	r25, 0x00	; 0
    264a:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    264e:	81 11       	cpse	r24, r1
    2650:	a6 cf       	rjmp	.-180    	; 0x259e <thd3_execute+0x38>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
    2652:	8c 2d       	mov	r24, r12
    2654:	0e 94 80 04 	call	0x900	; 0x900 <chThdSetPriority>
  test_assert(6, p1 == prio,
    2658:	61 e0       	ldi	r22, 0x01	; 1
    265a:	8d 11       	cpse	r24, r13
    265c:	60 e0       	ldi	r22, 0x00	; 0
    265e:	86 e0       	ldi	r24, 0x06	; 6
    2660:	90 e0       	ldi	r25, 0x00	; 0
    2662:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2666:	81 11       	cpse	r24, r1
    2668:	9a cf       	rjmp	.-204    	; 0x259e <thd3_execute+0x38>
              "unexpected returned priority level");
  test_assert(7, chThdSelf()->p_prio == prio + 2,
    266a:	e0 91 3c 0c 	lds	r30, 0x0C3C
    266e:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2672:	84 81       	ldd	r24, Z+4	; 0x04
    2674:	90 e0       	ldi	r25, 0x00	; 0
    2676:	61 e0       	ldi	r22, 0x01	; 1
    2678:	e8 16       	cp	r14, r24
    267a:	f9 06       	cpc	r15, r25
    267c:	09 f0       	breq	.+2      	; 0x2680 <thd3_execute+0x11a>
    267e:	60 e0       	ldi	r22, 0x00	; 0
    2680:	87 e0       	ldi	r24, 0x07	; 7
    2682:	90 e0       	ldi	r25, 0x00	; 0
    2684:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2688:	81 11       	cpse	r24, r1
    268a:	89 cf       	rjmp	.-238    	; 0x259e <thd3_execute+0x38>
              "unexpected priority level");
  test_assert(8, chThdSelf()->p_realprio == prio + 1,
    268c:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2690:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2694:	87 8d       	ldd	r24, Z+31	; 0x1f
    2696:	90 e0       	ldi	r25, 0x00	; 0
    2698:	61 e0       	ldi	r22, 0x01	; 1
    269a:	c8 17       	cp	r28, r24
    269c:	d9 07       	cpc	r29, r25
    269e:	09 f0       	breq	.+2      	; 0x26a2 <thd3_execute+0x13c>
    26a0:	60 e0       	ldi	r22, 0x00	; 0
    26a2:	88 e0       	ldi	r24, 0x08	; 8
    26a4:	90 e0       	ldi	r25, 0x00	; 0
    26a6:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    26aa:	81 11       	cpse	r24, r1
    26ac:	78 cf       	rjmp	.-272    	; 0x259e <thd3_execute+0x38>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
    26ae:	8d 2d       	mov	r24, r13
    26b0:	8d 5f       	subi	r24, 0xFD	; 253
    26b2:	0e 94 80 04 	call	0x900	; 0x900 <chThdSetPriority>
  test_assert(9, p1 == prio + 1,
    26b6:	90 e0       	ldi	r25, 0x00	; 0
    26b8:	61 e0       	ldi	r22, 0x01	; 1
    26ba:	c8 17       	cp	r28, r24
    26bc:	d9 07       	cpc	r29, r25
    26be:	09 f0       	breq	.+2      	; 0x26c2 <thd3_execute+0x15c>
    26c0:	60 e0       	ldi	r22, 0x00	; 0
    26c2:	89 e0       	ldi	r24, 0x09	; 9
    26c4:	90 e0       	ldi	r25, 0x00	; 0
    26c6:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    26ca:	81 11       	cpse	r24, r1
    26cc:	68 cf       	rjmp	.-304    	; 0x259e <thd3_execute+0x38>
              "unexpected returned priority level");
  test_assert(10, chThdSelf()->p_prio == prio + 3,
    26ce:	0d 5f       	subi	r16, 0xFD	; 253
    26d0:	1f 4f       	sbci	r17, 0xFF	; 255
    26d2:	e0 91 3c 0c 	lds	r30, 0x0C3C
    26d6:	f0 91 3d 0c 	lds	r31, 0x0C3D
    26da:	84 81       	ldd	r24, Z+4	; 0x04
    26dc:	90 e0       	ldi	r25, 0x00	; 0
    26de:	61 e0       	ldi	r22, 0x01	; 1
    26e0:	80 17       	cp	r24, r16
    26e2:	91 07       	cpc	r25, r17
    26e4:	09 f0       	breq	.+2      	; 0x26e8 <thd3_execute+0x182>
    26e6:	60 e0       	ldi	r22, 0x00	; 0
    26e8:	8a e0       	ldi	r24, 0x0A	; 10
    26ea:	90 e0       	ldi	r25, 0x00	; 0
    26ec:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    26f0:	81 11       	cpse	r24, r1
    26f2:	55 cf       	rjmp	.-342    	; 0x259e <thd3_execute+0x38>
              "unexpected priority level");
  test_assert(11, chThdSelf()->p_realprio == prio + 3,
    26f4:	e0 91 3c 0c 	lds	r30, 0x0C3C
    26f8:	f0 91 3d 0c 	lds	r31, 0x0C3D
    26fc:	87 8d       	ldd	r24, Z+31	; 0x1f
    26fe:	90 e0       	ldi	r25, 0x00	; 0
    2700:	61 e0       	ldi	r22, 0x01	; 1
    2702:	08 17       	cp	r16, r24
    2704:	19 07       	cpc	r17, r25
    2706:	09 f0       	breq	.+2      	; 0x270a <thd3_execute+0x1a4>
    2708:	60 e0       	ldi	r22, 0x00	; 0
    270a:	8b e0       	ldi	r24, 0x0B	; 11
    270c:	90 e0       	ldi	r25, 0x00	; 0
    270e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2712:	81 11       	cpse	r24, r1
    2714:	44 cf       	rjmp	.-376    	; 0x259e <thd3_execute+0x38>
              "unexpected real priority level");

  chSysLock();
    2716:	f8 94       	cli
  chThdSelf()->p_prio = prio;
    2718:	e0 91 3c 0c 	lds	r30, 0x0C3C
    271c:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2720:	d4 82       	std	Z+4, r13	; 0x04
  chThdSelf()->p_realprio = prio;
    2722:	d7 8e       	std	Z+31, r13	; 0x1f
  chSysUnlock();
    2724:	78 94       	sei
    2726:	3b cf       	rjmp	.-394    	; 0x259e <thd3_execute+0x38>

00002728 <thd2_execute>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
    2728:	0f 93       	push	r16
    272a:	1f 93       	push	r17

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-4, thread, "D");
    272c:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2730:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2734:	44 81       	ldd	r20, Z+4	; 0x04
    2736:	44 50       	subi	r20, 0x04	; 4
    2738:	0d ef       	ldi	r16, 0xFD	; 253
    273a:	17 e0       	ldi	r17, 0x07	; 7
    273c:	2e e8       	ldi	r18, 0x8E	; 142
    273e:	34 e1       	ldi	r19, 0x14	; 20
    2740:	67 e9       	ldi	r22, 0x97	; 151
    2742:	70 e0       	ldi	r23, 0x00	; 0
    2744:	80 91 8f 02 	lds	r24, 0x028F
    2748:	90 91 90 02 	lds	r25, 0x0290
    274c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2750:	90 93 42 0c 	sts	0x0C42, r25
    2754:	80 93 41 0c 	sts	0x0C41, r24
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-5, thread, "E");
    2758:	e0 91 3c 0c 	lds	r30, 0x0C3C
    275c:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2760:	44 81       	ldd	r20, Z+4	; 0x04
    2762:	45 50       	subi	r20, 0x05	; 5
    2764:	0c ec       	ldi	r16, 0xCC	; 204
    2766:	15 e0       	ldi	r17, 0x05	; 5
    2768:	2e e8       	ldi	r18, 0x8E	; 142
    276a:	34 e1       	ldi	r19, 0x14	; 20
    276c:	67 e9       	ldi	r22, 0x97	; 151
    276e:	70 e0       	ldi	r23, 0x00	; 0
    2770:	80 91 8d 02 	lds	r24, 0x028D
    2774:	90 91 8e 02 	lds	r25, 0x028E
    2778:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    277c:	90 93 40 0c 	sts	0x0C40, r25
    2780:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread, "A");
    2784:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2788:	f0 91 3d 0c 	lds	r31, 0x0C3D
    278c:	44 81       	ldd	r20, Z+4	; 0x04
    278e:	41 50       	subi	r20, 0x01	; 1
    2790:	04 ec       	ldi	r16, 0xC4	; 196
    2792:	15 e0       	ldi	r17, 0x05	; 5
    2794:	2e e8       	ldi	r18, 0x8E	; 142
    2796:	34 e1       	ldi	r19, 0x14	; 20
    2798:	67 e9       	ldi	r22, 0x97	; 151
    279a:	70 e0       	ldi	r23, 0x00	; 0
    279c:	80 91 95 02 	lds	r24, 0x0295
    27a0:	90 91 96 02 	lds	r25, 0x0296
    27a4:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    27a8:	90 93 48 0c 	sts	0x0C48, r25
    27ac:	80 93 47 0c 	sts	0x0C47, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-2, thread, "B");
    27b0:	e0 91 3c 0c 	lds	r30, 0x0C3C
    27b4:	f0 91 3d 0c 	lds	r31, 0x0C3D
    27b8:	44 81       	ldd	r20, Z+4	; 0x04
    27ba:	42 50       	subi	r20, 0x02	; 2
    27bc:	06 ec       	ldi	r16, 0xC6	; 198
    27be:	15 e0       	ldi	r17, 0x05	; 5
    27c0:	2e e8       	ldi	r18, 0x8E	; 142
    27c2:	34 e1       	ldi	r19, 0x14	; 20
    27c4:	67 e9       	ldi	r22, 0x97	; 151
    27c6:	70 e0       	ldi	r23, 0x00	; 0
    27c8:	80 91 93 02 	lds	r24, 0x0293
    27cc:	90 91 94 02 	lds	r25, 0x0294
    27d0:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    27d4:	90 93 46 0c 	sts	0x0C46, r25
    27d8:	80 93 45 0c 	sts	0x0C45, r24
  /* Done this way for coverage of chThdCreateI() and chThdResume().*/
  chSysLock();
    27dc:	f8 94       	cli
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriority()-3, thread, "C");
    27de:	e0 91 3c 0c 	lds	r30, 0x0C3C
    27e2:	f0 91 3d 0c 	lds	r31, 0x0C3D
    27e6:	44 81       	ldd	r20, Z+4	; 0x04
    27e8:	43 50       	subi	r20, 0x03	; 3
    27ea:	09 e9       	ldi	r16, 0x99	; 153
    27ec:	16 e0       	ldi	r17, 0x06	; 6
    27ee:	2e e8       	ldi	r18, 0x8E	; 142
    27f0:	34 e1       	ldi	r19, 0x14	; 20
    27f2:	67 e9       	ldi	r22, 0x97	; 151
    27f4:	70 e0       	ldi	r23, 0x00	; 0
    27f6:	80 91 91 02 	lds	r24, 0x0291
    27fa:	90 91 92 02 	lds	r25, 0x0292
    27fe:	0e 94 1b 04 	call	0x836	; 0x836 <chThdCreateI>
    2802:	e3 e4       	ldi	r30, 0x43	; 67
    2804:	fc e0       	ldi	r31, 0x0C	; 12
    2806:	91 83       	std	Z+1, r25	; 0x01
    2808:	80 83       	st	Z, r24
  chSysUnlock();
    280a:	78 94       	sei
  chThdResume(threads[2]);
    280c:	80 81       	ld	r24, Z
    280e:	91 81       	ldd	r25, Z+1	; 0x01
    2810:	0e 94 94 04 	call	0x928	; 0x928 <chThdResume>
  test_wait_threads();
    2814:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    2818:	68 ec       	ldi	r22, 0xC8	; 200
    281a:	75 e0       	ldi	r23, 0x05	; 5
    281c:	81 e0       	ldi	r24, 0x01	; 1
    281e:	90 e0       	ldi	r25, 0x00	; 0
}
    2820:	1f 91       	pop	r17
    2822:	0f 91       	pop	r16
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriority()-3, thread, "C");
  chSysUnlock();
  chThdResume(threads[2]);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
    2824:	0c 94 f8 0f 	jmp	0x1ff0	; 0x1ff0 <_test_assert_sequence>

00002828 <thd1_execute>:

  test_emit_token(*(char *)p);
  return 0;
}

static void thd1_execute(void) {
    2828:	0f 93       	push	r16
    282a:	1f 93       	push	r17

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-5, thread, "E");
    282c:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2830:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2834:	44 81       	ldd	r20, Z+4	; 0x04
    2836:	45 50       	subi	r20, 0x05	; 5
    2838:	0c ec       	ldi	r16, 0xCC	; 204
    283a:	15 e0       	ldi	r17, 0x05	; 5
    283c:	2e e8       	ldi	r18, 0x8E	; 142
    283e:	34 e1       	ldi	r19, 0x14	; 20
    2840:	67 e9       	ldi	r22, 0x97	; 151
    2842:	70 e0       	ldi	r23, 0x00	; 0
    2844:	80 91 8d 02 	lds	r24, 0x028D
    2848:	90 91 8e 02 	lds	r25, 0x028E
    284c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2850:	90 93 40 0c 	sts	0x0C40, r25
    2854:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-4, thread, "D");
    2858:	e0 91 3c 0c 	lds	r30, 0x0C3C
    285c:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2860:	44 81       	ldd	r20, Z+4	; 0x04
    2862:	44 50       	subi	r20, 0x04	; 4
    2864:	0d ef       	ldi	r16, 0xFD	; 253
    2866:	17 e0       	ldi	r17, 0x07	; 7
    2868:	2e e8       	ldi	r18, 0x8E	; 142
    286a:	34 e1       	ldi	r19, 0x14	; 20
    286c:	67 e9       	ldi	r22, 0x97	; 151
    286e:	70 e0       	ldi	r23, 0x00	; 0
    2870:	80 91 8f 02 	lds	r24, 0x028F
    2874:	90 91 90 02 	lds	r25, 0x0290
    2878:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    287c:	90 93 42 0c 	sts	0x0C42, r25
    2880:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread, "C");
    2884:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2888:	f0 91 3d 0c 	lds	r31, 0x0C3D
    288c:	44 81       	ldd	r20, Z+4	; 0x04
    288e:	43 50       	subi	r20, 0x03	; 3
    2890:	09 e9       	ldi	r16, 0x99	; 153
    2892:	16 e0       	ldi	r17, 0x06	; 6
    2894:	2e e8       	ldi	r18, 0x8E	; 142
    2896:	34 e1       	ldi	r19, 0x14	; 20
    2898:	67 e9       	ldi	r22, 0x97	; 151
    289a:	70 e0       	ldi	r23, 0x00	; 0
    289c:	80 91 91 02 	lds	r24, 0x0291
    28a0:	90 91 92 02 	lds	r25, 0x0292
    28a4:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    28a8:	90 93 44 0c 	sts	0x0C44, r25
    28ac:	80 93 43 0c 	sts	0x0C43, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-2, thread, "B");
    28b0:	e0 91 3c 0c 	lds	r30, 0x0C3C
    28b4:	f0 91 3d 0c 	lds	r31, 0x0C3D
    28b8:	44 81       	ldd	r20, Z+4	; 0x04
    28ba:	42 50       	subi	r20, 0x02	; 2
    28bc:	06 ec       	ldi	r16, 0xC6	; 198
    28be:	15 e0       	ldi	r17, 0x05	; 5
    28c0:	2e e8       	ldi	r18, 0x8E	; 142
    28c2:	34 e1       	ldi	r19, 0x14	; 20
    28c4:	67 e9       	ldi	r22, 0x97	; 151
    28c6:	70 e0       	ldi	r23, 0x00	; 0
    28c8:	80 91 93 02 	lds	r24, 0x0293
    28cc:	90 91 94 02 	lds	r25, 0x0294
    28d0:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    28d4:	90 93 46 0c 	sts	0x0C46, r25
    28d8:	80 93 45 0c 	sts	0x0C45, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread, "A");
    28dc:	e0 91 3c 0c 	lds	r30, 0x0C3C
    28e0:	f0 91 3d 0c 	lds	r31, 0x0C3D
    28e4:	44 81       	ldd	r20, Z+4	; 0x04
    28e6:	41 50       	subi	r20, 0x01	; 1
    28e8:	04 ec       	ldi	r16, 0xC4	; 196
    28ea:	15 e0       	ldi	r17, 0x05	; 5
    28ec:	2e e8       	ldi	r18, 0x8E	; 142
    28ee:	34 e1       	ldi	r19, 0x14	; 20
    28f0:	67 e9       	ldi	r22, 0x97	; 151
    28f2:	70 e0       	ldi	r23, 0x00	; 0
    28f4:	80 91 95 02 	lds	r24, 0x0295
    28f8:	90 91 96 02 	lds	r25, 0x0296
    28fc:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2900:	90 93 48 0c 	sts	0x0C48, r25
    2904:	80 93 47 0c 	sts	0x0C47, r24
  test_wait_threads();
    2908:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    290c:	68 ec       	ldi	r22, 0xC8	; 200
    290e:	75 e0       	ldi	r23, 0x05	; 5
    2910:	81 e0       	ldi	r24, 0x01	; 1
    2912:	90 e0       	ldi	r25, 0x00	; 0
}
    2914:	1f 91       	pop	r17
    2916:	0f 91       	pop	r16
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-2, thread, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread, "A");
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
    2918:	0c 94 f8 0f 	jmp	0x1ff0	; 0x1ff0 <_test_assert_sequence>

0000291c <thread>:
 * priority order regardless of the initial order.
 */

static msg_t thread(void *p) {

  test_emit_token(*(char *)p);
    291c:	fc 01       	movw	r30, r24
    291e:	80 81       	ld	r24, Z
    2920:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  return 0;
}
    2924:	80 e0       	ldi	r24, 0x00	; 0
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	08 95       	ret

0000292a <thd4_execute>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
    292a:	0f 93       	push	r16
    292c:	1f 93       	push	r17
    292e:	cf 93       	push	r28
    2930:	df 93       	push	r29
  systime_t time;

  test_wait_tick();
    2932:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>

  /* Timeouts in microseconds.*/
  time = chTimeNow();
    2936:	c0 91 2f 0c 	lds	r28, 0x0C2F
    293a:	d0 91 30 0c 	lds	r29, 0x0C30
  chThdSleepMicroseconds(100000);
    293e:	84 e6       	ldi	r24, 0x64	; 100
    2940:	90 e0       	ldi	r25, 0x00	; 0
    2942:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_assert_time_window(1, time + US2ST(100000), time + US2ST(100000) + 1);
    2946:	ae 01       	movw	r20, r28
    2948:	4b 59       	subi	r20, 0x9B	; 155
    294a:	5f 4f       	sbci	r21, 0xFF	; 255
    294c:	be 01       	movw	r22, r28
    294e:	6c 59       	subi	r22, 0x9C	; 156
    2950:	7f 4f       	sbci	r23, 0xFF	; 255
    2952:	81 e0       	ldi	r24, 0x01	; 1
    2954:	90 e0       	ldi	r25, 0x00	; 0
    2956:	0e 94 20 10 	call	0x2040	; 0x2040 <_test_assert_time_window>
    295a:	88 23       	and	r24, r24
    295c:	29 f0       	breq	.+10     	; 0x2968 <thd4_execute+0x3e>

  /* Absolute timelines.*/
  time = chTimeNow() + MS2ST(100);
  chThdSleepUntil(time);
  test_assert_time_window(4, time, time + 1);
}
    295e:	df 91       	pop	r29
    2960:	cf 91       	pop	r28
    2962:	1f 91       	pop	r17
    2964:	0f 91       	pop	r16
    2966:	08 95       	ret
  time = chTimeNow();
  chThdSleepMicroseconds(100000);
  test_assert_time_window(1, time + US2ST(100000), time + US2ST(100000) + 1);

  /* Timeouts in milliseconds.*/
  time = chTimeNow();
    2968:	c0 91 2f 0c 	lds	r28, 0x0C2F
    296c:	d0 91 30 0c 	lds	r29, 0x0C30
  chThdSleepMilliseconds(100);
    2970:	84 e6       	ldi	r24, 0x64	; 100
    2972:	90 e0       	ldi	r25, 0x00	; 0
    2974:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_assert_time_window(2, time + MS2ST(100), time + MS2ST(100) + 1);
    2978:	ae 01       	movw	r20, r28
    297a:	4b 59       	subi	r20, 0x9B	; 155
    297c:	5f 4f       	sbci	r21, 0xFF	; 255
    297e:	be 01       	movw	r22, r28
    2980:	6c 59       	subi	r22, 0x9C	; 156
    2982:	7f 4f       	sbci	r23, 0xFF	; 255
    2984:	82 e0       	ldi	r24, 0x02	; 2
    2986:	90 e0       	ldi	r25, 0x00	; 0
    2988:	0e 94 20 10 	call	0x2040	; 0x2040 <_test_assert_time_window>
    298c:	81 11       	cpse	r24, r1
    298e:	e7 cf       	rjmp	.-50     	; 0x295e <thd4_execute+0x34>

  /* Timeouts in seconds.*/
  time = chTimeNow();
    2990:	c0 91 2f 0c 	lds	r28, 0x0C2F
    2994:	d0 91 30 0c 	lds	r29, 0x0C30
  chThdSleepSeconds(1);
    2998:	88 ee       	ldi	r24, 0xE8	; 232
    299a:	93 e0       	ldi	r25, 0x03	; 3
    299c:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_assert_time_window(3, time + S2ST(1), time + S2ST(1) + 1);
    29a0:	ae 01       	movw	r20, r28
    29a2:	47 51       	subi	r20, 0x17	; 23
    29a4:	5c 4f       	sbci	r21, 0xFC	; 252
    29a6:	be 01       	movw	r22, r28
    29a8:	68 51       	subi	r22, 0x18	; 24
    29aa:	7c 4f       	sbci	r23, 0xFC	; 252
    29ac:	83 e0       	ldi	r24, 0x03	; 3
    29ae:	90 e0       	ldi	r25, 0x00	; 0
    29b0:	0e 94 20 10 	call	0x2040	; 0x2040 <_test_assert_time_window>
    29b4:	81 11       	cpse	r24, r1
    29b6:	d3 cf       	rjmp	.-90     	; 0x295e <thd4_execute+0x34>

  /* Absolute timelines.*/
  time = chTimeNow() + MS2ST(100);
    29b8:	00 91 2f 0c 	lds	r16, 0x0C2F
    29bc:	10 91 30 0c 	lds	r17, 0x0C30
    29c0:	e8 01       	movw	r28, r16
    29c2:	cc 59       	subi	r28, 0x9C	; 156
    29c4:	df 4f       	sbci	r29, 0xFF	; 255
  chThdSleepUntil(time);
    29c6:	ce 01       	movw	r24, r28
    29c8:	0e 94 b1 04 	call	0x962	; 0x962 <chThdSleepUntil>
  test_assert_time_window(4, time, time + 1);
    29cc:	a8 01       	movw	r20, r16
    29ce:	4b 59       	subi	r20, 0x9B	; 155
    29d0:	5f 4f       	sbci	r21, 0xFF	; 255
    29d2:	be 01       	movw	r22, r28
    29d4:	84 e0       	ldi	r24, 0x04	; 4
    29d6:	90 e0       	ldi	r25, 0x00	; 0
}
    29d8:	df 91       	pop	r29
    29da:	cf 91       	pop	r28
    29dc:	1f 91       	pop	r17
    29de:	0f 91       	pop	r16
  test_assert_time_window(3, time + S2ST(1), time + S2ST(1) + 1);

  /* Absolute timelines.*/
  time = chTimeNow() + MS2ST(100);
  chThdSleepUntil(time);
  test_assert_time_window(4, time, time + 1);
    29e0:	0c 94 20 10 	jmp	0x2040	; 0x2040 <_test_assert_time_window>

000029e4 <sem3_setup>:
 * correct after each operation.
 */

static void sem3_setup(void) {

  chSemInit(&sem1, 0);
    29e4:	60 e0       	ldi	r22, 0x00	; 0
    29e6:	80 e0       	ldi	r24, 0x00	; 0
    29e8:	92 e0       	ldi	r25, 0x02	; 2
    29ea:	0c 94 37 05 	jmp	0xa6e	; 0xa6e <chSemInit>

000029ee <sem2_setup>:
 * correct after each operation.
 */

static void sem2_setup(void) {

  chSemInit(&sem1, 0);
    29ee:	60 e0       	ldi	r22, 0x00	; 0
    29f0:	80 e0       	ldi	r24, 0x00	; 0
    29f2:	92 e0       	ldi	r25, 0x02	; 2
    29f4:	0c 94 37 05 	jmp	0xa6e	; 0xa6e <chSemInit>

000029f8 <sem1_setup>:
 * setting.
 */

static void sem1_setup(void) {

  chSemInit(&sem1, 0);
    29f8:	60 e0       	ldi	r22, 0x00	; 0
    29fa:	80 e0       	ldi	r24, 0x00	; 0
    29fc:	92 e0       	ldi	r25, 0x02	; 2
    29fe:	0c 94 37 05 	jmp	0xa6e	; 0xa6e <chSemInit>

00002a02 <sem4_execute>:

  chBSemSignal((BinarySemaphore *)p);
  return 0;
}

static void sem4_execute(void) {
    2a02:	0f 93       	push	r16
    2a04:	1f 93       	push	r17
    2a06:	cf 93       	push	r28
    2a08:	df 93       	push	r29
    2a0a:	00 d0       	rcall	.+0      	; 0x2a0c <sem4_execute+0xa>
    2a0c:	00 d0       	rcall	.+0      	; 0x2a0e <sem4_execute+0xc>
    2a0e:	1f 92       	push	r1
    2a10:	cd b7       	in	r28, 0x3d	; 61
    2a12:	de b7       	in	r29, 0x3e	; 62
  BinarySemaphore bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemInit(&bsem, TRUE);
    2a14:	60 e0       	ldi	r22, 0x00	; 0
    2a16:	ce 01       	movw	r24, r28
    2a18:	01 96       	adiw	r24, 0x01	; 1
    2a1a:	0e 94 37 05 	call	0xa6e	; 0xa6e <chSemInit>
  chBSemReset(&bsem, TRUE);
    2a1e:	60 e0       	ldi	r22, 0x00	; 0
    2a20:	ce 01       	movw	r24, r28
    2a22:	01 96       	adiw	r24, 0x01	; 1
    2a24:	0e 94 65 05 	call	0xaca	; 0xaca <chSemReset>
  test_assert(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
    2a28:	61 e0       	ldi	r22, 0x01	; 1
    2a2a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a2c:	18 16       	cp	r1, r24
    2a2e:	0c f4       	brge	.+2      	; 0x2a32 <sem4_execute+0x30>
    2a30:	60 e0       	ldi	r22, 0x00	; 0
    2a32:	81 e0       	ldi	r24, 0x01	; 1
    2a34:	90 e0       	ldi	r25, 0x00	; 0
    2a36:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2a3a:	88 23       	and	r24, r24
    2a3c:	51 f0       	breq	.+20     	; 0x2a52 <sem4_execute+0x50>
  
  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
    2a3e:	0f 90       	pop	r0
    2a40:	0f 90       	pop	r0
    2a42:	0f 90       	pop	r0
    2a44:	0f 90       	pop	r0
    2a46:	0f 90       	pop	r0
    2a48:	df 91       	pop	r29
    2a4a:	cf 91       	pop	r28
    2a4c:	1f 91       	pop	r17
    2a4e:	0f 91       	pop	r16
    2a50:	08 95       	ret
  chBSemReset(&bsem, TRUE);
  test_assert(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
                                 chThdGetPriority()-1, thread4, &bsem);
    2a52:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2a56:	f0 91 3d 0c 	lds	r31, 0x0C3D
  chBSemInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
    2a5a:	44 81       	ldd	r20, Z+4	; 0x04
    2a5c:	41 50       	subi	r20, 0x01	; 1
    2a5e:	8e 01       	movw	r16, r28
    2a60:	0f 5f       	subi	r16, 0xFF	; 255
    2a62:	1f 4f       	sbci	r17, 0xFF	; 255
    2a64:	23 e9       	ldi	r18, 0x93	; 147
    2a66:	35 e1       	ldi	r19, 0x15	; 21
    2a68:	67 e9       	ldi	r22, 0x97	; 151
    2a6a:	70 e0       	ldi	r23, 0x00	; 0
    2a6c:	80 91 8d 02 	lds	r24, 0x028D
    2a70:	90 91 8e 02 	lds	r25, 0x028E
    2a74:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2a78:	90 93 40 0c 	sts	0x0C40, r25
    2a7c:	80 93 3f 0c 	sts	0x0C3F, r24
                                 chThdGetPriority()-1, thread4, &bsem);
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
    2a80:	c8 01       	movw	r24, r16
    2a82:	0e 94 9c 05 	call	0xb38	; 0xb38 <chSemWait>
  
  /* The binary semaphore is expected to be taken.*/
  test_assert(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
    2a86:	61 e0       	ldi	r22, 0x01	; 1
    2a88:	8d 81       	ldd	r24, Y+5	; 0x05
    2a8a:	18 16       	cp	r1, r24
    2a8c:	0c f4       	brge	.+2      	; 0x2a90 <sem4_execute+0x8e>
    2a8e:	60 e0       	ldi	r22, 0x00	; 0
    2a90:	82 e0       	ldi	r24, 0x02	; 2
    2a92:	90 e0       	ldi	r25, 0x00	; 0
    2a94:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2a98:	81 11       	cpse	r24, r1
    2a9a:	d1 cf       	rjmp	.-94     	; 0x2a3e <sem4_execute+0x3c>
  
  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
    2a9c:	f8 94       	cli
    2a9e:	8d 81       	ldd	r24, Y+5	; 0x05
    2aa0:	18 16       	cp	r1, r24
    2aa2:	ac f5       	brge	.+106    	; 0x2b0e <sem4_execute+0x10c>
    2aa4:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
    2aa8:	78 94       	sei
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
    2aaa:	61 e0       	ldi	r22, 0x01	; 1
    2aac:	8d 81       	ldd	r24, Y+5	; 0x05
    2aae:	18 16       	cp	r1, r24
    2ab0:	64 f5       	brge	.+88     	; 0x2b0a <sem4_execute+0x108>
    2ab2:	83 e0       	ldi	r24, 0x03	; 3
    2ab4:	90 e0       	ldi	r25, 0x00	; 0
    2ab6:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2aba:	81 11       	cpse	r24, r1
    2abc:	c0 cf       	rjmp	.-128    	; 0x2a3e <sem4_execute+0x3c>
  test_assert(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
    2abe:	61 e0       	ldi	r22, 0x01	; 1
    2ac0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ac2:	81 30       	cpi	r24, 0x01	; 1
    2ac4:	09 f0       	breq	.+2      	; 0x2ac8 <sem4_execute+0xc6>
    2ac6:	60 e0       	ldi	r22, 0x00	; 0
    2ac8:	84 e0       	ldi	r24, 0x04	; 4
    2aca:	90 e0       	ldi	r25, 0x00	; 0
    2acc:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2ad0:	81 11       	cpse	r24, r1
    2ad2:	b5 cf       	rjmp	.-150    	; 0x2a3e <sem4_execute+0x3c>
  
  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
    2ad4:	f8 94       	cli
    2ad6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ad8:	18 16       	cp	r1, r24
    2ada:	04 f5       	brge	.+64     	; 0x2b1c <sem4_execute+0x11a>
    2adc:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
    2ae0:	78 94       	sei
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "taken");
    2ae2:	61 e0       	ldi	r22, 0x01	; 1
    2ae4:	8d 81       	ldd	r24, Y+5	; 0x05
    2ae6:	18 16       	cp	r1, r24
    2ae8:	bc f4       	brge	.+46     	; 0x2b18 <sem4_execute+0x116>
    2aea:	83 e0       	ldi	r24, 0x03	; 3
    2aec:	90 e0       	ldi	r25, 0x00	; 0
    2aee:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2af2:	81 11       	cpse	r24, r1
    2af4:	a4 cf       	rjmp	.-184    	; 0x2a3e <sem4_execute+0x3c>
  test_assert(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
    2af6:	61 e0       	ldi	r22, 0x01	; 1
    2af8:	8d 81       	ldd	r24, Y+5	; 0x05
    2afa:	81 30       	cpi	r24, 0x01	; 1
    2afc:	09 f0       	breq	.+2      	; 0x2b00 <sem4_execute+0xfe>
    2afe:	60 e0       	ldi	r22, 0x00	; 0
    2b00:	85 e0       	ldi	r24, 0x05	; 5
    2b02:	90 e0       	ldi	r25, 0x00	; 0
    2b04:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2b08:	9a cf       	rjmp	.-204    	; 0x2a3e <sem4_execute+0x3c>
  test_assert(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
  
  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
    2b0a:	60 e0       	ldi	r22, 0x00	; 0
    2b0c:	d2 cf       	rjmp	.-92     	; 0x2ab2 <sem4_execute+0xb0>
  /* The binary semaphore is expected to be taken.*/
  test_assert(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
  
  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
    2b0e:	ce 01       	movw	r24, r28
    2b10:	01 96       	adiw	r24, 0x01	; 1
    2b12:	0e 94 f6 05 	call	0xbec	; 0xbec <chSemSignalI>
    2b16:	c6 cf       	rjmp	.-116    	; 0x2aa4 <sem4_execute+0xa2>
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
  test_assert(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
  
  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "taken");
    2b18:	60 e0       	ldi	r22, 0x00	; 0
    2b1a:	e7 cf       	rjmp	.-50     	; 0x2aea <sem4_execute+0xe8>
  chBSemSignal(&bsem);
  test_assert(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
  test_assert(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
  
  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
    2b1c:	ce 01       	movw	r24, r28
    2b1e:	01 96       	adiw	r24, 0x01	; 1
    2b20:	0e 94 f6 05 	call	0xbec	; 0xbec <chSemSignalI>
    2b24:	db cf       	rjmp	.-74     	; 0x2adc <sem4_execute+0xda>

00002b26 <thread4>:
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static msg_t thread4(void *p) {

  chBSemSignal((BinarySemaphore *)p);
    2b26:	f8 94       	cli
    2b28:	fc 01       	movw	r30, r24
    2b2a:	24 81       	ldd	r18, Z+4	; 0x04
    2b2c:	12 16       	cp	r1, r18
    2b2e:	34 f4       	brge	.+12     	; 0x2b3c <thread4+0x16>
    2b30:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
    2b34:	78 94       	sei
  return 0;
}
    2b36:	80 e0       	ldi	r24, 0x00	; 0
    2b38:	90 e0       	ldi	r25, 0x00	; 0
    2b3a:	08 95       	ret
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static msg_t thread4(void *p) {

  chBSemSignal((BinarySemaphore *)p);
    2b3c:	0e 94 f6 05 	call	0xbec	; 0xbec <chSemSignalI>
    2b40:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
    2b44:	78 94       	sei
  return 0;
}
    2b46:	80 e0       	ldi	r24, 0x00	; 0
    2b48:	90 e0       	ldi	r25, 0x00	; 0
    2b4a:	08 95       	ret

00002b4c <thread3>:
}

static msg_t thread3(void *p) {

  (void)p;
  chSemWait(&sem1);
    2b4c:	80 e0       	ldi	r24, 0x00	; 0
    2b4e:	92 e0       	ldi	r25, 0x02	; 2
    2b50:	0e 94 9c 05 	call	0xb38	; 0xb38 <chSemWait>
  chSemSignal(&sem1);
    2b54:	80 e0       	ldi	r24, 0x00	; 0
    2b56:	92 e0       	ldi	r25, 0x02	; 2
    2b58:	0e 94 d6 05 	call	0xbac	; 0xbac <chSemSignal>
  return 0;
}
    2b5c:	80 e0       	ldi	r24, 0x00	; 0
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	08 95       	ret

00002b62 <thread1>:
static void sem1_setup(void) {

  chSemInit(&sem1, 0);
}

static msg_t thread1(void *p) {
    2b62:	cf 93       	push	r28
    2b64:	df 93       	push	r29
    2b66:	ec 01       	movw	r28, r24

  chSemWait(&sem1);
    2b68:	80 e0       	ldi	r24, 0x00	; 0
    2b6a:	92 e0       	ldi	r25, 0x02	; 2
    2b6c:	0e 94 9c 05 	call	0xb38	; 0xb38 <chSemWait>
  test_emit_token(*(char *)p);
    2b70:	88 81       	ld	r24, Y
    2b72:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  return 0;
}
    2b76:	80 e0       	ldi	r24, 0x00	; 0
    2b78:	90 e0       	ldi	r25, 0x00	; 0
    2b7a:	df 91       	pop	r29
    2b7c:	cf 91       	pop	r28
    2b7e:	08 95       	ret

00002b80 <thread2>:
}

static msg_t thread2(void *p) {

  (void)p;
  chThdSleepMilliseconds(50);
    2b80:	82 e3       	ldi	r24, 0x32	; 50
    2b82:	90 e0       	ldi	r25, 0x00	; 0
    2b84:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  chSysLock();
    2b88:	f8 94       	cli
  chSemSignalI(&sem1); /* For coverage reasons */
    2b8a:	80 e0       	ldi	r24, 0x00	; 0
    2b8c:	92 e0       	ldi	r25, 0x02	; 2
    2b8e:	0e 94 f6 05 	call	0xbec	; 0xbec <chSemSignalI>
  chSchRescheduleS();
    2b92:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  chSysUnlock();
    2b96:	78 94       	sei
  return 0;
}
    2b98:	80 e0       	ldi	r24, 0x00	; 0
    2b9a:	90 e0       	ldi	r25, 0x00	; 0
    2b9c:	08 95       	ret

00002b9e <sem1_execute>:
  chSemWait(&sem1);
  test_emit_token(*(char *)p);
  return 0;
}

static void sem1_execute(void) {
    2b9e:	0f 93       	push	r16
    2ba0:	1f 93       	push	r17
    2ba2:	cf 93       	push	r28
    2ba4:	df 93       	push	r29

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+5, thread1, "A");
    2ba6:	c0 91 8d 02 	lds	r28, 0x028D
    2baa:	d0 91 8e 02 	lds	r29, 0x028E
    2bae:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2bb2:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2bb6:	44 81       	ldd	r20, Z+4	; 0x04
    2bb8:	4b 5f       	subi	r20, 0xFB	; 251
    2bba:	04 ec       	ldi	r16, 0xC4	; 196
    2bbc:	15 e0       	ldi	r17, 0x05	; 5
    2bbe:	21 eb       	ldi	r18, 0xB1	; 177
    2bc0:	35 e1       	ldi	r19, 0x15	; 21
    2bc2:	67 e9       	ldi	r22, 0x97	; 151
    2bc4:	70 e0       	ldi	r23, 0x00	; 0
    2bc6:	ce 01       	movw	r24, r28
    2bc8:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2bcc:	90 93 40 0c 	sts	0x0C40, r25
    2bd0:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()+1, thread1, "B");
    2bd4:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2bd8:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2bdc:	44 81       	ldd	r20, Z+4	; 0x04
    2bde:	4f 5f       	subi	r20, 0xFF	; 255
    2be0:	06 ec       	ldi	r16, 0xC6	; 198
    2be2:	15 e0       	ldi	r17, 0x05	; 5
    2be4:	21 eb       	ldi	r18, 0xB1	; 177
    2be6:	35 e1       	ldi	r19, 0x15	; 21
    2be8:	67 e9       	ldi	r22, 0x97	; 151
    2bea:	70 e0       	ldi	r23, 0x00	; 0
    2bec:	80 91 8f 02 	lds	r24, 0x028F
    2bf0:	90 91 90 02 	lds	r25, 0x0290
    2bf4:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2bf8:	90 93 42 0c 	sts	0x0C42, r25
    2bfc:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()+3, thread1, "C");
    2c00:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2c04:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2c08:	44 81       	ldd	r20, Z+4	; 0x04
    2c0a:	4d 5f       	subi	r20, 0xFD	; 253
    2c0c:	09 e9       	ldi	r16, 0x99	; 153
    2c0e:	16 e0       	ldi	r17, 0x06	; 6
    2c10:	21 eb       	ldi	r18, 0xB1	; 177
    2c12:	35 e1       	ldi	r19, 0x15	; 21
    2c14:	67 e9       	ldi	r22, 0x97	; 151
    2c16:	70 e0       	ldi	r23, 0x00	; 0
    2c18:	80 91 91 02 	lds	r24, 0x0291
    2c1c:	90 91 92 02 	lds	r25, 0x0292
    2c20:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2c24:	90 93 44 0c 	sts	0x0C44, r25
    2c28:	80 93 43 0c 	sts	0x0C43, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()+4, thread1, "D");
    2c2c:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2c30:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2c34:	44 81       	ldd	r20, Z+4	; 0x04
    2c36:	4c 5f       	subi	r20, 0xFC	; 252
    2c38:	0d ef       	ldi	r16, 0xFD	; 253
    2c3a:	17 e0       	ldi	r17, 0x07	; 7
    2c3c:	21 eb       	ldi	r18, 0xB1	; 177
    2c3e:	35 e1       	ldi	r19, 0x15	; 21
    2c40:	67 e9       	ldi	r22, 0x97	; 151
    2c42:	70 e0       	ldi	r23, 0x00	; 0
    2c44:	80 91 93 02 	lds	r24, 0x0293
    2c48:	90 91 94 02 	lds	r25, 0x0294
    2c4c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2c50:	90 93 46 0c 	sts	0x0C46, r25
    2c54:	80 93 45 0c 	sts	0x0C45, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()+2, thread1, "E");
    2c58:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2c5c:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2c60:	44 81       	ldd	r20, Z+4	; 0x04
    2c62:	4e 5f       	subi	r20, 0xFE	; 254
    2c64:	0c ec       	ldi	r16, 0xCC	; 204
    2c66:	15 e0       	ldi	r17, 0x05	; 5
    2c68:	21 eb       	ldi	r18, 0xB1	; 177
    2c6a:	35 e1       	ldi	r19, 0x15	; 21
    2c6c:	67 e9       	ldi	r22, 0x97	; 151
    2c6e:	70 e0       	ldi	r23, 0x00	; 0
    2c70:	80 91 95 02 	lds	r24, 0x0295
    2c74:	90 91 96 02 	lds	r25, 0x0296
    2c78:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2c7c:	90 93 48 0c 	sts	0x0C48, r25
    2c80:	80 93 47 0c 	sts	0x0C47, r24
  chSemSignal(&sem1);
    2c84:	80 e0       	ldi	r24, 0x00	; 0
    2c86:	92 e0       	ldi	r25, 0x02	; 2
    2c88:	0e 94 d6 05 	call	0xbac	; 0xbac <chSemSignal>
  chSemSignal(&sem1);
    2c8c:	80 e0       	ldi	r24, 0x00	; 0
    2c8e:	92 e0       	ldi	r25, 0x02	; 2
    2c90:	0e 94 d6 05 	call	0xbac	; 0xbac <chSemSignal>
  chSemSignal(&sem1);
    2c94:	80 e0       	ldi	r24, 0x00	; 0
    2c96:	92 e0       	ldi	r25, 0x02	; 2
    2c98:	0e 94 d6 05 	call	0xbac	; 0xbac <chSemSignal>
  chSemSignal(&sem1);
    2c9c:	80 e0       	ldi	r24, 0x00	; 0
    2c9e:	92 e0       	ldi	r25, 0x02	; 2
    2ca0:	0e 94 d6 05 	call	0xbac	; 0xbac <chSemSignal>
  chSemSignal(&sem1);
    2ca4:	80 e0       	ldi	r24, 0x00	; 0
    2ca6:	92 e0       	ldi	r25, 0x02	; 2
    2ca8:	0e 94 d6 05 	call	0xbac	; 0xbac <chSemSignal>
  test_wait_threads();
    2cac:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
#if CH_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
    2cb0:	68 ec       	ldi	r22, 0xC8	; 200
    2cb2:	75 e0       	ldi	r23, 0x05	; 5
    2cb4:	81 e0       	ldi	r24, 0x01	; 1
    2cb6:	90 e0       	ldi	r25, 0x00	; 0
    2cb8:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <_test_assert_sequence>
    2cbc:	88 23       	and	r24, r24
    2cbe:	29 f0       	breq	.+10     	; 0x2cca <sem1_execute+0x12c>
  chSysLock();
  chSemAddCounterI(&sem1, 2);
  chSysUnlock();
  test_wait_threads();
  test_assert(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
}
    2cc0:	df 91       	pop	r29
    2cc2:	cf 91       	pop	r28
    2cc4:	1f 91       	pop	r17
    2cc6:	0f 91       	pop	r16
    2cc8:	08 95       	ret
#if CH_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+5, thread1, "A");
    2cca:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2cce:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2cd2:	44 81       	ldd	r20, Z+4	; 0x04
    2cd4:	4b 5f       	subi	r20, 0xFB	; 251
    2cd6:	04 ec       	ldi	r16, 0xC4	; 196
    2cd8:	15 e0       	ldi	r17, 0x05	; 5
    2cda:	21 eb       	ldi	r18, 0xB1	; 177
    2cdc:	35 e1       	ldi	r19, 0x15	; 21
    2cde:	67 e9       	ldi	r22, 0x97	; 151
    2ce0:	70 e0       	ldi	r23, 0x00	; 0
    2ce2:	ce 01       	movw	r24, r28
    2ce4:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2ce8:	90 93 40 0c 	sts	0x0C40, r25
    2cec:	80 93 3f 0c 	sts	0x0C3F, r24
  chSysLock();
    2cf0:	f8 94       	cli
  chSemAddCounterI(&sem1, 2);
    2cf2:	62 e0       	ldi	r22, 0x02	; 2
    2cf4:	80 e0       	ldi	r24, 0x00	; 0
    2cf6:	92 e0       	ldi	r25, 0x02	; 2
    2cf8:	0e 94 12 06 	call	0xc24	; 0xc24 <chSemAddCounterI>
  chSysUnlock();
    2cfc:	78 94       	sei
  test_wait_threads();
    2cfe:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_assert(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
    2d02:	61 e0       	ldi	r22, 0x01	; 1
    2d04:	80 91 04 02 	lds	r24, 0x0204
    2d08:	81 30       	cpi	r24, 0x01	; 1
    2d0a:	09 f0       	breq	.+2      	; 0x2d0e <sem1_execute+0x170>
    2d0c:	60 e0       	ldi	r22, 0x00	; 0
    2d0e:	82 e0       	ldi	r24, 0x02	; 2
    2d10:	90 e0       	ldi	r25, 0x00	; 0
}
    2d12:	df 91       	pop	r29
    2d14:	cf 91       	pop	r28
    2d16:	1f 91       	pop	r17
    2d18:	0f 91       	pop	r16
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+5, thread1, "A");
  chSysLock();
  chSemAddCounterI(&sem1, 2);
  chSysUnlock();
  test_wait_threads();
  test_assert(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
    2d1a:	0c 94 e9 0f 	jmp	0x1fd2	; 0x1fd2 <_test_assert>

00002d1e <sem3_execute>:
  chSemWait(&sem1);
  chSemSignal(&sem1);
  return 0;
}

static void sem3_execute(void) {
    2d1e:	0f 93       	push	r16
    2d20:	1f 93       	push	r17

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread3, 0);
    2d22:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2d26:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2d2a:	44 81       	ldd	r20, Z+4	; 0x04
    2d2c:	4f 5f       	subi	r20, 0xFF	; 255
    2d2e:	00 e0       	ldi	r16, 0x00	; 0
    2d30:	10 e0       	ldi	r17, 0x00	; 0
    2d32:	26 ea       	ldi	r18, 0xA6	; 166
    2d34:	35 e1       	ldi	r19, 0x15	; 21
    2d36:	67 e9       	ldi	r22, 0x97	; 151
    2d38:	70 e0       	ldi	r23, 0x00	; 0
    2d3a:	80 91 8d 02 	lds	r24, 0x028D
    2d3e:	90 91 8e 02 	lds	r25, 0x028E
    2d42:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2d46:	90 93 40 0c 	sts	0x0C40, r25
    2d4a:	80 93 3f 0c 	sts	0x0C3F, r24
  chSemSignalWait(&sem1, &sem1);
    2d4e:	60 e0       	ldi	r22, 0x00	; 0
    2d50:	72 e0       	ldi	r23, 0x02	; 2
    2d52:	cb 01       	movw	r24, r22
    2d54:	0e 94 35 06 	call	0xc6a	; 0xc6a <chSemSignalWait>
  test_assert(1, isempty(&sem1.s_queue), "queue not empty");
    2d58:	61 e0       	ldi	r22, 0x01	; 1
    2d5a:	80 91 00 02 	lds	r24, 0x0200
    2d5e:	90 91 01 02 	lds	r25, 0x0201
    2d62:	80 50       	subi	r24, 0x00	; 0
    2d64:	92 40       	sbci	r25, 0x02	; 2
    2d66:	09 f0       	breq	.+2      	; 0x2d6a <sem3_execute+0x4c>
    2d68:	60 e0       	ldi	r22, 0x00	; 0
    2d6a:	81 e0       	ldi	r24, 0x01	; 1
    2d6c:	90 e0       	ldi	r25, 0x00	; 0
    2d6e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2d72:	88 23       	and	r24, r24
    2d74:	19 f0       	breq	.+6      	; 0x2d7c <sem3_execute+0x5e>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
}
    2d76:	1f 91       	pop	r17
    2d78:	0f 91       	pop	r16
    2d7a:	08 95       	ret
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
    2d7c:	61 e0       	ldi	r22, 0x01	; 1
    2d7e:	80 91 04 02 	lds	r24, 0x0204
    2d82:	81 11       	cpse	r24, r1
    2d84:	25 c0       	rjmp	.+74     	; 0x2dd0 <sem3_execute+0xb2>
    2d86:	82 e0       	ldi	r24, 0x02	; 2
    2d88:	90 e0       	ldi	r25, 0x00	; 0
    2d8a:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2d8e:	81 11       	cpse	r24, r1
    2d90:	f2 cf       	rjmp	.-28     	; 0x2d76 <sem3_execute+0x58>

  chSemSignalWait(&sem1, &sem1);
    2d92:	60 e0       	ldi	r22, 0x00	; 0
    2d94:	72 e0       	ldi	r23, 0x02	; 2
    2d96:	cb 01       	movw	r24, r22
    2d98:	0e 94 35 06 	call	0xc6a	; 0xc6a <chSemSignalWait>
  test_assert(3, isempty(&sem1.s_queue), "queue not empty");
    2d9c:	61 e0       	ldi	r22, 0x01	; 1
    2d9e:	80 91 00 02 	lds	r24, 0x0200
    2da2:	90 91 01 02 	lds	r25, 0x0201
    2da6:	80 50       	subi	r24, 0x00	; 0
    2da8:	92 40       	sbci	r25, 0x02	; 2
    2daa:	09 f0       	breq	.+2      	; 0x2dae <sem3_execute+0x90>
    2dac:	60 e0       	ldi	r22, 0x00	; 0
    2dae:	83 e0       	ldi	r24, 0x03	; 3
    2db0:	90 e0       	ldi	r25, 0x00	; 0
    2db2:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2db6:	81 11       	cpse	r24, r1
    2db8:	de cf       	rjmp	.-68     	; 0x2d76 <sem3_execute+0x58>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
    2dba:	61 e0       	ldi	r22, 0x01	; 1
    2dbc:	80 91 04 02 	lds	r24, 0x0204
    2dc0:	81 11       	cpse	r24, r1
    2dc2:	0e c0       	rjmp	.+28     	; 0x2de0 <sem3_execute+0xc2>
    2dc4:	84 e0       	ldi	r24, 0x04	; 4
    2dc6:	90 e0       	ldi	r25, 0x00	; 0
}
    2dc8:	1f 91       	pop	r17
    2dca:	0f 91       	pop	r16
  test_assert(1, isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
    2dcc:	0c 94 e9 0f 	jmp	0x1fd2	; 0x1fd2 <_test_assert>
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
    2dd0:	60 e0       	ldi	r22, 0x00	; 0
    2dd2:	82 e0       	ldi	r24, 0x02	; 2
    2dd4:	90 e0       	ldi	r25, 0x00	; 0
    2dd6:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2dda:	81 11       	cpse	r24, r1
    2ddc:	cc cf       	rjmp	.-104    	; 0x2d76 <sem3_execute+0x58>
    2dde:	d9 cf       	rjmp	.-78     	; 0x2d92 <sem3_execute+0x74>

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
    2de0:	60 e0       	ldi	r22, 0x00	; 0
    2de2:	f0 cf       	rjmp	.-32     	; 0x2dc4 <sem3_execute+0xa6>

00002de4 <sem2_execute>:
  chSchRescheduleS();
  chSysUnlock();
  return 0;
}

static void sem2_execute(void) {
    2de4:	0f 93       	push	r16
    2de6:	1f 93       	push	r17
    2de8:	cf 93       	push	r28
    2dea:	df 93       	push	r29
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
    2dec:	60 e0       	ldi	r22, 0x00	; 0
    2dee:	70 e0       	ldi	r23, 0x00	; 0
    2df0:	80 e0       	ldi	r24, 0x00	; 0
    2df2:	92 e0       	ldi	r25, 0x02	; 2
    2df4:	0e 94 d1 05 	call	0xba2	; 0xba2 <chSemWaitTimeout>
  test_assert(1, msg == RDY_TIMEOUT, "wrong wake-up message");
    2df8:	61 e0       	ldi	r22, 0x01	; 1
    2dfa:	01 96       	adiw	r24, 0x01	; 1
    2dfc:	09 f0       	breq	.+2      	; 0x2e00 <sem2_execute+0x1c>
    2dfe:	60 e0       	ldi	r22, 0x00	; 0
    2e00:	81 e0       	ldi	r24, 0x01	; 1
    2e02:	90 e0       	ldi	r25, 0x00	; 0
    2e04:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2e08:	88 23       	and	r24, r24
    2e0a:	29 f0       	breq	.+10     	; 0x2e16 <sem2_execute+0x32>
    test_assert(8, isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
}
    2e0c:	df 91       	pop	r29
    2e0e:	cf 91       	pop	r28
    2e10:	1f 91       	pop	r17
    2e12:	0f 91       	pop	r16
    2e14:	08 95       	ret
  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == RDY_TIMEOUT, "wrong wake-up message");
  test_assert(2, isempty(&sem1.s_queue), "queue not empty");
    2e16:	61 e0       	ldi	r22, 0x01	; 1
    2e18:	80 91 00 02 	lds	r24, 0x0200
    2e1c:	90 91 01 02 	lds	r25, 0x0201
    2e20:	80 50       	subi	r24, 0x00	; 0
    2e22:	92 40       	sbci	r25, 0x02	; 2
    2e24:	09 f0       	breq	.+2      	; 0x2e28 <sem2_execute+0x44>
    2e26:	60 e0       	ldi	r22, 0x00	; 0
    2e28:	82 e0       	ldi	r24, 0x02	; 2
    2e2a:	90 e0       	ldi	r25, 0x00	; 0
    2e2c:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2e30:	81 11       	cpse	r24, r1
    2e32:	ec cf       	rjmp	.-40     	; 0x2e0c <sem2_execute+0x28>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
    2e34:	61 e0       	ldi	r22, 0x01	; 1
    2e36:	80 91 04 02 	lds	r24, 0x0204
    2e3a:	81 11       	cpse	r24, r1
    2e3c:	60 e0       	ldi	r22, 0x00	; 0
    2e3e:	83 e0       	ldi	r24, 0x03	; 3
    2e40:	90 e0       	ldi	r25, 0x00	; 0
    2e42:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2e46:	81 11       	cpse	r24, r1
    2e48:	e1 cf       	rjmp	.-62     	; 0x2e0c <sem2_execute+0x28>

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
    2e4a:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2e4e:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2e52:	44 81       	ldd	r20, Z+4	; 0x04
    2e54:	41 50       	subi	r20, 0x01	; 1
    2e56:	00 e0       	ldi	r16, 0x00	; 0
    2e58:	10 e0       	ldi	r17, 0x00	; 0
    2e5a:	20 ec       	ldi	r18, 0xC0	; 192
    2e5c:	35 e1       	ldi	r19, 0x15	; 21
    2e5e:	67 e9       	ldi	r22, 0x97	; 151
    2e60:	70 e0       	ldi	r23, 0x00	; 0
    2e62:	80 91 8d 02 	lds	r24, 0x028D
    2e66:	90 91 8e 02 	lds	r25, 0x028E
    2e6a:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2e6e:	90 93 40 0c 	sts	0x0C40, r25
    2e72:	80 93 3f 0c 	sts	0x0C3F, r24
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
    2e76:	64 ef       	ldi	r22, 0xF4	; 244
    2e78:	71 e0       	ldi	r23, 0x01	; 1
    2e7a:	80 e0       	ldi	r24, 0x00	; 0
    2e7c:	92 e0       	ldi	r25, 0x02	; 2
    2e7e:	0e 94 d1 05 	call	0xba2	; 0xba2 <chSemWaitTimeout>
    2e82:	ec 01       	movw	r28, r24
  test_wait_threads();
    2e84:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_assert(4, msg == RDY_OK, "wrong wake-up message");
    2e88:	61 e0       	ldi	r22, 0x01	; 1
    2e8a:	cd 2b       	or	r28, r29
    2e8c:	09 f0       	breq	.+2      	; 0x2e90 <sem2_execute+0xac>
    2e8e:	6d c0       	rjmp	.+218    	; 0x2f6a <sem2_execute+0x186>
    2e90:	84 e0       	ldi	r24, 0x04	; 4
    2e92:	90 e0       	ldi	r25, 0x00	; 0
    2e94:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2e98:	81 11       	cpse	r24, r1
    2e9a:	b8 cf       	rjmp	.-144    	; 0x2e0c <sem2_execute+0x28>
  test_assert(5, isempty(&sem1.s_queue), "queue not empty");
    2e9c:	61 e0       	ldi	r22, 0x01	; 1
    2e9e:	80 91 00 02 	lds	r24, 0x0200
    2ea2:	90 91 01 02 	lds	r25, 0x0201
    2ea6:	80 50       	subi	r24, 0x00	; 0
    2ea8:	92 40       	sbci	r25, 0x02	; 2
    2eaa:	09 f0       	breq	.+2      	; 0x2eae <sem2_execute+0xca>
    2eac:	60 e0       	ldi	r22, 0x00	; 0
    2eae:	85 e0       	ldi	r24, 0x05	; 5
    2eb0:	90 e0       	ldi	r25, 0x00	; 0
    2eb2:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2eb6:	81 11       	cpse	r24, r1
    2eb8:	a9 cf       	rjmp	.-174    	; 0x2e0c <sem2_execute+0x28>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
    2eba:	61 e0       	ldi	r22, 0x01	; 1
    2ebc:	80 91 04 02 	lds	r24, 0x0204
    2ec0:	81 11       	cpse	r24, r1
    2ec2:	60 e0       	ldi	r22, 0x00	; 0
    2ec4:	86 e0       	ldi	r24, 0x06	; 6
    2ec6:	90 e0       	ldi	r25, 0x00	; 0
    2ec8:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2ecc:	81 11       	cpse	r24, r1
    2ece:	9e cf       	rjmp	.-196    	; 0x2e0c <sem2_execute+0x28>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
    2ed0:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  target_time = chTimeNow() + MS2ST(5 * 500);
    2ed4:	c0 91 2f 0c 	lds	r28, 0x0C2F
    2ed8:	d0 91 30 0c 	lds	r29, 0x0C30
    2edc:	11 e4       	ldi	r17, 0x41	; 65
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
    2ede:	81 2f       	mov	r24, r17
    2ee0:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(500));
    2ee4:	64 ef       	ldi	r22, 0xF4	; 244
    2ee6:	71 e0       	ldi	r23, 0x01	; 1
    2ee8:	80 e0       	ldi	r24, 0x00	; 0
    2eea:	92 e0       	ldi	r25, 0x02	; 2
    2eec:	0e 94 d1 05 	call	0xba2	; 0xba2 <chSemWaitTimeout>
    test_assert(7, msg == RDY_TIMEOUT, "wrong wake-up message");
    2ef0:	61 e0       	ldi	r22, 0x01	; 1
    2ef2:	01 96       	adiw	r24, 0x01	; 1
    2ef4:	09 f0       	breq	.+2      	; 0x2ef8 <sem2_execute+0x114>
    2ef6:	60 e0       	ldi	r22, 0x00	; 0
    2ef8:	87 e0       	ldi	r24, 0x07	; 7
    2efa:	90 e0       	ldi	r25, 0x00	; 0
    2efc:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2f00:	81 11       	cpse	r24, r1
    2f02:	84 cf       	rjmp	.-248    	; 0x2e0c <sem2_execute+0x28>
    test_assert(8, isempty(&sem1.s_queue), "queue not empty");
    2f04:	61 e0       	ldi	r22, 0x01	; 1
    2f06:	20 91 00 02 	lds	r18, 0x0200
    2f0a:	30 91 01 02 	lds	r19, 0x0201
    2f0e:	20 50       	subi	r18, 0x00	; 0
    2f10:	32 40       	sbci	r19, 0x02	; 2
    2f12:	09 f0       	breq	.+2      	; 0x2f16 <sem2_execute+0x132>
    2f14:	60 e0       	ldi	r22, 0x00	; 0
    2f16:	88 e0       	ldi	r24, 0x08	; 8
    2f18:	90 e0       	ldi	r25, 0x00	; 0
    2f1a:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2f1e:	81 11       	cpse	r24, r1
    2f20:	75 cf       	rjmp	.-278    	; 0x2e0c <sem2_execute+0x28>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
    2f22:	61 e0       	ldi	r22, 0x01	; 1
    2f24:	80 91 04 02 	lds	r24, 0x0204
    2f28:	81 11       	cpse	r24, r1
    2f2a:	60 e0       	ldi	r22, 0x00	; 0
    2f2c:	89 e0       	ldi	r24, 0x09	; 9
    2f2e:	90 e0       	ldi	r25, 0x00	; 0
    2f30:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    2f34:	81 11       	cpse	r24, r1
    2f36:	6a cf       	rjmp	.-300    	; 0x2e0c <sem2_execute+0x28>
    2f38:	1f 5f       	subi	r17, 0xFF	; 255
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(5 * 500);
  for (i = 0; i < 5; i++) {
    2f3a:	16 34       	cpi	r17, 0x46	; 70
    2f3c:	81 f6       	brne	.-96     	; 0x2ede <sem2_execute+0xfa>
    msg = chSemWaitTimeout(&sem1, MS2ST(500));
    test_assert(7, msg == RDY_TIMEOUT, "wrong wake-up message");
    test_assert(8, isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
    2f3e:	68 ec       	ldi	r22, 0xC8	; 200
    2f40:	75 e0       	ldi	r23, 0x05	; 5
    2f42:	8a e0       	ldi	r24, 0x0A	; 10
    2f44:	90 e0       	ldi	r25, 0x00	; 0
    2f46:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <_test_assert_sequence>
    2f4a:	81 11       	cpse	r24, r1
    2f4c:	5f cf       	rjmp	.-322    	; 0x2e0c <sem2_execute+0x28>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
    2f4e:	ae 01       	movw	r20, r28
    2f50:	47 53       	subi	r20, 0x37	; 55
    2f52:	56 4f       	sbci	r21, 0xF6	; 246

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(5 * 500);
    2f54:	be 01       	movw	r22, r28
    2f56:	6c 53       	subi	r22, 0x3C	; 60
    2f58:	76 4f       	sbci	r23, 0xF6	; 246
    test_assert(7, msg == RDY_TIMEOUT, "wrong wake-up message");
    test_assert(8, isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
    2f5a:	8b e0       	ldi	r24, 0x0B	; 11
    2f5c:	90 e0       	ldi	r25, 0x00	; 0
}
    2f5e:	df 91       	pop	r29
    2f60:	cf 91       	pop	r28
    2f62:	1f 91       	pop	r17
    2f64:	0f 91       	pop	r16
    test_assert(7, msg == RDY_TIMEOUT, "wrong wake-up message");
    test_assert(8, isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
    2f66:	0c 94 20 10 	jmp	0x2040	; 0x2040 <_test_assert_time_window>
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
  test_wait_threads();
  test_assert(4, msg == RDY_OK, "wrong wake-up message");
    2f6a:	60 e0       	ldi	r22, 0x00	; 0
    2f6c:	91 cf       	rjmp	.-222    	; 0x2e90 <sem2_execute+0xac>

00002f6e <mtx8_execute>:
  test_emit_token(*(char *)p);
  chMtxUnlock();
  return 0;
}

static void mtx8_execute(void) {
    2f6e:	0f 93       	push	r16
    2f70:	1f 93       	push	r17
    2f72:	cf 93       	push	r28

  tprio_t prio = chThdGetPriority();
    2f74:	e0 91 3c 0c 	lds	r30, 0x0C3C
    2f78:	f0 91 3d 0c 	lds	r31, 0x0C3D
    2f7c:	c4 81       	ldd	r28, Z+4	; 0x04
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
    2f7e:	4c 2f       	mov	r20, r28
    2f80:	4f 5f       	subi	r20, 0xFF	; 255
    2f82:	04 ec       	ldi	r16, 0xC4	; 196
    2f84:	15 e0       	ldi	r17, 0x05	; 5
    2f86:	2f e3       	ldi	r18, 0x3F	; 63
    2f88:	38 e1       	ldi	r19, 0x18	; 24
    2f8a:	67 e9       	ldi	r22, 0x97	; 151
    2f8c:	70 e0       	ldi	r23, 0x00	; 0
    2f8e:	80 91 8d 02 	lds	r24, 0x028D
    2f92:	90 91 8e 02 	lds	r25, 0x028E
    2f96:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2f9a:	90 93 40 0c 	sts	0x0C40, r25
    2f9e:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
    2fa2:	4c 2f       	mov	r20, r28
    2fa4:	4e 5f       	subi	r20, 0xFE	; 254
    2fa6:	09 e9       	ldi	r16, 0x99	; 153
    2fa8:	16 e0       	ldi	r17, 0x06	; 6
    2faa:	2a e2       	ldi	r18, 0x2A	; 42
    2fac:	38 e1       	ldi	r19, 0x18	; 24
    2fae:	67 e9       	ldi	r22, 0x97	; 151
    2fb0:	70 e0       	ldi	r23, 0x00	; 0
    2fb2:	80 91 8f 02 	lds	r24, 0x028F
    2fb6:	90 91 90 02 	lds	r25, 0x0290
    2fba:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2fbe:	90 93 42 0c 	sts	0x0C42, r25
    2fc2:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
    2fc6:	4c 2f       	mov	r20, r28
    2fc8:	4d 5f       	subi	r20, 0xFD	; 253
    2fca:	06 ec       	ldi	r16, 0xC6	; 198
    2fcc:	15 e0       	ldi	r17, 0x05	; 5
    2fce:	28 e0       	ldi	r18, 0x08	; 8
    2fd0:	38 e1       	ldi	r19, 0x18	; 24
    2fd2:	67 e9       	ldi	r22, 0x97	; 151
    2fd4:	70 e0       	ldi	r23, 0x00	; 0
    2fd6:	80 91 91 02 	lds	r24, 0x0291
    2fda:	90 91 92 02 	lds	r25, 0x0292
    2fde:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    2fe2:	90 93 44 0c 	sts	0x0C44, r25
    2fe6:	80 93 43 0c 	sts	0x0C43, r24
  chCondSignal(&c1);
    2fea:	85 e1       	ldi	r24, 0x15	; 21
    2fec:	92 e0       	ldi	r25, 0x02	; 2
    2fee:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <chCondSignal>
  chCondSignal(&c1);
    2ff2:	85 e1       	ldi	r24, 0x15	; 21
    2ff4:	92 e0       	ldi	r25, 0x02	; 2
    2ff6:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <chCondSignal>
  test_wait_threads();
    2ffa:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_assert_sequence(1, "ABC");
    2ffe:	67 e9       	ldi	r22, 0x97	; 151
    3000:	76 e0       	ldi	r23, 0x06	; 6
    3002:	81 e0       	ldi	r24, 0x01	; 1
    3004:	90 e0       	ldi	r25, 0x00	; 0
}
    3006:	cf 91       	pop	r28
    3008:	1f 91       	pop	r17
    300a:	0f 91       	pop	r16
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
  chCondSignal(&c1);
  chCondSignal(&c1);
  test_wait_threads();
  test_assert_sequence(1, "ABC");
    300c:	0c 94 f8 0f 	jmp	0x1ff0	; 0x1ff0 <_test_assert_sequence>

00003010 <thread12>:
  chMtxUnlock();
  chMtxUnlock();
  return 0;
}

static msg_t thread12(void *p) {
    3010:	cf 93       	push	r28
    3012:	df 93       	push	r29
    3014:	ec 01       	movw	r28, r24

  chMtxLock(&m2);
    3016:	8d e0       	ldi	r24, 0x0D	; 13
    3018:	92 e0       	ldi	r25, 0x02	; 2
    301a:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_emit_token(*(char *)p);
    301e:	88 81       	ld	r24, Y
    3020:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  chMtxUnlock();
    3024:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  return 0;
}
    3028:	80 e0       	ldi	r24, 0x00	; 0
    302a:	90 e0       	ldi	r25, 0x00	; 0
    302c:	df 91       	pop	r29
    302e:	cf 91       	pop	r28
    3030:	08 95       	ret

00003032 <thread1>:
static void mtx1_setup(void) {

  chMtxInit(&m1);
}

static msg_t thread1(void *p) {
    3032:	cf 93       	push	r28
    3034:	df 93       	push	r29
    3036:	ec 01       	movw	r28, r24

  chMtxLock(&m1);
    3038:	85 e0       	ldi	r24, 0x05	; 5
    303a:	92 e0       	ldi	r25, 0x02	; 2
    303c:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_emit_token(*(char *)p);
    3040:	88 81       	ld	r24, Y
    3042:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  chMtxUnlock();
    3046:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  return 0;
}
    304a:	80 e0       	ldi	r24, 0x00	; 0
    304c:	90 e0       	ldi	r25, 0x00	; 0
    304e:	df 91       	pop	r29
    3050:	cf 91       	pop	r28
    3052:	08 95       	ret

00003054 <thread10>:

  chCondInit(&c1);
  chMtxInit(&m1);
}

static msg_t thread10(void *p) {
    3054:	cf 93       	push	r28
    3056:	df 93       	push	r29
    3058:	ec 01       	movw	r28, r24

  chMtxLock(&m1);
    305a:	85 e0       	ldi	r24, 0x05	; 5
    305c:	92 e0       	ldi	r25, 0x02	; 2
    305e:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  chCondWait(&c1);
    3062:	85 e1       	ldi	r24, 0x15	; 21
    3064:	92 e0       	ldi	r25, 0x02	; 2
    3066:	0e 94 14 09 	call	0x1228	; 0x1228 <chCondWait>
  test_emit_token(*(char *)p);
    306a:	88 81       	ld	r24, Y
    306c:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  chMtxUnlock();
    3070:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  return 0;
}
    3074:	80 e0       	ldi	r24, 0x00	; 0
    3076:	90 e0       	ldi	r25, 0x00	; 0
    3078:	df 91       	pop	r29
    307a:	cf 91       	pop	r28
    307c:	08 95       	ret

0000307e <thread11>:
  chCondInit(&c1);
  chMtxInit(&m1);
  chMtxInit(&m2);
}

static msg_t thread11(void *p) {
    307e:	cf 93       	push	r28
    3080:	df 93       	push	r29
    3082:	ec 01       	movw	r28, r24

  chMtxLock(&m2);
    3084:	8d e0       	ldi	r24, 0x0D	; 13
    3086:	92 e0       	ldi	r25, 0x02	; 2
    3088:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  chMtxLock(&m1);
    308c:	85 e0       	ldi	r24, 0x05	; 5
    308e:	92 e0       	ldi	r25, 0x02	; 2
    3090:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
#if CH_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
    3094:	6f ef       	ldi	r22, 0xFF	; 255
    3096:	7f ef       	ldi	r23, 0xFF	; 255
    3098:	85 e1       	ldi	r24, 0x15	; 21
    309a:	92 e0       	ldi	r25, 0x02	; 2
    309c:	0e 94 66 09 	call	0x12cc	; 0x12cc <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
    30a0:	88 81       	ld	r24, Y
    30a2:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  chMtxUnlock();
    30a6:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  chMtxUnlock();
    30aa:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  return 0;
}
    30ae:	80 e0       	ldi	r24, 0x00	; 0
    30b0:	90 e0       	ldi	r25, 0x00	; 0
    30b2:	df 91       	pop	r29
    30b4:	cf 91       	pop	r28
    30b6:	08 95       	ret

000030b8 <mtx8_setup>:
 * to complete the code coverage.
 */

static void mtx8_setup(void) {

  chCondInit(&c1);
    30b8:	85 e1       	ldi	r24, 0x15	; 21
    30ba:	92 e0       	ldi	r25, 0x02	; 2
    30bc:	0e 94 74 08 	call	0x10e8	; 0x10e8 <chCondInit>
  chMtxInit(&m1);
    30c0:	85 e0       	ldi	r24, 0x05	; 5
    30c2:	92 e0       	ldi	r25, 0x02	; 2
    30c4:	0e 94 86 06 	call	0xd0c	; 0xd0c <chMtxInit>
  chMtxInit(&m2);
    30c8:	8d e0       	ldi	r24, 0x0D	; 13
    30ca:	92 e0       	ldi	r25, 0x02	; 2
    30cc:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <chMtxInit>

000030d0 <mtx7_setup>:
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {

  chCondInit(&c1);
    30d0:	85 e1       	ldi	r24, 0x15	; 21
    30d2:	92 e0       	ldi	r25, 0x02	; 2
    30d4:	0e 94 74 08 	call	0x10e8	; 0x10e8 <chCondInit>
  chMtxInit(&m1);
    30d8:	85 e0       	ldi	r24, 0x05	; 5
    30da:	92 e0       	ldi	r25, 0x02	; 2
    30dc:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <chMtxInit>

000030e0 <mtx6_setup>:
 * order regardless of the initial order.
 */

static void mtx6_setup(void) {

  chCondInit(&c1);
    30e0:	85 e1       	ldi	r24, 0x15	; 21
    30e2:	92 e0       	ldi	r25, 0x02	; 2
    30e4:	0e 94 74 08 	call	0x10e8	; 0x10e8 <chCondInit>
  chMtxInit(&m1);
    30e8:	85 e0       	ldi	r24, 0x05	; 5
    30ea:	92 e0       	ldi	r25, 0x02	; 2
    30ec:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <chMtxInit>

000030f0 <mtx5_setup>:
 * operation.
 */

static void mtx5_setup(void) {

  chMtxInit(&m1);
    30f0:	85 e0       	ldi	r24, 0x05	; 5
    30f2:	92 e0       	ldi	r25, 0x02	; 2
    30f4:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <chMtxInit>

000030f8 <mtx4_setup>:
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {

  chMtxInit(&m1);
    30f8:	85 e0       	ldi	r24, 0x05	; 5
    30fa:	92 e0       	ldi	r25, 0x02	; 2
    30fc:	0e 94 86 06 	call	0xd0c	; 0xd0c <chMtxInit>
  chMtxInit(&m2);
    3100:	8d e0       	ldi	r24, 0x0D	; 13
    3102:	92 e0       	ldi	r25, 0x02	; 2
    3104:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <chMtxInit>

00003108 <mtx3_setup>:
 * @endcode
 */

static void mtx3_setup(void) {

  chMtxInit(&m1); /* Mutex B.*/
    3108:	85 e0       	ldi	r24, 0x05	; 5
    310a:	92 e0       	ldi	r25, 0x02	; 2
    310c:	0e 94 86 06 	call	0xd0c	; 0xd0c <chMtxInit>
  chMtxInit(&m2); /* Mutex A.*/
    3110:	8d e0       	ldi	r24, 0x0D	; 13
    3112:	92 e0       	ldi	r25, 0x02	; 2
    3114:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <chMtxInit>

00003118 <mtx2_setup>:
 * @endcode
 */

static void mtx2_setup(void) {

  chMtxInit(&m1);
    3118:	85 e0       	ldi	r24, 0x05	; 5
    311a:	92 e0       	ldi	r25, 0x02	; 2
    311c:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <chMtxInit>

00003120 <mtx1_setup>:
 * priority order regardless of the initial order.
 */

static void mtx1_setup(void) {

  chMtxInit(&m1);
    3120:	85 e0       	ldi	r24, 0x05	; 5
    3122:	92 e0       	ldi	r25, 0x02	; 2
    3124:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <chMtxInit>

00003128 <mtx7_execute>:

  chCondInit(&c1);
  chMtxInit(&m1);
}

static void mtx7_execute(void) {
    3128:	0f 93       	push	r16
    312a:	1f 93       	push	r17
    312c:	cf 93       	push	r28

  tprio_t prio = chThdGetPriority();
    312e:	e0 91 3c 0c 	lds	r30, 0x0C3C
    3132:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3136:	c4 81       	ldd	r28, Z+4	; 0x04
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
    3138:	4c 2f       	mov	r20, r28
    313a:	4f 5f       	subi	r20, 0xFF	; 255
    313c:	0c ec       	ldi	r16, 0xCC	; 204
    313e:	15 e0       	ldi	r17, 0x05	; 5
    3140:	2a e2       	ldi	r18, 0x2A	; 42
    3142:	38 e1       	ldi	r19, 0x18	; 24
    3144:	67 e9       	ldi	r22, 0x97	; 151
    3146:	70 e0       	ldi	r23, 0x00	; 0
    3148:	80 91 8d 02 	lds	r24, 0x028D
    314c:	90 91 8e 02 	lds	r25, 0x028E
    3150:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3154:	90 93 40 0c 	sts	0x0C40, r25
    3158:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
    315c:	4c 2f       	mov	r20, r28
    315e:	4e 5f       	subi	r20, 0xFE	; 254
    3160:	0d ef       	ldi	r16, 0xFD	; 253
    3162:	17 e0       	ldi	r17, 0x07	; 7
    3164:	2a e2       	ldi	r18, 0x2A	; 42
    3166:	38 e1       	ldi	r19, 0x18	; 24
    3168:	67 e9       	ldi	r22, 0x97	; 151
    316a:	70 e0       	ldi	r23, 0x00	; 0
    316c:	80 91 8f 02 	lds	r24, 0x028F
    3170:	90 91 90 02 	lds	r25, 0x0290
    3174:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3178:	90 93 42 0c 	sts	0x0C42, r25
    317c:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
    3180:	4c 2f       	mov	r20, r28
    3182:	4d 5f       	subi	r20, 0xFD	; 253
    3184:	09 e9       	ldi	r16, 0x99	; 153
    3186:	16 e0       	ldi	r17, 0x06	; 6
    3188:	2a e2       	ldi	r18, 0x2A	; 42
    318a:	38 e1       	ldi	r19, 0x18	; 24
    318c:	67 e9       	ldi	r22, 0x97	; 151
    318e:	70 e0       	ldi	r23, 0x00	; 0
    3190:	80 91 91 02 	lds	r24, 0x0291
    3194:	90 91 92 02 	lds	r25, 0x0292
    3198:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    319c:	90 93 44 0c 	sts	0x0C44, r25
    31a0:	80 93 43 0c 	sts	0x0C43, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
    31a4:	4c 2f       	mov	r20, r28
    31a6:	4c 5f       	subi	r20, 0xFC	; 252
    31a8:	06 ec       	ldi	r16, 0xC6	; 198
    31aa:	15 e0       	ldi	r17, 0x05	; 5
    31ac:	2a e2       	ldi	r18, 0x2A	; 42
    31ae:	38 e1       	ldi	r19, 0x18	; 24
    31b0:	67 e9       	ldi	r22, 0x97	; 151
    31b2:	70 e0       	ldi	r23, 0x00	; 0
    31b4:	80 91 93 02 	lds	r24, 0x0293
    31b8:	90 91 94 02 	lds	r25, 0x0294
    31bc:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    31c0:	90 93 46 0c 	sts	0x0C46, r25
    31c4:	80 93 45 0c 	sts	0x0C45, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
    31c8:	4c 2f       	mov	r20, r28
    31ca:	4b 5f       	subi	r20, 0xFB	; 251
    31cc:	04 ec       	ldi	r16, 0xC4	; 196
    31ce:	15 e0       	ldi	r17, 0x05	; 5
    31d0:	2a e2       	ldi	r18, 0x2A	; 42
    31d2:	38 e1       	ldi	r19, 0x18	; 24
    31d4:	67 e9       	ldi	r22, 0x97	; 151
    31d6:	70 e0       	ldi	r23, 0x00	; 0
    31d8:	80 91 95 02 	lds	r24, 0x0295
    31dc:	90 91 96 02 	lds	r25, 0x0296
    31e0:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    31e4:	90 93 48 0c 	sts	0x0C48, r25
    31e8:	80 93 47 0c 	sts	0x0C47, r24
  chCondBroadcast(&c1);
    31ec:	85 e1       	ldi	r24, 0x15	; 21
    31ee:	92 e0       	ldi	r25, 0x02	; 2
    31f0:	0e 94 cf 08 	call	0x119e	; 0x119e <chCondBroadcast>
  test_wait_threads();
    31f4:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    31f8:	68 ec       	ldi	r22, 0xC8	; 200
    31fa:	75 e0       	ldi	r23, 0x05	; 5
    31fc:	81 e0       	ldi	r24, 0x01	; 1
    31fe:	90 e0       	ldi	r25, 0x00	; 0
}
    3200:	cf 91       	pop	r28
    3202:	1f 91       	pop	r17
    3204:	0f 91       	pop	r16
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
  chCondBroadcast(&c1);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
    3206:	0c 94 f8 0f 	jmp	0x1ff0	; 0x1ff0 <_test_assert_sequence>

0000320a <mtx6_execute>:
  test_emit_token(*(char *)p);
  chMtxUnlock();
  return 0;
}

static void mtx6_execute(void) {
    320a:	0f 93       	push	r16
    320c:	1f 93       	push	r17
    320e:	cf 93       	push	r28

  tprio_t prio = chThdGetPriority();
    3210:	e0 91 3c 0c 	lds	r30, 0x0C3C
    3214:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3218:	c4 81       	ldd	r28, Z+4	; 0x04
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
    321a:	4c 2f       	mov	r20, r28
    321c:	4f 5f       	subi	r20, 0xFF	; 255
    321e:	0c ec       	ldi	r16, 0xCC	; 204
    3220:	15 e0       	ldi	r17, 0x05	; 5
    3222:	2a e2       	ldi	r18, 0x2A	; 42
    3224:	38 e1       	ldi	r19, 0x18	; 24
    3226:	67 e9       	ldi	r22, 0x97	; 151
    3228:	70 e0       	ldi	r23, 0x00	; 0
    322a:	80 91 8d 02 	lds	r24, 0x028D
    322e:	90 91 8e 02 	lds	r25, 0x028E
    3232:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3236:	90 93 40 0c 	sts	0x0C40, r25
    323a:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
    323e:	4c 2f       	mov	r20, r28
    3240:	4e 5f       	subi	r20, 0xFE	; 254
    3242:	0d ef       	ldi	r16, 0xFD	; 253
    3244:	17 e0       	ldi	r17, 0x07	; 7
    3246:	2a e2       	ldi	r18, 0x2A	; 42
    3248:	38 e1       	ldi	r19, 0x18	; 24
    324a:	67 e9       	ldi	r22, 0x97	; 151
    324c:	70 e0       	ldi	r23, 0x00	; 0
    324e:	80 91 8f 02 	lds	r24, 0x028F
    3252:	90 91 90 02 	lds	r25, 0x0290
    3256:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    325a:	90 93 42 0c 	sts	0x0C42, r25
    325e:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
    3262:	4c 2f       	mov	r20, r28
    3264:	4d 5f       	subi	r20, 0xFD	; 253
    3266:	09 e9       	ldi	r16, 0x99	; 153
    3268:	16 e0       	ldi	r17, 0x06	; 6
    326a:	2a e2       	ldi	r18, 0x2A	; 42
    326c:	38 e1       	ldi	r19, 0x18	; 24
    326e:	67 e9       	ldi	r22, 0x97	; 151
    3270:	70 e0       	ldi	r23, 0x00	; 0
    3272:	80 91 91 02 	lds	r24, 0x0291
    3276:	90 91 92 02 	lds	r25, 0x0292
    327a:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    327e:	90 93 44 0c 	sts	0x0C44, r25
    3282:	80 93 43 0c 	sts	0x0C43, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
    3286:	4c 2f       	mov	r20, r28
    3288:	4c 5f       	subi	r20, 0xFC	; 252
    328a:	06 ec       	ldi	r16, 0xC6	; 198
    328c:	15 e0       	ldi	r17, 0x05	; 5
    328e:	2a e2       	ldi	r18, 0x2A	; 42
    3290:	38 e1       	ldi	r19, 0x18	; 24
    3292:	67 e9       	ldi	r22, 0x97	; 151
    3294:	70 e0       	ldi	r23, 0x00	; 0
    3296:	80 91 93 02 	lds	r24, 0x0293
    329a:	90 91 94 02 	lds	r25, 0x0294
    329e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    32a2:	90 93 46 0c 	sts	0x0C46, r25
    32a6:	80 93 45 0c 	sts	0x0C45, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
    32aa:	4c 2f       	mov	r20, r28
    32ac:	4b 5f       	subi	r20, 0xFB	; 251
    32ae:	04 ec       	ldi	r16, 0xC4	; 196
    32b0:	15 e0       	ldi	r17, 0x05	; 5
    32b2:	2a e2       	ldi	r18, 0x2A	; 42
    32b4:	38 e1       	ldi	r19, 0x18	; 24
    32b6:	67 e9       	ldi	r22, 0x97	; 151
    32b8:	70 e0       	ldi	r23, 0x00	; 0
    32ba:	80 91 95 02 	lds	r24, 0x0295
    32be:	90 91 96 02 	lds	r25, 0x0296
    32c2:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    32c6:	90 93 48 0c 	sts	0x0C48, r25
    32ca:	80 93 47 0c 	sts	0x0C47, r24
  chSysLock();
    32ce:	f8 94       	cli
  chCondSignalI(&c1);
    32d0:	85 e1       	ldi	r24, 0x15	; 21
    32d2:	92 e0       	ldi	r25, 0x02	; 2
    32d4:	0e 94 94 08 	call	0x1128	; 0x1128 <chCondSignalI>
  chCondSignalI(&c1);
    32d8:	85 e1       	ldi	r24, 0x15	; 21
    32da:	92 e0       	ldi	r25, 0x02	; 2
    32dc:	0e 94 94 08 	call	0x1128	; 0x1128 <chCondSignalI>
  chCondSignalI(&c1);
    32e0:	85 e1       	ldi	r24, 0x15	; 21
    32e2:	92 e0       	ldi	r25, 0x02	; 2
    32e4:	0e 94 94 08 	call	0x1128	; 0x1128 <chCondSignalI>
  chCondSignalI(&c1);
    32e8:	85 e1       	ldi	r24, 0x15	; 21
    32ea:	92 e0       	ldi	r25, 0x02	; 2
    32ec:	0e 94 94 08 	call	0x1128	; 0x1128 <chCondSignalI>
  chCondSignalI(&c1);
    32f0:	85 e1       	ldi	r24, 0x15	; 21
    32f2:	92 e0       	ldi	r25, 0x02	; 2
    32f4:	0e 94 94 08 	call	0x1128	; 0x1128 <chCondSignalI>
  chSchRescheduleS();
    32f8:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  chSysUnlock();
    32fc:	78 94       	sei
  test_wait_threads();
    32fe:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    3302:	68 ec       	ldi	r22, 0xC8	; 200
    3304:	75 e0       	ldi	r23, 0x05	; 5
    3306:	81 e0       	ldi	r24, 0x01	; 1
    3308:	90 e0       	ldi	r25, 0x00	; 0
}
    330a:	cf 91       	pop	r28
    330c:	1f 91       	pop	r17
    330e:	0f 91       	pop	r16
  chCondSignalI(&c1);
  chCondSignalI(&c1);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
    3310:	0c 94 f8 0f 	jmp	0x1ff0	; 0x1ff0 <_test_assert_sequence>

00003314 <mtx1_execute>:
  test_emit_token(*(char *)p);
  chMtxUnlock();
  return 0;
}

static void mtx1_execute(void) {
    3314:	0f 93       	push	r16
    3316:	1f 93       	push	r17
    3318:	cf 93       	push	r28

  tprio_t prio = chThdGetPriority(); /* Because priority inheritance.*/
    331a:	e0 91 3c 0c 	lds	r30, 0x0C3C
    331e:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3322:	c4 81       	ldd	r28, Z+4	; 0x04
  chMtxLock(&m1);
    3324:	85 e0       	ldi	r24, 0x05	; 5
    3326:	92 e0       	ldi	r25, 0x02	; 2
    3328:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    332c:	4c 2f       	mov	r20, r28
    332e:	4f 5f       	subi	r20, 0xFF	; 255
    3330:	0c ec       	ldi	r16, 0xCC	; 204
    3332:	15 e0       	ldi	r17, 0x05	; 5
    3334:	29 e1       	ldi	r18, 0x19	; 25
    3336:	38 e1       	ldi	r19, 0x18	; 24
    3338:	67 e9       	ldi	r22, 0x97	; 151
    333a:	70 e0       	ldi	r23, 0x00	; 0
    333c:	80 91 8d 02 	lds	r24, 0x028D
    3340:	90 91 8e 02 	lds	r25, 0x028E
    3344:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3348:	90 93 40 0c 	sts	0x0C40, r25
    334c:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    3350:	4c 2f       	mov	r20, r28
    3352:	4e 5f       	subi	r20, 0xFE	; 254
    3354:	0d ef       	ldi	r16, 0xFD	; 253
    3356:	17 e0       	ldi	r17, 0x07	; 7
    3358:	29 e1       	ldi	r18, 0x19	; 25
    335a:	38 e1       	ldi	r19, 0x18	; 24
    335c:	67 e9       	ldi	r22, 0x97	; 151
    335e:	70 e0       	ldi	r23, 0x00	; 0
    3360:	80 91 8f 02 	lds	r24, 0x028F
    3364:	90 91 90 02 	lds	r25, 0x0290
    3368:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    336c:	90 93 42 0c 	sts	0x0C42, r25
    3370:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    3374:	4c 2f       	mov	r20, r28
    3376:	4d 5f       	subi	r20, 0xFD	; 253
    3378:	09 e9       	ldi	r16, 0x99	; 153
    337a:	16 e0       	ldi	r17, 0x06	; 6
    337c:	29 e1       	ldi	r18, 0x19	; 25
    337e:	38 e1       	ldi	r19, 0x18	; 24
    3380:	67 e9       	ldi	r22, 0x97	; 151
    3382:	70 e0       	ldi	r23, 0x00	; 0
    3384:	80 91 91 02 	lds	r24, 0x0291
    3388:	90 91 92 02 	lds	r25, 0x0292
    338c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3390:	90 93 44 0c 	sts	0x0C44, r25
    3394:	80 93 43 0c 	sts	0x0C43, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
    3398:	4c 2f       	mov	r20, r28
    339a:	4c 5f       	subi	r20, 0xFC	; 252
    339c:	06 ec       	ldi	r16, 0xC6	; 198
    339e:	15 e0       	ldi	r17, 0x05	; 5
    33a0:	29 e1       	ldi	r18, 0x19	; 25
    33a2:	38 e1       	ldi	r19, 0x18	; 24
    33a4:	67 e9       	ldi	r22, 0x97	; 151
    33a6:	70 e0       	ldi	r23, 0x00	; 0
    33a8:	80 91 93 02 	lds	r24, 0x0293
    33ac:	90 91 94 02 	lds	r25, 0x0294
    33b0:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    33b4:	90 93 46 0c 	sts	0x0C46, r25
    33b8:	80 93 45 0c 	sts	0x0C45, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
    33bc:	4c 2f       	mov	r20, r28
    33be:	4b 5f       	subi	r20, 0xFB	; 251
    33c0:	04 ec       	ldi	r16, 0xC4	; 196
    33c2:	15 e0       	ldi	r17, 0x05	; 5
    33c4:	29 e1       	ldi	r18, 0x19	; 25
    33c6:	38 e1       	ldi	r19, 0x18	; 24
    33c8:	67 e9       	ldi	r22, 0x97	; 151
    33ca:	70 e0       	ldi	r23, 0x00	; 0
    33cc:	80 91 95 02 	lds	r24, 0x0295
    33d0:	90 91 96 02 	lds	r25, 0x0296
    33d4:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    33d8:	90 93 48 0c 	sts	0x0C48, r25
    33dc:	80 93 47 0c 	sts	0x0C47, r24
  chMtxUnlock();
    33e0:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  test_wait_threads();
    33e4:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_assert(1, prio == chThdGetPriority(), "wrong priority level");
    33e8:	e0 91 3c 0c 	lds	r30, 0x0C3C
    33ec:	f0 91 3d 0c 	lds	r31, 0x0C3D
    33f0:	61 e0       	ldi	r22, 0x01	; 1
    33f2:	84 81       	ldd	r24, Z+4	; 0x04
    33f4:	8c 13       	cpse	r24, r28
    33f6:	60 e0       	ldi	r22, 0x00	; 0
    33f8:	81 e0       	ldi	r24, 0x01	; 1
    33fa:	90 e0       	ldi	r25, 0x00	; 0
    33fc:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3400:	88 23       	and	r24, r24
    3402:	21 f0       	breq	.+8      	; 0x340c <mtx1_execute+0xf8>
  test_assert_sequence(2, "ABCDE");
}
    3404:	cf 91       	pop	r28
    3406:	1f 91       	pop	r17
    3408:	0f 91       	pop	r16
    340a:	08 95       	ret
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock();
  test_wait_threads();
  test_assert(1, prio == chThdGetPriority(), "wrong priority level");
  test_assert_sequence(2, "ABCDE");
    340c:	68 ec       	ldi	r22, 0xC8	; 200
    340e:	75 e0       	ldi	r23, 0x05	; 5
    3410:	82 e0       	ldi	r24, 0x02	; 2
    3412:	90 e0       	ldi	r25, 0x00	; 0
}
    3414:	cf 91       	pop	r28
    3416:	1f 91       	pop	r17
    3418:	0f 91       	pop	r16
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock();
  test_wait_threads();
  test_assert(1, prio == chThdGetPriority(), "wrong priority level");
  test_assert_sequence(2, "ABCDE");
    341a:	0c 94 f8 0f 	jmp	0x1ff0	; 0x1ff0 <_test_assert_sequence>

0000341e <mtx5_execute>:
static void mtx5_setup(void) {

  chMtxInit(&m1);
}

static void mtx5_execute(void) {
    341e:	cf 93       	push	r28
  bool_t b;
  tprio_t prio;

  prio = chThdGetPriority();
    3420:	e0 91 3c 0c 	lds	r30, 0x0C3C
    3424:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3428:	c4 81       	ldd	r28, Z+4	; 0x04

  b = chMtxTryLock(&m1);
    342a:	85 e0       	ldi	r24, 0x05	; 5
    342c:	92 e0       	ldi	r25, 0x02	; 2
    342e:	0e 94 53 07 	call	0xea6	; 0xea6 <chMtxTryLock>
  test_assert(1, b, "already locked");
    3432:	68 2f       	mov	r22, r24
    3434:	81 e0       	ldi	r24, 0x01	; 1
    3436:	90 e0       	ldi	r25, 0x00	; 0
    3438:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    343c:	88 23       	and	r24, r24
    343e:	11 f0       	breq	.+4      	; 0x3444 <mtx5_execute+0x26>
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, isempty(&m1.m_queue), "queue not empty");
  test_assert(7, m1.m_owner == NULL, "still owned");
}
    3440:	cf 91       	pop	r28
    3442:	08 95       	ret
  prio = chThdGetPriority();

  b = chMtxTryLock(&m1);
  test_assert(1, b, "already locked");

  b = chMtxTryLock(&m1);
    3444:	85 e0       	ldi	r24, 0x05	; 5
    3446:	92 e0       	ldi	r25, 0x02	; 2
    3448:	0e 94 53 07 	call	0xea6	; 0xea6 <chMtxTryLock>
  test_assert(2, !b, "not locked");
    344c:	61 e0       	ldi	r22, 0x01	; 1
    344e:	81 11       	cpse	r24, r1
    3450:	57 c0       	rjmp	.+174    	; 0x3500 <mtx5_execute+0xe2>
    3452:	82 e0       	ldi	r24, 0x02	; 2
    3454:	90 e0       	ldi	r25, 0x00	; 0
    3456:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    345a:	81 11       	cpse	r24, r1
    345c:	f1 cf       	rjmp	.-30     	; 0x3440 <mtx5_execute+0x22>

  chSysLock();
    345e:	f8 94       	cli
  chMtxUnlockS();
    3460:	0e 94 db 07 	call	0xfb6	; 0xfb6 <chMtxUnlockS>
  chSysUnlock();
    3464:	78 94       	sei

  test_assert(3, isempty(&m1.m_queue), "queue not empty");
    3466:	61 e0       	ldi	r22, 0x01	; 1
    3468:	80 91 05 02 	lds	r24, 0x0205
    346c:	90 91 06 02 	lds	r25, 0x0206
    3470:	85 50       	subi	r24, 0x05	; 5
    3472:	92 40       	sbci	r25, 0x02	; 2
    3474:	09 f0       	breq	.+2      	; 0x3478 <mtx5_execute+0x5a>
    3476:	60 e0       	ldi	r22, 0x00	; 0
    3478:	83 e0       	ldi	r24, 0x03	; 3
    347a:	90 e0       	ldi	r25, 0x00	; 0
    347c:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3480:	81 11       	cpse	r24, r1
    3482:	de cf       	rjmp	.-68     	; 0x3440 <mtx5_execute+0x22>
  test_assert(4, m1.m_owner == NULL, "still owned");
    3484:	61 e0       	ldi	r22, 0x01	; 1
    3486:	80 91 09 02 	lds	r24, 0x0209
    348a:	90 91 0a 02 	lds	r25, 0x020A
    348e:	89 2b       	or	r24, r25
    3490:	09 f0       	breq	.+2      	; 0x3494 <mtx5_execute+0x76>
    3492:	3e c0       	rjmp	.+124    	; 0x3510 <mtx5_execute+0xf2>
    3494:	84 e0       	ldi	r24, 0x04	; 4
    3496:	90 e0       	ldi	r25, 0x00	; 0
    3498:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    349c:	81 11       	cpse	r24, r1
    349e:	d0 cf       	rjmp	.-96     	; 0x3440 <mtx5_execute+0x22>
  test_assert(5, chThdGetPriority() == prio, "wrong priority level");
    34a0:	e0 91 3c 0c 	lds	r30, 0x0C3C
    34a4:	f0 91 3d 0c 	lds	r31, 0x0C3D
    34a8:	61 e0       	ldi	r22, 0x01	; 1
    34aa:	84 81       	ldd	r24, Z+4	; 0x04
    34ac:	8c 13       	cpse	r24, r28
    34ae:	60 e0       	ldi	r22, 0x00	; 0
    34b0:	85 e0       	ldi	r24, 0x05	; 5
    34b2:	90 e0       	ldi	r25, 0x00	; 0
    34b4:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    34b8:	81 11       	cpse	r24, r1
    34ba:	c2 cf       	rjmp	.-124    	; 0x3440 <mtx5_execute+0x22>
  
  chMtxLock(&m1);
    34bc:	85 e0       	ldi	r24, 0x05	; 5
    34be:	92 e0       	ldi	r25, 0x02	; 2
    34c0:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  chMtxUnlockAll();
    34c4:	0e 94 25 08 	call	0x104a	; 0x104a <chMtxUnlockAll>
  test_assert(6, isempty(&m1.m_queue), "queue not empty");
    34c8:	61 e0       	ldi	r22, 0x01	; 1
    34ca:	80 91 05 02 	lds	r24, 0x0205
    34ce:	90 91 06 02 	lds	r25, 0x0206
    34d2:	85 50       	subi	r24, 0x05	; 5
    34d4:	92 40       	sbci	r25, 0x02	; 2
    34d6:	09 f0       	breq	.+2      	; 0x34da <mtx5_execute+0xbc>
    34d8:	60 e0       	ldi	r22, 0x00	; 0
    34da:	86 e0       	ldi	r24, 0x06	; 6
    34dc:	90 e0       	ldi	r25, 0x00	; 0
    34de:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    34e2:	81 11       	cpse	r24, r1
    34e4:	ad cf       	rjmp	.-166    	; 0x3440 <mtx5_execute+0x22>
  test_assert(7, m1.m_owner == NULL, "still owned");
    34e6:	61 e0       	ldi	r22, 0x01	; 1
    34e8:	80 91 09 02 	lds	r24, 0x0209
    34ec:	90 91 0a 02 	lds	r25, 0x020A
    34f0:	89 2b       	or	r24, r25
    34f2:	09 f0       	breq	.+2      	; 0x34f6 <mtx5_execute+0xd8>
    34f4:	60 e0       	ldi	r22, 0x00	; 0
    34f6:	87 e0       	ldi	r24, 0x07	; 7
    34f8:	90 e0       	ldi	r25, 0x00	; 0
}
    34fa:	cf 91       	pop	r28
  test_assert(5, chThdGetPriority() == prio, "wrong priority level");
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, isempty(&m1.m_queue), "queue not empty");
  test_assert(7, m1.m_owner == NULL, "still owned");
    34fc:	0c 94 e9 0f 	jmp	0x1fd2	; 0x1fd2 <_test_assert>

  b = chMtxTryLock(&m1);
  test_assert(1, b, "already locked");

  b = chMtxTryLock(&m1);
  test_assert(2, !b, "not locked");
    3500:	60 e0       	ldi	r22, 0x00	; 0
    3502:	82 e0       	ldi	r24, 0x02	; 2
    3504:	90 e0       	ldi	r25, 0x00	; 0
    3506:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    350a:	81 11       	cpse	r24, r1
    350c:	99 cf       	rjmp	.-206    	; 0x3440 <mtx5_execute+0x22>
    350e:	a7 cf       	rjmp	.-178    	; 0x345e <mtx5_execute+0x40>
  chSysLock();
  chMtxUnlockS();
  chSysUnlock();

  test_assert(3, isempty(&m1.m_queue), "queue not empty");
  test_assert(4, m1.m_owner == NULL, "still owned");
    3510:	60 e0       	ldi	r22, 0x00	; 0
    3512:	c0 cf       	rjmp	.-128    	; 0x3494 <mtx5_execute+0x76>

00003514 <mtx4_execute>:
  chMtxLock(&m1);
  chMtxUnlock();
  return 0;
}

static void mtx4_execute(void) {
    3514:	bf 92       	push	r11
    3516:	cf 92       	push	r12
    3518:	df 92       	push	r13
    351a:	ef 92       	push	r14
    351c:	ff 92       	push	r15
    351e:	0f 93       	push	r16
    3520:	1f 93       	push	r17
    3522:	cf 93       	push	r28
    3524:	df 93       	push	r29
  tprio_t p, p1, p2;

  p = chThdGetPriority();
    3526:	e0 91 3c 0c 	lds	r30, 0x0C3C
    352a:	f0 91 3d 0c 	lds	r31, 0x0C3D
    352e:	d4 80       	ldd	r13, Z+4	; 0x04
  p1 = p + 1;
    3530:	cd 2c       	mov	r12, r13
    3532:	c3 94       	inc	r12
  p2 = p + 2;
    3534:	bd 2c       	mov	r11, r13
    3536:	b3 94       	inc	r11
    3538:	b3 94       	inc	r11
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
    353a:	e0 90 8d 02 	lds	r14, 0x028D
    353e:	f0 90 8e 02 	lds	r15, 0x028E
    3542:	06 ec       	ldi	r16, 0xC6	; 198
    3544:	15 e0       	ldi	r17, 0x05	; 5
    3546:	27 ef       	ldi	r18, 0xF7	; 247
    3548:	3b e1       	ldi	r19, 0x1B	; 27
    354a:	4c 2d       	mov	r20, r12
    354c:	67 e9       	ldi	r22, 0x97	; 151
    354e:	70 e0       	ldi	r23, 0x00	; 0
    3550:	c7 01       	movw	r24, r14
    3552:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3556:	90 93 40 0c 	sts	0x0C40, r25
    355a:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
    355e:	c0 91 8f 02 	lds	r28, 0x028F
    3562:	d0 91 90 02 	lds	r29, 0x0290
    3566:	04 ec       	ldi	r16, 0xC4	; 196
    3568:	15 e0       	ldi	r17, 0x05	; 5
    356a:	2a ee       	ldi	r18, 0xEA	; 234
    356c:	3b e1       	ldi	r19, 0x1B	; 27
    356e:	4b 2d       	mov	r20, r11
    3570:	67 e9       	ldi	r22, 0x97	; 151
    3572:	70 e0       	ldi	r23, 0x00	; 0
    3574:	ce 01       	movw	r24, r28
    3576:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    357a:	90 93 42 0c 	sts	0x0C42, r25
    357e:	80 93 41 0c 	sts	0x0C41, r24
  chMtxLock(&m2);
    3582:	8d e0       	ldi	r24, 0x0D	; 13
    3584:	92 e0       	ldi	r25, 0x02	; 2
    3586:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_assert(1, chThdGetPriority() == p, "wrong priority level");
    358a:	e0 91 3c 0c 	lds	r30, 0x0C3C
    358e:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3592:	61 e0       	ldi	r22, 0x01	; 1
    3594:	84 81       	ldd	r24, Z+4	; 0x04
    3596:	8d 11       	cpse	r24, r13
    3598:	60 e0       	ldi	r22, 0x00	; 0
    359a:	81 e0       	ldi	r24, 0x01	; 1
    359c:	90 e0       	ldi	r25, 0x00	; 0
    359e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    35a2:	88 23       	and	r24, r24
    35a4:	51 f0       	breq	.+20     	; 0x35ba <mtx4_execute+0xa6>
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriority() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriority() == p, "wrong priority level");
  test_wait_threads();
}
    35a6:	df 91       	pop	r29
    35a8:	cf 91       	pop	r28
    35aa:	1f 91       	pop	r17
    35ac:	0f 91       	pop	r16
    35ae:	ff 90       	pop	r15
    35b0:	ef 90       	pop	r14
    35b2:	df 90       	pop	r13
    35b4:	cf 90       	pop	r12
    35b6:	bf 90       	pop	r11
    35b8:	08 95       	ret
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
  chMtxLock(&m2);
  test_assert(1, chThdGetPriority() == p, "wrong priority level");
  chThdSleepMilliseconds(100);
    35ba:	84 e6       	ldi	r24, 0x64	; 100
    35bc:	90 e0       	ldi	r25, 0x00	; 0
    35be:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_assert(2, chThdGetPriority() == p1, "wrong priority level");
    35c2:	e0 91 3c 0c 	lds	r30, 0x0C3C
    35c6:	f0 91 3d 0c 	lds	r31, 0x0C3D
    35ca:	61 e0       	ldi	r22, 0x01	; 1
    35cc:	84 81       	ldd	r24, Z+4	; 0x04
    35ce:	8c 11       	cpse	r24, r12
    35d0:	60 e0       	ldi	r22, 0x00	; 0
    35d2:	82 e0       	ldi	r24, 0x02	; 2
    35d4:	90 e0       	ldi	r25, 0x00	; 0
    35d6:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    35da:	81 11       	cpse	r24, r1
    35dc:	e4 cf       	rjmp	.-56     	; 0x35a6 <mtx4_execute+0x92>
  chMtxLock(&m1);
    35de:	85 e0       	ldi	r24, 0x05	; 5
    35e0:	92 e0       	ldi	r25, 0x02	; 2
    35e2:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_assert(3, chThdGetPriority() == p1, "wrong priority level");
    35e6:	e0 91 3c 0c 	lds	r30, 0x0C3C
    35ea:	f0 91 3d 0c 	lds	r31, 0x0C3D
    35ee:	61 e0       	ldi	r22, 0x01	; 1
    35f0:	84 81       	ldd	r24, Z+4	; 0x04
    35f2:	8c 11       	cpse	r24, r12
    35f4:	60 e0       	ldi	r22, 0x00	; 0
    35f6:	83 e0       	ldi	r24, 0x03	; 3
    35f8:	90 e0       	ldi	r25, 0x00	; 0
    35fa:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    35fe:	81 11       	cpse	r24, r1
    3600:	d2 cf       	rjmp	.-92     	; 0x35a6 <mtx4_execute+0x92>
  chThdSleepMilliseconds(100);
    3602:	84 e6       	ldi	r24, 0x64	; 100
    3604:	90 e0       	ldi	r25, 0x00	; 0
    3606:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_assert(4, chThdGetPriority() == p2, "wrong priority level");
    360a:	e0 91 3c 0c 	lds	r30, 0x0C3C
    360e:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3612:	61 e0       	ldi	r22, 0x01	; 1
    3614:	84 81       	ldd	r24, Z+4	; 0x04
    3616:	8b 11       	cpse	r24, r11
    3618:	60 e0       	ldi	r22, 0x00	; 0
    361a:	84 e0       	ldi	r24, 0x04	; 4
    361c:	90 e0       	ldi	r25, 0x00	; 0
    361e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3622:	81 11       	cpse	r24, r1
    3624:	c0 cf       	rjmp	.-128    	; 0x35a6 <mtx4_execute+0x92>
  chMtxUnlock();
    3626:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  test_assert(5, chThdGetPriority() == p1, "wrong priority level");
    362a:	e0 91 3c 0c 	lds	r30, 0x0C3C
    362e:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3632:	61 e0       	ldi	r22, 0x01	; 1
    3634:	84 81       	ldd	r24, Z+4	; 0x04
    3636:	8c 11       	cpse	r24, r12
    3638:	60 e0       	ldi	r22, 0x00	; 0
    363a:	85 e0       	ldi	r24, 0x05	; 5
    363c:	90 e0       	ldi	r25, 0x00	; 0
    363e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3642:	81 11       	cpse	r24, r1
    3644:	b0 cf       	rjmp	.-160    	; 0x35a6 <mtx4_execute+0x92>
  chThdSleepMilliseconds(100);
    3646:	84 e6       	ldi	r24, 0x64	; 100
    3648:	90 e0       	ldi	r25, 0x00	; 0
    364a:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_assert(6, chThdGetPriority() == p1, "wrong priority level");
    364e:	e0 91 3c 0c 	lds	r30, 0x0C3C
    3652:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3656:	61 e0       	ldi	r22, 0x01	; 1
    3658:	84 81       	ldd	r24, Z+4	; 0x04
    365a:	8c 11       	cpse	r24, r12
    365c:	60 e0       	ldi	r22, 0x00	; 0
    365e:	86 e0       	ldi	r24, 0x06	; 6
    3660:	90 e0       	ldi	r25, 0x00	; 0
    3662:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3666:	81 11       	cpse	r24, r1
    3668:	9e cf       	rjmp	.-196    	; 0x35a6 <mtx4_execute+0x92>
  chMtxUnlockAll();
    366a:	0e 94 25 08 	call	0x104a	; 0x104a <chMtxUnlockAll>
  test_assert(7, chThdGetPriority() == p, "wrong priority level");
    366e:	e0 91 3c 0c 	lds	r30, 0x0C3C
    3672:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3676:	61 e0       	ldi	r22, 0x01	; 1
    3678:	84 81       	ldd	r24, Z+4	; 0x04
    367a:	8d 11       	cpse	r24, r13
    367c:	60 e0       	ldi	r22, 0x00	; 0
    367e:	87 e0       	ldi	r24, 0x07	; 7
    3680:	90 e0       	ldi	r25, 0x00	; 0
    3682:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3686:	81 11       	cpse	r24, r1
    3688:	8e cf       	rjmp	.-228    	; 0x35a6 <mtx4_execute+0x92>
  test_wait_threads();
    368a:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
    368e:	0d ef       	ldi	r16, 0xFD	; 253
    3690:	17 e0       	ldi	r17, 0x07	; 7
    3692:	27 ef       	ldi	r18, 0xF7	; 247
    3694:	3b e1       	ldi	r19, 0x1B	; 27
    3696:	4c 2d       	mov	r20, r12
    3698:	67 e9       	ldi	r22, 0x97	; 151
    369a:	70 e0       	ldi	r23, 0x00	; 0
    369c:	c7 01       	movw	r24, r14
    369e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    36a2:	90 93 40 0c 	sts	0x0C40, r25
    36a6:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
    36aa:	09 e9       	ldi	r16, 0x99	; 153
    36ac:	16 e0       	ldi	r17, 0x06	; 6
    36ae:	2a ee       	ldi	r18, 0xEA	; 234
    36b0:	3b e1       	ldi	r19, 0x1B	; 27
    36b2:	4b 2d       	mov	r20, r11
    36b4:	67 e9       	ldi	r22, 0x97	; 151
    36b6:	70 e0       	ldi	r23, 0x00	; 0
    36b8:	ce 01       	movw	r24, r28
    36ba:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    36be:	90 93 42 0c 	sts	0x0C42, r25
    36c2:	80 93 41 0c 	sts	0x0C41, r24
  chMtxLock(&m2);
    36c6:	8d e0       	ldi	r24, 0x0D	; 13
    36c8:	92 e0       	ldi	r25, 0x02	; 2
    36ca:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_assert(8, chThdGetPriority() == p, "wrong priority level");
    36ce:	e0 91 3c 0c 	lds	r30, 0x0C3C
    36d2:	f0 91 3d 0c 	lds	r31, 0x0C3D
    36d6:	61 e0       	ldi	r22, 0x01	; 1
    36d8:	84 81       	ldd	r24, Z+4	; 0x04
    36da:	8d 11       	cpse	r24, r13
    36dc:	60 e0       	ldi	r22, 0x00	; 0
    36de:	88 e0       	ldi	r24, 0x08	; 8
    36e0:	90 e0       	ldi	r25, 0x00	; 0
    36e2:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    36e6:	81 11       	cpse	r24, r1
    36e8:	5e cf       	rjmp	.-324    	; 0x35a6 <mtx4_execute+0x92>
  chThdSleepMilliseconds(100);
    36ea:	84 e6       	ldi	r24, 0x64	; 100
    36ec:	90 e0       	ldi	r25, 0x00	; 0
    36ee:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_assert(9, chThdGetPriority() == p1, "wrong priority level");
    36f2:	e0 91 3c 0c 	lds	r30, 0x0C3C
    36f6:	f0 91 3d 0c 	lds	r31, 0x0C3D
    36fa:	61 e0       	ldi	r22, 0x01	; 1
    36fc:	84 81       	ldd	r24, Z+4	; 0x04
    36fe:	8c 11       	cpse	r24, r12
    3700:	60 e0       	ldi	r22, 0x00	; 0
    3702:	89 e0       	ldi	r24, 0x09	; 9
    3704:	90 e0       	ldi	r25, 0x00	; 0
    3706:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    370a:	81 11       	cpse	r24, r1
    370c:	4c cf       	rjmp	.-360    	; 0x35a6 <mtx4_execute+0x92>
  chMtxLock(&m1);
    370e:	85 e0       	ldi	r24, 0x05	; 5
    3710:	92 e0       	ldi	r25, 0x02	; 2
    3712:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_assert(10, chThdGetPriority() == p1, "wrong priority level");
    3716:	e0 91 3c 0c 	lds	r30, 0x0C3C
    371a:	f0 91 3d 0c 	lds	r31, 0x0C3D
    371e:	61 e0       	ldi	r22, 0x01	; 1
    3720:	84 81       	ldd	r24, Z+4	; 0x04
    3722:	8c 11       	cpse	r24, r12
    3724:	60 e0       	ldi	r22, 0x00	; 0
    3726:	8a e0       	ldi	r24, 0x0A	; 10
    3728:	90 e0       	ldi	r25, 0x00	; 0
    372a:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    372e:	81 11       	cpse	r24, r1
    3730:	3a cf       	rjmp	.-396    	; 0x35a6 <mtx4_execute+0x92>
  chThdSleepMilliseconds(100);
    3732:	84 e6       	ldi	r24, 0x64	; 100
    3734:	90 e0       	ldi	r25, 0x00	; 0
    3736:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_assert(11, chThdGetPriority() == p2, "wrong priority level");
    373a:	e0 91 3c 0c 	lds	r30, 0x0C3C
    373e:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3742:	61 e0       	ldi	r22, 0x01	; 1
    3744:	84 81       	ldd	r24, Z+4	; 0x04
    3746:	8b 11       	cpse	r24, r11
    3748:	60 e0       	ldi	r22, 0x00	; 0
    374a:	8b e0       	ldi	r24, 0x0B	; 11
    374c:	90 e0       	ldi	r25, 0x00	; 0
    374e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3752:	81 11       	cpse	r24, r1
    3754:	28 cf       	rjmp	.-432    	; 0x35a6 <mtx4_execute+0x92>
  chSysLock();
    3756:	f8 94       	cli
  chMtxUnlockS();
    3758:	0e 94 db 07 	call	0xfb6	; 0xfb6 <chMtxUnlockS>
  chSysUnlock();
    375c:	78 94       	sei
  test_assert(12, chThdGetPriority() == p1, "wrong priority level");
    375e:	e0 91 3c 0c 	lds	r30, 0x0C3C
    3762:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3766:	61 e0       	ldi	r22, 0x01	; 1
    3768:	84 81       	ldd	r24, Z+4	; 0x04
    376a:	8c 11       	cpse	r24, r12
    376c:	60 e0       	ldi	r22, 0x00	; 0
    376e:	8c e0       	ldi	r24, 0x0C	; 12
    3770:	90 e0       	ldi	r25, 0x00	; 0
    3772:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3776:	81 11       	cpse	r24, r1
    3778:	16 cf       	rjmp	.-468    	; 0x35a6 <mtx4_execute+0x92>
  chThdSleepMilliseconds(100);
    377a:	84 e6       	ldi	r24, 0x64	; 100
    377c:	90 e0       	ldi	r25, 0x00	; 0
    377e:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_assert(13, chThdGetPriority() == p1, "wrong priority level");
    3782:	e0 91 3c 0c 	lds	r30, 0x0C3C
    3786:	f0 91 3d 0c 	lds	r31, 0x0C3D
    378a:	61 e0       	ldi	r22, 0x01	; 1
    378c:	84 81       	ldd	r24, Z+4	; 0x04
    378e:	8c 11       	cpse	r24, r12
    3790:	60 e0       	ldi	r22, 0x00	; 0
    3792:	8d e0       	ldi	r24, 0x0D	; 13
    3794:	90 e0       	ldi	r25, 0x00	; 0
    3796:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    379a:	81 11       	cpse	r24, r1
    379c:	04 cf       	rjmp	.-504    	; 0x35a6 <mtx4_execute+0x92>
  chMtxUnlockAll();
    379e:	0e 94 25 08 	call	0x104a	; 0x104a <chMtxUnlockAll>
  test_assert(14, chThdGetPriority() == p, "wrong priority level");
    37a2:	e0 91 3c 0c 	lds	r30, 0x0C3C
    37a6:	f0 91 3d 0c 	lds	r31, 0x0C3D
    37aa:	61 e0       	ldi	r22, 0x01	; 1
    37ac:	84 81       	ldd	r24, Z+4	; 0x04
    37ae:	8d 11       	cpse	r24, r13
    37b0:	60 e0       	ldi	r22, 0x00	; 0
    37b2:	8e e0       	ldi	r24, 0x0E	; 14
    37b4:	90 e0       	ldi	r25, 0x00	; 0
    37b6:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    37ba:	81 11       	cpse	r24, r1
    37bc:	f4 ce       	rjmp	.-536    	; 0x35a6 <mtx4_execute+0x92>
  test_wait_threads();
}
    37be:	df 91       	pop	r29
    37c0:	cf 91       	pop	r28
    37c2:	1f 91       	pop	r17
    37c4:	0f 91       	pop	r16
    37c6:	ff 90       	pop	r15
    37c8:	ef 90       	pop	r14
    37ca:	df 90       	pop	r13
    37cc:	cf 90       	pop	r12
    37ce:	bf 90       	pop	r11
  test_assert(12, chThdGetPriority() == p1, "wrong priority level");
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriority() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriority() == p, "wrong priority level");
  test_wait_threads();
    37d0:	0c 94 4a 10 	jmp	0x2094	; 0x2094 <test_wait_threads>

000037d4 <thread4b>:
}

static msg_t thread4b(void *p) {

  (void)p;
  chThdSleepMilliseconds(150);
    37d4:	86 e9       	ldi	r24, 0x96	; 150
    37d6:	90 e0       	ldi	r25, 0x00	; 0
    37d8:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  chMtxLock(&m1);
    37dc:	85 e0       	ldi	r24, 0x05	; 5
    37de:	92 e0       	ldi	r25, 0x02	; 2
    37e0:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  chMtxUnlock();
    37e4:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  return 0;
}
    37e8:	80 e0       	ldi	r24, 0x00	; 0
    37ea:	90 e0       	ldi	r25, 0x00	; 0
    37ec:	08 95       	ret

000037ee <thread4a>:
}

static msg_t thread4a(void *p) {

  (void)p;
  chThdSleepMilliseconds(50);
    37ee:	82 e3       	ldi	r24, 0x32	; 50
    37f0:	90 e0       	ldi	r25, 0x00	; 0
    37f2:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  chMtxLock(&m2);
    37f6:	8d e0       	ldi	r24, 0x0D	; 13
    37f8:	92 e0       	ldi	r25, 0x02	; 2
    37fa:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  chMtxUnlock();
    37fe:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  return 0;
}
    3802:	80 e0       	ldi	r24, 0x00	; 0
    3804:	90 e0       	ldi	r25, 0x00	; 0
    3806:	08 95       	ret

00003808 <mtx3_execute>:
  chMtxUnlock();
  test_emit_token('A');
  return 0;
}

static void mtx3_execute(void) {
    3808:	0f 93       	push	r16
    380a:	1f 93       	push	r17
    380c:	cf 93       	push	r28
    380e:	df 93       	push	r29
  systime_t time;

  test_wait_tick();
    3810:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  time = chTimeNow();
    3814:	c0 91 2f 0c 	lds	r28, 0x0C2F
    3818:	d0 91 30 0c 	lds	r29, 0x0C30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-5, thread3LL, 0);
    381c:	e0 91 3c 0c 	lds	r30, 0x0C3C
    3820:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3824:	44 81       	ldd	r20, Z+4	; 0x04
    3826:	45 50       	subi	r20, 0x05	; 5
    3828:	00 e0       	ldi	r16, 0x00	; 0
    382a:	10 e0       	ldi	r17, 0x00	; 0
    382c:	2e e4       	ldi	r18, 0x4E	; 78
    382e:	3d e1       	ldi	r19, 0x1D	; 29
    3830:	67 e9       	ldi	r22, 0x97	; 151
    3832:	70 e0       	ldi	r23, 0x00	; 0
    3834:	80 91 8d 02 	lds	r24, 0x028D
    3838:	90 91 8e 02 	lds	r25, 0x028E
    383c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3840:	90 93 40 0c 	sts	0x0C40, r25
    3844:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-4, thread3L, 0);
    3848:	e0 91 3c 0c 	lds	r30, 0x0C3C
    384c:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3850:	44 81       	ldd	r20, Z+4	; 0x04
    3852:	44 50       	subi	r20, 0x04	; 4
    3854:	2c e2       	ldi	r18, 0x2C	; 44
    3856:	3d e1       	ldi	r19, 0x1D	; 29
    3858:	67 e9       	ldi	r22, 0x97	; 151
    385a:	70 e0       	ldi	r23, 0x00	; 0
    385c:	80 91 8f 02 	lds	r24, 0x028F
    3860:	90 91 90 02 	lds	r25, 0x0290
    3864:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3868:	90 93 42 0c 	sts	0x0C42, r25
    386c:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread3M, 0);
    3870:	e0 91 3c 0c 	lds	r30, 0x0C3C
    3874:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3878:	44 81       	ldd	r20, Z+4	; 0x04
    387a:	43 50       	subi	r20, 0x03	; 3
    387c:	28 e1       	ldi	r18, 0x18	; 24
    387e:	3d e1       	ldi	r19, 0x1D	; 29
    3880:	67 e9       	ldi	r22, 0x97	; 151
    3882:	70 e0       	ldi	r23, 0x00	; 0
    3884:	80 91 91 02 	lds	r24, 0x0291
    3888:	90 91 92 02 	lds	r25, 0x0292
    388c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3890:	90 93 44 0c 	sts	0x0C44, r25
    3894:	80 93 43 0c 	sts	0x0C43, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-2, thread3H, 0);
    3898:	e0 91 3c 0c 	lds	r30, 0x0C3C
    389c:	f0 91 3d 0c 	lds	r31, 0x0C3D
    38a0:	44 81       	ldd	r20, Z+4	; 0x04
    38a2:	42 50       	subi	r20, 0x02	; 2
    38a4:	2a e0       	ldi	r18, 0x0A	; 10
    38a6:	3d e1       	ldi	r19, 0x1D	; 29
    38a8:	67 e9       	ldi	r22, 0x97	; 151
    38aa:	70 e0       	ldi	r23, 0x00	; 0
    38ac:	80 91 93 02 	lds	r24, 0x0293
    38b0:	90 91 94 02 	lds	r25, 0x0294
    38b4:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    38b8:	90 93 46 0c 	sts	0x0C46, r25
    38bc:	80 93 45 0c 	sts	0x0C45, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread3HH, 0);
    38c0:	e0 91 3c 0c 	lds	r30, 0x0C3C
    38c4:	f0 91 3d 0c 	lds	r31, 0x0C3D
    38c8:	44 81       	ldd	r20, Z+4	; 0x04
    38ca:	41 50       	subi	r20, 0x01	; 1
    38cc:	26 ef       	ldi	r18, 0xF6	; 246
    38ce:	3c e1       	ldi	r19, 0x1C	; 28
    38d0:	67 e9       	ldi	r22, 0x97	; 151
    38d2:	70 e0       	ldi	r23, 0x00	; 0
    38d4:	80 91 95 02 	lds	r24, 0x0295
    38d8:	90 91 96 02 	lds	r25, 0x0296
    38dc:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    38e0:	90 93 48 0c 	sts	0x0C48, r25
    38e4:	80 93 47 0c 	sts	0x0C47, r24
  test_wait_threads();
    38e8:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    38ec:	68 ec       	ldi	r22, 0xC8	; 200
    38ee:	75 e0       	ldi	r23, 0x05	; 5
    38f0:	81 e0       	ldi	r24, 0x01	; 1
    38f2:	90 e0       	ldi	r25, 0x00	; 0
    38f4:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <_test_assert_sequence>
    38f8:	88 23       	and	r24, r24
    38fa:	29 f0       	breq	.+10     	; 0x3906 <mtx3_execute+0xfe>
  test_assert_time_window(2, time + MS2ST(110), time + MS2ST(110) + ALLOWED_DELAY);
}
    38fc:	df 91       	pop	r29
    38fe:	cf 91       	pop	r28
    3900:	1f 91       	pop	r17
    3902:	0f 91       	pop	r16
    3904:	08 95       	ret
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread3M, 0);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-2, thread3H, 0);
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread3HH, 0);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
  test_assert_time_window(2, time + MS2ST(110), time + MS2ST(110) + ALLOWED_DELAY);
    3906:	ae 01       	movw	r20, r28
    3908:	4d 58       	subi	r20, 0x8D	; 141
    390a:	5f 4f       	sbci	r21, 0xFF	; 255
    390c:	be 01       	movw	r22, r28
    390e:	62 59       	subi	r22, 0x92	; 146
    3910:	7f 4f       	sbci	r23, 0xFF	; 255
    3912:	82 e0       	ldi	r24, 0x02	; 2
    3914:	90 e0       	ldi	r25, 0x00	; 0
}
    3916:	df 91       	pop	r29
    3918:	cf 91       	pop	r28
    391a:	1f 91       	pop	r17
    391c:	0f 91       	pop	r16
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread3M, 0);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-2, thread3H, 0);
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread3HH, 0);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
  test_assert_time_window(2, time + MS2ST(110), time + MS2ST(110) + ALLOWED_DELAY);
    391e:	0c 94 20 10 	jmp	0x2040	; 0x2040 <_test_assert_time_window>

00003922 <mtx2_execute>:
  chMtxUnlock();
  test_emit_token('A');
  return 0;
}

static void mtx2_execute(void) {
    3922:	0f 93       	push	r16
    3924:	1f 93       	push	r17
    3926:	cf 93       	push	r28
    3928:	df 93       	push	r29
  systime_t time;

  test_wait_tick();
    392a:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  time = chTimeNow();
    392e:	c0 91 2f 0c 	lds	r28, 0x0C2F
    3932:	d0 91 30 0c 	lds	r29, 0x0C30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-1, thread2H, 0);
    3936:	e0 91 3c 0c 	lds	r30, 0x0C3C
    393a:	f0 91 3d 0c 	lds	r31, 0x0C3D
    393e:	44 81       	ldd	r20, Z+4	; 0x04
    3940:	41 50       	subi	r20, 0x01	; 1
    3942:	00 e0       	ldi	r16, 0x00	; 0
    3944:	10 e0       	ldi	r17, 0x00	; 0
    3946:	20 e8       	ldi	r18, 0x80	; 128
    3948:	3d e1       	ldi	r19, 0x1D	; 29
    394a:	67 e9       	ldi	r22, 0x97	; 151
    394c:	70 e0       	ldi	r23, 0x00	; 0
    394e:	80 91 8d 02 	lds	r24, 0x028D
    3952:	90 91 8e 02 	lds	r25, 0x028E
    3956:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    395a:	90 93 40 0c 	sts	0x0C40, r25
    395e:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-2, thread2M, 0);
    3962:	e0 91 3c 0c 	lds	r30, 0x0C3C
    3966:	f0 91 3d 0c 	lds	r31, 0x0C3D
    396a:	44 81       	ldd	r20, Z+4	; 0x04
    396c:	42 50       	subi	r20, 0x02	; 2
    396e:	22 e7       	ldi	r18, 0x72	; 114
    3970:	3d e1       	ldi	r19, 0x1D	; 29
    3972:	67 e9       	ldi	r22, 0x97	; 151
    3974:	70 e0       	ldi	r23, 0x00	; 0
    3976:	80 91 8f 02 	lds	r24, 0x028F
    397a:	90 91 90 02 	lds	r25, 0x0290
    397e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3982:	90 93 42 0c 	sts	0x0C42, r25
    3986:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread2L, 0);
    398a:	e0 91 3c 0c 	lds	r30, 0x0C3C
    398e:	f0 91 3d 0c 	lds	r31, 0x0C3D
    3992:	44 81       	ldd	r20, Z+4	; 0x04
    3994:	43 50       	subi	r20, 0x03	; 3
    3996:	2e e5       	ldi	r18, 0x5E	; 94
    3998:	3d e1       	ldi	r19, 0x1D	; 29
    399a:	67 e9       	ldi	r22, 0x97	; 151
    399c:	70 e0       	ldi	r23, 0x00	; 0
    399e:	80 91 91 02 	lds	r24, 0x0291
    39a2:	90 91 92 02 	lds	r25, 0x0292
    39a6:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    39aa:	90 93 44 0c 	sts	0x0C44, r25
    39ae:	80 93 43 0c 	sts	0x0C43, r24
  test_wait_threads();
    39b2:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_assert_sequence(1, "ABC");
    39b6:	67 e9       	ldi	r22, 0x97	; 151
    39b8:	76 e0       	ldi	r23, 0x06	; 6
    39ba:	81 e0       	ldi	r24, 0x01	; 1
    39bc:	90 e0       	ldi	r25, 0x00	; 0
    39be:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <_test_assert_sequence>
    39c2:	88 23       	and	r24, r24
    39c4:	29 f0       	breq	.+10     	; 0x39d0 <mtx2_execute+0xae>
  test_assert_time_window(2, time + MS2ST(100), time + MS2ST(100) + ALLOWED_DELAY);
}
    39c6:	df 91       	pop	r29
    39c8:	cf 91       	pop	r28
    39ca:	1f 91       	pop	r17
    39cc:	0f 91       	pop	r16
    39ce:	08 95       	ret
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-1, thread2H, 0);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-2, thread2M, 0);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread2L, 0);
  test_wait_threads();
  test_assert_sequence(1, "ABC");
  test_assert_time_window(2, time + MS2ST(100), time + MS2ST(100) + ALLOWED_DELAY);
    39d0:	ae 01       	movw	r20, r28
    39d2:	47 59       	subi	r20, 0x97	; 151
    39d4:	5f 4f       	sbci	r21, 0xFF	; 255
    39d6:	be 01       	movw	r22, r28
    39d8:	6c 59       	subi	r22, 0x9C	; 156
    39da:	7f 4f       	sbci	r23, 0xFF	; 255
    39dc:	82 e0       	ldi	r24, 0x02	; 2
    39de:	90 e0       	ldi	r25, 0x00	; 0
}
    39e0:	df 91       	pop	r29
    39e2:	cf 91       	pop	r28
    39e4:	1f 91       	pop	r17
    39e6:	0f 91       	pop	r16
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-1, thread2H, 0);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-2, thread2M, 0);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread2L, 0);
  test_wait_threads();
  test_assert_sequence(1, "ABC");
  test_assert_time_window(2, time + MS2ST(100), time + MS2ST(100) + ALLOWED_DELAY);
    39e8:	0c 94 20 10 	jmp	0x2040	; 0x2040 <_test_assert_time_window>

000039ec <thread3HH>:

/* Highest priority thread */
static msg_t thread3HH(void *p) {

  (void)p;
  chThdSleepMilliseconds(50);
    39ec:	82 e3       	ldi	r24, 0x32	; 50
    39ee:	90 e0       	ldi	r25, 0x00	; 0
    39f0:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  chMtxLock(&m2);
    39f4:	8d e0       	ldi	r24, 0x0D	; 13
    39f6:	92 e0       	ldi	r25, 0x02	; 2
    39f8:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_cpu_pulse(10);
    39fc:	8a e0       	ldi	r24, 0x0A	; 10
    39fe:	90 e0       	ldi	r25, 0x00	; 0
    3a00:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  chMtxUnlock();
    3a04:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  test_emit_token('A');
    3a08:	81 e4       	ldi	r24, 0x41	; 65
    3a0a:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  return 0;
}
    3a0e:	80 e0       	ldi	r24, 0x00	; 0
    3a10:	90 e0       	ldi	r25, 0x00	; 0
    3a12:	08 95       	ret

00003a14 <thread3H>:

/* High priority thread */
static msg_t thread3H(void *p) {

  (void)p;
  chThdSleepMilliseconds(40);
    3a14:	88 e2       	ldi	r24, 0x28	; 40
    3a16:	90 e0       	ldi	r25, 0x00	; 0
    3a18:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_cpu_pulse(20);
    3a1c:	84 e1       	ldi	r24, 0x14	; 20
    3a1e:	90 e0       	ldi	r25, 0x00	; 0
    3a20:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  test_emit_token('B');
    3a24:	82 e4       	ldi	r24, 0x42	; 66
    3a26:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  return 0;
}
    3a2a:	80 e0       	ldi	r24, 0x00	; 0
    3a2c:	90 e0       	ldi	r25, 0x00	; 0
    3a2e:	08 95       	ret

00003a30 <thread3M>:

/* Medium priority thread */
static msg_t thread3M(void *p) {

  (void)p;
  chThdSleepMilliseconds(20);
    3a30:	84 e1       	ldi	r24, 0x14	; 20
    3a32:	90 e0       	ldi	r25, 0x00	; 0
    3a34:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  chMtxLock(&m2);
    3a38:	8d e0       	ldi	r24, 0x0D	; 13
    3a3a:	92 e0       	ldi	r25, 0x02	; 2
    3a3c:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_cpu_pulse(10);
    3a40:	8a e0       	ldi	r24, 0x0A	; 10
    3a42:	90 e0       	ldi	r25, 0x00	; 0
    3a44:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  chMtxUnlock();
    3a48:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  test_emit_token('C');
    3a4c:	83 e4       	ldi	r24, 0x43	; 67
    3a4e:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  return 0;
}
    3a52:	80 e0       	ldi	r24, 0x00	; 0
    3a54:	90 e0       	ldi	r25, 0x00	; 0
    3a56:	08 95       	ret

00003a58 <thread3L>:

/* Low priority thread */
static msg_t thread3L(void *p) {

  (void)p;
  chThdSleepMilliseconds(10);
    3a58:	8a e0       	ldi	r24, 0x0A	; 10
    3a5a:	90 e0       	ldi	r25, 0x00	; 0
    3a5c:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  chMtxLock(&m2);
    3a60:	8d e0       	ldi	r24, 0x0D	; 13
    3a62:	92 e0       	ldi	r25, 0x02	; 2
    3a64:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_cpu_pulse(20);
    3a68:	84 e1       	ldi	r24, 0x14	; 20
    3a6a:	90 e0       	ldi	r25, 0x00	; 0
    3a6c:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  chMtxLock(&m1);
    3a70:	85 e0       	ldi	r24, 0x05	; 5
    3a72:	92 e0       	ldi	r25, 0x02	; 2
    3a74:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_cpu_pulse(10);
    3a78:	8a e0       	ldi	r24, 0x0A	; 10
    3a7a:	90 e0       	ldi	r25, 0x00	; 0
    3a7c:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  chMtxUnlock();
    3a80:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  test_cpu_pulse(10);
    3a84:	8a e0       	ldi	r24, 0x0A	; 10
    3a86:	90 e0       	ldi	r25, 0x00	; 0
    3a88:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  chMtxUnlock();
    3a8c:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  test_emit_token('D');
    3a90:	84 e4       	ldi	r24, 0x44	; 68
    3a92:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  return 0;
}
    3a96:	80 e0       	ldi	r24, 0x00	; 0
    3a98:	90 e0       	ldi	r25, 0x00	; 0
    3a9a:	08 95       	ret

00003a9c <thread3LL>:

/* Lowest priority thread */
static msg_t thread3LL(void *p) {

  (void)p;
  chMtxLock(&m1);
    3a9c:	85 e0       	ldi	r24, 0x05	; 5
    3a9e:	92 e0       	ldi	r25, 0x02	; 2
    3aa0:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_cpu_pulse(30);
    3aa4:	8e e1       	ldi	r24, 0x1E	; 30
    3aa6:	90 e0       	ldi	r25, 0x00	; 0
    3aa8:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  chMtxUnlock();
    3aac:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  test_emit_token('E');
    3ab0:	85 e4       	ldi	r24, 0x45	; 69
    3ab2:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  return 0;
}
    3ab6:	80 e0       	ldi	r24, 0x00	; 0
    3ab8:	90 e0       	ldi	r25, 0x00	; 0
    3aba:	08 95       	ret

00003abc <thread2L>:

/* Low priority thread */
static msg_t thread2L(void *p) {

  (void)p;
  chMtxLock(&m1);
    3abc:	85 e0       	ldi	r24, 0x05	; 5
    3abe:	92 e0       	ldi	r25, 0x02	; 2
    3ac0:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_cpu_pulse(40);
    3ac4:	88 e2       	ldi	r24, 0x28	; 40
    3ac6:	90 e0       	ldi	r25, 0x00	; 0
    3ac8:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  chMtxUnlock();
    3acc:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  test_cpu_pulse(10);
    3ad0:	8a e0       	ldi	r24, 0x0A	; 10
    3ad2:	90 e0       	ldi	r25, 0x00	; 0
    3ad4:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  test_emit_token('C');
    3ad8:	83 e4       	ldi	r24, 0x43	; 67
    3ada:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  return 0;
}
    3ade:	80 e0       	ldi	r24, 0x00	; 0
    3ae0:	90 e0       	ldi	r25, 0x00	; 0
    3ae2:	08 95       	ret

00003ae4 <thread2M>:

/* Medium priority thread */
static msg_t thread2M(void *p) {

  (void)p;
  chThdSleepMilliseconds(20);
    3ae4:	84 e1       	ldi	r24, 0x14	; 20
    3ae6:	90 e0       	ldi	r25, 0x00	; 0
    3ae8:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_cpu_pulse(40);
    3aec:	88 e2       	ldi	r24, 0x28	; 40
    3aee:	90 e0       	ldi	r25, 0x00	; 0
    3af0:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  test_emit_token('B');
    3af4:	82 e4       	ldi	r24, 0x42	; 66
    3af6:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  return 0;
}
    3afa:	80 e0       	ldi	r24, 0x00	; 0
    3afc:	90 e0       	ldi	r25, 0x00	; 0
    3afe:	08 95       	ret

00003b00 <thread2H>:

/* High priority thread */
static msg_t thread2H(void *p) {

  (void)p;
  chThdSleepMilliseconds(40);
    3b00:	88 e2       	ldi	r24, 0x28	; 40
    3b02:	90 e0       	ldi	r25, 0x00	; 0
    3b04:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  chMtxLock(&m1);
    3b08:	85 e0       	ldi	r24, 0x05	; 5
    3b0a:	92 e0       	ldi	r25, 0x02	; 2
    3b0c:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
  test_cpu_pulse(10);
    3b10:	8a e0       	ldi	r24, 0x0A	; 10
    3b12:	90 e0       	ldi	r25, 0x00	; 0
    3b14:	0e 94 5e 10 	call	0x20bc	; 0x20bc <test_cpu_pulse>
  chMtxUnlock();
    3b18:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
  test_emit_token('A');
    3b1c:	81 e4       	ldi	r24, 0x41	; 65
    3b1e:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  return 0;
}
    3b22:	80 e0       	ldi	r24, 0x00	; 0
    3b24:	90 e0       	ldi	r25, 0x00	; 0
    3b26:	08 95       	ret

00003b28 <msg1_execute>:
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
  return 0;
}

static void msg1_execute(void) {
    3b28:	0f 93       	push	r16
    3b2a:	1f 93       	push	r17
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() + 1,
    3b2c:	00 91 3c 0c 	lds	r16, 0x0C3C
    3b30:	10 91 3d 0c 	lds	r17, 0x0C3D
    3b34:	f8 01       	movw	r30, r16
    3b36:	44 81       	ldd	r20, Z+4	; 0x04
    3b38:	4f 5f       	subi	r20, 0xFF	; 255
    3b3a:	24 ed       	ldi	r18, 0xD4	; 212
    3b3c:	3d e1       	ldi	r19, 0x1D	; 29
    3b3e:	67 e9       	ldi	r22, 0x97	; 151
    3b40:	70 e0       	ldi	r23, 0x00	; 0
    3b42:	80 91 8d 02 	lds	r24, 0x028D
    3b46:	90 91 8e 02 	lds	r25, 0x028E
    3b4a:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    3b4e:	90 93 40 0c 	sts	0x0C40, r25
    3b52:	80 93 3f 0c 	sts	0x0C3F, r24
                                 thread, chThdSelf());
  tp = chMsgWait();
    3b56:	0e 94 2f 0b 	call	0x165e	; 0x165e <chMsgWait>
  msg = chMsgGet(tp);
    3b5a:	fc 01       	movw	r30, r24
    3b5c:	12 8d       	ldd	r17, Z+26	; 0x1a
    3b5e:	73 8d       	ldd	r23, Z+27	; 0x1b
  chMsgRelease(tp, msg);
    3b60:	61 2f       	mov	r22, r17
    3b62:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <chMsgRelease>
  test_emit_token(msg);
    3b66:	81 2f       	mov	r24, r17
    3b68:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  tp = chMsgWait();
    3b6c:	0e 94 2f 0b 	call	0x165e	; 0x165e <chMsgWait>
  msg = chMsgGet(tp);
    3b70:	fc 01       	movw	r30, r24
    3b72:	12 8d       	ldd	r17, Z+26	; 0x1a
    3b74:	73 8d       	ldd	r23, Z+27	; 0x1b
  chMsgRelease(tp, msg);
    3b76:	61 2f       	mov	r22, r17
    3b78:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <chMsgRelease>
  test_emit_token(msg);
    3b7c:	81 2f       	mov	r24, r17
    3b7e:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  tp = chMsgWait();
    3b82:	0e 94 2f 0b 	call	0x165e	; 0x165e <chMsgWait>
  msg = chMsgGet(tp);
    3b86:	fc 01       	movw	r30, r24
    3b88:	12 8d       	ldd	r17, Z+26	; 0x1a
    3b8a:	73 8d       	ldd	r23, Z+27	; 0x1b
  chMsgRelease(tp, msg);
    3b8c:	61 2f       	mov	r22, r17
    3b8e:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <chMsgRelease>
  test_emit_token(msg);
    3b92:	81 2f       	mov	r24, r17
    3b94:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
  test_assert_sequence(1, "ABC");
    3b98:	67 e9       	ldi	r22, 0x97	; 151
    3b9a:	76 e0       	ldi	r23, 0x06	; 6
    3b9c:	81 e0       	ldi	r24, 0x01	; 1
    3b9e:	90 e0       	ldi	r25, 0x00	; 0
}
    3ba0:	1f 91       	pop	r17
    3ba2:	0f 91       	pop	r16
  test_emit_token(msg);
  tp = chMsgWait();
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
  test_assert_sequence(1, "ABC");
    3ba4:	0c 94 f8 0f 	jmp	0x1ff0	; 0x1ff0 <_test_assert_sequence>

00003ba8 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static msg_t thread(void *p) {
    3ba8:	cf 93       	push	r28
    3baa:	df 93       	push	r29
    3bac:	ec 01       	movw	r28, r24

  chMsgSend(p, 'A');
    3bae:	61 e4       	ldi	r22, 0x41	; 65
    3bb0:	70 e0       	ldi	r23, 0x00	; 0
    3bb2:	0e 94 08 0b 	call	0x1610	; 0x1610 <chMsgSend>
  chMsgSend(p, 'B');
    3bb6:	62 e4       	ldi	r22, 0x42	; 66
    3bb8:	70 e0       	ldi	r23, 0x00	; 0
    3bba:	ce 01       	movw	r24, r28
    3bbc:	0e 94 08 0b 	call	0x1610	; 0x1610 <chMsgSend>
  chMsgSend(p, 'C');
    3bc0:	63 e4       	ldi	r22, 0x43	; 67
    3bc2:	70 e0       	ldi	r23, 0x00	; 0
    3bc4:	ce 01       	movw	r24, r28
    3bc6:	0e 94 08 0b 	call	0x1610	; 0x1610 <chMsgSend>
  return 0;
}
    3bca:	80 e0       	ldi	r24, 0x00	; 0
    3bcc:	90 e0       	ldi	r25, 0x00	; 0
    3bce:	df 91       	pop	r29
    3bd0:	cf 91       	pop	r28
    3bd2:	08 95       	ret

00003bd4 <mbox1_execute>:
static void mbox1_setup(void) {

  chMBInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}

static void mbox1_execute(void) {
    3bd4:	0f 93       	push	r16
    3bd6:	1f 93       	push	r17
    3bd8:	cf 93       	push	r28
    3bda:	df 93       	push	r29
    3bdc:	00 d0       	rcall	.+0      	; 0x3bde <mbox1_execute+0xa>
    3bde:	cd b7       	in	r28, 0x3d	; 61
    3be0:	de b7       	in	r29, 0x3e	; 62
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
    3be2:	61 e0       	ldi	r22, 0x01	; 1
    3be4:	80 91 2a 02 	lds	r24, 0x022A
    3be8:	85 30       	cpi	r24, 0x05	; 5
    3bea:	09 f0       	breq	.+2      	; 0x3bee <mbox1_execute+0x1a>
    3bec:	60 e0       	ldi	r22, 0x00	; 0
    3bee:	81 e0       	ldi	r24, 0x01	; 1
    3bf0:	90 e0       	ldi	r25, 0x00	; 0
    3bf2:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3bf6:	81 11       	cpse	r24, r1
    3bf8:	2a c0       	rjmp	.+84     	; 0x3c4e <mbox1_execute+0x7a>
    3bfa:	02 e4       	ldi	r16, 0x42	; 66
    3bfc:	10 e0       	ldi	r17, 0x00	; 0

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    3bfe:	4f ef       	ldi	r20, 0xFF	; 255
    3c00:	5f ef       	ldi	r21, 0xFF	; 255
    3c02:	b8 01       	movw	r22, r16
    3c04:	89 e1       	ldi	r24, 0x19	; 25
    3c06:	92 e0       	ldi	r25, 0x02	; 2
    3c08:	0e 94 c8 0b 	call	0x1790	; 0x1790 <chMBPost>
    test_assert(2, msg1 == RDY_OK, "wrong wake-up message");
    3c0c:	61 e0       	ldi	r22, 0x01	; 1
    3c0e:	89 2b       	or	r24, r25
    3c10:	09 f0       	breq	.+2      	; 0x3c14 <mbox1_execute+0x40>
    3c12:	60 e0       	ldi	r22, 0x00	; 0
    3c14:	82 e0       	ldi	r24, 0x02	; 2
    3c16:	90 e0       	ldi	r25, 0x00	; 0
    3c18:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3c1c:	81 11       	cpse	r24, r1
    3c1e:	17 c0       	rjmp	.+46     	; 0x3c4e <mbox1_execute+0x7a>
    3c20:	0f 5f       	subi	r16, 0xFF	; 255
    3c22:	1f 4f       	sbci	r17, 0xFF	; 255
  test_assert(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    3c24:	06 34       	cpi	r16, 0x46	; 70
    3c26:	11 05       	cpc	r17, r1
    3c28:	51 f7       	brne	.-44     	; 0x3bfe <mbox1_execute+0x2a>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == RDY_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
    3c2a:	4f ef       	ldi	r20, 0xFF	; 255
    3c2c:	5f ef       	ldi	r21, 0xFF	; 255
    3c2e:	61 e4       	ldi	r22, 0x41	; 65
    3c30:	70 e0       	ldi	r23, 0x00	; 0
    3c32:	89 e1       	ldi	r24, 0x19	; 25
    3c34:	92 e0       	ldi	r25, 0x02	; 2
    3c36:	0e 94 1d 0c 	call	0x183a	; 0x183a <chMBPostAhead>
  test_assert(3, msg1 == RDY_OK, "wrong wake-up message");
    3c3a:	61 e0       	ldi	r22, 0x01	; 1
    3c3c:	89 2b       	or	r24, r25
    3c3e:	09 f0       	breq	.+2      	; 0x3c42 <mbox1_execute+0x6e>
    3c40:	60 e0       	ldi	r22, 0x00	; 0
    3c42:	83 e0       	ldi	r24, 0x03	; 3
    3c44:	90 e0       	ldi	r25, 0x00	; 0
    3c46:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3c4a:	88 23       	and	r24, r24
    3c4c:	39 f0       	breq	.+14     	; 0x3c5c <mbox1_execute+0x88>
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
}
    3c4e:	0f 90       	pop	r0
    3c50:	0f 90       	pop	r0
    3c52:	df 91       	pop	r29
    3c54:	cf 91       	pop	r28
    3c56:	1f 91       	pop	r17
    3c58:	0f 91       	pop	r16
    3c5a:	08 95       	ret
  test_assert(3, msg1 == RDY_OK, "wrong wake-up message");

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
    3c5c:	41 e0       	ldi	r20, 0x01	; 1
    3c5e:	50 e0       	ldi	r21, 0x00	; 0
    3c60:	68 e5       	ldi	r22, 0x58	; 88
    3c62:	70 e0       	ldi	r23, 0x00	; 0
    3c64:	89 e1       	ldi	r24, 0x19	; 25
    3c66:	92 e0       	ldi	r25, 0x02	; 2
    3c68:	0e 94 c8 0b 	call	0x1790	; 0x1790 <chMBPost>
  test_assert(4, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3c6c:	61 e0       	ldi	r22, 0x01	; 1
    3c6e:	01 96       	adiw	r24, 0x01	; 1
    3c70:	09 f0       	breq	.+2      	; 0x3c74 <mbox1_execute+0xa0>
    3c72:	60 e0       	ldi	r22, 0x00	; 0
    3c74:	84 e0       	ldi	r24, 0x04	; 4
    3c76:	90 e0       	ldi	r25, 0x00	; 0
    3c78:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3c7c:	81 11       	cpse	r24, r1
    3c7e:	e7 cf       	rjmp	.-50     	; 0x3c4e <mbox1_execute+0x7a>
  chSysLock();
    3c80:	f8 94       	cli
  msg1 = chMBPostI(&mb1, 'X');
    3c82:	68 e5       	ldi	r22, 0x58	; 88
    3c84:	70 e0       	ldi	r23, 0x00	; 0
    3c86:	89 e1       	ldi	r24, 0x19	; 25
    3c88:	92 e0       	ldi	r25, 0x02	; 2
    3c8a:	0e 94 cd 0b 	call	0x179a	; 0x179a <chMBPostI>
  chSysUnlock();
    3c8e:	78 94       	sei
  test_assert(5, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3c90:	61 e0       	ldi	r22, 0x01	; 1
    3c92:	01 96       	adiw	r24, 0x01	; 1
    3c94:	09 f0       	breq	.+2      	; 0x3c98 <mbox1_execute+0xc4>
    3c96:	60 e0       	ldi	r22, 0x00	; 0
    3c98:	85 e0       	ldi	r24, 0x05	; 5
    3c9a:	90 e0       	ldi	r25, 0x00	; 0
    3c9c:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3ca0:	81 11       	cpse	r24, r1
    3ca2:	d5 cf       	rjmp	.-86     	; 0x3c4e <mbox1_execute+0x7a>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
    3ca4:	41 e0       	ldi	r20, 0x01	; 1
    3ca6:	50 e0       	ldi	r21, 0x00	; 0
    3ca8:	68 e5       	ldi	r22, 0x58	; 88
    3caa:	70 e0       	ldi	r23, 0x00	; 0
    3cac:	89 e1       	ldi	r24, 0x19	; 25
    3cae:	92 e0       	ldi	r25, 0x02	; 2
    3cb0:	0e 94 1d 0c 	call	0x183a	; 0x183a <chMBPostAhead>
  test_assert(6, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3cb4:	61 e0       	ldi	r22, 0x01	; 1
    3cb6:	01 96       	adiw	r24, 0x01	; 1
    3cb8:	09 f0       	breq	.+2      	; 0x3cbc <mbox1_execute+0xe8>
    3cba:	60 e0       	ldi	r22, 0x00	; 0
    3cbc:	86 e0       	ldi	r24, 0x06	; 6
    3cbe:	90 e0       	ldi	r25, 0x00	; 0
    3cc0:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3cc4:	81 11       	cpse	r24, r1
    3cc6:	c3 cf       	rjmp	.-122    	; 0x3c4e <mbox1_execute+0x7a>
  chSysLock();
    3cc8:	f8 94       	cli
  msg1 = chMBPostAheadI(&mb1, 'X');
    3cca:	68 e5       	ldi	r22, 0x58	; 88
    3ccc:	70 e0       	ldi	r23, 0x00	; 0
    3cce:	89 e1       	ldi	r24, 0x19	; 25
    3cd0:	92 e0       	ldi	r25, 0x02	; 2
    3cd2:	0e 94 22 0c 	call	0x1844	; 0x1844 <chMBPostAheadI>
  chSysUnlock();
    3cd6:	78 94       	sei
  test_assert(7, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3cd8:	61 e0       	ldi	r22, 0x01	; 1
    3cda:	01 96       	adiw	r24, 0x01	; 1
    3cdc:	09 f0       	breq	.+2      	; 0x3ce0 <mbox1_execute+0x10c>
    3cde:	60 e0       	ldi	r22, 0x00	; 0
    3ce0:	87 e0       	ldi	r24, 0x07	; 7
    3ce2:	90 e0       	ldi	r25, 0x00	; 0
    3ce4:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3ce8:	81 11       	cpse	r24, r1
    3cea:	b1 cf       	rjmp	.-158    	; 0x3c4e <mbox1_execute+0x7a>

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
    3cec:	f8 94       	cli
    3cee:	61 e0       	ldi	r22, 0x01	; 1
    3cf0:	80 91 2a 02 	lds	r24, 0x022A
    3cf4:	81 11       	cpse	r24, r1
    3cf6:	60 e0       	ldi	r22, 0x00	; 0
    3cf8:	88 e0       	ldi	r24, 0x08	; 8
    3cfa:	90 e0       	ldi	r25, 0x00	; 0
    3cfc:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3d00:	78 94       	sei
    3d02:	81 11       	cpse	r24, r1
    3d04:	a4 cf       	rjmp	.-184    	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
    3d06:	f8 94       	cli
    3d08:	61 e0       	ldi	r22, 0x01	; 1
    3d0a:	80 91 25 02 	lds	r24, 0x0225
    3d0e:	85 30       	cpi	r24, 0x05	; 5
    3d10:	09 f0       	breq	.+2      	; 0x3d14 <mbox1_execute+0x140>
    3d12:	60 e0       	ldi	r22, 0x00	; 0
    3d14:	89 e0       	ldi	r24, 0x09	; 9
    3d16:	90 e0       	ldi	r25, 0x00	; 0
    3d18:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3d1c:	78 94       	sei
    3d1e:	81 11       	cpse	r24, r1
    3d20:	96 cf       	rjmp	.-212    	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    3d22:	f8 94       	cli
    3d24:	61 e0       	ldi	r22, 0x01	; 1
    3d26:	20 91 1f 02 	lds	r18, 0x021F
    3d2a:	30 91 20 02 	lds	r19, 0x0220
    3d2e:	80 91 1d 02 	lds	r24, 0x021D
    3d32:	90 91 1e 02 	lds	r25, 0x021E
    3d36:	28 17       	cp	r18, r24
    3d38:	39 07       	cpc	r19, r25
    3d3a:	09 f0       	breq	.+2      	; 0x3d3e <mbox1_execute+0x16a>
    3d3c:	60 e0       	ldi	r22, 0x00	; 0
    3d3e:	8a e0       	ldi	r24, 0x0A	; 10
    3d40:	90 e0       	ldi	r25, 0x00	; 0
    3d42:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3d46:	78 94       	sei
    3d48:	81 11       	cpse	r24, r1
    3d4a:	81 cf       	rjmp	.-254    	; 0x3c4e <mbox1_execute+0x7a>
    3d4c:	05 e0       	ldi	r16, 0x05	; 5
    3d4e:	10 e0       	ldi	r17, 0x00	; 0
    3d50:	06 c0       	rjmp	.+12     	; 0x3d5e <mbox1_execute+0x18a>
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == RDY_OK, "wrong wake-up message");
    test_emit_token(msg2);
    3d52:	89 81       	ldd	r24, Y+1	; 0x01
    3d54:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
    3d58:	01 50       	subi	r16, 0x01	; 1
    3d5a:	11 09       	sbc	r17, r1
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    3d5c:	a1 f0       	breq	.+40     	; 0x3d86 <mbox1_execute+0x1b2>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    3d5e:	4f ef       	ldi	r20, 0xFF	; 255
    3d60:	5f ef       	ldi	r21, 0xFF	; 255
    3d62:	be 01       	movw	r22, r28
    3d64:	6f 5f       	subi	r22, 0xFF	; 255
    3d66:	7f 4f       	sbci	r23, 0xFF	; 255
    3d68:	89 e1       	ldi	r24, 0x19	; 25
    3d6a:	92 e0       	ldi	r25, 0x02	; 2
    3d6c:	0e 94 75 0c 	call	0x18ea	; 0x18ea <chMBFetch>
    test_assert(11, msg1 == RDY_OK, "wrong wake-up message");
    3d70:	61 e0       	ldi	r22, 0x01	; 1
    3d72:	89 2b       	or	r24, r25
    3d74:	09 f0       	breq	.+2      	; 0x3d78 <mbox1_execute+0x1a4>
    3d76:	60 e0       	ldi	r22, 0x00	; 0
    3d78:	8b e0       	ldi	r24, 0x0B	; 11
    3d7a:	90 e0       	ldi	r25, 0x00	; 0
    3d7c:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3d80:	88 23       	and	r24, r24
    3d82:	39 f3       	breq	.-50     	; 0x3d52 <mbox1_execute+0x17e>
    3d84:	64 cf       	rjmp	.-312    	; 0x3c4e <mbox1_execute+0x7a>
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
    3d86:	68 ec       	ldi	r22, 0xC8	; 200
    3d88:	75 e0       	ldi	r23, 0x05	; 5
    3d8a:	8c e0       	ldi	r24, 0x0C	; 12
    3d8c:	90 e0       	ldi	r25, 0x00	; 0
    3d8e:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <_test_assert_sequence>
    3d92:	81 11       	cpse	r24, r1
    3d94:	5c cf       	rjmp	.-328    	; 0x3c4e <mbox1_execute+0x7a>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    3d96:	4f ef       	ldi	r20, 0xFF	; 255
    3d98:	5f ef       	ldi	r21, 0xFF	; 255
    3d9a:	67 e4       	ldi	r22, 0x47	; 71
    3d9c:	70 e0       	ldi	r23, 0x00	; 0
    3d9e:	89 e1       	ldi	r24, 0x19	; 25
    3da0:	92 e0       	ldi	r25, 0x02	; 2
    3da2:	0e 94 c8 0b 	call	0x1790	; 0x1790 <chMBPost>
  test_assert(13, msg1 == RDY_OK, "wrong wake-up message");
    3da6:	61 e0       	ldi	r22, 0x01	; 1
    3da8:	89 2b       	or	r24, r25
    3daa:	09 f0       	breq	.+2      	; 0x3dae <mbox1_execute+0x1da>
    3dac:	60 e0       	ldi	r22, 0x00	; 0
    3dae:	8d e0       	ldi	r24, 0x0D	; 13
    3db0:	90 e0       	ldi	r25, 0x00	; 0
    3db2:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3db6:	81 11       	cpse	r24, r1
    3db8:	4a cf       	rjmp	.-364    	; 0x3c4e <mbox1_execute+0x7a>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    3dba:	4f ef       	ldi	r20, 0xFF	; 255
    3dbc:	5f ef       	ldi	r21, 0xFF	; 255
    3dbe:	be 01       	movw	r22, r28
    3dc0:	6f 5f       	subi	r22, 0xFF	; 255
    3dc2:	7f 4f       	sbci	r23, 0xFF	; 255
    3dc4:	89 e1       	ldi	r24, 0x19	; 25
    3dc6:	92 e0       	ldi	r25, 0x02	; 2
    3dc8:	0e 94 75 0c 	call	0x18ea	; 0x18ea <chMBFetch>
  test_assert(14, msg1 == RDY_OK, "wrong wake-up message");
    3dcc:	61 e0       	ldi	r22, 0x01	; 1
    3dce:	89 2b       	or	r24, r25
    3dd0:	09 f0       	breq	.+2      	; 0x3dd4 <mbox1_execute+0x200>
    3dd2:	60 e0       	ldi	r22, 0x00	; 0
    3dd4:	8e e0       	ldi	r24, 0x0E	; 14
    3dd6:	90 e0       	ldi	r25, 0x00	; 0
    3dd8:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3ddc:	81 11       	cpse	r24, r1
    3dde:	37 cf       	rjmp	.-402    	; 0x3c4e <mbox1_execute+0x7a>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
    3de0:	61 e0       	ldi	r22, 0x01	; 1
    3de2:	20 91 19 02 	lds	r18, 0x0219
    3de6:	30 91 1a 02 	lds	r19, 0x021A
    3dea:	80 91 1d 02 	lds	r24, 0x021D
    3dee:	90 91 1e 02 	lds	r25, 0x021E
    3df2:	28 17       	cp	r18, r24
    3df4:	39 07       	cpc	r19, r25
    3df6:	09 f0       	breq	.+2      	; 0x3dfa <mbox1_execute+0x226>
    3df8:	60 e0       	ldi	r22, 0x00	; 0
    3dfa:	8f e0       	ldi	r24, 0x0F	; 15
    3dfc:	90 e0       	ldi	r25, 0x00	; 0
    3dfe:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3e02:	81 11       	cpse	r24, r1
    3e04:	24 cf       	rjmp	.-440    	; 0x3c4e <mbox1_execute+0x7a>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
    3e06:	61 e0       	ldi	r22, 0x01	; 1
    3e08:	20 91 19 02 	lds	r18, 0x0219
    3e0c:	30 91 1a 02 	lds	r19, 0x021A
    3e10:	80 91 1f 02 	lds	r24, 0x021F
    3e14:	90 91 20 02 	lds	r25, 0x0220
    3e18:	28 17       	cp	r18, r24
    3e1a:	39 07       	cpc	r19, r25
    3e1c:	09 f0       	breq	.+2      	; 0x3e20 <mbox1_execute+0x24c>
    3e1e:	60 e0       	ldi	r22, 0x00	; 0
    3e20:	80 e1       	ldi	r24, 0x10	; 16
    3e22:	90 e0       	ldi	r25, 0x00	; 0
    3e24:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3e28:	81 11       	cpse	r24, r1
    3e2a:	11 cf       	rjmp	.-478    	; 0x3c4e <mbox1_execute+0x7a>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
    3e2c:	41 e0       	ldi	r20, 0x01	; 1
    3e2e:	50 e0       	ldi	r21, 0x00	; 0
    3e30:	be 01       	movw	r22, r28
    3e32:	6f 5f       	subi	r22, 0xFF	; 255
    3e34:	7f 4f       	sbci	r23, 0xFF	; 255
    3e36:	89 e1       	ldi	r24, 0x19	; 25
    3e38:	92 e0       	ldi	r25, 0x02	; 2
    3e3a:	0e 94 75 0c 	call	0x18ea	; 0x18ea <chMBFetch>
  test_assert(17, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3e3e:	61 e0       	ldi	r22, 0x01	; 1
    3e40:	01 96       	adiw	r24, 0x01	; 1
    3e42:	09 f0       	breq	.+2      	; 0x3e46 <mbox1_execute+0x272>
    3e44:	60 e0       	ldi	r22, 0x00	; 0
    3e46:	81 e1       	ldi	r24, 0x11	; 17
    3e48:	90 e0       	ldi	r25, 0x00	; 0
    3e4a:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3e4e:	81 11       	cpse	r24, r1
    3e50:	fe ce       	rjmp	.-516    	; 0x3c4e <mbox1_execute+0x7a>
  chSysLock();
    3e52:	f8 94       	cli
  msg1 = chMBFetchI(&mb1, &msg2);
    3e54:	be 01       	movw	r22, r28
    3e56:	6f 5f       	subi	r22, 0xFF	; 255
    3e58:	7f 4f       	sbci	r23, 0xFF	; 255
    3e5a:	89 e1       	ldi	r24, 0x19	; 25
    3e5c:	92 e0       	ldi	r25, 0x02	; 2
    3e5e:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <chMBFetchI>
  chSysUnlock();
    3e62:	78 94       	sei
  test_assert(18, msg1 == RDY_TIMEOUT, "wrong wake-up message");
    3e64:	61 e0       	ldi	r22, 0x01	; 1
    3e66:	01 96       	adiw	r24, 0x01	; 1
    3e68:	09 f0       	breq	.+2      	; 0x3e6c <mbox1_execute+0x298>
    3e6a:	60 e0       	ldi	r22, 0x00	; 0
    3e6c:	82 e1       	ldi	r24, 0x12	; 18
    3e6e:	90 e0       	ldi	r25, 0x00	; 0
    3e70:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3e74:	81 11       	cpse	r24, r1
    3e76:	eb ce       	rjmp	.-554    	; 0x3c4e <mbox1_execute+0x7a>

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    3e78:	f8 94       	cli
    3e7a:	61 e0       	ldi	r22, 0x01	; 1
    3e7c:	80 91 2a 02 	lds	r24, 0x022A
    3e80:	85 30       	cpi	r24, 0x05	; 5
    3e82:	09 f0       	breq	.+2      	; 0x3e86 <mbox1_execute+0x2b2>
    3e84:	60 e0       	ldi	r22, 0x00	; 0
    3e86:	83 e1       	ldi	r24, 0x13	; 19
    3e88:	90 e0       	ldi	r25, 0x00	; 0
    3e8a:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3e8e:	78 94       	sei
    3e90:	81 11       	cpse	r24, r1
    3e92:	dd ce       	rjmp	.-582    	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
    3e94:	f8 94       	cli
    3e96:	61 e0       	ldi	r22, 0x01	; 1
    3e98:	80 91 25 02 	lds	r24, 0x0225
    3e9c:	81 11       	cpse	r24, r1
    3e9e:	60 e0       	ldi	r22, 0x00	; 0
    3ea0:	84 e1       	ldi	r24, 0x14	; 20
    3ea2:	90 e0       	ldi	r25, 0x00	; 0
    3ea4:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3ea8:	78 94       	sei
    3eaa:	81 11       	cpse	r24, r1
    3eac:	d0 ce       	rjmp	.-608    	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    3eae:	f8 94       	cli
    3eb0:	61 e0       	ldi	r22, 0x01	; 1
    3eb2:	20 91 1f 02 	lds	r18, 0x021F
    3eb6:	30 91 20 02 	lds	r19, 0x0220
    3eba:	80 91 1d 02 	lds	r24, 0x021D
    3ebe:	90 91 1e 02 	lds	r25, 0x021E
    3ec2:	28 17       	cp	r18, r24
    3ec4:	39 07       	cpc	r19, r25
    3ec6:	09 f0       	breq	.+2      	; 0x3eca <mbox1_execute+0x2f6>
    3ec8:	60 e0       	ldi	r22, 0x00	; 0
    3eca:	85 e1       	ldi	r24, 0x15	; 21
    3ecc:	90 e0       	ldi	r25, 0x00	; 0
    3ece:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3ed2:	78 94       	sei
    3ed4:	81 11       	cpse	r24, r1
    3ed6:	bb ce       	rjmp	.-650    	; 0x3c4e <mbox1_execute+0x7a>

  /*
   * Testing I-Class.
   */
  chSysLock()
    3ed8:	f8 94       	cli
  msg1 = chMBPostI(&mb1, 'A');
    3eda:	61 e4       	ldi	r22, 0x41	; 65
    3edc:	70 e0       	ldi	r23, 0x00	; 0
    3ede:	89 e1       	ldi	r24, 0x19	; 25
    3ee0:	92 e0       	ldi	r25, 0x02	; 2
    3ee2:	0e 94 cd 0b 	call	0x179a	; 0x179a <chMBPostI>
  test_assert(22, msg1 == RDY_OK, "wrong wake-up message");
    3ee6:	61 e0       	ldi	r22, 0x01	; 1
    3ee8:	89 2b       	or	r24, r25
    3eea:	09 f0       	breq	.+2      	; 0x3eee <mbox1_execute+0x31a>
    3eec:	60 e0       	ldi	r22, 0x00	; 0
    3eee:	86 e1       	ldi	r24, 0x16	; 22
    3ef0:	90 e0       	ldi	r25, 0x00	; 0
    3ef2:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3ef6:	81 11       	cpse	r24, r1
    3ef8:	aa ce       	rjmp	.-684    	; 0x3c4e <mbox1_execute+0x7a>
  msg1 = chMBPostI(&mb1, 'B');
    3efa:	62 e4       	ldi	r22, 0x42	; 66
    3efc:	70 e0       	ldi	r23, 0x00	; 0
    3efe:	89 e1       	ldi	r24, 0x19	; 25
    3f00:	92 e0       	ldi	r25, 0x02	; 2
    3f02:	0e 94 cd 0b 	call	0x179a	; 0x179a <chMBPostI>
  test_assert(23, msg1 == RDY_OK, "wrong wake-up message");
    3f06:	61 e0       	ldi	r22, 0x01	; 1
    3f08:	89 2b       	or	r24, r25
    3f0a:	09 f0       	breq	.+2      	; 0x3f0e <mbox1_execute+0x33a>
    3f0c:	60 e0       	ldi	r22, 0x00	; 0
    3f0e:	87 e1       	ldi	r24, 0x17	; 23
    3f10:	90 e0       	ldi	r25, 0x00	; 0
    3f12:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3f16:	81 11       	cpse	r24, r1
    3f18:	9a ce       	rjmp	.-716    	; 0x3c4e <mbox1_execute+0x7a>
  msg1 = chMBPostI(&mb1, 'C');
    3f1a:	63 e4       	ldi	r22, 0x43	; 67
    3f1c:	70 e0       	ldi	r23, 0x00	; 0
    3f1e:	89 e1       	ldi	r24, 0x19	; 25
    3f20:	92 e0       	ldi	r25, 0x02	; 2
    3f22:	0e 94 cd 0b 	call	0x179a	; 0x179a <chMBPostI>
  test_assert(24, msg1 == RDY_OK, "wrong wake-up message");
    3f26:	61 e0       	ldi	r22, 0x01	; 1
    3f28:	89 2b       	or	r24, r25
    3f2a:	09 f0       	breq	.+2      	; 0x3f2e <mbox1_execute+0x35a>
    3f2c:	60 e0       	ldi	r22, 0x00	; 0
    3f2e:	88 e1       	ldi	r24, 0x18	; 24
    3f30:	90 e0       	ldi	r25, 0x00	; 0
    3f32:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3f36:	81 11       	cpse	r24, r1
    3f38:	8a ce       	rjmp	.-748    	; 0x3c4e <mbox1_execute+0x7a>
  msg1 = chMBPostI(&mb1, 'D');
    3f3a:	64 e4       	ldi	r22, 0x44	; 68
    3f3c:	70 e0       	ldi	r23, 0x00	; 0
    3f3e:	89 e1       	ldi	r24, 0x19	; 25
    3f40:	92 e0       	ldi	r25, 0x02	; 2
    3f42:	0e 94 cd 0b 	call	0x179a	; 0x179a <chMBPostI>
  test_assert(25, msg1 == RDY_OK, "wrong wake-up message");
    3f46:	61 e0       	ldi	r22, 0x01	; 1
    3f48:	89 2b       	or	r24, r25
    3f4a:	09 f0       	breq	.+2      	; 0x3f4e <mbox1_execute+0x37a>
    3f4c:	60 e0       	ldi	r22, 0x00	; 0
    3f4e:	89 e1       	ldi	r24, 0x19	; 25
    3f50:	90 e0       	ldi	r25, 0x00	; 0
    3f52:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3f56:	81 11       	cpse	r24, r1
    3f58:	7a ce       	rjmp	.-780    	; 0x3c4e <mbox1_execute+0x7a>
  msg1 = chMBPostI(&mb1, 'E');
    3f5a:	65 e4       	ldi	r22, 0x45	; 69
    3f5c:	70 e0       	ldi	r23, 0x00	; 0
    3f5e:	89 e1       	ldi	r24, 0x19	; 25
    3f60:	92 e0       	ldi	r25, 0x02	; 2
    3f62:	0e 94 cd 0b 	call	0x179a	; 0x179a <chMBPostI>
  chSysUnlock();
    3f66:	78 94       	sei
  test_assert(26, msg1 == RDY_OK, "wrong wake-up message");
    3f68:	61 e0       	ldi	r22, 0x01	; 1
    3f6a:	89 2b       	or	r24, r25
    3f6c:	09 f0       	breq	.+2      	; 0x3f70 <mbox1_execute+0x39c>
    3f6e:	60 e0       	ldi	r22, 0x00	; 0
    3f70:	8a e1       	ldi	r24, 0x1A	; 26
    3f72:	90 e0       	ldi	r25, 0x00	; 0
    3f74:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3f78:	81 11       	cpse	r24, r1
    3f7a:	69 ce       	rjmp	.-814    	; 0x3c4e <mbox1_execute+0x7a>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    3f7c:	61 e0       	ldi	r22, 0x01	; 1
    3f7e:	20 91 1f 02 	lds	r18, 0x021F
    3f82:	30 91 20 02 	lds	r19, 0x0220
    3f86:	80 91 1d 02 	lds	r24, 0x021D
    3f8a:	90 91 1e 02 	lds	r25, 0x021E
    3f8e:	28 17       	cp	r18, r24
    3f90:	39 07       	cpc	r19, r25
    3f92:	09 f0       	breq	.+2      	; 0x3f96 <mbox1_execute+0x3c2>
    3f94:	60 e0       	ldi	r22, 0x00	; 0
    3f96:	8b e1       	ldi	r24, 0x1B	; 27
    3f98:	90 e0       	ldi	r25, 0x00	; 0
    3f9a:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3f9e:	81 11       	cpse	r24, r1
    3fa0:	56 ce       	rjmp	.-852    	; 0x3c4e <mbox1_execute+0x7a>
    3fa2:	05 e0       	ldi	r16, 0x05	; 5
    3fa4:	10 e0       	ldi	r17, 0x00	; 0
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    3fa6:	f8 94       	cli
    msg1 = chMBFetchI(&mb1, &msg2);
    3fa8:	be 01       	movw	r22, r28
    3faa:	6f 5f       	subi	r22, 0xFF	; 255
    3fac:	7f 4f       	sbci	r23, 0xFF	; 255
    3fae:	89 e1       	ldi	r24, 0x19	; 25
    3fb0:	92 e0       	ldi	r25, 0x02	; 2
    3fb2:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <chMBFetchI>
    chSysUnlock();
    3fb6:	78 94       	sei
    test_assert(28, msg1 == RDY_OK, "wrong wake-up message");
    3fb8:	61 e0       	ldi	r22, 0x01	; 1
    3fba:	89 2b       	or	r24, r25
    3fbc:	09 f0       	breq	.+2      	; 0x3fc0 <mbox1_execute+0x3ec>
    3fbe:	60 e0       	ldi	r22, 0x00	; 0
    3fc0:	8c e1       	ldi	r24, 0x1C	; 28
    3fc2:	90 e0       	ldi	r25, 0x00	; 0
    3fc4:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3fc8:	81 11       	cpse	r24, r1
    3fca:	41 ce       	rjmp	.-894    	; 0x3c4e <mbox1_execute+0x7a>
    test_emit_token(msg2);
    3fcc:	89 81       	ldd	r24, Y+1	; 0x01
    3fce:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
    3fd2:	01 50       	subi	r16, 0x01	; 1
    3fd4:	11 09       	sbc	r17, r1
  test_assert(25, msg1 == RDY_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == RDY_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    3fd6:	39 f7       	brne	.-50     	; 0x3fa6 <mbox1_execute+0x3d2>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == RDY_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
    3fd8:	68 ec       	ldi	r22, 0xC8	; 200
    3fda:	75 e0       	ldi	r23, 0x05	; 5
    3fdc:	8d e1       	ldi	r24, 0x1D	; 29
    3fde:	90 e0       	ldi	r25, 0x00	; 0
    3fe0:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <_test_assert_sequence>
    3fe4:	81 11       	cpse	r24, r1
    3fe6:	33 ce       	rjmp	.-922    	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    3fe8:	f8 94       	cli
    3fea:	61 e0       	ldi	r22, 0x01	; 1
    3fec:	80 91 2a 02 	lds	r24, 0x022A
    3ff0:	85 30       	cpi	r24, 0x05	; 5
    3ff2:	09 f0       	breq	.+2      	; 0x3ff6 <mbox1_execute+0x422>
    3ff4:	60 e0       	ldi	r22, 0x00	; 0
    3ff6:	8e e1       	ldi	r24, 0x1E	; 30
    3ff8:	90 e0       	ldi	r25, 0x00	; 0
    3ffa:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    3ffe:	78 94       	sei
    4000:	81 11       	cpse	r24, r1
    4002:	25 ce       	rjmp	.-950    	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
    4004:	f8 94       	cli
    4006:	61 e0       	ldi	r22, 0x01	; 1
    4008:	80 91 25 02 	lds	r24, 0x0225
    400c:	81 11       	cpse	r24, r1
    400e:	60 e0       	ldi	r22, 0x00	; 0
    4010:	8f e1       	ldi	r24, 0x1F	; 31
    4012:	90 e0       	ldi	r25, 0x00	; 0
    4014:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4018:	78 94       	sei
    401a:	81 11       	cpse	r24, r1
    401c:	18 ce       	rjmp	.-976    	; 0x3c4e <mbox1_execute+0x7a>
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    401e:	61 e0       	ldi	r22, 0x01	; 1
    4020:	20 91 1f 02 	lds	r18, 0x021F
    4024:	30 91 20 02 	lds	r19, 0x0220
    4028:	80 91 1d 02 	lds	r24, 0x021D
    402c:	90 91 1e 02 	lds	r25, 0x021E
    4030:	28 17       	cp	r18, r24
    4032:	39 07       	cpc	r19, r25
    4034:	09 f0       	breq	.+2      	; 0x4038 <mbox1_execute+0x464>
    4036:	60 e0       	ldi	r22, 0x00	; 0
    4038:	80 e2       	ldi	r24, 0x20	; 32
    403a:	90 e0       	ldi	r25, 0x00	; 0
    403c:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4040:	81 11       	cpse	r24, r1
    4042:	05 ce       	rjmp	.-1014   	; 0x3c4e <mbox1_execute+0x7a>

  chSysLock();
    4044:	f8 94       	cli
  msg1 = chMBPostAheadI(&mb1, 'E');
    4046:	65 e4       	ldi	r22, 0x45	; 69
    4048:	70 e0       	ldi	r23, 0x00	; 0
    404a:	89 e1       	ldi	r24, 0x19	; 25
    404c:	92 e0       	ldi	r25, 0x02	; 2
    404e:	0e 94 22 0c 	call	0x1844	; 0x1844 <chMBPostAheadI>
  test_assert(33, msg1 == RDY_OK, "wrong wake-up message");
    4052:	61 e0       	ldi	r22, 0x01	; 1
    4054:	89 2b       	or	r24, r25
    4056:	09 f0       	breq	.+2      	; 0x405a <mbox1_execute+0x486>
    4058:	60 e0       	ldi	r22, 0x00	; 0
    405a:	81 e2       	ldi	r24, 0x21	; 33
    405c:	90 e0       	ldi	r25, 0x00	; 0
    405e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4062:	81 11       	cpse	r24, r1
    4064:	f4 cd       	rjmp	.-1048   	; 0x3c4e <mbox1_execute+0x7a>
  msg1 = chMBPostAheadI(&mb1, 'D');
    4066:	64 e4       	ldi	r22, 0x44	; 68
    4068:	70 e0       	ldi	r23, 0x00	; 0
    406a:	89 e1       	ldi	r24, 0x19	; 25
    406c:	92 e0       	ldi	r25, 0x02	; 2
    406e:	0e 94 22 0c 	call	0x1844	; 0x1844 <chMBPostAheadI>
  test_assert(34, msg1 == RDY_OK, "wrong wake-up message");
    4072:	61 e0       	ldi	r22, 0x01	; 1
    4074:	89 2b       	or	r24, r25
    4076:	09 f0       	breq	.+2      	; 0x407a <mbox1_execute+0x4a6>
    4078:	60 e0       	ldi	r22, 0x00	; 0
    407a:	82 e2       	ldi	r24, 0x22	; 34
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4082:	81 11       	cpse	r24, r1
    4084:	e4 cd       	rjmp	.-1080   	; 0x3c4e <mbox1_execute+0x7a>
  msg1 = chMBPostAheadI(&mb1, 'C');
    4086:	63 e4       	ldi	r22, 0x43	; 67
    4088:	70 e0       	ldi	r23, 0x00	; 0
    408a:	89 e1       	ldi	r24, 0x19	; 25
    408c:	92 e0       	ldi	r25, 0x02	; 2
    408e:	0e 94 22 0c 	call	0x1844	; 0x1844 <chMBPostAheadI>
  test_assert(35, msg1 == RDY_OK, "wrong wake-up message");
    4092:	61 e0       	ldi	r22, 0x01	; 1
    4094:	89 2b       	or	r24, r25
    4096:	09 f0       	breq	.+2      	; 0x409a <mbox1_execute+0x4c6>
    4098:	60 e0       	ldi	r22, 0x00	; 0
    409a:	83 e2       	ldi	r24, 0x23	; 35
    409c:	90 e0       	ldi	r25, 0x00	; 0
    409e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    40a2:	81 11       	cpse	r24, r1
    40a4:	d4 cd       	rjmp	.-1112   	; 0x3c4e <mbox1_execute+0x7a>
  msg1 = chMBPostAheadI(&mb1, 'B');
    40a6:	62 e4       	ldi	r22, 0x42	; 66
    40a8:	70 e0       	ldi	r23, 0x00	; 0
    40aa:	89 e1       	ldi	r24, 0x19	; 25
    40ac:	92 e0       	ldi	r25, 0x02	; 2
    40ae:	0e 94 22 0c 	call	0x1844	; 0x1844 <chMBPostAheadI>
  test_assert(36, msg1 == RDY_OK, "wrong wake-up message");
    40b2:	61 e0       	ldi	r22, 0x01	; 1
    40b4:	89 2b       	or	r24, r25
    40b6:	09 f0       	breq	.+2      	; 0x40ba <mbox1_execute+0x4e6>
    40b8:	60 e0       	ldi	r22, 0x00	; 0
    40ba:	84 e2       	ldi	r24, 0x24	; 36
    40bc:	90 e0       	ldi	r25, 0x00	; 0
    40be:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    40c2:	81 11       	cpse	r24, r1
    40c4:	c4 cd       	rjmp	.-1144   	; 0x3c4e <mbox1_execute+0x7a>
  msg1 = chMBPostAheadI(&mb1, 'A');
    40c6:	61 e4       	ldi	r22, 0x41	; 65
    40c8:	70 e0       	ldi	r23, 0x00	; 0
    40ca:	89 e1       	ldi	r24, 0x19	; 25
    40cc:	92 e0       	ldi	r25, 0x02	; 2
    40ce:	0e 94 22 0c 	call	0x1844	; 0x1844 <chMBPostAheadI>
  chSysUnlock();
    40d2:	78 94       	sei
  test_assert(37, msg1 == RDY_OK, "wrong wake-up message");
    40d4:	61 e0       	ldi	r22, 0x01	; 1
    40d6:	89 2b       	or	r24, r25
    40d8:	09 f0       	breq	.+2      	; 0x40dc <mbox1_execute+0x508>
    40da:	60 e0       	ldi	r22, 0x00	; 0
    40dc:	85 e2       	ldi	r24, 0x25	; 37
    40de:	90 e0       	ldi	r25, 0x00	; 0
    40e0:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    40e4:	81 11       	cpse	r24, r1
    40e6:	b3 cd       	rjmp	.-1178   	; 0x3c4e <mbox1_execute+0x7a>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    40e8:	61 e0       	ldi	r22, 0x01	; 1
    40ea:	20 91 1f 02 	lds	r18, 0x021F
    40ee:	30 91 20 02 	lds	r19, 0x0220
    40f2:	80 91 1d 02 	lds	r24, 0x021D
    40f6:	90 91 1e 02 	lds	r25, 0x021E
    40fa:	28 17       	cp	r18, r24
    40fc:	39 07       	cpc	r19, r25
    40fe:	09 f0       	breq	.+2      	; 0x4102 <mbox1_execute+0x52e>
    4100:	60 e0       	ldi	r22, 0x00	; 0
    4102:	86 e2       	ldi	r24, 0x26	; 38
    4104:	90 e0       	ldi	r25, 0x00	; 0
    4106:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    410a:	81 11       	cpse	r24, r1
    410c:	a0 cd       	rjmp	.-1216   	; 0x3c4e <mbox1_execute+0x7a>
    410e:	05 e0       	ldi	r16, 0x05	; 5
    4110:	10 e0       	ldi	r17, 0x00	; 0
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    4112:	f8 94       	cli
    msg1 = chMBFetchI(&mb1, &msg2);
    4114:	be 01       	movw	r22, r28
    4116:	6f 5f       	subi	r22, 0xFF	; 255
    4118:	7f 4f       	sbci	r23, 0xFF	; 255
    411a:	89 e1       	ldi	r24, 0x19	; 25
    411c:	92 e0       	ldi	r25, 0x02	; 2
    411e:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <chMBFetchI>
    chSysUnlock();
    4122:	78 94       	sei
    test_assert(39, msg1 == RDY_OK, "wrong wake-up message");
    4124:	61 e0       	ldi	r22, 0x01	; 1
    4126:	89 2b       	or	r24, r25
    4128:	09 f0       	breq	.+2      	; 0x412c <mbox1_execute+0x558>
    412a:	60 e0       	ldi	r22, 0x00	; 0
    412c:	87 e2       	ldi	r24, 0x27	; 39
    412e:	90 e0       	ldi	r25, 0x00	; 0
    4130:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4134:	81 11       	cpse	r24, r1
    4136:	8b cd       	rjmp	.-1258   	; 0x3c4e <mbox1_execute+0x7a>
    test_emit_token(msg2);
    4138:	89 81       	ldd	r24, Y+1	; 0x01
    413a:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
    413e:	01 50       	subi	r16, 0x01	; 1
    4140:	11 09       	sbc	r17, r1
  test_assert(36, msg1 == RDY_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == RDY_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    4142:	39 f7       	brne	.-50     	; 0x4112 <mbox1_execute+0x53e>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == RDY_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
    4144:	68 ec       	ldi	r22, 0xC8	; 200
    4146:	75 e0       	ldi	r23, 0x05	; 5
    4148:	88 e2       	ldi	r24, 0x28	; 40
    414a:	90 e0       	ldi	r25, 0x00	; 0
    414c:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <_test_assert_sequence>
    4150:	81 11       	cpse	r24, r1
    4152:	7d cd       	rjmp	.-1286   	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    4154:	f8 94       	cli
    4156:	61 e0       	ldi	r22, 0x01	; 1
    4158:	80 91 2a 02 	lds	r24, 0x022A
    415c:	85 30       	cpi	r24, 0x05	; 5
    415e:	09 f0       	breq	.+2      	; 0x4162 <mbox1_execute+0x58e>
    4160:	60 e0       	ldi	r22, 0x00	; 0
    4162:	89 e2       	ldi	r24, 0x29	; 41
    4164:	90 e0       	ldi	r25, 0x00	; 0
    4166:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    416a:	78 94       	sei
    416c:	81 11       	cpse	r24, r1
    416e:	6f cd       	rjmp	.-1314   	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
    4170:	f8 94       	cli
    4172:	61 e0       	ldi	r22, 0x01	; 1
    4174:	80 91 25 02 	lds	r24, 0x0225
    4178:	81 11       	cpse	r24, r1
    417a:	60 e0       	ldi	r22, 0x00	; 0
    417c:	8a e2       	ldi	r24, 0x2A	; 42
    417e:	90 e0       	ldi	r25, 0x00	; 0
    4180:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4184:	78 94       	sei
    4186:	81 11       	cpse	r24, r1
    4188:	62 cd       	rjmp	.-1340   	; 0x3c4e <mbox1_execute+0x7a>
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    418a:	61 e0       	ldi	r22, 0x01	; 1
    418c:	20 91 1f 02 	lds	r18, 0x021F
    4190:	30 91 20 02 	lds	r19, 0x0220
    4194:	80 91 1d 02 	lds	r24, 0x021D
    4198:	90 91 1e 02 	lds	r25, 0x021E
    419c:	28 17       	cp	r18, r24
    419e:	39 07       	cpc	r19, r25
    41a0:	09 f0       	breq	.+2      	; 0x41a4 <mbox1_execute+0x5d0>
    41a2:	60 e0       	ldi	r22, 0x00	; 0
    41a4:	8b e2       	ldi	r24, 0x2B	; 43
    41a6:	90 e0       	ldi	r25, 0x00	; 0
    41a8:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    41ac:	81 11       	cpse	r24, r1
    41ae:	4f cd       	rjmp	.-1378   	; 0x3c4e <mbox1_execute+0x7a>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
    41b0:	89 e1       	ldi	r24, 0x19	; 25
    41b2:	92 e0       	ldi	r25, 0x02	; 2
    41b4:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <chMBReset>

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    41b8:	f8 94       	cli
    41ba:	61 e0       	ldi	r22, 0x01	; 1
    41bc:	80 91 2a 02 	lds	r24, 0x022A
    41c0:	85 30       	cpi	r24, 0x05	; 5
    41c2:	09 f0       	breq	.+2      	; 0x41c6 <mbox1_execute+0x5f2>
    41c4:	60 e0       	ldi	r22, 0x00	; 0
    41c6:	8c e2       	ldi	r24, 0x2C	; 44
    41c8:	90 e0       	ldi	r25, 0x00	; 0
    41ca:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    41ce:	78 94       	sei
    41d0:	81 11       	cpse	r24, r1
    41d2:	3d cd       	rjmp	.-1414   	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
    41d4:	f8 94       	cli
    41d6:	61 e0       	ldi	r22, 0x01	; 1
    41d8:	80 91 25 02 	lds	r24, 0x0225
    41dc:	81 11       	cpse	r24, r1
    41de:	60 e0       	ldi	r22, 0x00	; 0
    41e0:	8d e2       	ldi	r24, 0x2D	; 45
    41e2:	90 e0       	ldi	r25, 0x00	; 0
    41e4:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    41e8:	78 94       	sei
    41ea:	81 11       	cpse	r24, r1
    41ec:	30 cd       	rjmp	.-1440   	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
    41ee:	f8 94       	cli
    41f0:	61 e0       	ldi	r22, 0x01	; 1
    41f2:	20 91 19 02 	lds	r18, 0x0219
    41f6:	30 91 1a 02 	lds	r19, 0x021A
    41fa:	80 91 1d 02 	lds	r24, 0x021D
    41fe:	90 91 1e 02 	lds	r25, 0x021E
    4202:	28 17       	cp	r18, r24
    4204:	39 07       	cpc	r19, r25
    4206:	09 f0       	breq	.+2      	; 0x420a <mbox1_execute+0x636>
    4208:	60 e0       	ldi	r22, 0x00	; 0
    420a:	8e e2       	ldi	r24, 0x2E	; 46
    420c:	90 e0       	ldi	r25, 0x00	; 0
    420e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4212:	78 94       	sei
    4214:	81 11       	cpse	r24, r1
    4216:	1b cd       	rjmp	.-1482   	; 0x3c4e <mbox1_execute+0x7a>
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
    4218:	f8 94       	cli
    421a:	61 e0       	ldi	r22, 0x01	; 1
    421c:	20 91 19 02 	lds	r18, 0x0219
    4220:	30 91 1a 02 	lds	r19, 0x021A
    4224:	80 91 1f 02 	lds	r24, 0x021F
    4228:	90 91 20 02 	lds	r25, 0x0220
    422c:	28 17       	cp	r18, r24
    422e:	39 07       	cpc	r19, r25
    4230:	09 f0       	breq	.+2      	; 0x4234 <mbox1_execute+0x660>
    4232:	60 e0       	ldi	r22, 0x00	; 0
    4234:	8f e2       	ldi	r24, 0x2F	; 47
    4236:	90 e0       	ldi	r25, 0x00	; 0
    4238:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    423c:	78 94       	sei
    423e:	07 cd       	rjmp	.-1522   	; 0x3c4e <mbox1_execute+0x7a>

00004240 <mbox1_setup>:
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {

  chMBInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
    4240:	45 e0       	ldi	r20, 0x05	; 5
    4242:	69 e4       	ldi	r22, 0x49	; 73
    4244:	7c e0       	ldi	r23, 0x0C	; 12
    4246:	89 e1       	ldi	r24, 0x19	; 25
    4248:	92 e0       	ldi	r25, 0x02	; 2
    424a:	0c 94 61 0b 	jmp	0x16c2	; 0x16c2 <chMBInit>

0000424e <evt3_setup>:
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
    424e:	8f ef       	ldi	r24, 0xFF	; 255
    4250:	0c 94 92 09 	jmp	0x1324	; 0x1324 <chEvtGetAndClearEvents>

00004254 <evt2_setup>:
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
    4254:	8f ef       	ldi	r24, 0xFF	; 255
    4256:	0c 94 92 09 	jmp	0x1324	; 0x1324 <chEvtGetAndClearEvents>

0000425a <evt1_setup>:
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
    425a:	8f ef       	ldi	r24, 0xFF	; 255
    425c:	0c 94 92 09 	jmp	0x1324	; 0x1324 <chEvtGetAndClearEvents>

00004260 <evt2_execute>:
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
  return 0;
}

static void evt2_execute(void) {
    4260:	cf 92       	push	r12
    4262:	df 92       	push	r13
    4264:	ef 92       	push	r14
    4266:	ff 92       	push	r15
    4268:	0f 93       	push	r16
    426a:	1f 93       	push	r17
    426c:	cf 93       	push	r28
    426e:	df 93       	push	r29
    4270:	cd b7       	in	r28, 0x3d	; 61
    4272:	de b7       	in	r29, 0x3e	; 62
    4274:	2c 97       	sbiw	r28, 0x0c	; 12
    4276:	0f b6       	in	r0, 0x3f	; 63
    4278:	f8 94       	cli
    427a:	de bf       	out	0x3e, r29	; 62
    427c:	0f be       	out	0x3f, r0	; 63
    427e:	cd bf       	out	0x3d, r28	; 61
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(5);
    4280:	85 e0       	ldi	r24, 0x05	; 5
    4282:	0e 94 9f 09 	call	0x133e	; 0x133e <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
    4286:	8f ef       	ldi	r24, 0xFF	; 255
    4288:	0e 94 2c 0a 	call	0x1458	; 0x1458 <chEvtWaitOne>
  test_assert(1, m == 1, "single event error");
    428c:	61 e0       	ldi	r22, 0x01	; 1
    428e:	81 30       	cpi	r24, 0x01	; 1
    4290:	09 f0       	breq	.+2      	; 0x4294 <evt2_execute+0x34>
    4292:	60 e0       	ldi	r22, 0x00	; 0
    4294:	81 e0       	ldi	r24, 0x01	; 1
    4296:	90 e0       	ldi	r25, 0x00	; 0
    4298:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    429c:	88 23       	and	r24, r24
    429e:	79 f0       	breq	.+30     	; 0x42be <evt2_execute+0x5e>
  test_wait_threads();
  chEvtUnregister(&es1, &el1);
  chEvtUnregister(&es2, &el2);
  test_assert(14, !chEvtIsListeningI(&es1), "stuck listener");
  test_assert(15, !chEvtIsListeningI(&es2), "stuck listener");
}
    42a0:	2c 96       	adiw	r28, 0x0c	; 12
    42a2:	0f b6       	in	r0, 0x3f	; 63
    42a4:	f8 94       	cli
    42a6:	de bf       	out	0x3e, r29	; 62
    42a8:	0f be       	out	0x3f, r0	; 63
    42aa:	cd bf       	out	0x3d, r28	; 61
    42ac:	df 91       	pop	r29
    42ae:	cf 91       	pop	r28
    42b0:	1f 91       	pop	r17
    42b2:	0f 91       	pop	r16
    42b4:	ff 90       	pop	r15
    42b6:	ef 90       	pop	r14
    42b8:	df 90       	pop	r13
    42ba:	cf 90       	pop	r12
    42bc:	08 95       	ret
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(5);
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
  m = chEvtWaitOne(ALL_EVENTS);
    42be:	8f ef       	ldi	r24, 0xFF	; 255
    42c0:	0e 94 2c 0a 	call	0x1458	; 0x1458 <chEvtWaitOne>
  test_assert(2, m == 4, "single event error");
    42c4:	61 e0       	ldi	r22, 0x01	; 1
    42c6:	84 30       	cpi	r24, 0x04	; 4
    42c8:	09 f0       	breq	.+2      	; 0x42cc <evt2_execute+0x6c>
    42ca:	60 e0       	ldi	r22, 0x00	; 0
    42cc:	82 e0       	ldi	r24, 0x02	; 2
    42ce:	90 e0       	ldi	r25, 0x00	; 0
    42d0:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    42d4:	81 11       	cpse	r24, r1
    42d6:	e4 cf       	rjmp	.-56     	; 0x42a0 <evt2_execute+0x40>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    42d8:	8f ef       	ldi	r24, 0xFF	; 255
    42da:	0e 94 92 09 	call	0x1324	; 0x1324 <chEvtGetAndClearEvents>
  test_assert(3, m == 0, "stuck event");
    42de:	61 e0       	ldi	r22, 0x01	; 1
    42e0:	81 11       	cpse	r24, r1
    42e2:	23 c1       	rjmp	.+582    	; 0x452a <evt2_execute+0x2ca>
    42e4:	83 e0       	ldi	r24, 0x03	; 3
    42e6:	90 e0       	ldi	r25, 0x00	; 0
    42e8:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    42ec:	81 11       	cpse	r24, r1
    42ee:	d8 cf       	rjmp	.-80     	; 0x42a0 <evt2_execute+0x40>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
    42f0:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  target_time = chTimeNow() + MS2ST(50);
    42f4:	e0 90 2f 0c 	lds	r14, 0x0C2F
    42f8:	f0 90 30 0c 	lds	r15, 0x0C30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
    42fc:	00 91 3c 0c 	lds	r16, 0x0C3C
    4300:	10 91 3d 0c 	lds	r17, 0x0C3D
    4304:	c0 90 8d 02 	lds	r12, 0x028D
    4308:	d0 90 8e 02 	lds	r13, 0x028E
    430c:	f8 01       	movw	r30, r16
    430e:	44 81       	ldd	r20, Z+4	; 0x04
    4310:	41 50       	subi	r20, 0x01	; 1
    4312:	28 ea       	ldi	r18, 0xA8	; 168
    4314:	32 e2       	ldi	r19, 0x22	; 34
    4316:	67 e9       	ldi	r22, 0x97	; 151
    4318:	70 e0       	ldi	r23, 0x00	; 0
    431a:	c6 01       	movw	r24, r12
    431c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    4320:	90 93 40 0c 	sts	0x0C40, r25
    4324:	80 93 3f 0c 	sts	0x0C3F, r24
                                 thread1, chThdSelf());
  m = chEvtWaitOne(ALL_EVENTS);
    4328:	8f ef       	ldi	r24, 0xFF	; 255
    432a:	0e 94 2c 0a 	call	0x1458	; 0x1458 <chEvtWaitOne>
    432e:	18 2f       	mov	r17, r24
  test_assert_time_window(4, target_time, target_time + ALLOWED_DELAY);
    4330:	a7 01       	movw	r20, r14
    4332:	49 5c       	subi	r20, 0xC9	; 201
    4334:	5f 4f       	sbci	r21, 0xFF	; 255

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(50);
    4336:	b7 01       	movw	r22, r14
    4338:	6e 5c       	subi	r22, 0xCE	; 206
    433a:	7f 4f       	sbci	r23, 0xFF	; 255
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
                                 thread1, chThdSelf());
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert_time_window(4, target_time, target_time + ALLOWED_DELAY);
    433c:	84 e0       	ldi	r24, 0x04	; 4
    433e:	90 e0       	ldi	r25, 0x00	; 0
    4340:	0e 94 20 10 	call	0x2040	; 0x2040 <_test_assert_time_window>
    4344:	81 11       	cpse	r24, r1
    4346:	ac cf       	rjmp	.-168    	; 0x42a0 <evt2_execute+0x40>
  test_assert(5, m == 1, "single event error");
    4348:	61 e0       	ldi	r22, 0x01	; 1
    434a:	11 30       	cpi	r17, 0x01	; 1
    434c:	09 f0       	breq	.+2      	; 0x4350 <evt2_execute+0xf0>
    434e:	60 e0       	ldi	r22, 0x00	; 0
    4350:	85 e0       	ldi	r24, 0x05	; 5
    4352:	90 e0       	ldi	r25, 0x00	; 0
    4354:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4358:	81 11       	cpse	r24, r1
    435a:	a2 cf       	rjmp	.-188    	; 0x42a0 <evt2_execute+0x40>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    435c:	8f ef       	ldi	r24, 0xFF	; 255
    435e:	0e 94 92 09 	call	0x1324	; 0x1324 <chEvtGetAndClearEvents>
  test_assert(6, m == 0, "stuck event");
    4362:	61 e0       	ldi	r22, 0x01	; 1
    4364:	81 11       	cpse	r24, r1
    4366:	60 e0       	ldi	r22, 0x00	; 0
    4368:	86 e0       	ldi	r24, 0x06	; 6
    436a:	90 e0       	ldi	r25, 0x00	; 0
    436c:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4370:	81 11       	cpse	r24, r1
    4372:	96 cf       	rjmp	.-212    	; 0x42a0 <evt2_execute+0x40>
  test_wait_threads();
    4374:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
    4378:	85 e0       	ldi	r24, 0x05	; 5
    437a:	0e 94 9f 09 	call	0x133e	; 0x133e <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
    437e:	8f ef       	ldi	r24, 0xFF	; 255
    4380:	0e 94 4c 0a 	call	0x1498	; 0x1498 <chEvtWaitAny>
  test_assert(7, m == 5, "unexpected pending bit");
    4384:	61 e0       	ldi	r22, 0x01	; 1
    4386:	85 30       	cpi	r24, 0x05	; 5
    4388:	09 f0       	breq	.+2      	; 0x438c <evt2_execute+0x12c>
    438a:	60 e0       	ldi	r22, 0x00	; 0
    438c:	87 e0       	ldi	r24, 0x07	; 7
    438e:	90 e0       	ldi	r25, 0x00	; 0
    4390:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4394:	81 11       	cpse	r24, r1
    4396:	84 cf       	rjmp	.-248    	; 0x42a0 <evt2_execute+0x40>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    4398:	8f ef       	ldi	r24, 0xFF	; 255
    439a:	0e 94 92 09 	call	0x1324	; 0x1324 <chEvtGetAndClearEvents>
  test_assert(8, m == 0, "stuck event");
    439e:	61 e0       	ldi	r22, 0x01	; 1
    43a0:	81 11       	cpse	r24, r1
    43a2:	60 e0       	ldi	r22, 0x00	; 0
    43a4:	88 e0       	ldi	r24, 0x08	; 8
    43a6:	90 e0       	ldi	r25, 0x00	; 0
    43a8:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    43ac:	81 11       	cpse	r24, r1
    43ae:	78 cf       	rjmp	.-272    	; 0x42a0 <evt2_execute+0x40>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
    43b0:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  target_time = chTimeNow() + MS2ST(50);
    43b4:	e0 90 2f 0c 	lds	r14, 0x0C2F
    43b8:	f0 90 30 0c 	lds	r15, 0x0C30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
    43bc:	00 91 3c 0c 	lds	r16, 0x0C3C
    43c0:	10 91 3d 0c 	lds	r17, 0x0C3D
    43c4:	f8 01       	movw	r30, r16
    43c6:	44 81       	ldd	r20, Z+4	; 0x04
    43c8:	41 50       	subi	r20, 0x01	; 1
    43ca:	28 ea       	ldi	r18, 0xA8	; 168
    43cc:	32 e2       	ldi	r19, 0x22	; 34
    43ce:	67 e9       	ldi	r22, 0x97	; 151
    43d0:	70 e0       	ldi	r23, 0x00	; 0
    43d2:	c6 01       	movw	r24, r12
    43d4:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    43d8:	90 93 40 0c 	sts	0x0C40, r25
    43dc:	80 93 3f 0c 	sts	0x0C3F, r24
                                 thread1, chThdSelf());
  m = chEvtWaitAny(ALL_EVENTS);
    43e0:	8f ef       	ldi	r24, 0xFF	; 255
    43e2:	0e 94 4c 0a 	call	0x1498	; 0x1498 <chEvtWaitAny>
    43e6:	18 2f       	mov	r17, r24
  test_assert_time_window(9, target_time, target_time + ALLOWED_DELAY);
    43e8:	a7 01       	movw	r20, r14
    43ea:	49 5c       	subi	r20, 0xC9	; 201
    43ec:	5f 4f       	sbci	r21, 0xFF	; 255

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(50);
    43ee:	b7 01       	movw	r22, r14
    43f0:	6e 5c       	subi	r22, 0xCE	; 206
    43f2:	7f 4f       	sbci	r23, 0xFF	; 255
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
                                 thread1, chThdSelf());
  m = chEvtWaitAny(ALL_EVENTS);
  test_assert_time_window(9, target_time, target_time + ALLOWED_DELAY);
    43f4:	89 e0       	ldi	r24, 0x09	; 9
    43f6:	90 e0       	ldi	r25, 0x00	; 0
    43f8:	0e 94 20 10 	call	0x2040	; 0x2040 <_test_assert_time_window>
    43fc:	81 11       	cpse	r24, r1
    43fe:	50 cf       	rjmp	.-352    	; 0x42a0 <evt2_execute+0x40>
  test_assert(10, m == 1, "single event error");
    4400:	61 e0       	ldi	r22, 0x01	; 1
    4402:	11 30       	cpi	r17, 0x01	; 1
    4404:	09 f0       	breq	.+2      	; 0x4408 <evt2_execute+0x1a8>
    4406:	60 e0       	ldi	r22, 0x00	; 0
    4408:	8a e0       	ldi	r24, 0x0A	; 10
    440a:	90 e0       	ldi	r25, 0x00	; 0
    440c:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4410:	81 11       	cpse	r24, r1
    4412:	46 cf       	rjmp	.-372    	; 0x42a0 <evt2_execute+0x40>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    4414:	8f ef       	ldi	r24, 0xFF	; 255
    4416:	0e 94 92 09 	call	0x1324	; 0x1324 <chEvtGetAndClearEvents>
  test_assert(11, m == 0, "stuck event");
    441a:	61 e0       	ldi	r22, 0x01	; 1
    441c:	81 11       	cpse	r24, r1
    441e:	60 e0       	ldi	r22, 0x00	; 0
    4420:	8b e0       	ldi	r24, 0x0B	; 11
    4422:	90 e0       	ldi	r25, 0x00	; 0
    4424:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4428:	81 11       	cpse	r24, r1
    442a:	3a cf       	rjmp	.-396    	; 0x42a0 <evt2_execute+0x40>
  test_wait_threads();
    442c:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>

  /*
   * Test on chEvtWaitAll().
   */
  chEvtInit(&es1);
    4430:	8b e2       	ldi	r24, 0x2B	; 43
    4432:	92 e0       	ldi	r25, 0x02	; 2
    4434:	90 93 2c 02 	sts	0x022C, r25
    4438:	80 93 2b 02 	sts	0x022B, r24
  chEvtInit(&es2);
    443c:	8d e2       	ldi	r24, 0x2D	; 45
    443e:	92 e0       	ldi	r25, 0x02	; 2
    4440:	90 93 2e 02 	sts	0x022E, r25
    4444:	80 93 2d 02 	sts	0x022D, r24
  chEvtRegisterMask(&es1, &el1, 1);
    4448:	41 e0       	ldi	r20, 0x01	; 1
    444a:	be 01       	movw	r22, r28
    444c:	69 5f       	subi	r22, 0xF9	; 249
    444e:	7f 4f       	sbci	r23, 0xFF	; 255
    4450:	8b e2       	ldi	r24, 0x2B	; 43
    4452:	92 e0       	ldi	r25, 0x02	; 2
    4454:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <chEvtRegisterMask>
  chEvtRegisterMask(&es2, &el2, 4);
    4458:	44 e0       	ldi	r20, 0x04	; 4
    445a:	be 01       	movw	r22, r28
    445c:	6f 5f       	subi	r22, 0xFF	; 255
    445e:	7f 4f       	sbci	r23, 0xFF	; 255
    4460:	8d e2       	ldi	r24, 0x2D	; 45
    4462:	92 e0       	ldi	r25, 0x02	; 2
    4464:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <chEvtRegisterMask>
  test_wait_tick();
    4468:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  target_time = chTimeNow() + MS2ST(50);
    446c:	e0 90 2f 0c 	lds	r14, 0x0C2F
    4470:	f0 90 30 0c 	lds	r15, 0x0C30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
    4474:	e0 91 3c 0c 	lds	r30, 0x0C3C
    4478:	f0 91 3d 0c 	lds	r31, 0x0C3D
    447c:	44 81       	ldd	r20, Z+4	; 0x04
    447e:	41 50       	subi	r20, 0x01	; 1
    4480:	04 ec       	ldi	r16, 0xC4	; 196
    4482:	15 e0       	ldi	r17, 0x05	; 5
    4484:	27 e9       	ldi	r18, 0x97	; 151
    4486:	32 e2       	ldi	r19, 0x22	; 34
    4488:	67 e9       	ldi	r22, 0x97	; 151
    448a:	70 e0       	ldi	r23, 0x00	; 0
    448c:	c6 01       	movw	r24, r12
    448e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    4492:	90 93 40 0c 	sts	0x0C40, r25
    4496:	80 93 3f 0c 	sts	0x0C3F, r24
                                 thread2, "A");
  m = chEvtWaitAll(5);
    449a:	85 e0       	ldi	r24, 0x05	; 5
    449c:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <chEvtWaitAll>
  test_assert_time_window(12, target_time, target_time + ALLOWED_DELAY);
    44a0:	a7 01       	movw	r20, r14
    44a2:	49 5c       	subi	r20, 0xC9	; 201
    44a4:	5f 4f       	sbci	r21, 0xFF	; 255
  chEvtInit(&es1);
  chEvtInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
  target_time = chTimeNow() + MS2ST(50);
    44a6:	b7 01       	movw	r22, r14
    44a8:	6e 5c       	subi	r22, 0xCE	; 206
    44aa:	7f 4f       	sbci	r23, 0xFF	; 255
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority() - 1,
                                 thread2, "A");
  m = chEvtWaitAll(5);
  test_assert_time_window(12, target_time, target_time + ALLOWED_DELAY);
    44ac:	8c e0       	ldi	r24, 0x0C	; 12
    44ae:	90 e0       	ldi	r25, 0x00	; 0
    44b0:	0e 94 20 10 	call	0x2040	; 0x2040 <_test_assert_time_window>
    44b4:	81 11       	cpse	r24, r1
    44b6:	f4 ce       	rjmp	.-536    	; 0x42a0 <evt2_execute+0x40>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    44b8:	8f ef       	ldi	r24, 0xFF	; 255
    44ba:	0e 94 92 09 	call	0x1324	; 0x1324 <chEvtGetAndClearEvents>
  test_assert(13, m == 0, "stuck event");
    44be:	61 e0       	ldi	r22, 0x01	; 1
    44c0:	81 11       	cpse	r24, r1
    44c2:	60 e0       	ldi	r22, 0x00	; 0
    44c4:	8d e0       	ldi	r24, 0x0D	; 13
    44c6:	90 e0       	ldi	r25, 0x00	; 0
    44c8:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    44cc:	81 11       	cpse	r24, r1
    44ce:	e8 ce       	rjmp	.-560    	; 0x42a0 <evt2_execute+0x40>
  test_wait_threads();
    44d0:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
    44d4:	be 01       	movw	r22, r28
    44d6:	69 5f       	subi	r22, 0xF9	; 249
    44d8:	7f 4f       	sbci	r23, 0xFF	; 255
    44da:	8b e2       	ldi	r24, 0x2B	; 43
    44dc:	92 e0       	ldi	r25, 0x02	; 2
    44de:	0e 94 7f 09 	call	0x12fe	; 0x12fe <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
    44e2:	be 01       	movw	r22, r28
    44e4:	6f 5f       	subi	r22, 0xFF	; 255
    44e6:	7f 4f       	sbci	r23, 0xFF	; 255
    44e8:	8d e2       	ldi	r24, 0x2D	; 45
    44ea:	92 e0       	ldi	r25, 0x02	; 2
    44ec:	0e 94 7f 09 	call	0x12fe	; 0x12fe <chEvtUnregister>
  test_assert(14, !chEvtIsListeningI(&es1), "stuck listener");
    44f0:	61 e0       	ldi	r22, 0x01	; 1
    44f2:	80 91 2b 02 	lds	r24, 0x022B
    44f6:	90 91 2c 02 	lds	r25, 0x022C
    44fa:	8b 52       	subi	r24, 0x2B	; 43
    44fc:	92 40       	sbci	r25, 0x02	; 2
    44fe:	09 f0       	breq	.+2      	; 0x4502 <evt2_execute+0x2a2>
    4500:	60 e0       	ldi	r22, 0x00	; 0
    4502:	8e e0       	ldi	r24, 0x0E	; 14
    4504:	90 e0       	ldi	r25, 0x00	; 0
    4506:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    450a:	81 11       	cpse	r24, r1
    450c:	c9 ce       	rjmp	.-622    	; 0x42a0 <evt2_execute+0x40>
  test_assert(15, !chEvtIsListeningI(&es2), "stuck listener");
    450e:	61 e0       	ldi	r22, 0x01	; 1
    4510:	80 91 2d 02 	lds	r24, 0x022D
    4514:	90 91 2e 02 	lds	r25, 0x022E
    4518:	8d 52       	subi	r24, 0x2D	; 45
    451a:	92 40       	sbci	r25, 0x02	; 2
    451c:	09 f0       	breq	.+2      	; 0x4520 <evt2_execute+0x2c0>
    451e:	60 e0       	ldi	r22, 0x00	; 0
    4520:	8f e0       	ldi	r24, 0x0F	; 15
    4522:	90 e0       	ldi	r25, 0x00	; 0
    4524:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4528:	bb ce       	rjmp	.-650    	; 0x42a0 <evt2_execute+0x40>
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(2, m == 4, "single event error");
  m = chEvtGetAndClearEvents(ALL_EVENTS);
  test_assert(3, m == 0, "stuck event");
    452a:	60 e0       	ldi	r22, 0x00	; 0
    452c:	db ce       	rjmp	.-586    	; 0x42e4 <evt2_execute+0x84>

0000452e <thread2>:
}

static msg_t thread2(void *p) {

  (void)p;
  chEvtBroadcast(&es1);
    452e:	60 e0       	ldi	r22, 0x00	; 0
    4530:	8b e2       	ldi	r24, 0x2B	; 43
    4532:	92 e0       	ldi	r25, 0x02	; 2
    4534:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <chEvtBroadcastFlags>
  chThdSleepMilliseconds(50);
    4538:	82 e3       	ldi	r24, 0x32	; 50
    453a:	90 e0       	ldi	r25, 0x00	; 0
    453c:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  chEvtBroadcast(&es2);
    4540:	60 e0       	ldi	r22, 0x00	; 0
    4542:	8d e2       	ldi	r24, 0x2D	; 45
    4544:	92 e0       	ldi	r25, 0x02	; 2
    4546:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <chEvtBroadcastFlags>
  return 0;
}
    454a:	80 e0       	ldi	r24, 0x00	; 0
    454c:	90 e0       	ldi	r25, 0x00	; 0
    454e:	08 95       	ret

00004550 <thread1>:
static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static msg_t thread1(void *p) {
    4550:	cf 93       	push	r28
    4552:	df 93       	push	r29
    4554:	ec 01       	movw	r28, r24

  chThdSleepMilliseconds(50);
    4556:	82 e3       	ldi	r24, 0x32	; 50
    4558:	90 e0       	ldi	r25, 0x00	; 0
    455a:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  chEvtSignal((Thread *)p, 1);
    455e:	61 e0       	ldi	r22, 0x01	; 1
    4560:	ce 01       	movw	r24, r28
    4562:	0e 94 c8 09 	call	0x1390	; 0x1390 <chEvtSignal>
  return 0;
}
    4566:	80 e0       	ldi	r24, 0x00	; 0
    4568:	90 e0       	ldi	r25, 0x00	; 0
    456a:	df 91       	pop	r29
    456c:	cf 91       	pop	r28
    456e:	08 95       	ret

00004570 <evt1_execute>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
    4570:	cf 93       	push	r28
    4572:	df 93       	push	r29
    4574:	cd b7       	in	r28, 0x3d	; 61
    4576:	de b7       	in	r29, 0x3e	; 62
    4578:	2c 97       	sbiw	r28, 0x0c	; 12
    457a:	0f b6       	in	r0, 0x3f	; 63
    457c:	f8 94       	cli
    457e:	de bf       	out	0x3e, r29	; 62
    4580:	0f be       	out	0x3f, r0	; 63
    4582:	cd bf       	out	0x3d, r28	; 61
  EventListener el1, el2;

  /*
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtInit(&es1);
    4584:	8b e2       	ldi	r24, 0x2B	; 43
    4586:	92 e0       	ldi	r25, 0x02	; 2
    4588:	90 93 2c 02 	sts	0x022C, r25
    458c:	80 93 2b 02 	sts	0x022B, r24
  chEvtRegisterMask(&es1, &el1, 1);
    4590:	41 e0       	ldi	r20, 0x01	; 1
    4592:	be 01       	movw	r22, r28
    4594:	69 5f       	subi	r22, 0xF9	; 249
    4596:	7f 4f       	sbci	r23, 0xFF	; 255
    4598:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <chEvtRegisterMask>
  chEvtRegisterMask(&es1, &el2, 2);
    459c:	42 e0       	ldi	r20, 0x02	; 2
    459e:	be 01       	movw	r22, r28
    45a0:	6f 5f       	subi	r22, 0xFF	; 255
    45a2:	7f 4f       	sbci	r23, 0xFF	; 255
    45a4:	8b e2       	ldi	r24, 0x2B	; 43
    45a6:	92 e0       	ldi	r25, 0x02	; 2
    45a8:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <chEvtRegisterMask>
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
    45ac:	61 e0       	ldi	r22, 0x01	; 1
    45ae:	80 91 2b 02 	lds	r24, 0x022B
    45b2:	90 91 2c 02 	lds	r25, 0x022C
    45b6:	8b 52       	subi	r24, 0x2B	; 43
    45b8:	92 40       	sbci	r25, 0x02	; 2
    45ba:	79 f0       	breq	.+30     	; 0x45da <evt1_execute+0x6a>
    45bc:	81 e0       	ldi	r24, 0x01	; 1
    45be:	90 e0       	ldi	r25, 0x00	; 0
    45c0:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    45c4:	88 23       	and	r24, r24
    45c6:	81 f0       	breq	.+32     	; 0x45e8 <evt1_execute+0x78>
  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
}
    45c8:	2c 96       	adiw	r28, 0x0c	; 12
    45ca:	0f b6       	in	r0, 0x3f	; 63
    45cc:	f8 94       	cli
    45ce:	de bf       	out	0x3e, r29	; 62
    45d0:	0f be       	out	0x3f, r0	; 63
    45d2:	cd bf       	out	0x3d, r28	; 61
    45d4:	df 91       	pop	r29
    45d6:	cf 91       	pop	r28
    45d8:	08 95       	ret
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
    45da:	60 e0       	ldi	r22, 0x00	; 0
    45dc:	81 e0       	ldi	r24, 0x01	; 1
    45de:	90 e0       	ldi	r25, 0x00	; 0
    45e0:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    45e4:	81 11       	cpse	r24, r1
    45e6:	f0 cf       	rjmp	.-32     	; 0x45c8 <evt1_execute+0x58>
  chEvtUnregister(&es1, &el1);
    45e8:	be 01       	movw	r22, r28
    45ea:	69 5f       	subi	r22, 0xF9	; 249
    45ec:	7f 4f       	sbci	r23, 0xFF	; 255
    45ee:	8b e2       	ldi	r24, 0x2B	; 43
    45f0:	92 e0       	ldi	r25, 0x02	; 2
    45f2:	0e 94 7f 09 	call	0x12fe	; 0x12fe <chEvtUnregister>
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
    45f6:	61 e0       	ldi	r22, 0x01	; 1
    45f8:	80 91 2b 02 	lds	r24, 0x022B
    45fc:	90 91 2c 02 	lds	r25, 0x022C
    4600:	8b 52       	subi	r24, 0x2B	; 43
    4602:	92 40       	sbci	r25, 0x02	; 2
    4604:	41 f1       	breq	.+80     	; 0x4656 <evt1_execute+0xe6>
    4606:	82 e0       	ldi	r24, 0x02	; 2
    4608:	90 e0       	ldi	r25, 0x00	; 0
    460a:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    460e:	81 11       	cpse	r24, r1
    4610:	db cf       	rjmp	.-74     	; 0x45c8 <evt1_execute+0x58>
  chEvtUnregister(&es1, &el2);
    4612:	be 01       	movw	r22, r28
    4614:	6f 5f       	subi	r22, 0xFF	; 255
    4616:	7f 4f       	sbci	r23, 0xFF	; 255
    4618:	8b e2       	ldi	r24, 0x2B	; 43
    461a:	92 e0       	ldi	r25, 0x02	; 2
    461c:	0e 94 7f 09 	call	0x12fe	; 0x12fe <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
    4620:	61 e0       	ldi	r22, 0x01	; 1
    4622:	80 91 2b 02 	lds	r24, 0x022B
    4626:	90 91 2c 02 	lds	r25, 0x022C
    462a:	8b 52       	subi	r24, 0x2B	; 43
    462c:	92 40       	sbci	r25, 0x02	; 2
    462e:	09 f0       	breq	.+2      	; 0x4632 <evt1_execute+0xc2>
    4630:	60 e0       	ldi	r22, 0x00	; 0
    4632:	83 e0       	ldi	r24, 0x03	; 3
    4634:	90 e0       	ldi	r25, 0x00	; 0
    4636:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    463a:	81 11       	cpse	r24, r1
    463c:	c5 cf       	rjmp	.-118    	; 0x45c8 <evt1_execute+0x58>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
    463e:	67 e0       	ldi	r22, 0x07	; 7
    4640:	8d e8       	ldi	r24, 0x8D	; 141
    4642:	93 e0       	ldi	r25, 0x03	; 3
    4644:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
    4648:	67 e9       	ldi	r22, 0x97	; 151
    464a:	76 e0       	ldi	r23, 0x06	; 6
    464c:	84 e0       	ldi	r24, 0x04	; 4
    464e:	90 e0       	ldi	r25, 0x00	; 0
    4650:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <_test_assert_sequence>
    4654:	b9 cf       	rjmp	.-142    	; 0x45c8 <evt1_execute+0x58>
  chEvtInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el1);
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
    4656:	60 e0       	ldi	r22, 0x00	; 0
    4658:	d6 cf       	rjmp	.-84     	; 0x4606 <evt1_execute+0x96>

0000465a <h3>:
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
    465a:	83 e4       	ldi	r24, 0x43	; 67
    465c:	0c 94 d2 0f 	jmp	0x1fa4	; 0x1fa4 <test_emit_token>

00004660 <h2>:

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
    4660:	82 e4       	ldi	r24, 0x42	; 66
    4662:	0c 94 d2 0f 	jmp	0x1fa4	; 0x1fa4 <test_emit_token>

00004666 <h1>:
static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
    4666:	81 e4       	ldi	r24, 0x41	; 65
    4668:	0c 94 d2 0f 	jmp	0x1fa4	; 0x1fa4 <test_emit_token>

0000466c <evt3_execute>:
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    466c:	60 e0       	ldi	r22, 0x00	; 0
    466e:	70 e0       	ldi	r23, 0x00	; 0
    4670:	8f ef       	ldi	r24, 0xFF	; 255
    4672:	0e 94 84 0a 	call	0x1508	; 0x1508 <chEvtWaitOneTimeout>
  test_assert(1, m == 0, "spurious event");
    4676:	61 e0       	ldi	r22, 0x01	; 1
    4678:	81 11       	cpse	r24, r1
    467a:	60 e0       	ldi	r22, 0x00	; 0
    467c:	81 e0       	ldi	r24, 0x01	; 1
    467e:	90 e0       	ldi	r25, 0x00	; 0
    4680:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4684:	81 11       	cpse	r24, r1
    4686:	08 95       	ret
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    4688:	60 e0       	ldi	r22, 0x00	; 0
    468a:	70 e0       	ldi	r23, 0x00	; 0
    468c:	8f ef       	ldi	r24, 0xFF	; 255
    468e:	0e 94 b3 0a 	call	0x1566	; 0x1566 <chEvtWaitAnyTimeout>
  test_assert(2, m == 0, "spurious event");
    4692:	61 e0       	ldi	r22, 0x01	; 1
    4694:	81 11       	cpse	r24, r1
    4696:	3c c0       	rjmp	.+120    	; 0x4710 <evt3_execute+0xa4>
    4698:	82 e0       	ldi	r24, 0x02	; 2
    469a:	90 e0       	ldi	r25, 0x00	; 0
    469c:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    46a0:	81 11       	cpse	r24, r1
    46a2:	f1 cf       	rjmp	.-30     	; 0x4686 <evt3_execute+0x1a>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    46a4:	60 e0       	ldi	r22, 0x00	; 0
    46a6:	70 e0       	ldi	r23, 0x00	; 0
    46a8:	8f ef       	ldi	r24, 0xFF	; 255
    46aa:	0e 94 df 0a 	call	0x15be	; 0x15be <chEvtWaitAllTimeout>
  test_assert(3, m == 0, "spurious event");
    46ae:	61 e0       	ldi	r22, 0x01	; 1
    46b0:	81 11       	cpse	r24, r1
    46b2:	60 e0       	ldi	r22, 0x00	; 0
    46b4:	83 e0       	ldi	r24, 0x03	; 3
    46b6:	90 e0       	ldi	r25, 0x00	; 0
    46b8:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    46bc:	81 11       	cpse	r24, r1
    46be:	e3 cf       	rjmp	.-58     	; 0x4686 <evt3_execute+0x1a>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
    46c0:	6a e0       	ldi	r22, 0x0A	; 10
    46c2:	70 e0       	ldi	r23, 0x00	; 0
    46c4:	8f ef       	ldi	r24, 0xFF	; 255
    46c6:	0e 94 84 0a 	call	0x1508	; 0x1508 <chEvtWaitOneTimeout>
  test_assert(4, m == 0, "spurious event");
    46ca:	61 e0       	ldi	r22, 0x01	; 1
    46cc:	81 11       	cpse	r24, r1
    46ce:	28 c0       	rjmp	.+80     	; 0x4720 <evt3_execute+0xb4>
    46d0:	84 e0       	ldi	r24, 0x04	; 4
    46d2:	90 e0       	ldi	r25, 0x00	; 0
    46d4:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    46d8:	81 11       	cpse	r24, r1
    46da:	d5 cf       	rjmp	.-86     	; 0x4686 <evt3_execute+0x1a>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
    46dc:	6a e0       	ldi	r22, 0x0A	; 10
    46de:	70 e0       	ldi	r23, 0x00	; 0
    46e0:	8f ef       	ldi	r24, 0xFF	; 255
    46e2:	0e 94 b3 0a 	call	0x1566	; 0x1566 <chEvtWaitAnyTimeout>
  test_assert(5, m == 0, "spurious event");
    46e6:	61 e0       	ldi	r22, 0x01	; 1
    46e8:	81 11       	cpse	r24, r1
    46ea:	60 e0       	ldi	r22, 0x00	; 0
    46ec:	85 e0       	ldi	r24, 0x05	; 5
    46ee:	90 e0       	ldi	r25, 0x00	; 0
    46f0:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    46f4:	81 11       	cpse	r24, r1
    46f6:	c7 cf       	rjmp	.-114    	; 0x4686 <evt3_execute+0x1a>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
    46f8:	6a e0       	ldi	r22, 0x0A	; 10
    46fa:	70 e0       	ldi	r23, 0x00	; 0
    46fc:	8f ef       	ldi	r24, 0xFF	; 255
    46fe:	0e 94 df 0a 	call	0x15be	; 0x15be <chEvtWaitAllTimeout>
  test_assert(6, m == 0, "spurious event");
    4702:	61 e0       	ldi	r22, 0x01	; 1
    4704:	81 11       	cpse	r24, r1
    4706:	60 e0       	ldi	r22, 0x00	; 0
    4708:	86 e0       	ldi	r24, 0x06	; 6
    470a:	90 e0       	ldi	r25, 0x00	; 0
    470c:	0c 94 e9 0f 	jmp	0x1fd2	; 0x1fd2 <_test_assert>
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(1, m == 0, "spurious event");
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(2, m == 0, "spurious event");
    4710:	60 e0       	ldi	r22, 0x00	; 0
    4712:	82 e0       	ldi	r24, 0x02	; 2
    4714:	90 e0       	ldi	r25, 0x00	; 0
    4716:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    471a:	81 11       	cpse	r24, r1
    471c:	b4 cf       	rjmp	.-152    	; 0x4686 <evt3_execute+0x1a>
    471e:	c2 cf       	rjmp	.-124    	; 0x46a4 <evt3_execute+0x38>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(3, m == 0, "spurious event");
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
  test_assert(4, m == 0, "spurious event");
    4720:	60 e0       	ldi	r22, 0x00	; 0
    4722:	d6 cf       	rjmp	.-84     	; 0x46d0 <evt3_execute+0x64>

00004724 <notify>:

#if CH_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(GenericQueue *qp) {
    4724:	08 95       	ret

00004726 <thread2>:
}

static msg_t thread2(void *p) {

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
    4726:	48 ec       	ldi	r20, 0xC8	; 200
    4728:	50 e0       	ldi	r21, 0x00	; 0
    472a:	60 e0       	ldi	r22, 0x00	; 0
    472c:	81 e4       	ldi	r24, 0x41	; 65
    472e:	92 e0       	ldi	r25, 0x02	; 2
    4730:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <chOQPutTimeout>
  return 0;
}
    4734:	80 e0       	ldi	r24, 0x00	; 0
    4736:	90 e0       	ldi	r25, 0x00	; 0
    4738:	08 95       	ret

0000473a <queues2_setup>:
 * This test case tests sysnchronos and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
    473a:	0f 93       	push	r16
    473c:	1f 93       	push	r17

  chOQInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
    473e:	60 91 8d 02 	lds	r22, 0x028D
    4742:	70 91 8e 02 	lds	r23, 0x028E
    4746:	00 e0       	ldi	r16, 0x00	; 0
    4748:	10 e0       	ldi	r17, 0x00	; 0
    474a:	22 e9       	ldi	r18, 0x92	; 146
    474c:	33 e2       	ldi	r19, 0x23	; 35
    474e:	44 e0       	ldi	r20, 0x04	; 4
    4750:	50 e0       	ldi	r21, 0x00	; 0
    4752:	81 e4       	ldi	r24, 0x41	; 65
    4754:	92 e0       	ldi	r25, 0x02	; 2
    4756:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <chOQInit>
}
    475a:	1f 91       	pop	r17
    475c:	0f 91       	pop	r16
    475e:	08 95       	ret

00004760 <thread1>:
}

static msg_t thread1(void *p) {

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
    4760:	68 ec       	ldi	r22, 0xC8	; 200
    4762:	70 e0       	ldi	r23, 0x00	; 0
    4764:	8f e2       	ldi	r24, 0x2F	; 47
    4766:	92 e0       	ldi	r25, 0x02	; 2
    4768:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <chIQGetTimeout>
  return 0;
}
    476c:	80 e0       	ldi	r24, 0x00	; 0
    476e:	90 e0       	ldi	r25, 0x00	; 0
    4770:	08 95       	ret

00004772 <queues1_setup>:
 * This test case tests sysnchronos and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
    4772:	0f 93       	push	r16
    4774:	1f 93       	push	r17

  chIQInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
    4776:	60 91 8d 02 	lds	r22, 0x028D
    477a:	70 91 8e 02 	lds	r23, 0x028E
    477e:	00 e0       	ldi	r16, 0x00	; 0
    4780:	10 e0       	ldi	r17, 0x00	; 0
    4782:	22 e9       	ldi	r18, 0x92	; 146
    4784:	33 e2       	ldi	r19, 0x23	; 35
    4786:	44 e0       	ldi	r20, 0x04	; 4
    4788:	50 e0       	ldi	r21, 0x00	; 0
    478a:	8f e2       	ldi	r24, 0x2F	; 47
    478c:	92 e0       	ldi	r25, 0x02	; 2
    478e:	0e 94 c2 0c 	call	0x1984	; 0x1984 <chIQInit>
}
    4792:	1f 91       	pop	r17
    4794:	0f 91       	pop	r16
    4796:	08 95       	ret

00004798 <queues2_execute>:
  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
  return 0;
}

static void queues2_execute(void) {
    4798:	0f 93       	push	r16
    479a:	1f 93       	push	r17
    479c:	cf 93       	push	r28
    479e:	df 93       	push	r29
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
    47a0:	f8 94       	cli
    47a2:	20 91 4b 02 	lds	r18, 0x024B
    47a6:	30 91 4c 02 	lds	r19, 0x024C
    47aa:	80 91 4d 02 	lds	r24, 0x024D
    47ae:	90 91 4e 02 	lds	r25, 0x024E
    47b2:	28 17       	cp	r18, r24
    47b4:	39 07       	cpc	r19, r25
    47b6:	09 f4       	brne	.+2      	; 0x47ba <queues2_execute+0x22>
    47b8:	51 c0       	rjmp	.+162    	; 0x485c <queues2_execute+0xc4>
    47ba:	60 e0       	ldi	r22, 0x00	; 0
    47bc:	81 e0       	ldi	r24, 0x01	; 1
    47be:	90 e0       	ldi	r25, 0x00	; 0
    47c0:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    47c4:	78 94       	sei
    47c6:	81 11       	cpse	r24, r1
    47c8:	3b c0       	rjmp	.+118    	; 0x4840 <queues2_execute+0xa8>
    47ca:	c1 e4       	ldi	r28, 0x41	; 65

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
    47cc:	4f ef       	ldi	r20, 0xFF	; 255
    47ce:	5f ef       	ldi	r21, 0xFF	; 255
    47d0:	6c 2f       	mov	r22, r28
    47d2:	81 e4       	ldi	r24, 0x41	; 65
    47d4:	92 e0       	ldi	r25, 0x02	; 2
    47d6:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <chOQPutTimeout>
    47da:	cf 5f       	subi	r28, 0xFF	; 255

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    47dc:	c5 34       	cpi	r28, 0x45	; 69
    47de:	b1 f7       	brne	.-20     	; 0x47cc <queues2_execute+0x34>
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
    47e0:	f8 94       	cli
    47e2:	61 e0       	ldi	r22, 0x01	; 1
    47e4:	80 91 45 02 	lds	r24, 0x0245
    47e8:	90 91 46 02 	lds	r25, 0x0246
    47ec:	89 2b       	or	r24, r25
    47ee:	69 f5       	brne	.+90     	; 0x484a <queues2_execute+0xb2>
    47f0:	82 e0       	ldi	r24, 0x02	; 2
    47f2:	90 e0       	ldi	r25, 0x00	; 0
    47f4:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    47f8:	78 94       	sei
    47fa:	81 11       	cpse	r24, r1
    47fc:	21 c0       	rjmp	.+66     	; 0x4840 <queues2_execute+0xa8>
    47fe:	c4 e0       	ldi	r28, 0x04	; 4
    4800:	d0 e0       	ldi	r29, 0x00	; 0

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    4802:	f8 94       	cli
    c = chOQGetI(&oq);
    4804:	81 e4       	ldi	r24, 0x41	; 65
    4806:	92 e0       	ldi	r25, 0x02	; 2
    4808:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <chOQGetI>
    chSysUnlock();
    480c:	78 94       	sei
    test_emit_token(c);
    480e:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
    4812:	21 97       	sbiw	r28, 0x01	; 1
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    4814:	b1 f7       	brne	.-20     	; 0x4802 <queues2_execute+0x6a>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
    4816:	f8 94       	cli
    4818:	20 91 4b 02 	lds	r18, 0x024B
    481c:	30 91 4c 02 	lds	r19, 0x024C
    4820:	80 91 4d 02 	lds	r24, 0x024D
    4824:	90 91 4e 02 	lds	r25, 0x024E
    4828:	28 17       	cp	r18, r24
    482a:	39 07       	cpc	r19, r25
    482c:	09 f4       	brne	.+2      	; 0x4830 <queues2_execute+0x98>
    482e:	fc c0       	rjmp	.+504    	; 0x4a28 <queues2_execute+0x290>
    4830:	60 e0       	ldi	r22, 0x00	; 0
    4832:	83 e0       	ldi	r24, 0x03	; 3
    4834:	90 e0       	ldi	r25, 0x00	; 0
    4836:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    483a:	78 94       	sei
    483c:	88 23       	and	r24, r24
    483e:	b9 f0       	breq	.+46     	; 0x486e <queues2_execute+0xd6>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
    4840:	df 91       	pop	r29
    4842:	cf 91       	pop	r28
    4844:	1f 91       	pop	r17
    4846:	0f 91       	pop	r16
    4848:	08 95       	ret
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
    484a:	60 e0       	ldi	r22, 0x00	; 0
    484c:	82 e0       	ldi	r24, 0x02	; 2
    484e:	90 e0       	ldi	r25, 0x00	; 0
    4850:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4854:	78 94       	sei
    4856:	88 23       	and	r24, r24
    4858:	91 f2       	breq	.-92     	; 0x47fe <queues2_execute+0x66>
    485a:	f2 cf       	rjmp	.-28     	; 0x4840 <queues2_execute+0xa8>
static void queues2_execute(void) {
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
    485c:	61 e0       	ldi	r22, 0x01	; 1
    485e:	80 91 45 02 	lds	r24, 0x0245
    4862:	90 91 46 02 	lds	r25, 0x0246
    4866:	89 2b       	or	r24, r25
    4868:	09 f0       	breq	.+2      	; 0x486c <queues2_execute+0xd4>
    486a:	a8 cf       	rjmp	.-176    	; 0x47bc <queues2_execute+0x24>
    486c:	a6 cf       	rjmp	.-180    	; 0x47ba <queues2_execute+0x22>
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
  test_assert_sequence(4, "ABCD");
    486e:	6a ef       	ldi	r22, 0xFA	; 250
    4870:	77 e0       	ldi	r23, 0x07	; 7
    4872:	84 e0       	ldi	r24, 0x04	; 4
    4874:	90 e0       	ldi	r25, 0x00	; 0
    4876:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <_test_assert_sequence>
    487a:	81 11       	cpse	r24, r1
    487c:	e1 cf       	rjmp	.-62     	; 0x4840 <queues2_execute+0xa8>
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
    487e:	f8 94       	cli
    4880:	81 e4       	ldi	r24, 0x41	; 65
    4882:	92 e0       	ldi	r25, 0x02	; 2
    4884:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <chOQGetI>
    4888:	61 e0       	ldi	r22, 0x01	; 1
    488a:	03 96       	adiw	r24, 0x03	; 3
    488c:	09 f0       	breq	.+2      	; 0x4890 <queues2_execute+0xf8>
    488e:	60 e0       	ldi	r22, 0x00	; 0
    4890:	85 e0       	ldi	r24, 0x05	; 5
    4892:	90 e0       	ldi	r25, 0x00	; 0
    4894:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4898:	78 94       	sei
    489a:	81 11       	cpse	r24, r1
    489c:	d1 cf       	rjmp	.-94     	; 0x4840 <queues2_execute+0xa8>

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
    489e:	c0 91 8f 02 	lds	r28, 0x028F
    48a2:	d0 91 90 02 	lds	r29, 0x0290
    48a6:	20 e0       	ldi	r18, 0x00	; 0
    48a8:	30 e0       	ldi	r19, 0x00	; 0
    48aa:	48 e0       	ldi	r20, 0x08	; 8
    48ac:	50 e0       	ldi	r21, 0x00	; 0
    48ae:	be 01       	movw	r22, r28
    48b0:	81 e4       	ldi	r24, 0x41	; 65
    48b2:	92 e0       	ldi	r25, 0x02	; 2
    48b4:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <chOQWriteTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
    48b8:	61 e0       	ldi	r22, 0x01	; 1
    48ba:	04 97       	sbiw	r24, 0x04	; 4
    48bc:	09 f0       	breq	.+2      	; 0x48c0 <queues2_execute+0x128>
    48be:	60 e0       	ldi	r22, 0x00	; 0
    48c0:	86 e0       	ldi	r24, 0x06	; 6
    48c2:	90 e0       	ldi	r25, 0x00	; 0
    48c4:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    48c8:	81 11       	cpse	r24, r1
    48ca:	ba cf       	rjmp	.-140    	; 0x4840 <queues2_execute+0xa8>
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
    48cc:	f8 94       	cli
    48ce:	61 e0       	ldi	r22, 0x01	; 1
    48d0:	80 91 45 02 	lds	r24, 0x0245
    48d4:	90 91 46 02 	lds	r25, 0x0246
    48d8:	89 2b       	or	r24, r25
    48da:	09 f0       	breq	.+2      	; 0x48de <queues2_execute+0x146>
    48dc:	60 e0       	ldi	r22, 0x00	; 0
    48de:	87 e0       	ldi	r24, 0x07	; 7
    48e0:	90 e0       	ldi	r25, 0x00	; 0
    48e2:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    48e6:	78 94       	sei
    48e8:	81 11       	cpse	r24, r1
    48ea:	aa cf       	rjmp	.-172    	; 0x4840 <queues2_execute+0xa8>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread2, NULL);
    48ec:	e0 91 3c 0c 	lds	r30, 0x0C3C
    48f0:	f0 91 3d 0c 	lds	r31, 0x0C3D
    48f4:	44 81       	ldd	r20, Z+4	; 0x04
    48f6:	4f 5f       	subi	r20, 0xFF	; 255
    48f8:	00 e0       	ldi	r16, 0x00	; 0
    48fa:	10 e0       	ldi	r17, 0x00	; 0
    48fc:	23 e9       	ldi	r18, 0x93	; 147
    48fe:	33 e2       	ldi	r19, 0x23	; 35
    4900:	67 e9       	ldi	r22, 0x97	; 151
    4902:	70 e0       	ldi	r23, 0x00	; 0
    4904:	80 91 8d 02 	lds	r24, 0x028D
    4908:	90 91 8e 02 	lds	r25, 0x028E
    490c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    4910:	90 93 40 0c 	sts	0x0C40, r25
    4914:	80 93 3f 0c 	sts	0x0C3F, r24
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
    4918:	f8 94       	cli
    491a:	80 91 49 02 	lds	r24, 0x0249
    491e:	90 91 4a 02 	lds	r25, 0x024A
    4922:	20 91 47 02 	lds	r18, 0x0247
    4926:	30 91 48 02 	lds	r19, 0x0248
    492a:	82 1b       	sub	r24, r18
    492c:	93 0b       	sbc	r25, r19
    492e:	20 91 45 02 	lds	r18, 0x0245
    4932:	30 91 46 02 	lds	r19, 0x0246
    4936:	82 1b       	sub	r24, r18
    4938:	93 0b       	sbc	r25, r19
    493a:	61 e0       	ldi	r22, 0x01	; 1
    493c:	04 97       	sbiw	r24, 0x04	; 4
    493e:	09 f0       	breq	.+2      	; 0x4942 <queues2_execute+0x1aa>
    4940:	60 e0       	ldi	r22, 0x00	; 0
    4942:	88 e0       	ldi	r24, 0x08	; 8
    4944:	90 e0       	ldi	r25, 0x00	; 0
    4946:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    494a:	78 94       	sei
    494c:	81 11       	cpse	r24, r1
    494e:	78 cf       	rjmp	.-272    	; 0x4840 <queues2_execute+0xa8>
  test_wait_threads();
    4950:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>

  /* Testing reset */
  chSysLock();
    4954:	f8 94       	cli
  chOQResetI(&oq);
    4956:	81 e4       	ldi	r24, 0x41	; 65
    4958:	92 e0       	ldi	r25, 0x02	; 2
    495a:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <chOQResetI>
  chSysUnlock();
    495e:	78 94       	sei
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
    4960:	f8 94       	cli
    4962:	80 91 49 02 	lds	r24, 0x0249
    4966:	90 91 4a 02 	lds	r25, 0x024A
    496a:	20 91 47 02 	lds	r18, 0x0247
    496e:	30 91 48 02 	lds	r19, 0x0248
    4972:	82 1b       	sub	r24, r18
    4974:	93 0b       	sbc	r25, r19
    4976:	61 e0       	ldi	r22, 0x01	; 1
    4978:	20 91 45 02 	lds	r18, 0x0245
    497c:	30 91 46 02 	lds	r19, 0x0246
    4980:	82 17       	cp	r24, r18
    4982:	93 07       	cpc	r25, r19
    4984:	09 f0       	breq	.+2      	; 0x4988 <queues2_execute+0x1f0>
    4986:	60 e0       	ldi	r22, 0x00	; 0
    4988:	89 e0       	ldi	r24, 0x09	; 9
    498a:	90 e0       	ldi	r25, 0x00	; 0
    498c:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4990:	78 94       	sei
    4992:	81 11       	cpse	r24, r1
    4994:	55 cf       	rjmp	.-342    	; 0x4840 <queues2_execute+0xa8>

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    4996:	20 e0       	ldi	r18, 0x00	; 0
    4998:	30 e0       	ldi	r19, 0x00	; 0
    499a:	42 e0       	ldi	r20, 0x02	; 2
    499c:	50 e0       	ldi	r21, 0x00	; 0
    499e:	be 01       	movw	r22, r28
    49a0:	81 e4       	ldi	r24, 0x41	; 65
    49a2:	92 e0       	ldi	r25, 0x02	; 2
    49a4:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <chOQWriteTimeout>
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    49a8:	61 e0       	ldi	r22, 0x01	; 1
    49aa:	02 97       	sbiw	r24, 0x02	; 2
    49ac:	09 f0       	breq	.+2      	; 0x49b0 <queues2_execute+0x218>
    49ae:	60 e0       	ldi	r22, 0x00	; 0
    49b0:	8a e0       	ldi	r24, 0x0A	; 10
    49b2:	90 e0       	ldi	r25, 0x00	; 0
    49b4:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    49b8:	81 11       	cpse	r24, r1
    49ba:	42 cf       	rjmp	.-380    	; 0x4840 <queues2_execute+0xa8>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    49bc:	20 e0       	ldi	r18, 0x00	; 0
    49be:	30 e0       	ldi	r19, 0x00	; 0
    49c0:	42 e0       	ldi	r20, 0x02	; 2
    49c2:	50 e0       	ldi	r21, 0x00	; 0
    49c4:	be 01       	movw	r22, r28
    49c6:	81 e4       	ldi	r24, 0x41	; 65
    49c8:	92 e0       	ldi	r25, 0x02	; 2
    49ca:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <chOQWriteTimeout>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    49ce:	61 e0       	ldi	r22, 0x01	; 1
    49d0:	02 97       	sbiw	r24, 0x02	; 2
    49d2:	09 f0       	breq	.+2      	; 0x49d6 <queues2_execute+0x23e>
    49d4:	60 e0       	ldi	r22, 0x00	; 0
    49d6:	8b e0       	ldi	r24, 0x0B	; 11
    49d8:	90 e0       	ldi	r25, 0x00	; 0
    49da:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    49de:	81 11       	cpse	r24, r1
    49e0:	2f cf       	rjmp	.-418    	; 0x4840 <queues2_execute+0xa8>
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
    49e2:	f8 94       	cli
    49e4:	61 e0       	ldi	r22, 0x01	; 1
    49e6:	80 91 45 02 	lds	r24, 0x0245
    49ea:	90 91 46 02 	lds	r25, 0x0246
    49ee:	89 2b       	or	r24, r25
    49f0:	09 f0       	breq	.+2      	; 0x49f4 <queues2_execute+0x25c>
    49f2:	60 e0       	ldi	r22, 0x00	; 0
    49f4:	8c e0       	ldi	r24, 0x0C	; 12
    49f6:	90 e0       	ldi	r25, 0x00	; 0
    49f8:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    49fc:	78 94       	sei
    49fe:	81 11       	cpse	r24, r1
    4a00:	1f cf       	rjmp	.-450    	; 0x4840 <queues2_execute+0xa8>

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
    4a02:	4a e0       	ldi	r20, 0x0A	; 10
    4a04:	50 e0       	ldi	r21, 0x00	; 0
    4a06:	60 e0       	ldi	r22, 0x00	; 0
    4a08:	81 e4       	ldi	r24, 0x41	; 65
    4a0a:	92 e0       	ldi	r25, 0x02	; 2
    4a0c:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <chOQPutTimeout>
    4a10:	61 e0       	ldi	r22, 0x01	; 1
    4a12:	01 96       	adiw	r24, 0x01	; 1
    4a14:	09 f0       	breq	.+2      	; 0x4a18 <queues2_execute+0x280>
    4a16:	60 e0       	ldi	r22, 0x00	; 0
    4a18:	8d e0       	ldi	r24, 0x0D	; 13
    4a1a:	90 e0       	ldi	r25, 0x00	; 0
}
    4a1c:	df 91       	pop	r29
    4a1e:	cf 91       	pop	r28
    4a20:	1f 91       	pop	r17
    4a22:	0f 91       	pop	r16
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
    4a24:	0c 94 e9 0f 	jmp	0x1fd2	; 0x1fd2 <_test_assert>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
    4a28:	61 e0       	ldi	r22, 0x01	; 1
    4a2a:	80 91 45 02 	lds	r24, 0x0245
    4a2e:	90 91 46 02 	lds	r25, 0x0246
    4a32:	89 2b       	or	r24, r25
    4a34:	09 f0       	breq	.+2      	; 0x4a38 <queues2_execute+0x2a0>
    4a36:	fd ce       	rjmp	.-518    	; 0x4832 <queues2_execute+0x9a>
    4a38:	fb ce       	rjmp	.-522    	; 0x4830 <queues2_execute+0x98>

00004a3a <queues1_execute>:
  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
  return 0;
}

static void queues1_execute(void) {
    4a3a:	0f 93       	push	r16
    4a3c:	1f 93       	push	r17
    4a3e:	cf 93       	push	r28
    4a40:	df 93       	push	r29
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
    4a42:	f8 94       	cli
    4a44:	61 e0       	ldi	r22, 0x01	; 1
    4a46:	80 91 33 02 	lds	r24, 0x0233
    4a4a:	90 91 34 02 	lds	r25, 0x0234
    4a4e:	89 2b       	or	r24, r25
    4a50:	09 f0       	breq	.+2      	; 0x4a54 <queues1_execute+0x1a>
    4a52:	60 e0       	ldi	r22, 0x00	; 0
    4a54:	81 e0       	ldi	r24, 0x01	; 1
    4a56:	90 e0       	ldi	r25, 0x00	; 0
    4a58:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4a5c:	78 94       	sei
    4a5e:	81 11       	cpse	r24, r1
    4a60:	2b c0       	rjmp	.+86     	; 0x4ab8 <queues1_execute+0x7e>

  /* Queue filling */
  chSysLock();
    4a62:	f8 94       	cli
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
    4a64:	61 e4       	ldi	r22, 0x41	; 65
    4a66:	8f e2       	ldi	r24, 0x2F	; 47
    4a68:	92 e0       	ldi	r25, 0x02	; 2
    4a6a:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    4a6e:	62 e4       	ldi	r22, 0x42	; 66
    4a70:	8f e2       	ldi	r24, 0x2F	; 47
    4a72:	92 e0       	ldi	r25, 0x02	; 2
    4a74:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    4a78:	63 e4       	ldi	r22, 0x43	; 67
    4a7a:	8f e2       	ldi	r24, 0x2F	; 47
    4a7c:	92 e0       	ldi	r25, 0x02	; 2
    4a7e:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    4a82:	64 e4       	ldi	r22, 0x44	; 68
    4a84:	8f e2       	ldi	r24, 0x2F	; 47
    4a86:	92 e0       	ldi	r25, 0x02	; 2
    4a88:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
  chSysUnlock();
    4a8c:	78 94       	sei
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
    4a8e:	f8 94       	cli
    4a90:	20 91 39 02 	lds	r18, 0x0239
    4a94:	30 91 3a 02 	lds	r19, 0x023A
    4a98:	80 91 3b 02 	lds	r24, 0x023B
    4a9c:	90 91 3c 02 	lds	r25, 0x023C
    4aa0:	28 17       	cp	r18, r24
    4aa2:	39 07       	cpc	r19, r25
    4aa4:	09 f4       	brne	.+2      	; 0x4aa8 <queues1_execute+0x6e>
    4aa6:	20 c1       	rjmp	.+576    	; 0x4ce8 <queues1_execute+0x2ae>
    4aa8:	60 e0       	ldi	r22, 0x00	; 0
    4aaa:	82 e0       	ldi	r24, 0x02	; 2
    4aac:	90 e0       	ldi	r25, 0x00	; 0
    4aae:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4ab2:	78 94       	sei
    4ab4:	88 23       	and	r24, r24
    4ab6:	29 f0       	breq	.+10     	; 0x4ac2 <queues1_execute+0x88>
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
    4ab8:	df 91       	pop	r29
    4aba:	cf 91       	pop	r28
    4abc:	1f 91       	pop	r17
    4abe:	0f 91       	pop	r16
    4ac0:	08 95       	ret
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
    4ac2:	f8 94       	cli
    4ac4:	60 e0       	ldi	r22, 0x00	; 0
    4ac6:	8f e2       	ldi	r24, 0x2F	; 47
    4ac8:	92 e0       	ldi	r25, 0x02	; 2
    4aca:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    4ace:	61 e0       	ldi	r22, 0x01	; 1
    4ad0:	04 96       	adiw	r24, 0x04	; 4
    4ad2:	09 f0       	breq	.+2      	; 0x4ad6 <queues1_execute+0x9c>
    4ad4:	60 e0       	ldi	r22, 0x00	; 0
    4ad6:	83 e0       	ldi	r24, 0x03	; 3
    4ad8:	90 e0       	ldi	r25, 0x00	; 0
    4ada:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4ade:	78 94       	sei
    4ae0:	81 11       	cpse	r24, r1
    4ae2:	ea cf       	rjmp	.-44     	; 0x4ab8 <queues1_execute+0x7e>
    4ae4:	c4 e0       	ldi	r28, 0x04	; 4
    4ae6:	d0 e0       	ldi	r29, 0x00	; 0

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
    4ae8:	6f ef       	ldi	r22, 0xFF	; 255
    4aea:	7f ef       	ldi	r23, 0xFF	; 255
    4aec:	8f e2       	ldi	r24, 0x2F	; 47
    4aee:	92 e0       	ldi	r25, 0x02	; 2
    4af0:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <chIQGetTimeout>
    4af4:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <test_emit_token>
    4af8:	21 97       	sbiw	r28, 0x01	; 1
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    4afa:	b1 f7       	brne	.-20     	; 0x4ae8 <queues1_execute+0xae>
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
    4afc:	f8 94       	cli
    4afe:	61 e0       	ldi	r22, 0x01	; 1
    4b00:	80 91 33 02 	lds	r24, 0x0233
    4b04:	90 91 34 02 	lds	r25, 0x0234
    4b08:	89 2b       	or	r24, r25
    4b0a:	09 f0       	breq	.+2      	; 0x4b0e <queues1_execute+0xd4>
    4b0c:	60 e0       	ldi	r22, 0x00	; 0
    4b0e:	84 e0       	ldi	r24, 0x04	; 4
    4b10:	90 e0       	ldi	r25, 0x00	; 0
    4b12:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4b16:	78 94       	sei
    4b18:	81 11       	cpse	r24, r1
    4b1a:	ce cf       	rjmp	.-100    	; 0x4ab8 <queues1_execute+0x7e>
  test_assert_sequence(5, "ABCD");
    4b1c:	6a ef       	ldi	r22, 0xFA	; 250
    4b1e:	77 e0       	ldi	r23, 0x07	; 7
    4b20:	85 e0       	ldi	r24, 0x05	; 5
    4b22:	90 e0       	ldi	r25, 0x00	; 0
    4b24:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <_test_assert_sequence>
    4b28:	81 11       	cpse	r24, r1
    4b2a:	c6 cf       	rjmp	.-116    	; 0x4ab8 <queues1_execute+0x7e>

  /* Queue filling again */
  chSysLock();
    4b2c:	f8 94       	cli
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
    4b2e:	61 e4       	ldi	r22, 0x41	; 65
    4b30:	8f e2       	ldi	r24, 0x2F	; 47
    4b32:	92 e0       	ldi	r25, 0x02	; 2
    4b34:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    4b38:	62 e4       	ldi	r22, 0x42	; 66
    4b3a:	8f e2       	ldi	r24, 0x2F	; 47
    4b3c:	92 e0       	ldi	r25, 0x02	; 2
    4b3e:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    4b42:	63 e4       	ldi	r22, 0x43	; 67
    4b44:	8f e2       	ldi	r24, 0x2F	; 47
    4b46:	92 e0       	ldi	r25, 0x02	; 2
    4b48:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    4b4c:	64 e4       	ldi	r22, 0x44	; 68
    4b4e:	8f e2       	ldi	r24, 0x2F	; 47
    4b50:	92 e0       	ldi	r25, 0x02	; 2
    4b52:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
  chSysUnlock();
    4b56:	78 94       	sei

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
    4b58:	c0 91 8f 02 	lds	r28, 0x028F
    4b5c:	d0 91 90 02 	lds	r29, 0x0290
    4b60:	20 e0       	ldi	r18, 0x00	; 0
    4b62:	30 e0       	ldi	r19, 0x00	; 0
    4b64:	48 e0       	ldi	r20, 0x08	; 8
    4b66:	50 e0       	ldi	r21, 0x00	; 0
    4b68:	be 01       	movw	r22, r28
    4b6a:	8f e2       	ldi	r24, 0x2F	; 47
    4b6c:	92 e0       	ldi	r25, 0x02	; 2
    4b6e:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <chIQReadTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
    4b72:	61 e0       	ldi	r22, 0x01	; 1
    4b74:	04 97       	sbiw	r24, 0x04	; 4
    4b76:	09 f0       	breq	.+2      	; 0x4b7a <queues1_execute+0x140>
    4b78:	60 e0       	ldi	r22, 0x00	; 0
    4b7a:	86 e0       	ldi	r24, 0x06	; 6
    4b7c:	90 e0       	ldi	r25, 0x00	; 0
    4b7e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4b82:	81 11       	cpse	r24, r1
    4b84:	99 cf       	rjmp	.-206    	; 0x4ab8 <queues1_execute+0x7e>
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
    4b86:	f8 94       	cli
    4b88:	61 e0       	ldi	r22, 0x01	; 1
    4b8a:	80 91 33 02 	lds	r24, 0x0233
    4b8e:	90 91 34 02 	lds	r25, 0x0234
    4b92:	89 2b       	or	r24, r25
    4b94:	09 f0       	breq	.+2      	; 0x4b98 <queues1_execute+0x15e>
    4b96:	60 e0       	ldi	r22, 0x00	; 0
    4b98:	87 e0       	ldi	r24, 0x07	; 7
    4b9a:	90 e0       	ldi	r25, 0x00	; 0
    4b9c:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4ba0:	78 94       	sei
    4ba2:	81 11       	cpse	r24, r1
    4ba4:	89 cf       	rjmp	.-238    	; 0x4ab8 <queues1_execute+0x7e>

  /* Queue filling again */
  chSysLock();
    4ba6:	f8 94       	cli
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
    4ba8:	61 e4       	ldi	r22, 0x41	; 65
    4baa:	8f e2       	ldi	r24, 0x2F	; 47
    4bac:	92 e0       	ldi	r25, 0x02	; 2
    4bae:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    4bb2:	62 e4       	ldi	r22, 0x42	; 66
    4bb4:	8f e2       	ldi	r24, 0x2F	; 47
    4bb6:	92 e0       	ldi	r25, 0x02	; 2
    4bb8:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    4bbc:	63 e4       	ldi	r22, 0x43	; 67
    4bbe:	8f e2       	ldi	r24, 0x2F	; 47
    4bc0:	92 e0       	ldi	r25, 0x02	; 2
    4bc2:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    4bc6:	64 e4       	ldi	r22, 0x44	; 68
    4bc8:	8f e2       	ldi	r24, 0x2F	; 47
    4bca:	92 e0       	ldi	r25, 0x02	; 2
    4bcc:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
  chSysUnlock();
    4bd0:	78 94       	sei

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    4bd2:	20 e0       	ldi	r18, 0x00	; 0
    4bd4:	30 e0       	ldi	r19, 0x00	; 0
    4bd6:	42 e0       	ldi	r20, 0x02	; 2
    4bd8:	50 e0       	ldi	r21, 0x00	; 0
    4bda:	be 01       	movw	r22, r28
    4bdc:	8f e2       	ldi	r24, 0x2F	; 47
    4bde:	92 e0       	ldi	r25, 0x02	; 2
    4be0:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <chIQReadTimeout>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    4be4:	61 e0       	ldi	r22, 0x01	; 1
    4be6:	02 97       	sbiw	r24, 0x02	; 2
    4be8:	09 f0       	breq	.+2      	; 0x4bec <queues1_execute+0x1b2>
    4bea:	60 e0       	ldi	r22, 0x00	; 0
    4bec:	88 e0       	ldi	r24, 0x08	; 8
    4bee:	90 e0       	ldi	r25, 0x00	; 0
    4bf0:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4bf4:	81 11       	cpse	r24, r1
    4bf6:	60 cf       	rjmp	.-320    	; 0x4ab8 <queues1_execute+0x7e>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    4bf8:	20 e0       	ldi	r18, 0x00	; 0
    4bfa:	30 e0       	ldi	r19, 0x00	; 0
    4bfc:	42 e0       	ldi	r20, 0x02	; 2
    4bfe:	50 e0       	ldi	r21, 0x00	; 0
    4c00:	be 01       	movw	r22, r28
    4c02:	8f e2       	ldi	r24, 0x2F	; 47
    4c04:	92 e0       	ldi	r25, 0x02	; 2
    4c06:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <chIQReadTimeout>
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    4c0a:	61 e0       	ldi	r22, 0x01	; 1
    4c0c:	02 97       	sbiw	r24, 0x02	; 2
    4c0e:	09 f0       	breq	.+2      	; 0x4c12 <queues1_execute+0x1d8>
    4c10:	60 e0       	ldi	r22, 0x00	; 0
    4c12:	89 e0       	ldi	r24, 0x09	; 9
    4c14:	90 e0       	ldi	r25, 0x00	; 0
    4c16:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4c1a:	81 11       	cpse	r24, r1
    4c1c:	4d cf       	rjmp	.-358    	; 0x4ab8 <queues1_execute+0x7e>
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
    4c1e:	f8 94       	cli
    4c20:	61 e0       	ldi	r22, 0x01	; 1
    4c22:	80 91 33 02 	lds	r24, 0x0233
    4c26:	90 91 34 02 	lds	r25, 0x0234
    4c2a:	89 2b       	or	r24, r25
    4c2c:	09 f0       	breq	.+2      	; 0x4c30 <queues1_execute+0x1f6>
    4c2e:	60 e0       	ldi	r22, 0x00	; 0
    4c30:	8a e0       	ldi	r24, 0x0A	; 10
    4c32:	90 e0       	ldi	r25, 0x00	; 0
    4c34:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4c38:	78 94       	sei
    4c3a:	81 11       	cpse	r24, r1
    4c3c:	3d cf       	rjmp	.-390    	; 0x4ab8 <queues1_execute+0x7e>

  /* Testing reset */
  chSysLock();
    4c3e:	f8 94       	cli
  chIQPutI(&iq, 0);
    4c40:	60 e0       	ldi	r22, 0x00	; 0
    4c42:	8f e2       	ldi	r24, 0x2F	; 47
    4c44:	92 e0       	ldi	r25, 0x02	; 2
    4c46:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
  chIQResetI(&iq);
    4c4a:	8f e2       	ldi	r24, 0x2F	; 47
    4c4c:	92 e0       	ldi	r25, 0x02	; 2
    4c4e:	0e 94 dc 0c 	call	0x19b8	; 0x19b8 <chIQResetI>
  chSysUnlock();
    4c52:	78 94       	sei
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
    4c54:	f8 94       	cli
    4c56:	61 e0       	ldi	r22, 0x01	; 1
    4c58:	80 91 33 02 	lds	r24, 0x0233
    4c5c:	90 91 34 02 	lds	r25, 0x0234
    4c60:	89 2b       	or	r24, r25
    4c62:	09 f0       	breq	.+2      	; 0x4c66 <queues1_execute+0x22c>
    4c64:	60 e0       	ldi	r22, 0x00	; 0
    4c66:	8b e0       	ldi	r24, 0x0B	; 11
    4c68:	90 e0       	ldi	r25, 0x00	; 0
    4c6a:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4c6e:	78 94       	sei
    4c70:	81 11       	cpse	r24, r1
    4c72:	22 cf       	rjmp	.-444    	; 0x4ab8 <queues1_execute+0x7e>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread1, NULL);
    4c74:	e0 91 3c 0c 	lds	r30, 0x0C3C
    4c78:	f0 91 3d 0c 	lds	r31, 0x0C3D
    4c7c:	44 81       	ldd	r20, Z+4	; 0x04
    4c7e:	4f 5f       	subi	r20, 0xFF	; 255
    4c80:	00 e0       	ldi	r16, 0x00	; 0
    4c82:	10 e0       	ldi	r17, 0x00	; 0
    4c84:	20 eb       	ldi	r18, 0xB0	; 176
    4c86:	33 e2       	ldi	r19, 0x23	; 35
    4c88:	67 e9       	ldi	r22, 0x97	; 151
    4c8a:	70 e0       	ldi	r23, 0x00	; 0
    4c8c:	80 91 8d 02 	lds	r24, 0x028D
    4c90:	90 91 8e 02 	lds	r25, 0x028E
    4c94:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    4c98:	90 93 40 0c 	sts	0x0C40, r25
    4c9c:	80 93 3f 0c 	sts	0x0C3F, r24
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
    4ca0:	f8 94       	cli
    4ca2:	61 e0       	ldi	r22, 0x01	; 1
    4ca4:	80 91 33 02 	lds	r24, 0x0233
    4ca8:	90 91 34 02 	lds	r25, 0x0234
    4cac:	89 2b       	or	r24, r25
    4cae:	09 f0       	breq	.+2      	; 0x4cb2 <queues1_execute+0x278>
    4cb0:	60 e0       	ldi	r22, 0x00	; 0
    4cb2:	8c e0       	ldi	r24, 0x0C	; 12
    4cb4:	90 e0       	ldi	r25, 0x00	; 0
    4cb6:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <_test_assert>
    4cba:	78 94       	sei
    4cbc:	81 11       	cpse	r24, r1
    4cbe:	fc ce       	rjmp	.-520    	; 0x4ab8 <queues1_execute+0x7e>
  test_wait_threads();
    4cc0:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
    4cc4:	6a e0       	ldi	r22, 0x0A	; 10
    4cc6:	70 e0       	ldi	r23, 0x00	; 0
    4cc8:	8f e2       	ldi	r24, 0x2F	; 47
    4cca:	92 e0       	ldi	r25, 0x02	; 2
    4ccc:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <chIQGetTimeout>
    4cd0:	61 e0       	ldi	r22, 0x01	; 1
    4cd2:	01 96       	adiw	r24, 0x01	; 1
    4cd4:	09 f0       	breq	.+2      	; 0x4cd8 <queues1_execute+0x29e>
    4cd6:	60 e0       	ldi	r22, 0x00	; 0
    4cd8:	8d e0       	ldi	r24, 0x0D	; 13
    4cda:	90 e0       	ldi	r25, 0x00	; 0
}
    4cdc:	df 91       	pop	r29
    4cde:	cf 91       	pop	r28
    4ce0:	1f 91       	pop	r17
    4ce2:	0f 91       	pop	r16
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread1, NULL);
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
    4ce4:	0c 94 e9 0f 	jmp	0x1fd2	; 0x1fd2 <_test_assert>
  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
    4ce8:	61 e0       	ldi	r22, 0x01	; 1
    4cea:	80 91 33 02 	lds	r24, 0x0233
    4cee:	90 91 34 02 	lds	r25, 0x0234
    4cf2:	89 2b       	or	r24, r25
    4cf4:	09 f0       	breq	.+2      	; 0x4cf8 <queues1_execute+0x2be>
    4cf6:	d9 ce       	rjmp	.-590    	; 0x4aaa <queues1_execute+0x70>
    4cf8:	d7 ce       	rjmp	.-594    	; 0x4aa8 <queues1_execute+0x6e>

00004cfa <thread2>:
};

static msg_t thread2(void *p) {

  return (msg_t)p;
}
    4cfa:	08 95       	ret

00004cfc <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
    4cfc:	08 95       	ret

00004cfe <bmk13_execute>:
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {

  test_print("--- System: ");
    4cfe:	8a e2       	ldi	r24, 0x2A	; 42
    4d00:	98 e0       	ldi	r25, 0x08	; 8
    4d02:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(sizeof(ReadyList) + sizeof(VTList) +
    4d06:	6f ee       	ldi	r22, 0xEF	; 239
    4d08:	70 e0       	ldi	r23, 0x00	; 0
    4d0a:	80 e0       	ldi	r24, 0x00	; 0
    4d0c:	90 e0       	ldi	r25, 0x00	; 0
    4d0e:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
              PORT_IDLE_THREAD_STACK_SIZE +
              (sizeof(Thread) + sizeof(struct intctx) +
               sizeof(struct extctx) +
               PORT_INT_REQUIRED_STACK) * 2);
  test_println(" bytes");
    4d12:	87 e3       	ldi	r24, 0x37	; 55
    4d14:	98 e0       	ldi	r25, 0x08	; 8
    4d16:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
  test_print("--- Thread: ");
    4d1a:	8e e3       	ldi	r24, 0x3E	; 62
    4d1c:	98 e0       	ldi	r25, 0x08	; 8
    4d1e:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(sizeof(Thread));
    4d22:	60 e2       	ldi	r22, 0x20	; 32
    4d24:	70 e0       	ldi	r23, 0x00	; 0
    4d26:	80 e0       	ldi	r24, 0x00	; 0
    4d28:	90 e0       	ldi	r25, 0x00	; 0
    4d2a:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" bytes");
    4d2e:	87 e3       	ldi	r24, 0x37	; 55
    4d30:	98 e0       	ldi	r25, 0x08	; 8
    4d32:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
  test_print("--- Timer : ");
    4d36:	8b e4       	ldi	r24, 0x4B	; 75
    4d38:	98 e0       	ldi	r25, 0x08	; 8
    4d3a:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(sizeof(VirtualTimer));
    4d3e:	6a e0       	ldi	r22, 0x0A	; 10
    4d40:	70 e0       	ldi	r23, 0x00	; 0
    4d42:	80 e0       	ldi	r24, 0x00	; 0
    4d44:	90 e0       	ldi	r25, 0x00	; 0
    4d46:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" bytes");
    4d4a:	87 e3       	ldi	r24, 0x37	; 55
    4d4c:	98 e0       	ldi	r25, 0x08	; 8
    4d4e:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
  test_print("--- Semaph: ");
    4d52:	88 e5       	ldi	r24, 0x58	; 88
    4d54:	98 e0       	ldi	r25, 0x08	; 8
    4d56:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(sizeof(Semaphore));
    4d5a:	65 e0       	ldi	r22, 0x05	; 5
    4d5c:	70 e0       	ldi	r23, 0x00	; 0
    4d5e:	80 e0       	ldi	r24, 0x00	; 0
    4d60:	90 e0       	ldi	r25, 0x00	; 0
    4d62:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" bytes");
    4d66:	87 e3       	ldi	r24, 0x37	; 55
    4d68:	98 e0       	ldi	r25, 0x08	; 8
    4d6a:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
#if CH_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
    4d6e:	85 e6       	ldi	r24, 0x65	; 101
    4d70:	98 e0       	ldi	r25, 0x08	; 8
    4d72:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(sizeof(EventSource));
    4d76:	62 e0       	ldi	r22, 0x02	; 2
    4d78:	70 e0       	ldi	r23, 0x00	; 0
    4d7a:	80 e0       	ldi	r24, 0x00	; 0
    4d7c:	90 e0       	ldi	r25, 0x00	; 0
    4d7e:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" bytes");
    4d82:	87 e3       	ldi	r24, 0x37	; 55
    4d84:	98 e0       	ldi	r25, 0x08	; 8
    4d86:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
  test_print("--- EventL: ");
    4d8a:	82 e7       	ldi	r24, 0x72	; 114
    4d8c:	98 e0       	ldi	r25, 0x08	; 8
    4d8e:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(sizeof(EventListener));
    4d92:	66 e0       	ldi	r22, 0x06	; 6
    4d94:	70 e0       	ldi	r23, 0x00	; 0
    4d96:	80 e0       	ldi	r24, 0x00	; 0
    4d98:	90 e0       	ldi	r25, 0x00	; 0
    4d9a:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" bytes");
    4d9e:	87 e3       	ldi	r24, 0x37	; 55
    4da0:	98 e0       	ldi	r25, 0x08	; 8
    4da2:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
#endif
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
    4da6:	8f e7       	ldi	r24, 0x7F	; 127
    4da8:	98 e0       	ldi	r25, 0x08	; 8
    4daa:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(sizeof(Mutex));
    4dae:	68 e0       	ldi	r22, 0x08	; 8
    4db0:	70 e0       	ldi	r23, 0x00	; 0
    4db2:	80 e0       	ldi	r24, 0x00	; 0
    4db4:	90 e0       	ldi	r25, 0x00	; 0
    4db6:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" bytes");
    4dba:	87 e3       	ldi	r24, 0x37	; 55
    4dbc:	98 e0       	ldi	r25, 0x08	; 8
    4dbe:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
#endif
#if CH_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
    4dc2:	8c e8       	ldi	r24, 0x8C	; 140
    4dc4:	98 e0       	ldi	r25, 0x08	; 8
    4dc6:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(sizeof(CondVar));
    4dca:	64 e0       	ldi	r22, 0x04	; 4
    4dcc:	70 e0       	ldi	r23, 0x00	; 0
    4dce:	80 e0       	ldi	r24, 0x00	; 0
    4dd0:	90 e0       	ldi	r25, 0x00	; 0
    4dd2:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" bytes");
    4dd6:	87 e3       	ldi	r24, 0x37	; 55
    4dd8:	98 e0       	ldi	r25, 0x08	; 8
    4dda:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
#endif
#if CH_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
    4dde:	89 e9       	ldi	r24, 0x99	; 153
    4de0:	98 e0       	ldi	r25, 0x08	; 8
    4de2:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(sizeof(GenericQueue));
    4de6:	62 e1       	ldi	r22, 0x12	; 18
    4de8:	70 e0       	ldi	r23, 0x00	; 0
    4dea:	80 e0       	ldi	r24, 0x00	; 0
    4dec:	90 e0       	ldi	r25, 0x00	; 0
    4dee:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" bytes");
    4df2:	87 e3       	ldi	r24, 0x37	; 55
    4df4:	98 e0       	ldi	r25, 0x08	; 8
    4df6:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
#endif
#if CH_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
    4dfa:	86 ea       	ldi	r24, 0xA6	; 166
    4dfc:	98 e0       	ldi	r25, 0x08	; 8
    4dfe:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(sizeof(Mailbox));
    4e02:	62 e1       	ldi	r22, 0x12	; 18
    4e04:	70 e0       	ldi	r23, 0x00	; 0
    4e06:	80 e0       	ldi	r24, 0x00	; 0
    4e08:	90 e0       	ldi	r25, 0x00	; 0
    4e0a:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" bytes");
    4e0e:	87 e3       	ldi	r24, 0x37	; 55
    4e10:	98 e0       	ldi	r25, 0x08	; 8
    4e12:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

00004e16 <bmk12_execute>:
static void bmk12_setup(void) {

  chMtxInit(&mtx1);
}

static void bmk12_execute(void) {
    4e16:	cf 92       	push	r12
    4e18:	df 92       	push	r13
    4e1a:	ef 92       	push	r14
    4e1c:	ff 92       	push	r15
  uint32_t n = 0;

  test_wait_tick();
    4e1e:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  test_start_timer(1000);
    4e22:	88 ee       	ldi	r24, 0xE8	; 232
    4e24:	93 e0       	ldi	r25, 0x03	; 3
    4e26:	0e 94 8b 10 	call	0x2116	; 0x2116 <test_start_timer>

  chMtxInit(&mtx1);
}

static void bmk12_execute(void) {
  uint32_t n = 0;
    4e2a:	c1 2c       	mov	r12, r1
    4e2c:	d1 2c       	mov	r13, r1
    4e2e:	76 01       	movw	r14, r12

  test_wait_tick();
  test_start_timer(1000);
  do {
    chMtxLock(&mtx1);
    4e30:	8b e2       	ldi	r24, 0x2B	; 43
    4e32:	9b e0       	ldi	r25, 0x0B	; 11
    4e34:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
    chMtxUnlock();
    4e38:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
    chMtxLock(&mtx1);
    4e3c:	8b e2       	ldi	r24, 0x2B	; 43
    4e3e:	9b e0       	ldi	r25, 0x0B	; 11
    4e40:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
    chMtxUnlock();
    4e44:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
    chMtxLock(&mtx1);
    4e48:	8b e2       	ldi	r24, 0x2B	; 43
    4e4a:	9b e0       	ldi	r25, 0x0B	; 11
    4e4c:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
    chMtxUnlock();
    4e50:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
    chMtxLock(&mtx1);
    4e54:	8b e2       	ldi	r24, 0x2B	; 43
    4e56:	9b e0       	ldi	r25, 0x0B	; 11
    4e58:	0e 94 4e 07 	call	0xe9c	; 0xe9c <chMtxLock>
    chMtxUnlock();
    4e5c:	0e 94 8c 07 	call	0xf18	; 0xf18 <chMtxUnlock>
    n++;
    4e60:	8f ef       	ldi	r24, 0xFF	; 255
    4e62:	c8 1a       	sub	r12, r24
    4e64:	d8 0a       	sbc	r13, r24
    4e66:	e8 0a       	sbc	r14, r24
    4e68:	f8 0a       	sbc	r15, r24
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    4e6a:	80 91 3e 0c 	lds	r24, 0x0C3E
    4e6e:	88 23       	and	r24, r24
    4e70:	f9 f2       	breq	.-66     	; 0x4e30 <bmk12_execute+0x1a>
  test_print("--- Score : ");
    4e72:	83 eb       	ldi	r24, 0xB3	; 179
    4e74:	98 e0       	ldi	r25, 0x08	; 8
    4e76:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n * 4);
    4e7a:	c7 01       	movw	r24, r14
    4e7c:	b6 01       	movw	r22, r12
    4e7e:	66 0f       	add	r22, r22
    4e80:	77 1f       	adc	r23, r23
    4e82:	88 1f       	adc	r24, r24
    4e84:	99 1f       	adc	r25, r25
    4e86:	66 0f       	add	r22, r22
    4e88:	77 1f       	adc	r23, r23
    4e8a:	88 1f       	adc	r24, r24
    4e8c:	99 1f       	adc	r25, r25
    4e8e:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" lock+unlock/S");
    4e92:	80 ec       	ldi	r24, 0xC0	; 192
    4e94:	98 e0       	ldi	r25, 0x08	; 8
}
    4e96:	ff 90       	pop	r15
    4e98:	ef 90       	pop	r14
    4e9a:	df 90       	pop	r13
    4e9c:	cf 90       	pop	r12
    ChkIntSources();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" lock+unlock/S");
    4e9e:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

00004ea2 <bmk12_setup>:
 * a second of continuous operations.
 */

static void bmk12_setup(void) {

  chMtxInit(&mtx1);
    4ea2:	8b e2       	ldi	r24, 0x2B	; 43
    4ea4:	9b e0       	ldi	r25, 0x0B	; 11
    4ea6:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <chMtxInit>

00004eaa <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static msg_t thread3(void *p) {
    4eaa:	04 c0       	rjmp	.+8      	; 0x4eb4 <thread3+0xa>

  (void)p;
  while (!chThdShouldTerminate())
    chSemWait(&sem1);
    4eac:	80 ef       	ldi	r24, 0xF0	; 240
    4eae:	9a e0       	ldi	r25, 0x0A	; 10
    4eb0:	0e 94 9c 05 	call	0xb38	; 0xb38 <chSemWait>
 */

static msg_t thread3(void *p) {

  (void)p;
  while (!chThdShouldTerminate())
    4eb4:	e0 91 3c 0c 	lds	r30, 0x0C3C
    4eb8:	f0 91 3d 0c 	lds	r31, 0x0C3D
    4ebc:	86 85       	ldd	r24, Z+14	; 0x0e
    4ebe:	82 ff       	sbrs	r24, 2
    4ec0:	f5 cf       	rjmp	.-22     	; 0x4eac <thread3+0x2>
    chSemWait(&sem1);
  return 0;
}
    4ec2:	80 e0       	ldi	r24, 0x00	; 0
    4ec4:	90 e0       	ldi	r25, 0x00	; 0
    4ec6:	08 95       	ret

00004ec8 <bmk11_execute>:
static void bmk11_setup(void) {

  chSemInit(&sem1, 1);
}

static void bmk11_execute(void) {
    4ec8:	cf 92       	push	r12
    4eca:	df 92       	push	r13
    4ecc:	ef 92       	push	r14
    4ece:	ff 92       	push	r15
  uint32_t n = 0;

  test_wait_tick();
    4ed0:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  test_start_timer(1000);
    4ed4:	88 ee       	ldi	r24, 0xE8	; 232
    4ed6:	93 e0       	ldi	r25, 0x03	; 3
    4ed8:	0e 94 8b 10 	call	0x2116	; 0x2116 <test_start_timer>

  chSemInit(&sem1, 1);
}

static void bmk11_execute(void) {
  uint32_t n = 0;
    4edc:	c1 2c       	mov	r12, r1
    4ede:	d1 2c       	mov	r13, r1
    4ee0:	76 01       	movw	r14, r12

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemWait(&sem1);
    4ee2:	80 ef       	ldi	r24, 0xF0	; 240
    4ee4:	9a e0       	ldi	r25, 0x0A	; 10
    4ee6:	0e 94 9c 05 	call	0xb38	; 0xb38 <chSemWait>
    chSemSignal(&sem1);
    4eea:	80 ef       	ldi	r24, 0xF0	; 240
    4eec:	9a e0       	ldi	r25, 0x0A	; 10
    4eee:	0e 94 d6 05 	call	0xbac	; 0xbac <chSemSignal>
    chSemWait(&sem1);
    4ef2:	80 ef       	ldi	r24, 0xF0	; 240
    4ef4:	9a e0       	ldi	r25, 0x0A	; 10
    4ef6:	0e 94 9c 05 	call	0xb38	; 0xb38 <chSemWait>
    chSemSignal(&sem1);
    4efa:	80 ef       	ldi	r24, 0xF0	; 240
    4efc:	9a e0       	ldi	r25, 0x0A	; 10
    4efe:	0e 94 d6 05 	call	0xbac	; 0xbac <chSemSignal>
    chSemWait(&sem1);
    4f02:	80 ef       	ldi	r24, 0xF0	; 240
    4f04:	9a e0       	ldi	r25, 0x0A	; 10
    4f06:	0e 94 9c 05 	call	0xb38	; 0xb38 <chSemWait>
    chSemSignal(&sem1);
    4f0a:	80 ef       	ldi	r24, 0xF0	; 240
    4f0c:	9a e0       	ldi	r25, 0x0A	; 10
    4f0e:	0e 94 d6 05 	call	0xbac	; 0xbac <chSemSignal>
    chSemWait(&sem1);
    4f12:	80 ef       	ldi	r24, 0xF0	; 240
    4f14:	9a e0       	ldi	r25, 0x0A	; 10
    4f16:	0e 94 9c 05 	call	0xb38	; 0xb38 <chSemWait>
    chSemSignal(&sem1);
    4f1a:	80 ef       	ldi	r24, 0xF0	; 240
    4f1c:	9a e0       	ldi	r25, 0x0A	; 10
    4f1e:	0e 94 d6 05 	call	0xbac	; 0xbac <chSemSignal>
    n++;
    4f22:	8f ef       	ldi	r24, 0xFF	; 255
    4f24:	c8 1a       	sub	r12, r24
    4f26:	d8 0a       	sbc	r13, r24
    4f28:	e8 0a       	sbc	r14, r24
    4f2a:	f8 0a       	sbc	r15, r24
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    4f2c:	80 91 3e 0c 	lds	r24, 0x0C3E
    4f30:	88 23       	and	r24, r24
    4f32:	b9 f2       	breq	.-82     	; 0x4ee2 <bmk11_execute+0x1a>
  test_print("--- Score : ");
    4f34:	83 eb       	ldi	r24, 0xB3	; 179
    4f36:	98 e0       	ldi	r25, 0x08	; 8
    4f38:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n * 4);
    4f3c:	c7 01       	movw	r24, r14
    4f3e:	b6 01       	movw	r22, r12
    4f40:	66 0f       	add	r22, r22
    4f42:	77 1f       	adc	r23, r23
    4f44:	88 1f       	adc	r24, r24
    4f46:	99 1f       	adc	r25, r25
    4f48:	66 0f       	add	r22, r22
    4f4a:	77 1f       	adc	r23, r23
    4f4c:	88 1f       	adc	r24, r24
    4f4e:	99 1f       	adc	r25, r25
    4f50:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" wait+signal/S");
    4f54:	8f ec       	ldi	r24, 0xCF	; 207
    4f56:	98 e0       	ldi	r25, 0x08	; 8
}
    4f58:	ff 90       	pop	r15
    4f5a:	ef 90       	pop	r14
    4f5c:	df 90       	pop	r13
    4f5e:	cf 90       	pop	r12
    ChkIntSources();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" wait+signal/S");
    4f60:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

00004f64 <bmk11_setup>:
 * a second of continuous operations.
 */

static void bmk11_setup(void) {

  chSemInit(&sem1, 1);
    4f64:	61 e0       	ldi	r22, 0x01	; 1
    4f66:	80 ef       	ldi	r24, 0xF0	; 240
    4f68:	9a e0       	ldi	r25, 0x0A	; 10
    4f6a:	0c 94 37 05 	jmp	0xa6e	; 0xa6e <chSemInit>

00004f6e <bmk7_setup>:
  return 0;
}

static void bmk7_setup(void) {

  chSemInit(&sem1, 0);
    4f6e:	60 e0       	ldi	r22, 0x00	; 0
    4f70:	80 ef       	ldi	r24, 0xF0	; 240
    4f72:	9a e0       	ldi	r25, 0x0A	; 10
    4f74:	0c 94 37 05 	jmp	0xa6e	; 0xa6e <chSemInit>

00004f78 <bmk10_execute>:
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
    4f78:	cf 92       	push	r12
    4f7a:	df 92       	push	r13
    4f7c:	ef 92       	push	r14
    4f7e:	ff 92       	push	r15
  static VirtualTimer vt1, vt2;
  uint32_t n = 0;

  test_wait_tick();
    4f80:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  test_start_timer(1000);
    4f84:	88 ee       	ldi	r24, 0xE8	; 232
    4f86:	93 e0       	ldi	r25, 0x03	; 3
    4f88:	0e 94 8b 10 	call	0x2116	; 0x2116 <test_start_timer>

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
  static VirtualTimer vt1, vt2;
  uint32_t n = 0;
    4f8c:	c1 2c       	mov	r12, r1
    4f8e:	d1 2c       	mov	r13, r1
    4f90:	76 01       	movw	r14, r12

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    4f92:	f8 94       	cli
    chVTSetI(&vt1, 1, tmo, NULL);
    4f94:	20 e0       	ldi	r18, 0x00	; 0
    4f96:	30 e0       	ldi	r19, 0x00	; 0
    4f98:	4e e7       	ldi	r20, 0x7E	; 126
    4f9a:	56 e2       	ldi	r21, 0x26	; 38
    4f9c:	61 e0       	ldi	r22, 0x01	; 1
    4f9e:	70 e0       	ldi	r23, 0x00	; 0
    4fa0:	87 e1       	ldi	r24, 0x17	; 23
    4fa2:	9b e0       	ldi	r25, 0x0B	; 11
    4fa4:	0e 94 a3 01 	call	0x346	; 0x346 <chVTSetI>
    chVTSetI(&vt2, 10000, tmo, NULL);
    4fa8:	20 e0       	ldi	r18, 0x00	; 0
    4faa:	30 e0       	ldi	r19, 0x00	; 0
    4fac:	4e e7       	ldi	r20, 0x7E	; 126
    4fae:	56 e2       	ldi	r21, 0x26	; 38
    4fb0:	60 e1       	ldi	r22, 0x10	; 16
    4fb2:	77 e2       	ldi	r23, 0x27	; 39
    4fb4:	81 e2       	ldi	r24, 0x21	; 33
    4fb6:	9b e0       	ldi	r25, 0x0B	; 11
    4fb8:	0e 94 a3 01 	call	0x346	; 0x346 <chVTSetI>
    chVTResetI(&vt1);
    4fbc:	87 e1       	ldi	r24, 0x17	; 23
    4fbe:	9b e0       	ldi	r25, 0x0B	; 11
    4fc0:	0e 94 df 01 	call	0x3be	; 0x3be <chVTResetI>
    chVTResetI(&vt2);
    4fc4:	81 e2       	ldi	r24, 0x21	; 33
    4fc6:	9b e0       	ldi	r25, 0x0B	; 11
    4fc8:	0e 94 df 01 	call	0x3be	; 0x3be <chVTResetI>
    chSysUnlock();
    4fcc:	78 94       	sei
    n++;
    4fce:	8f ef       	ldi	r24, 0xFF	; 255
    4fd0:	c8 1a       	sub	r12, r24
    4fd2:	d8 0a       	sbc	r13, r24
    4fd4:	e8 0a       	sbc	r14, r24
    4fd6:	f8 0a       	sbc	r15, r24
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    4fd8:	80 91 3e 0c 	lds	r24, 0x0C3E
    4fdc:	88 23       	and	r24, r24
    4fde:	c9 f2       	breq	.-78     	; 0x4f92 <bmk10_execute+0x1a>
  test_print("--- Score : ");
    4fe0:	83 eb       	ldi	r24, 0xB3	; 179
    4fe2:	98 e0       	ldi	r25, 0x08	; 8
    4fe4:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n * 2);
    4fe8:	c7 01       	movw	r24, r14
    4fea:	b6 01       	movw	r22, r12
    4fec:	66 0f       	add	r22, r22
    4fee:	77 1f       	adc	r23, r23
    4ff0:	88 1f       	adc	r24, r24
    4ff2:	99 1f       	adc	r25, r25
    4ff4:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" timers/S");
    4ff8:	8e ed       	ldi	r24, 0xDE	; 222
    4ffa:	98 e0       	ldi	r25, 0x08	; 8
}
    4ffc:	ff 90       	pop	r15
    4ffe:	ef 90       	pop	r14
    5000:	df 90       	pop	r13
    5002:	cf 90       	pop	r12
    ChkIntSources();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 2);
  test_println(" timers/S");
    5004:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

00005008 <bmk9_execute>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
    5008:	cf 92       	push	r12
    500a:	df 92       	push	r13
    500c:	ef 92       	push	r14
    500e:	ff 92       	push	r15
    5010:	0f 93       	push	r16
    5012:	1f 93       	push	r17
  uint32_t n;
  static uint8_t ib[16];
  static InputQueue iq;

  chIQInit(&iq, ib, sizeof(ib), NULL, NULL);
    5014:	00 e0       	ldi	r16, 0x00	; 0
    5016:	10 e0       	ldi	r17, 0x00	; 0
    5018:	20 e0       	ldi	r18, 0x00	; 0
    501a:	30 e0       	ldi	r19, 0x00	; 0
    501c:	40 e1       	ldi	r20, 0x10	; 16
    501e:	50 e0       	ldi	r21, 0x00	; 0
    5020:	67 e0       	ldi	r22, 0x07	; 7
    5022:	7b e0       	ldi	r23, 0x0B	; 11
    5024:	85 ef       	ldi	r24, 0xF5	; 245
    5026:	9a e0       	ldi	r25, 0x0A	; 10
    5028:	0e 94 c2 0c 	call	0x1984	; 0x1984 <chIQInit>
  n = 0;
  test_wait_tick();
    502c:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  test_start_timer(1000);
    5030:	88 ee       	ldi	r24, 0xE8	; 232
    5032:	93 e0       	ldi	r25, 0x03	; 3
    5034:	0e 94 8b 10 	call	0x2116	; 0x2116 <test_start_timer>
  uint32_t n;
  static uint8_t ib[16];
  static InputQueue iq;

  chIQInit(&iq, ib, sizeof(ib), NULL, NULL);
  n = 0;
    5038:	c1 2c       	mov	r12, r1
    503a:	d1 2c       	mov	r13, r1
    503c:	76 01       	movw	r14, r12
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    503e:	f8 94       	cli
    chIQPutI(&iq, 0);
    5040:	60 e0       	ldi	r22, 0x00	; 0
    5042:	85 ef       	ldi	r24, 0xF5	; 245
    5044:	9a e0       	ldi	r25, 0x0A	; 10
    5046:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    chIQPutI(&iq, 1);
    504a:	61 e0       	ldi	r22, 0x01	; 1
    504c:	85 ef       	ldi	r24, 0xF5	; 245
    504e:	9a e0       	ldi	r25, 0x0A	; 10
    5050:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    chIQPutI(&iq, 2);
    5054:	62 e0       	ldi	r22, 0x02	; 2
    5056:	85 ef       	ldi	r24, 0xF5	; 245
    5058:	9a e0       	ldi	r25, 0x0A	; 10
    505a:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    chIQPutI(&iq, 3);
    505e:	63 e0       	ldi	r22, 0x03	; 3
    5060:	85 ef       	ldi	r24, 0xF5	; 245
    5062:	9a e0       	ldi	r25, 0x0A	; 10
    5064:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    chSysUnlock();
    5068:	78 94       	sei
    (void)chIQGet(&iq);
    506a:	6f ef       	ldi	r22, 0xFF	; 255
    506c:	7f ef       	ldi	r23, 0xFF	; 255
    506e:	85 ef       	ldi	r24, 0xF5	; 245
    5070:	9a e0       	ldi	r25, 0x0A	; 10
    5072:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <chIQGetTimeout>
    (void)chIQGet(&iq);
    5076:	6f ef       	ldi	r22, 0xFF	; 255
    5078:	7f ef       	ldi	r23, 0xFF	; 255
    507a:	85 ef       	ldi	r24, 0xF5	; 245
    507c:	9a e0       	ldi	r25, 0x0A	; 10
    507e:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <chIQGetTimeout>
    (void)chIQGet(&iq);
    5082:	6f ef       	ldi	r22, 0xFF	; 255
    5084:	7f ef       	ldi	r23, 0xFF	; 255
    5086:	85 ef       	ldi	r24, 0xF5	; 245
    5088:	9a e0       	ldi	r25, 0x0A	; 10
    508a:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <chIQGetTimeout>
    (void)chIQGet(&iq);
    508e:	6f ef       	ldi	r22, 0xFF	; 255
    5090:	7f ef       	ldi	r23, 0xFF	; 255
    5092:	85 ef       	ldi	r24, 0xF5	; 245
    5094:	9a e0       	ldi	r25, 0x0A	; 10
    5096:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <chIQGetTimeout>
    n++;
    509a:	8f ef       	ldi	r24, 0xFF	; 255
    509c:	c8 1a       	sub	r12, r24
    509e:	d8 0a       	sbc	r13, r24
    50a0:	e8 0a       	sbc	r14, r24
    50a2:	f8 0a       	sbc	r15, r24
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    50a4:	80 91 3e 0c 	lds	r24, 0x0C3E
    50a8:	88 23       	and	r24, r24
    50aa:	49 f2       	breq	.-110    	; 0x503e <bmk9_execute+0x36>
  test_print("--- Score : ");
    50ac:	83 eb       	ldi	r24, 0xB3	; 179
    50ae:	98 e0       	ldi	r25, 0x08	; 8
    50b0:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n * 4);
    50b4:	c7 01       	movw	r24, r14
    50b6:	b6 01       	movw	r22, r12
    50b8:	66 0f       	add	r22, r22
    50ba:	77 1f       	adc	r23, r23
    50bc:	88 1f       	adc	r24, r24
    50be:	99 1f       	adc	r25, r25
    50c0:	66 0f       	add	r22, r22
    50c2:	77 1f       	adc	r23, r23
    50c4:	88 1f       	adc	r24, r24
    50c6:	99 1f       	adc	r25, r25
    50c8:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" bytes/S");
    50cc:	88 ee       	ldi	r24, 0xE8	; 232
    50ce:	98 e0       	ldi	r25, 0x08	; 8
}
    50d0:	1f 91       	pop	r17
    50d2:	0f 91       	pop	r16
    50d4:	ff 90       	pop	r15
    50d6:	ef 90       	pop	r14
    50d8:	df 90       	pop	r13
    50da:	cf 90       	pop	r12
    ChkIntSources();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" bytes/S");
    50dc:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

000050e0 <bmk6_execute>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
    50e0:	bf 92       	push	r11
    50e2:	cf 92       	push	r12
    50e4:	df 92       	push	r13
    50e6:	ef 92       	push	r14
    50e8:	ff 92       	push	r15
    50ea:	0f 93       	push	r16
    50ec:	1f 93       	push	r17
    50ee:	cf 93       	push	r28
    50f0:	df 93       	push	r29

  uint32_t n = 0;
  void *wap = wa[0];
    50f2:	c0 91 8d 02 	lds	r28, 0x028D
    50f6:	d0 91 8e 02 	lds	r29, 0x028E
  tprio_t prio = chThdGetPriority() + 1;
    50fa:	e0 91 3c 0c 	lds	r30, 0x0C3C
    50fe:	f0 91 3d 0c 	lds	r31, 0x0C3D
    5102:	b4 80       	ldd	r11, Z+4	; 0x04
    5104:	b3 94       	inc	r11
  test_wait_tick();
    5106:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  test_start_timer(1000);
    510a:	88 ee       	ldi	r24, 0xE8	; 232
    510c:	93 e0       	ldi	r25, 0x03	; 3
    510e:	0e 94 8b 10 	call	0x2116	; 0x2116 <test_start_timer>
 * a second of continuous operations.
 */

static void bmk6_execute(void) {

  uint32_t n = 0;
    5112:	c1 2c       	mov	r12, r1
    5114:	d1 2c       	mov	r13, r1
    5116:	76 01       	movw	r14, r12
  void *wap = wa[0];
  tprio_t prio = chThdGetPriority() + 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread2, NULL);
    5118:	00 e0       	ldi	r16, 0x00	; 0
    511a:	10 e0       	ldi	r17, 0x00	; 0
    511c:	2d e7       	ldi	r18, 0x7D	; 125
    511e:	36 e2       	ldi	r19, 0x26	; 38
    5120:	4b 2d       	mov	r20, r11
    5122:	67 e9       	ldi	r22, 0x97	; 151
    5124:	70 e0       	ldi	r23, 0x00	; 0
    5126:	ce 01       	movw	r24, r28
    5128:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    n++;
    512c:	8f ef       	ldi	r24, 0xFF	; 255
    512e:	c8 1a       	sub	r12, r24
    5130:	d8 0a       	sbc	r13, r24
    5132:	e8 0a       	sbc	r14, r24
    5134:	f8 0a       	sbc	r15, r24
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    5136:	80 91 3e 0c 	lds	r24, 0x0C3E
    513a:	88 23       	and	r24, r24
    513c:	69 f3       	breq	.-38     	; 0x5118 <bmk6_execute+0x38>
  test_print("--- Score : ");
    513e:	83 eb       	ldi	r24, 0xB3	; 179
    5140:	98 e0       	ldi	r25, 0x08	; 8
    5142:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n);
    5146:	c7 01       	movw	r24, r14
    5148:	b6 01       	movw	r22, r12
    514a:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" threads/S");
    514e:	81 ef       	ldi	r24, 0xF1	; 241
    5150:	98 e0       	ldi	r25, 0x08	; 8
}
    5152:	df 91       	pop	r29
    5154:	cf 91       	pop	r28
    5156:	1f 91       	pop	r17
    5158:	0f 91       	pop	r16
    515a:	ff 90       	pop	r15
    515c:	ef 90       	pop	r14
    515e:	df 90       	pop	r13
    5160:	cf 90       	pop	r12
    5162:	bf 90       	pop	r11
    ChkIntSources();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n);
  test_println(" threads/S");
    5164:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

00005168 <bmk8_execute>:
#endif
  } while(!chThdShouldTerminate());
  return 0;
}

static void bmk8_execute(void) {
    5168:	0f 93       	push	r16
    516a:	1f 93       	push	r17
    516c:	cf 93       	push	r28
    516e:	df 93       	push	r29
    5170:	00 d0       	rcall	.+0      	; 0x5172 <bmk8_execute+0xa>
    5172:	00 d0       	rcall	.+0      	; 0x5174 <bmk8_execute+0xc>
    5174:	cd b7       	in	r28, 0x3d	; 61
    5176:	de b7       	in	r29, 0x3e	; 62
  uint32_t n;

  n = 0;
    5178:	19 82       	std	Y+1, r1	; 0x01
    517a:	1a 82       	std	Y+2, r1	; 0x02
    517c:	1b 82       	std	Y+3, r1	; 0x03
    517e:	1c 82       	std	Y+4, r1	; 0x04
  test_wait_tick();
    5180:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-1, thread8, (void *)&n);
    5184:	e0 91 3c 0c 	lds	r30, 0x0C3C
    5188:	f0 91 3d 0c 	lds	r31, 0x0C3D
    518c:	44 81       	ldd	r20, Z+4	; 0x04
    518e:	41 50       	subi	r20, 0x01	; 1
    5190:	8e 01       	movw	r16, r28
    5192:	0f 5f       	subi	r16, 0xFF	; 255
    5194:	1f 4f       	sbci	r17, 0xFF	; 255
    5196:	24 e5       	ldi	r18, 0x54	; 84
    5198:	39 e2       	ldi	r19, 0x29	; 41
    519a:	67 e9       	ldi	r22, 0x97	; 151
    519c:	70 e0       	ldi	r23, 0x00	; 0
    519e:	80 91 8d 02 	lds	r24, 0x028D
    51a2:	90 91 8e 02 	lds	r25, 0x028E
    51a6:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    51aa:	90 93 40 0c 	sts	0x0C40, r25
    51ae:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-1, thread8, (void *)&n);
    51b2:	e0 91 3c 0c 	lds	r30, 0x0C3C
    51b6:	f0 91 3d 0c 	lds	r31, 0x0C3D
    51ba:	44 81       	ldd	r20, Z+4	; 0x04
    51bc:	41 50       	subi	r20, 0x01	; 1
    51be:	8e 01       	movw	r16, r28
    51c0:	0f 5f       	subi	r16, 0xFF	; 255
    51c2:	1f 4f       	sbci	r17, 0xFF	; 255
    51c4:	24 e5       	ldi	r18, 0x54	; 84
    51c6:	39 e2       	ldi	r19, 0x29	; 41
    51c8:	67 e9       	ldi	r22, 0x97	; 151
    51ca:	70 e0       	ldi	r23, 0x00	; 0
    51cc:	80 91 8f 02 	lds	r24, 0x028F
    51d0:	90 91 90 02 	lds	r25, 0x0290
    51d4:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    51d8:	90 93 42 0c 	sts	0x0C42, r25
    51dc:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-1, thread8, (void *)&n);
    51e0:	e0 91 3c 0c 	lds	r30, 0x0C3C
    51e4:	f0 91 3d 0c 	lds	r31, 0x0C3D
    51e8:	44 81       	ldd	r20, Z+4	; 0x04
    51ea:	41 50       	subi	r20, 0x01	; 1
    51ec:	8e 01       	movw	r16, r28
    51ee:	0f 5f       	subi	r16, 0xFF	; 255
    51f0:	1f 4f       	sbci	r17, 0xFF	; 255
    51f2:	24 e5       	ldi	r18, 0x54	; 84
    51f4:	39 e2       	ldi	r19, 0x29	; 41
    51f6:	67 e9       	ldi	r22, 0x97	; 151
    51f8:	70 e0       	ldi	r23, 0x00	; 0
    51fa:	80 91 91 02 	lds	r24, 0x0291
    51fe:	90 91 92 02 	lds	r25, 0x0292
    5202:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    5206:	90 93 44 0c 	sts	0x0C44, r25
    520a:	80 93 43 0c 	sts	0x0C43, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-1, thread8, (void *)&n);
    520e:	e0 91 3c 0c 	lds	r30, 0x0C3C
    5212:	f0 91 3d 0c 	lds	r31, 0x0C3D
    5216:	44 81       	ldd	r20, Z+4	; 0x04
    5218:	41 50       	subi	r20, 0x01	; 1
    521a:	8e 01       	movw	r16, r28
    521c:	0f 5f       	subi	r16, 0xFF	; 255
    521e:	1f 4f       	sbci	r17, 0xFF	; 255
    5220:	24 e5       	ldi	r18, 0x54	; 84
    5222:	39 e2       	ldi	r19, 0x29	; 41
    5224:	67 e9       	ldi	r22, 0x97	; 151
    5226:	70 e0       	ldi	r23, 0x00	; 0
    5228:	80 91 93 02 	lds	r24, 0x0293
    522c:	90 91 94 02 	lds	r25, 0x0294
    5230:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    5234:	90 93 46 0c 	sts	0x0C46, r25
    5238:	80 93 45 0c 	sts	0x0C45, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-1, thread8, (void *)&n);
    523c:	e0 91 3c 0c 	lds	r30, 0x0C3C
    5240:	f0 91 3d 0c 	lds	r31, 0x0C3D
    5244:	44 81       	ldd	r20, Z+4	; 0x04
    5246:	41 50       	subi	r20, 0x01	; 1
    5248:	8e 01       	movw	r16, r28
    524a:	0f 5f       	subi	r16, 0xFF	; 255
    524c:	1f 4f       	sbci	r17, 0xFF	; 255
    524e:	24 e5       	ldi	r18, 0x54	; 84
    5250:	39 e2       	ldi	r19, 0x29	; 41
    5252:	67 e9       	ldi	r22, 0x97	; 151
    5254:	70 e0       	ldi	r23, 0x00	; 0
    5256:	80 91 95 02 	lds	r24, 0x0295
    525a:	90 91 96 02 	lds	r25, 0x0296
    525e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    5262:	90 93 48 0c 	sts	0x0C48, r25
    5266:	80 93 47 0c 	sts	0x0C47, r24

  chThdSleepSeconds(1);
    526a:	88 ee       	ldi	r24, 0xE8	; 232
    526c:	93 e0       	ldi	r25, 0x03	; 3
    526e:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
  test_terminate_threads();
    5272:	0e 94 39 10 	call	0x2072	; 0x2072 <test_terminate_threads>
  test_wait_threads();
    5276:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>

  test_print("--- Score : ");
    527a:	83 eb       	ldi	r24, 0xB3	; 179
    527c:	98 e0       	ldi	r25, 0x08	; 8
    527e:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n);
    5282:	69 81       	ldd	r22, Y+1	; 0x01
    5284:	7a 81       	ldd	r23, Y+2	; 0x02
    5286:	8b 81       	ldd	r24, Y+3	; 0x03
    5288:	9c 81       	ldd	r25, Y+4	; 0x04
    528a:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" ctxswc/S");
    528e:	8c ef       	ldi	r24, 0xFC	; 252
    5290:	98 e0       	ldi	r25, 0x08	; 8
    5292:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <test_println>
}
    5296:	0f 90       	pop	r0
    5298:	0f 90       	pop	r0
    529a:	0f 90       	pop	r0
    529c:	0f 90       	pop	r0
    529e:	df 91       	pop	r29
    52a0:	cf 91       	pop	r28
    52a2:	1f 91       	pop	r17
    52a4:	0f 91       	pop	r16
    52a6:	08 95       	ret

000052a8 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static msg_t thread8(void *p) {
    52a8:	cf 93       	push	r28
    52aa:	df 93       	push	r29
    52ac:	ec 01       	movw	r28, r24

  do {
    chThdYield();
    52ae:	0e 94 bf 04 	call	0x97e	; 0x97e <chThdYield>
    chThdYield();
    52b2:	0e 94 bf 04 	call	0x97e	; 0x97e <chThdYield>
    chThdYield();
    52b6:	0e 94 bf 04 	call	0x97e	; 0x97e <chThdYield>
    chThdYield();
    52ba:	0e 94 bf 04 	call	0x97e	; 0x97e <chThdYield>
    (*(uint32_t *)p) += 4;
    52be:	48 81       	ld	r20, Y
    52c0:	59 81       	ldd	r21, Y+1	; 0x01
    52c2:	6a 81       	ldd	r22, Y+2	; 0x02
    52c4:	7b 81       	ldd	r23, Y+3	; 0x03
    52c6:	4c 5f       	subi	r20, 0xFC	; 252
    52c8:	5f 4f       	sbci	r21, 0xFF	; 255
    52ca:	6f 4f       	sbci	r22, 0xFF	; 255
    52cc:	7f 4f       	sbci	r23, 0xFF	; 255
    52ce:	48 83       	st	Y, r20
    52d0:	59 83       	std	Y+1, r21	; 0x01
    52d2:	6a 83       	std	Y+2, r22	; 0x02
    52d4:	7b 83       	std	Y+3, r23	; 0x03
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while(!chThdShouldTerminate());
    52d6:	e0 91 3c 0c 	lds	r30, 0x0C3C
    52da:	f0 91 3d 0c 	lds	r31, 0x0C3D
    52de:	86 85       	ldd	r24, Z+14	; 0x0e
    52e0:	82 ff       	sbrs	r24, 2
    52e2:	e5 cf       	rjmp	.-54     	; 0x52ae <thread8+0x6>
  return 0;
}
    52e4:	80 e0       	ldi	r24, 0x00	; 0
    52e6:	90 e0       	ldi	r25, 0x00	; 0
    52e8:	df 91       	pop	r29
    52ea:	cf 91       	pop	r28
    52ec:	08 95       	ret

000052ee <bmk7_execute>:
static void bmk7_setup(void) {

  chSemInit(&sem1, 0);
}

static void bmk7_execute(void) {
    52ee:	cf 92       	push	r12
    52f0:	df 92       	push	r13
    52f2:	ef 92       	push	r14
    52f4:	ff 92       	push	r15
    52f6:	0f 93       	push	r16
    52f8:	1f 93       	push	r17
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+5, thread3, NULL);
    52fa:	e0 91 3c 0c 	lds	r30, 0x0C3C
    52fe:	f0 91 3d 0c 	lds	r31, 0x0C3D
    5302:	44 81       	ldd	r20, Z+4	; 0x04
    5304:	4b 5f       	subi	r20, 0xFB	; 251
    5306:	00 e0       	ldi	r16, 0x00	; 0
    5308:	10 e0       	ldi	r17, 0x00	; 0
    530a:	25 e5       	ldi	r18, 0x55	; 85
    530c:	37 e2       	ldi	r19, 0x27	; 39
    530e:	67 e9       	ldi	r22, 0x97	; 151
    5310:	70 e0       	ldi	r23, 0x00	; 0
    5312:	80 91 8d 02 	lds	r24, 0x028D
    5316:	90 91 8e 02 	lds	r25, 0x028E
    531a:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    531e:	90 93 40 0c 	sts	0x0C40, r25
    5322:	80 93 3f 0c 	sts	0x0C3F, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()+4, thread3, NULL);
    5326:	e0 91 3c 0c 	lds	r30, 0x0C3C
    532a:	f0 91 3d 0c 	lds	r31, 0x0C3D
    532e:	44 81       	ldd	r20, Z+4	; 0x04
    5330:	4c 5f       	subi	r20, 0xFC	; 252
    5332:	25 e5       	ldi	r18, 0x55	; 85
    5334:	37 e2       	ldi	r19, 0x27	; 39
    5336:	67 e9       	ldi	r22, 0x97	; 151
    5338:	70 e0       	ldi	r23, 0x00	; 0
    533a:	80 91 8f 02 	lds	r24, 0x028F
    533e:	90 91 90 02 	lds	r25, 0x0290
    5342:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    5346:	90 93 42 0c 	sts	0x0C42, r25
    534a:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()+3, thread3, NULL);
    534e:	e0 91 3c 0c 	lds	r30, 0x0C3C
    5352:	f0 91 3d 0c 	lds	r31, 0x0C3D
    5356:	44 81       	ldd	r20, Z+4	; 0x04
    5358:	4d 5f       	subi	r20, 0xFD	; 253
    535a:	25 e5       	ldi	r18, 0x55	; 85
    535c:	37 e2       	ldi	r19, 0x27	; 39
    535e:	67 e9       	ldi	r22, 0x97	; 151
    5360:	70 e0       	ldi	r23, 0x00	; 0
    5362:	80 91 91 02 	lds	r24, 0x0291
    5366:	90 91 92 02 	lds	r25, 0x0292
    536a:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    536e:	90 93 44 0c 	sts	0x0C44, r25
    5372:	80 93 43 0c 	sts	0x0C43, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()+2, thread3, NULL);
    5376:	e0 91 3c 0c 	lds	r30, 0x0C3C
    537a:	f0 91 3d 0c 	lds	r31, 0x0C3D
    537e:	44 81       	ldd	r20, Z+4	; 0x04
    5380:	4e 5f       	subi	r20, 0xFE	; 254
    5382:	25 e5       	ldi	r18, 0x55	; 85
    5384:	37 e2       	ldi	r19, 0x27	; 39
    5386:	67 e9       	ldi	r22, 0x97	; 151
    5388:	70 e0       	ldi	r23, 0x00	; 0
    538a:	80 91 93 02 	lds	r24, 0x0293
    538e:	90 91 94 02 	lds	r25, 0x0294
    5392:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    5396:	90 93 46 0c 	sts	0x0C46, r25
    539a:	80 93 45 0c 	sts	0x0C45, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()+1, thread3, NULL);
    539e:	e0 91 3c 0c 	lds	r30, 0x0C3C
    53a2:	f0 91 3d 0c 	lds	r31, 0x0C3D
    53a6:	44 81       	ldd	r20, Z+4	; 0x04
    53a8:	4f 5f       	subi	r20, 0xFF	; 255
    53aa:	25 e5       	ldi	r18, 0x55	; 85
    53ac:	37 e2       	ldi	r19, 0x27	; 39
    53ae:	67 e9       	ldi	r22, 0x97	; 151
    53b0:	70 e0       	ldi	r23, 0x00	; 0
    53b2:	80 91 95 02 	lds	r24, 0x0295
    53b6:	90 91 96 02 	lds	r25, 0x0296
    53ba:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    53be:	90 93 48 0c 	sts	0x0C48, r25
    53c2:	80 93 47 0c 	sts	0x0C47, r24

  n = 0;
  test_wait_tick();
    53c6:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  test_start_timer(1000);
    53ca:	88 ee       	ldi	r24, 0xE8	; 232
    53cc:	93 e0       	ldi	r25, 0x03	; 3
    53ce:	0e 94 8b 10 	call	0x2116	; 0x2116 <test_start_timer>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()+3, thread3, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()+2, thread3, NULL);
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()+1, thread3, NULL);

  n = 0;
    53d2:	c1 2c       	mov	r12, r1
    53d4:	d1 2c       	mov	r13, r1
    53d6:	76 01       	movw	r14, r12
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemReset(&sem1, 0);
    53d8:	60 e0       	ldi	r22, 0x00	; 0
    53da:	80 ef       	ldi	r24, 0xF0	; 240
    53dc:	9a e0       	ldi	r25, 0x0A	; 10
    53de:	0e 94 65 05 	call	0xaca	; 0xaca <chSemReset>
    n++;
    53e2:	8f ef       	ldi	r24, 0xFF	; 255
    53e4:	c8 1a       	sub	r12, r24
    53e6:	d8 0a       	sbc	r13, r24
    53e8:	e8 0a       	sbc	r14, r24
    53ea:	f8 0a       	sbc	r15, r24
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    53ec:	80 91 3e 0c 	lds	r24, 0x0C3E
    53f0:	88 23       	and	r24, r24
    53f2:	91 f3       	breq	.-28     	; 0x53d8 <bmk7_execute+0xea>
  test_terminate_threads();
    53f4:	0e 94 39 10 	call	0x2072	; 0x2072 <test_terminate_threads>
  chSemReset(&sem1, 0);
    53f8:	60 e0       	ldi	r22, 0x00	; 0
    53fa:	80 ef       	ldi	r24, 0xF0	; 240
    53fc:	9a e0       	ldi	r25, 0x0A	; 10
    53fe:	0e 94 65 05 	call	0xaca	; 0xaca <chSemReset>
  test_wait_threads();
    5402:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>

  test_print("--- Score : ");
    5406:	83 eb       	ldi	r24, 0xB3	; 179
    5408:	98 e0       	ldi	r25, 0x08	; 8
    540a:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n);
    540e:	c7 01       	movw	r24, r14
    5410:	b6 01       	movw	r22, r12
    5412:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_print(" reschedules/S, ");
    5416:	86 e0       	ldi	r24, 0x06	; 6
    5418:	99 e0       	ldi	r25, 0x09	; 9
    541a:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n * 6);
    541e:	c7 01       	movw	r24, r14
    5420:	b6 01       	movw	r22, r12
    5422:	66 0f       	add	r22, r22
    5424:	77 1f       	adc	r23, r23
    5426:	88 1f       	adc	r24, r24
    5428:	99 1f       	adc	r25, r25
    542a:	6c 0d       	add	r22, r12
    542c:	7d 1d       	adc	r23, r13
    542e:	8e 1d       	adc	r24, r14
    5430:	9f 1d       	adc	r25, r15
    5432:	66 0f       	add	r22, r22
    5434:	77 1f       	adc	r23, r23
    5436:	88 1f       	adc	r24, r24
    5438:	99 1f       	adc	r25, r25
    543a:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" ctxswc/S");
    543e:	8c ef       	ldi	r24, 0xFC	; 252
    5440:	98 e0       	ldi	r25, 0x08	; 8
}
    5442:	1f 91       	pop	r17
    5444:	0f 91       	pop	r16
    5446:	ff 90       	pop	r15
    5448:	ef 90       	pop	r14
    544a:	df 90       	pop	r13
    544c:	cf 90       	pop	r12

  test_print("--- Score : ");
  test_printn(n);
  test_print(" reschedules/S, ");
  test_printn(n * 6);
  test_println(" ctxswc/S");
    544e:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

00005452 <bmk5_execute>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
    5452:	bf 92       	push	r11
    5454:	cf 92       	push	r12
    5456:	df 92       	push	r13
    5458:	ef 92       	push	r14
    545a:	ff 92       	push	r15
    545c:	0f 93       	push	r16
    545e:	1f 93       	push	r17
    5460:	cf 93       	push	r28
    5462:	df 93       	push	r29

  uint32_t n = 0;
  void *wap = wa[0];
    5464:	c0 91 8d 02 	lds	r28, 0x028D
    5468:	d0 91 8e 02 	lds	r29, 0x028E
  tprio_t prio = chThdGetPriority() - 1;
    546c:	e0 91 3c 0c 	lds	r30, 0x0C3C
    5470:	f0 91 3d 0c 	lds	r31, 0x0C3D
    5474:	b4 80       	ldd	r11, Z+4	; 0x04
    5476:	ba 94       	dec	r11
  test_wait_tick();
    5478:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  test_start_timer(1000);
    547c:	88 ee       	ldi	r24, 0xE8	; 232
    547e:	93 e0       	ldi	r25, 0x03	; 3
    5480:	0e 94 8b 10 	call	0x2116	; 0x2116 <test_start_timer>
 * a second of continuous operations.
 */

static void bmk5_execute(void) {

  uint32_t n = 0;
    5484:	c1 2c       	mov	r12, r1
    5486:	d1 2c       	mov	r13, r1
    5488:	76 01       	movw	r14, r12
  void *wap = wa[0];
  tprio_t prio = chThdGetPriority() - 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread2, NULL));
    548a:	00 e0       	ldi	r16, 0x00	; 0
    548c:	10 e0       	ldi	r17, 0x00	; 0
    548e:	2d e7       	ldi	r18, 0x7D	; 125
    5490:	36 e2       	ldi	r19, 0x26	; 38
    5492:	4b 2d       	mov	r20, r11
    5494:	67 e9       	ldi	r22, 0x97	; 151
    5496:	70 e0       	ldi	r23, 0x00	; 0
    5498:	ce 01       	movw	r24, r28
    549a:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    549e:	0e 94 08 05 	call	0xa10	; 0xa10 <chThdWait>
    n++;
    54a2:	8f ef       	ldi	r24, 0xFF	; 255
    54a4:	c8 1a       	sub	r12, r24
    54a6:	d8 0a       	sbc	r13, r24
    54a8:	e8 0a       	sbc	r14, r24
    54aa:	f8 0a       	sbc	r15, r24
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    54ac:	80 91 3e 0c 	lds	r24, 0x0C3E
    54b0:	88 23       	and	r24, r24
    54b2:	59 f3       	breq	.-42     	; 0x548a <bmk5_execute+0x38>
  test_print("--- Score : ");
    54b4:	83 eb       	ldi	r24, 0xB3	; 179
    54b6:	98 e0       	ldi	r25, 0x08	; 8
    54b8:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n);
    54bc:	c7 01       	movw	r24, r14
    54be:	b6 01       	movw	r22, r12
    54c0:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" threads/S");
    54c4:	81 ef       	ldi	r24, 0xF1	; 241
    54c6:	98 e0       	ldi	r25, 0x08	; 8
}
    54c8:	df 91       	pop	r29
    54ca:	cf 91       	pop	r28
    54cc:	1f 91       	pop	r17
    54ce:	0f 91       	pop	r16
    54d0:	ff 90       	pop	r15
    54d2:	ef 90       	pop	r14
    54d4:	df 90       	pop	r13
    54d6:	cf 90       	pop	r12
    54d8:	bf 90       	pop	r11
    ChkIntSources();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n);
  test_println(" threads/S");
    54da:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

000054de <bmk4_execute>:
  } while (msg == RDY_OK);
  chSysUnlock();
  return 0;
}

static void bmk4_execute(void) {
    54de:	cf 92       	push	r12
    54e0:	df 92       	push	r13
    54e2:	ef 92       	push	r14
    54e4:	ff 92       	push	r15
    54e6:	0f 93       	push	r16
    54e8:	1f 93       	push	r17
    54ea:	cf 93       	push	r28
    54ec:	df 93       	push	r29
  Thread *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread4, NULL);
    54ee:	e0 91 3c 0c 	lds	r30, 0x0C3C
    54f2:	f0 91 3d 0c 	lds	r31, 0x0C3D
    54f6:	44 81       	ldd	r20, Z+4	; 0x04
    54f8:	4f 5f       	subi	r20, 0xFF	; 255
    54fa:	00 e0       	ldi	r16, 0x00	; 0
    54fc:	10 e0       	ldi	r17, 0x00	; 0
    54fe:	2c e2       	ldi	r18, 0x2C	; 44
    5500:	3c e2       	ldi	r19, 0x2C	; 44
    5502:	67 e9       	ldi	r22, 0x97	; 151
    5504:	70 e0       	ldi	r23, 0x00	; 0
    5506:	80 91 8d 02 	lds	r24, 0x028D
    550a:	90 91 8e 02 	lds	r25, 0x028E
    550e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    5512:	ec 01       	movw	r28, r24
    5514:	90 93 40 0c 	sts	0x0C40, r25
    5518:	80 93 3f 0c 	sts	0x0C3F, r24
  n = 0;
  test_wait_tick();
    551c:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  test_start_timer(1000);
    5520:	88 ee       	ldi	r24, 0xE8	; 232
    5522:	93 e0       	ldi	r25, 0x03	; 3
    5524:	0e 94 8b 10 	call	0x2116	; 0x2116 <test_start_timer>
static void bmk4_execute(void) {
  Thread *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread4, NULL);
  n = 0;
    5528:	c1 2c       	mov	r12, r1
    552a:	d1 2c       	mov	r13, r1
    552c:	76 01       	movw	r14, r12
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    552e:	f8 94       	cli
    chSchWakeupS(tp, RDY_OK);
    5530:	60 e0       	ldi	r22, 0x00	; 0
    5532:	70 e0       	ldi	r23, 0x00	; 0
    5534:	ce 01       	movw	r24, r28
    5536:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
    chSchWakeupS(tp, RDY_OK);
    553a:	60 e0       	ldi	r22, 0x00	; 0
    553c:	70 e0       	ldi	r23, 0x00	; 0
    553e:	ce 01       	movw	r24, r28
    5540:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
    chSchWakeupS(tp, RDY_OK);
    5544:	60 e0       	ldi	r22, 0x00	; 0
    5546:	70 e0       	ldi	r23, 0x00	; 0
    5548:	ce 01       	movw	r24, r28
    554a:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
    chSchWakeupS(tp, RDY_OK);
    554e:	60 e0       	ldi	r22, 0x00	; 0
    5550:	70 e0       	ldi	r23, 0x00	; 0
    5552:	ce 01       	movw	r24, r28
    5554:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
    chSysUnlock();
    5558:	78 94       	sei
    n += 4;
    555a:	84 e0       	ldi	r24, 0x04	; 4
    555c:	c8 0e       	add	r12, r24
    555e:	d1 1c       	adc	r13, r1
    5560:	e1 1c       	adc	r14, r1
    5562:	f1 1c       	adc	r15, r1
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    5564:	80 91 3e 0c 	lds	r24, 0x0C3E
    5568:	88 23       	and	r24, r24
    556a:	09 f3       	breq	.-62     	; 0x552e <bmk4_execute+0x50>
  chSysLock();
    556c:	f8 94       	cli
  chSchWakeupS(tp, RDY_TIMEOUT);
    556e:	6f ef       	ldi	r22, 0xFF	; 255
    5570:	7f ef       	ldi	r23, 0xFF	; 255
    5572:	ce 01       	movw	r24, r28
    5574:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <chSchWakeupS>
  chSysUnlock();
    5578:	78 94       	sei

  test_wait_threads();
    557a:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_print("--- Score : ");
    557e:	83 eb       	ldi	r24, 0xB3	; 179
    5580:	98 e0       	ldi	r25, 0x08	; 8
    5582:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n * 2);
    5586:	c7 01       	movw	r24, r14
    5588:	b6 01       	movw	r22, r12
    558a:	66 0f       	add	r22, r22
    558c:	77 1f       	adc	r23, r23
    558e:	88 1f       	adc	r24, r24
    5590:	99 1f       	adc	r25, r25
    5592:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" ctxswc/S");
    5596:	8c ef       	ldi	r24, 0xFC	; 252
    5598:	98 e0       	ldi	r25, 0x08	; 8
}
    559a:	df 91       	pop	r29
    559c:	cf 91       	pop	r28
    559e:	1f 91       	pop	r17
    55a0:	0f 91       	pop	r16
    55a2:	ff 90       	pop	r15
    55a4:	ef 90       	pop	r14
    55a6:	df 90       	pop	r13
    55a8:	cf 90       	pop	r12
  chSysUnlock();

  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n * 2);
  test_println(" ctxswc/S");
    55aa:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

000055ae <msg_loop_test>:
}

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(Thread *tp) {
    55ae:	cf 92       	push	r12
    55b0:	df 92       	push	r13
    55b2:	ef 92       	push	r14
    55b4:	ff 92       	push	r15
    55b6:	cf 93       	push	r28
    55b8:	df 93       	push	r29
    55ba:	ec 01       	movw	r28, r24

  uint32_t n = 0;
  test_wait_tick();
    55bc:	0e 94 81 10 	call	0x2102	; 0x2102 <test_wait_tick>
  test_start_timer(1000);
    55c0:	88 ee       	ldi	r24, 0xE8	; 232
    55c2:	93 e0       	ldi	r25, 0x03	; 3
    55c4:	0e 94 8b 10 	call	0x2116	; 0x2116 <test_start_timer>
#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(Thread *tp) {

  uint32_t n = 0;
    55c8:	c1 2c       	mov	r12, r1
    55ca:	d1 2c       	mov	r13, r1
    55cc:	76 01       	movw	r14, r12
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
    55ce:	61 e0       	ldi	r22, 0x01	; 1
    55d0:	70 e0       	ldi	r23, 0x00	; 0
    55d2:	ce 01       	movw	r24, r28
    55d4:	0e 94 08 0b 	call	0x1610	; 0x1610 <chMsgSend>
    n++;
    55d8:	8f ef       	ldi	r24, 0xFF	; 255
    55da:	c8 1a       	sub	r12, r24
    55dc:	d8 0a       	sbc	r13, r24
    55de:	e8 0a       	sbc	r14, r24
    55e0:	f8 0a       	sbc	r15, r24
#if defined(SIMULATOR)
    ChkIntSources();
#endif
  } while (!test_timer_done);
    55e2:	80 91 3e 0c 	lds	r24, 0x0C3E
    55e6:	88 23       	and	r24, r24
    55e8:	91 f3       	breq	.-28     	; 0x55ce <msg_loop_test+0x20>
  (void)chMsgSend(tp, 0);
    55ea:	60 e0       	ldi	r22, 0x00	; 0
    55ec:	70 e0       	ldi	r23, 0x00	; 0
    55ee:	ce 01       	movw	r24, r28
    55f0:	0e 94 08 0b 	call	0x1610	; 0x1610 <chMsgSend>
  return n;
}
    55f4:	c6 01       	movw	r24, r12
    55f6:	df 91       	pop	r29
    55f8:	cf 91       	pop	r28
    55fa:	ff 90       	pop	r15
    55fc:	ef 90       	pop	r14
    55fe:	df 90       	pop	r13
    5600:	cf 90       	pop	r12
    5602:	08 95       	ret

00005604 <bmk3_execute>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
    5604:	cf 92       	push	r12
    5606:	df 92       	push	r13
    5608:	ef 92       	push	r14
    560a:	ff 92       	push	r15
    560c:	0f 93       	push	r16
    560e:	1f 93       	push	r17
    5610:	cf 93       	push	r28
    5612:	df 93       	push	r29
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread1, NULL);
    5614:	e0 91 3c 0c 	lds	r30, 0x0C3C
    5618:	f0 91 3d 0c 	lds	r31, 0x0C3D
    561c:	44 81       	ldd	r20, Z+4	; 0x04
    561e:	4f 5f       	subi	r20, 0xFF	; 255
    5620:	00 e0       	ldi	r16, 0x00	; 0
    5622:	10 e0       	ldi	r17, 0x00	; 0
    5624:	2b e1       	ldi	r18, 0x1B	; 27
    5626:	3c e2       	ldi	r19, 0x2C	; 44
    5628:	67 e9       	ldi	r22, 0x97	; 151
    562a:	70 e0       	ldi	r23, 0x00	; 0
    562c:	80 91 8d 02 	lds	r24, 0x028D
    5630:	90 91 8e 02 	lds	r25, 0x028E
    5634:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    5638:	cf e3       	ldi	r28, 0x3F	; 63
    563a:	dc e0       	ldi	r29, 0x0C	; 12
    563c:	99 83       	std	Y+1, r25	; 0x01
    563e:	88 83       	st	Y, r24
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriority()-2, thread2, NULL);
    5640:	e0 91 3c 0c 	lds	r30, 0x0C3C
    5644:	f0 91 3d 0c 	lds	r31, 0x0C3D
    5648:	44 81       	ldd	r20, Z+4	; 0x04
    564a:	42 50       	subi	r20, 0x02	; 2
    564c:	2d e7       	ldi	r18, 0x7D	; 125
    564e:	36 e2       	ldi	r19, 0x26	; 38
    5650:	67 e9       	ldi	r22, 0x97	; 151
    5652:	70 e0       	ldi	r23, 0x00	; 0
    5654:	80 91 8f 02 	lds	r24, 0x028F
    5658:	90 91 90 02 	lds	r25, 0x0290
    565c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    5660:	90 93 42 0c 	sts	0x0C42, r25
    5664:	80 93 41 0c 	sts	0x0C41, r24
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriority()-3, thread2, NULL);
    5668:	e0 91 3c 0c 	lds	r30, 0x0C3C
    566c:	f0 91 3d 0c 	lds	r31, 0x0C3D
    5670:	44 81       	ldd	r20, Z+4	; 0x04
    5672:	43 50       	subi	r20, 0x03	; 3
    5674:	2d e7       	ldi	r18, 0x7D	; 125
    5676:	36 e2       	ldi	r19, 0x26	; 38
    5678:	67 e9       	ldi	r22, 0x97	; 151
    567a:	70 e0       	ldi	r23, 0x00	; 0
    567c:	80 91 91 02 	lds	r24, 0x0291
    5680:	90 91 92 02 	lds	r25, 0x0292
    5684:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    5688:	90 93 44 0c 	sts	0x0C44, r25
    568c:	80 93 43 0c 	sts	0x0C43, r24
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriority()-4, thread2, NULL);
    5690:	e0 91 3c 0c 	lds	r30, 0x0C3C
    5694:	f0 91 3d 0c 	lds	r31, 0x0C3D
    5698:	44 81       	ldd	r20, Z+4	; 0x04
    569a:	44 50       	subi	r20, 0x04	; 4
    569c:	2d e7       	ldi	r18, 0x7D	; 125
    569e:	36 e2       	ldi	r19, 0x26	; 38
    56a0:	67 e9       	ldi	r22, 0x97	; 151
    56a2:	70 e0       	ldi	r23, 0x00	; 0
    56a4:	80 91 93 02 	lds	r24, 0x0293
    56a8:	90 91 94 02 	lds	r25, 0x0294
    56ac:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    56b0:	90 93 46 0c 	sts	0x0C46, r25
    56b4:	80 93 45 0c 	sts	0x0C45, r24
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriority()-5, thread2, NULL);
    56b8:	e0 91 3c 0c 	lds	r30, 0x0C3C
    56bc:	f0 91 3d 0c 	lds	r31, 0x0C3D
    56c0:	44 81       	ldd	r20, Z+4	; 0x04
    56c2:	45 50       	subi	r20, 0x05	; 5
    56c4:	2d e7       	ldi	r18, 0x7D	; 125
    56c6:	36 e2       	ldi	r19, 0x26	; 38
    56c8:	67 e9       	ldi	r22, 0x97	; 151
    56ca:	70 e0       	ldi	r23, 0x00	; 0
    56cc:	80 91 95 02 	lds	r24, 0x0295
    56d0:	90 91 96 02 	lds	r25, 0x0296
    56d4:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    56d8:	90 93 48 0c 	sts	0x0C48, r25
    56dc:	80 93 47 0c 	sts	0x0C47, r24
  n = msg_loop_test(threads[0]);
    56e0:	88 81       	ld	r24, Y
    56e2:	99 81       	ldd	r25, Y+1	; 0x01
    56e4:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <msg_loop_test>
    56e8:	6c 01       	movw	r12, r24
    56ea:	e1 2c       	mov	r14, r1
    56ec:	f1 2c       	mov	r15, r1
  test_wait_threads();
    56ee:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_print("--- Score : ");
    56f2:	83 eb       	ldi	r24, 0xB3	; 179
    56f4:	98 e0       	ldi	r25, 0x08	; 8
    56f6:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n);
    56fa:	c7 01       	movw	r24, r14
    56fc:	b6 01       	movw	r22, r12
    56fe:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_print(" msgs/S, ");
    5702:	87 e1       	ldi	r24, 0x17	; 23
    5704:	99 e0       	ldi	r25, 0x09	; 9
    5706:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n << 1);
    570a:	c7 01       	movw	r24, r14
    570c:	b6 01       	movw	r22, r12
    570e:	66 0f       	add	r22, r22
    5710:	77 1f       	adc	r23, r23
    5712:	88 1f       	adc	r24, r24
    5714:	99 1f       	adc	r25, r25
    5716:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" ctxswc/S");
    571a:	8c ef       	ldi	r24, 0xFC	; 252
    571c:	98 e0       	ldi	r25, 0x08	; 8
}
    571e:	df 91       	pop	r29
    5720:	cf 91       	pop	r28
    5722:	1f 91       	pop	r17
    5724:	0f 91       	pop	r16
    5726:	ff 90       	pop	r15
    5728:	ef 90       	pop	r14
    572a:	df 90       	pop	r13
    572c:	cf 90       	pop	r12
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
    572e:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

00005732 <bmk2_execute>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
    5732:	cf 92       	push	r12
    5734:	df 92       	push	r13
    5736:	ef 92       	push	r14
    5738:	ff 92       	push	r15
    573a:	0f 93       	push	r16
    573c:	1f 93       	push	r17
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()+1, thread1, NULL);
    573e:	e0 91 3c 0c 	lds	r30, 0x0C3C
    5742:	f0 91 3d 0c 	lds	r31, 0x0C3D
    5746:	44 81       	ldd	r20, Z+4	; 0x04
    5748:	4f 5f       	subi	r20, 0xFF	; 255
    574a:	00 e0       	ldi	r16, 0x00	; 0
    574c:	10 e0       	ldi	r17, 0x00	; 0
    574e:	2b e1       	ldi	r18, 0x1B	; 27
    5750:	3c e2       	ldi	r19, 0x2C	; 44
    5752:	67 e9       	ldi	r22, 0x97	; 151
    5754:	70 e0       	ldi	r23, 0x00	; 0
    5756:	80 91 8d 02 	lds	r24, 0x028D
    575a:	90 91 8e 02 	lds	r25, 0x028E
    575e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    5762:	90 93 40 0c 	sts	0x0C40, r25
    5766:	80 93 3f 0c 	sts	0x0C3F, r24
  n = msg_loop_test(threads[0]);
    576a:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <msg_loop_test>
    576e:	6c 01       	movw	r12, r24
    5770:	e1 2c       	mov	r14, r1
    5772:	f1 2c       	mov	r15, r1
  test_wait_threads();
    5774:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_print("--- Score : ");
    5778:	83 eb       	ldi	r24, 0xB3	; 179
    577a:	98 e0       	ldi	r25, 0x08	; 8
    577c:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n);
    5780:	c7 01       	movw	r24, r14
    5782:	b6 01       	movw	r22, r12
    5784:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_print(" msgs/S, ");
    5788:	87 e1       	ldi	r24, 0x17	; 23
    578a:	99 e0       	ldi	r25, 0x09	; 9
    578c:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n << 1);
    5790:	c7 01       	movw	r24, r14
    5792:	b6 01       	movw	r22, r12
    5794:	66 0f       	add	r22, r22
    5796:	77 1f       	adc	r23, r23
    5798:	88 1f       	adc	r24, r24
    579a:	99 1f       	adc	r25, r25
    579c:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" ctxswc/S");
    57a0:	8c ef       	ldi	r24, 0xFC	; 252
    57a2:	98 e0       	ldi	r25, 0x08	; 8
}
    57a4:	1f 91       	pop	r17
    57a6:	0f 91       	pop	r16
    57a8:	ff 90       	pop	r15
    57aa:	ef 90       	pop	r14
    57ac:	df 90       	pop	r13
    57ae:	cf 90       	pop	r12
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
    57b0:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

000057b4 <bmk1_execute>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
    57b4:	cf 92       	push	r12
    57b6:	df 92       	push	r13
    57b8:	ef 92       	push	r14
    57ba:	ff 92       	push	r15
    57bc:	0f 93       	push	r16
    57be:	1f 93       	push	r17
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriority()-1, thread1, NULL);
    57c0:	e0 91 3c 0c 	lds	r30, 0x0C3C
    57c4:	f0 91 3d 0c 	lds	r31, 0x0C3D
    57c8:	44 81       	ldd	r20, Z+4	; 0x04
    57ca:	41 50       	subi	r20, 0x01	; 1
    57cc:	00 e0       	ldi	r16, 0x00	; 0
    57ce:	10 e0       	ldi	r17, 0x00	; 0
    57d0:	2b e1       	ldi	r18, 0x1B	; 27
    57d2:	3c e2       	ldi	r19, 0x2C	; 44
    57d4:	67 e9       	ldi	r22, 0x97	; 151
    57d6:	70 e0       	ldi	r23, 0x00	; 0
    57d8:	80 91 8d 02 	lds	r24, 0x028D
    57dc:	90 91 8e 02 	lds	r25, 0x028E
    57e0:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>
    57e4:	90 93 40 0c 	sts	0x0C40, r25
    57e8:	80 93 3f 0c 	sts	0x0C3F, r24
  n = msg_loop_test(threads[0]);
    57ec:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <msg_loop_test>
    57f0:	6c 01       	movw	r12, r24
    57f2:	e1 2c       	mov	r14, r1
    57f4:	f1 2c       	mov	r15, r1
  test_wait_threads();
    57f6:	0e 94 4a 10 	call	0x2094	; 0x2094 <test_wait_threads>
  test_print("--- Score : ");
    57fa:	83 eb       	ldi	r24, 0xB3	; 179
    57fc:	98 e0       	ldi	r25, 0x08	; 8
    57fe:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n);
    5802:	c7 01       	movw	r24, r14
    5804:	b6 01       	movw	r22, r12
    5806:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_print(" msgs/S, ");
    580a:	87 e1       	ldi	r24, 0x17	; 23
    580c:	99 e0       	ldi	r25, 0x09	; 9
    580e:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <test_print>
  test_printn(n << 1);
    5812:	c7 01       	movw	r24, r14
    5814:	b6 01       	movw	r22, r12
    5816:	66 0f       	add	r22, r22
    5818:	77 1f       	adc	r23, r23
    581a:	88 1f       	adc	r24, r24
    581c:	99 1f       	adc	r25, r25
    581e:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <test_printn>
  test_println(" ctxswc/S");
    5822:	8c ef       	ldi	r24, 0xFC	; 252
    5824:	98 e0       	ldi	r25, 0x08	; 8
}
    5826:	1f 91       	pop	r17
    5828:	0f 91       	pop	r16
    582a:	ff 90       	pop	r15
    582c:	ef 90       	pop	r14
    582e:	df 90       	pop	r13
    5830:	cf 90       	pop	r12
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
    5832:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <test_println>

00005836 <thread1>:
static Semaphore sem1;
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
static Mutex mtx1;
#endif

static msg_t thread1(void *p) {
    5836:	cf 93       	push	r28
    5838:	df 93       	push	r29
  Thread *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
    583a:	0e 94 2f 0b 	call	0x165e	; 0x165e <chMsgWait>
    msg = chMsgGet(tp);
    583e:	fc 01       	movw	r30, r24
    5840:	c2 8d       	ldd	r28, Z+26	; 0x1a
    5842:	d3 8d       	ldd	r29, Z+27	; 0x1b
    chMsgRelease(tp, msg);
    5844:	be 01       	movw	r22, r28
    5846:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <chMsgRelease>
  } while (msg);
    584a:	cd 2b       	or	r28, r29
    584c:	b1 f7       	brne	.-20     	; 0x583a <thread1+0x4>
  return 0;
}
    584e:	80 e0       	ldi	r24, 0x00	; 0
    5850:	90 e0       	ldi	r25, 0x00	; 0
    5852:	df 91       	pop	r29
    5854:	cf 91       	pop	r28
    5856:	08 95       	ret

00005858 <thread4>:
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

msg_t thread4(void *p) {
    5858:	cf 93       	push	r28
    585a:	df 93       	push	r29
  msg_t msg;
  Thread *self = chThdSelf();
    585c:	c0 91 3c 0c 	lds	r28, 0x0C3C
    5860:	d0 91 3d 0c 	lds	r29, 0x0C3D

  (void)p;
  chSysLock();
    5864:	f8 94       	cli
  do {
    chSchGoSleepS(THD_STATE_SUSPENDED);
    5866:	82 e0       	ldi	r24, 0x02	; 2
    5868:	0e 94 9a 02 	call	0x534	; 0x534 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
  } while (msg == RDY_OK);
    586c:	8a 89       	ldd	r24, Y+18	; 0x12
    586e:	9b 89       	ldd	r25, Y+19	; 0x13
    5870:	89 2b       	or	r24, r25
    5872:	c9 f3       	breq	.-14     	; 0x5866 <thread4+0xe>
  chSysUnlock();
    5874:	78 94       	sei
  return 0;
}
    5876:	80 e0       	ldi	r24, 0x00	; 0
    5878:	90 e0       	ldi	r25, 0x00	; 0
    587a:	df 91       	pop	r29
    587c:	cf 91       	pop	r28
    587e:	08 95       	ret

00005880 <halInit>:
 *
 * @init
 */
void halInit(void) {

  hal_lld_init();
    5880:	0e 94 35 2d 	call	0x5a6a	; 0x5a6a <hal_lld_init>

#if HAL_USE_TM || defined(__DOXYGEN__)
  tmInit();
#endif
#if HAL_USE_PAL || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    5884:	86 e4       	ldi	r24, 0x46	; 70
    5886:	94 e0       	ldi	r25, 0x04	; 4
    5888:	0e 94 6a 2d 	call	0x5ad4	; 0x5ad4 <_pal_lld_init>
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
    588c:	0e 94 a0 2c 	call	0x5940	; 0x5940 <sdInit>
#endif
#if HAL_USE_RTC || defined(__DOXYGEN__)
  rtcInit();
#endif
  /* Board specific initialization.*/
  boardInit();
    5890:	0c 94 1e 2f 	jmp	0x5e3c	; 0x5e3c <boardInit>

00005894 <palReadBus>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @return              The bus logical states.
 *
 * @api
 */
ioportmask_t palReadBus(IOBus *bus) {
    5894:	fc 01       	movw	r30, r24

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palReadBus");

  return palReadGroup(bus->portid, bus->mask, bus->offset);
    5896:	a0 81       	ld	r26, Z
    5898:	b1 81       	ldd	r27, Z+1	; 0x01
    589a:	2c 91       	ld	r18, X
    589c:	30 e0       	ldi	r19, 0x00	; 0
    589e:	03 80       	ldd	r0, Z+3	; 0x03
    58a0:	02 c0       	rjmp	.+4      	; 0x58a6 <palReadBus+0x12>
    58a2:	35 95       	asr	r19
    58a4:	27 95       	ror	r18
    58a6:	0a 94       	dec	r0
    58a8:	e2 f7       	brpl	.-8      	; 0x58a2 <palReadBus+0xe>
    58aa:	82 81       	ldd	r24, Z+2	; 0x02
}
    58ac:	82 23       	and	r24, r18
    58ae:	08 95       	ret

000058b0 <palWriteBus>:
 *                      the bus width are masked so most significant bits are
 *                      lost.
 *
 * @api
 */
void palWriteBus(IOBus *bus, ioportmask_t bits) {
    58b0:	fc 01       	movw	r30, r24

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palWriteBus");

  palWriteGroup(bus->portid, bus->mask, bus->offset, bits);
    58b2:	a0 81       	ld	r26, Z
    58b4:	b1 81       	ldd	r27, Z+1	; 0x01
    58b6:	12 96       	adiw	r26, 0x02	; 2
    58b8:	3c 91       	ld	r19, X
    58ba:	12 97       	sbiw	r26, 0x02	; 2
    58bc:	82 81       	ldd	r24, Z+2	; 0x02
    58be:	23 81       	ldd	r18, Z+3	; 0x03
    58c0:	68 23       	and	r22, r24
    58c2:	02 2e       	mov	r0, r18
    58c4:	01 c0       	rjmp	.+2      	; 0x58c8 <palWriteBus+0x18>
    58c6:	66 0f       	add	r22, r22
    58c8:	0a 94       	dec	r0
    58ca:	ea f7       	brpl	.-6      	; 0x58c6 <palWriteBus+0x16>
    58cc:	02 2e       	mov	r0, r18
    58ce:	01 c0       	rjmp	.+2      	; 0x58d2 <palWriteBus+0x22>
    58d0:	88 0f       	add	r24, r24
    58d2:	0a 94       	dec	r0
    58d4:	ea f7       	brpl	.-6      	; 0x58d0 <palWriteBus+0x20>
    58d6:	80 95       	com	r24
    58d8:	83 23       	and	r24, r19
    58da:	86 2b       	or	r24, r22
    58dc:	12 96       	adiw	r26, 0x02	; 2
    58de:	8c 93       	st	X, r24
    58e0:	08 95       	ret

000058e2 <palSetBusMode>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @param[in] mode      the mode
 *
 * @api
 */
void palSetBusMode(IOBus *bus, iomode_t mode) {
    58e2:	fc 01       	movw	r30, r24
    58e4:	46 2f       	mov	r20, r22

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palSetBusMode");

  palSetGroupMode(bus->portid, bus->mask, bus->offset, mode);
    58e6:	82 81       	ldd	r24, Z+2	; 0x02
    58e8:	68 2f       	mov	r22, r24
    58ea:	70 e0       	ldi	r23, 0x00	; 0
    58ec:	03 80       	ldd	r0, Z+3	; 0x03
    58ee:	02 c0       	rjmp	.+4      	; 0x58f4 <palSetBusMode+0x12>
    58f0:	66 0f       	add	r22, r22
    58f2:	77 1f       	adc	r23, r23
    58f4:	0a 94       	dec	r0
    58f6:	e2 f7       	brpl	.-8      	; 0x58f0 <palSetBusMode+0xe>
    58f8:	80 81       	ld	r24, Z
    58fa:	91 81       	ldd	r25, Z+1	; 0x01
    58fc:	0c 94 a0 2d 	jmp	0x5b40	; 0x5b40 <_pal_lld_setgroupmode>

00005900 <readt>:
  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
    5900:	05 96       	adiw	r24, 0x05	; 5
    5902:	0c 94 86 0d 	jmp	0x1b0c	; 0x1b0c <chIQReadTimeout>

00005906 <read>:
                          n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    5906:	2f ef       	ldi	r18, 0xFF	; 255
    5908:	3f ef       	ldi	r19, 0xFF	; 255
    590a:	05 96       	adiw	r24, 0x05	; 5
    590c:	0c 94 86 0d 	jmp	0x1b0c	; 0x1b0c <chIQReadTimeout>

00005910 <writet>:
  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
    5910:	47 96       	adiw	r24, 0x17	; 23
    5912:	0c 94 9e 0e 	jmp	0x1d3c	; 0x1d3c <chOQWriteTimeout>

00005916 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    5916:	2f ef       	ldi	r18, 0xFF	; 255
    5918:	3f ef       	ldi	r19, 0xFF	; 255
    591a:	47 96       	adiw	r24, 0x17	; 23
    591c:	0c 94 9e 0e 	jmp	0x1d3c	; 0x1d3c <chOQWriteTimeout>

00005920 <gett>:
  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    5920:	05 96       	adiw	r24, 0x05	; 5
    5922:	0c 94 4f 0d 	jmp	0x1a9e	; 0x1a9e <chIQGetTimeout>

00005926 <get>:
  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    5926:	6f ef       	ldi	r22, 0xFF	; 255
    5928:	7f ef       	ldi	r23, 0xFF	; 255
    592a:	05 96       	adiw	r24, 0x05	; 5
    592c:	0c 94 4f 0d 	jmp	0x1a9e	; 0x1a9e <chIQGetTimeout>

00005930 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    5930:	47 96       	adiw	r24, 0x17	; 23
    5932:	0c 94 20 0e 	jmp	0x1c40	; 0x1c40 <chOQPutTimeout>

00005936 <put>:
                         n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    5936:	4f ef       	ldi	r20, 0xFF	; 255
    5938:	5f ef       	ldi	r21, 0xFF	; 255
    593a:	47 96       	adiw	r24, 0x17	; 23
    593c:	0c 94 20 0e 	jmp	0x1c40	; 0x1c40 <chOQPutTimeout>

00005940 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    5940:	0c 94 47 2e 	jmp	0x5c8e	; 0x5c8e <sd_lld_init>

00005944 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    5944:	ef 92       	push	r14
    5946:	ff 92       	push	r15
    5948:	0f 93       	push	r16
    594a:	1f 93       	push	r17
    594c:	cf 93       	push	r28
    594e:	df 93       	push	r29
    5950:	ec 01       	movw	r28, r24
    5952:	9b 01       	movw	r18, r22
    5954:	7a 01       	movw	r14, r20

  sdp->vmt = &vmt;
    5956:	fc 01       	movw	r30, r24
    5958:	83 e3       	ldi	r24, 0x33	; 51
    595a:	94 e0       	ldi	r25, 0x04	; 4
    595c:	81 93       	st	Z+, r24
    595e:	91 93       	st	Z+, r25
  chEvtInit(&sdp->event);
    5960:	fb 83       	std	Y+3, r31	; 0x03
    5962:	ea 83       	std	Y+2, r30	; 0x02
  sdp->state = SD_STOP;
    5964:	81 e0       	ldi	r24, 0x01	; 1
    5966:	8c 83       	std	Y+4, r24	; 0x04
  chIQInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    5968:	be 01       	movw	r22, r28
    596a:	67 5d       	subi	r22, 0xD7	; 215
    596c:	7f 4f       	sbci	r23, 0xFF	; 255
    596e:	8e 01       	movw	r16, r28
    5970:	40 e1       	ldi	r20, 0x10	; 16
    5972:	50 e0       	ldi	r21, 0x00	; 0
    5974:	ce 01       	movw	r24, r28
    5976:	05 96       	adiw	r24, 0x05	; 5
    5978:	0e 94 c2 0c 	call	0x1984	; 0x1984 <chIQInit>
  chOQInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    597c:	be 01       	movw	r22, r28
    597e:	67 5c       	subi	r22, 0xC7	; 199
    5980:	7f 4f       	sbci	r23, 0xFF	; 255
    5982:	97 01       	movw	r18, r14
    5984:	40 e1       	ldi	r20, 0x10	; 16
    5986:	50 e0       	ldi	r21, 0x00	; 0
    5988:	ce 01       	movw	r24, r28
    598a:	47 96       	adiw	r24, 0x17	; 23
    598c:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <chOQInit>
}
    5990:	df 91       	pop	r29
    5992:	cf 91       	pop	r28
    5994:	1f 91       	pop	r17
    5996:	0f 91       	pop	r16
    5998:	ff 90       	pop	r15
    599a:	ef 90       	pop	r14
    599c:	08 95       	ret

0000599e <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    599e:	cf 93       	push	r28
    59a0:	df 93       	push	r29
    59a2:	ec 01       	movw	r28, r24

  chDbgCheck(sdp != NULL, "sdStart");

  chSysLock();
    59a4:	f8 94       	cli
  chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
              "sdStart(), #1",
              "invalid state");
  sd_lld_start(sdp, config);
    59a6:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <sd_lld_start>
  sdp->state = SD_READY;
    59aa:	82 e0       	ldi	r24, 0x02	; 2
    59ac:	8c 83       	std	Y+4, r24	; 0x04
  chSysUnlock();
    59ae:	78 94       	sei
}
    59b0:	df 91       	pop	r29
    59b2:	cf 91       	pop	r28
    59b4:	08 95       	ret

000059b6 <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
    59b6:	cf 93       	push	r28
    59b8:	df 93       	push	r29
    59ba:	ec 01       	movw	r28, r24

  chDbgCheck(sdp != NULL, "sdStop");

  chSysLock();
    59bc:	f8 94       	cli
  chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
              "sdStop(), #1",
              "invalid state");
  sd_lld_stop(sdp);
    59be:	0e 94 85 2e 	call	0x5d0a	; 0x5d0a <sd_lld_stop>
  sdp->state = SD_STOP;
    59c2:	81 e0       	ldi	r24, 0x01	; 1
    59c4:	8c 83       	std	Y+4, r24	; 0x04
  chOQResetI(&sdp->oqueue);
    59c6:	ce 01       	movw	r24, r28
    59c8:	47 96       	adiw	r24, 0x17	; 23
    59ca:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <chOQResetI>
  chIQResetI(&sdp->iqueue);
    59ce:	ce 01       	movw	r24, r28
    59d0:	05 96       	adiw	r24, 0x05	; 5
    59d2:	0e 94 dc 0c 	call	0x19b8	; 0x19b8 <chIQResetI>
  chSchRescheduleS();
    59d6:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <chSchRescheduleS>
  chSysUnlock();
    59da:	78 94       	sei
}
    59dc:	df 91       	pop	r29
    59de:	cf 91       	pop	r28
    59e0:	08 95       	ret

000059e2 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    59e2:	1f 93       	push	r17
    59e4:	cf 93       	push	r28
    59e6:	df 93       	push	r29
    59e8:	ec 01       	movw	r28, r24
    59ea:	16 2f       	mov	r17, r22

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    59ec:	89 85       	ldd	r24, Y+9	; 0x09
    59ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    59f0:	89 2b       	or	r24, r25
    59f2:	59 f0       	breq	.+22     	; 0x5a0a <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    59f4:	61 2f       	mov	r22, r17
    59f6:	ce 01       	movw	r24, r28
    59f8:	05 96       	adiw	r24, 0x05	; 5
    59fa:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    59fe:	97 fd       	sbrc	r25, 7
    5a00:	10 c0       	rjmp	.+32     	; 0x5a22 <sdIncomingDataI+0x40>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
    5a02:	df 91       	pop	r29
    5a04:	cf 91       	pop	r28
    5a06:	1f 91       	pop	r17
    5a08:	08 95       	ret

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    5a0a:	64 e0       	ldi	r22, 0x04	; 4
    5a0c:	ce 01       	movw	r24, r28
    5a0e:	02 96       	adiw	r24, 0x02	; 2
    5a10:	0e 94 cf 09 	call	0x139e	; 0x139e <chEvtBroadcastFlagsI>
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    5a14:	61 2f       	mov	r22, r17
    5a16:	ce 01       	movw	r24, r28
    5a18:	05 96       	adiw	r24, 0x05	; 5
    5a1a:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <chIQPutI>
    5a1e:	97 ff       	sbrs	r25, 7
    5a20:	f0 cf       	rjmp	.-32     	; 0x5a02 <sdIncomingDataI+0x20>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    5a22:	60 e8       	ldi	r22, 0x80	; 128
    5a24:	ce 01       	movw	r24, r28
    5a26:	02 96       	adiw	r24, 0x02	; 2
}
    5a28:	df 91       	pop	r29
    5a2a:	cf 91       	pop	r28
    5a2c:	1f 91       	pop	r17
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    5a2e:	0c 94 cf 09 	jmp	0x139e	; 0x139e <chEvtBroadcastFlagsI>

00005a32 <sdRequestDataI>:
 * @retval Q_EMPTY      if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    5a32:	0f 93       	push	r16
    5a34:	1f 93       	push	r17
    5a36:	cf 93       	push	r28
    5a38:	df 93       	push	r29
    5a3a:	8c 01       	movw	r16, r24
  msg_t  b;

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdRequestDataI");

  b = chOQGetI(&sdp->oqueue);
    5a3c:	47 96       	adiw	r24, 0x17	; 23
    5a3e:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <chOQGetI>
    5a42:	ec 01       	movw	r28, r24
  if (b < Q_OK)
    5a44:	97 fd       	sbrc	r25, 7
    5a46:	06 c0       	rjmp	.+12     	; 0x5a54 <sdRequestDataI+0x22>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
    5a48:	ce 01       	movw	r24, r28
    5a4a:	df 91       	pop	r29
    5a4c:	cf 91       	pop	r28
    5a4e:	1f 91       	pop	r17
    5a50:	0f 91       	pop	r16
    5a52:	08 95       	ret
  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdRequestDataI");

  b = chOQGetI(&sdp->oqueue);
  if (b < Q_OK)
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    5a54:	68 e0       	ldi	r22, 0x08	; 8
    5a56:	c8 01       	movw	r24, r16
    5a58:	02 96       	adiw	r24, 0x02	; 2
    5a5a:	0e 94 cf 09 	call	0x139e	; 0x139e <chEvtBroadcastFlagsI>
  return b;
}
    5a5e:	ce 01       	movw	r24, r28
    5a60:	df 91       	pop	r29
    5a62:	cf 91       	pop	r28
    5a64:	1f 91       	pop	r17
    5a66:	0f 91       	pop	r16
    5a68:	08 95       	ret

00005a6a <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
    5a6a:	cf 93       	push	r28
     /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
    5a6c:	10 92 69 00 	sts	0x0069, r1
#ifdef EICRB
  EICRB  = 0x00;
    5a70:	10 92 6a 00 	sts	0x006A, r1
#endif
  EIMSK  = 0x00;
    5a74:	1d ba       	out	0x1d, r1	; 29

  /*
   * Timer 0 setup.
   */
  TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.        */
    5a76:	c2 e0       	ldi	r28, 0x02	; 2
    5a78:	c4 bd       	out	0x24, r28	; 36
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.   */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.   */
  TCCR0B  = (0 << WGM02) ;				 /* CTC mode.        */
    5a7a:	15 bc       	out	0x25, r1	; 37


static void setClock()
{
  
  uint8_t prescaler_index = findBestPrescaler(CH_FREQUENCY,ratio_base,clock_source_base,PRESCALER_SIZE_BASE);
    5a7c:	25 e0       	ldi	r18, 0x05	; 5
    5a7e:	48 e6       	ldi	r20, 0x68	; 104
    5a80:	52 e0       	ldi	r21, 0x02	; 2
    5a82:	6d e6       	ldi	r22, 0x6D	; 109
    5a84:	72 e0       	ldi	r23, 0x02	; 2
    5a86:	88 ee       	ldi	r24, 0xE8	; 232
    5a88:	93 e0       	ldi	r25, 0x03	; 3
    5a8a:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <findBestPrescaler>
  
  TCCR0B &= ~((1 << CS02)  | (1 << CS01)  | (1 << CS00));
    5a8e:	95 b5       	in	r25, 0x25	; 37
    5a90:	98 7f       	andi	r25, 0xF8	; 248
    5a92:	95 bd       	out	0x25, r25	; 37
  TCCR0B |=((clock_source_base[prescaler_index] & 0x07)<<CS00);
    5a94:	95 b5       	in	r25, 0x25	; 37
    5a96:	e8 2f       	mov	r30, r24
    5a98:	f0 e0       	ldi	r31, 0x00	; 0
    5a9a:	df 01       	movw	r26, r30
    5a9c:	a8 59       	subi	r26, 0x98	; 152
    5a9e:	bd 4f       	sbci	r27, 0xFD	; 253
    5aa0:	8c 91       	ld	r24, X
    5aa2:	87 70       	andi	r24, 0x07	; 7
    5aa4:	89 2b       	or	r24, r25
    5aa6:	85 bd       	out	0x25, r24	; 37
  OCR0A   = F_CPU / ratio_base[prescaler_index] /CH_FREQUENCY - 1;
    5aa8:	ee 0f       	add	r30, r30
    5aaa:	ff 1f       	adc	r31, r31
    5aac:	e3 59       	subi	r30, 0x93	; 147
    5aae:	fd 4f       	sbci	r31, 0xFD	; 253
    5ab0:	20 81       	ld	r18, Z
    5ab2:	31 81       	ldd	r19, Z+1	; 0x01
    5ab4:	40 e0       	ldi	r20, 0x00	; 0
    5ab6:	50 e0       	ldi	r21, 0x00	; 0
    5ab8:	60 e8       	ldi	r22, 0x80	; 128
    5aba:	7e e3       	ldi	r23, 0x3E	; 62
    5abc:	80 e0       	ldi	r24, 0x00	; 0
    5abe:	90 e0       	ldi	r25, 0x00	; 0
    5ac0:	0e 94 ea 32 	call	0x65d4	; 0x65d4 <__udivmodsi4>
    5ac4:	21 50       	subi	r18, 0x01	; 1
    5ac6:	27 bd       	out	0x27, r18	; 39
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.   */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.   */
  TCCR0B  = (0 << WGM02) ;				 /* CTC mode.        */
             setClock();  			 
  
  TCNT0   = 0;                                           /* Reset counter.   */
    5ac8:	16 bc       	out	0x26, r1	; 38
  TIFR0   = (1 << OCF0A);                                /* Reset pending.   */
    5aca:	c5 bb       	out	0x15, r28	; 21
  TIMSK0  = (1 << OCIE0A);  
    5acc:	c0 93 6e 00 	sts	0x006E, r28
}
    5ad0:	cf 91       	pop	r28
    5ad2:	08 95       	ret

00005ad4 <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    5ad4:	fc 01       	movw	r30, r24

#if defined(PORTA) || defined(__DOXYGEN__)
  PORTA = config->porta.out;
    5ad6:	80 81       	ld	r24, Z
    5ad8:	82 b9       	out	0x02, r24	; 2
  DDRA = config->porta.dir;
    5ada:	81 81       	ldd	r24, Z+1	; 0x01
    5adc:	81 b9       	out	0x01, r24	; 1
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
    5ade:	82 81       	ldd	r24, Z+2	; 0x02
    5ae0:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
    5ae2:	83 81       	ldd	r24, Z+3	; 0x03
    5ae4:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
    5ae6:	84 81       	ldd	r24, Z+4	; 0x04
    5ae8:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
    5aea:	85 81       	ldd	r24, Z+5	; 0x05
    5aec:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
    5aee:	86 81       	ldd	r24, Z+6	; 0x06
    5af0:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
    5af2:	87 81       	ldd	r24, Z+7	; 0x07
    5af4:	8a b9       	out	0x0a, r24	; 10
#endif

#if defined(PORTE) || defined(__DOXYGEN__)
  PORTE = config->porte.out;
    5af6:	80 85       	ldd	r24, Z+8	; 0x08
    5af8:	8e b9       	out	0x0e, r24	; 14
  DDRE = config->porte.dir;
    5afa:	81 85       	ldd	r24, Z+9	; 0x09
    5afc:	8d b9       	out	0x0d, r24	; 13
#endif

#if defined(PORTF) || defined(__DOXYGEN__)
  PORTF = config->portf.out;
    5afe:	82 85       	ldd	r24, Z+10	; 0x0a
    5b00:	81 bb       	out	0x11, r24	; 17
  DDRF = config->portf.dir;
    5b02:	83 85       	ldd	r24, Z+11	; 0x0b
    5b04:	80 bb       	out	0x10, r24	; 16
#endif

#if defined(PORTG) || defined(__DOXYGEN__)
  PORTG = config->portg.out;
    5b06:	84 85       	ldd	r24, Z+12	; 0x0c
    5b08:	84 bb       	out	0x14, r24	; 20
  DDRG = config->portg.dir;
    5b0a:	85 85       	ldd	r24, Z+13	; 0x0d
    5b0c:	83 bb       	out	0x13, r24	; 19
#endif

#if defined(PORTH) || defined(__DOXYGEN__)
  PORTH = config->porth.out;
    5b0e:	86 85       	ldd	r24, Z+14	; 0x0e
    5b10:	80 93 02 01 	sts	0x0102, r24
  DDRH = config->porth.dir;
    5b14:	87 85       	ldd	r24, Z+15	; 0x0f
    5b16:	80 93 01 01 	sts	0x0101, r24
#endif

#if defined(PORTJ) || defined(__DOXYGEN__)
  PORTJ = config->portj.out;
    5b1a:	80 89       	ldd	r24, Z+16	; 0x10
    5b1c:	80 93 05 01 	sts	0x0105, r24
  DDRJ = config->portj.dir;
    5b20:	81 89       	ldd	r24, Z+17	; 0x11
    5b22:	80 93 04 01 	sts	0x0104, r24
#endif

#if defined(PORTK) || defined(__DOXYGEN__)
  PORTK = config->portk.out;
    5b26:	82 89       	ldd	r24, Z+18	; 0x12
    5b28:	80 93 08 01 	sts	0x0108, r24
  DDRK = config->portk.dir;
    5b2c:	83 89       	ldd	r24, Z+19	; 0x13
    5b2e:	80 93 07 01 	sts	0x0107, r24
#endif

#if defined(PORTL) || defined(__DOXYGEN__)
  PORTL = config->portl.out;
    5b32:	84 89       	ldd	r24, Z+20	; 0x14
    5b34:	80 93 0b 01 	sts	0x010B, r24
  DDRL = config->portl.dir;
    5b38:	85 89       	ldd	r24, Z+21	; 0x15
    5b3a:	80 93 0a 01 	sts	0x010A, r24
    5b3e:	08 95       	ret

00005b40 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    5b40:	fc 01       	movw	r30, r24

  switch (mode) {
    5b42:	42 30       	cpi	r20, 0x02	; 2
    5b44:	91 f0       	breq	.+36     	; 0x5b6a <_pal_lld_setgroupmode+0x2a>
    5b46:	78 f0       	brcs	.+30     	; 0x5b66 <_pal_lld_setgroupmode+0x26>
    5b48:	45 30       	cpi	r20, 0x05	; 5
    5b4a:	79 f0       	breq	.+30     	; 0x5b6a <_pal_lld_setgroupmode+0x2a>
    5b4c:	46 30       	cpi	r20, 0x06	; 6
    5b4e:	a9 f0       	breq	.+42     	; 0x5b7a <_pal_lld_setgroupmode+0x3a>
    5b50:	43 30       	cpi	r20, 0x03	; 3
    5b52:	b1 f4       	brne	.+44     	; 0x5b80 <_pal_lld_setgroupmode+0x40>
    port->dir &= ~mask;
    port->out &= ~mask;
	break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    5b54:	91 81       	ldd	r25, Z+1	; 0x01
    5b56:	86 2f       	mov	r24, r22
    5b58:	80 95       	com	r24
    5b5a:	89 23       	and	r24, r25
    5b5c:	81 83       	std	Z+1, r24	; 0x01
    port->out |= mask;
    5b5e:	82 81       	ldd	r24, Z+2	; 0x02
    5b60:	86 2b       	or	r24, r22
    5b62:	82 83       	std	Z+2, r24	; 0x02
    break;
    5b64:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
    5b66:	41 11       	cpse	r20, r1
    5b68:	0c c0       	rjmp	.+24     	; 0x5b82 <_pal_lld_setgroupmode+0x42>
  case PAL_MODE_RESET:
  case PAL_MODE_INPUT:
  case PAL_MODE_INPUT_ANALOG:
    port->dir &= ~mask;
    5b6a:	81 81       	ldd	r24, Z+1	; 0x01
    5b6c:	60 95       	com	r22
    5b6e:	86 23       	and	r24, r22
    5b70:	81 83       	std	Z+1, r24	; 0x01
    port->out &= ~mask;
    5b72:	82 81       	ldd	r24, Z+2	; 0x02
    5b74:	86 23       	and	r24, r22
    5b76:	82 83       	std	Z+2, r24	; 0x02
	break;
    5b78:	08 95       	ret
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    port->out |= mask;
    break;
  case PAL_MODE_OUTPUT_PUSHPULL:
    port->dir |= mask;
    5b7a:	81 81       	ldd	r24, Z+1	; 0x01
    5b7c:	86 2b       	or	r24, r22
    5b7e:	81 83       	std	Z+1, r24	; 0x01
    5b80:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
    5b82:	41 30       	cpi	r20, 0x01	; 1
    5b84:	39 f3       	breq	.-50     	; 0x5b54 <_pal_lld_setgroupmode+0x14>
    5b86:	08 95       	ret

00005b88 <notify1>:

#if USE_AVR_USART0 || defined(__DOXYGEN__)
static void notify1(GenericQueue *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
    5b88:	e1 ec       	ldi	r30, 0xC1	; 193
    5b8a:	f0 e0       	ldi	r31, 0x00	; 0
    5b8c:	80 81       	ld	r24, Z
    5b8e:	80 62       	ori	r24, 0x20	; 32
    5b90:	80 83       	st	Z, r24
    5b92:	08 95       	ret

00005b94 <__vector_25>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(USART0_RX_vect) {
    5b94:	1f 92       	push	r1
    5b96:	0f 92       	push	r0
    5b98:	0f b6       	in	r0, 0x3f	; 63
    5b9a:	0f 92       	push	r0
    5b9c:	11 24       	eor	r1, r1
    5b9e:	0b b6       	in	r0, 0x3b	; 59
    5ba0:	0f 92       	push	r0
    5ba2:	2f 93       	push	r18
    5ba4:	3f 93       	push	r19
    5ba6:	4f 93       	push	r20
    5ba8:	5f 93       	push	r21
    5baa:	6f 93       	push	r22
    5bac:	7f 93       	push	r23
    5bae:	8f 93       	push	r24
    5bb0:	9f 93       	push	r25
    5bb2:	af 93       	push	r26
    5bb4:	bf 93       	push	r27
    5bb6:	ef 93       	push	r30
    5bb8:	ff 93       	push	r31
  uint8_t sra;

  CH_IRQ_PROLOGUE();

  sra = UCSR0A;
    5bba:	80 91 c0 00 	lds	r24, 0x00C0
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    5bbe:	98 2f       	mov	r25, r24
    5bc0:	9c 71       	andi	r25, 0x1C	; 28
    5bc2:	f1 f4       	brne	.+60     	; 0x5c00 <__vector_25+0x6c>
    set_error(sra, &SD1);
  chSysLockFromIsr();
  sdIncomingDataI(&SD1, UDR0);
    5bc4:	60 91 c6 00 	lds	r22, 0x00C6
    5bc8:	8c e3       	ldi	r24, 0x3C	; 60
    5bca:	9f e0       	ldi	r25, 0x0F	; 15
    5bcc:	0e 94 f1 2c 	call	0x59e2	; 0x59e2 <sdIncomingDataI>
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
    5bd0:	0e 94 42 03 	call	0x684	; 0x684 <chSchIsPreemptionRequired>
    5bd4:	81 11       	cpse	r24, r1
    5bd6:	0e 94 e2 03 	call	0x7c4	; 0x7c4 <chSchDoReschedule>
}
    5bda:	ff 91       	pop	r31
    5bdc:	ef 91       	pop	r30
    5bde:	bf 91       	pop	r27
    5be0:	af 91       	pop	r26
    5be2:	9f 91       	pop	r25
    5be4:	8f 91       	pop	r24
    5be6:	7f 91       	pop	r23
    5be8:	6f 91       	pop	r22
    5bea:	5f 91       	pop	r21
    5bec:	4f 91       	pop	r20
    5bee:	3f 91       	pop	r19
    5bf0:	2f 91       	pop	r18
    5bf2:	0f 90       	pop	r0
    5bf4:	0b be       	out	0x3b, r0	; 59
    5bf6:	0f 90       	pop	r0
    5bf8:	0f be       	out	0x3f, r0	; 63
    5bfa:	0f 90       	pop	r0
    5bfc:	1f 90       	pop	r1
    5bfe:	18 95       	reti
    upe = (1 << UPE1);
    fe = (1 << FE1);
  }
#endif

  if (sra & dor)
    5c00:	83 fd       	sbrc	r24, 3
    5c02:	0a c0       	rjmp	.+20     	; 0x5c18 <__vector_25+0x84>
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void set_error(uint8_t sra, SerialDriver *sdp) {
  flagsmask_t sts = 0;
    5c04:	60 e0       	ldi	r22, 0x00	; 0
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    5c06:	82 fd       	sbrc	r24, 2
    sts |= SD_PARITY_ERROR;
    5c08:	60 62       	ori	r22, 0x20	; 32
  if (sra & fe)
    5c0a:	84 fd       	sbrc	r24, 4
    sts |= SD_FRAMING_ERROR;
    5c0c:	60 64       	ori	r22, 0x40	; 64
  chSysLockFromIsr();
  chnAddFlagsI(sdp, sts);
    5c0e:	8e e3       	ldi	r24, 0x3E	; 62
    5c10:	9f e0       	ldi	r25, 0x0F	; 15
    5c12:	0e 94 cf 09 	call	0x139e	; 0x139e <chEvtBroadcastFlagsI>
    5c16:	d6 cf       	rjmp	.-84     	; 0x5bc4 <__vector_25+0x30>
    fe = (1 << FE1);
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
    5c18:	60 e8       	ldi	r22, 0x80	; 128
    5c1a:	f5 cf       	rjmp	.-22     	; 0x5c06 <__vector_25+0x72>

00005c1c <__vector_26>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(USART0_UDRE_vect) {
    5c1c:	1f 92       	push	r1
    5c1e:	0f 92       	push	r0
    5c20:	0f b6       	in	r0, 0x3f	; 63
    5c22:	0f 92       	push	r0
    5c24:	11 24       	eor	r1, r1
    5c26:	0b b6       	in	r0, 0x3b	; 59
    5c28:	0f 92       	push	r0
    5c2a:	2f 93       	push	r18
    5c2c:	3f 93       	push	r19
    5c2e:	4f 93       	push	r20
    5c30:	5f 93       	push	r21
    5c32:	6f 93       	push	r22
    5c34:	7f 93       	push	r23
    5c36:	8f 93       	push	r24
    5c38:	9f 93       	push	r25
    5c3a:	af 93       	push	r26
    5c3c:	bf 93       	push	r27
    5c3e:	ef 93       	push	r30
    5c40:	ff 93       	push	r31
  msg_t b;

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
  b = sdRequestDataI(&SD1);
    5c42:	8c e3       	ldi	r24, 0x3C	; 60
    5c44:	9f e0       	ldi	r25, 0x0F	; 15
    5c46:	0e 94 19 2d 	call	0x5a32	; 0x5a32 <sdRequestDataI>
  chSysUnlockFromIsr();
  if (b < Q_OK)
    5c4a:	97 fd       	sbrc	r25, 7
    5c4c:	1a c0       	rjmp	.+52     	; 0x5c82 <__vector_26+0x66>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
    5c4e:	80 93 c6 00 	sts	0x00C6, r24

  CH_IRQ_EPILOGUE();
    5c52:	0e 94 42 03 	call	0x684	; 0x684 <chSchIsPreemptionRequired>
    5c56:	81 11       	cpse	r24, r1
    5c58:	0e 94 e2 03 	call	0x7c4	; 0x7c4 <chSchDoReschedule>
}
    5c5c:	ff 91       	pop	r31
    5c5e:	ef 91       	pop	r30
    5c60:	bf 91       	pop	r27
    5c62:	af 91       	pop	r26
    5c64:	9f 91       	pop	r25
    5c66:	8f 91       	pop	r24
    5c68:	7f 91       	pop	r23
    5c6a:	6f 91       	pop	r22
    5c6c:	5f 91       	pop	r21
    5c6e:	4f 91       	pop	r20
    5c70:	3f 91       	pop	r19
    5c72:	2f 91       	pop	r18
    5c74:	0f 90       	pop	r0
    5c76:	0b be       	out	0x3b, r0	; 59
    5c78:	0f 90       	pop	r0
    5c7a:	0f be       	out	0x3f, r0	; 63
    5c7c:	0f 90       	pop	r0
    5c7e:	1f 90       	pop	r1
    5c80:	18 95       	reti

  chSysLockFromIsr();
  b = sdRequestDataI(&SD1);
  chSysUnlockFromIsr();
  if (b < Q_OK)
    UCSR0B &= ~(1 << UDRIE0);
    5c82:	80 91 c1 00 	lds	r24, 0x00C1
    5c86:	8f 7d       	andi	r24, 0xDF	; 223
    5c88:	80 93 c1 00 	sts	0x00C1, r24
    5c8c:	e2 cf       	rjmp	.-60     	; 0x5c52 <__vector_26+0x36>

00005c8e <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if USE_AVR_USART0
  sdObjectInit(&SD1, NULL, notify1);
    5c8e:	44 ec       	ldi	r20, 0xC4	; 196
    5c90:	5d e2       	ldi	r21, 0x2D	; 45
    5c92:	60 e0       	ldi	r22, 0x00	; 0
    5c94:	70 e0       	ldi	r23, 0x00	; 0
    5c96:	8c e3       	ldi	r24, 0x3C	; 60
    5c98:	9f e0       	ldi	r25, 0x0F	; 15
    5c9a:	0c 94 a2 2c 	jmp	0x5944	; 0x5944 <sdObjectInit>

00005c9e <sd_lld_start>:
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    5c9e:	61 15       	cp	r22, r1
    5ca0:	71 05       	cpc	r23, r1
    5ca2:	e1 f0       	breq	.+56     	; 0x5cdc <sd_lld_start+0x3e>
    config = &default_config;

#if USE_AVR_USART0
  if (&SD1 == sdp) {
    5ca4:	8c 53       	subi	r24, 0x3C	; 60
    5ca6:	9f 40       	sbci	r25, 0x0F	; 15
    5ca8:	09 f0       	breq	.+2      	; 0x5cac <sd_lld_start+0xe>
    5caa:	08 95       	ret
 *
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart0_init(const SerialConfig *config) {

  UBRR0L = config->sc_brr;
    5cac:	fb 01       	movw	r30, r22
    5cae:	80 81       	ld	r24, Z
    5cb0:	80 93 c4 00 	sts	0x00C4, r24
  UBRR0H = config->sc_brr >> 8;
    5cb4:	81 81       	ldd	r24, Z+1	; 0x01
    5cb6:	80 93 c5 00 	sts	0x00C5, r24
  UCSR0A = 0;
    5cba:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    5cbe:	88 e9       	ldi	r24, 0x98	; 152
    5cc0:	80 93 c1 00 	sts	0x00C1, r24
  switch (config->sc_bits_per_char) {
    5cc4:	82 81       	ldd	r24, Z+2	; 0x02
    5cc6:	81 30       	cpi	r24, 0x01	; 1
    5cc8:	79 f0       	breq	.+30     	; 0x5ce8 <sd_lld_start+0x4a>
    5cca:	58 f0       	brcs	.+22     	; 0x5ce2 <sd_lld_start+0x44>
    5ccc:	82 30       	cpi	r24, 0x02	; 2
    5cce:	c9 f0       	breq	.+50     	; 0x5d02 <sd_lld_start+0x64>
    5cd0:	84 30       	cpi	r24, 0x04	; 4
    5cd2:	71 f0       	breq	.+28     	; 0x5cf0 <sd_lld_start+0x52>
    UCSR0B |= (1 << UCSZ02);
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_8:
  default:
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    5cd4:	86 e0       	ldi	r24, 0x06	; 6
    5cd6:	80 93 c2 00 	sts	0x00C2, r24
    5cda:	08 95       	ret
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
    5cdc:	63 e4       	ldi	r22, 0x43	; 67
    5cde:	74 e0       	ldi	r23, 0x04	; 4
    5ce0:	e1 cf       	rjmp	.-62     	; 0x5ca4 <sd_lld_start+0x6>
  UBRR0H = config->sc_brr >> 8;
  UCSR0A = 0;
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
  switch (config->sc_bits_per_char) {
  case USART_CHAR_SIZE_5:
    UCSR0C = 0;
    5ce2:	10 92 c2 00 	sts	0x00C2, r1
    5ce6:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    UCSR0C = (1 << UCSZ00);
    5ce8:	82 e0       	ldi	r24, 0x02	; 2
    5cea:	80 93 c2 00 	sts	0x00C2, r24
    5cee:	08 95       	ret
    break;
  case USART_CHAR_SIZE_7:
    UCSR0C = (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_9:
    UCSR0B |= (1 << UCSZ02);
    5cf0:	80 91 c1 00 	lds	r24, 0x00C1
    5cf4:	84 60       	ori	r24, 0x04	; 4
    5cf6:	80 93 c1 00 	sts	0x00C1, r24
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    5cfa:	86 e0       	ldi	r24, 0x06	; 6
    5cfc:	80 93 c2 00 	sts	0x00C2, r24
    5d00:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    UCSR0C = (1 << UCSZ00);
    break;
  case USART_CHAR_SIZE_7:
    UCSR0C = (1 << UCSZ01);
    5d02:	84 e0       	ldi	r24, 0x04	; 4
    5d04:	80 93 c2 00 	sts	0x00C2, r24
    5d08:	08 95       	ret

00005d0a <sd_lld_stop>:
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {

#if USE_AVR_USART0
  if (&SD1 == sdp)
    5d0a:	8c 53       	subi	r24, 0x3C	; 60
    5d0c:	9f 40       	sbci	r25, 0x0F	; 15
    5d0e:	09 f0       	breq	.+2      	; 0x5d12 <sd_lld_stop+0x8>
    5d10:	08 95       	ret
/**
 * @brief   USART0 de-initialization.
 */
static void usart0_deinit(void) {

  UCSR0A = 0;
    5d12:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = 0;
    5d16:	10 92 c1 00 	sts	0x00C1, r1
  UCSR0C = 0;
    5d1a:	10 92 c2 00 	sts	0x00C2, r1
    5d1e:	08 95       	ret

00005d20 <findBestPrescaler>:
uint16_t ratio_extended[]={1024,256,128,64,32,8,1};
uint8_t clock_source_extended[]={7,6,5,4,3,2,1};


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
{
    5d20:	4f 92       	push	r4
    5d22:	5f 92       	push	r5
    5d24:	6f 92       	push	r6
    5d26:	7f 92       	push	r7
    5d28:	8f 92       	push	r8
    5d2a:	9f 92       	push	r9
    5d2c:	af 92       	push	r10
    5d2e:	bf 92       	push	r11
    5d30:	cf 92       	push	r12
    5d32:	df 92       	push	r13
    5d34:	ef 92       	push	r14
    5d36:	ff 92       	push	r15
    5d38:	0f 93       	push	r16
    5d3a:	1f 93       	push	r17
    5d3c:	cf 93       	push	r28
    5d3e:	df 93       	push	r29
    5d40:	5c 01       	movw	r10, r24
    5d42:	eb 01       	movw	r28, r22
    5d44:	82 2e       	mov	r8, r18
  uint8_t i;
  for(i=0;i<n;i++)
    5d46:	22 23       	and	r18, r18
    5d48:	09 f4       	brne	.+2      	; 0x5d4c <findBestPrescaler+0x2c>
    5d4a:	5f c0       	rjmp	.+190    	; 0x5e0a <findBestPrescaler+0xea>
  {
    uint32_t result = F_CPU/ratio[i]/frequency;
    5d4c:	08 81       	ld	r16, Y
    5d4e:	19 81       	ldd	r17, Y+1	; 0x01
    5d50:	6c 01       	movw	r12, r24
    5d52:	e1 2c       	mov	r14, r1
    5d54:	f1 2c       	mov	r15, r1
    5d56:	98 01       	movw	r18, r16
    5d58:	40 e0       	ldi	r20, 0x00	; 0
    5d5a:	50 e0       	ldi	r21, 0x00	; 0
    5d5c:	60 e0       	ldi	r22, 0x00	; 0
    5d5e:	74 e2       	ldi	r23, 0x24	; 36
    5d60:	84 ef       	ldi	r24, 0xF4	; 244
    5d62:	90 e0       	ldi	r25, 0x00	; 0
    5d64:	0e 94 ea 32 	call	0x65d4	; 0x65d4 <__udivmodsi4>
    5d68:	ca 01       	movw	r24, r20
    5d6a:	b9 01       	movw	r22, r18
    5d6c:	a7 01       	movw	r20, r14
    5d6e:	96 01       	movw	r18, r12
    5d70:	0e 94 ea 32 	call	0x65d4	; 0x65d4 <__udivmodsi4>
    5d74:	29 01       	movw	r4, r18
    5d76:	3a 01       	movw	r6, r20
    if(result > 256UL)
    5d78:	21 e0       	ldi	r18, 0x01	; 1
    5d7a:	42 16       	cp	r4, r18
    5d7c:	52 06       	cpc	r5, r18
    5d7e:	61 04       	cpc	r6, r1
    5d80:	71 04       	cpc	r7, r1
    5d82:	08 f0       	brcs	.+2      	; 0x5d86 <findBestPrescaler+0x66>
    5d84:	58 c0       	rjmp	.+176    	; 0x5e36 <findBestPrescaler+0x116>
       return (i-1);
    if(result * ratio[i] * frequency == F_CPU)
    5d86:	98 01       	movw	r18, r16
    5d88:	d5 01       	movw	r26, r10
    5d8a:	0e 94 ce 32 	call	0x659c	; 0x659c <__umulhisi3>
    5d8e:	9b 01       	movw	r18, r22
    5d90:	ac 01       	movw	r20, r24
    5d92:	c3 01       	movw	r24, r6
    5d94:	b2 01       	movw	r22, r4
    5d96:	0e 94 da 32 	call	0x65b4	; 0x65b4 <__mulsi3>
    5d9a:	61 15       	cp	r22, r1
    5d9c:	74 42       	sbci	r23, 0x24	; 36
    5d9e:	84 4f       	sbci	r24, 0xF4	; 244
    5da0:	91 05       	cpc	r25, r1
    5da2:	09 f4       	brne	.+2      	; 0x5da6 <findBestPrescaler+0x86>
    5da4:	46 c0       	rjmp	.+140    	; 0x5e32 <findBestPrescaler+0x112>
uint8_t clock_source_base[]={5,4,3,2,1};
uint16_t ratio_extended[]={1024,256,128,64,32,8,1};
uint8_t clock_source_extended[]={7,6,5,4,3,2,1};


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
    5da6:	8e 01       	movw	r16, r28
    5da8:	0e 5f       	subi	r16, 0xFE	; 254
    5daa:	1f 4f       	sbci	r17, 0xFF	; 255
{
  uint8_t i;
  for(i=0;i<n;i++)
    5dac:	91 2c       	mov	r9, r1
    5dae:	2a c0       	rjmp	.+84     	; 0x5e04 <findBestPrescaler+0xe4>
  {
    uint32_t result = F_CPU/ratio[i]/frequency;
    5db0:	f8 01       	movw	r30, r16
    5db2:	c1 91       	ld	r28, Z+
    5db4:	d1 91       	ld	r29, Z+
    5db6:	8f 01       	movw	r16, r30
    5db8:	9e 01       	movw	r18, r28
    5dba:	40 e0       	ldi	r20, 0x00	; 0
    5dbc:	50 e0       	ldi	r21, 0x00	; 0
    5dbe:	60 e0       	ldi	r22, 0x00	; 0
    5dc0:	74 e2       	ldi	r23, 0x24	; 36
    5dc2:	84 ef       	ldi	r24, 0xF4	; 244
    5dc4:	90 e0       	ldi	r25, 0x00	; 0
    5dc6:	0e 94 ea 32 	call	0x65d4	; 0x65d4 <__udivmodsi4>
    5dca:	ca 01       	movw	r24, r20
    5dcc:	b9 01       	movw	r22, r18
    5dce:	a7 01       	movw	r20, r14
    5dd0:	96 01       	movw	r18, r12
    5dd2:	0e 94 ea 32 	call	0x65d4	; 0x65d4 <__udivmodsi4>
    5dd6:	29 01       	movw	r4, r18
    5dd8:	3a 01       	movw	r6, r20
    if(result > 256UL)
    5dda:	21 30       	cpi	r18, 0x01	; 1
    5ddc:	f1 e0       	ldi	r31, 0x01	; 1
    5dde:	3f 07       	cpc	r19, r31
    5de0:	41 05       	cpc	r20, r1
    5de2:	51 05       	cpc	r21, r1
    5de4:	98 f4       	brcc	.+38     	; 0x5e0c <findBestPrescaler+0xec>
       return (i-1);
    if(result * ratio[i] * frequency == F_CPU)
    5de6:	9e 01       	movw	r18, r28
    5de8:	d5 01       	movw	r26, r10
    5dea:	0e 94 ce 32 	call	0x659c	; 0x659c <__umulhisi3>
    5dee:	9b 01       	movw	r18, r22
    5df0:	ac 01       	movw	r20, r24
    5df2:	c3 01       	movw	r24, r6
    5df4:	b2 01       	movw	r22, r4
    5df6:	0e 94 da 32 	call	0x65b4	; 0x65b4 <__mulsi3>
    5dfa:	61 15       	cp	r22, r1
    5dfc:	74 42       	sbci	r23, 0x24	; 36
    5dfe:	84 4f       	sbci	r24, 0xF4	; 244
    5e00:	91 05       	cpc	r25, r1
    5e02:	29 f0       	breq	.+10     	; 0x5e0e <findBestPrescaler+0xee>


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
{
  uint8_t i;
  for(i=0;i<n;i++)
    5e04:	93 94       	inc	r9
    5e06:	98 10       	cpse	r9, r8
    5e08:	d3 cf       	rjmp	.-90     	; 0x5db0 <findBestPrescaler+0x90>
    5e0a:	02 c0       	rjmp	.+4      	; 0x5e10 <findBestPrescaler+0xf0>
    5e0c:	9a 94       	dec	r9
    5e0e:	89 2d       	mov	r24, r9
       return (i-1);
    if(result * ratio[i] * frequency == F_CPU)
      return i;
  };
  
    5e10:	df 91       	pop	r29
    5e12:	cf 91       	pop	r28
    5e14:	1f 91       	pop	r17
    5e16:	0f 91       	pop	r16
    5e18:	ff 90       	pop	r15
    5e1a:	ef 90       	pop	r14
    5e1c:	df 90       	pop	r13
    5e1e:	cf 90       	pop	r12
    5e20:	bf 90       	pop	r11
    5e22:	af 90       	pop	r10
    5e24:	9f 90       	pop	r9
    5e26:	8f 90       	pop	r8
    5e28:	7f 90       	pop	r7
    5e2a:	6f 90       	pop	r6
    5e2c:	5f 90       	pop	r5
    5e2e:	4f 90       	pop	r4
    5e30:	08 95       	ret


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
{
  uint8_t i;
  for(i=0;i<n;i++)
    5e32:	91 2c       	mov	r9, r1
    5e34:	ec cf       	rjmp	.-40     	; 0x5e0e <findBestPrescaler+0xee>
  {
    uint32_t result = F_CPU/ratio[i]/frequency;
    if(result > 256UL)
    5e36:	99 24       	eor	r9, r9
    5e38:	9a 94       	dec	r9
       return (i-1);
    5e3a:	e9 cf       	rjmp	.-46     	; 0x5e0e <findBestPrescaler+0xee>

00005e3c <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
    5e3c:	10 92 69 00 	sts	0x0069, r1
  EICRB  = 0x00;
    5e40:	10 92 6a 00 	sts	0x006A, r1
  EIMSK  = 0x00;
    5e44:	1d ba       	out	0x1d, r1	; 29

  /*
   * Timer 0 setup.
   */
  TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.        */
    5e46:	82 e0       	ldi	r24, 0x02	; 2
    5e48:	84 bd       	out	0x24, r24	; 36
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.   */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.   */
  TCCR0B  = (0 << WGM02) |                               /* CTC mode.        */
    5e4a:	93 e0       	ldi	r25, 0x03	; 3
    5e4c:	95 bd       	out	0x25, r25	; 37
            (0 << CS02)  | (1 << CS01)  | (1 << CS00);   /* CLK/64 clock.    */
  OCR0A   = F_CPU / 64 / CH_FREQUENCY - 1;
    5e4e:	99 ef       	ldi	r25, 0xF9	; 249
    5e50:	97 bd       	out	0x27, r25	; 39
  TCNT0   = 0;                                           /* Reset counter.   */
    5e52:	16 bc       	out	0x26, r1	; 38
  TIFR0   = (1 << OCF0A);                                /* Reset pending.   */
    5e54:	85 bb       	out	0x15, r24	; 21
  TIMSK0  = (1 << OCIE0A);                               /* IRQ on compare.  */
    5e56:	80 93 6e 00 	sts	0x006E, r24
    5e5a:	08 95       	ret

00005e5c <tmrcb>:
 */

#include "ch.h"
#include "evtimer.h"

static void tmrcb(void *p) {
    5e5c:	cf 93       	push	r28
    5e5e:	df 93       	push	r29
    5e60:	ec 01       	movw	r28, r24
  EvTimer *etp = p;

  chSysLockFromIsr();
  chEvtBroadcastI(&etp->et_es);
    5e62:	60 e0       	ldi	r22, 0x00	; 0
    5e64:	0a 96       	adiw	r24, 0x0a	; 10
    5e66:	0e 94 cf 09 	call	0x139e	; 0x139e <chEvtBroadcastFlagsI>
  chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    5e6a:	6c 85       	ldd	r22, Y+12	; 0x0c
    5e6c:	7d 85       	ldd	r23, Y+13	; 0x0d
    5e6e:	9e 01       	movw	r18, r28
    5e70:	4e e2       	ldi	r20, 0x2E	; 46
    5e72:	5f e2       	ldi	r21, 0x2F	; 47
    5e74:	ce 01       	movw	r24, r28
  chSysUnlockFromIsr();
}
    5e76:	df 91       	pop	r29
    5e78:	cf 91       	pop	r28
static void tmrcb(void *p) {
  EvTimer *etp = p;

  chSysLockFromIsr();
  chEvtBroadcastI(&etp->et_es);
  chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    5e7a:	0c 94 a3 01 	jmp	0x346	; 0x346 <chVTSetI>

00005e7e <evtStart>:
 *
 * @param etp pointer to an initialized @p EvTimer structure.
 */
void evtStart(EvTimer *etp) {

  chSysLock();
    5e7e:	f8 94       	cli

  if (!chVTIsArmedI(&etp->et_vt))
    5e80:	fc 01       	movw	r30, r24
    5e82:	26 81       	ldd	r18, Z+6	; 0x06
    5e84:	37 81       	ldd	r19, Z+7	; 0x07
    5e86:	23 2b       	or	r18, r19
    5e88:	11 f0       	breq	.+4      	; 0x5e8e <evtStart+0x10>
    chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);

  chSysUnlock();
    5e8a:	78 94       	sei
    5e8c:	08 95       	ret
void evtStart(EvTimer *etp) {

  chSysLock();

  if (!chVTIsArmedI(&etp->et_vt))
    chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    5e8e:	64 85       	ldd	r22, Z+12	; 0x0c
    5e90:	75 85       	ldd	r23, Z+13	; 0x0d
    5e92:	9c 01       	movw	r18, r24
    5e94:	4e e2       	ldi	r20, 0x2E	; 46
    5e96:	5f e2       	ldi	r21, 0x2F	; 47
    5e98:	0e 94 a3 01 	call	0x346	; 0x346 <chVTSetI>

  chSysUnlock();
    5e9c:	78 94       	sei
    5e9e:	08 95       	ret

00005ea0 <evtStop>:
 *
 * @param etp pointer to an initialized @p EvTimer structure.
 */
void evtStop(EvTimer *etp) {

  chVTReset(&etp->et_vt);
    5ea0:	f8 94       	cli
    5ea2:	fc 01       	movw	r30, r24
    5ea4:	26 81       	ldd	r18, Z+6	; 0x06
    5ea6:	37 81       	ldd	r19, Z+7	; 0x07
    5ea8:	23 2b       	or	r18, r19
    5eaa:	11 f0       	breq	.+4      	; 0x5eb0 <evtStop+0x10>
    5eac:	0e 94 df 01 	call	0x3be	; 0x3be <chVTResetI>
    5eb0:	78 94       	sei
    5eb2:	08 95       	ret

00005eb4 <Thread1>:

static WORKING_AREA(waThread1, 32);
static msg_t Thread1(void *arg) {

  while (TRUE) {
    palTogglePad(IOPORT2, PORTB_LED1);
    5eb4:	85 b1       	in	r24, 0x05	; 5
    5eb6:	80 58       	subi	r24, 0x80	; 128
    5eb8:	85 b9       	out	0x05, r24	; 5
    chThdSleepMilliseconds(1000);
    5eba:	88 ee       	ldi	r24, 0xE8	; 232
    5ebc:	93 e0       	ldi	r25, 0x03	; 3
    5ebe:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
    5ec2:	f8 cf       	rjmp	.-16     	; 0x5eb4 <Thread1>

00005ec4 <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
    5ec4:	0e 94 40 2c 	call	0x5880	; 0x5880 <halInit>
  chSysInit();
    5ec8:	0e 94 12 01 	call	0x224	; 0x224 <chSysInit>

  /*
   * Activates the serial driver 1 using the driver default configuration.
   */
  palClearPad(IOPORT2, PORTB_LED1);
    5ecc:	2f 98       	cbi	0x05, 7	; 5
  sdStart(&SD1, NULL);
    5ece:	60 e0       	ldi	r22, 0x00	; 0
    5ed0:	70 e0       	ldi	r23, 0x00	; 0
    5ed2:	8c e3       	ldi	r24, 0x3C	; 60
    5ed4:	9f e0       	ldi	r25, 0x0F	; 15
    5ed6:	0e 94 cf 2c 	call	0x599e	; 0x599e <sdStart>

  /*
   * Starts the LED blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
    5eda:	00 e0       	ldi	r16, 0x00	; 0
    5edc:	10 e0       	ldi	r17, 0x00	; 0
    5ede:	2a e5       	ldi	r18, 0x5A	; 90
    5ee0:	3f e2       	ldi	r19, 0x2F	; 47
    5ee2:	40 e4       	ldi	r20, 0x40	; 64
    5ee4:	67 e8       	ldi	r22, 0x87	; 135
    5ee6:	70 e0       	ldi	r23, 0x00	; 0
    5ee8:	83 e3       	ldi	r24, 0x33	; 51
    5eea:	9b e0       	ldi	r25, 0x0B	; 11
    5eec:	0e 94 71 04 	call	0x8e2	; 0x8e2 <chThdCreateStatic>

  TestThread(&SD1);
    5ef0:	8c e3       	ldi	r24, 0x3C	; 60
    5ef2:	9f e0       	ldi	r25, 0x0F	; 15
    5ef4:	0e 94 a0 10 	call	0x2140	; 0x2140 <TestThread>
  while(TRUE) {
    chThdSleepMilliseconds(1000);
    5ef8:	88 ee       	ldi	r24, 0xE8	; 232
    5efa:	93 e0       	ldi	r25, 0x03	; 3
    5efc:	0e 94 aa 04 	call	0x954	; 0x954 <chThdSleep>
    5f00:	fb cf       	rjmp	.-10     	; 0x5ef8 <main+0x34>

00005f02 <vfprintf>:
    5f02:	6f 92       	push	r6
    5f04:	7f 92       	push	r7
    5f06:	8f 92       	push	r8
    5f08:	9f 92       	push	r9
    5f0a:	af 92       	push	r10
    5f0c:	bf 92       	push	r11
    5f0e:	cf 92       	push	r12
    5f10:	df 92       	push	r13
    5f12:	ef 92       	push	r14
    5f14:	ff 92       	push	r15
    5f16:	0f 93       	push	r16
    5f18:	1f 93       	push	r17
    5f1a:	cf 93       	push	r28
    5f1c:	df 93       	push	r29
    5f1e:	cd b7       	in	r28, 0x3d	; 61
    5f20:	de b7       	in	r29, 0x3e	; 62
    5f22:	2c 97       	sbiw	r28, 0x0c	; 12
    5f24:	0f b6       	in	r0, 0x3f	; 63
    5f26:	f8 94       	cli
    5f28:	de bf       	out	0x3e, r29	; 62
    5f2a:	0f be       	out	0x3f, r0	; 63
    5f2c:	cd bf       	out	0x3d, r28	; 61
    5f2e:	6c 01       	movw	r12, r24
    5f30:	3b 01       	movw	r6, r22
    5f32:	8a 01       	movw	r16, r20
    5f34:	fc 01       	movw	r30, r24
    5f36:	17 82       	std	Z+7, r1	; 0x07
    5f38:	16 82       	std	Z+6, r1	; 0x06
    5f3a:	83 81       	ldd	r24, Z+3	; 0x03
    5f3c:	81 fd       	sbrc	r24, 1
    5f3e:	03 c0       	rjmp	.+6      	; 0x5f46 <vfprintf+0x44>
    5f40:	1f c1       	rjmp	.+574    	; 0x6180 <vfprintf+0x27e>
    5f42:	85 01       	movw	r16, r10
    5f44:	04 c0       	rjmp	.+8      	; 0x5f4e <vfprintf+0x4c>
    5f46:	4e 01       	movw	r8, r28
    5f48:	08 94       	sec
    5f4a:	81 1c       	adc	r8, r1
    5f4c:	91 1c       	adc	r9, r1
    5f4e:	f6 01       	movw	r30, r12
    5f50:	e3 80       	ldd	r14, Z+3	; 0x03
    5f52:	f3 01       	movw	r30, r6
    5f54:	e3 fc       	sbrc	r14, 3
    5f56:	85 91       	lpm	r24, Z+
    5f58:	e3 fe       	sbrs	r14, 3
    5f5a:	81 91       	ld	r24, Z+
    5f5c:	3f 01       	movw	r6, r30
    5f5e:	88 23       	and	r24, r24
    5f60:	09 f4       	brne	.+2      	; 0x5f64 <vfprintf+0x62>
    5f62:	0a c1       	rjmp	.+532    	; 0x6178 <vfprintf+0x276>
    5f64:	85 32       	cpi	r24, 0x25	; 37
    5f66:	39 f4       	brne	.+14     	; 0x5f76 <vfprintf+0x74>
    5f68:	e3 fc       	sbrc	r14, 3
    5f6a:	25 91       	lpm	r18, Z+
    5f6c:	e3 fe       	sbrs	r14, 3
    5f6e:	21 91       	ld	r18, Z+
    5f70:	3f 01       	movw	r6, r30
    5f72:	25 32       	cpi	r18, 0x25	; 37
    5f74:	19 f5       	brne	.+70     	; 0x5fbc <vfprintf+0xba>
    5f76:	90 e0       	ldi	r25, 0x00	; 0
    5f78:	b6 01       	movw	r22, r12
    5f7a:	0e 94 6a 33 	call	0x66d4	; 0x66d4 <fputc>
    5f7e:	58 01       	movw	r10, r16
    5f80:	e0 cf       	rjmp	.-64     	; 0x5f42 <vfprintf+0x40>
    5f82:	22 23       	and	r18, r18
    5f84:	09 f4       	brne	.+2      	; 0x5f88 <vfprintf+0x86>
    5f86:	f8 c0       	rjmp	.+496    	; 0x6178 <vfprintf+0x276>
    5f88:	84 ee       	ldi	r24, 0xE4	; 228
    5f8a:	90 e0       	ldi	r25, 0x00	; 0
    5f8c:	62 2f       	mov	r22, r18
    5f8e:	70 e0       	ldi	r23, 0x00	; 0
    5f90:	2c 87       	std	Y+12, r18	; 0x0c
    5f92:	0e 94 1f 33 	call	0x663e	; 0x663e <strchr_P>
    5f96:	2c 85       	ldd	r18, Y+12	; 0x0c
    5f98:	00 97       	sbiw	r24, 0x00	; 0
    5f9a:	49 f4       	brne	.+18     	; 0x5fae <vfprintf+0xac>
    5f9c:	23 32       	cpi	r18, 0x23	; 35
    5f9e:	19 f4       	brne	.+6      	; 0x5fa6 <vfprintf+0xa4>
    5fa0:	f0 e1       	ldi	r31, 0x10	; 16
    5fa2:	ff 2a       	or	r15, r31
    5fa4:	04 c0       	rjmp	.+8      	; 0x5fae <vfprintf+0xac>
    5fa6:	2c 36       	cpi	r18, 0x6C	; 108
    5fa8:	79 f4       	brne	.+30     	; 0x5fc8 <vfprintf+0xc6>
    5faa:	20 e8       	ldi	r18, 0x80	; 128
    5fac:	f2 2a       	or	r15, r18
    5fae:	f3 01       	movw	r30, r6
    5fb0:	e3 fc       	sbrc	r14, 3
    5fb2:	25 91       	lpm	r18, Z+
    5fb4:	e3 fe       	sbrs	r14, 3
    5fb6:	21 91       	ld	r18, Z+
    5fb8:	3f 01       	movw	r6, r30
    5fba:	01 c0       	rjmp	.+2      	; 0x5fbe <vfprintf+0xbc>
    5fbc:	ff 24       	eor	r15, r15
    5fbe:	f7 fe       	sbrs	r15, 7
    5fc0:	e0 cf       	rjmp	.-64     	; 0x5f82 <vfprintf+0x80>
    5fc2:	22 23       	and	r18, r18
    5fc4:	09 f4       	brne	.+2      	; 0x5fc8 <vfprintf+0xc6>
    5fc6:	d8 c0       	rjmp	.+432    	; 0x6178 <vfprintf+0x276>
    5fc8:	84 ef       	ldi	r24, 0xF4	; 244
    5fca:	90 e0       	ldi	r25, 0x00	; 0
    5fcc:	62 2f       	mov	r22, r18
    5fce:	70 e0       	ldi	r23, 0x00	; 0
    5fd0:	2c 87       	std	Y+12, r18	; 0x0c
    5fd2:	0e 94 1f 33 	call	0x663e	; 0x663e <strchr_P>
    5fd6:	2c 85       	ldd	r18, Y+12	; 0x0c
    5fd8:	00 97       	sbiw	r24, 0x00	; 0
    5fda:	41 f0       	breq	.+16     	; 0x5fec <vfprintf+0xea>
    5fdc:	64 e0       	ldi	r22, 0x04	; 4
    5fde:	a6 2e       	mov	r10, r22
    5fe0:	b1 2c       	mov	r11, r1
    5fe2:	a0 0e       	add	r10, r16
    5fe4:	b1 1e       	adc	r11, r17
    5fe6:	8f e3       	ldi	r24, 0x3F	; 63
    5fe8:	90 e0       	ldi	r25, 0x00	; 0
    5fea:	0f c0       	rjmp	.+30     	; 0x600a <vfprintf+0x108>
    5fec:	23 36       	cpi	r18, 0x63	; 99
    5fee:	29 f0       	breq	.+10     	; 0x5ffa <vfprintf+0xf8>
    5ff0:	23 37       	cpi	r18, 0x73	; 115
    5ff2:	89 f0       	breq	.+34     	; 0x6016 <vfprintf+0x114>
    5ff4:	23 35       	cpi	r18, 0x53	; 83
    5ff6:	29 f5       	brne	.+74     	; 0x6042 <vfprintf+0x140>
    5ff8:	0c c0       	rjmp	.+24     	; 0x6012 <vfprintf+0x110>
    5ffa:	52 e0       	ldi	r21, 0x02	; 2
    5ffc:	a5 2e       	mov	r10, r21
    5ffe:	b1 2c       	mov	r11, r1
    6000:	a0 0e       	add	r10, r16
    6002:	b1 1e       	adc	r11, r17
    6004:	f8 01       	movw	r30, r16
    6006:	80 81       	ld	r24, Z
    6008:	91 81       	ldd	r25, Z+1	; 0x01
    600a:	b6 01       	movw	r22, r12
    600c:	0e 94 6a 33 	call	0x66d4	; 0x66d4 <fputc>
    6010:	98 cf       	rjmp	.-208    	; 0x5f42 <vfprintf+0x40>
    6012:	f1 e0       	ldi	r31, 0x01	; 1
    6014:	ff 2a       	or	r15, r31
    6016:	42 e0       	ldi	r20, 0x02	; 2
    6018:	a4 2e       	mov	r10, r20
    601a:	b1 2c       	mov	r11, r1
    601c:	a0 0e       	add	r10, r16
    601e:	b1 1e       	adc	r11, r17
    6020:	f8 01       	movw	r30, r16
    6022:	00 81       	ld	r16, Z
    6024:	11 81       	ldd	r17, Z+1	; 0x01
    6026:	04 c0       	rjmp	.+8      	; 0x6030 <vfprintf+0x12e>
    6028:	90 e0       	ldi	r25, 0x00	; 0
    602a:	b6 01       	movw	r22, r12
    602c:	0e 94 6a 33 	call	0x66d4	; 0x66d4 <fputc>
    6030:	f8 01       	movw	r30, r16
    6032:	f0 fc       	sbrc	r15, 0
    6034:	85 91       	lpm	r24, Z+
    6036:	f0 fe       	sbrs	r15, 0
    6038:	81 91       	ld	r24, Z+
    603a:	8f 01       	movw	r16, r30
    603c:	88 23       	and	r24, r24
    603e:	a1 f7       	brne	.-24     	; 0x6028 <vfprintf+0x126>
    6040:	80 cf       	rjmp	.-256    	; 0x5f42 <vfprintf+0x40>
    6042:	24 36       	cpi	r18, 0x64	; 100
    6044:	11 f0       	breq	.+4      	; 0x604a <vfprintf+0x148>
    6046:	29 36       	cpi	r18, 0x69	; 105
    6048:	61 f5       	brne	.+88     	; 0x60a2 <vfprintf+0x1a0>
    604a:	f7 fe       	sbrs	r15, 7
    604c:	0b c0       	rjmp	.+22     	; 0x6064 <vfprintf+0x162>
    604e:	34 e0       	ldi	r19, 0x04	; 4
    6050:	a3 2e       	mov	r10, r19
    6052:	b1 2c       	mov	r11, r1
    6054:	a0 0e       	add	r10, r16
    6056:	b1 1e       	adc	r11, r17
    6058:	f8 01       	movw	r30, r16
    605a:	80 81       	ld	r24, Z
    605c:	91 81       	ldd	r25, Z+1	; 0x01
    605e:	a2 81       	ldd	r26, Z+2	; 0x02
    6060:	b3 81       	ldd	r27, Z+3	; 0x03
    6062:	0c c0       	rjmp	.+24     	; 0x607c <vfprintf+0x17a>
    6064:	22 e0       	ldi	r18, 0x02	; 2
    6066:	a2 2e       	mov	r10, r18
    6068:	b1 2c       	mov	r11, r1
    606a:	a0 0e       	add	r10, r16
    606c:	b1 1e       	adc	r11, r17
    606e:	f8 01       	movw	r30, r16
    6070:	80 81       	ld	r24, Z
    6072:	91 81       	ldd	r25, Z+1	; 0x01
    6074:	aa 27       	eor	r26, r26
    6076:	97 fd       	sbrc	r25, 7
    6078:	a0 95       	com	r26
    607a:	ba 2f       	mov	r27, r26
    607c:	ff ee       	ldi	r31, 0xEF	; 239
    607e:	ff 22       	and	r15, r31
    6080:	b7 ff       	sbrs	r27, 7
    6082:	09 c0       	rjmp	.+18     	; 0x6096 <vfprintf+0x194>
    6084:	b0 95       	com	r27
    6086:	a0 95       	com	r26
    6088:	90 95       	com	r25
    608a:	81 95       	neg	r24
    608c:	9f 4f       	sbci	r25, 0xFF	; 255
    608e:	af 4f       	sbci	r26, 0xFF	; 255
    6090:	bf 4f       	sbci	r27, 0xFF	; 255
    6092:	20 e4       	ldi	r18, 0x40	; 64
    6094:	f2 2a       	or	r15, r18
    6096:	bc 01       	movw	r22, r24
    6098:	cd 01       	movw	r24, r26
    609a:	a4 01       	movw	r20, r8
    609c:	2a e0       	ldi	r18, 0x0A	; 10
    609e:	30 e0       	ldi	r19, 0x00	; 0
    60a0:	3b c0       	rjmp	.+118    	; 0x6118 <vfprintf+0x216>
    60a2:	20 37       	cpi	r18, 0x70	; 112
    60a4:	99 f0       	breq	.+38     	; 0x60cc <vfprintf+0x1ca>
    60a6:	21 37       	cpi	r18, 0x71	; 113
    60a8:	30 f4       	brcc	.+12     	; 0x60b6 <vfprintf+0x1b4>
    60aa:	28 35       	cpi	r18, 0x58	; 88
    60ac:	b1 f0       	breq	.+44     	; 0x60da <vfprintf+0x1d8>
    60ae:	2f 36       	cpi	r18, 0x6F	; 111
    60b0:	09 f0       	breq	.+2      	; 0x60b4 <vfprintf+0x1b2>
    60b2:	62 c0       	rjmp	.+196    	; 0x6178 <vfprintf+0x276>
    60b4:	17 c0       	rjmp	.+46     	; 0x60e4 <vfprintf+0x1e2>
    60b6:	25 37       	cpi	r18, 0x75	; 117
    60b8:	21 f0       	breq	.+8      	; 0x60c2 <vfprintf+0x1c0>
    60ba:	28 37       	cpi	r18, 0x78	; 120
    60bc:	09 f0       	breq	.+2      	; 0x60c0 <vfprintf+0x1be>
    60be:	5c c0       	rjmp	.+184    	; 0x6178 <vfprintf+0x276>
    60c0:	07 c0       	rjmp	.+14     	; 0x60d0 <vfprintf+0x1ce>
    60c2:	8f ee       	ldi	r24, 0xEF	; 239
    60c4:	f8 22       	and	r15, r24
    60c6:	2a e0       	ldi	r18, 0x0A	; 10
    60c8:	30 e0       	ldi	r19, 0x00	; 0
    60ca:	0e c0       	rjmp	.+28     	; 0x60e8 <vfprintf+0x1e6>
    60cc:	e0 e1       	ldi	r30, 0x10	; 16
    60ce:	fe 2a       	or	r15, r30
    60d0:	f4 e2       	ldi	r31, 0x24	; 36
    60d2:	ff 2a       	or	r15, r31
    60d4:	20 e1       	ldi	r18, 0x10	; 16
    60d6:	30 e0       	ldi	r19, 0x00	; 0
    60d8:	07 c0       	rjmp	.+14     	; 0x60e8 <vfprintf+0x1e6>
    60da:	24 e0       	ldi	r18, 0x04	; 4
    60dc:	f2 2a       	or	r15, r18
    60de:	20 e1       	ldi	r18, 0x10	; 16
    60e0:	32 e0       	ldi	r19, 0x02	; 2
    60e2:	02 c0       	rjmp	.+4      	; 0x60e8 <vfprintf+0x1e6>
    60e4:	28 e0       	ldi	r18, 0x08	; 8
    60e6:	30 e0       	ldi	r19, 0x00	; 0
    60e8:	f7 fe       	sbrs	r15, 7
    60ea:	0b c0       	rjmp	.+22     	; 0x6102 <vfprintf+0x200>
    60ec:	94 e0       	ldi	r25, 0x04	; 4
    60ee:	a9 2e       	mov	r10, r25
    60f0:	b1 2c       	mov	r11, r1
    60f2:	a0 0e       	add	r10, r16
    60f4:	b1 1e       	adc	r11, r17
    60f6:	f8 01       	movw	r30, r16
    60f8:	60 81       	ld	r22, Z
    60fa:	71 81       	ldd	r23, Z+1	; 0x01
    60fc:	82 81       	ldd	r24, Z+2	; 0x02
    60fe:	93 81       	ldd	r25, Z+3	; 0x03
    6100:	0a c0       	rjmp	.+20     	; 0x6116 <vfprintf+0x214>
    6102:	82 e0       	ldi	r24, 0x02	; 2
    6104:	a8 2e       	mov	r10, r24
    6106:	b1 2c       	mov	r11, r1
    6108:	a0 0e       	add	r10, r16
    610a:	b1 1e       	adc	r11, r17
    610c:	f8 01       	movw	r30, r16
    610e:	60 81       	ld	r22, Z
    6110:	71 81       	ldd	r23, Z+1	; 0x01
    6112:	80 e0       	ldi	r24, 0x00	; 0
    6114:	90 e0       	ldi	r25, 0x00	; 0
    6116:	a4 01       	movw	r20, r8
    6118:	0e 94 b3 33 	call	0x6766	; 0x6766 <__ultoa_invert>
    611c:	08 2f       	mov	r16, r24
    611e:	08 19       	sub	r16, r8
    6120:	ef 2c       	mov	r14, r15
    6122:	ff 24       	eor	r15, r15
    6124:	e6 fe       	sbrs	r14, 6
    6126:	05 c0       	rjmp	.+10     	; 0x6132 <vfprintf+0x230>
    6128:	8d e2       	ldi	r24, 0x2D	; 45
    612a:	90 e0       	ldi	r25, 0x00	; 0
    612c:	b6 01       	movw	r22, r12
    612e:	0e 94 6a 33 	call	0x66d4	; 0x66d4 <fputc>
    6132:	e4 fe       	sbrs	r14, 4
    6134:	15 c0       	rjmp	.+42     	; 0x6160 <vfprintf+0x25e>
    6136:	fe 01       	movw	r30, r28
    6138:	e0 0f       	add	r30, r16
    613a:	f1 1d       	adc	r31, r1
    613c:	80 81       	ld	r24, Z
    613e:	80 33       	cpi	r24, 0x30	; 48
    6140:	79 f0       	breq	.+30     	; 0x6160 <vfprintf+0x25e>
    6142:	80 e3       	ldi	r24, 0x30	; 48
    6144:	90 e0       	ldi	r25, 0x00	; 0
    6146:	b6 01       	movw	r22, r12
    6148:	0e 94 6a 33 	call	0x66d4	; 0x66d4 <fputc>
    614c:	e2 fe       	sbrs	r14, 2
    614e:	08 c0       	rjmp	.+16     	; 0x6160 <vfprintf+0x25e>
    6150:	c7 01       	movw	r24, r14
    6152:	80 72       	andi	r24, 0x20	; 32
    6154:	90 70       	andi	r25, 0x00	; 0
    6156:	88 5a       	subi	r24, 0xA8	; 168
    6158:	9f 4f       	sbci	r25, 0xFF	; 255
    615a:	b6 01       	movw	r22, r12
    615c:	0e 94 6a 33 	call	0x66d4	; 0x66d4 <fputc>
    6160:	01 50       	subi	r16, 0x01	; 1
    6162:	f4 01       	movw	r30, r8
    6164:	e0 0f       	add	r30, r16
    6166:	f1 1d       	adc	r31, r1
    6168:	80 81       	ld	r24, Z
    616a:	90 e0       	ldi	r25, 0x00	; 0
    616c:	b6 01       	movw	r22, r12
    616e:	0e 94 6a 33 	call	0x66d4	; 0x66d4 <fputc>
    6172:	00 23       	and	r16, r16
    6174:	a9 f7       	brne	.-22     	; 0x6160 <vfprintf+0x25e>
    6176:	e5 ce       	rjmp	.-566    	; 0x5f42 <vfprintf+0x40>
    6178:	f6 01       	movw	r30, r12
    617a:	86 81       	ldd	r24, Z+6	; 0x06
    617c:	97 81       	ldd	r25, Z+7	; 0x07
    617e:	02 c0       	rjmp	.+4      	; 0x6184 <vfprintf+0x282>
    6180:	8f ef       	ldi	r24, 0xFF	; 255
    6182:	9f ef       	ldi	r25, 0xFF	; 255
    6184:	2c 96       	adiw	r28, 0x0c	; 12
    6186:	0f b6       	in	r0, 0x3f	; 63
    6188:	f8 94       	cli
    618a:	de bf       	out	0x3e, r29	; 62
    618c:	0f be       	out	0x3f, r0	; 63
    618e:	cd bf       	out	0x3d, r28	; 61
    6190:	df 91       	pop	r29
    6192:	cf 91       	pop	r28
    6194:	1f 91       	pop	r17
    6196:	0f 91       	pop	r16
    6198:	ff 90       	pop	r15
    619a:	ef 90       	pop	r14
    619c:	df 90       	pop	r13
    619e:	cf 90       	pop	r12
    61a0:	bf 90       	pop	r11
    61a2:	af 90       	pop	r10
    61a4:	9f 90       	pop	r9
    61a6:	8f 90       	pop	r8
    61a8:	7f 90       	pop	r7
    61aa:	6f 90       	pop	r6
    61ac:	08 95       	ret

000061ae <putval>:
    61ae:	20 fd       	sbrc	r18, 0
    61b0:	09 c0       	rjmp	.+18     	; 0x61c4 <putval+0x16>
    61b2:	fc 01       	movw	r30, r24
    61b4:	23 fd       	sbrc	r18, 3
    61b6:	05 c0       	rjmp	.+10     	; 0x61c2 <putval+0x14>
    61b8:	22 ff       	sbrs	r18, 2
    61ba:	02 c0       	rjmp	.+4      	; 0x61c0 <putval+0x12>
    61bc:	73 83       	std	Z+3, r23	; 0x03
    61be:	62 83       	std	Z+2, r22	; 0x02
    61c0:	51 83       	std	Z+1, r21	; 0x01
    61c2:	40 83       	st	Z, r20
    61c4:	08 95       	ret

000061c6 <mulacc>:
    61c6:	cf 92       	push	r12
    61c8:	df 92       	push	r13
    61ca:	ef 92       	push	r14
    61cc:	ff 92       	push	r15
    61ce:	6b 01       	movw	r12, r22
    61d0:	7c 01       	movw	r14, r24
    61d2:	44 fd       	sbrc	r20, 4
    61d4:	10 c0       	rjmp	.+32     	; 0x61f6 <mulacc+0x30>
    61d6:	46 fd       	sbrc	r20, 6
    61d8:	10 c0       	rjmp	.+32     	; 0x61fa <mulacc+0x34>
    61da:	d6 01       	movw	r26, r12
    61dc:	f7 01       	movw	r30, r14
    61de:	aa 0f       	add	r26, r26
    61e0:	bb 1f       	adc	r27, r27
    61e2:	ee 1f       	adc	r30, r30
    61e4:	ff 1f       	adc	r31, r31
    61e6:	10 94       	com	r1
    61e8:	d1 f7       	brne	.-12     	; 0x61de <mulacc+0x18>
    61ea:	ca 0e       	add	r12, r26
    61ec:	db 1e       	adc	r13, r27
    61ee:	ee 1e       	adc	r14, r30
    61f0:	ff 1e       	adc	r15, r31
    61f2:	81 e0       	ldi	r24, 0x01	; 1
    61f4:	03 c0       	rjmp	.+6      	; 0x61fc <mulacc+0x36>
    61f6:	83 e0       	ldi	r24, 0x03	; 3
    61f8:	01 c0       	rjmp	.+2      	; 0x61fc <mulacc+0x36>
    61fa:	84 e0       	ldi	r24, 0x04	; 4
    61fc:	cc 0c       	add	r12, r12
    61fe:	dd 1c       	adc	r13, r13
    6200:	ee 1c       	adc	r14, r14
    6202:	ff 1c       	adc	r15, r15
    6204:	81 50       	subi	r24, 0x01	; 1
    6206:	d1 f7       	brne	.-12     	; 0x61fc <mulacc+0x36>
    6208:	c2 0e       	add	r12, r18
    620a:	d1 1c       	adc	r13, r1
    620c:	e1 1c       	adc	r14, r1
    620e:	f1 1c       	adc	r15, r1
    6210:	b6 01       	movw	r22, r12
    6212:	c7 01       	movw	r24, r14
    6214:	ff 90       	pop	r15
    6216:	ef 90       	pop	r14
    6218:	df 90       	pop	r13
    621a:	cf 90       	pop	r12
    621c:	08 95       	ret

0000621e <skip_spaces>:
    621e:	0f 93       	push	r16
    6220:	1f 93       	push	r17
    6222:	cf 93       	push	r28
    6224:	df 93       	push	r29
    6226:	8c 01       	movw	r16, r24
    6228:	c8 01       	movw	r24, r16
    622a:	0e 94 2a 33 	call	0x6654	; 0x6654 <fgetc>
    622e:	ec 01       	movw	r28, r24
    6230:	97 fd       	sbrc	r25, 7
    6232:	08 c0       	rjmp	.+16     	; 0x6244 <skip_spaces+0x26>
    6234:	0e 94 17 33 	call	0x662e	; 0x662e <isspace>
    6238:	00 97       	sbiw	r24, 0x00	; 0
    623a:	b1 f7       	brne	.-20     	; 0x6228 <skip_spaces+0xa>
    623c:	ce 01       	movw	r24, r28
    623e:	b8 01       	movw	r22, r16
    6240:	0e 94 96 33 	call	0x672c	; 0x672c <ungetc>
    6244:	ce 01       	movw	r24, r28
    6246:	df 91       	pop	r29
    6248:	cf 91       	pop	r28
    624a:	1f 91       	pop	r17
    624c:	0f 91       	pop	r16
    624e:	08 95       	ret

00006250 <conv_int>:
    6250:	af 92       	push	r10
    6252:	bf 92       	push	r11
    6254:	cf 92       	push	r12
    6256:	df 92       	push	r13
    6258:	ef 92       	push	r14
    625a:	ff 92       	push	r15
    625c:	0f 93       	push	r16
    625e:	1f 93       	push	r17
    6260:	cf 93       	push	r28
    6262:	df 93       	push	r29
    6264:	8c 01       	movw	r16, r24
    6266:	d6 2f       	mov	r29, r22
    6268:	5a 01       	movw	r10, r20
    626a:	c2 2f       	mov	r28, r18
    626c:	0e 94 2a 33 	call	0x6654	; 0x6654 <fgetc>
    6270:	8b 32       	cpi	r24, 0x2B	; 43
    6272:	19 f0       	breq	.+6      	; 0x627a <conv_int+0x2a>
    6274:	8d 32       	cpi	r24, 0x2D	; 45
    6276:	49 f4       	brne	.+18     	; 0x628a <conv_int+0x3a>
    6278:	c0 68       	ori	r28, 0x80	; 128
    627a:	d1 50       	subi	r29, 0x01	; 1
    627c:	09 f4       	brne	.+2      	; 0x6280 <conv_int+0x30>
    627e:	61 c0       	rjmp	.+194    	; 0x6342 <conv_int+0xf2>
    6280:	c8 01       	movw	r24, r16
    6282:	0e 94 2a 33 	call	0x6654	; 0x6654 <fgetc>
    6286:	97 fd       	sbrc	r25, 7
    6288:	5c c0       	rjmp	.+184    	; 0x6342 <conv_int+0xf2>
    628a:	cd 7f       	andi	r28, 0xFD	; 253
    628c:	2c 2f       	mov	r18, r28
    628e:	20 73       	andi	r18, 0x30	; 48
    6290:	d1 f4       	brne	.+52     	; 0x62c6 <conv_int+0x76>
    6292:	80 33       	cpi	r24, 0x30	; 48
    6294:	c1 f4       	brne	.+48     	; 0x62c6 <conv_int+0x76>
    6296:	d1 50       	subi	r29, 0x01	; 1
    6298:	09 f4       	brne	.+2      	; 0x629c <conv_int+0x4c>
    629a:	3e c0       	rjmp	.+124    	; 0x6318 <conv_int+0xc8>
    629c:	c8 01       	movw	r24, r16
    629e:	0e 94 2a 33 	call	0x6654	; 0x6654 <fgetc>
    62a2:	97 fd       	sbrc	r25, 7
    62a4:	39 c0       	rjmp	.+114    	; 0x6318 <conv_int+0xc8>
    62a6:	c2 60       	ori	r28, 0x02	; 2
    62a8:	88 37       	cpi	r24, 0x78	; 120
    62aa:	11 f0       	breq	.+4      	; 0x62b0 <conv_int+0x60>
    62ac:	88 35       	cpi	r24, 0x58	; 88
    62ae:	49 f4       	brne	.+18     	; 0x62c2 <conv_int+0x72>
    62b0:	c0 64       	ori	r28, 0x40	; 64
    62b2:	d1 50       	subi	r29, 0x01	; 1
    62b4:	89 f1       	breq	.+98     	; 0x6318 <conv_int+0xc8>
    62b6:	c8 01       	movw	r24, r16
    62b8:	0e 94 2a 33 	call	0x6654	; 0x6654 <fgetc>
    62bc:	97 ff       	sbrs	r25, 7
    62be:	03 c0       	rjmp	.+6      	; 0x62c6 <conv_int+0x76>
    62c0:	2b c0       	rjmp	.+86     	; 0x6318 <conv_int+0xc8>
    62c2:	c6 ff       	sbrs	r28, 6
    62c4:	c0 61       	ori	r28, 0x10	; 16
    62c6:	cc 24       	eor	r12, r12
    62c8:	dd 24       	eor	r13, r13
    62ca:	76 01       	movw	r14, r12
    62cc:	28 2f       	mov	r18, r24
    62ce:	20 53       	subi	r18, 0x30	; 48
    62d0:	28 30       	cpi	r18, 0x08	; 8
    62d2:	80 f0       	brcs	.+32     	; 0x62f4 <conv_int+0xa4>
    62d4:	c4 fd       	sbrc	r28, 4
    62d6:	09 c0       	rjmp	.+18     	; 0x62ea <conv_int+0x9a>
    62d8:	2a 30       	cpi	r18, 0x0A	; 10
    62da:	60 f0       	brcs	.+24     	; 0x62f4 <conv_int+0xa4>
    62dc:	c6 ff       	sbrs	r28, 6
    62de:	05 c0       	rjmp	.+10     	; 0x62ea <conv_int+0x9a>
    62e0:	2f 7d       	andi	r18, 0xDF	; 223
    62e2:	32 2f       	mov	r19, r18
    62e4:	31 51       	subi	r19, 0x11	; 17
    62e6:	36 30       	cpi	r19, 0x06	; 6
    62e8:	20 f0       	brcs	.+8      	; 0x62f2 <conv_int+0xa2>
    62ea:	b8 01       	movw	r22, r16
    62ec:	0e 94 96 33 	call	0x672c	; 0x672c <ungetc>
    62f0:	10 c0       	rjmp	.+32     	; 0x6312 <conv_int+0xc2>
    62f2:	27 50       	subi	r18, 0x07	; 7
    62f4:	c7 01       	movw	r24, r14
    62f6:	b6 01       	movw	r22, r12
    62f8:	4c 2f       	mov	r20, r28
    62fa:	0e 94 e3 30 	call	0x61c6	; 0x61c6 <mulacc>
    62fe:	6b 01       	movw	r12, r22
    6300:	7c 01       	movw	r14, r24
    6302:	c2 60       	ori	r28, 0x02	; 2
    6304:	d1 50       	subi	r29, 0x01	; 1
    6306:	59 f0       	breq	.+22     	; 0x631e <conv_int+0xce>
    6308:	c8 01       	movw	r24, r16
    630a:	0e 94 2a 33 	call	0x6654	; 0x6654 <fgetc>
    630e:	97 ff       	sbrs	r25, 7
    6310:	dd cf       	rjmp	.-70     	; 0x62cc <conv_int+0x7c>
    6312:	c1 fd       	sbrc	r28, 1
    6314:	04 c0       	rjmp	.+8      	; 0x631e <conv_int+0xce>
    6316:	15 c0       	rjmp	.+42     	; 0x6342 <conv_int+0xf2>
    6318:	cc 24       	eor	r12, r12
    631a:	dd 24       	eor	r13, r13
    631c:	76 01       	movw	r14, r12
    631e:	c7 ff       	sbrs	r28, 7
    6320:	08 c0       	rjmp	.+16     	; 0x6332 <conv_int+0xe2>
    6322:	f0 94       	com	r15
    6324:	e0 94       	com	r14
    6326:	d0 94       	com	r13
    6328:	c0 94       	com	r12
    632a:	c1 1c       	adc	r12, r1
    632c:	d1 1c       	adc	r13, r1
    632e:	e1 1c       	adc	r14, r1
    6330:	f1 1c       	adc	r15, r1
    6332:	c5 01       	movw	r24, r10
    6334:	b7 01       	movw	r22, r14
    6336:	a6 01       	movw	r20, r12
    6338:	2c 2f       	mov	r18, r28
    633a:	0e 94 d7 30 	call	0x61ae	; 0x61ae <putval>
    633e:	81 e0       	ldi	r24, 0x01	; 1
    6340:	01 c0       	rjmp	.+2      	; 0x6344 <conv_int+0xf4>
    6342:	80 e0       	ldi	r24, 0x00	; 0
    6344:	df 91       	pop	r29
    6346:	cf 91       	pop	r28
    6348:	1f 91       	pop	r17
    634a:	0f 91       	pop	r16
    634c:	ff 90       	pop	r15
    634e:	ef 90       	pop	r14
    6350:	df 90       	pop	r13
    6352:	cf 90       	pop	r12
    6354:	bf 90       	pop	r11
    6356:	af 90       	pop	r10
    6358:	08 95       	ret

0000635a <vfscanf>:
    635a:	5f 92       	push	r5
    635c:	6f 92       	push	r6
    635e:	7f 92       	push	r7
    6360:	8f 92       	push	r8
    6362:	9f 92       	push	r9
    6364:	af 92       	push	r10
    6366:	bf 92       	push	r11
    6368:	cf 92       	push	r12
    636a:	df 92       	push	r13
    636c:	ef 92       	push	r14
    636e:	ff 92       	push	r15
    6370:	0f 93       	push	r16
    6372:	1f 93       	push	r17
    6374:	cf 93       	push	r28
    6376:	df 93       	push	r29
    6378:	0f 92       	push	r0
    637a:	cd b7       	in	r28, 0x3d	; 61
    637c:	de b7       	in	r29, 0x3e	; 62
    637e:	7c 01       	movw	r14, r24
    6380:	4b 01       	movw	r8, r22
    6382:	3a 01       	movw	r6, r20
    6384:	fc 01       	movw	r30, r24
    6386:	17 82       	std	Z+7, r1	; 0x07
    6388:	16 82       	std	Z+6, r1	; 0x06
    638a:	bb 24       	eor	r11, r11
    638c:	e3 c0       	rjmp	.+454    	; 0x6554 <vfscanf+0x1fa>
    638e:	81 2f       	mov	r24, r17
    6390:	90 e0       	ldi	r25, 0x00	; 0
    6392:	0e 94 17 33 	call	0x662e	; 0x662e <isspace>
    6396:	00 97       	sbiw	r24, 0x00	; 0
    6398:	21 f0       	breq	.+8      	; 0x63a2 <vfscanf+0x48>
    639a:	c7 01       	movw	r24, r14
    639c:	0e 94 0f 31 	call	0x621e	; 0x621e <skip_spaces>
    63a0:	d9 c0       	rjmp	.+434    	; 0x6554 <vfscanf+0x1fa>
    63a2:	15 32       	cpi	r17, 0x25	; 37
    63a4:	41 f4       	brne	.+16     	; 0x63b6 <vfscanf+0x5c>
    63a6:	f4 01       	movw	r30, r8
    63a8:	03 fd       	sbrc	r16, 3
    63aa:	35 91       	lpm	r19, Z+
    63ac:	03 ff       	sbrs	r16, 3
    63ae:	31 91       	ld	r19, Z+
    63b0:	4f 01       	movw	r8, r30
    63b2:	35 32       	cpi	r19, 0x25	; 37
    63b4:	61 f4       	brne	.+24     	; 0x63ce <vfscanf+0x74>
    63b6:	c7 01       	movw	r24, r14
    63b8:	0e 94 2a 33 	call	0x6654	; 0x6654 <fgetc>
    63bc:	97 fd       	sbrc	r25, 7
    63be:	d6 c0       	rjmp	.+428    	; 0x656c <vfscanf+0x212>
    63c0:	18 17       	cp	r17, r24
    63c2:	09 f4       	brne	.+2      	; 0x63c6 <vfscanf+0x6c>
    63c4:	c7 c0       	rjmp	.+398    	; 0x6554 <vfscanf+0x1fa>
    63c6:	b7 01       	movw	r22, r14
    63c8:	0e 94 96 33 	call	0x672c	; 0x672c <ungetc>
    63cc:	d1 c0       	rjmp	.+418    	; 0x6570 <vfscanf+0x216>
    63ce:	3a 32       	cpi	r19, 0x2A	; 42
    63d0:	41 f4       	brne	.+16     	; 0x63e2 <vfscanf+0x88>
    63d2:	03 fd       	sbrc	r16, 3
    63d4:	35 91       	lpm	r19, Z+
    63d6:	03 ff       	sbrs	r16, 3
    63d8:	31 91       	ld	r19, Z+
    63da:	4f 01       	movw	r8, r30
    63dc:	aa 24       	eor	r10, r10
    63de:	a3 94       	inc	r10
    63e0:	01 c0       	rjmp	.+2      	; 0x63e4 <vfscanf+0x8a>
    63e2:	aa 24       	eor	r10, r10
    63e4:	55 24       	eor	r5, r5
    63e6:	10 c0       	rjmp	.+32     	; 0x6408 <vfscanf+0xae>
    63e8:	f2 e0       	ldi	r31, 0x02	; 2
    63ea:	af 2a       	or	r10, r31
    63ec:	65 2d       	mov	r22, r5
    63ee:	70 e0       	ldi	r23, 0x00	; 0
    63f0:	80 e0       	ldi	r24, 0x00	; 0
    63f2:	90 e0       	ldi	r25, 0x00	; 0
    63f4:	40 e2       	ldi	r20, 0x20	; 32
    63f6:	0e 94 e3 30 	call	0x61c6	; 0x61c6 <mulacc>
    63fa:	56 2e       	mov	r5, r22
    63fc:	f4 01       	movw	r30, r8
    63fe:	03 fd       	sbrc	r16, 3
    6400:	35 91       	lpm	r19, Z+
    6402:	03 ff       	sbrs	r16, 3
    6404:	31 91       	ld	r19, Z+
    6406:	4f 01       	movw	r8, r30
    6408:	23 2f       	mov	r18, r19
    640a:	20 53       	subi	r18, 0x30	; 48
    640c:	2a 30       	cpi	r18, 0x0A	; 10
    640e:	60 f3       	brcs	.-40     	; 0x63e8 <vfscanf+0x8e>
    6410:	a1 fe       	sbrs	r10, 1
    6412:	03 c0       	rjmp	.+6      	; 0x641a <vfscanf+0xc0>
    6414:	55 20       	and	r5, r5
    6416:	19 f4       	brne	.+6      	; 0x641e <vfscanf+0xc4>
    6418:	ab c0       	rjmp	.+342    	; 0x6570 <vfscanf+0x216>
    641a:	55 24       	eor	r5, r5
    641c:	5a 94       	dec	r5
    641e:	38 36       	cpi	r19, 0x68	; 104
    6420:	19 f0       	breq	.+6      	; 0x6428 <vfscanf+0xce>
    6422:	3c 36       	cpi	r19, 0x6C	; 108
    6424:	99 f4       	brne	.+38     	; 0x644c <vfscanf+0xf2>
    6426:	0a c0       	rjmp	.+20     	; 0x643c <vfscanf+0xe2>
    6428:	f4 01       	movw	r30, r8
    642a:	03 fd       	sbrc	r16, 3
    642c:	35 91       	lpm	r19, Z+
    642e:	03 ff       	sbrs	r16, 3
    6430:	31 91       	ld	r19, Z+
    6432:	4f 01       	movw	r8, r30
    6434:	38 36       	cpi	r19, 0x68	; 104
    6436:	51 f4       	brne	.+20     	; 0x644c <vfscanf+0xf2>
    6438:	f8 e0       	ldi	r31, 0x08	; 8
    643a:	af 2a       	or	r10, r31
    643c:	44 e0       	ldi	r20, 0x04	; 4
    643e:	a4 2a       	or	r10, r20
    6440:	f4 01       	movw	r30, r8
    6442:	03 fd       	sbrc	r16, 3
    6444:	35 91       	lpm	r19, Z+
    6446:	03 ff       	sbrs	r16, 3
    6448:	31 91       	ld	r19, Z+
    644a:	4f 01       	movw	r8, r30
    644c:	33 23       	and	r19, r19
    644e:	09 f4       	brne	.+2      	; 0x6452 <vfscanf+0xf8>
    6450:	8f c0       	rjmp	.+286    	; 0x6570 <vfscanf+0x216>
    6452:	8b ef       	ldi	r24, 0xFB	; 251
    6454:	90 e0       	ldi	r25, 0x00	; 0
    6456:	63 2f       	mov	r22, r19
    6458:	70 e0       	ldi	r23, 0x00	; 0
    645a:	39 83       	std	Y+1, r19	; 0x01
    645c:	0e 94 1f 33 	call	0x663e	; 0x663e <strchr_P>
    6460:	39 81       	ldd	r19, Y+1	; 0x01
    6462:	00 97       	sbiw	r24, 0x00	; 0
    6464:	09 f4       	brne	.+2      	; 0x6468 <vfscanf+0x10e>
    6466:	84 c0       	rjmp	.+264    	; 0x6570 <vfscanf+0x216>
    6468:	8a 2d       	mov	r24, r10
    646a:	a0 fc       	sbrc	r10, 0
    646c:	08 c0       	rjmp	.+16     	; 0x647e <vfscanf+0x124>
    646e:	f3 01       	movw	r30, r6
    6470:	00 81       	ld	r16, Z
    6472:	11 81       	ldd	r17, Z+1	; 0x01
    6474:	42 e0       	ldi	r20, 0x02	; 2
    6476:	50 e0       	ldi	r21, 0x00	; 0
    6478:	64 0e       	add	r6, r20
    647a:	75 1e       	adc	r7, r21
    647c:	02 c0       	rjmp	.+4      	; 0x6482 <vfscanf+0x128>
    647e:	00 e0       	ldi	r16, 0x00	; 0
    6480:	10 e0       	ldi	r17, 0x00	; 0
    6482:	3e 36       	cpi	r19, 0x6E	; 110
    6484:	51 f4       	brne	.+20     	; 0x649a <vfscanf+0x140>
    6486:	f7 01       	movw	r30, r14
    6488:	46 81       	ldd	r20, Z+6	; 0x06
    648a:	57 81       	ldd	r21, Z+7	; 0x07
    648c:	60 e0       	ldi	r22, 0x00	; 0
    648e:	70 e0       	ldi	r23, 0x00	; 0
    6490:	c8 01       	movw	r24, r16
    6492:	2a 2d       	mov	r18, r10
    6494:	0e 94 d7 30 	call	0x61ae	; 0x61ae <putval>
    6498:	5d c0       	rjmp	.+186    	; 0x6554 <vfscanf+0x1fa>
    649a:	33 36       	cpi	r19, 0x63	; 99
    649c:	91 f4       	brne	.+36     	; 0x64c2 <vfscanf+0x168>
    649e:	81 fd       	sbrc	r24, 1
    64a0:	02 c0       	rjmp	.+4      	; 0x64a6 <vfscanf+0x14c>
    64a2:	55 24       	eor	r5, r5
    64a4:	53 94       	inc	r5
    64a6:	c7 01       	movw	r24, r14
    64a8:	0e 94 2a 33 	call	0x6654	; 0x6654 <fgetc>
    64ac:	97 fd       	sbrc	r25, 7
    64ae:	5e c0       	rjmp	.+188    	; 0x656c <vfscanf+0x212>
    64b0:	01 15       	cp	r16, r1
    64b2:	11 05       	cpc	r17, r1
    64b4:	19 f0       	breq	.+6      	; 0x64bc <vfscanf+0x162>
    64b6:	f8 01       	movw	r30, r16
    64b8:	81 93       	st	Z+, r24
    64ba:	8f 01       	movw	r16, r30
    64bc:	5a 94       	dec	r5
    64be:	99 f7       	brne	.-26     	; 0x64a6 <vfscanf+0x14c>
    64c0:	47 c0       	rjmp	.+142    	; 0x6550 <vfscanf+0x1f6>
    64c2:	c7 01       	movw	r24, r14
    64c4:	39 83       	std	Y+1, r19	; 0x01
    64c6:	0e 94 0f 31 	call	0x621e	; 0x621e <skip_spaces>
    64ca:	39 81       	ldd	r19, Y+1	; 0x01
    64cc:	97 fd       	sbrc	r25, 7
    64ce:	4e c0       	rjmp	.+156    	; 0x656c <vfscanf+0x212>
    64d0:	3f 36       	cpi	r19, 0x6F	; 111
    64d2:	61 f1       	breq	.+88     	; 0x652c <vfscanf+0x1d2>
    64d4:	30 37       	cpi	r19, 0x70	; 112
    64d6:	28 f4       	brcc	.+10     	; 0x64e2 <vfscanf+0x188>
    64d8:	34 36       	cpi	r19, 0x64	; 100
    64da:	29 f1       	breq	.+74     	; 0x6526 <vfscanf+0x1cc>
    64dc:	39 36       	cpi	r19, 0x69	; 105
    64de:	49 f5       	brne	.+82     	; 0x6532 <vfscanf+0x1d8>
    64e0:	2a c0       	rjmp	.+84     	; 0x6536 <vfscanf+0x1dc>
    64e2:	33 37       	cpi	r19, 0x73	; 115
    64e4:	19 f0       	breq	.+6      	; 0x64ec <vfscanf+0x192>
    64e6:	35 37       	cpi	r19, 0x75	; 117
    64e8:	21 f5       	brne	.+72     	; 0x6532 <vfscanf+0x1d8>
    64ea:	1d c0       	rjmp	.+58     	; 0x6526 <vfscanf+0x1cc>
    64ec:	c7 01       	movw	r24, r14
    64ee:	0e 94 2a 33 	call	0x6654	; 0x6654 <fgetc>
    64f2:	6c 01       	movw	r12, r24
    64f4:	97 fd       	sbrc	r25, 7
    64f6:	11 c0       	rjmp	.+34     	; 0x651a <vfscanf+0x1c0>
    64f8:	0e 94 17 33 	call	0x662e	; 0x662e <isspace>
    64fc:	00 97       	sbiw	r24, 0x00	; 0
    64fe:	29 f0       	breq	.+10     	; 0x650a <vfscanf+0x1b0>
    6500:	c6 01       	movw	r24, r12
    6502:	b7 01       	movw	r22, r14
    6504:	0e 94 96 33 	call	0x672c	; 0x672c <ungetc>
    6508:	08 c0       	rjmp	.+16     	; 0x651a <vfscanf+0x1c0>
    650a:	01 15       	cp	r16, r1
    650c:	11 05       	cpc	r17, r1
    650e:	19 f0       	breq	.+6      	; 0x6516 <vfscanf+0x1bc>
    6510:	f8 01       	movw	r30, r16
    6512:	c1 92       	st	Z+, r12
    6514:	8f 01       	movw	r16, r30
    6516:	5a 94       	dec	r5
    6518:	49 f7       	brne	.-46     	; 0x64ec <vfscanf+0x192>
    651a:	01 15       	cp	r16, r1
    651c:	11 05       	cpc	r17, r1
    651e:	c1 f0       	breq	.+48     	; 0x6550 <vfscanf+0x1f6>
    6520:	f8 01       	movw	r30, r16
    6522:	10 82       	st	Z, r1
    6524:	15 c0       	rjmp	.+42     	; 0x6550 <vfscanf+0x1f6>
    6526:	f0 e2       	ldi	r31, 0x20	; 32
    6528:	af 2a       	or	r10, r31
    652a:	05 c0       	rjmp	.+10     	; 0x6536 <vfscanf+0x1dc>
    652c:	40 e1       	ldi	r20, 0x10	; 16
    652e:	a4 2a       	or	r10, r20
    6530:	02 c0       	rjmp	.+4      	; 0x6536 <vfscanf+0x1dc>
    6532:	50 e4       	ldi	r21, 0x40	; 64
    6534:	a5 2a       	or	r10, r21
    6536:	c7 01       	movw	r24, r14
    6538:	65 2d       	mov	r22, r5
    653a:	a8 01       	movw	r20, r16
    653c:	2a 2d       	mov	r18, r10
    653e:	0e 94 28 31 	call	0x6250	; 0x6250 <conv_int>
    6542:	88 23       	and	r24, r24
    6544:	29 f4       	brne	.+10     	; 0x6550 <vfscanf+0x1f6>
    6546:	f7 01       	movw	r30, r14
    6548:	83 81       	ldd	r24, Z+3	; 0x03
    654a:	80 73       	andi	r24, 0x30	; 48
    654c:	79 f4       	brne	.+30     	; 0x656c <vfscanf+0x212>
    654e:	10 c0       	rjmp	.+32     	; 0x6570 <vfscanf+0x216>
    6550:	a0 fe       	sbrs	r10, 0
    6552:	b3 94       	inc	r11
    6554:	f7 01       	movw	r30, r14
    6556:	03 81       	ldd	r16, Z+3	; 0x03
    6558:	f4 01       	movw	r30, r8
    655a:	03 fd       	sbrc	r16, 3
    655c:	15 91       	lpm	r17, Z+
    655e:	03 ff       	sbrs	r16, 3
    6560:	11 91       	ld	r17, Z+
    6562:	4f 01       	movw	r8, r30
    6564:	11 23       	and	r17, r17
    6566:	09 f0       	breq	.+2      	; 0x656a <vfscanf+0x210>
    6568:	12 cf       	rjmp	.-476    	; 0x638e <vfscanf+0x34>
    656a:	02 c0       	rjmp	.+4      	; 0x6570 <vfscanf+0x216>
    656c:	bb 20       	and	r11, r11
    656e:	19 f0       	breq	.+6      	; 0x6576 <vfscanf+0x21c>
    6570:	8b 2d       	mov	r24, r11
    6572:	90 e0       	ldi	r25, 0x00	; 0
    6574:	02 c0       	rjmp	.+4      	; 0x657a <vfscanf+0x220>
    6576:	8f ef       	ldi	r24, 0xFF	; 255
    6578:	9f ef       	ldi	r25, 0xFF	; 255
    657a:	0f 90       	pop	r0
    657c:	df 91       	pop	r29
    657e:	cf 91       	pop	r28
    6580:	1f 91       	pop	r17
    6582:	0f 91       	pop	r16
    6584:	ff 90       	pop	r15
    6586:	ef 90       	pop	r14
    6588:	df 90       	pop	r13
    658a:	cf 90       	pop	r12
    658c:	bf 90       	pop	r11
    658e:	af 90       	pop	r10
    6590:	9f 90       	pop	r9
    6592:	8f 90       	pop	r8
    6594:	7f 90       	pop	r7
    6596:	6f 90       	pop	r6
    6598:	5f 90       	pop	r5
    659a:	08 95       	ret

0000659c <__umulhisi3>:
    659c:	a2 9f       	mul	r26, r18
    659e:	b0 01       	movw	r22, r0
    65a0:	b3 9f       	mul	r27, r19
    65a2:	c0 01       	movw	r24, r0
    65a4:	a3 9f       	mul	r26, r19
    65a6:	01 d0       	rcall	.+2      	; 0x65aa <__umulhisi3+0xe>
    65a8:	b2 9f       	mul	r27, r18
    65aa:	70 0d       	add	r23, r0
    65ac:	81 1d       	adc	r24, r1
    65ae:	11 24       	eor	r1, r1
    65b0:	91 1d       	adc	r25, r1
    65b2:	08 95       	ret

000065b4 <__mulsi3>:
    65b4:	db 01       	movw	r26, r22
    65b6:	8f 93       	push	r24
    65b8:	9f 93       	push	r25
    65ba:	0e 94 0c 33 	call	0x6618	; 0x6618 <__muluhisi3>
    65be:	bf 91       	pop	r27
    65c0:	af 91       	pop	r26
    65c2:	a2 9f       	mul	r26, r18
    65c4:	80 0d       	add	r24, r0
    65c6:	91 1d       	adc	r25, r1
    65c8:	a3 9f       	mul	r26, r19
    65ca:	90 0d       	add	r25, r0
    65cc:	b2 9f       	mul	r27, r18
    65ce:	90 0d       	add	r25, r0
    65d0:	11 24       	eor	r1, r1
    65d2:	08 95       	ret

000065d4 <__udivmodsi4>:
    65d4:	a1 e2       	ldi	r26, 0x21	; 33
    65d6:	1a 2e       	mov	r1, r26
    65d8:	aa 1b       	sub	r26, r26
    65da:	bb 1b       	sub	r27, r27
    65dc:	fd 01       	movw	r30, r26
    65de:	0d c0       	rjmp	.+26     	; 0x65fa <__udivmodsi4_ep>

000065e0 <__udivmodsi4_loop>:
    65e0:	aa 1f       	adc	r26, r26
    65e2:	bb 1f       	adc	r27, r27
    65e4:	ee 1f       	adc	r30, r30
    65e6:	ff 1f       	adc	r31, r31
    65e8:	a2 17       	cp	r26, r18
    65ea:	b3 07       	cpc	r27, r19
    65ec:	e4 07       	cpc	r30, r20
    65ee:	f5 07       	cpc	r31, r21
    65f0:	20 f0       	brcs	.+8      	; 0x65fa <__udivmodsi4_ep>
    65f2:	a2 1b       	sub	r26, r18
    65f4:	b3 0b       	sbc	r27, r19
    65f6:	e4 0b       	sbc	r30, r20
    65f8:	f5 0b       	sbc	r31, r21

000065fa <__udivmodsi4_ep>:
    65fa:	66 1f       	adc	r22, r22
    65fc:	77 1f       	adc	r23, r23
    65fe:	88 1f       	adc	r24, r24
    6600:	99 1f       	adc	r25, r25
    6602:	1a 94       	dec	r1
    6604:	69 f7       	brne	.-38     	; 0x65e0 <__udivmodsi4_loop>
    6606:	60 95       	com	r22
    6608:	70 95       	com	r23
    660a:	80 95       	com	r24
    660c:	90 95       	com	r25
    660e:	9b 01       	movw	r18, r22
    6610:	ac 01       	movw	r20, r24
    6612:	bd 01       	movw	r22, r26
    6614:	cf 01       	movw	r24, r30
    6616:	08 95       	ret

00006618 <__muluhisi3>:
    6618:	0e 94 ce 32 	call	0x659c	; 0x659c <__umulhisi3>
    661c:	a5 9f       	mul	r26, r21
    661e:	90 0d       	add	r25, r0
    6620:	b4 9f       	mul	r27, r20
    6622:	90 0d       	add	r25, r0
    6624:	a4 9f       	mul	r26, r20
    6626:	80 0d       	add	r24, r0
    6628:	91 1d       	adc	r25, r1
    662a:	11 24       	eor	r1, r1
    662c:	08 95       	ret

0000662e <isspace>:
    662e:	91 11       	cpse	r25, r1
    6630:	f8 c0       	rjmp	.+496    	; 0x6822 <__ctype_isfalse>
    6632:	80 32       	cpi	r24, 0x20	; 32
    6634:	19 f0       	breq	.+6      	; 0x663c <isspace+0xe>
    6636:	89 50       	subi	r24, 0x09	; 9
    6638:	85 50       	subi	r24, 0x05	; 5
    663a:	d0 f7       	brcc	.-12     	; 0x6630 <isspace+0x2>
    663c:	08 95       	ret

0000663e <strchr_P>:
    663e:	fc 01       	movw	r30, r24
    6640:	05 90       	lpm	r0, Z+
    6642:	06 16       	cp	r0, r22
    6644:	21 f0       	breq	.+8      	; 0x664e <strchr_P+0x10>
    6646:	00 20       	and	r0, r0
    6648:	d9 f7       	brne	.-10     	; 0x6640 <strchr_P+0x2>
    664a:	c0 01       	movw	r24, r0
    664c:	08 95       	ret
    664e:	31 97       	sbiw	r30, 0x01	; 1
    6650:	cf 01       	movw	r24, r30
    6652:	08 95       	ret

00006654 <fgetc>:
    6654:	cf 93       	push	r28
    6656:	df 93       	push	r29
    6658:	ec 01       	movw	r28, r24
    665a:	2b 81       	ldd	r18, Y+3	; 0x03
    665c:	20 ff       	sbrs	r18, 0
    665e:	35 c0       	rjmp	.+106    	; 0x66ca <fgetc+0x76>
    6660:	26 ff       	sbrs	r18, 6
    6662:	09 c0       	rjmp	.+18     	; 0x6676 <fgetc+0x22>
    6664:	2f 7b       	andi	r18, 0xBF	; 191
    6666:	2b 83       	std	Y+3, r18	; 0x03
    6668:	8e 81       	ldd	r24, Y+6	; 0x06
    666a:	9f 81       	ldd	r25, Y+7	; 0x07
    666c:	01 96       	adiw	r24, 0x01	; 1
    666e:	9f 83       	std	Y+7, r25	; 0x07
    6670:	8e 83       	std	Y+6, r24	; 0x06
    6672:	8a 81       	ldd	r24, Y+2	; 0x02
    6674:	28 c0       	rjmp	.+80     	; 0x66c6 <fgetc+0x72>
    6676:	22 ff       	sbrs	r18, 2
    6678:	0f c0       	rjmp	.+30     	; 0x6698 <fgetc+0x44>
    667a:	e8 81       	ld	r30, Y
    667c:	f9 81       	ldd	r31, Y+1	; 0x01
    667e:	80 81       	ld	r24, Z
    6680:	99 27       	eor	r25, r25
    6682:	87 fd       	sbrc	r24, 7
    6684:	90 95       	com	r25
    6686:	00 97       	sbiw	r24, 0x00	; 0
    6688:	19 f4       	brne	.+6      	; 0x6690 <fgetc+0x3c>
    668a:	20 62       	ori	r18, 0x20	; 32
    668c:	2b 83       	std	Y+3, r18	; 0x03
    668e:	1d c0       	rjmp	.+58     	; 0x66ca <fgetc+0x76>
    6690:	31 96       	adiw	r30, 0x01	; 1
    6692:	f9 83       	std	Y+1, r31	; 0x01
    6694:	e8 83       	st	Y, r30
    6696:	11 c0       	rjmp	.+34     	; 0x66ba <fgetc+0x66>
    6698:	ea 85       	ldd	r30, Y+10	; 0x0a
    669a:	fb 85       	ldd	r31, Y+11	; 0x0b
    669c:	ce 01       	movw	r24, r28
    669e:	09 95       	icall
    66a0:	97 ff       	sbrs	r25, 7
    66a2:	0b c0       	rjmp	.+22     	; 0x66ba <fgetc+0x66>
    66a4:	2b 81       	ldd	r18, Y+3	; 0x03
    66a6:	3f ef       	ldi	r19, 0xFF	; 255
    66a8:	8f 3f       	cpi	r24, 0xFF	; 255
    66aa:	93 07       	cpc	r25, r19
    66ac:	11 f4       	brne	.+4      	; 0x66b2 <fgetc+0x5e>
    66ae:	80 e1       	ldi	r24, 0x10	; 16
    66b0:	01 c0       	rjmp	.+2      	; 0x66b4 <fgetc+0x60>
    66b2:	80 e2       	ldi	r24, 0x20	; 32
    66b4:	82 2b       	or	r24, r18
    66b6:	8b 83       	std	Y+3, r24	; 0x03
    66b8:	08 c0       	rjmp	.+16     	; 0x66ca <fgetc+0x76>
    66ba:	2e 81       	ldd	r18, Y+6	; 0x06
    66bc:	3f 81       	ldd	r19, Y+7	; 0x07
    66be:	2f 5f       	subi	r18, 0xFF	; 255
    66c0:	3f 4f       	sbci	r19, 0xFF	; 255
    66c2:	3f 83       	std	Y+7, r19	; 0x07
    66c4:	2e 83       	std	Y+6, r18	; 0x06
    66c6:	90 e0       	ldi	r25, 0x00	; 0
    66c8:	02 c0       	rjmp	.+4      	; 0x66ce <fgetc+0x7a>
    66ca:	8f ef       	ldi	r24, 0xFF	; 255
    66cc:	9f ef       	ldi	r25, 0xFF	; 255
    66ce:	df 91       	pop	r29
    66d0:	cf 91       	pop	r28
    66d2:	08 95       	ret

000066d4 <fputc>:
    66d4:	0f 93       	push	r16
    66d6:	1f 93       	push	r17
    66d8:	cf 93       	push	r28
    66da:	df 93       	push	r29
    66dc:	8c 01       	movw	r16, r24
    66de:	eb 01       	movw	r28, r22
    66e0:	8b 81       	ldd	r24, Y+3	; 0x03
    66e2:	81 ff       	sbrs	r24, 1
    66e4:	1b c0       	rjmp	.+54     	; 0x671c <fputc+0x48>
    66e6:	82 ff       	sbrs	r24, 2
    66e8:	0d c0       	rjmp	.+26     	; 0x6704 <fputc+0x30>
    66ea:	2e 81       	ldd	r18, Y+6	; 0x06
    66ec:	3f 81       	ldd	r19, Y+7	; 0x07
    66ee:	8c 81       	ldd	r24, Y+4	; 0x04
    66f0:	9d 81       	ldd	r25, Y+5	; 0x05
    66f2:	28 17       	cp	r18, r24
    66f4:	39 07       	cpc	r19, r25
    66f6:	64 f4       	brge	.+24     	; 0x6710 <fputc+0x3c>
    66f8:	e8 81       	ld	r30, Y
    66fa:	f9 81       	ldd	r31, Y+1	; 0x01
    66fc:	01 93       	st	Z+, r16
    66fe:	f9 83       	std	Y+1, r31	; 0x01
    6700:	e8 83       	st	Y, r30
    6702:	06 c0       	rjmp	.+12     	; 0x6710 <fputc+0x3c>
    6704:	e8 85       	ldd	r30, Y+8	; 0x08
    6706:	f9 85       	ldd	r31, Y+9	; 0x09
    6708:	80 2f       	mov	r24, r16
    670a:	09 95       	icall
    670c:	00 97       	sbiw	r24, 0x00	; 0
    670e:	31 f4       	brne	.+12     	; 0x671c <fputc+0x48>
    6710:	8e 81       	ldd	r24, Y+6	; 0x06
    6712:	9f 81       	ldd	r25, Y+7	; 0x07
    6714:	01 96       	adiw	r24, 0x01	; 1
    6716:	9f 83       	std	Y+7, r25	; 0x07
    6718:	8e 83       	std	Y+6, r24	; 0x06
    671a:	02 c0       	rjmp	.+4      	; 0x6720 <fputc+0x4c>
    671c:	0f ef       	ldi	r16, 0xFF	; 255
    671e:	1f ef       	ldi	r17, 0xFF	; 255
    6720:	c8 01       	movw	r24, r16
    6722:	df 91       	pop	r29
    6724:	cf 91       	pop	r28
    6726:	1f 91       	pop	r17
    6728:	0f 91       	pop	r16
    672a:	08 95       	ret

0000672c <ungetc>:
    672c:	fb 01       	movw	r30, r22
    672e:	23 81       	ldd	r18, Z+3	; 0x03
    6730:	20 ff       	sbrs	r18, 0
    6732:	13 c0       	rjmp	.+38     	; 0x675a <ungetc+0x2e>
    6734:	26 fd       	sbrc	r18, 6
    6736:	11 c0       	rjmp	.+34     	; 0x675a <ungetc+0x2e>
    6738:	3f ef       	ldi	r19, 0xFF	; 255
    673a:	8f 3f       	cpi	r24, 0xFF	; 255
    673c:	93 07       	cpc	r25, r19
    673e:	81 f0       	breq	.+32     	; 0x6760 <ungetc+0x34>
    6740:	82 83       	std	Z+2, r24	; 0x02
    6742:	92 2f       	mov	r25, r18
    6744:	90 64       	ori	r25, 0x40	; 64
    6746:	9f 7d       	andi	r25, 0xDF	; 223
    6748:	93 83       	std	Z+3, r25	; 0x03
    674a:	26 81       	ldd	r18, Z+6	; 0x06
    674c:	37 81       	ldd	r19, Z+7	; 0x07
    674e:	21 50       	subi	r18, 0x01	; 1
    6750:	30 40       	sbci	r19, 0x00	; 0
    6752:	37 83       	std	Z+7, r19	; 0x07
    6754:	26 83       	std	Z+6, r18	; 0x06
    6756:	90 e0       	ldi	r25, 0x00	; 0
    6758:	08 95       	ret
    675a:	8f ef       	ldi	r24, 0xFF	; 255
    675c:	9f ef       	ldi	r25, 0xFF	; 255
    675e:	08 95       	ret
    6760:	8f ef       	ldi	r24, 0xFF	; 255
    6762:	9f ef       	ldi	r25, 0xFF	; 255
    6764:	08 95       	ret

00006766 <__ultoa_invert>:
    6766:	fa 01       	movw	r30, r20
    6768:	aa 27       	eor	r26, r26
    676a:	28 30       	cpi	r18, 0x08	; 8
    676c:	51 f1       	breq	.+84     	; 0x67c2 <__ultoa_invert+0x5c>
    676e:	20 31       	cpi	r18, 0x10	; 16
    6770:	81 f1       	breq	.+96     	; 0x67d2 <__ultoa_invert+0x6c>
    6772:	e8 94       	clt
    6774:	6f 93       	push	r22
    6776:	6e 7f       	andi	r22, 0xFE	; 254
    6778:	6e 5f       	subi	r22, 0xFE	; 254
    677a:	7f 4f       	sbci	r23, 0xFF	; 255
    677c:	8f 4f       	sbci	r24, 0xFF	; 255
    677e:	9f 4f       	sbci	r25, 0xFF	; 255
    6780:	af 4f       	sbci	r26, 0xFF	; 255
    6782:	b1 e0       	ldi	r27, 0x01	; 1
    6784:	3e d0       	rcall	.+124    	; 0x6802 <__ultoa_invert+0x9c>
    6786:	b4 e0       	ldi	r27, 0x04	; 4
    6788:	3c d0       	rcall	.+120    	; 0x6802 <__ultoa_invert+0x9c>
    678a:	67 0f       	add	r22, r23
    678c:	78 1f       	adc	r23, r24
    678e:	89 1f       	adc	r24, r25
    6790:	9a 1f       	adc	r25, r26
    6792:	a1 1d       	adc	r26, r1
    6794:	68 0f       	add	r22, r24
    6796:	79 1f       	adc	r23, r25
    6798:	8a 1f       	adc	r24, r26
    679a:	91 1d       	adc	r25, r1
    679c:	a1 1d       	adc	r26, r1
    679e:	6a 0f       	add	r22, r26
    67a0:	71 1d       	adc	r23, r1
    67a2:	81 1d       	adc	r24, r1
    67a4:	91 1d       	adc	r25, r1
    67a6:	a1 1d       	adc	r26, r1
    67a8:	20 d0       	rcall	.+64     	; 0x67ea <__ultoa_invert+0x84>
    67aa:	09 f4       	brne	.+2      	; 0x67ae <__ultoa_invert+0x48>
    67ac:	68 94       	set
    67ae:	3f 91       	pop	r19
    67b0:	2a e0       	ldi	r18, 0x0A	; 10
    67b2:	26 9f       	mul	r18, r22
    67b4:	11 24       	eor	r1, r1
    67b6:	30 19       	sub	r19, r0
    67b8:	30 5d       	subi	r19, 0xD0	; 208
    67ba:	31 93       	st	Z+, r19
    67bc:	de f6       	brtc	.-74     	; 0x6774 <__ultoa_invert+0xe>
    67be:	cf 01       	movw	r24, r30
    67c0:	08 95       	ret
    67c2:	46 2f       	mov	r20, r22
    67c4:	47 70       	andi	r20, 0x07	; 7
    67c6:	40 5d       	subi	r20, 0xD0	; 208
    67c8:	41 93       	st	Z+, r20
    67ca:	b3 e0       	ldi	r27, 0x03	; 3
    67cc:	0f d0       	rcall	.+30     	; 0x67ec <__ultoa_invert+0x86>
    67ce:	c9 f7       	brne	.-14     	; 0x67c2 <__ultoa_invert+0x5c>
    67d0:	f6 cf       	rjmp	.-20     	; 0x67be <__ultoa_invert+0x58>
    67d2:	46 2f       	mov	r20, r22
    67d4:	4f 70       	andi	r20, 0x0F	; 15
    67d6:	40 5d       	subi	r20, 0xD0	; 208
    67d8:	4a 33       	cpi	r20, 0x3A	; 58
    67da:	18 f0       	brcs	.+6      	; 0x67e2 <__ultoa_invert+0x7c>
    67dc:	49 5d       	subi	r20, 0xD9	; 217
    67de:	31 fd       	sbrc	r19, 1
    67e0:	40 52       	subi	r20, 0x20	; 32
    67e2:	41 93       	st	Z+, r20
    67e4:	02 d0       	rcall	.+4      	; 0x67ea <__ultoa_invert+0x84>
    67e6:	a9 f7       	brne	.-22     	; 0x67d2 <__ultoa_invert+0x6c>
    67e8:	ea cf       	rjmp	.-44     	; 0x67be <__ultoa_invert+0x58>
    67ea:	b4 e0       	ldi	r27, 0x04	; 4
    67ec:	a6 95       	lsr	r26
    67ee:	97 95       	ror	r25
    67f0:	87 95       	ror	r24
    67f2:	77 95       	ror	r23
    67f4:	67 95       	ror	r22
    67f6:	ba 95       	dec	r27
    67f8:	c9 f7       	brne	.-14     	; 0x67ec <__ultoa_invert+0x86>
    67fa:	00 97       	sbiw	r24, 0x00	; 0
    67fc:	61 05       	cpc	r22, r1
    67fe:	71 05       	cpc	r23, r1
    6800:	08 95       	ret
    6802:	9b 01       	movw	r18, r22
    6804:	ac 01       	movw	r20, r24
    6806:	0a 2e       	mov	r0, r26
    6808:	06 94       	lsr	r0
    680a:	57 95       	ror	r21
    680c:	47 95       	ror	r20
    680e:	37 95       	ror	r19
    6810:	27 95       	ror	r18
    6812:	ba 95       	dec	r27
    6814:	c9 f7       	brne	.-14     	; 0x6808 <__ultoa_invert+0xa2>
    6816:	62 0f       	add	r22, r18
    6818:	73 1f       	adc	r23, r19
    681a:	84 1f       	adc	r24, r20
    681c:	95 1f       	adc	r25, r21
    681e:	a0 1d       	adc	r26, r0
    6820:	08 95       	ret

00006822 <__ctype_isfalse>:
    6822:	99 27       	eor	r25, r25
    6824:	88 27       	eor	r24, r24

00006826 <__ctype_istrue>:
    6826:	08 95       	ret

00006828 <_exit>:
    6828:	f8 94       	cli

0000682a <__stop_program>:
    682a:	ff cf       	rjmp	.-2      	; 0x682a <__stop_program>
