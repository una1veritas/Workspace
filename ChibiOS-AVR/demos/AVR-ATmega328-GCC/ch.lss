
ch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009a  00800100  00003fba  0000404e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003fba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000011d  0080019a  0080019a  000040e8  2**0
                  ALLOC
  3 .stab         000031bc  00000000  00000000  000040e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000103b  00000000  00000000  000072a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000082df  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000005d0  00000000  00000000  000082f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000ed16  00000000  00000000  000088c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003ed7  00000000  00000000  000175d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000032d1  00000000  00000000  0001b4ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001acc  00000000  00000000  0001e780  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001bdc  00000000  00000000  0002024c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00007b0f  00000000  00000000  00021e28  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000220  00000000  00000000  00029937  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 45 00 	jmp	0x8a	; 0x8a <__ctors_end>
       4:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
       8:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
       c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      10:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      14:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      18:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      1c:	0c 94 d0 14 	jmp	0x29a0	; 0x29a0 <__vector_7>
      20:	0c 94 01 15 	jmp	0x2a02	; 0x2a02 <__vector_8>
      24:	0c 94 9f 14 	jmp	0x293e	; 0x293e <__vector_9>
      28:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      2c:	0c 94 3d 14 	jmp	0x287a	; 0x287a <__vector_11>
      30:	0c 94 6e 14 	jmp	0x28dc	; 0x28dc <__vector_12>
      34:	0c 94 0c 14 	jmp	0x2818	; 0x2818 <__vector_13>
      38:	0c 94 64 00 	jmp	0xc8	; 0xc8 <__vector_14>
      3c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      40:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      44:	0c 94 f5 16 	jmp	0x2dea	; 0x2dea <__vector_17>
      48:	0c 94 b8 11 	jmp	0x2370	; 0x2370 <__vector_18>
      4c:	0c 94 f8 11 	jmp	0x23f0	; 0x23f0 <__vector_19>
      50:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      54:	0c 94 76 12 	jmp	0x24ec	; 0x24ec <__vector_21>
      58:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      5c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      60:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
      64:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>

00000068 <__c.1844>:
      68:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

00000078 <__c.1850>:
      78:	45 46 47 65 66 67 00                                EFGefg.

0000007f <__c.1977>:
      7f:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000008a <__ctors_end>:
      8a:	11 24       	eor	r1, r1
      8c:	1f be       	out	0x3f, r1	; 63
      8e:	cf ef       	ldi	r28, 0xFF	; 255
      90:	d8 e0       	ldi	r29, 0x08	; 8
      92:	de bf       	out	0x3e, r29	; 62
      94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
      96:	11 e0       	ldi	r17, 0x01	; 1
      98:	a0 e0       	ldi	r26, 0x00	; 0
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	ea eb       	ldi	r30, 0xBA	; 186
      9e:	ff e3       	ldi	r31, 0x3F	; 63
      a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
      a2:	05 90       	lpm	r0, Z+
      a4:	0d 92       	st	X+, r0
      a6:	aa 39       	cpi	r26, 0x9A	; 154
      a8:	b1 07       	cpc	r27, r17
      aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
      ac:	12 e0       	ldi	r17, 0x02	; 2
      ae:	aa e9       	ldi	r26, 0x9A	; 154
      b0:	b1 e0       	ldi	r27, 0x01	; 1
      b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
      b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
      b6:	a7 3b       	cpi	r26, 0xB7	; 183
      b8:	b1 07       	cpc	r27, r17
      ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
      bc:	0e 94 02 1b 	call	0x3604	; 0x3604 <main>
      c0:	0c 94 db 1f 	jmp	0x3fb6	; 0x3fb6 <_exit>

000000c4 <__bad_interrupt>:
      c4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000c8 <__vector_14>:


/**
 * @brief   Timer0 interrupt handler.
 */
CH_IRQ_HANDLER(TIMER0_COMPA_vect) {
      c8:	1f 92       	push	r1
      ca:	0f 92       	push	r0
      cc:	0f b6       	in	r0, 0x3f	; 63
      ce:	0f 92       	push	r0
      d0:	11 24       	eor	r1, r1
      d2:	2f 93       	push	r18
      d4:	3f 93       	push	r19
      d6:	4f 93       	push	r20
      d8:	5f 93       	push	r21
      da:	6f 93       	push	r22
      dc:	7f 93       	push	r23
      de:	8f 93       	push	r24
      e0:	9f 93       	push	r25
      e2:	af 93       	push	r26
      e4:	bf 93       	push	r27
      e6:	ef 93       	push	r30
      e8:	ff 93       	push	r31

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
  chSysTimerHandlerI();
      ea:	0e 94 f7 00 	call	0x1ee	; 0x1ee <chSysTimerHandlerI>
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
      ee:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
      f2:	81 11       	cpse	r24, r1
      f4:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
      f8:	ff 91       	pop	r31
      fa:	ef 91       	pop	r30
      fc:	bf 91       	pop	r27
      fe:	af 91       	pop	r26
     100:	9f 91       	pop	r25
     102:	8f 91       	pop	r24
     104:	7f 91       	pop	r23
     106:	6f 91       	pop	r22
     108:	5f 91       	pop	r21
     10a:	4f 91       	pop	r20
     10c:	3f 91       	pop	r19
     10e:	2f 91       	pop	r18
     110:	0f 90       	pop	r0
     112:	0f be       	out	0x3f, r0	; 63
     114:	0f 90       	pop	r0
     116:	1f 90       	pop	r1
     118:	18 95       	reti

0000011a <port_switch>:
#if !defined(__DOXYGEN__)
__attribute__((naked, weak))
#endif
void port_switch(Thread *ntp, Thread *otp) {

  asm volatile ("push    r2");
     11a:	2f 92       	push	r2
  asm volatile ("push    r3");
     11c:	3f 92       	push	r3
  asm volatile ("push    r4");
     11e:	4f 92       	push	r4
  asm volatile ("push    r5");
     120:	5f 92       	push	r5
  asm volatile ("push    r6");
     122:	6f 92       	push	r6
  asm volatile ("push    r7");
     124:	7f 92       	push	r7
  asm volatile ("push    r8");
     126:	8f 92       	push	r8
  asm volatile ("push    r9");
     128:	9f 92       	push	r9
  asm volatile ("push    r10");
     12a:	af 92       	push	r10
  asm volatile ("push    r11");
     12c:	bf 92       	push	r11
  asm volatile ("push    r12");
     12e:	cf 92       	push	r12
  asm volatile ("push    r13");
     130:	df 92       	push	r13
  asm volatile ("push    r14");
     132:	ef 92       	push	r14
  asm volatile ("push    r15");
     134:	ff 92       	push	r15
  asm volatile ("push    r16");
     136:	0f 93       	push	r16
  asm volatile ("push    r17");
     138:	1f 93       	push	r17
  asm volatile ("push    r28");
     13a:	cf 93       	push	r28
  asm volatile ("push    r29");
     13c:	df 93       	push	r29

  asm volatile ("movw    r30, r22");
     13e:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
     140:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
     142:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
     144:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
     146:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
     148:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
     14a:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
     14c:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
     14e:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
     150:	0e be       	out	0x3e, r0	; 62

  asm volatile ("pop     r29");
     152:	df 91       	pop	r29
  asm volatile ("pop     r28");
     154:	cf 91       	pop	r28
  asm volatile ("pop     r17");
     156:	1f 91       	pop	r17
  asm volatile ("pop     r16");
     158:	0f 91       	pop	r16
  asm volatile ("pop     r15");
     15a:	ff 90       	pop	r15
  asm volatile ("pop     r14");
     15c:	ef 90       	pop	r14
  asm volatile ("pop     r13");
     15e:	df 90       	pop	r13
  asm volatile ("pop     r12");
     160:	cf 90       	pop	r12
  asm volatile ("pop     r11");
     162:	bf 90       	pop	r11
  asm volatile ("pop     r10");
     164:	af 90       	pop	r10
  asm volatile ("pop     r9");
     166:	9f 90       	pop	r9
  asm volatile ("pop     r8");
     168:	8f 90       	pop	r8
  asm volatile ("pop     r7");
     16a:	7f 90       	pop	r7
  asm volatile ("pop     r6");
     16c:	6f 90       	pop	r6
  asm volatile ("pop     r5");
     16e:	5f 90       	pop	r5
  asm volatile ("pop     r4");
     170:	4f 90       	pop	r4
  asm volatile ("pop     r3");
     172:	3f 90       	pop	r3
  asm volatile ("pop     r2");
     174:	2f 90       	pop	r2
  asm volatile ("ret");
     176:	08 95       	ret

00000178 <port_halt>:
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void port_halt(void) {

  port_disable();
     178:	f8 94       	cli
     17a:	ff cf       	rjmp	.-2      	; 0x17a <port_halt+0x2>

0000017c <_port_thread_start>:
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
     17c:	78 94       	sei
  asm volatile ("movw    r24, r4");
     17e:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
     180:	f1 01       	movw	r30, r2
  asm volatile ("icall");
     182:	09 95       	icall
  asm volatile ("call    chThdExit");
     184:	0e 94 bd 04 	call	0x97a	; 0x97a <chThdExit>
     188:	08 95       	ret

0000018a <_idle_thread>:
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
     18a:	e0 91 3a 02 	lds	r30, 0x023A
     18e:	f0 91 3b 02 	lds	r31, 0x023B
     192:	83 e8       	ldi	r24, 0x83	; 131
     194:	91 e0       	ldi	r25, 0x01	; 1
     196:	94 87       	std	Z+12, r25	; 0x0c
     198:	83 87       	std	Z+11, r24	; 0x0b
     19a:	ff cf       	rjmp	.-2      	; 0x19a <_idle_thread+0x10>

0000019c <chSysInit>:
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
     19c:	0f 93       	push	r16
     19e:	1f 93       	push	r17
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
     1a0:	0e 94 21 02 	call	0x442	; 0x442 <_scheduler_init>
  _vt_init();
     1a4:	0e 94 4c 01 	call	0x298	; 0x298 <_vt_init>
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
     1a8:	60 e4       	ldi	r22, 0x40	; 64
     1aa:	8a e9       	ldi	r24, 0x9A	; 154
     1ac:	91 e0       	ldi	r25, 0x01	; 1
     1ae:	0e 94 a8 03 	call	0x750	; 0x750 <_thread_init>
     1b2:	90 93 3b 02 	sts	0x023B, r25
     1b6:	80 93 3a 02 	sts	0x023A, r24
  currp->p_state = THD_STATE_CURRENT;
     1ba:	21 e0       	ldi	r18, 0x01	; 1
     1bc:	fc 01       	movw	r30, r24
     1be:	25 87       	std	Z+13, r18	; 0x0d
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
     1c0:	78 94       	sei

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
     1c2:	e0 91 3a 02 	lds	r30, 0x023A
     1c6:	f0 91 3b 02 	lds	r31, 0x023B
     1ca:	84 e5       	ldi	r24, 0x54	; 84
     1cc:	91 e0       	ldi	r25, 0x01	; 1
     1ce:	94 87       	std	Z+12, r25	; 0x0c
     1d0:	83 87       	std	Z+11, r24	; 0x0b

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	10 e0       	ldi	r17, 0x00	; 0
     1d6:	25 ec       	ldi	r18, 0xC5	; 197
     1d8:	30 e0       	ldi	r19, 0x00	; 0
     1da:	41 e0       	ldi	r20, 0x01	; 1
     1dc:	6d e6       	ldi	r22, 0x6D	; 109
     1de:	70 e0       	ldi	r23, 0x00	; 0
     1e0:	8a eb       	ldi	r24, 0xBA	; 186
     1e2:	91 e0       	ldi	r25, 0x01	; 1
     1e4:	0e 94 29 04 	call	0x852	; 0x852 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
     1e8:	1f 91       	pop	r17
     1ea:	0f 91       	pop	r16
     1ec:	08 95       	ret

000001ee <chSysTimerHandlerI>:
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     1ee:	0f 93       	push	r16
     1f0:	1f 93       	push	r17
     1f2:	cf 93       	push	r28
     1f4:	df 93       	push	r29

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
     1f6:	e0 91 3a 02 	lds	r30, 0x023A
     1fa:	f0 91 3b 02 	lds	r31, 0x023B
     1fe:	87 85       	ldd	r24, Z+15	; 0x0f
     200:	88 23       	and	r24, r24
     202:	11 f0       	breq	.+4      	; 0x208 <chSysTimerHandlerI+0x1a>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
     204:	81 50       	subi	r24, 0x01	; 1
     206:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
     208:	80 89       	ldd	r24, Z+16	; 0x10
     20a:	91 89       	ldd	r25, Z+17	; 0x11
     20c:	01 96       	adiw	r24, 0x01	; 1
     20e:	91 8b       	std	Z+17, r25	; 0x11
     210:	80 8b       	std	Z+16, r24	; 0x10
#endif
  chVTDoTickI();
     212:	80 91 2d 02 	lds	r24, 0x022D
     216:	90 91 2e 02 	lds	r25, 0x022E
     21a:	01 96       	adiw	r24, 0x01	; 1
     21c:	90 93 2e 02 	sts	0x022E, r25
     220:	80 93 2d 02 	sts	0x022D, r24
     224:	a0 91 27 02 	lds	r26, 0x0227
     228:	b0 91 28 02 	lds	r27, 0x0228
     22c:	82 e0       	ldi	r24, 0x02	; 2
     22e:	a7 32       	cpi	r26, 0x27	; 39
     230:	b8 07       	cpc	r27, r24
     232:	69 f1       	breq	.+90     	; 0x28e <chSysTimerHandlerI+0xa0>
     234:	14 96       	adiw	r26, 0x04	; 4
     236:	8d 91       	ld	r24, X+
     238:	9c 91       	ld	r25, X
     23a:	15 97       	sbiw	r26, 0x05	; 5
     23c:	01 97       	sbiw	r24, 0x01	; 1
     23e:	15 96       	adiw	r26, 0x05	; 5
     240:	9c 93       	st	X, r25
     242:	8e 93       	st	-X, r24
     244:	14 97       	sbiw	r26, 0x04	; 4
     246:	89 2b       	or	r24, r25
     248:	11 f5       	brne	.+68     	; 0x28e <chSysTimerHandlerI+0xa0>
     24a:	07 e2       	ldi	r16, 0x27	; 39
     24c:	12 e0       	ldi	r17, 0x02	; 2
     24e:	16 96       	adiw	r26, 0x06	; 6
     250:	ed 91       	ld	r30, X+
     252:	fc 91       	ld	r31, X
     254:	17 97       	sbiw	r26, 0x07	; 7
     256:	17 96       	adiw	r26, 0x07	; 7
     258:	1c 92       	st	X, r1
     25a:	1e 92       	st	-X, r1
     25c:	16 97       	sbiw	r26, 0x06	; 6
     25e:	cd 91       	ld	r28, X+
     260:	dc 91       	ld	r29, X
     262:	11 97       	sbiw	r26, 0x01	; 1
     264:	1b 83       	std	Y+3, r17	; 0x03
     266:	0a 83       	std	Y+2, r16	; 0x02
     268:	d0 93 28 02 	sts	0x0228, r29
     26c:	c0 93 27 02 	sts	0x0227, r28
     270:	18 96       	adiw	r26, 0x08	; 8
     272:	8d 91       	ld	r24, X+
     274:	9c 91       	ld	r25, X
     276:	19 97       	sbiw	r26, 0x09	; 9
     278:	09 95       	icall
     27a:	a0 91 27 02 	lds	r26, 0x0227
     27e:	b0 91 28 02 	lds	r27, 0x0228
     282:	14 96       	adiw	r26, 0x04	; 4
     284:	8d 91       	ld	r24, X+
     286:	9c 91       	ld	r25, X
     288:	15 97       	sbiw	r26, 0x05	; 5
     28a:	89 2b       	or	r24, r25
     28c:	01 f3       	breq	.-64     	; 0x24e <chSysTimerHandlerI+0x60>
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
     28e:	df 91       	pop	r29
     290:	cf 91       	pop	r28
     292:	1f 91       	pop	r17
     294:	0f 91       	pop	r16
     296:	08 95       	ret

00000298 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
     298:	e7 e2       	ldi	r30, 0x27	; 39
     29a:	f2 e0       	ldi	r31, 0x02	; 2
     29c:	f0 93 2a 02 	sts	0x022A, r31
     2a0:	e0 93 29 02 	sts	0x0229, r30
     2a4:	f1 83       	std	Z+1, r31	; 0x01
     2a6:	e0 83       	st	Z, r30
  vtlist.vt_time = (systime_t)-1;
     2a8:	8f ef       	ldi	r24, 0xFF	; 255
     2aa:	9f ef       	ldi	r25, 0xFF	; 255
     2ac:	90 93 2c 02 	sts	0x022C, r25
     2b0:	80 93 2b 02 	sts	0x022B, r24
  vtlist.vt_systime = 0;
     2b4:	10 92 2e 02 	sts	0x022E, r1
     2b8:	10 92 2d 02 	sts	0x022D, r1
     2bc:	08 95       	ret

000002be <chVTSetI>:
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
     2be:	cf 93       	push	r28
     2c0:	df 93       	push	r29
     2c2:	dc 01       	movw	r26, r24

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
     2c4:	19 96       	adiw	r26, 0x09	; 9
     2c6:	3c 93       	st	X, r19
     2c8:	2e 93       	st	-X, r18
     2ca:	18 97       	sbiw	r26, 0x08	; 8
  vtp->vt_func = vtfunc;
     2cc:	17 96       	adiw	r26, 0x07	; 7
     2ce:	5c 93       	st	X, r21
     2d0:	4e 93       	st	-X, r20
     2d2:	16 97       	sbiw	r26, 0x06	; 6
  p = vtlist.vt_next;
     2d4:	e0 91 27 02 	lds	r30, 0x0227
     2d8:	f0 91 28 02 	lds	r31, 0x0228
  while (p->vt_time < time) {
     2dc:	24 81       	ldd	r18, Z+4	; 0x04
     2de:	35 81       	ldd	r19, Z+5	; 0x05
     2e0:	26 17       	cp	r18, r22
     2e2:	37 07       	cpc	r19, r23
     2e4:	50 f4       	brcc	.+20     	; 0x2fa <chVTSetI+0x3c>
    time -= p->vt_time;
     2e6:	62 1b       	sub	r22, r18
     2e8:	73 0b       	sbc	r23, r19
    p = p->vt_next;
     2ea:	01 90       	ld	r0, Z+
     2ec:	f0 81       	ld	r31, Z
     2ee:	e0 2d       	mov	r30, r0
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
     2f0:	24 81       	ldd	r18, Z+4	; 0x04
     2f2:	35 81       	ldd	r19, Z+5	; 0x05
     2f4:	26 17       	cp	r18, r22
     2f6:	37 07       	cpc	r19, r23
     2f8:	b0 f3       	brcs	.-20     	; 0x2e6 <chVTSetI+0x28>
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
     2fa:	11 96       	adiw	r26, 0x01	; 1
     2fc:	fc 93       	st	X, r31
     2fe:	ee 93       	st	-X, r30
     300:	c2 81       	ldd	r28, Z+2	; 0x02
     302:	d3 81       	ldd	r29, Z+3	; 0x03
     304:	13 96       	adiw	r26, 0x03	; 3
     306:	dc 93       	st	X, r29
     308:	ce 93       	st	-X, r28
     30a:	12 97       	sbiw	r26, 0x02	; 2
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
     30c:	b3 83       	std	Z+3, r27	; 0x03
     30e:	a2 83       	std	Z+2, r26	; 0x02
     310:	b9 83       	std	Y+1, r27	; 0x01
     312:	a8 83       	st	Y, r26
  vtp->vt_time = time;
     314:	15 96       	adiw	r26, 0x05	; 5
     316:	7c 93       	st	X, r23
     318:	6e 93       	st	-X, r22
     31a:	14 97       	sbiw	r26, 0x04	; 4
  if (p != (void *)&vtlist)
     31c:	82 e0       	ldi	r24, 0x02	; 2
     31e:	e7 32       	cpi	r30, 0x27	; 39
     320:	f8 07       	cpc	r31, r24
     322:	31 f0       	breq	.+12     	; 0x330 <chVTSetI+0x72>
    p->vt_time -= time;
     324:	84 81       	ldd	r24, Z+4	; 0x04
     326:	95 81       	ldd	r25, Z+5	; 0x05
     328:	86 1b       	sub	r24, r22
     32a:	97 0b       	sbc	r25, r23
     32c:	95 83       	std	Z+5, r25	; 0x05
     32e:	84 83       	std	Z+4, r24	; 0x04
}
     330:	df 91       	pop	r29
     332:	cf 91       	pop	r28
     334:	08 95       	ret

00000336 <chVTResetI>:
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
     336:	cf 93       	push	r28
     338:	df 93       	push	r29
     33a:	fc 01       	movw	r30, r24
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
     33c:	a0 81       	ld	r26, Z
     33e:	b1 81       	ldd	r27, Z+1	; 0x01
     340:	82 e0       	ldi	r24, 0x02	; 2
     342:	a7 32       	cpi	r26, 0x27	; 39
     344:	b8 07       	cpc	r27, r24
     346:	61 f0       	breq	.+24     	; 0x360 <chVTResetI+0x2a>
    vtp->vt_next->vt_time += vtp->vt_time;
     348:	14 96       	adiw	r26, 0x04	; 4
     34a:	8d 91       	ld	r24, X+
     34c:	9c 91       	ld	r25, X
     34e:	15 97       	sbiw	r26, 0x05	; 5
     350:	24 81       	ldd	r18, Z+4	; 0x04
     352:	35 81       	ldd	r19, Z+5	; 0x05
     354:	82 0f       	add	r24, r18
     356:	93 1f       	adc	r25, r19
     358:	15 96       	adiw	r26, 0x05	; 5
     35a:	9c 93       	st	X, r25
     35c:	8e 93       	st	-X, r24
     35e:	14 97       	sbiw	r26, 0x04	; 4
  vtp->vt_prev->vt_next = vtp->vt_next;
     360:	c2 81       	ldd	r28, Z+2	; 0x02
     362:	d3 81       	ldd	r29, Z+3	; 0x03
     364:	b9 83       	std	Y+1, r27	; 0x01
     366:	a8 83       	st	Y, r26
  vtp->vt_next->vt_prev = vtp->vt_prev;
     368:	a0 81       	ld	r26, Z
     36a:	b1 81       	ldd	r27, Z+1	; 0x01
     36c:	13 96       	adiw	r26, 0x03	; 3
     36e:	dc 93       	st	X, r29
     370:	ce 93       	st	-X, r28
     372:	12 97       	sbiw	r26, 0x02	; 2
  vtp->vt_func = (vtfunc_t)NULL;
     374:	17 82       	std	Z+7, r1	; 0x07
     376:	16 82       	std	Z+6, r1	; 0x06
}
     378:	df 91       	pop	r29
     37a:	cf 91       	pop	r28
     37c:	08 95       	ret

0000037e <chTimeIsWithin>:
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
     37e:	20 91 2d 02 	lds	r18, 0x022D
     382:	30 91 2e 02 	lds	r19, 0x022E
  return end > start ? (time >= start) && (time < end) :
     386:	86 17       	cp	r24, r22
     388:	97 07       	cpc	r25, r23
     38a:	50 f4       	brcc	.+20     	; 0x3a0 <chTimeIsWithin+0x22>
     38c:	28 17       	cp	r18, r24
     38e:	39 07       	cpc	r19, r25
     390:	28 f0       	brcs	.+10     	; 0x39c <chTimeIsWithin+0x1e>
                       (time >= start) || (time < end);
     392:	81 e0       	ldi	r24, 0x01	; 1
     394:	26 17       	cp	r18, r22
     396:	37 07       	cpc	r19, r23
     398:	08 f4       	brcc	.+2      	; 0x39c <chTimeIsWithin+0x1e>
}
     39a:	08 95       	ret
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
                       (time >= start) || (time < end);
     39c:	80 e0       	ldi	r24, 0x00	; 0
     39e:	08 95       	ret
     3a0:	28 17       	cp	r18, r24
     3a2:	39 07       	cpc	r19, r25
     3a4:	b0 f3       	brcs	.-20     	; 0x392 <chTimeIsWithin+0x14>
     3a6:	81 e0       	ldi	r24, 0x01	; 1
}
     3a8:	08 95       	ret

000003aa <wakeup>:

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
     3aa:	cf 93       	push	r28
     3ac:	df 93       	push	r29
     3ae:	dc 01       	movw	r26, r24
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
  switch (tp->p_state) {
     3b0:	1d 96       	adiw	r26, 0x0d	; 13
     3b2:	8c 91       	ld	r24, X
     3b4:	1d 97       	sbiw	r26, 0x0d	; 13
     3b6:	83 30       	cpi	r24, 0x03	; 3
     3b8:	71 f1       	breq	.+92     	; 0x416 <wakeup+0x6c>
     3ba:	40 f1       	brcs	.+80     	; 0x40c <wakeup+0x62>
     3bc:	85 30       	cpi	r24, 0x05	; 5
     3be:	91 f1       	breq	.+100    	; 0x424 <wakeup+0x7a>
     3c0:	8d 30       	cpi	r24, 0x0D	; 13
     3c2:	81 f1       	breq	.+96     	; 0x424 <wakeup+0x7a>
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
     3c4:	8f ef       	ldi	r24, 0xFF	; 255
     3c6:	9f ef       	ldi	r25, 0xFF	; 255
     3c8:	53 96       	adiw	r26, 0x13	; 19
     3ca:	9c 93       	st	X, r25
     3cc:	8e 93       	st	-X, r24
     3ce:	52 97       	sbiw	r26, 0x12	; 18
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     3d0:	1d 96       	adiw	r26, 0x0d	; 13
     3d2:	1c 92       	st	X, r1
     3d4:	1d 97       	sbiw	r26, 0x0d	; 13
     3d6:	14 96       	adiw	r26, 0x04	; 4
     3d8:	9c 91       	ld	r25, X
     3da:	14 97       	sbiw	r26, 0x04	; 4
  cp = (Thread *)&rlist.r_queue;
     3dc:	ef e2       	ldi	r30, 0x2F	; 47
     3de:	f2 e0       	ldi	r31, 0x02	; 2
  do {
    cp = cp->p_next;
     3e0:	01 90       	ld	r0, Z+
     3e2:	f0 81       	ld	r31, Z
     3e4:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     3e6:	84 81       	ldd	r24, Z+4	; 0x04
     3e8:	89 17       	cp	r24, r25
     3ea:	d0 f7       	brcc	.-12     	; 0x3e0 <wakeup+0x36>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     3ec:	11 96       	adiw	r26, 0x01	; 1
     3ee:	fc 93       	st	X, r31
     3f0:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     3f2:	c2 81       	ldd	r28, Z+2	; 0x02
     3f4:	d3 81       	ldd	r29, Z+3	; 0x03
     3f6:	13 96       	adiw	r26, 0x03	; 3
     3f8:	dc 93       	st	X, r29
     3fa:	ce 93       	st	-X, r28
     3fc:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     3fe:	b3 83       	std	Z+3, r27	; 0x03
     400:	a2 83       	std	Z+2, r26	; 0x02
     402:	b9 83       	std	Y+1, r27	; 0x01
     404:	a8 83       	st	Y, r26
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromIsr();
}
     406:	df 91       	pop	r29
     408:	cf 91       	pop	r28
     40a:	08 95       	ret
 */
static void wakeup(void *p) {
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
  switch (tp->p_state) {
     40c:	81 11       	cpse	r24, r1
     40e:	da cf       	rjmp	.-76     	; 0x3c4 <wakeup+0x1a>
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromIsr();
}
     410:	df 91       	pop	r29
     412:	cf 91       	pop	r28
     414:	08 95       	ret
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
     416:	52 96       	adiw	r26, 0x12	; 18
     418:	ed 91       	ld	r30, X+
     41a:	fc 91       	ld	r31, X
     41c:	53 97       	sbiw	r26, 0x13	; 19
     41e:	84 81       	ldd	r24, Z+4	; 0x04
     420:	8f 5f       	subi	r24, 0xFF	; 255
     422:	84 83       	std	Z+4, r24	; 0x04
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     424:	12 96       	adiw	r26, 0x02	; 2
     426:	ed 91       	ld	r30, X+
     428:	fc 91       	ld	r31, X
     42a:	13 97       	sbiw	r26, 0x03	; 3
     42c:	8d 91       	ld	r24, X+
     42e:	9c 91       	ld	r25, X
     430:	11 97       	sbiw	r26, 0x01	; 1
     432:	91 83       	std	Z+1, r25	; 0x01
     434:	80 83       	st	Z, r24
  tp->p_next->p_prev = tp->p_prev;
     436:	cd 91       	ld	r28, X+
     438:	dc 91       	ld	r29, X
     43a:	11 97       	sbiw	r26, 0x01	; 1
     43c:	fb 83       	std	Y+3, r31	; 0x03
     43e:	ea 83       	std	Y+2, r30	; 0x02
     440:	c1 cf       	rjmp	.-126    	; 0x3c4 <wakeup+0x1a>

00000442 <_scheduler_init>:
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
     442:	ef e2       	ldi	r30, 0x2F	; 47
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	f0 93 32 02 	sts	0x0232, r31
     44a:	e0 93 31 02 	sts	0x0231, r30
     44e:	f1 83       	std	Z+1, r31	; 0x01
     450:	e0 83       	st	Z, r30
  rlist.r_prio = NOPRIO;
     452:	10 92 33 02 	sts	0x0233, r1
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
     456:	f0 93 39 02 	sts	0x0239, r31
     45a:	e0 93 38 02 	sts	0x0238, r30
     45e:	f0 93 37 02 	sts	0x0237, r31
     462:	e0 93 36 02 	sts	0x0236, r30
     466:	08 95       	ret

00000468 <chSchReadyI>:
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
     468:	cf 93       	push	r28
     46a:	df 93       	push	r29
     46c:	dc 01       	movw	r26, r24
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     46e:	1d 96       	adiw	r26, 0x0d	; 13
     470:	1c 92       	st	X, r1
     472:	1d 97       	sbiw	r26, 0x0d	; 13
     474:	14 96       	adiw	r26, 0x04	; 4
     476:	9c 91       	ld	r25, X
     478:	14 97       	sbiw	r26, 0x04	; 4
  cp = (Thread *)&rlist.r_queue;
     47a:	ef e2       	ldi	r30, 0x2F	; 47
     47c:	f2 e0       	ldi	r31, 0x02	; 2
  do {
    cp = cp->p_next;
     47e:	01 90       	ld	r0, Z+
     480:	f0 81       	ld	r31, Z
     482:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     484:	84 81       	ldd	r24, Z+4	; 0x04
     486:	89 17       	cp	r24, r25
     488:	d0 f7       	brcc	.-12     	; 0x47e <chSchReadyI+0x16>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     48a:	11 96       	adiw	r26, 0x01	; 1
     48c:	fc 93       	st	X, r31
     48e:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     490:	c2 81       	ldd	r28, Z+2	; 0x02
     492:	d3 81       	ldd	r29, Z+3	; 0x03
     494:	13 96       	adiw	r26, 0x03	; 3
     496:	dc 93       	st	X, r29
     498:	ce 93       	st	-X, r28
     49a:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     49c:	b3 83       	std	Z+3, r27	; 0x03
     49e:	a2 83       	std	Z+2, r26	; 0x02
     4a0:	b9 83       	std	Y+1, r27	; 0x01
     4a2:	a8 83       	st	Y, r26
  return tp;
}
     4a4:	cd 01       	movw	r24, r26
     4a6:	df 91       	pop	r29
     4a8:	cf 91       	pop	r28
     4aa:	08 95       	ret

000004ac <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
     4ac:	cf 93       	push	r28
     4ae:	df 93       	push	r29
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
     4b0:	2a e3       	ldi	r18, 0x3A	; 58
     4b2:	32 e0       	ldi	r19, 0x02	; 2
     4b4:	d9 01       	movw	r26, r18
     4b6:	6d 91       	ld	r22, X+
     4b8:	7c 91       	ld	r23, X
     4ba:	fb 01       	movw	r30, r22
     4bc:	85 87       	std	Z+13, r24	; 0x0d
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
     4be:	84 e1       	ldi	r24, 0x14	; 20
     4c0:	87 87       	std	Z+15, r24	; 0x0f
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     4c2:	ef e2       	ldi	r30, 0x2F	; 47
     4c4:	f2 e0       	ldi	r31, 0x02	; 2
     4c6:	80 81       	ld	r24, Z
     4c8:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     4ca:	dc 01       	movw	r26, r24
     4cc:	cd 91       	ld	r28, X+
     4ce:	dc 91       	ld	r29, X
     4d0:	11 97       	sbiw	r26, 0x01	; 1
     4d2:	d1 83       	std	Z+1, r29	; 0x01
     4d4:	c0 83       	st	Z, r28
     4d6:	fb 83       	std	Y+3, r31	; 0x03
     4d8:	ea 83       	std	Y+2, r30	; 0x02
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
     4da:	f9 01       	movw	r30, r18
     4dc:	91 83       	std	Z+1, r25	; 0x01
     4de:	80 83       	st	Z, r24
  currp->p_state = THD_STATE_CURRENT;
     4e0:	21 e0       	ldi	r18, 0x01	; 1
     4e2:	1d 96       	adiw	r26, 0x0d	; 13
     4e4:	2c 93       	st	X, r18
  chSysSwitch(currp, otp);
}
     4e6:	df 91       	pop	r29
     4e8:	cf 91       	pop	r28
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
  chSysSwitch(currp, otp);
     4ea:	0c 94 8d 00 	jmp	0x11a	; 0x11a <port_switch>

000004ee <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
     4ee:	1f 93       	push	r17
     4f0:	cf 93       	push	r28
     4f2:	df 93       	push	r29
     4f4:	cd b7       	in	r28, 0x3d	; 61
     4f6:	de b7       	in	r29, 0x3e	; 62
     4f8:	2a 97       	sbiw	r28, 0x0a	; 10
     4fa:	0f b6       	in	r0, 0x3f	; 63
     4fc:	f8 94       	cli
     4fe:	de bf       	out	0x3e, r29	; 62
     500:	0f be       	out	0x3f, r0	; 63
     502:	cd bf       	out	0x3d, r28	; 61
     504:	18 2f       	mov	r17, r24

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
     506:	6f 3f       	cpi	r22, 0xFF	; 255
     508:	8f ef       	ldi	r24, 0xFF	; 255
     50a:	78 07       	cpc	r23, r24
     50c:	29 f1       	breq	.+74     	; 0x558 <chSchGoSleepTimeoutS+0x6a>
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
     50e:	20 91 3a 02 	lds	r18, 0x023A
     512:	30 91 3b 02 	lds	r19, 0x023B
     516:	45 ed       	ldi	r20, 0xD5	; 213
     518:	51 e0       	ldi	r21, 0x01	; 1
     51a:	ce 01       	movw	r24, r28
     51c:	01 96       	adiw	r24, 0x01	; 1
     51e:	0e 94 5f 01 	call	0x2be	; 0x2be <chVTSetI>
    chSchGoSleepS(newstate);
     522:	81 2f       	mov	r24, r17
     524:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
     528:	8f 81       	ldd	r24, Y+7	; 0x07
     52a:	98 85       	ldd	r25, Y+8	; 0x08
     52c:	89 2b       	or	r24, r25
     52e:	21 f0       	breq	.+8      	; 0x538 <chSchGoSleepTimeoutS+0x4a>
      chVTResetI(&vt);
     530:	ce 01       	movw	r24, r28
     532:	01 96       	adiw	r24, 0x01	; 1
     534:	0e 94 9b 01 	call	0x336	; 0x336 <chVTResetI>
  }
  else
    chSchGoSleepS(newstate);
  return currp->p_u.rdymsg;
     538:	e0 91 3a 02 	lds	r30, 0x023A
     53c:	f0 91 3b 02 	lds	r31, 0x023B
}
     540:	82 89       	ldd	r24, Z+18	; 0x12
     542:	93 89       	ldd	r25, Z+19	; 0x13
     544:	2a 96       	adiw	r28, 0x0a	; 10
     546:	0f b6       	in	r0, 0x3f	; 63
     548:	f8 94       	cli
     54a:	de bf       	out	0x3e, r29	; 62
     54c:	0f be       	out	0x3f, r0	; 63
     54e:	cd bf       	out	0x3d, r28	; 61
     550:	df 91       	pop	r29
     552:	cf 91       	pop	r28
     554:	1f 91       	pop	r17
     556:	08 95       	ret
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt))
      chVTResetI(&vt);
  }
  else
    chSchGoSleepS(newstate);
     558:	81 2f       	mov	r24, r17
     55a:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
     55e:	ec cf       	rjmp	.-40     	; 0x538 <chSchGoSleepTimeoutS+0x4a>

00000560 <chSchWakeupS>:
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
     560:	cf 93       	push	r28
     562:	df 93       	push	r29
     564:	dc 01       	movw	r26, r24

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
     566:	53 96       	adiw	r26, 0x13	; 19
     568:	7c 93       	st	X, r23
     56a:	6e 93       	st	-X, r22
     56c:	52 97       	sbiw	r26, 0x12	; 18
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
     56e:	14 96       	adiw	r26, 0x04	; 4
     570:	2c 91       	ld	r18, X
     572:	14 97       	sbiw	r26, 0x04	; 4
     574:	c0 91 3a 02 	lds	r28, 0x023A
     578:	d0 91 3b 02 	lds	r29, 0x023B
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	92 17       	cp	r25, r18
     580:	d8 f0       	brcs	.+54     	; 0x5b8 <chSchWakeupS+0x58>
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     582:	1d 96       	adiw	r26, 0x0d	; 13
     584:	1c 92       	st	X, r1
     586:	1d 97       	sbiw	r26, 0x0d	; 13
  cp = (Thread *)&rlist.r_queue;
     588:	ef e2       	ldi	r30, 0x2F	; 47
     58a:	f2 e0       	ldi	r31, 0x02	; 2
  do {
    cp = cp->p_next;
     58c:	01 90       	ld	r0, Z+
     58e:	f0 81       	ld	r31, Z
     590:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     592:	84 81       	ldd	r24, Z+4	; 0x04
     594:	82 17       	cp	r24, r18
     596:	d0 f7       	brcc	.-12     	; 0x58c <chSchWakeupS+0x2c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     598:	11 96       	adiw	r26, 0x01	; 1
     59a:	fc 93       	st	X, r31
     59c:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     59e:	c2 81       	ldd	r28, Z+2	; 0x02
     5a0:	d3 81       	ldd	r29, Z+3	; 0x03
     5a2:	13 96       	adiw	r26, 0x03	; 3
     5a4:	dc 93       	st	X, r29
     5a6:	ce 93       	st	-X, r28
     5a8:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     5aa:	b3 83       	std	Z+3, r27	; 0x03
     5ac:	a2 83       	std	Z+2, r26	; 0x02
     5ae:	b9 83       	std	Y+1, r27	; 0x01
     5b0:	a8 83       	st	Y, r26
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
     5b2:	df 91       	pop	r29
     5b4:	cf 91       	pop	r28
     5b6:	08 95       	ret
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     5b8:	1d 86       	std	Y+13, r1	; 0x0d
  cp = (Thread *)&rlist.r_queue;
     5ba:	ef e2       	ldi	r30, 0x2F	; 47
     5bc:	f2 e0       	ldi	r31, 0x02	; 2
  do {
    cp = cp->p_next;
     5be:	01 90       	ld	r0, Z+
     5c0:	f0 81       	ld	r31, Z
     5c2:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     5c4:	84 81       	ldd	r24, Z+4	; 0x04
     5c6:	89 17       	cp	r24, r25
     5c8:	d0 f7       	brcc	.-12     	; 0x5be <chSchWakeupS+0x5e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     5ca:	f9 83       	std	Y+1, r31	; 0x01
     5cc:	e8 83       	st	Y, r30
  tp->p_prev = cp->p_prev;
     5ce:	82 81       	ldd	r24, Z+2	; 0x02
     5d0:	93 81       	ldd	r25, Z+3	; 0x03
     5d2:	9b 83       	std	Y+3, r25	; 0x03
     5d4:	8a 83       	std	Y+2, r24	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     5d6:	d3 83       	std	Z+3, r29	; 0x03
     5d8:	c2 83       	std	Z+2, r28	; 0x02
     5da:	fc 01       	movw	r30, r24
     5dc:	d1 83       	std	Z+1, r29	; 0x01
     5de:	c0 83       	st	Z, r28
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
     5e0:	b0 93 3b 02 	sts	0x023B, r27
     5e4:	a0 93 3a 02 	sts	0x023A, r26
    ntp->p_state = THD_STATE_CURRENT;
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	1d 96       	adiw	r26, 0x0d	; 13
     5ec:	8c 93       	st	X, r24
     5ee:	1d 97       	sbiw	r26, 0x0d	; 13
    chSysSwitch(ntp, otp);
     5f0:	be 01       	movw	r22, r28
     5f2:	cd 01       	movw	r24, r26
  }
}
     5f4:	df 91       	pop	r29
     5f6:	cf 91       	pop	r28
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
     5f8:	0c 94 8d 00 	jmp	0x11a	; 0x11a <port_switch>

000005fc <chSchIsPreemptionRequired>:
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_ISPREEMPTIONREQUIRED) || defined(__DOXYGEN__)
bool_t chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&rlist.r_queue);
     5fc:	e0 91 2f 02 	lds	r30, 0x022F
     600:	f0 91 30 02 	lds	r31, 0x0230
     604:	24 81       	ldd	r18, Z+4	; 0x04
  tprio_t p2 = currp->p_prio;
     606:	e0 91 3a 02 	lds	r30, 0x023A
     60a:	f0 91 3b 02 	lds	r31, 0x023B
     60e:	94 81       	ldd	r25, Z+4	; 0x04
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
     610:	87 85       	ldd	r24, Z+15	; 0x0f
     612:	81 11       	cpse	r24, r1
     614:	04 c0       	rjmp	.+8      	; 0x61e <chSchIsPreemptionRequired+0x22>
     616:	81 e0       	ldi	r24, 0x01	; 1
     618:	29 17       	cp	r18, r25
     61a:	20 f0       	brcs	.+8      	; 0x624 <chSchIsPreemptionRequired+0x28>
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
     61c:	08 95       	ret
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
     61e:	81 e0       	ldi	r24, 0x01	; 1
     620:	92 17       	cp	r25, r18
     622:	e0 f3       	brcs	.-8      	; 0x61c <chSchIsPreemptionRequired+0x20>
     624:	80 e0       	ldi	r24, 0x00	; 0
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
     626:	08 95       	ret

00000628 <chSchDoRescheduleBehind>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
     628:	cf 93       	push	r28
     62a:	df 93       	push	r29
  Thread *otp;

  otp = currp;
     62c:	a0 91 3a 02 	lds	r26, 0x023A
     630:	b0 91 3b 02 	lds	r27, 0x023B
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     634:	80 91 2f 02 	lds	r24, 0x022F
     638:	90 91 30 02 	lds	r25, 0x0230

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     63c:	ec 01       	movw	r28, r24
     63e:	e8 81       	ld	r30, Y
     640:	f9 81       	ldd	r31, Y+1	; 0x01
     642:	f0 93 30 02 	sts	0x0230, r31
     646:	e0 93 2f 02 	sts	0x022F, r30
     64a:	2f e2       	ldi	r18, 0x2F	; 47
     64c:	32 e0       	ldi	r19, 0x02	; 2
     64e:	33 83       	std	Z+3, r19	; 0x03
     650:	22 83       	std	Z+2, r18	; 0x02
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
     652:	90 93 3b 02 	sts	0x023B, r25
     656:	80 93 3a 02 	sts	0x023A, r24
  currp->p_state = THD_STATE_CURRENT;
     65a:	21 e0       	ldi	r18, 0x01	; 1
     65c:	2d 87       	std	Y+13, r18	; 0x0d
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
     65e:	24 e1       	ldi	r18, 0x14	; 20
     660:	1f 96       	adiw	r26, 0x0f	; 15
     662:	2c 93       	st	X, r18
     664:	1f 97       	sbiw	r26, 0x0f	; 15
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     666:	1d 96       	adiw	r26, 0x0d	; 13
     668:	1c 92       	st	X, r1
     66a:	1d 97       	sbiw	r26, 0x0d	; 13
     66c:	14 96       	adiw	r26, 0x04	; 4
     66e:	3c 91       	ld	r19, X
     670:	14 97       	sbiw	r26, 0x04	; 4
     672:	fc 01       	movw	r30, r24
     674:	03 c0       	rjmp	.+6      	; 0x67c <chSchDoRescheduleBehind+0x54>
     676:	01 90       	ld	r0, Z+
     678:	f0 81       	ld	r31, Z
     67a:	e0 2d       	mov	r30, r0
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
     67c:	24 81       	ldd	r18, Z+4	; 0x04
     67e:	23 17       	cp	r18, r19
     680:	d0 f7       	brcc	.-12     	; 0x676 <chSchDoRescheduleBehind+0x4e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     682:	11 96       	adiw	r26, 0x01	; 1
     684:	fc 93       	st	X, r31
     686:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     688:	c2 81       	ldd	r28, Z+2	; 0x02
     68a:	d3 81       	ldd	r29, Z+3	; 0x03
     68c:	13 96       	adiw	r26, 0x03	; 3
     68e:	dc 93       	st	X, r29
     690:	ce 93       	st	-X, r28
     692:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     694:	b3 83       	std	Z+3, r27	; 0x03
     696:	a2 83       	std	Z+2, r26	; 0x02
     698:	b9 83       	std	Y+1, r27	; 0x01
     69a:	a8 83       	st	Y, r26
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
     69c:	bd 01       	movw	r22, r26
}
     69e:	df 91       	pop	r29
     6a0:	cf 91       	pop	r28
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
     6a2:	0c 94 8d 00 	jmp	0x11a	; 0x11a <port_switch>

000006a6 <chSchDoRescheduleAhead>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
     6a6:	cf 93       	push	r28
     6a8:	df 93       	push	r29
  Thread *otp, *cp;

  otp = currp;
     6aa:	a0 91 3a 02 	lds	r26, 0x023A
     6ae:	b0 91 3b 02 	lds	r27, 0x023B
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     6b2:	80 91 2f 02 	lds	r24, 0x022F
     6b6:	90 91 30 02 	lds	r25, 0x0230

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     6ba:	ec 01       	movw	r28, r24
     6bc:	e8 81       	ld	r30, Y
     6be:	f9 81       	ldd	r31, Y+1	; 0x01
     6c0:	f0 93 30 02 	sts	0x0230, r31
     6c4:	e0 93 2f 02 	sts	0x022F, r30
     6c8:	2f e2       	ldi	r18, 0x2F	; 47
     6ca:	32 e0       	ldi	r19, 0x02	; 2
     6cc:	33 83       	std	Z+3, r19	; 0x03
     6ce:	22 83       	std	Z+2, r18	; 0x02
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
     6d0:	90 93 3b 02 	sts	0x023B, r25
     6d4:	80 93 3a 02 	sts	0x023A, r24
  currp->p_state = THD_STATE_CURRENT;
     6d8:	21 e0       	ldi	r18, 0x01	; 1
     6da:	2d 87       	std	Y+13, r18	; 0x0d

  otp->p_state = THD_STATE_READY;
     6dc:	1d 96       	adiw	r26, 0x0d	; 13
     6de:	1c 92       	st	X, r1
     6e0:	1d 97       	sbiw	r26, 0x0d	; 13
     6e2:	14 96       	adiw	r26, 0x04	; 4
     6e4:	3c 91       	ld	r19, X
     6e6:	14 97       	sbiw	r26, 0x04	; 4
     6e8:	fc 01       	movw	r30, r24
     6ea:	03 c0       	rjmp	.+6      	; 0x6f2 <chSchDoRescheduleAhead+0x4c>
     6ec:	01 90       	ld	r0, Z+
     6ee:	f0 81       	ld	r31, Z
     6f0:	e0 2d       	mov	r30, r0
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
     6f2:	24 81       	ldd	r18, Z+4	; 0x04
     6f4:	32 17       	cp	r19, r18
     6f6:	d0 f3       	brcs	.-12     	; 0x6ec <chSchDoRescheduleAhead+0x46>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
     6f8:	11 96       	adiw	r26, 0x01	; 1
     6fa:	fc 93       	st	X, r31
     6fc:	ee 93       	st	-X, r30
  otp->p_prev = cp->p_prev;
     6fe:	c2 81       	ldd	r28, Z+2	; 0x02
     700:	d3 81       	ldd	r29, Z+3	; 0x03
     702:	13 96       	adiw	r26, 0x03	; 3
     704:	dc 93       	st	X, r29
     706:	ce 93       	st	-X, r28
     708:	12 97       	sbiw	r26, 0x02	; 2
  otp->p_prev->p_next = cp->p_prev = otp;
     70a:	b3 83       	std	Z+3, r27	; 0x03
     70c:	a2 83       	std	Z+2, r26	; 0x02
     70e:	b9 83       	std	Y+1, r27	; 0x01
     710:	a8 83       	st	Y, r26

  chSysSwitch(currp, otp);
     712:	bd 01       	movw	r22, r26
}
     714:	df 91       	pop	r29
     716:	cf 91       	pop	r28
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
     718:	0c 94 8d 00 	jmp	0x11a	; 0x11a <port_switch>

0000071c <chSchRescheduleS>:
#if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI())
     71c:	a0 91 2f 02 	lds	r26, 0x022F
     720:	b0 91 30 02 	lds	r27, 0x0230
     724:	e0 91 3a 02 	lds	r30, 0x023A
     728:	f0 91 3b 02 	lds	r31, 0x023B
     72c:	14 96       	adiw	r26, 0x04	; 4
     72e:	9c 91       	ld	r25, X
     730:	84 81       	ldd	r24, Z+4	; 0x04
     732:	89 17       	cp	r24, r25
     734:	08 f0       	brcs	.+2      	; 0x738 <chSchRescheduleS+0x1c>
     736:	08 95       	ret
    chSchDoRescheduleAhead();
     738:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <chSchDoRescheduleAhead>

0000073c <chSchDoReschedule>:
void chSchDoReschedule(void) {

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
     73c:	e0 91 3a 02 	lds	r30, 0x023A
     740:	f0 91 3b 02 	lds	r31, 0x023B
     744:	87 85       	ldd	r24, Z+15	; 0x0f
     746:	81 11       	cpse	r24, r1
    chSchDoRescheduleBehind();
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
     748:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <chSchDoRescheduleAhead>
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
     74c:	0c 94 14 03 	jmp	0x628	; 0x628 <chSchDoRescheduleBehind>

00000750 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {
     750:	cf 93       	push	r28
     752:	df 93       	push	r29
     754:	fc 01       	movw	r30, r24

  tp->p_prio = prio;
     756:	64 83       	std	Z+4, r22	; 0x04
  tp->p_state = THD_STATE_SUSPENDED;
     758:	82 e0       	ldi	r24, 0x02	; 2
     75a:	85 87       	std	Z+13, r24	; 0x0d
  tp->p_flags = THD_MEM_MODE_STATIC;
     75c:	16 86       	std	Z+14, r1	; 0x0e
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
     75e:	84 e1       	ldi	r24, 0x14	; 20
     760:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
     762:	67 8f       	std	Z+31, r22	; 0x1f
  tp->p_mtxlist = NULL;
     764:	16 8e       	std	Z+30, r1	; 0x1e
     766:	15 8e       	std	Z+29, r1	; 0x1d
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
     768:	14 8e       	std	Z+28, r1	; 0x1c
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
     76a:	11 8a       	std	Z+17, r1	; 0x11
     76c:	10 8a       	std	Z+16, r1	; 0x10
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
     76e:	14 86       	std	Z+12, r1	; 0x0c
     770:	13 86       	std	Z+11, r1	; 0x0b
  REG_INSERT(tp);
     772:	8f e2       	ldi	r24, 0x2F	; 47
     774:	92 e0       	ldi	r25, 0x02	; 2
     776:	90 87       	std	Z+8, r25	; 0x08
     778:	87 83       	std	Z+7, r24	; 0x07
     77a:	c8 e3       	ldi	r28, 0x38	; 56
     77c:	d2 e0       	ldi	r29, 0x02	; 2
     77e:	a8 81       	ld	r26, Y
     780:	b9 81       	ldd	r27, Y+1	; 0x01
     782:	b2 87       	std	Z+10, r27	; 0x0a
     784:	a1 87       	std	Z+9, r26	; 0x09
     786:	f9 83       	std	Y+1, r31	; 0x01
     788:	e8 83       	st	Y, r30
     78a:	18 96       	adiw	r26, 0x08	; 8
     78c:	fc 93       	st	X, r31
     78e:	ee 93       	st	-X, r30
     790:	17 97       	sbiw	r26, 0x07	; 7
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
     792:	cf 01       	movw	r24, r30
     794:	44 96       	adiw	r24, 0x14	; 20
     796:	95 8b       	std	Z+21, r25	; 0x15
     798:	84 8b       	std	Z+20, r24	; 0x14
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
     79a:	cf 01       	movw	r24, r30
     79c:	46 96       	adiw	r24, 0x16	; 22
     79e:	91 8f       	std	Z+25, r25	; 0x19
     7a0:	80 8f       	std	Z+24, r24	; 0x18
     7a2:	97 8b       	std	Z+23, r25	; 0x17
     7a4:	86 8b       	std	Z+22, r24	; 0x16
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
}
     7a6:	cf 01       	movw	r24, r30
     7a8:	df 91       	pop	r29
     7aa:	cf 91       	pop	r28
     7ac:	08 95       	ret

000007ae <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
     7ae:	0f 93       	push	r16
     7b0:	1f 93       	push	r17
     7b2:	cf 93       	push	r28
     7b4:	df 93       	push	r29
     7b6:	fc 01       	movw	r30, r24
  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
     7b8:	65 51       	subi	r22, 0x15	; 21
     7ba:	71 09       	sbc	r23, r1
     7bc:	68 0f       	add	r22, r24
     7be:	79 1f       	adc	r23, r25
     7c0:	76 83       	std	Z+6, r23	; 0x06
     7c2:	65 83       	std	Z+5, r22	; 0x05
     7c4:	db 01       	movw	r26, r22
     7c6:	52 96       	adiw	r26, 0x12	; 18
     7c8:	2c 93       	st	X, r18
     7ca:	a5 81       	ldd	r26, Z+5	; 0x05
     7cc:	b6 81       	ldd	r27, Z+6	; 0x06
     7ce:	51 96       	adiw	r26, 0x11	; 17
     7d0:	3c 93       	st	X, r19
     7d2:	a5 81       	ldd	r26, Z+5	; 0x05
     7d4:	b6 81       	ldd	r27, Z+6	; 0x06
     7d6:	50 96       	adiw	r26, 0x10	; 16
     7d8:	0c 93       	st	X, r16
     7da:	a5 81       	ldd	r26, Z+5	; 0x05
     7dc:	b6 81       	ldd	r27, Z+6	; 0x06
     7de:	1f 96       	adiw	r26, 0x0f	; 15
     7e0:	1c 93       	st	X, r17
     7e2:	a5 81       	ldd	r26, Z+5	; 0x05
     7e4:	b6 81       	ldd	r27, Z+6	; 0x06
     7e6:	8e eb       	ldi	r24, 0xBE	; 190
     7e8:	90 e0       	ldi	r25, 0x00	; 0
     7ea:	53 96       	adiw	r26, 0x13	; 19
     7ec:	9c 93       	st	X, r25
     7ee:	a5 81       	ldd	r26, Z+5	; 0x05
     7f0:	b6 81       	ldd	r27, Z+6	; 0x06
     7f2:	54 96       	adiw	r26, 0x14	; 20
     7f4:	8c 93       	st	X, r24
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
     7f6:	44 83       	std	Z+4, r20	; 0x04
  tp->p_state = THD_STATE_SUSPENDED;
     7f8:	82 e0       	ldi	r24, 0x02	; 2
     7fa:	85 87       	std	Z+13, r24	; 0x0d
  tp->p_flags = THD_MEM_MODE_STATIC;
     7fc:	16 86       	std	Z+14, r1	; 0x0e
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
     7fe:	84 e1       	ldi	r24, 0x14	; 20
     800:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
     802:	47 8f       	std	Z+31, r20	; 0x1f
  tp->p_mtxlist = NULL;
     804:	16 8e       	std	Z+30, r1	; 0x1e
     806:	15 8e       	std	Z+29, r1	; 0x1d
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
     808:	14 8e       	std	Z+28, r1	; 0x1c
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
     80a:	11 8a       	std	Z+17, r1	; 0x11
     80c:	10 8a       	std	Z+16, r1	; 0x10
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
     80e:	14 86       	std	Z+12, r1	; 0x0c
     810:	13 86       	std	Z+11, r1	; 0x0b
  REG_INSERT(tp);
     812:	8f e2       	ldi	r24, 0x2F	; 47
     814:	92 e0       	ldi	r25, 0x02	; 2
     816:	90 87       	std	Z+8, r25	; 0x08
     818:	87 83       	std	Z+7, r24	; 0x07
     81a:	c8 e3       	ldi	r28, 0x38	; 56
     81c:	d2 e0       	ldi	r29, 0x02	; 2
     81e:	a8 81       	ld	r26, Y
     820:	b9 81       	ldd	r27, Y+1	; 0x01
     822:	b2 87       	std	Z+10, r27	; 0x0a
     824:	a1 87       	std	Z+9, r26	; 0x09
     826:	f9 83       	std	Y+1, r31	; 0x01
     828:	e8 83       	st	Y, r30
     82a:	18 96       	adiw	r26, 0x08	; 8
     82c:	fc 93       	st	X, r31
     82e:	ee 93       	st	-X, r30
     830:	17 97       	sbiw	r26, 0x07	; 7
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
     832:	cf 01       	movw	r24, r30
     834:	44 96       	adiw	r24, 0x14	; 20
     836:	95 8b       	std	Z+21, r25	; 0x15
     838:	84 8b       	std	Z+20, r24	; 0x14
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
     83a:	cf 01       	movw	r24, r30
     83c:	46 96       	adiw	r24, 0x16	; 22
     83e:	91 8f       	std	Z+25, r25	; 0x19
     840:	80 8f       	std	Z+24, r24	; 0x18
     842:	97 8b       	std	Z+23, r25	; 0x17
     844:	86 8b       	std	Z+22, r24	; 0x16
  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
  return _thread_init(tp, prio);
}
     846:	cf 01       	movw	r24, r30
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	1f 91       	pop	r17
     84e:	0f 91       	pop	r16
     850:	08 95       	ret

00000852 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
     852:	0f 93       	push	r16
     854:	1f 93       	push	r17
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
     856:	f8 94       	cli
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
     858:	0e 94 d7 03 	call	0x7ae	; 0x7ae <chThdCreateI>
     85c:	8c 01       	movw	r16, r24
     85e:	60 e0       	ldi	r22, 0x00	; 0
     860:	70 e0       	ldi	r23, 0x00	; 0
     862:	0e 94 b0 02 	call	0x560	; 0x560 <chSchWakeupS>
  chSysUnlock();
     866:	78 94       	sei
  return tp;
}
     868:	c8 01       	movw	r24, r16
     86a:	1f 91       	pop	r17
     86c:	0f 91       	pop	r16
     86e:	08 95       	ret

00000870 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
     870:	cf 93       	push	r28
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");

  chSysLock();
     872:	f8 94       	cli
#if CH_USE_MUTEXES
  oldprio = currp->p_realprio;
     874:	e0 91 3a 02 	lds	r30, 0x023A
     878:	f0 91 3b 02 	lds	r31, 0x023B
     87c:	c7 8d       	ldd	r28, Z+31	; 0x1f
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
     87e:	94 81       	ldd	r25, Z+4	; 0x04
     880:	c9 17       	cp	r28, r25
     882:	11 f0       	breq	.+4      	; 0x888 <chThdSetPriority+0x18>
     884:	98 17       	cp	r25, r24
     886:	08 f4       	brcc	.+2      	; 0x88a <chThdSetPriority+0x1a>
    currp->p_prio = newprio;
     888:	84 83       	std	Z+4, r24	; 0x04
  currp->p_realprio = newprio;
     88a:	87 8f       	std	Z+31, r24	; 0x1f
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
     88c:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  chSysUnlock();
     890:	78 94       	sei
  return oldprio;
}
     892:	8c 2f       	mov	r24, r28
     894:	cf 91       	pop	r28
     896:	08 95       	ret

00000898 <chThdResume>:
 * @param[in] tp        pointer to the thread
 * @return              The pointer to the thread.
 *
 * @api
 */
Thread *chThdResume(Thread *tp) {
     898:	cf 93       	push	r28
     89a:	df 93       	push	r29
     89c:	d8 2f       	mov	r29, r24
     89e:	c9 2f       	mov	r28, r25

  chSysLock();
     8a0:	f8 94       	cli
  chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
              "chThdResume(), #1",
              "thread not in THD_STATE_SUSPENDED state");
  chSchWakeupS(tp, RDY_OK);
     8a2:	60 e0       	ldi	r22, 0x00	; 0
     8a4:	70 e0       	ldi	r23, 0x00	; 0
     8a6:	0e 94 b0 02 	call	0x560	; 0x560 <chSchWakeupS>
  chSysUnlock();
     8aa:	78 94       	sei
  return tp;
}
     8ac:	8d 2f       	mov	r24, r29
     8ae:	9c 2f       	mov	r25, r28
     8b0:	df 91       	pop	r29
     8b2:	cf 91       	pop	r28
     8b4:	08 95       	ret

000008b6 <chThdTerminate>:
 *
 * @api
 */
void chThdTerminate(Thread *tp) {

  chSysLock();
     8b6:	f8 94       	cli
  tp->p_flags |= THD_TERMINATE;
     8b8:	fc 01       	movw	r30, r24
     8ba:	26 85       	ldd	r18, Z+14	; 0x0e
     8bc:	24 60       	ori	r18, 0x04	; 4
     8be:	26 87       	std	Z+14, r18	; 0x0e
  chSysUnlock();
     8c0:	78 94       	sei
     8c2:	08 95       	ret

000008c4 <chThdSleep>:
 */
void chThdSleep(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
     8c4:	f8 94       	cli
  chThdSleepS(time);
     8c6:	bc 01       	movw	r22, r24
     8c8:	86 e0       	ldi	r24, 0x06	; 6
     8ca:	0e 94 77 02 	call	0x4ee	; 0x4ee <chSchGoSleepTimeoutS>
  chSysUnlock();
     8ce:	78 94       	sei
     8d0:	08 95       	ret

000008d2 <chThdSleepUntil>:
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
     8d2:	f8 94       	cli
  if ((time -= chTimeNow()) > 0)
     8d4:	20 91 2d 02 	lds	r18, 0x022D
     8d8:	30 91 2e 02 	lds	r19, 0x022E
     8dc:	82 1b       	sub	r24, r18
     8de:	93 0b       	sbc	r25, r19
     8e0:	21 f0       	breq	.+8      	; 0x8ea <chThdSleepUntil+0x18>
    chThdSleepS(time);
     8e2:	bc 01       	movw	r22, r24
     8e4:	86 e0       	ldi	r24, 0x06	; 6
     8e6:	0e 94 77 02 	call	0x4ee	; 0x4ee <chSchGoSleepTimeoutS>
  chSysUnlock();
     8ea:	78 94       	sei
     8ec:	08 95       	ret

000008ee <chThdYield>:
 *
 * @api
 */
void chThdYield(void) {

  chSysLock();
     8ee:	f8 94       	cli
  chSchDoYieldS();
     8f0:	a0 91 2f 02 	lds	r26, 0x022F
     8f4:	b0 91 30 02 	lds	r27, 0x0230
     8f8:	e0 91 3a 02 	lds	r30, 0x023A
     8fc:	f0 91 3b 02 	lds	r31, 0x023B
     900:	14 96       	adiw	r26, 0x04	; 4
     902:	9c 91       	ld	r25, X
     904:	84 81       	ldd	r24, Z+4	; 0x04
     906:	98 17       	cp	r25, r24
     908:	10 f0       	brcs	.+4      	; 0x90e <__stack+0xf>
     90a:	0e 94 14 03 	call	0x628	; 0x628 <chSchDoRescheduleBehind>
  chSysUnlock();
     90e:	78 94       	sei
     910:	08 95       	ret

00000912 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
     912:	0f 93       	push	r16
     914:	1f 93       	push	r17
     916:	cf 93       	push	r28
     918:	df 93       	push	r29
  Thread *tp = currp;
     91a:	c0 91 3a 02 	lds	r28, 0x023A
     91e:	d0 91 3b 02 	lds	r29, 0x023B

  tp->p_u.exitcode = msg;
     922:	9b 8b       	std	Y+19, r25	; 0x13
     924:	8a 8b       	std	Y+18, r24	; 0x12
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
     926:	8c 89       	ldd	r24, Y+20	; 0x14
     928:	9d 89       	ldd	r25, Y+21	; 0x15
     92a:	8e 01       	movw	r16, r28
     92c:	0c 5e       	subi	r16, 0xEC	; 236
     92e:	1f 4f       	sbci	r17, 0xFF	; 255
     930:	80 17       	cp	r24, r16
     932:	91 07       	cpc	r25, r17
     934:	61 f0       	breq	.+24     	; 0x94e <chThdExitS+0x3c>
}

static INLINE Thread *list_remove(ThreadsList *tlp) {

  Thread *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
     936:	fc 01       	movw	r30, r24
     938:	20 81       	ld	r18, Z
     93a:	31 81       	ldd	r19, Z+1	; 0x01
     93c:	3d 8b       	std	Y+21, r19	; 0x15
     93e:	2c 8b       	std	Y+20, r18	; 0x14
    chSchReadyI(list_remove(&tp->p_waiting));
     940:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
     944:	8c 89       	ldd	r24, Y+20	; 0x14
     946:	9d 89       	ldd	r25, Y+21	; 0x15
     948:	80 17       	cp	r24, r16
     94a:	91 07       	cpc	r25, r17
     94c:	a1 f7       	brne	.-24     	; 0x936 <chThdExitS+0x24>
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
     94e:	8e 85       	ldd	r24, Y+14	; 0x0e
     950:	83 70       	andi	r24, 0x03	; 3
     952:	61 f4       	brne	.+24     	; 0x96c <chThdExitS+0x5a>
    REG_REMOVE(tp);
     954:	e9 85       	ldd	r30, Y+9	; 0x09
     956:	fa 85       	ldd	r31, Y+10	; 0x0a
     958:	8f 81       	ldd	r24, Y+7	; 0x07
     95a:	98 85       	ldd	r25, Y+8	; 0x08
     95c:	90 87       	std	Z+8, r25	; 0x08
     95e:	87 83       	std	Z+7, r24	; 0x07
     960:	af 81       	ldd	r26, Y+7	; 0x07
     962:	b8 85       	ldd	r27, Y+8	; 0x08
     964:	1a 96       	adiw	r26, 0x0a	; 10
     966:	fc 93       	st	X, r31
     968:	ee 93       	st	-X, r30
     96a:	19 97       	sbiw	r26, 0x09	; 9
#endif
  chSchGoSleepS(THD_STATE_FINAL);
     96c:	8e e0       	ldi	r24, 0x0E	; 14
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
     96e:	df 91       	pop	r29
     970:	cf 91       	pop	r28
     972:	1f 91       	pop	r17
     974:	0f 91       	pop	r16
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    REG_REMOVE(tp);
#endif
  chSchGoSleepS(THD_STATE_FINAL);
     976:	0c 94 56 02 	jmp	0x4ac	; 0x4ac <chSchGoSleepS>

0000097a <chThdExit>:
 *
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
     97a:	f8 94       	cli
  chThdExitS(msg);
     97c:	0c 94 89 04 	jmp	0x912	; 0x912 <chThdExitS>

00000980 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(Thread *tp) {
     980:	cf 93       	push	r28
     982:	df 93       	push	r29
     984:	ec 01       	movw	r28, r24
  msg_t msg;

  chDbgCheck(tp != NULL, "chThdWait");

  chSysLock();
     986:	f8 94       	cli
  chDbgAssert(tp != currp, "chThdWait(), #1", "waiting self");
#if CH_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "chThdWait(), #2", "not referenced");
#endif
  if (tp->p_state != THD_STATE_FINAL) {
     988:	8d 85       	ldd	r24, Y+13	; 0x0d
     98a:	8e 30       	cpi	r24, 0x0E	; 14
     98c:	69 f0       	breq	.+26     	; 0x9a8 <chThdWait+0x28>
    list_insert(currp, &tp->p_waiting);
     98e:	e0 91 3a 02 	lds	r30, 0x023A
     992:	f0 91 3b 02 	lds	r31, 0x023B
  return tp;
}

static INLINE void list_insert(Thread *tp, ThreadsList *tlp) {

  tp->p_next = tlp->p_next;
     996:	8c 89       	ldd	r24, Y+20	; 0x14
     998:	9d 89       	ldd	r25, Y+21	; 0x15
     99a:	91 83       	std	Z+1, r25	; 0x01
     99c:	80 83       	st	Z, r24
  tlp->p_next = tp;
     99e:	fd 8b       	std	Y+21, r31	; 0x15
     9a0:	ec 8b       	std	Y+20, r30	; 0x14
    chSchGoSleepS(THD_STATE_WTEXIT);
     9a2:	87 e0       	ldi	r24, 0x07	; 7
     9a4:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
     9a8:	8a 89       	ldd	r24, Y+18	; 0x12
     9aa:	9b 89       	ldd	r25, Y+19	; 0x13
  chSysUnlock();
     9ac:	78 94       	sei
#if CH_USE_DYNAMIC
  chThdRelease(tp);
#endif
  return msg;
}
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	08 95       	ret

000009b4 <chRegFirstThread>:
 * @api
 */
Thread *chRegFirstThread(void) {
  Thread *tp;

  chSysLock();
     9b4:	f8 94       	cli
  tp = rlist.r_newer;
     9b6:	e6 e3       	ldi	r30, 0x36	; 54
     9b8:	f2 e0       	ldi	r31, 0x02	; 2
     9ba:	80 81       	ld	r24, Z
     9bc:	91 81       	ldd	r25, Z+1	; 0x01
#if CH_USE_DYNAMIC
  tp->p_refs++;
#endif
  chSysUnlock();
     9be:	78 94       	sei
  return tp;
}
     9c0:	08 95       	ret

000009c2 <chRegNextThread>:
 * @api
 */
Thread *chRegNextThread(Thread *tp) {
  Thread *ntp;

  chSysLock();
     9c2:	f8 94       	cli
  ntp = tp->p_newer;
     9c4:	fc 01       	movw	r30, r24
     9c6:	27 81       	ldd	r18, Z+7	; 0x07
     9c8:	30 85       	ldd	r19, Z+8	; 0x08
  if (ntp == (Thread *)&rlist)
     9ca:	f2 e0       	ldi	r31, 0x02	; 2
     9cc:	2f 32       	cpi	r18, 0x2F	; 47
     9ce:	3f 07       	cpc	r19, r31
     9d0:	19 f0       	breq	.+6      	; 0x9d8 <chRegNextThread+0x16>
    chDbgAssert(ntp->p_refs < 255, "chRegNextThread(), #1",
                "too many references");
    ntp->p_refs++;
  }
#endif
  chSysUnlock();
     9d2:	78 94       	sei
#if CH_USE_DYNAMIC
  chThdRelease(tp);
#endif
  return ntp;
}
     9d4:	c9 01       	movw	r24, r18
     9d6:	08 95       	ret
  Thread *ntp;

  chSysLock();
  ntp = tp->p_newer;
  if (ntp == (Thread *)&rlist)
    ntp = NULL;
     9d8:	20 e0       	ldi	r18, 0x00	; 0
     9da:	30 e0       	ldi	r19, 0x00	; 0
     9dc:	fa cf       	rjmp	.-12     	; 0x9d2 <chRegNextThread+0x10>

000009de <chSemInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemInit(Semaphore *sp, cnt_t n) {
     9de:	fc 01       	movw	r30, r24

  chDbgCheck((sp != NULL) && (n >= 0), "chSemInit");

  queue_init(&sp->s_queue);
     9e0:	82 83       	std	Z+2, r24	; 0x02
     9e2:	f3 83       	std	Z+3, r31	; 0x03
     9e4:	80 83       	st	Z, r24
     9e6:	f1 83       	std	Z+1, r31	; 0x01
  sp->s_cnt = n;
     9e8:	64 83       	std	Z+4, r22	; 0x04
     9ea:	08 95       	ret

000009ec <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(Semaphore *sp, cnt_t n) {
     9ec:	ff 92       	push	r15
     9ee:	0f 93       	push	r16
     9f0:	1f 93       	push	r17
     9f2:	cf 93       	push	r28
     9f4:	df 93       	push	r29
     9f6:	ec 01       	movw	r28, r24
  cnt_t cnt;

  chDbgCheckClassI();
  chDbgCheck((sp != NULL) && (n >= 0), "chSemResetI");
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
     9f8:	fc 80       	ldd	r15, Y+4	; 0x04
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemResetI(), #1",
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
     9fa:	6c 83       	std	Y+4, r22	; 0x04
  while (++cnt <= 0)
     9fc:	f3 94       	inc	r15
     9fe:	1f 14       	cp	r1, r15
     a00:	b4 f0       	brlt	.+44     	; 0xa2e <chSemResetI+0x42>
    chSchReadyI(lifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_RESET;
     a02:	0e ef       	ldi	r16, 0xFE	; 254
     a04:	1f ef       	ldi	r17, 0xFF	; 255
  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
  return tp;
}

static INLINE Thread *lifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_prev;
     a06:	8a 81       	ldd	r24, Y+2	; 0x02
     a08:	9b 81       	ldd	r25, Y+3	; 0x03

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
     a0a:	dc 01       	movw	r26, r24
     a0c:	12 96       	adiw	r26, 0x02	; 2
     a0e:	ed 91       	ld	r30, X+
     a10:	fc 91       	ld	r31, X
     a12:	13 97       	sbiw	r26, 0x03	; 3
     a14:	fb 83       	std	Y+3, r31	; 0x03
     a16:	ea 83       	std	Y+2, r30	; 0x02
     a18:	d1 83       	std	Z+1, r29	; 0x01
     a1a:	c0 83       	st	Z, r28
     a1c:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
     a20:	fc 01       	movw	r30, r24
     a22:	13 8b       	std	Z+19, r17	; 0x13
     a24:	02 8b       	std	Z+18, r16	; 0x12
              "chSemResetI(), #1",
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= 0)
     a26:	f3 94       	inc	r15
     a28:	f1 e0       	ldi	r31, 0x01	; 1
     a2a:	ff 12       	cpse	r15, r31
     a2c:	ec cf       	rjmp	.-40     	; 0xa06 <chSemResetI+0x1a>
    chSchReadyI(lifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_RESET;
}
     a2e:	df 91       	pop	r29
     a30:	cf 91       	pop	r28
     a32:	1f 91       	pop	r17
     a34:	0f 91       	pop	r16
     a36:	ff 90       	pop	r15
     a38:	08 95       	ret

00000a3a <chSemReset>:
 *
 * @api
 */
void chSemReset(Semaphore *sp, cnt_t n) {

  chSysLock();
     a3a:	f8 94       	cli
  chSemResetI(sp, n);
     a3c:	0e 94 f6 04 	call	0x9ec	; 0x9ec <chSemResetI>
  chSchRescheduleS();
     a40:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  chSysUnlock();
     a44:	78 94       	sei
     a46:	08 95       	ret

00000a48 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(Semaphore *sp) {
     a48:	cf 93       	push	r28
     a4a:	df 93       	push	r29
     a4c:	fc 01       	movw	r30, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
     a4e:	84 81       	ldd	r24, Z+4	; 0x04
     a50:	81 50       	subi	r24, 0x01	; 1
     a52:	84 83       	std	Z+4, r24	; 0x04
     a54:	87 fd       	sbrc	r24, 7
     a56:	06 c0       	rjmp	.+12     	; 0xa64 <chSemWaitS+0x1c>
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
    return currp->p_u.rdymsg;
  }
  return RDY_OK;
     a58:	20 e0       	ldi	r18, 0x00	; 0
     a5a:	30 e0       	ldi	r19, 0x00	; 0
}
     a5c:	c9 01       	movw	r24, r18
     a5e:	df 91       	pop	r29
     a60:	cf 91       	pop	r28
     a62:	08 95       	ret
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    currp->p_u.wtobjp = sp;
     a64:	a0 91 3a 02 	lds	r26, 0x023A
     a68:	b0 91 3b 02 	lds	r27, 0x023B
     a6c:	53 96       	adiw	r26, 0x13	; 19
     a6e:	fc 93       	st	X, r31
     a70:	ee 93       	st	-X, r30
     a72:	52 97       	sbiw	r26, 0x12	; 18
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
     a74:	11 96       	adiw	r26, 0x01	; 1
     a76:	fc 93       	st	X, r31
     a78:	ee 93       	st	-X, r30
  tp->p_prev = tqp->p_prev;
     a7a:	c2 81       	ldd	r28, Z+2	; 0x02
     a7c:	d3 81       	ldd	r29, Z+3	; 0x03
     a7e:	13 96       	adiw	r26, 0x03	; 3
     a80:	dc 93       	st	X, r29
     a82:	ce 93       	st	-X, r28
     a84:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = tqp->p_prev = tp;
     a86:	b3 83       	std	Z+3, r27	; 0x03
     a88:	a2 83       	std	Z+2, r26	; 0x02
     a8a:	b9 83       	std	Y+1, r27	; 0x01
     a8c:	a8 83       	st	Y, r26
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
     a8e:	83 e0       	ldi	r24, 0x03	; 3
     a90:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
    return currp->p_u.rdymsg;
     a94:	e0 91 3a 02 	lds	r30, 0x023A
     a98:	f0 91 3b 02 	lds	r31, 0x023B
     a9c:	22 89       	ldd	r18, Z+18	; 0x12
     a9e:	33 89       	ldd	r19, Z+19	; 0x13
  }
  return RDY_OK;
}
     aa0:	c9 01       	movw	r24, r18
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <chSemWait>:
 * @api
 */
msg_t chSemWait(Semaphore *sp) {
  msg_t msg;

  chSysLock();
     aa8:	f8 94       	cli
  msg = chSemWaitS(sp);
     aaa:	0e 94 24 05 	call	0xa48	; 0xa48 <chSemWaitS>
  chSysUnlock();
     aae:	78 94       	sei
  return msg;
}
     ab0:	08 95       	ret

00000ab2 <chSemWaitTimeoutS>:
 * @retval RDY_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(Semaphore *sp, systime_t time) {
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29
     ab6:	fc 01       	movw	r30, r24

  chDbgCheckClassS();
  chDbgCheck(sp != NULL, "chSemWaitTimeoutS");
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
     ab8:	94 81       	ldd	r25, Z+4	; 0x04
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
     aba:	89 2f       	mov	r24, r25
     abc:	81 50       	subi	r24, 0x01	; 1
     abe:	84 83       	std	Z+4, r24	; 0x04
     ac0:	87 fd       	sbrc	r24, 7
     ac2:	06 c0       	rjmp	.+12     	; 0xad0 <chSemWaitTimeoutS+0x1e>
    }
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
  }
  return RDY_OK;
     ac4:	20 e0       	ldi	r18, 0x00	; 0
     ac6:	30 e0       	ldi	r19, 0x00	; 0
}
     ac8:	c9 01       	movw	r24, r18
     aca:	df 91       	pop	r29
     acc:	cf 91       	pop	r28
     ace:	08 95       	ret
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
     ad0:	61 15       	cp	r22, r1
     ad2:	71 05       	cpc	r23, r1
     ad4:	d1 f0       	breq	.+52     	; 0xb0a <chSemWaitTimeoutS+0x58>
      sp->s_cnt++;
      return RDY_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
     ad6:	a0 91 3a 02 	lds	r26, 0x023A
     ada:	b0 91 3b 02 	lds	r27, 0x023B
     ade:	53 96       	adiw	r26, 0x13	; 19
     ae0:	fc 93       	st	X, r31
     ae2:	ee 93       	st	-X, r30
     ae4:	52 97       	sbiw	r26, 0x12	; 18
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
     ae6:	11 96       	adiw	r26, 0x01	; 1
     ae8:	fc 93       	st	X, r31
     aea:	ee 93       	st	-X, r30
  tp->p_prev = tqp->p_prev;
     aec:	c2 81       	ldd	r28, Z+2	; 0x02
     aee:	d3 81       	ldd	r29, Z+3	; 0x03
     af0:	13 96       	adiw	r26, 0x03	; 3
     af2:	dc 93       	st	X, r29
     af4:	ce 93       	st	-X, r28
     af6:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = tqp->p_prev = tp;
     af8:	b3 83       	std	Z+3, r27	; 0x03
     afa:	a2 83       	std	Z+2, r26	; 0x02
     afc:	b9 83       	std	Y+1, r27	; 0x01
     afe:	a8 83       	st	Y, r26
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
     b00:	83 e0       	ldi	r24, 0x03	; 3
  }
  return RDY_OK;
}
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
      sp->s_cnt++;
      return RDY_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
     b06:	0c 94 77 02 	jmp	0x4ee	; 0x4ee <chSchGoSleepTimeoutS>
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
     b0a:	94 83       	std	Z+4, r25	; 0x04
      return RDY_TIMEOUT;
     b0c:	2f ef       	ldi	r18, 0xFF	; 255
     b0e:	3f ef       	ldi	r19, 0xFF	; 255
     b10:	db cf       	rjmp	.-74     	; 0xac8 <chSemWaitTimeoutS+0x16>

00000b12 <chSemWaitTimeout>:
 * @api
 */
msg_t chSemWaitTimeout(Semaphore *sp, systime_t time) {
  msg_t msg;

  chSysLock();
     b12:	f8 94       	cli
  msg = chSemWaitTimeoutS(sp, time);
     b14:	0e 94 59 05 	call	0xab2	; 0xab2 <chSemWaitTimeoutS>
  chSysUnlock();
     b18:	78 94       	sei
  return msg;
}
     b1a:	08 95       	ret

00000b1c <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p Semaphore structure
 *
 * @api
 */
void chSemSignal(Semaphore *sp) {
     b1c:	cf 93       	push	r28
     b1e:	df 93       	push	r29
     b20:	fc 01       	movw	r30, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemSignal(), #1",
              "inconsistent semaphore");

  chSysLock();
     b22:	f8 94       	cli
  if (++sp->s_cnt <= 0)
     b24:	84 81       	ldd	r24, Z+4	; 0x04
     b26:	8f 5f       	subi	r24, 0xFF	; 255
     b28:	84 83       	std	Z+4, r24	; 0x04
     b2a:	18 16       	cp	r1, r24
     b2c:	24 f4       	brge	.+8      	; 0xb36 <chSemSignal+0x1a>
    chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
  chSysUnlock();
     b2e:	78 94       	sei
}
     b30:	df 91       	pop	r29
     b32:	cf 91       	pop	r28
     b34:	08 95       	ret
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     b36:	80 81       	ld	r24, Z
     b38:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     b3a:	ec 01       	movw	r28, r24
     b3c:	a8 81       	ld	r26, Y
     b3e:	b9 81       	ldd	r27, Y+1	; 0x01
     b40:	b1 83       	std	Z+1, r27	; 0x01
     b42:	a0 83       	st	Z, r26
     b44:	13 96       	adiw	r26, 0x03	; 3
     b46:	fc 93       	st	X, r31
     b48:	ee 93       	st	-X, r30
     b4a:	12 97       	sbiw	r26, 0x02	; 2
              "chSemSignal(), #1",
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= 0)
    chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
     b4c:	60 e0       	ldi	r22, 0x00	; 0
     b4e:	70 e0       	ldi	r23, 0x00	; 0
     b50:	0e 94 b0 02 	call	0x560	; 0x560 <chSchWakeupS>
  chSysUnlock();
     b54:	78 94       	sei
}
     b56:	df 91       	pop	r29
     b58:	cf 91       	pop	r28
     b5a:	08 95       	ret

00000b5c <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p Semaphore structure
 *
 * @iclass
 */
void chSemSignalI(Semaphore *sp) {
     b5c:	cf 93       	push	r28
     b5e:	df 93       	push	r29
     b60:	fc 01       	movw	r30, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemSignalI(), #1",
              "inconsistent semaphore");

  if (++sp->s_cnt <= 0) {
     b62:	84 81       	ldd	r24, Z+4	; 0x04
     b64:	8f 5f       	subi	r24, 0xFF	; 255
     b66:	84 83       	std	Z+4, r24	; 0x04
     b68:	18 16       	cp	r1, r24
     b6a:	1c f4       	brge	.+6      	; 0xb72 <chSemSignalI+0x16>
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
    chSchReadyI(tp);
  }
}
     b6c:	df 91       	pop	r29
     b6e:	cf 91       	pop	r28
     b70:	08 95       	ret
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     b72:	80 81       	ld	r24, Z
     b74:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     b76:	ec 01       	movw	r28, r24
     b78:	a8 81       	ld	r26, Y
     b7a:	b9 81       	ldd	r27, Y+1	; 0x01
     b7c:	b1 83       	std	Z+1, r27	; 0x01
     b7e:	a0 83       	st	Z, r26
     b80:	13 96       	adiw	r26, 0x03	; 3
     b82:	fc 93       	st	X, r31
     b84:	ee 93       	st	-X, r30
     b86:	12 97       	sbiw	r26, 0x02	; 2

  if (++sp->s_cnt <= 0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
     b88:	1b 8a       	std	Y+19, r1	; 0x13
     b8a:	1a 8a       	std	Y+18, r1	; 0x12
    chSchReadyI(tp);
  }
}
     b8c:	df 91       	pop	r29
     b8e:	cf 91       	pop	r28
  if (++sp->s_cnt <= 0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
    chSchReadyI(tp);
     b90:	0c 94 34 02 	jmp	0x468	; 0x468 <chSchReadyI>

00000b94 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(Semaphore *sp, cnt_t n) {
     b94:	1f 93       	push	r17
     b96:	cf 93       	push	r28
     b98:	df 93       	push	r29
     b9a:	ec 01       	movw	r28, r24
     b9c:	16 2f       	mov	r17, r22
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     b9e:	16 16       	cp	r1, r22
     ba0:	1c f0       	brlt	.+6      	; 0xba8 <chSemAddCounterI+0x14>
     ba2:	17 c0       	rjmp	.+46     	; 0xbd2 <chSemAddCounterI+0x3e>
    if (++sp->s_cnt <= 0)
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
    n--;
     ba4:	11 50       	subi	r17, 0x01	; 1
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     ba6:	a9 f0       	breq	.+42     	; 0xbd2 <chSemAddCounterI+0x3e>
    if (++sp->s_cnt <= 0)
     ba8:	8c 81       	ldd	r24, Y+4	; 0x04
     baa:	8f 5f       	subi	r24, 0xFF	; 255
     bac:	8c 83       	std	Y+4, r24	; 0x04
     bae:	18 16       	cp	r1, r24
     bb0:	cc f3       	brlt	.-14     	; 0xba4 <chSemAddCounterI+0x10>
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     bb2:	88 81       	ld	r24, Y
     bb4:	99 81       	ldd	r25, Y+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     bb6:	dc 01       	movw	r26, r24
     bb8:	ed 91       	ld	r30, X+
     bba:	fc 91       	ld	r31, X
     bbc:	f9 83       	std	Y+1, r31	; 0x01
     bbe:	e8 83       	st	Y, r30
     bc0:	d3 83       	std	Z+3, r29	; 0x03
     bc2:	c2 83       	std	Z+2, r28	; 0x02
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
     bc4:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
     bc8:	fc 01       	movw	r30, r24
     bca:	13 8a       	std	Z+19, r1	; 0x13
     bcc:	12 8a       	std	Z+18, r1	; 0x12
    n--;
     bce:	11 50       	subi	r17, 0x01	; 1
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     bd0:	59 f7       	brne	.-42     	; 0xba8 <chSemAddCounterI+0x14>
    if (++sp->s_cnt <= 0)
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
    n--;
  }
}
     bd2:	df 91       	pop	r29
     bd4:	cf 91       	pop	r28
     bd6:	1f 91       	pop	r17
     bd8:	08 95       	ret

00000bda <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(Semaphore *sps, Semaphore *spw) {
     bda:	0f 93       	push	r16
     bdc:	1f 93       	push	r17
     bde:	cf 93       	push	r28
     be0:	df 93       	push	r29
     be2:	fc 01       	movw	r30, r24
     be4:	eb 01       	movw	r28, r22
  chDbgAssert(((spw->s_cnt >= 0) && isempty(&spw->s_queue)) ||
              ((spw->s_cnt < 0) && notempty(&spw->s_queue)),
              "chSemSignalWait(), #2",
              "inconsistent semaphore");

  chSysLock();
     be6:	f8 94       	cli
  if (++sps->s_cnt <= 0)
     be8:	84 81       	ldd	r24, Z+4	; 0x04
     bea:	8f 5f       	subi	r24, 0xFF	; 255
     bec:	84 83       	std	Z+4, r24	; 0x04
     bee:	18 16       	cp	r1, r24
     bf0:	9c f5       	brge	.+102    	; 0xc58 <chSemSignalWait+0x7e>
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
  if (--spw->s_cnt < 0) {
     bf2:	8c 81       	ldd	r24, Y+4	; 0x04
     bf4:	81 50       	subi	r24, 0x01	; 1
     bf6:	8c 83       	std	Y+4, r24	; 0x04
     bf8:	87 fd       	sbrc	r24, 7
     bfa:	0b c0       	rjmp	.+22     	; 0xc12 <chSemSignalWait+0x38>
    ctp->p_u.wtobjp = spw;
    chSchGoSleepS(THD_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
     bfc:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
    msg = RDY_OK;
     c00:	20 e0       	ldi	r18, 0x00	; 0
     c02:	30 e0       	ldi	r19, 0x00	; 0
  }
  chSysUnlock();
     c04:	78 94       	sei
  return msg;
}
     c06:	c9 01       	movw	r24, r18
     c08:	df 91       	pop	r29
     c0a:	cf 91       	pop	r28
     c0c:	1f 91       	pop	r17
     c0e:	0f 91       	pop	r16
     c10:	08 95       	ret

  chSysLock();
  if (++sps->s_cnt <= 0)
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
  if (--spw->s_cnt < 0) {
    Thread *ctp = currp;
     c12:	00 91 3a 02 	lds	r16, 0x023A
     c16:	10 91 3b 02 	lds	r17, 0x023B
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
     c1a:	d8 01       	movw	r26, r16
     c1c:	11 96       	adiw	r26, 0x01	; 1
     c1e:	dc 93       	st	X, r29
     c20:	ce 93       	st	-X, r28
  tp->p_prev = tqp->p_prev;
     c22:	ea 81       	ldd	r30, Y+2	; 0x02
     c24:	fb 81       	ldd	r31, Y+3	; 0x03
     c26:	13 96       	adiw	r26, 0x03	; 3
     c28:	fc 93       	st	X, r31
     c2a:	ee 93       	st	-X, r30
     c2c:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = tqp->p_prev = tp;
     c2e:	1b 83       	std	Y+3, r17	; 0x03
     c30:	0a 83       	std	Y+2, r16	; 0x02
     c32:	11 83       	std	Z+1, r17	; 0x01
     c34:	00 83       	st	Z, r16
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtobjp = spw;
     c36:	53 96       	adiw	r26, 0x13	; 19
     c38:	dc 93       	st	X, r29
     c3a:	ce 93       	st	-X, r28
     c3c:	52 97       	sbiw	r26, 0x12	; 18
    chSchGoSleepS(THD_STATE_WTSEM);
     c3e:	83 e0       	ldi	r24, 0x03	; 3
     c40:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
     c44:	f8 01       	movw	r30, r16
     c46:	22 89       	ldd	r18, Z+18	; 0x12
     c48:	33 89       	ldd	r19, Z+19	; 0x13
  }
  else {
    chSchRescheduleS();
    msg = RDY_OK;
  }
  chSysUnlock();
     c4a:	78 94       	sei
  return msg;
}
     c4c:	c9 01       	movw	r24, r18
     c4e:	df 91       	pop	r29
     c50:	cf 91       	pop	r28
     c52:	1f 91       	pop	r17
     c54:	0f 91       	pop	r16
     c56:	08 95       	ret
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     c58:	80 81       	ld	r24, Z
     c5a:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     c5c:	dc 01       	movw	r26, r24
     c5e:	2d 91       	ld	r18, X+
     c60:	3c 91       	ld	r19, X
     c62:	31 83       	std	Z+1, r19	; 0x01
     c64:	20 83       	st	Z, r18
     c66:	d9 01       	movw	r26, r18
     c68:	13 96       	adiw	r26, 0x03	; 3
     c6a:	fc 93       	st	X, r31
     c6c:	ee 93       	st	-X, r30
     c6e:	12 97       	sbiw	r26, 0x02	; 2
              "chSemSignalWait(), #2",
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= 0)
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
     c70:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
     c74:	fc 01       	movw	r30, r24
     c76:	13 8a       	std	Z+19, r1	; 0x13
     c78:	12 8a       	std	Z+18, r1	; 0x12
     c7a:	bb cf       	rjmp	.-138    	; 0xbf2 <chSemSignalWait+0x18>

00000c7c <chMtxInit>:
 *
 * @param[out] mp       pointer to a @p Mutex structure
 *
 * @init
 */
void chMtxInit(Mutex *mp) {
     c7c:	fc 01       	movw	r30, r24

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
     c7e:	82 83       	std	Z+2, r24	; 0x02
     c80:	f3 83       	std	Z+3, r31	; 0x03
     c82:	80 83       	st	Z, r24
     c84:	f1 83       	std	Z+1, r31	; 0x01
  mp->m_owner = NULL;
     c86:	15 82       	std	Z+5, r1	; 0x05
     c88:	14 82       	std	Z+4, r1	; 0x04
     c8a:	08 95       	ret

00000c8c <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @sclass
 */
void chMtxLockS(Mutex *mp) {
     c8c:	0f 93       	push	r16
     c8e:	1f 93       	push	r17
     c90:	cf 93       	push	r28
     c92:	df 93       	push	r29
     c94:	8c 01       	movw	r16, r24
  Thread *ctp = currp;
     c96:	c0 91 3a 02 	lds	r28, 0x023A
     c9a:	d0 91 3b 02 	lds	r29, 0x023B

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxLockS");

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
     c9e:	dc 01       	movw	r26, r24
     ca0:	14 96       	adiw	r26, 0x04	; 4
     ca2:	ed 91       	ld	r30, X+
     ca4:	fc 91       	ld	r31, X
     ca6:	15 97       	sbiw	r26, 0x05	; 5
     ca8:	30 97       	sbiw	r30, 0x00	; 0
     caa:	09 f4       	brne	.+2      	; 0xcae <chMtxLockS+0x22>
     cac:	9f c0       	rjmp	.+318    	; 0xdec <chMtxLockS+0x160>
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
     cae:	4c 81       	ldd	r20, Y+4	; 0x04
     cb0:	84 81       	ldd	r24, Z+4	; 0x04
     cb2:	84 17       	cp	r24, r20
     cb4:	48 f4       	brcc	.+18     	; 0xcc8 <chMtxLockS+0x3c>
      /* Make priority of thread tp match the running thread's priority.*/
      tp->p_prio = ctp->p_prio;
     cb6:	44 83       	std	Z+4, r20	; 0x04
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
     cb8:	85 85       	ldd	r24, Z+13	; 0x0d
     cba:	84 30       	cpi	r24, 0x04	; 4
     cbc:	09 f4       	brne	.+2      	; 0xcc0 <chMtxLockS+0x34>
     cbe:	60 c0       	rjmp	.+192    	; 0xd80 <chMtxLockS+0xf4>
     cc0:	85 30       	cpi	r24, 0x05	; 5
     cc2:	91 f1       	breq	.+100    	; 0xd28 <chMtxLockS+0x9c>
     cc4:	88 23       	and	r24, r24
     cc6:	f1 f0       	breq	.+60     	; 0xd04 <chMtxLockS+0x78>
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
     cc8:	f8 01       	movw	r30, r16
  do {
    cp = cp->p_next;
     cca:	01 90       	ld	r0, Z+
     ccc:	f0 81       	ld	r31, Z
     cce:	e0 2d       	mov	r30, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     cd0:	0e 17       	cp	r16, r30
     cd2:	1f 07       	cpc	r17, r31
     cd4:	21 f0       	breq	.+8      	; 0xcde <chMtxLockS+0x52>
     cd6:	94 81       	ldd	r25, Z+4	; 0x04
     cd8:	8c 81       	ldd	r24, Y+4	; 0x04
     cda:	98 17       	cp	r25, r24
     cdc:	b0 f7       	brcc	.-20     	; 0xcca <chMtxLockS+0x3e>
  tp->p_next = cp;
     cde:	f9 83       	std	Y+1, r31	; 0x01
     ce0:	e8 83       	st	Y, r30
  tp->p_prev = cp->p_prev;
     ce2:	a2 81       	ldd	r26, Z+2	; 0x02
     ce4:	b3 81       	ldd	r27, Z+3	; 0x03
     ce6:	bb 83       	std	Y+3, r27	; 0x03
     ce8:	aa 83       	std	Y+2, r26	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     cea:	d3 83       	std	Z+3, r29	; 0x03
     cec:	c2 83       	std	Z+2, r28	; 0x02
     cee:	cd 93       	st	X+, r28
     cf0:	dc 93       	st	X, r29
      }
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
    ctp->p_u.wtobjp = mp;
     cf2:	1b 8b       	std	Y+19, r17	; 0x13
     cf4:	0a 8b       	std	Y+18, r16	; 0x12
    chSchGoSleepS(THD_STATE_WTMTX);
     cf6:	84 e0       	ldi	r24, 0x04	; 4
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
     cf8:	df 91       	pop	r29
     cfa:	cf 91       	pop	r28
     cfc:	1f 91       	pop	r17
     cfe:	0f 91       	pop	r16
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
    ctp->p_u.wtobjp = mp;
    chSchGoSleepS(THD_STATE_WTMTX);
     d00:	0c 94 56 02 	jmp	0x4ac	; 0x4ac <chSchGoSleepS>
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     d04:	22 81       	ldd	r18, Z+2	; 0x02
     d06:	33 81       	ldd	r19, Z+3	; 0x03
     d08:	80 81       	ld	r24, Z
     d0a:	91 81       	ldd	r25, Z+1	; 0x01
     d0c:	d9 01       	movw	r26, r18
     d0e:	8d 93       	st	X+, r24
     d10:	9c 93       	st	X, r25
  tp->p_next->p_prev = tp->p_prev;
     d12:	80 81       	ld	r24, Z
     d14:	91 81       	ldd	r25, Z+1	; 0x01
     d16:	dc 01       	movw	r26, r24
     d18:	13 96       	adiw	r26, 0x03	; 3
     d1a:	3c 93       	st	X, r19
     d1c:	2e 93       	st	-X, r18
     d1e:	12 97       	sbiw	r26, 0x02	; 2
#if CH_DBG_ENABLE_ASSERTS
        /* Prevents an assertion in chSchReadyI().*/
        tp->p_state = THD_STATE_CURRENT;
#endif
        /* Re-enqueues tp with its new priority on the ready list.*/
        chSchReadyI(dequeue(tp));
     d20:	cf 01       	movw	r24, r30
     d22:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
        break;
     d26:	d0 cf       	rjmp	.-96     	; 0xcc8 <chMtxLockS+0x3c>
#endif
#if CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY
      case THD_STATE_SNDMSGQ:
#endif
        /* Re-enqueues tp with its new priority on the queue.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
     d28:	82 89       	ldd	r24, Z+18	; 0x12
     d2a:	93 89       	ldd	r25, Z+19	; 0x13
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     d2c:	62 81       	ldd	r22, Z+2	; 0x02
     d2e:	73 81       	ldd	r23, Z+3	; 0x03
     d30:	20 81       	ld	r18, Z
     d32:	31 81       	ldd	r19, Z+1	; 0x01
     d34:	db 01       	movw	r26, r22
     d36:	2d 93       	st	X+, r18
     d38:	3c 93       	st	X, r19
  tp->p_next->p_prev = tp->p_prev;
     d3a:	20 81       	ld	r18, Z
     d3c:	31 81       	ldd	r19, Z+1	; 0x01
     d3e:	d9 01       	movw	r26, r18
     d40:	13 96       	adiw	r26, 0x03	; 3
     d42:	7c 93       	st	X, r23
     d44:	6e 93       	st	-X, r22
     d46:	12 97       	sbiw	r26, 0x02	; 2
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
     d48:	dc 01       	movw	r26, r24
  do {
    cp = cp->p_next;
     d4a:	0d 90       	ld	r0, X+
     d4c:	bc 91       	ld	r27, X
     d4e:	a0 2d       	mov	r26, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     d50:	8a 17       	cp	r24, r26
     d52:	9b 07       	cpc	r25, r27
     d54:	29 f0       	breq	.+10     	; 0xd60 <chMtxLockS+0xd4>
     d56:	14 96       	adiw	r26, 0x04	; 4
     d58:	2c 91       	ld	r18, X
     d5a:	14 97       	sbiw	r26, 0x04	; 4
     d5c:	24 17       	cp	r18, r20
     d5e:	a8 f7       	brcc	.-22     	; 0xd4a <chMtxLockS+0xbe>
  tp->p_next = cp;
     d60:	b1 83       	std	Z+1, r27	; 0x01
     d62:	a0 83       	st	Z, r26
  tp->p_prev = cp->p_prev;
     d64:	12 96       	adiw	r26, 0x02	; 2
     d66:	8d 91       	ld	r24, X+
     d68:	9c 91       	ld	r25, X
     d6a:	13 97       	sbiw	r26, 0x03	; 3
     d6c:	93 83       	std	Z+3, r25	; 0x03
     d6e:	82 83       	std	Z+2, r24	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     d70:	13 96       	adiw	r26, 0x03	; 3
     d72:	fc 93       	st	X, r31
     d74:	ee 93       	st	-X, r30
     d76:	12 97       	sbiw	r26, 0x02	; 2
     d78:	dc 01       	movw	r26, r24
     d7a:	ed 93       	st	X+, r30
     d7c:	fc 93       	st	X, r31
     d7e:	a4 cf       	rjmp	.-184    	; 0xcc8 <chMtxLockS+0x3c>
      tp->p_prio = ctp->p_prio;
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
      case THD_STATE_WTMTX:
        /* Re-enqueues the mutex owner with its new priority.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
     d80:	82 89       	ldd	r24, Z+18	; 0x12
     d82:	93 89       	ldd	r25, Z+19	; 0x13
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     d84:	62 81       	ldd	r22, Z+2	; 0x02
     d86:	73 81       	ldd	r23, Z+3	; 0x03
     d88:	20 81       	ld	r18, Z
     d8a:	31 81       	ldd	r19, Z+1	; 0x01
     d8c:	db 01       	movw	r26, r22
     d8e:	2d 93       	st	X+, r18
     d90:	3c 93       	st	X, r19
  tp->p_next->p_prev = tp->p_prev;
     d92:	20 81       	ld	r18, Z
     d94:	31 81       	ldd	r19, Z+1	; 0x01
     d96:	d9 01       	movw	r26, r18
     d98:	13 96       	adiw	r26, 0x03	; 3
     d9a:	7c 93       	st	X, r23
     d9c:	6e 93       	st	-X, r22
     d9e:	12 97       	sbiw	r26, 0x02	; 2
     da0:	dc 01       	movw	r26, r24
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
     da2:	0d 90       	ld	r0, X+
     da4:	bc 91       	ld	r27, X
     da6:	a0 2d       	mov	r26, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     da8:	8a 17       	cp	r24, r26
     daa:	9b 07       	cpc	r25, r27
     dac:	69 f1       	breq	.+90     	; 0xe08 <chMtxLockS+0x17c>
     dae:	14 96       	adiw	r26, 0x04	; 4
     db0:	2c 91       	ld	r18, X
     db2:	14 97       	sbiw	r26, 0x04	; 4
     db4:	24 17       	cp	r18, r20
     db6:	a8 f7       	brcc	.-22     	; 0xda2 <chMtxLockS+0x116>
  tp->p_next = cp;
     db8:	b1 83       	std	Z+1, r27	; 0x01
     dba:	a0 83       	st	Z, r26
  tp->p_prev = cp->p_prev;
     dbc:	12 96       	adiw	r26, 0x02	; 2
     dbe:	2d 91       	ld	r18, X+
     dc0:	3c 91       	ld	r19, X
     dc2:	13 97       	sbiw	r26, 0x03	; 3
     dc4:	33 83       	std	Z+3, r19	; 0x03
     dc6:	22 83       	std	Z+2, r18	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     dc8:	13 96       	adiw	r26, 0x03	; 3
     dca:	fc 93       	st	X, r31
     dcc:	ee 93       	st	-X, r30
     dce:	12 97       	sbiw	r26, 0x02	; 2
     dd0:	d9 01       	movw	r26, r18
     dd2:	ed 93       	st	X+, r30
     dd4:	fc 93       	st	X, r31
        tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
     dd6:	dc 01       	movw	r26, r24
     dd8:	14 96       	adiw	r26, 0x04	; 4
     dda:	ed 91       	ld	r30, X+
     ddc:	fc 91       	ld	r31, X
     dde:	15 97       	sbiw	r26, 0x05	; 5
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
     de0:	4c 81       	ldd	r20, Y+4	; 0x04
     de2:	84 81       	ldd	r24, Z+4	; 0x04
     de4:	84 17       	cp	r24, r20
     de6:	08 f4       	brcc	.+2      	; 0xdea <chMtxLockS+0x15e>
     de8:	66 cf       	rjmp	.-308    	; 0xcb6 <chMtxLockS+0x2a>
     dea:	6e cf       	rjmp	.-292    	; 0xcc8 <chMtxLockS+0x3c>
    chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
    chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
  }
  else {
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
     dec:	fc 01       	movw	r30, r24
     dee:	d5 83       	std	Z+5, r29	; 0x05
     df0:	c4 83       	std	Z+4, r28	; 0x04
    mp->m_next = ctp->p_mtxlist;
     df2:	8d 8d       	ldd	r24, Y+29	; 0x1d
     df4:	9e 8d       	ldd	r25, Y+30	; 0x1e
     df6:	97 83       	std	Z+7, r25	; 0x07
     df8:	86 83       	std	Z+6, r24	; 0x06
    ctp->p_mtxlist = mp;
     dfa:	1e 8f       	std	Y+30, r17	; 0x1e
     dfc:	0d 8f       	std	Y+29, r16	; 0x1d
  }
}
     dfe:	df 91       	pop	r29
     e00:	cf 91       	pop	r28
     e02:	1f 91       	pop	r17
     e04:	0f 91       	pop	r16
     e06:	08 95       	ret
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     e08:	dc 01       	movw	r26, r24
     e0a:	d6 cf       	rjmp	.-84     	; 0xdb8 <chMtxLockS+0x12c>

00000e0c <chMtxLock>:
 *
 * @api
 */
void chMtxLock(Mutex *mp) {

  chSysLock();
     e0c:	f8 94       	cli

  chMtxLockS(mp);
     e0e:	0e 94 46 06 	call	0xc8c	; 0xc8c <chMtxLockS>

  chSysUnlock();
     e12:	78 94       	sei
     e14:	08 95       	ret

00000e16 <chMtxTryLock>:
 * @api
 */
bool_t chMtxTryLock(Mutex *mp) {
  bool_t b;

  chSysLock();
     e16:	f8 94       	cli
bool_t chMtxTryLockS(Mutex *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
     e18:	dc 01       	movw	r26, r24
     e1a:	14 96       	adiw	r26, 0x04	; 4
     e1c:	2d 91       	ld	r18, X+
     e1e:	3c 91       	ld	r19, X
     e20:	15 97       	sbiw	r26, 0x05	; 5
     e22:	23 2b       	or	r18, r19
     e24:	19 f0       	breq	.+6      	; 0xe2c <chMtxTryLock+0x16>
    return FALSE;
     e26:	80 e0       	ldi	r24, 0x00	; 0

  chSysLock();

  b = chMtxTryLockS(mp);

  chSysUnlock();
     e28:	78 94       	sei
  return b;
}
     e2a:	08 95       	ret
  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
    return FALSE;
  mp->m_owner = currp;
     e2c:	e0 91 3a 02 	lds	r30, 0x023A
     e30:	f0 91 3b 02 	lds	r31, 0x023B
     e34:	15 96       	adiw	r26, 0x05	; 5
     e36:	fc 93       	st	X, r31
     e38:	ee 93       	st	-X, r30
     e3a:	14 97       	sbiw	r26, 0x04	; 4
  mp->m_next = currp->p_mtxlist;
     e3c:	25 8d       	ldd	r18, Z+29	; 0x1d
     e3e:	36 8d       	ldd	r19, Z+30	; 0x1e
     e40:	17 96       	adiw	r26, 0x07	; 7
     e42:	3c 93       	st	X, r19
     e44:	2e 93       	st	-X, r18
     e46:	16 97       	sbiw	r26, 0x06	; 6
  currp->p_mtxlist = mp;
     e48:	96 8f       	std	Z+30, r25	; 0x1e
     e4a:	85 8f       	std	Z+29, r24	; 0x1d
  return TRUE;
     e4c:	81 e0       	ldi	r24, 0x01	; 1

  chSysLock();

  b = chMtxTryLockS(mp);

  chSysUnlock();
     e4e:	78 94       	sei
  return b;
}
     e50:	08 95       	ret

00000e52 <chMtxTryLockS>:
bool_t chMtxTryLockS(Mutex *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
     e52:	dc 01       	movw	r26, r24
     e54:	14 96       	adiw	r26, 0x04	; 4
     e56:	2d 91       	ld	r18, X+
     e58:	3c 91       	ld	r19, X
     e5a:	15 97       	sbiw	r26, 0x05	; 5
     e5c:	23 2b       	or	r18, r19
     e5e:	11 f0       	breq	.+4      	; 0xe64 <chMtxTryLockS+0x12>
    return FALSE;
     e60:	80 e0       	ldi	r24, 0x00	; 0
  mp->m_owner = currp;
  mp->m_next = currp->p_mtxlist;
  currp->p_mtxlist = mp;
  return TRUE;
}
     e62:	08 95       	ret
  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
    return FALSE;
  mp->m_owner = currp;
     e64:	e0 91 3a 02 	lds	r30, 0x023A
     e68:	f0 91 3b 02 	lds	r31, 0x023B
     e6c:	15 96       	adiw	r26, 0x05	; 5
     e6e:	fc 93       	st	X, r31
     e70:	ee 93       	st	-X, r30
     e72:	14 97       	sbiw	r26, 0x04	; 4
  mp->m_next = currp->p_mtxlist;
     e74:	25 8d       	ldd	r18, Z+29	; 0x1d
     e76:	36 8d       	ldd	r19, Z+30	; 0x1e
     e78:	17 96       	adiw	r26, 0x07	; 7
     e7a:	3c 93       	st	X, r19
     e7c:	2e 93       	st	-X, r18
     e7e:	16 97       	sbiw	r26, 0x06	; 6
  currp->p_mtxlist = mp;
     e80:	96 8f       	std	Z+30, r25	; 0x1e
     e82:	85 8f       	std	Z+29, r24	; 0x1d
  return TRUE;
     e84:	81 e0       	ldi	r24, 0x01	; 1
     e86:	08 95       	ret

00000e88 <chMtxUnlock>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @api
 */
Mutex *chMtxUnlock(void) {
     e88:	cf 93       	push	r28
     e8a:	df 93       	push	r29
  Thread *ctp = currp;
     e8c:	80 91 3a 02 	lds	r24, 0x023A
     e90:	90 91 3b 02 	lds	r25, 0x023B
  Mutex *ump, *mp;

  chSysLock();
     e94:	f8 94       	cli
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
              "chMtxUnlock(), #2",
              "ownership failure");
  /* Removes the top Mutex from the Thread's owned mutexes list and marks it
     as not owned.*/
  ump = ctp->p_mtxlist;
     e96:	dc 01       	movw	r26, r24
     e98:	5d 96       	adiw	r26, 0x1d	; 29
     e9a:	cd 91       	ld	r28, X+
     e9c:	dc 91       	ld	r29, X
     e9e:	5e 97       	sbiw	r26, 0x1e	; 30
  ctp->p_mtxlist = ump->m_next;
     ea0:	ee 81       	ldd	r30, Y+6	; 0x06
     ea2:	ff 81       	ldd	r31, Y+7	; 0x07
     ea4:	5e 96       	adiw	r26, 0x1e	; 30
     ea6:	fc 93       	st	X, r31
     ea8:	ee 93       	st	-X, r30
     eaa:	5d 97       	sbiw	r26, 0x1d	; 29
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
     eac:	28 81       	ld	r18, Y
     eae:	39 81       	ldd	r19, Y+1	; 0x01
     eb0:	2c 17       	cp	r18, r28
     eb2:	3d 07       	cpc	r19, r29
     eb4:	89 f1       	breq	.+98     	; 0xf18 <chMtxUnlock+0x90>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
     eb6:	5f 96       	adiw	r26, 0x1f	; 31
     eb8:	3c 91       	ld	r19, X
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     eba:	30 97       	sbiw	r30, 0x00	; 0
     ebc:	79 f0       	breq	.+30     	; 0xedc <chMtxUnlock+0x54>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
     ebe:	a0 81       	ld	r26, Z
     ec0:	b1 81       	ldd	r27, Z+1	; 0x01
     ec2:	ae 17       	cp	r26, r30
     ec4:	bf 07       	cpc	r27, r31
     ec6:	29 f0       	breq	.+10     	; 0xed2 <chMtxUnlock+0x4a>
     ec8:	14 96       	adiw	r26, 0x04	; 4
     eca:	2c 91       	ld	r18, X
     ecc:	32 17       	cp	r19, r18
     ece:	08 f4       	brcc	.+2      	; 0xed2 <chMtxUnlock+0x4a>
     ed0:	32 2f       	mov	r19, r18
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
     ed2:	06 80       	ldd	r0, Z+6	; 0x06
     ed4:	f7 81       	ldd	r31, Z+7	; 0x07
     ed6:	e0 2d       	mov	r30, r0

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     ed8:	30 97       	sbiw	r30, 0x00	; 0
     eda:	89 f7       	brne	.-30     	; 0xebe <chMtxUnlock+0x36>
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    /* Assigns to the current thread the highest priority among all the
       waiting threads.*/
    ctp->p_prio = newprio;
     edc:	fc 01       	movw	r30, r24
     ede:	34 83       	std	Z+4, r19	; 0x04
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     ee0:	e8 81       	ld	r30, Y
     ee2:	f9 81       	ldd	r31, Y+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     ee4:	a0 81       	ld	r26, Z
     ee6:	b1 81       	ldd	r27, Z+1	; 0x01
     ee8:	b9 83       	std	Y+1, r27	; 0x01
     eea:	a8 83       	st	Y, r26
     eec:	13 96       	adiw	r26, 0x03	; 3
     eee:	dc 93       	st	X, r29
     ef0:	ce 93       	st	-X, r28
     ef2:	12 97       	sbiw	r26, 0x02	; 2
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    ump->m_owner = tp;
     ef4:	fd 83       	std	Y+5, r31	; 0x05
     ef6:	ec 83       	std	Y+4, r30	; 0x04
    ump->m_next = tp->p_mtxlist;
     ef8:	85 8d       	ldd	r24, Z+29	; 0x1d
     efa:	96 8d       	ldd	r25, Z+30	; 0x1e
     efc:	9f 83       	std	Y+7, r25	; 0x07
     efe:	8e 83       	std	Y+6, r24	; 0x06
    tp->p_mtxlist = ump;
     f00:	d6 8f       	std	Z+30, r29	; 0x1e
     f02:	c5 8f       	std	Z+29, r28	; 0x1d
    chSchWakeupS(tp, RDY_OK);
     f04:	60 e0       	ldi	r22, 0x00	; 0
     f06:	70 e0       	ldi	r23, 0x00	; 0
     f08:	cf 01       	movw	r24, r30
     f0a:	0e 94 b0 02 	call	0x560	; 0x560 <chSchWakeupS>
  }
  else
    ump->m_owner = NULL;
  chSysUnlock();
     f0e:	78 94       	sei
  return ump;
}
     f10:	ce 01       	movw	r24, r28
     f12:	df 91       	pop	r29
     f14:	cf 91       	pop	r28
     f16:	08 95       	ret
    ump->m_next = tp->p_mtxlist;
    tp->p_mtxlist = ump;
    chSchWakeupS(tp, RDY_OK);
  }
  else
    ump->m_owner = NULL;
     f18:	1d 82       	std	Y+5, r1	; 0x05
     f1a:	1c 82       	std	Y+4, r1	; 0x04
  chSysUnlock();
     f1c:	78 94       	sei
  return ump;
}
     f1e:	ce 01       	movw	r24, r28
     f20:	df 91       	pop	r29
     f22:	cf 91       	pop	r28
     f24:	08 95       	ret

00000f26 <chMtxUnlockS>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @sclass
 */
Mutex *chMtxUnlockS(void) {
     f26:	cf 93       	push	r28
     f28:	df 93       	push	r29
  Thread *ctp = currp;
     f2a:	80 91 3a 02 	lds	r24, 0x023A
     f2e:	90 91 3b 02 	lds	r25, 0x023B
              "chMtxUnlockS(), #2",
              "ownership failure");

  /* Removes the top Mutex from the owned mutexes list and marks it as not
     owned.*/
  ump = ctp->p_mtxlist;
     f32:	dc 01       	movw	r26, r24
     f34:	5d 96       	adiw	r26, 0x1d	; 29
     f36:	cd 91       	ld	r28, X+
     f38:	dc 91       	ld	r29, X
     f3a:	5e 97       	sbiw	r26, 0x1e	; 30
  ctp->p_mtxlist = ump->m_next;
     f3c:	ee 81       	ldd	r30, Y+6	; 0x06
     f3e:	ff 81       	ldd	r31, Y+7	; 0x07
     f40:	5e 96       	adiw	r26, 0x1e	; 30
     f42:	fc 93       	st	X, r31
     f44:	ee 93       	st	-X, r30
     f46:	5d 97       	sbiw	r26, 0x1d	; 29
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
     f48:	28 81       	ld	r18, Y
     f4a:	39 81       	ldd	r19, Y+1	; 0x01
     f4c:	2c 17       	cp	r18, r28
     f4e:	3d 07       	cpc	r19, r29
     f50:	71 f1       	breq	.+92     	; 0xfae <chMtxUnlockS+0x88>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
     f52:	5f 96       	adiw	r26, 0x1f	; 31
     f54:	3c 91       	ld	r19, X
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     f56:	30 97       	sbiw	r30, 0x00	; 0
     f58:	79 f0       	breq	.+30     	; 0xf78 <chMtxUnlockS+0x52>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
     f5a:	a0 81       	ld	r26, Z
     f5c:	b1 81       	ldd	r27, Z+1	; 0x01
     f5e:	ae 17       	cp	r26, r30
     f60:	bf 07       	cpc	r27, r31
     f62:	29 f0       	breq	.+10     	; 0xf6e <chMtxUnlockS+0x48>
     f64:	14 96       	adiw	r26, 0x04	; 4
     f66:	2c 91       	ld	r18, X
     f68:	32 17       	cp	r19, r18
     f6a:	08 f4       	brcc	.+2      	; 0xf6e <chMtxUnlockS+0x48>
     f6c:	32 2f       	mov	r19, r18
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
     f6e:	06 80       	ldd	r0, Z+6	; 0x06
     f70:	f7 81       	ldd	r31, Z+7	; 0x07
     f72:	e0 2d       	mov	r30, r0

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     f74:	30 97       	sbiw	r30, 0x00	; 0
     f76:	89 f7       	brne	.-30     	; 0xf5a <chMtxUnlockS+0x34>
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    ctp->p_prio = newprio;
     f78:	fc 01       	movw	r30, r24
     f7a:	34 83       	std	Z+4, r19	; 0x04
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     f7c:	e8 81       	ld	r30, Y
     f7e:	f9 81       	ldd	r31, Y+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     f80:	a0 81       	ld	r26, Z
     f82:	b1 81       	ldd	r27, Z+1	; 0x01
     f84:	b9 83       	std	Y+1, r27	; 0x01
     f86:	a8 83       	st	Y, r26
     f88:	13 96       	adiw	r26, 0x03	; 3
     f8a:	dc 93       	st	X, r29
     f8c:	ce 93       	st	-X, r28
     f8e:	12 97       	sbiw	r26, 0x02	; 2
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    ump->m_owner = tp;
     f90:	fd 83       	std	Y+5, r31	; 0x05
     f92:	ec 83       	std	Y+4, r30	; 0x04
    ump->m_next = tp->p_mtxlist;
     f94:	85 8d       	ldd	r24, Z+29	; 0x1d
     f96:	96 8d       	ldd	r25, Z+30	; 0x1e
     f98:	9f 83       	std	Y+7, r25	; 0x07
     f9a:	8e 83       	std	Y+6, r24	; 0x06
    tp->p_mtxlist = ump;
     f9c:	d6 8f       	std	Z+30, r29	; 0x1e
     f9e:	c5 8f       	std	Z+29, r28	; 0x1d
    chSchReadyI(tp);
     fa0:	cf 01       	movw	r24, r30
     fa2:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
  }
  else
    ump->m_owner = NULL;
  return ump;
}
     fa6:	ce 01       	movw	r24, r28
     fa8:	df 91       	pop	r29
     faa:	cf 91       	pop	r28
     fac:	08 95       	ret
    ump->m_next = tp->p_mtxlist;
    tp->p_mtxlist = ump;
    chSchReadyI(tp);
  }
  else
    ump->m_owner = NULL;
     fae:	1d 82       	std	Y+5, r1	; 0x05
     fb0:	1c 82       	std	Y+4, r1	; 0x04
  return ump;
}
     fb2:	ce 01       	movw	r24, r28
     fb4:	df 91       	pop	r29
     fb6:	cf 91       	pop	r28
     fb8:	08 95       	ret

00000fba <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
     fba:	0f 93       	push	r16
     fbc:	1f 93       	push	r17
     fbe:	cf 93       	push	r28
     fc0:	df 93       	push	r29
  Thread *ctp = currp;
     fc2:	00 91 3a 02 	lds	r16, 0x023A
     fc6:	10 91 3b 02 	lds	r17, 0x023B

  chSysLock();
     fca:	f8 94       	cli
  if (ctp->p_mtxlist != NULL) {
     fcc:	d8 01       	movw	r26, r16
     fce:	5d 96       	adiw	r26, 0x1d	; 29
     fd0:	ed 91       	ld	r30, X+
     fd2:	fc 91       	ld	r31, X
     fd4:	5e 97       	sbiw	r26, 0x1e	; 30
     fd6:	30 97       	sbiw	r30, 0x00	; 0
     fd8:	f9 f4       	brne	.+62     	; 0x1018 <chMtxUnlockAll+0x5e>
     fda:	38 c0       	rjmp	.+112    	; 0x104c <chMtxUnlockAll+0x92>
     fdc:	8d 91       	ld	r24, X+
     fde:	9c 91       	ld	r25, X
     fe0:	11 97       	sbiw	r26, 0x01	; 1
     fe2:	91 83       	std	Z+1, r25	; 0x01
     fe4:	80 83       	st	Z, r24
     fe6:	ec 01       	movw	r28, r24
     fe8:	fb 83       	std	Y+3, r31	; 0x03
     fea:	ea 83       	std	Y+2, r30	; 0x02
    do {
      Mutex *ump = ctp->p_mtxlist;
      ctp->p_mtxlist = ump->m_next;
      if (chMtxQueueNotEmptyS(ump)) {
        Thread *tp = fifo_remove(&ump->m_queue);
        ump->m_owner = tp;
     fec:	b5 83       	std	Z+5, r27	; 0x05
     fee:	a4 83       	std	Z+4, r26	; 0x04
        ump->m_next = tp->p_mtxlist;
     ff0:	5d 96       	adiw	r26, 0x1d	; 29
     ff2:	8d 91       	ld	r24, X+
     ff4:	9c 91       	ld	r25, X
     ff6:	5e 97       	sbiw	r26, 0x1e	; 30
     ff8:	97 83       	std	Z+7, r25	; 0x07
     ffa:	86 83       	std	Z+6, r24	; 0x06
        tp->p_mtxlist = ump;
     ffc:	5e 96       	adiw	r26, 0x1e	; 30
     ffe:	fc 93       	st	X, r31
    1000:	ee 93       	st	-X, r30
    1002:	5d 97       	sbiw	r26, 0x1d	; 29
        chSchReadyI(tp);
    1004:	cd 01       	movw	r24, r26
    1006:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
      }
      else
        ump->m_owner = NULL;
    } while (ctp->p_mtxlist != NULL);
    100a:	d8 01       	movw	r26, r16
    100c:	5d 96       	adiw	r26, 0x1d	; 29
    100e:	ed 91       	ld	r30, X+
    1010:	fc 91       	ld	r31, X
    1012:	5e 97       	sbiw	r26, 0x1e	; 30
    1014:	30 97       	sbiw	r30, 0x00	; 0
    1016:	99 f0       	breq	.+38     	; 0x103e <chMtxUnlockAll+0x84>

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      Mutex *ump = ctp->p_mtxlist;
      ctp->p_mtxlist = ump->m_next;
    1018:	86 81       	ldd	r24, Z+6	; 0x06
    101a:	97 81       	ldd	r25, Z+7	; 0x07
    101c:	e8 01       	movw	r28, r16
    101e:	9e 8f       	std	Y+30, r25	; 0x1e
    1020:	8d 8f       	std	Y+29, r24	; 0x1d
      if (chMtxQueueNotEmptyS(ump)) {
    1022:	a0 81       	ld	r26, Z
    1024:	b1 81       	ldd	r27, Z+1	; 0x01
    1026:	ae 17       	cp	r26, r30
    1028:	bf 07       	cpc	r27, r31
    102a:	c1 f6       	brne	.-80     	; 0xfdc <chMtxUnlockAll+0x22>
        ump->m_next = tp->p_mtxlist;
        tp->p_mtxlist = ump;
        chSchReadyI(tp);
      }
      else
        ump->m_owner = NULL;
    102c:	15 82       	std	Z+5, r1	; 0x05
    102e:	14 82       	std	Z+4, r1	; 0x04
    } while (ctp->p_mtxlist != NULL);
    1030:	d8 01       	movw	r26, r16
    1032:	5d 96       	adiw	r26, 0x1d	; 29
    1034:	ed 91       	ld	r30, X+
    1036:	fc 91       	ld	r31, X
    1038:	5e 97       	sbiw	r26, 0x1e	; 30
    103a:	30 97       	sbiw	r30, 0x00	; 0
    103c:	69 f7       	brne	.-38     	; 0x1018 <chMtxUnlockAll+0x5e>
    ctp->p_prio = ctp->p_realprio;
    103e:	5f 96       	adiw	r26, 0x1f	; 31
    1040:	8c 91       	ld	r24, X
    1042:	5f 97       	sbiw	r26, 0x1f	; 31
    1044:	14 96       	adiw	r26, 0x04	; 4
    1046:	8c 93       	st	X, r24
    chSchRescheduleS();
    1048:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  }
  chSysUnlock();
    104c:	78 94       	sei
}
    104e:	df 91       	pop	r29
    1050:	cf 91       	pop	r28
    1052:	1f 91       	pop	r17
    1054:	0f 91       	pop	r16
    1056:	08 95       	ret

00001058 <chCondInit>:
 *
 * @param[out] cp       pointer to a @p CondVar structure
 *
 * @init
 */
void chCondInit(CondVar *cp) {
    1058:	fc 01       	movw	r30, r24

  chDbgCheck(cp != NULL, "chCondInit");

  queue_init(&cp->c_queue);
    105a:	82 83       	std	Z+2, r24	; 0x02
    105c:	f3 83       	std	Z+3, r31	; 0x03
    105e:	80 83       	st	Z, r24
    1060:	f1 83       	std	Z+1, r31	; 0x01
    1062:	08 95       	ret

00001064 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @api
 */
void chCondSignal(CondVar *cp) {
    1064:	cf 93       	push	r28
    1066:	df 93       	push	r29
    1068:	fc 01       	movw	r30, r24

  chDbgCheck(cp != NULL, "chCondSignal");

  chSysLock();
    106a:	f8 94       	cli
  if (notempty(&cp->c_queue))
    106c:	80 81       	ld	r24, Z
    106e:	91 81       	ldd	r25, Z+1	; 0x01
    1070:	8e 17       	cp	r24, r30
    1072:	9f 07       	cpc	r25, r31
    1074:	69 f0       	breq	.+26     	; 0x1090 <chCondSignal+0x2c>
    1076:	ec 01       	movw	r28, r24
    1078:	a8 81       	ld	r26, Y
    107a:	b9 81       	ldd	r27, Y+1	; 0x01
    107c:	b1 83       	std	Z+1, r27	; 0x01
    107e:	a0 83       	st	Z, r26
    1080:	13 96       	adiw	r26, 0x03	; 3
    1082:	fc 93       	st	X, r31
    1084:	ee 93       	st	-X, r30
    1086:	12 97       	sbiw	r26, 0x02	; 2
    chSchWakeupS(fifo_remove(&cp->c_queue), RDY_OK);
    1088:	60 e0       	ldi	r22, 0x00	; 0
    108a:	70 e0       	ldi	r23, 0x00	; 0
    108c:	0e 94 b0 02 	call	0x560	; 0x560 <chSchWakeupS>
  chSysUnlock();
    1090:	78 94       	sei
}
    1092:	df 91       	pop	r29
    1094:	cf 91       	pop	r28
    1096:	08 95       	ret

00001098 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @iclass
 */
void chCondSignalI(CondVar *cp) {
    1098:	cf 93       	push	r28
    109a:	df 93       	push	r29
    109c:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(cp != NULL, "chCondSignalI");

  if (notempty(&cp->c_queue))
    109e:	80 81       	ld	r24, Z
    10a0:	91 81       	ldd	r25, Z+1	; 0x01
    10a2:	8e 17       	cp	r24, r30
    10a4:	9f 07       	cpc	r25, r31
    10a6:	71 f0       	breq	.+28     	; 0x10c4 <chCondSignalI+0x2c>
    10a8:	ec 01       	movw	r28, r24
    10aa:	a8 81       	ld	r26, Y
    10ac:	b9 81       	ldd	r27, Y+1	; 0x01
    10ae:	b1 83       	std	Z+1, r27	; 0x01
    10b0:	a0 83       	st	Z, r26
    10b2:	13 96       	adiw	r26, 0x03	; 3
    10b4:	fc 93       	st	X, r31
    10b6:	ee 93       	st	-X, r30
    10b8:	12 97       	sbiw	r26, 0x02	; 2
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_OK;
    10ba:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
    10be:	fc 01       	movw	r30, r24
    10c0:	13 8a       	std	Z+19, r1	; 0x13
    10c2:	12 8a       	std	Z+18, r1	; 0x12
}
    10c4:	df 91       	pop	r29
    10c6:	cf 91       	pop	r28
    10c8:	08 95       	ret

000010ca <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @iclass
 */
void chCondBroadcastI(CondVar *cp) {
    10ca:	0f 93       	push	r16
    10cc:	1f 93       	push	r17
    10ce:	cf 93       	push	r28
    10d0:	df 93       	push	r29
    10d2:	ec 01       	movw	r28, r24
  chDbgCheck(cp != NULL, "chCondBroadcastI");

  /* Empties the condition variable queue and inserts all the Threads into the
     ready list in FIFO order. The wakeup message is set to @p RDY_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (cp->c_queue.p_next != (void *)&cp->c_queue)
    10d4:	88 81       	ld	r24, Y
    10d6:	99 81       	ldd	r25, Y+1	; 0x01
    10d8:	8c 17       	cp	r24, r28
    10da:	9d 07       	cpc	r25, r29
    10dc:	99 f0       	breq	.+38     	; 0x1104 <chCondBroadcastI+0x3a>
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_RESET;
    10de:	0e ef       	ldi	r16, 0xFE	; 254
    10e0:	1f ef       	ldi	r17, 0xFF	; 255
    10e2:	dc 01       	movw	r26, r24
    10e4:	ed 91       	ld	r30, X+
    10e6:	fc 91       	ld	r31, X
    10e8:	f9 83       	std	Y+1, r31	; 0x01
    10ea:	e8 83       	st	Y, r30
    10ec:	d3 83       	std	Z+3, r29	; 0x03
    10ee:	c2 83       	std	Z+2, r28	; 0x02
    10f0:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
    10f4:	fc 01       	movw	r30, r24
    10f6:	13 8b       	std	Z+19, r17	; 0x13
    10f8:	02 8b       	std	Z+18, r16	; 0x12
  chDbgCheck(cp != NULL, "chCondBroadcastI");

  /* Empties the condition variable queue and inserts all the Threads into the
     ready list in FIFO order. The wakeup message is set to @p RDY_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (cp->c_queue.p_next != (void *)&cp->c_queue)
    10fa:	88 81       	ld	r24, Y
    10fc:	99 81       	ldd	r25, Y+1	; 0x01
    10fe:	8c 17       	cp	r24, r28
    1100:	9d 07       	cpc	r25, r29
    1102:	79 f7       	brne	.-34     	; 0x10e2 <chCondBroadcastI+0x18>
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_RESET;
}
    1104:	df 91       	pop	r29
    1106:	cf 91       	pop	r28
    1108:	1f 91       	pop	r17
    110a:	0f 91       	pop	r16
    110c:	08 95       	ret

0000110e <chCondBroadcast>:
 *
 * @api
 */
void chCondBroadcast(CondVar *cp) {

  chSysLock();
    110e:	f8 94       	cli
  chCondBroadcastI(cp);
    1110:	0e 94 65 08 	call	0x10ca	; 0x10ca <chCondBroadcastI>
  chSchRescheduleS();
    1114:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  chSysUnlock();
    1118:	78 94       	sei
    111a:	08 95       	ret

0000111c <chCondWaitS>:
 * @retval RDY_RESET    if the condvar has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(CondVar *cp) {
    111c:	ef 92       	push	r14
    111e:	ff 92       	push	r15
    1120:	0f 93       	push	r16
    1122:	1f 93       	push	r17
    1124:	cf 93       	push	r28
    1126:	df 93       	push	r29
    1128:	7c 01       	movw	r14, r24
  Thread *ctp = currp;
    112a:	c0 91 3a 02 	lds	r28, 0x023A
    112e:	d0 91 3b 02 	lds	r29, 0x023B
  chDbgCheck(cp != NULL, "chCondWaitS");
  chDbgAssert(ctp->p_mtxlist != NULL,
              "chCondWaitS(), #1",
              "not owning a mutex");

  mp = chMtxUnlockS();
    1132:	0e 94 93 07 	call	0xf26	; 0xf26 <chMtxUnlockS>
    1136:	8c 01       	movw	r16, r24
  ctp->p_u.wtobjp = cp;
    1138:	ea 8a       	std	Y+18, r14	; 0x12
    113a:	fb 8a       	std	Y+19, r15	; 0x13
  prio_insert(ctp, &cp->c_queue);
    113c:	d7 01       	movw	r26, r14
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
    113e:	f7 01       	movw	r30, r14
    1140:	04 c0       	rjmp	.+8      	; 0x114a <chCondWaitS+0x2e>
  do {
    cp = cp->p_next;
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    1142:	94 81       	ldd	r25, Z+4	; 0x04
    1144:	8c 81       	ldd	r24, Y+4	; 0x04
    1146:	98 17       	cp	r25, r24
    1148:	28 f1       	brcs	.+74     	; 0x1194 <chCondWaitS+0x78>
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
    114a:	01 90       	ld	r0, Z+
    114c:	f0 81       	ld	r31, Z
    114e:	e0 2d       	mov	r30, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    1150:	ae 17       	cp	r26, r30
    1152:	bf 07       	cpc	r27, r31
    1154:	b1 f7       	brne	.-20     	; 0x1142 <chCondWaitS+0x26>
  tp->p_next = cp;
    1156:	b9 83       	std	Y+1, r27	; 0x01
    1158:	a8 83       	st	Y, r26
  tp->p_prev = cp->p_prev;
    115a:	12 96       	adiw	r26, 0x02	; 2
    115c:	ed 91       	ld	r30, X+
    115e:	fc 91       	ld	r31, X
    1160:	13 97       	sbiw	r26, 0x03	; 3
    1162:	fb 83       	std	Y+3, r31	; 0x03
    1164:	ea 83       	std	Y+2, r30	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
    1166:	13 96       	adiw	r26, 0x03	; 3
    1168:	dc 93       	st	X, r29
    116a:	ce 93       	st	-X, r28
    116c:	12 97       	sbiw	r26, 0x02	; 2
    116e:	d1 83       	std	Z+1, r29	; 0x01
    1170:	c0 83       	st	Z, r28
  chSchGoSleepS(THD_STATE_WTCOND);
    1172:	85 e0       	ldi	r24, 0x05	; 5
    1174:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
    1178:	fa 88       	ldd	r15, Y+18	; 0x12
    117a:	cb 89       	ldd	r28, Y+19	; 0x13
  chMtxLockS(mp);
    117c:	c8 01       	movw	r24, r16
    117e:	0e 94 46 06 	call	0xc8c	; 0xc8c <chMtxLockS>
  return msg;
}
    1182:	8f 2d       	mov	r24, r15
    1184:	9c 2f       	mov	r25, r28
    1186:	df 91       	pop	r29
    1188:	cf 91       	pop	r28
    118a:	1f 91       	pop	r17
    118c:	0f 91       	pop	r16
    118e:	ff 90       	pop	r15
    1190:	ef 90       	pop	r14
    1192:	08 95       	ret
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    1194:	df 01       	movw	r26, r30
    1196:	df cf       	rjmp	.-66     	; 0x1156 <chCondWaitS+0x3a>

00001198 <chCondWait>:
 * @api
 */
msg_t chCondWait(CondVar *cp) {
  msg_t msg;

  chSysLock();
    1198:	f8 94       	cli
  msg = chCondWaitS(cp);
    119a:	0e 94 8e 08 	call	0x111c	; 0x111c <chCondWaitS>
  chSysUnlock();
    119e:	78 94       	sei
  return msg;
}
    11a0:	08 95       	ret

000011a2 <chCondWaitTimeoutS>:
 * @retval RDY_TIMEOUT  if the condvar has not been signaled within the
 *                      specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(CondVar *cp, systime_t time) {
    11a2:	ef 92       	push	r14
    11a4:	ff 92       	push	r15
    11a6:	0f 93       	push	r16
    11a8:	1f 93       	push	r17
    11aa:	cf 93       	push	r28
    11ac:	df 93       	push	r29
    11ae:	00 d0       	rcall	.+0      	; 0x11b0 <chCondWaitTimeoutS+0xe>
    11b0:	cd b7       	in	r28, 0x3d	; 61
    11b2:	de b7       	in	r29, 0x3e	; 62
    11b4:	7c 01       	movw	r14, r24
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE), "chCondWaitTimeoutS");
  chDbgAssert(currp->p_mtxlist != NULL,
              "chCondWaitTimeoutS(), #1",
              "not owning a mutex");

  mp = chMtxUnlockS();
    11b6:	69 83       	std	Y+1, r22	; 0x01
    11b8:	7a 83       	std	Y+2, r23	; 0x02
    11ba:	0e 94 93 07 	call	0xf26	; 0xf26 <chMtxUnlockS>
    11be:	8c 01       	movw	r16, r24
  currp->p_u.wtobjp = cp;
    11c0:	40 91 3a 02 	lds	r20, 0x023A
    11c4:	50 91 3b 02 	lds	r21, 0x023B
    11c8:	da 01       	movw	r26, r20
    11ca:	52 96       	adiw	r26, 0x12	; 18
    11cc:	ec 92       	st	X, r14
    11ce:	52 97       	sbiw	r26, 0x12	; 18
    11d0:	53 96       	adiw	r26, 0x13	; 19
    11d2:	fc 92       	st	X, r15
  prio_insert(currp, &cp->c_queue);
    11d4:	97 01       	movw	r18, r14
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
    11d6:	f7 01       	movw	r30, r14
    11d8:	7a 81       	ldd	r23, Y+2	; 0x02
    11da:	69 81       	ldd	r22, Y+1	; 0x01
  do {
    cp = cp->p_next;
    11dc:	01 90       	ld	r0, Z+
    11de:	f0 81       	ld	r31, Z
    11e0:	e0 2d       	mov	r30, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    11e2:	2e 17       	cp	r18, r30
    11e4:	3f 07       	cpc	r19, r31
    11e6:	31 f0       	breq	.+12     	; 0x11f4 <chCondWaitTimeoutS+0x52>
    11e8:	94 81       	ldd	r25, Z+4	; 0x04
    11ea:	da 01       	movw	r26, r20
    11ec:	14 96       	adiw	r26, 0x04	; 4
    11ee:	8c 91       	ld	r24, X
    11f0:	98 17       	cp	r25, r24
    11f2:	a0 f7       	brcc	.-24     	; 0x11dc <chCondWaitTimeoutS+0x3a>
  tp->p_next = cp;
    11f4:	da 01       	movw	r26, r20
    11f6:	11 96       	adiw	r26, 0x01	; 1
    11f8:	fc 93       	st	X, r31
    11fa:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
    11fc:	82 81       	ldd	r24, Z+2	; 0x02
    11fe:	93 81       	ldd	r25, Z+3	; 0x03
    1200:	13 96       	adiw	r26, 0x03	; 3
    1202:	9c 93       	st	X, r25
    1204:	8e 93       	st	-X, r24
    1206:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
    1208:	53 83       	std	Z+3, r21	; 0x03
    120a:	42 83       	std	Z+2, r20	; 0x02
    120c:	fc 01       	movw	r30, r24
    120e:	51 83       	std	Z+1, r21	; 0x01
    1210:	40 83       	st	Z, r20
  msg = chSchGoSleepTimeoutS(THD_STATE_WTCOND, time);
    1212:	85 e0       	ldi	r24, 0x05	; 5
    1214:	0e 94 77 02 	call	0x4ee	; 0x4ee <chSchGoSleepTimeoutS>
    1218:	7c 01       	movw	r14, r24
  if (msg != RDY_TIMEOUT)
    121a:	8f 3f       	cpi	r24, 0xFF	; 255
    121c:	ff ef       	ldi	r31, 0xFF	; 255
    121e:	9f 07       	cpc	r25, r31
    1220:	19 f0       	breq	.+6      	; 0x1228 <chCondWaitTimeoutS+0x86>
    chMtxLockS(mp);
    1222:	c8 01       	movw	r24, r16
    1224:	0e 94 46 06 	call	0xc8c	; 0xc8c <chMtxLockS>
  return msg;
}
    1228:	c7 01       	movw	r24, r14
    122a:	0f 90       	pop	r0
    122c:	0f 90       	pop	r0
    122e:	df 91       	pop	r29
    1230:	cf 91       	pop	r28
    1232:	1f 91       	pop	r17
    1234:	0f 91       	pop	r16
    1236:	ff 90       	pop	r15
    1238:	ef 90       	pop	r14
    123a:	08 95       	ret

0000123c <chCondWaitTimeout>:
 * @api
 */
msg_t chCondWaitTimeout(CondVar *cp, systime_t time) {
  msg_t msg;

  chSysLock();
    123c:	f8 94       	cli
  msg = chCondWaitTimeoutS(cp, time);
    123e:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <chCondWaitTimeoutS>
  chSysUnlock();
    1242:	78 94       	sei
  return msg;
}
    1244:	08 95       	ret

00001246 <chEvtRegisterMask>:
 * @param[in] mask      the mask of event flags to be ORed to the thread when
 *                      the event source is broadcasted
 *
 * @api
 */
void chEvtRegisterMask(EventSource *esp, EventListener *elp, eventmask_t mask) {
    1246:	fb 01       	movw	r30, r22

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtRegisterMask");

  chSysLock();
    1248:	f8 94       	cli
  elp->el_next     = esp->es_next;
    124a:	dc 01       	movw	r26, r24
    124c:	2d 91       	ld	r18, X+
    124e:	3c 91       	ld	r19, X
    1250:	11 97       	sbiw	r26, 0x01	; 1
    1252:	31 83       	std	Z+1, r19	; 0x01
    1254:	20 83       	st	Z, r18
  esp->es_next     = elp;
    1256:	6d 93       	st	X+, r22
    1258:	7c 93       	st	X, r23
  elp->el_listener = currp;
    125a:	80 91 3a 02 	lds	r24, 0x023A
    125e:	90 91 3b 02 	lds	r25, 0x023B
    1262:	93 83       	std	Z+3, r25	; 0x03
    1264:	82 83       	std	Z+2, r24	; 0x02
  elp->el_mask     = mask;
    1266:	44 83       	std	Z+4, r20	; 0x04
  elp->el_flags    = 0;
    1268:	15 82       	std	Z+5, r1	; 0x05
  chSysUnlock();
    126a:	78 94       	sei
    126c:	08 95       	ret

0000126e <chEvtUnregister>:
  EventListener *p;

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
  chSysLock();
    126e:	f8 94       	cli
void chEvtUnregister(EventSource *esp, EventListener *elp) {
  EventListener *p;

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
    1270:	fc 01       	movw	r30, r24
  chSysLock();
  while (p->el_next != (EventListener *)esp) {
    1272:	01 c0       	rjmp	.+2      	; 0x1276 <chEvtUnregister+0x8>
    if (p->el_next == elp) {
    1274:	f9 01       	movw	r30, r18

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
  chSysLock();
  while (p->el_next != (EventListener *)esp) {
    1276:	20 81       	ld	r18, Z
    1278:	31 81       	ldd	r19, Z+1	; 0x01
    127a:	28 17       	cp	r18, r24
    127c:	39 07       	cpc	r19, r25
    127e:	41 f0       	breq	.+16     	; 0x1290 <chEvtUnregister+0x22>
    if (p->el_next == elp) {
    1280:	62 17       	cp	r22, r18
    1282:	73 07       	cpc	r23, r19
    1284:	b9 f7       	brne	.-18     	; 0x1274 <chEvtUnregister+0x6>
      p->el_next = elp->el_next;
    1286:	db 01       	movw	r26, r22
    1288:	8d 91       	ld	r24, X+
    128a:	9c 91       	ld	r25, X
    128c:	91 83       	std	Z+1, r25	; 0x01
    128e:	80 83       	st	Z, r24
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
    1290:	78 94       	sei
    1292:	08 95       	ret

00001294 <chEvtGetAndClearEvents>:
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t mask) {
  eventmask_t m;

  chSysLock();
    1294:	f8 94       	cli

  m = currp->p_epending & mask;
    1296:	e0 91 3a 02 	lds	r30, 0x023A
    129a:	f0 91 3b 02 	lds	r31, 0x023B
    129e:	24 8d       	ldd	r18, Z+28	; 0x1c
  currp->p_epending &= ~mask;
    12a0:	98 2f       	mov	r25, r24
    12a2:	90 95       	com	r25
    12a4:	92 23       	and	r25, r18
    12a6:	94 8f       	std	Z+28, r25	; 0x1c

  chSysUnlock();
    12a8:	78 94       	sei
  return m;
}
    12aa:	82 23       	and	r24, r18
    12ac:	08 95       	ret

000012ae <chEvtAddEvents>:
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t mask) {

  chSysLock();
    12ae:	f8 94       	cli

  mask = (currp->p_epending |= mask);
    12b0:	e0 91 3a 02 	lds	r30, 0x023A
    12b4:	f0 91 3b 02 	lds	r31, 0x023B
    12b8:	94 8d       	ldd	r25, Z+28	; 0x1c
    12ba:	89 2b       	or	r24, r25
    12bc:	84 8f       	std	Z+28, r24	; 0x1c

  chSysUnlock();
    12be:	78 94       	sei
  return mask;
}
    12c0:	08 95       	ret

000012c2 <chEvtGetAndClearFlags>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
flagsmask_t chEvtGetAndClearFlags(EventListener *elp) {
    12c2:	fc 01       	movw	r30, r24
  flagsmask_t flags;

  chSysLock();
    12c4:	f8 94       	cli

  flags = elp->el_flags;
    12c6:	85 81       	ldd	r24, Z+5	; 0x05
  elp->el_flags = 0;
    12c8:	15 82       	std	Z+5, r1	; 0x05

  chSysUnlock();
    12ca:	78 94       	sei
  return flags;
}
    12cc:	08 95       	ret

000012ce <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(Thread *tp, eventmask_t mask) {
    12ce:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
    12d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    12d2:	68 2b       	or	r22, r24
    12d4:	64 8f       	std	Z+28, r22	; 0x1c
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
    12d6:	85 85       	ldd	r24, Z+13	; 0x0d
    12d8:	88 30       	cpi	r24, 0x08	; 8
    12da:	71 f0       	breq	.+28     	; 0x12f8 <chEvtSignalI+0x2a>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
    12dc:	89 30       	cpi	r24, 0x09	; 9
    12de:	09 f0       	breq	.+2      	; 0x12e2 <chEvtSignalI+0x14>
    12e0:	08 95       	ret
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    12e2:	82 89       	ldd	r24, Z+18	; 0x12
    12e4:	68 23       	and	r22, r24

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
    12e6:	86 13       	cpse	r24, r22
    12e8:	fb cf       	rjmp	.-10     	; 0x12e0 <chEvtSignalI+0x12>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
    12ea:	cf 01       	movw	r24, r30
    12ec:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
    12f0:	fc 01       	movw	r30, r24
    12f2:	13 8a       	std	Z+19, r1	; 0x13
    12f4:	12 8a       	std	Z+18, r1	; 0x12
    12f6:	08 95       	ret
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
    12f8:	82 89       	ldd	r24, Z+18	; 0x12
    12fa:	86 23       	and	r24, r22
  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
    12fc:	b1 f7       	brne	.-20     	; 0x12ea <chEvtSignalI+0x1c>
    12fe:	08 95       	ret

00001300 <chEvtSignal>:
 */
void chEvtSignal(Thread *tp, eventmask_t mask) {

  chDbgCheck(tp != NULL, "chEvtSignal");

  chSysLock();
    1300:	f8 94       	cli
  chEvtSignalI(tp, mask);
    1302:	0e 94 67 09 	call	0x12ce	; 0x12ce <chEvtSignalI>
  chSchRescheduleS();
    1306:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  chSysUnlock();
    130a:	78 94       	sei
    130c:	08 95       	ret

0000130e <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p EventSource structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(EventSource *esp, flagsmask_t flags) {
    130e:	ff 92       	push	r15
    1310:	0f 93       	push	r16
    1312:	1f 93       	push	r17
    1314:	cf 93       	push	r28
    1316:	df 93       	push	r29
    1318:	8c 01       	movw	r16, r24
    131a:	f6 2e       	mov	r15, r22
  EventListener *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
    131c:	fc 01       	movw	r30, r24
    131e:	c0 81       	ld	r28, Z
    1320:	d1 81       	ldd	r29, Z+1	; 0x01
  while (elp != (EventListener *)esp) {
    1322:	8c 17       	cp	r24, r28
    1324:	9d 07       	cpc	r25, r29
    1326:	71 f0       	breq	.+28     	; 0x1344 <chEvtBroadcastFlagsI+0x36>
    elp->el_flags |= flags;
    1328:	8d 81       	ldd	r24, Y+5	; 0x05
    132a:	8f 29       	or	r24, r15
    132c:	8d 83       	std	Y+5, r24	; 0x05
    chEvtSignalI(elp->el_listener, elp->el_mask);
    132e:	6c 81       	ldd	r22, Y+4	; 0x04
    1330:	8a 81       	ldd	r24, Y+2	; 0x02
    1332:	9b 81       	ldd	r25, Y+3	; 0x03
    1334:	0e 94 67 09 	call	0x12ce	; 0x12ce <chEvtSignalI>
    elp = elp->el_next;
    1338:	09 90       	ld	r0, Y+
    133a:	d8 81       	ld	r29, Y
    133c:	c0 2d       	mov	r28, r0

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
  while (elp != (EventListener *)esp) {
    133e:	0c 17       	cp	r16, r28
    1340:	1d 07       	cpc	r17, r29
    1342:	91 f7       	brne	.-28     	; 0x1328 <chEvtBroadcastFlagsI+0x1a>
    elp->el_flags |= flags;
    chEvtSignalI(elp->el_listener, elp->el_mask);
    elp = elp->el_next;
  }
}
    1344:	df 91       	pop	r29
    1346:	cf 91       	pop	r28
    1348:	1f 91       	pop	r17
    134a:	0f 91       	pop	r16
    134c:	ff 90       	pop	r15
    134e:	08 95       	ret

00001350 <chEvtBroadcastFlags>:
 *
 * @api
 */
void chEvtBroadcastFlags(EventSource *esp, flagsmask_t flags) {

  chSysLock();
    1350:	f8 94       	cli
  chEvtBroadcastFlagsI(esp, flags);
    1352:	0e 94 87 09 	call	0x130e	; 0x130e <chEvtBroadcastFlagsI>
  chSchRescheduleS();
    1356:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  chSysUnlock();
    135a:	78 94       	sei
    135c:	08 95       	ret

0000135e <chEvtGetAndClearFlagsI>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
flagsmask_t chEvtGetAndClearFlagsI(EventListener *elp) {
    135e:	fc 01       	movw	r30, r24
  flagsmask_t flags;

  flags = elp->el_flags;
    1360:	85 81       	ldd	r24, Z+5	; 0x05
  elp->el_flags = 0;
    1362:	15 82       	std	Z+5, r1	; 0x05

  return flags;
}
    1364:	08 95       	ret

00001366 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t mask) {
    1366:	ef 92       	push	r14
    1368:	ff 92       	push	r15
    136a:	0f 93       	push	r16
    136c:	1f 93       	push	r17
    136e:	cf 93       	push	r28
    1370:	df 93       	push	r29
    1372:	8c 01       	movw	r16, r24
    1374:	e6 2e       	mov	r14, r22
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    1376:	66 23       	and	r22, r22
    1378:	01 f1       	breq	.+64     	; 0x13ba <chEvtDispatch+0x54>
    137a:	f1 2c       	mov	r15, r1
    if (mask & EVENT_MASK(eid)) {
    137c:	c1 e0       	ldi	r28, 0x01	; 1
    137e:	d0 e0       	ldi	r29, 0x00	; 0
    1380:	03 c0       	rjmp	.+6      	; 0x1388 <chEvtDispatch+0x22>
                  "chEvtDispatch(), #1",
                  "null handler");
      mask &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
    1382:	f3 94       	inc	r15
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    1384:	ee 20       	and	r14, r14
    1386:	c9 f0       	breq	.+50     	; 0x13ba <chEvtDispatch+0x54>
    if (mask & EVENT_MASK(eid)) {
    1388:	9e 01       	movw	r18, r28
    138a:	0f 2c       	mov	r0, r15
    138c:	01 c0       	rjmp	.+2      	; 0x1390 <chEvtDispatch+0x2a>
    138e:	22 0f       	add	r18, r18
    1390:	0a 94       	dec	r0
    1392:	ea f7       	brpl	.-6      	; 0x138e <chEvtDispatch+0x28>
    1394:	8e 2d       	mov	r24, r14
    1396:	82 23       	and	r24, r18
    1398:	a1 f3       	breq	.-24     	; 0x1382 <chEvtDispatch+0x1c>
      chDbgAssert(handlers[eid] != NULL,
                  "chEvtDispatch(), #1",
                  "null handler");
      mask &= ~EVENT_MASK(eid);
    139a:	20 95       	com	r18
    139c:	e2 22       	and	r14, r18
      handlers[eid](eid);
    139e:	ef 2d       	mov	r30, r15
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	ee 0f       	add	r30, r30
    13a4:	ff 1f       	adc	r31, r31
    13a6:	e0 0f       	add	r30, r16
    13a8:	f1 1f       	adc	r31, r17
    13aa:	01 90       	ld	r0, Z+
    13ac:	f0 81       	ld	r31, Z
    13ae:	e0 2d       	mov	r30, r0
    13b0:	8f 2d       	mov	r24, r15
    13b2:	09 95       	icall
    }
    eid++;
    13b4:	f3 94       	inc	r15
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    13b6:	e1 10       	cpse	r14, r1
    13b8:	e7 cf       	rjmp	.-50     	; 0x1388 <chEvtDispatch+0x22>
      mask &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
    13ba:	df 91       	pop	r29
    13bc:	cf 91       	pop	r28
    13be:	1f 91       	pop	r17
    13c0:	0f 91       	pop	r16
    13c2:	ff 90       	pop	r15
    13c4:	ef 90       	pop	r14
    13c6:	08 95       	ret

000013c8 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest id served and cleared event.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t mask) {
    13c8:	1f 93       	push	r17
    13ca:	cf 93       	push	r28
    13cc:	df 93       	push	r29
    13ce:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    13d0:	c0 91 3a 02 	lds	r28, 0x023A
    13d4:	d0 91 3b 02 	lds	r29, 0x023B
  eventmask_t m;

  chSysLock();
    13d8:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    13da:	2c 8d       	ldd	r18, Y+28	; 0x1c
    13dc:	98 2f       	mov	r25, r24
    13de:	92 23       	and	r25, r18
    13e0:	39 f4       	brne	.+14     	; 0x13f0 <chEvtWaitOne+0x28>
    ctp->p_u.ewmask = mask;
    13e2:	8a 8b       	std	Y+18, r24	; 0x12
    chSchGoSleepS(THD_STATE_WTOREVT);
    13e4:	88 e0       	ldi	r24, 0x08	; 8
    13e6:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
    m = ctp->p_epending & mask;
    13ea:	2c 8d       	ldd	r18, Y+28	; 0x1c
    13ec:	91 2f       	mov	r25, r17
    13ee:	92 23       	and	r25, r18
  }
  m &= -m;
    13f0:	89 2f       	mov	r24, r25
    13f2:	81 95       	neg	r24
    13f4:	89 23       	and	r24, r25
  ctp->p_epending &= ~m;
    13f6:	98 2f       	mov	r25, r24
    13f8:	90 95       	com	r25
    13fa:	92 23       	and	r25, r18
    13fc:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    13fe:	78 94       	sei
  return m;
}
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	1f 91       	pop	r17
    1406:	08 95       	ret

00001408 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
    1408:	1f 93       	push	r17
    140a:	cf 93       	push	r28
    140c:	df 93       	push	r29
    140e:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    1410:	c0 91 3a 02 	lds	r28, 0x023A
    1414:	d0 91 3b 02 	lds	r29, 0x023B
  eventmask_t m;

  chSysLock();
    1418:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    141a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    141c:	82 23       	and	r24, r18
    141e:	39 f4       	brne	.+14     	; 0x142e <chEvtWaitAny+0x26>
    ctp->p_u.ewmask = mask;
    1420:	1a 8b       	std	Y+18, r17	; 0x12
    chSchGoSleepS(THD_STATE_WTOREVT);
    1422:	88 e0       	ldi	r24, 0x08	; 8
    1424:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
    m = ctp->p_epending & mask;
    1428:	2c 8d       	ldd	r18, Y+28	; 0x1c
    142a:	81 2f       	mov	r24, r17
    142c:	82 23       	and	r24, r18
  }
  ctp->p_epending &= ~m;
    142e:	98 2f       	mov	r25, r24
    1430:	90 95       	com	r25
    1432:	92 23       	and	r25, r18
    1434:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    1436:	78 94       	sei
  return m;
}
    1438:	df 91       	pop	r29
    143a:	cf 91       	pop	r28
    143c:	1f 91       	pop	r17
    143e:	08 95       	ret

00001440 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t mask) {
    1440:	1f 93       	push	r17
    1442:	cf 93       	push	r28
    1444:	df 93       	push	r29
    1446:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    1448:	c0 91 3a 02 	lds	r28, 0x023A
    144c:	d0 91 3b 02 	lds	r29, 0x023B

  chSysLock();
    1450:	f8 94       	cli

  if ((ctp->p_epending & mask) != mask) {
    1452:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1454:	89 23       	and	r24, r25
    1456:	81 17       	cp	r24, r17
    1458:	29 f0       	breq	.+10     	; 0x1464 <chEvtWaitAll+0x24>
    ctp->p_u.ewmask = mask;
    145a:	1a 8b       	std	Y+18, r17	; 0x12
    chSchGoSleepS(THD_STATE_WTANDEVT);
    145c:	89 e0       	ldi	r24, 0x09	; 9
    145e:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
    1462:	9c 8d       	ldd	r25, Y+28	; 0x1c
  }
  ctp->p_epending &= ~mask;
    1464:	81 2f       	mov	r24, r17
    1466:	80 95       	com	r24
    1468:	89 23       	and	r24, r25
    146a:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    146c:	78 94       	sei
  return mask;
}
    146e:	81 2f       	mov	r24, r17
    1470:	df 91       	pop	r29
    1472:	cf 91       	pop	r28
    1474:	1f 91       	pop	r17
    1476:	08 95       	ret

00001478 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest id served and cleared event.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t mask, systime_t time) {
    1478:	0f 93       	push	r16
    147a:	1f 93       	push	r17
    147c:	cf 93       	push	r28
    147e:	df 93       	push	r29
    1480:	08 2f       	mov	r16, r24
  Thread *ctp = currp;
    1482:	c0 91 3a 02 	lds	r28, 0x023A
    1486:	d0 91 3b 02 	lds	r29, 0x023B
  eventmask_t m;

  chSysLock();
    148a:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    148c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    148e:	18 2f       	mov	r17, r24
    1490:	19 23       	and	r17, r25
    1492:	99 f4       	brne	.+38     	; 0x14ba <chEvtWaitOneTimeout+0x42>
    if (TIME_IMMEDIATE == time) {
    1494:	61 15       	cp	r22, r1
    1496:	71 05       	cpc	r23, r1
    1498:	39 f4       	brne	.+14     	; 0x14a8 <chEvtWaitOneTimeout+0x30>
    m = ctp->p_epending & mask;
  }
  m &= -m;
  ctp->p_epending &= ~m;

  chSysUnlock();
    149a:	78 94       	sei
  return m;
}
    149c:	81 2f       	mov	r24, r17
    149e:	df 91       	pop	r29
    14a0:	cf 91       	pop	r28
    14a2:	1f 91       	pop	r17
    14a4:	0f 91       	pop	r16
    14a6:	08 95       	ret
  if ((m = (ctp->p_epending & mask)) == 0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    14a8:	8a 8b       	std	Y+18, r24	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
    14aa:	88 e0       	ldi	r24, 0x08	; 8
    14ac:	0e 94 77 02 	call	0x4ee	; 0x4ee <chSchGoSleepTimeoutS>
    14b0:	97 fd       	sbrc	r25, 7
    14b2:	f3 cf       	rjmp	.-26     	; 0x149a <chEvtWaitOneTimeout+0x22>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & mask;
    14b4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    14b6:	10 2f       	mov	r17, r16
    14b8:	19 23       	and	r17, r25
  }
  m &= -m;
    14ba:	81 2f       	mov	r24, r17
    14bc:	81 95       	neg	r24
    14be:	18 23       	and	r17, r24
  ctp->p_epending &= ~m;
    14c0:	81 2f       	mov	r24, r17
    14c2:	80 95       	com	r24
    14c4:	89 23       	and	r24, r25
    14c6:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    14c8:	78 94       	sei
  return m;
}
    14ca:	81 2f       	mov	r24, r17
    14cc:	df 91       	pop	r29
    14ce:	cf 91       	pop	r28
    14d0:	1f 91       	pop	r17
    14d2:	0f 91       	pop	r16
    14d4:	08 95       	ret

000014d6 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t time) {
    14d6:	0f 93       	push	r16
    14d8:	1f 93       	push	r17
    14da:	cf 93       	push	r28
    14dc:	df 93       	push	r29
    14de:	08 2f       	mov	r16, r24
  Thread *ctp = currp;
    14e0:	c0 91 3a 02 	lds	r28, 0x023A
    14e4:	d0 91 3b 02 	lds	r29, 0x023B
  eventmask_t m;

  chSysLock();
    14e8:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    14ea:	9c 8d       	ldd	r25, Y+28	; 0x1c
    14ec:	18 2f       	mov	r17, r24
    14ee:	19 23       	and	r17, r25
    14f0:	99 f4       	brne	.+38     	; 0x1518 <chEvtWaitAnyTimeout+0x42>
    if (TIME_IMMEDIATE == time) {
    14f2:	61 15       	cp	r22, r1
    14f4:	71 05       	cpc	r23, r1
    14f6:	39 f4       	brne	.+14     	; 0x1506 <chEvtWaitAnyTimeout+0x30>
    }
    m = ctp->p_epending & mask;
  }
  ctp->p_epending &= ~m;

  chSysUnlock();
    14f8:	78 94       	sei
  return m;
}
    14fa:	81 2f       	mov	r24, r17
    14fc:	df 91       	pop	r29
    14fe:	cf 91       	pop	r28
    1500:	1f 91       	pop	r17
    1502:	0f 91       	pop	r16
    1504:	08 95       	ret
  if ((m = (ctp->p_epending & mask)) == 0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    1506:	8a 8b       	std	Y+18, r24	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
    1508:	88 e0       	ldi	r24, 0x08	; 8
    150a:	0e 94 77 02 	call	0x4ee	; 0x4ee <chSchGoSleepTimeoutS>
    150e:	97 fd       	sbrc	r25, 7
    1510:	f3 cf       	rjmp	.-26     	; 0x14f8 <chEvtWaitAnyTimeout+0x22>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & mask;
    1512:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1514:	10 2f       	mov	r17, r16
    1516:	19 23       	and	r17, r25
  }
  ctp->p_epending &= ~m;
    1518:	81 2f       	mov	r24, r17
    151a:	80 95       	com	r24
    151c:	89 23       	and	r24, r25
    151e:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    1520:	78 94       	sei
  return m;
}
    1522:	81 2f       	mov	r24, r17
    1524:	df 91       	pop	r29
    1526:	cf 91       	pop	r28
    1528:	1f 91       	pop	r17
    152a:	0f 91       	pop	r16
    152c:	08 95       	ret

0000152e <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t mask, systime_t time) {
    152e:	1f 93       	push	r17
    1530:	cf 93       	push	r28
    1532:	df 93       	push	r29
    1534:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    1536:	c0 91 3a 02 	lds	r28, 0x023A
    153a:	d0 91 3b 02 	lds	r29, 0x023B

  chSysLock();
    153e:	f8 94       	cli

  if ((ctp->p_epending & mask) != mask) {
    1540:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1542:	91 2f       	mov	r25, r17
    1544:	98 23       	and	r25, r24
    1546:	91 17       	cp	r25, r17
    1548:	89 f0       	breq	.+34     	; 0x156c <chEvtWaitAllTimeout+0x3e>
    if (TIME_IMMEDIATE == time) {
    154a:	61 15       	cp	r22, r1
    154c:	71 05       	cpc	r23, r1
    154e:	39 f4       	brne	.+14     	; 0x155e <chEvtWaitAllTimeout+0x30>
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    if (chSchGoSleepTimeoutS(THD_STATE_WTANDEVT, time) < RDY_OK) {
      chSysUnlock();
    1550:	78 94       	sei
      return (eventmask_t)0;
    1552:	10 e0       	ldi	r17, 0x00	; 0
  }
  ctp->p_epending &= ~mask;

  chSysUnlock();
  return mask;
}
    1554:	81 2f       	mov	r24, r17
    1556:	df 91       	pop	r29
    1558:	cf 91       	pop	r28
    155a:	1f 91       	pop	r17
    155c:	08 95       	ret
  if ((ctp->p_epending & mask) != mask) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    155e:	1a 8b       	std	Y+18, r17	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTANDEVT, time) < RDY_OK) {
    1560:	89 e0       	ldi	r24, 0x09	; 9
    1562:	0e 94 77 02 	call	0x4ee	; 0x4ee <chSchGoSleepTimeoutS>
    1566:	97 fd       	sbrc	r25, 7
    1568:	f3 cf       	rjmp	.-26     	; 0x1550 <chEvtWaitAllTimeout+0x22>
    156a:	8c 8d       	ldd	r24, Y+28	; 0x1c
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~mask;
    156c:	91 2f       	mov	r25, r17
    156e:	90 95       	com	r25
    1570:	98 23       	and	r25, r24
    1572:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    1574:	78 94       	sei
  return mask;
}
    1576:	81 2f       	mov	r24, r17
    1578:	df 91       	pop	r29
    157a:	cf 91       	pop	r28
    157c:	1f 91       	pop	r17
    157e:	08 95       	ret

00001580 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(Thread *tp, msg_t msg) {
    1580:	cf 93       	push	r28
    1582:	df 93       	push	r29
    1584:	fc 01       	movw	r30, r24
  Thread *ctp = currp;
    1586:	c0 91 3a 02 	lds	r28, 0x023A
    158a:	d0 91 3b 02 	lds	r29, 0x023B

  chDbgCheck(tp != NULL, "chMsgSend");

  chSysLock();
    158e:	f8 94       	cli
  ctp->p_msg = msg;
    1590:	7b 8f       	std	Y+27, r23	; 0x1b
    1592:	6a 8f       	std	Y+26, r22	; 0x1a
  ctp->p_u.wtobjp = &tp->p_msgqueue;
    1594:	46 96       	adiw	r24, 0x16	; 22
    1596:	9b 8b       	std	Y+19, r25	; 0x13
    1598:	8a 8b       	std	Y+18, r24	; 0x12
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
    159a:	99 83       	std	Y+1, r25	; 0x01
    159c:	88 83       	st	Y, r24
  tp->p_prev = tqp->p_prev;
    159e:	a0 8d       	ldd	r26, Z+24	; 0x18
    15a0:	b1 8d       	ldd	r27, Z+25	; 0x19
    15a2:	bb 83       	std	Y+3, r27	; 0x03
    15a4:	aa 83       	std	Y+2, r26	; 0x02
  tp->p_prev->p_next = tqp->p_prev = tp;
    15a6:	d1 8f       	std	Z+25, r29	; 0x19
    15a8:	c0 8f       	std	Z+24, r28	; 0x18
    15aa:	cd 93       	st	X+, r28
    15ac:	dc 93       	st	X, r29
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == THD_STATE_WTMSG)
    15ae:	85 85       	ldd	r24, Z+13	; 0x0d
    15b0:	8c 30       	cpi	r24, 0x0C	; 12
    15b2:	49 f0       	breq	.+18     	; 0x15c6 <chMsgSend+0x46>
    chSchReadyI(tp);
  chSchGoSleepS(THD_STATE_SNDMSGQ);
    15b4:	8a e0       	ldi	r24, 0x0A	; 10
    15b6:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
    15ba:	8a 89       	ldd	r24, Y+18	; 0x12
    15bc:	9b 89       	ldd	r25, Y+19	; 0x13
  chSysUnlock();
    15be:	78 94       	sei
  return msg;
}
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	08 95       	ret
  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == THD_STATE_WTMSG)
    chSchReadyI(tp);
    15c6:	cf 01       	movw	r24, r30
    15c8:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
    15cc:	f3 cf       	rjmp	.-26     	; 0x15b4 <chMsgSend+0x34>

000015ce <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
Thread *chMsgWait(void) {
    15ce:	cf 93       	push	r28
    15d0:	df 93       	push	r29
  Thread *tp;

  chSysLock();
    15d2:	f8 94       	cli
  if (!chMsgIsPendingI(currp))
    15d4:	a0 91 3a 02 	lds	r26, 0x023A
    15d8:	b0 91 3b 02 	lds	r27, 0x023B
    15dc:	56 96       	adiw	r26, 0x16	; 22
    15de:	ed 91       	ld	r30, X+
    15e0:	fc 91       	ld	r31, X
    15e2:	57 97       	sbiw	r26, 0x17	; 23
    15e4:	cd 01       	movw	r24, r26
    15e6:	46 96       	adiw	r24, 0x16	; 22
    15e8:	e8 17       	cp	r30, r24
    15ea:	f9 07       	cpc	r31, r25
    15ec:	79 f0       	breq	.+30     	; 0x160c <chMsgWait+0x3e>
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    15ee:	c0 81       	ld	r28, Z
    15f0:	d1 81       	ldd	r29, Z+1	; 0x01
    15f2:	57 96       	adiw	r26, 0x17	; 23
    15f4:	dc 93       	st	X, r29
    15f6:	ce 93       	st	-X, r28
    15f8:	56 97       	sbiw	r26, 0x16	; 22
    15fa:	9b 83       	std	Y+3, r25	; 0x03
    15fc:	8a 83       	std	Y+2, r24	; 0x02
    chSchGoSleepS(THD_STATE_WTMSG);
  tp = fifo_remove(&currp->p_msgqueue);
  tp->p_state = THD_STATE_SNDMSG;
    15fe:	8b e0       	ldi	r24, 0x0B	; 11
    1600:	85 87       	std	Z+13, r24	; 0x0d
  chSysUnlock();
    1602:	78 94       	sei
  return tp;
}
    1604:	cf 01       	movw	r24, r30
    1606:	df 91       	pop	r29
    1608:	cf 91       	pop	r28
    160a:	08 95       	ret
Thread *chMsgWait(void) {
  Thread *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp))
    chSchGoSleepS(THD_STATE_WTMSG);
    160c:	8c e0       	ldi	r24, 0x0C	; 12
    160e:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
    1612:	a0 91 3a 02 	lds	r26, 0x023A
    1616:	b0 91 3b 02 	lds	r27, 0x023B
    161a:	56 96       	adiw	r26, 0x16	; 22
    161c:	ed 91       	ld	r30, X+
    161e:	fc 91       	ld	r31, X
    1620:	57 97       	sbiw	r26, 0x17	; 23
    1622:	cd 01       	movw	r24, r26
    1624:	46 96       	adiw	r24, 0x16	; 22
    1626:	e3 cf       	rjmp	.-58     	; 0x15ee <chMsgWait+0x20>

00001628 <chMsgRelease>:
 *
 * @api
 */
void chMsgRelease(Thread *tp, msg_t msg) {

  chSysLock();
    1628:	f8 94       	cli
  chDbgAssert(tp->p_state == THD_STATE_SNDMSG,
              "chMsgRelease(), #1", "invalid state");
  chMsgReleaseS(tp, msg);
    162a:	0e 94 b0 02 	call	0x560	; 0x560 <chSchWakeupS>
  chSysUnlock();
    162e:	78 94       	sei
    1630:	08 95       	ret

00001632 <chMBInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBInit(Mailbox *mbp, msg_t *buf, cnt_t n) {
    1632:	cf 93       	push	r28
    1634:	df 93       	push	r29
    1636:	ec 01       	movw	r28, r24

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0), "chMBInit");

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
    1638:	7f 83       	std	Y+7, r23	; 0x07
    163a:	6e 83       	std	Y+6, r22	; 0x06
    163c:	7d 83       	std	Y+5, r23	; 0x05
    163e:	6c 83       	std	Y+4, r22	; 0x04
    1640:	79 83       	std	Y+1, r23	; 0x01
    1642:	68 83       	st	Y, r22
  mbp->mb_top = &buf[n];
    1644:	24 2f       	mov	r18, r20
    1646:	22 0f       	add	r18, r18
    1648:	33 0b       	sbc	r19, r19
    164a:	26 0f       	add	r18, r22
    164c:	37 1f       	adc	r19, r23
    164e:	3b 83       	std	Y+3, r19	; 0x03
    1650:	2a 83       	std	Y+2, r18	; 0x02
  chSemInit(&mbp->mb_emptysem, n);
    1652:	64 2f       	mov	r22, r20
    1654:	0d 96       	adiw	r24, 0x0d	; 13
    1656:	0e 94 ef 04 	call	0x9de	; 0x9de <chSemInit>
  chSemInit(&mbp->mb_fullsem, 0);
    165a:	60 e0       	ldi	r22, 0x00	; 0
    165c:	ce 01       	movw	r24, r28
    165e:	08 96       	adiw	r24, 0x08	; 8
}
    1660:	df 91       	pop	r29
    1662:	cf 91       	pop	r28
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0), "chMBInit");

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
  mbp->mb_top = &buf[n];
  chSemInit(&mbp->mb_emptysem, n);
  chSemInit(&mbp->mb_fullsem, 0);
    1664:	0c 94 ef 04 	jmp	0x9de	; 0x9de <chSemInit>

00001668 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized Mailbox object
 *
 * @api
 */
void chMBReset(Mailbox *mbp) {
    1668:	cf 93       	push	r28
    166a:	df 93       	push	r29
    166c:	ec 01       	movw	r28, r24

  chDbgCheck(mbp != NULL, "chMBReset");

  chSysLock();
    166e:	f8 94       	cli
  mbp->mb_wrptr = mbp->mb_rdptr = mbp->mb_buffer;
    1670:	88 81       	ld	r24, Y
    1672:	99 81       	ldd	r25, Y+1	; 0x01
    1674:	9f 83       	std	Y+7, r25	; 0x07
    1676:	8e 83       	std	Y+6, r24	; 0x06
    1678:	9d 83       	std	Y+5, r25	; 0x05
    167a:	8c 83       	std	Y+4, r24	; 0x04
  chSemResetI(&mbp->mb_emptysem, mbp->mb_top - mbp->mb_buffer);
    167c:	6a 81       	ldd	r22, Y+2	; 0x02
    167e:	7b 81       	ldd	r23, Y+3	; 0x03
    1680:	68 1b       	sub	r22, r24
    1682:	79 0b       	sbc	r23, r25
    1684:	75 95       	asr	r23
    1686:	67 95       	ror	r22
    1688:	ce 01       	movw	r24, r28
    168a:	0d 96       	adiw	r24, 0x0d	; 13
    168c:	0e 94 f6 04 	call	0x9ec	; 0x9ec <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, 0);
    1690:	60 e0       	ldi	r22, 0x00	; 0
    1692:	ce 01       	movw	r24, r28
    1694:	08 96       	adiw	r24, 0x08	; 8
    1696:	0e 94 f6 04 	call	0x9ec	; 0x9ec <chSemResetI>
  chSchRescheduleS();
    169a:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  chSysUnlock();
    169e:	78 94       	sei
}
    16a0:	df 91       	pop	r29
    16a2:	cf 91       	pop	r28
    16a4:	08 95       	ret

000016a6 <chMBPostS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(Mailbox *mbp, msg_t msg, systime_t time) {
    16a6:	ef 92       	push	r14
    16a8:	ff 92       	push	r15
    16aa:	0f 93       	push	r16
    16ac:	1f 93       	push	r17
    16ae:	cf 93       	push	r28
    16b0:	df 93       	push	r29
    16b2:	ec 01       	movw	r28, r24
    16b4:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL, "chMBPostS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
    16b6:	ba 01       	movw	r22, r20
    16b8:	0d 96       	adiw	r24, 0x0d	; 13
    16ba:	0e 94 59 05 	call	0xab2	; 0xab2 <chSemWaitTimeoutS>
    16be:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    16c0:	00 97       	sbiw	r24, 0x00	; 0
    16c2:	89 f4       	brne	.+34     	; 0x16e6 <chMBPostS+0x40>
    *mbp->mb_wrptr++ = msg;
    16c4:	ec 81       	ldd	r30, Y+4	; 0x04
    16c6:	fd 81       	ldd	r31, Y+5	; 0x05
    16c8:	e1 92       	st	Z+, r14
    16ca:	f1 92       	st	Z+, r15
    16cc:	fd 83       	std	Y+5, r31	; 0x05
    16ce:	ec 83       	std	Y+4, r30	; 0x04
    if (mbp->mb_wrptr >= mbp->mb_top)
    16d0:	8a 81       	ldd	r24, Y+2	; 0x02
    16d2:	9b 81       	ldd	r25, Y+3	; 0x03
    16d4:	e8 17       	cp	r30, r24
    16d6:	f9 07       	cpc	r31, r25
    16d8:	70 f4       	brcc	.+28     	; 0x16f6 <chMBPostS+0x50>
      mbp->mb_wrptr = mbp->mb_buffer;
    chSemSignalI(&mbp->mb_fullsem);
    16da:	ce 01       	movw	r24, r28
    16dc:	08 96       	adiw	r24, 0x08	; 8
    16de:	0e 94 ae 05 	call	0xb5c	; 0xb5c <chSemSignalI>
    chSchRescheduleS();
    16e2:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  }
  return rdymsg;
}
    16e6:	c8 01       	movw	r24, r16
    16e8:	df 91       	pop	r29
    16ea:	cf 91       	pop	r28
    16ec:	1f 91       	pop	r17
    16ee:	0f 91       	pop	r16
    16f0:	ff 90       	pop	r15
    16f2:	ef 90       	pop	r14
    16f4:	08 95       	ret

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == RDY_OK) {
    *mbp->mb_wrptr++ = msg;
    if (mbp->mb_wrptr >= mbp->mb_top)
      mbp->mb_wrptr = mbp->mb_buffer;
    16f6:	88 81       	ld	r24, Y
    16f8:	99 81       	ldd	r25, Y+1	; 0x01
    16fa:	9d 83       	std	Y+5, r25	; 0x05
    16fc:	8c 83       	std	Y+4, r24	; 0x04
    16fe:	ed cf       	rjmp	.-38     	; 0x16da <chMBPostS+0x34>

00001700 <chMBPost>:
 * @api
 */
msg_t chMBPost(Mailbox *mbp, msg_t msg, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    1700:	f8 94       	cli
  rdymsg = chMBPostS(mbp, msg, time);
    1702:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <chMBPostS>
  chSysUnlock();
    1706:	78 94       	sei
  return rdymsg;
}
    1708:	08 95       	ret

0000170a <chMBPostI>:
 * @retval RDY_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(Mailbox *mbp, msg_t msg) {
    170a:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    170c:	81 89       	ldd	r24, Z+17	; 0x11
    170e:	18 16       	cp	r1, r24
    1710:	d4 f4       	brge	.+52     	; 0x1746 <chMBPostI+0x3c>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
    1712:	81 50       	subi	r24, 0x01	; 1
    1714:	81 8b       	std	Z+17, r24	; 0x11
  *mbp->mb_wrptr++ = msg;
    1716:	a4 81       	ldd	r26, Z+4	; 0x04
    1718:	b5 81       	ldd	r27, Z+5	; 0x05
    171a:	6d 93       	st	X+, r22
    171c:	7d 93       	st	X+, r23
    171e:	b5 83       	std	Z+5, r27	; 0x05
    1720:	a4 83       	std	Z+4, r26	; 0x04
  if (mbp->mb_wrptr >= mbp->mb_top)
    1722:	82 81       	ldd	r24, Z+2	; 0x02
    1724:	93 81       	ldd	r25, Z+3	; 0x03
    1726:	a8 17       	cp	r26, r24
    1728:	b9 07       	cpc	r27, r25
    172a:	40 f4       	brcc	.+16     	; 0x173c <chMBPostI+0x32>
    mbp->mb_wrptr = mbp->mb_buffer;
  chSemSignalI(&mbp->mb_fullsem);
    172c:	cf 01       	movw	r24, r30
    172e:	08 96       	adiw	r24, 0x08	; 8
    1730:	0e 94 ae 05 	call	0xb5c	; 0xb5c <chSemSignalI>
  return RDY_OK;
    1734:	20 e0       	ldi	r18, 0x00	; 0
    1736:	30 e0       	ldi	r19, 0x00	; 0
}
    1738:	c9 01       	movw	r24, r18
    173a:	08 95       	ret
  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top)
    mbp->mb_wrptr = mbp->mb_buffer;
    173c:	80 81       	ld	r24, Z
    173e:	91 81       	ldd	r25, Z+1	; 0x01
    1740:	95 83       	std	Z+5, r25	; 0x05
    1742:	84 83       	std	Z+4, r24	; 0x04
    1744:	f3 cf       	rjmp	.-26     	; 0x172c <chMBPostI+0x22>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
    1746:	2f ef       	ldi	r18, 0xFF	; 255
    1748:	3f ef       	ldi	r19, 0xFF	; 255
    174a:	f6 cf       	rjmp	.-20     	; 0x1738 <chMBPostI+0x2e>

0000174c <chMBPostAheadS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(Mailbox *mbp, msg_t msg, systime_t time) {
    174c:	ef 92       	push	r14
    174e:	ff 92       	push	r15
    1750:	0f 93       	push	r16
    1752:	1f 93       	push	r17
    1754:	cf 93       	push	r28
    1756:	df 93       	push	r29
    1758:	ec 01       	movw	r28, r24
    175a:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL, "chMBPostAheadS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
    175c:	ba 01       	movw	r22, r20
    175e:	0d 96       	adiw	r24, 0x0d	; 13
    1760:	0e 94 59 05 	call	0xab2	; 0xab2 <chSemWaitTimeoutS>
    1764:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    1766:	00 97       	sbiw	r24, 0x00	; 0
    1768:	91 f4       	brne	.+36     	; 0x178e <chMBPostAheadS+0x42>
    if (--mbp->mb_rdptr < mbp->mb_buffer)
    176a:	ee 81       	ldd	r30, Y+6	; 0x06
    176c:	ff 81       	ldd	r31, Y+7	; 0x07
    176e:	32 97       	sbiw	r30, 0x02	; 2
    1770:	ff 83       	std	Y+7, r31	; 0x07
    1772:	ee 83       	std	Y+6, r30	; 0x06
    1774:	88 81       	ld	r24, Y
    1776:	99 81       	ldd	r25, Y+1	; 0x01
    1778:	e8 17       	cp	r30, r24
    177a:	f9 07       	cpc	r31, r25
    177c:	80 f0       	brcs	.+32     	; 0x179e <chMBPostAheadS+0x52>
      mbp->mb_rdptr = mbp->mb_top - 1;
    *mbp->mb_rdptr = msg;
    177e:	f1 82       	std	Z+1, r15	; 0x01
    1780:	e0 82       	st	Z, r14
    chSemSignalI(&mbp->mb_fullsem);
    1782:	ce 01       	movw	r24, r28
    1784:	08 96       	adiw	r24, 0x08	; 8
    1786:	0e 94 ae 05 	call	0xb5c	; 0xb5c <chSemSignalI>
    chSchRescheduleS();
    178a:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  }
  return rdymsg;
}
    178e:	c8 01       	movw	r24, r16
    1790:	df 91       	pop	r29
    1792:	cf 91       	pop	r28
    1794:	1f 91       	pop	r17
    1796:	0f 91       	pop	r16
    1798:	ff 90       	pop	r15
    179a:	ef 90       	pop	r14
    179c:	08 95       	ret
  chDbgCheck(mbp != NULL, "chMBPostAheadS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == RDY_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer)
      mbp->mb_rdptr = mbp->mb_top - 1;
    179e:	ea 81       	ldd	r30, Y+2	; 0x02
    17a0:	fb 81       	ldd	r31, Y+3	; 0x03
    17a2:	32 97       	sbiw	r30, 0x02	; 2
    17a4:	ff 83       	std	Y+7, r31	; 0x07
    17a6:	ee 83       	std	Y+6, r30	; 0x06
    17a8:	ea cf       	rjmp	.-44     	; 0x177e <chMBPostAheadS+0x32>

000017aa <chMBPostAhead>:
 * @api
 */
msg_t chMBPostAhead(Mailbox *mbp, msg_t msg, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    17aa:	f8 94       	cli
  rdymsg = chMBPostAheadS(mbp, msg, time);
    17ac:	0e 94 a6 0b 	call	0x174c	; 0x174c <chMBPostAheadS>
  chSysUnlock();
    17b0:	78 94       	sei
  return rdymsg;
}
    17b2:	08 95       	ret

000017b4 <chMBPostAheadI>:
 * @retval RDY_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(Mailbox *mbp, msg_t msg) {
    17b4:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostAheadI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    17b6:	81 89       	ldd	r24, Z+17	; 0x11
    17b8:	18 16       	cp	r1, r24
    17ba:	e4 f4       	brge	.+56     	; 0x17f4 <chMBPostAheadI+0x40>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
    17bc:	81 50       	subi	r24, 0x01	; 1
    17be:	81 8b       	std	Z+17, r24	; 0x11
  if (--mbp->mb_rdptr < mbp->mb_buffer)
    17c0:	a6 81       	ldd	r26, Z+6	; 0x06
    17c2:	b7 81       	ldd	r27, Z+7	; 0x07
    17c4:	12 97       	sbiw	r26, 0x02	; 2
    17c6:	b7 83       	std	Z+7, r27	; 0x07
    17c8:	a6 83       	std	Z+6, r26	; 0x06
    17ca:	80 81       	ld	r24, Z
    17cc:	91 81       	ldd	r25, Z+1	; 0x01
    17ce:	a8 17       	cp	r26, r24
    17d0:	b9 07       	cpc	r27, r25
    17d2:	50 f0       	brcs	.+20     	; 0x17e8 <chMBPostAheadI+0x34>
    mbp->mb_rdptr = mbp->mb_top - 1;
  *mbp->mb_rdptr = msg;
    17d4:	6d 93       	st	X+, r22
    17d6:	7c 93       	st	X, r23
  chSemSignalI(&mbp->mb_fullsem);
    17d8:	cf 01       	movw	r24, r30
    17da:	08 96       	adiw	r24, 0x08	; 8
    17dc:	0e 94 ae 05 	call	0xb5c	; 0xb5c <chSemSignalI>
  return RDY_OK;
    17e0:	20 e0       	ldi	r18, 0x00	; 0
    17e2:	30 e0       	ldi	r19, 0x00	; 0
}
    17e4:	c9 01       	movw	r24, r18
    17e6:	08 95       	ret

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer)
    mbp->mb_rdptr = mbp->mb_top - 1;
    17e8:	a2 81       	ldd	r26, Z+2	; 0x02
    17ea:	b3 81       	ldd	r27, Z+3	; 0x03
    17ec:	12 97       	sbiw	r26, 0x02	; 2
    17ee:	b7 83       	std	Z+7, r27	; 0x07
    17f0:	a6 83       	std	Z+6, r26	; 0x06
    17f2:	f0 cf       	rjmp	.-32     	; 0x17d4 <chMBPostAheadI+0x20>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostAheadI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
    17f4:	2f ef       	ldi	r18, 0xFF	; 255
    17f6:	3f ef       	ldi	r19, 0xFF	; 255
    17f8:	f5 cf       	rjmp	.-22     	; 0x17e4 <chMBPostAheadI+0x30>

000017fa <chMBFetchS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(Mailbox *mbp, msg_t *msgp, systime_t time) {
    17fa:	ef 92       	push	r14
    17fc:	ff 92       	push	r15
    17fe:	0f 93       	push	r16
    1800:	1f 93       	push	r17
    1802:	cf 93       	push	r28
    1804:	df 93       	push	r29
    1806:	ec 01       	movw	r28, r24
    1808:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
    180a:	ba 01       	movw	r22, r20
    180c:	08 96       	adiw	r24, 0x08	; 8
    180e:	0e 94 59 05 	call	0xab2	; 0xab2 <chSemWaitTimeoutS>
    1812:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    1814:	00 97       	sbiw	r24, 0x00	; 0
    1816:	a1 f4       	brne	.+40     	; 0x1840 <chMBFetchS+0x46>
    *msgp = *mbp->mb_rdptr++;
    1818:	ee 81       	ldd	r30, Y+6	; 0x06
    181a:	ff 81       	ldd	r31, Y+7	; 0x07
    181c:	81 91       	ld	r24, Z+
    181e:	91 91       	ld	r25, Z+
    1820:	d7 01       	movw	r26, r14
    1822:	8d 93       	st	X+, r24
    1824:	9c 93       	st	X, r25
    1826:	ff 83       	std	Y+7, r31	; 0x07
    1828:	ee 83       	std	Y+6, r30	; 0x06
    if (mbp->mb_rdptr >= mbp->mb_top)
    182a:	8a 81       	ldd	r24, Y+2	; 0x02
    182c:	9b 81       	ldd	r25, Y+3	; 0x03
    182e:	e8 17       	cp	r30, r24
    1830:	f9 07       	cpc	r31, r25
    1832:	70 f4       	brcc	.+28     	; 0x1850 <chMBFetchS+0x56>
      mbp->mb_rdptr = mbp->mb_buffer;
    chSemSignalI(&mbp->mb_emptysem);
    1834:	ce 01       	movw	r24, r28
    1836:	0d 96       	adiw	r24, 0x0d	; 13
    1838:	0e 94 ae 05 	call	0xb5c	; 0xb5c <chSemSignalI>
    chSchRescheduleS();
    183c:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  }
  return rdymsg;
}
    1840:	c8 01       	movw	r24, r16
    1842:	df 91       	pop	r29
    1844:	cf 91       	pop	r28
    1846:	1f 91       	pop	r17
    1848:	0f 91       	pop	r16
    184a:	ff 90       	pop	r15
    184c:	ef 90       	pop	r14
    184e:	08 95       	ret

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == RDY_OK) {
    *msgp = *mbp->mb_rdptr++;
    if (mbp->mb_rdptr >= mbp->mb_top)
      mbp->mb_rdptr = mbp->mb_buffer;
    1850:	88 81       	ld	r24, Y
    1852:	99 81       	ldd	r25, Y+1	; 0x01
    1854:	9f 83       	std	Y+7, r25	; 0x07
    1856:	8e 83       	std	Y+6, r24	; 0x06
    1858:	ed cf       	rjmp	.-38     	; 0x1834 <chMBFetchS+0x3a>

0000185a <chMBFetch>:
 * @api
 */
msg_t chMBFetch(Mailbox *mbp, msg_t *msgp, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    185a:	f8 94       	cli
  rdymsg = chMBFetchS(mbp, msgp, time);
    185c:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <chMBFetchS>
  chSysUnlock();
    1860:	78 94       	sei
  return rdymsg;
}
    1862:	08 95       	ret

00001864 <chMBFetchI>:
 * @retval RDY_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(Mailbox *mbp, msg_t *msgp) {
    1864:	cf 93       	push	r28
    1866:	df 93       	push	r29
    1868:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchI");

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    186a:	84 85       	ldd	r24, Z+12	; 0x0c
    186c:	18 16       	cp	r1, r24
    186e:	fc f4       	brge	.+62     	; 0x18ae <chMBFetchI+0x4a>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_fullsem);
    1870:	81 50       	subi	r24, 0x01	; 1
    1872:	84 87       	std	Z+12, r24	; 0x0c
  *msgp = *mbp->mb_rdptr++;
    1874:	a6 81       	ldd	r26, Z+6	; 0x06
    1876:	b7 81       	ldd	r27, Z+7	; 0x07
    1878:	8d 91       	ld	r24, X+
    187a:	9d 91       	ld	r25, X+
    187c:	eb 01       	movw	r28, r22
    187e:	99 83       	std	Y+1, r25	; 0x01
    1880:	88 83       	st	Y, r24
    1882:	b7 83       	std	Z+7, r27	; 0x07
    1884:	a6 83       	std	Z+6, r26	; 0x06
  if (mbp->mb_rdptr >= mbp->mb_top)
    1886:	82 81       	ldd	r24, Z+2	; 0x02
    1888:	93 81       	ldd	r25, Z+3	; 0x03
    188a:	a8 17       	cp	r26, r24
    188c:	b9 07       	cpc	r27, r25
    188e:	50 f4       	brcc	.+20     	; 0x18a4 <chMBFetchI+0x40>
    mbp->mb_rdptr = mbp->mb_buffer;
  chSemSignalI(&mbp->mb_emptysem);
    1890:	cf 01       	movw	r24, r30
    1892:	0d 96       	adiw	r24, 0x0d	; 13
    1894:	0e 94 ae 05 	call	0xb5c	; 0xb5c <chSemSignalI>
  return RDY_OK;
    1898:	20 e0       	ldi	r18, 0x00	; 0
    189a:	30 e0       	ldi	r19, 0x00	; 0
}
    189c:	c9 01       	movw	r24, r18
    189e:	df 91       	pop	r29
    18a0:	cf 91       	pop	r28
    18a2:	08 95       	ret
  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top)
    mbp->mb_rdptr = mbp->mb_buffer;
    18a4:	80 81       	ld	r24, Z
    18a6:	91 81       	ldd	r25, Z+1	; 0x01
    18a8:	97 83       	std	Z+7, r25	; 0x07
    18aa:	86 83       	std	Z+6, r24	; 0x06
    18ac:	f1 cf       	rjmp	.-30     	; 0x1890 <chMBFetchI+0x2c>

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchI");

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    return RDY_TIMEOUT;
    18ae:	2f ef       	ldi	r18, 0xFF	; 255
    18b0:	3f ef       	ldi	r19, 0xFF	; 255
    18b2:	f4 cf       	rjmp	.-24     	; 0x189c <chMBFetchI+0x38>

000018b4 <qwait>:
 *                      released from threads queue.
 * @retval Q_OK         is the normal exit, thread signaled.
 * @retval Q_RESET      if the queue has been reset.
 * @retval Q_TIMEOUT    if the queue operation timed out.
 */
static msg_t qwait(GenericQueue *qp, systime_t time) {
    18b4:	cf 93       	push	r28
    18b6:	df 93       	push	r29

  if (TIME_IMMEDIATE == time)
    18b8:	61 15       	cp	r22, r1
    18ba:	71 05       	cpc	r23, r1
    18bc:	b1 f0       	breq	.+44     	; 0x18ea <qwait+0x36>
    return Q_TIMEOUT;
  currp->p_u.wtobjp = qp;
    18be:	e0 91 3a 02 	lds	r30, 0x023A
    18c2:	f0 91 3b 02 	lds	r31, 0x023B
    18c6:	93 8b       	std	Z+19, r25	; 0x13
    18c8:	82 8b       	std	Z+18, r24	; 0x12
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
    18ca:	91 83       	std	Z+1, r25	; 0x01
    18cc:	80 83       	st	Z, r24
  tp->p_prev = tqp->p_prev;
    18ce:	ec 01       	movw	r28, r24
    18d0:	aa 81       	ldd	r26, Y+2	; 0x02
    18d2:	bb 81       	ldd	r27, Y+3	; 0x03
    18d4:	b3 83       	std	Z+3, r27	; 0x03
    18d6:	a2 83       	std	Z+2, r26	; 0x02
  tp->p_prev->p_next = tqp->p_prev = tp;
    18d8:	fb 83       	std	Y+3, r31	; 0x03
    18da:	ea 83       	std	Y+2, r30	; 0x02
    18dc:	ed 93       	st	X+, r30
    18de:	fc 93       	st	X, r31
  queue_insert(currp, &qp->q_waiting);
  return chSchGoSleepTimeoutS(THD_STATE_WTQUEUE, time);
    18e0:	8d e0       	ldi	r24, 0x0D	; 13
}
    18e2:	df 91       	pop	r29
    18e4:	cf 91       	pop	r28

  if (TIME_IMMEDIATE == time)
    return Q_TIMEOUT;
  currp->p_u.wtobjp = qp;
  queue_insert(currp, &qp->q_waiting);
  return chSchGoSleepTimeoutS(THD_STATE_WTQUEUE, time);
    18e6:	0c 94 77 02 	jmp	0x4ee	; 0x4ee <chSchGoSleepTimeoutS>
}
    18ea:	8f ef       	ldi	r24, 0xFF	; 255
    18ec:	9f ef       	ldi	r25, 0xFF	; 255
    18ee:	df 91       	pop	r29
    18f0:	cf 91       	pop	r28
    18f2:	08 95       	ret

000018f4 <chIQInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQInit(InputQueue *iqp, uint8_t *bp, size_t size, qnotify_t infy,
              void *link) {
    18f4:	0f 93       	push	r16
    18f6:	1f 93       	push	r17
    18f8:	fc 01       	movw	r30, r24

  queue_init(&iqp->q_waiting);
    18fa:	82 83       	std	Z+2, r24	; 0x02
    18fc:	f3 83       	std	Z+3, r31	; 0x03
    18fe:	80 83       	st	Z, r24
    1900:	f1 83       	std	Z+1, r31	; 0x01
  iqp->q_counter = 0;
    1902:	15 82       	std	Z+5, r1	; 0x05
    1904:	14 82       	std	Z+4, r1	; 0x04
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
    1906:	73 87       	std	Z+11, r23	; 0x0b
    1908:	62 87       	std	Z+10, r22	; 0x0a
    190a:	75 87       	std	Z+13, r23	; 0x0d
    190c:	64 87       	std	Z+12, r22	; 0x0c
    190e:	77 83       	std	Z+7, r23	; 0x07
    1910:	66 83       	std	Z+6, r22	; 0x06
  iqp->q_top = bp + size;
    1912:	46 0f       	add	r20, r22
    1914:	57 1f       	adc	r21, r23
    1916:	51 87       	std	Z+9, r21	; 0x09
    1918:	40 87       	std	Z+8, r20	; 0x08
  iqp->q_notify = infy;
    191a:	37 87       	std	Z+15, r19	; 0x0f
    191c:	26 87       	std	Z+14, r18	; 0x0e
  iqp->q_link = link;
    191e:	11 8b       	std	Z+17, r17	; 0x11
    1920:	00 8b       	std	Z+16, r16	; 0x10
}
    1922:	1f 91       	pop	r17
    1924:	0f 91       	pop	r16
    1926:	08 95       	ret

00001928 <chIQResetI>:
 *
 * @param[in] iqp       pointer to an @p InputQueue structure
 *
 * @iclass
 */
void chIQResetI(InputQueue *iqp) {
    1928:	0f 93       	push	r16
    192a:	1f 93       	push	r17
    192c:	cf 93       	push	r28
    192e:	df 93       	push	r29
    1930:	ec 01       	movw	r28, r24

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
    1932:	8e 81       	ldd	r24, Y+6	; 0x06
    1934:	9f 81       	ldd	r25, Y+7	; 0x07
    1936:	9b 87       	std	Y+11, r25	; 0x0b
    1938:	8a 87       	std	Y+10, r24	; 0x0a
    193a:	9d 87       	std	Y+13, r25	; 0x0d
    193c:	8c 87       	std	Y+12, r24	; 0x0c
  iqp->q_counter = 0;
    193e:	1d 82       	std	Y+5, r1	; 0x05
    1940:	1c 82       	std	Y+4, r1	; 0x04
  while (notempty(&iqp->q_waiting))
    1942:	88 81       	ld	r24, Y
    1944:	99 81       	ldd	r25, Y+1	; 0x01
    1946:	8c 17       	cp	r24, r28
    1948:	9d 07       	cpc	r25, r29
    194a:	99 f0       	breq	.+38     	; 0x1972 <chIQResetI+0x4a>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_RESET;
    194c:	0e ef       	ldi	r16, 0xFE	; 254
    194e:	1f ef       	ldi	r17, 0xFF	; 255
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    1950:	dc 01       	movw	r26, r24
    1952:	ed 91       	ld	r30, X+
    1954:	fc 91       	ld	r31, X
    1956:	f9 83       	std	Y+1, r31	; 0x01
    1958:	e8 83       	st	Y, r30
    195a:	d3 83       	std	Z+3, r29	; 0x03
    195c:	c2 83       	std	Z+2, r28	; 0x02
    195e:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
    1962:	fc 01       	movw	r30, r24
    1964:	13 8b       	std	Z+19, r17	; 0x13
    1966:	02 8b       	std	Z+18, r16	; 0x12

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
  while (notempty(&iqp->q_waiting))
    1968:	88 81       	ld	r24, Y
    196a:	99 81       	ldd	r25, Y+1	; 0x01
    196c:	8c 17       	cp	r24, r28
    196e:	9d 07       	cpc	r25, r29
    1970:	79 f7       	brne	.-34     	; 0x1950 <chIQResetI+0x28>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_RESET;
}
    1972:	df 91       	pop	r29
    1974:	cf 91       	pop	r28
    1976:	1f 91       	pop	r17
    1978:	0f 91       	pop	r16
    197a:	08 95       	ret

0000197c <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(InputQueue *iqp, uint8_t b) {
    197c:	cf 93       	push	r28
    197e:	df 93       	push	r29
    1980:	fc 01       	movw	r30, r24

  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
    1982:	a2 85       	ldd	r26, Z+10	; 0x0a
    1984:	b3 85       	ldd	r27, Z+11	; 0x0b
    1986:	84 85       	ldd	r24, Z+12	; 0x0c
    1988:	95 85       	ldd	r25, Z+13	; 0x0d
    198a:	a8 17       	cp	r26, r24
    198c:	b9 07       	cpc	r27, r25
    198e:	a9 f1       	breq	.+106    	; 0x19fa <chIQPutI+0x7e>
    1990:	84 81       	ldd	r24, Z+4	; 0x04
    1992:	95 81       	ldd	r25, Z+5	; 0x05
    return Q_FULL;

  iqp->q_counter++;
    1994:	01 96       	adiw	r24, 0x01	; 1
    1996:	95 83       	std	Z+5, r25	; 0x05
    1998:	84 83       	std	Z+4, r24	; 0x04
  *iqp->q_wrptr++ = b;
    199a:	6d 93       	st	X+, r22
    199c:	b3 87       	std	Z+11, r27	; 0x0b
    199e:	a2 87       	std	Z+10, r26	; 0x0a
  if (iqp->q_wrptr >= iqp->q_top)
    19a0:	80 85       	ldd	r24, Z+8	; 0x08
    19a2:	91 85       	ldd	r25, Z+9	; 0x09
    19a4:	a8 17       	cp	r26, r24
    19a6:	b9 07       	cpc	r27, r25
    19a8:	c8 f4       	brcc	.+50     	; 0x19dc <chIQPutI+0x60>
    iqp->q_wrptr = iqp->q_buffer;

  if (notempty(&iqp->q_waiting))
    19aa:	80 81       	ld	r24, Z
    19ac:	91 81       	ldd	r25, Z+1	; 0x01
    19ae:	8e 17       	cp	r24, r30
    19b0:	9f 07       	cpc	r25, r31
    19b2:	e9 f0       	breq	.+58     	; 0x19ee <chIQPutI+0x72>
    19b4:	ec 01       	movw	r28, r24
    19b6:	a8 81       	ld	r26, Y
    19b8:	b9 81       	ldd	r27, Y+1	; 0x01
    19ba:	b1 83       	std	Z+1, r27	; 0x01
    19bc:	a0 83       	st	Z, r26
    19be:	13 96       	adiw	r26, 0x03	; 3
    19c0:	fc 93       	st	X, r31
    19c2:	ee 93       	st	-X, r30
    19c4:	12 97       	sbiw	r26, 0x02	; 2
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;
    19c6:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
    19ca:	fc 01       	movw	r30, r24
    19cc:	13 8a       	std	Z+19, r1	; 0x13
    19ce:	12 8a       	std	Z+18, r1	; 0x12

  return Q_OK;
    19d0:	20 e0       	ldi	r18, 0x00	; 0
    19d2:	30 e0       	ldi	r19, 0x00	; 0
}
    19d4:	c9 01       	movw	r24, r18
    19d6:	df 91       	pop	r29
    19d8:	cf 91       	pop	r28
    19da:	08 95       	ret
    return Q_FULL;

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top)
    iqp->q_wrptr = iqp->q_buffer;
    19dc:	86 81       	ldd	r24, Z+6	; 0x06
    19de:	97 81       	ldd	r25, Z+7	; 0x07
    19e0:	93 87       	std	Z+11, r25	; 0x0b
    19e2:	82 87       	std	Z+10, r24	; 0x0a

  if (notempty(&iqp->q_waiting))
    19e4:	80 81       	ld	r24, Z
    19e6:	91 81       	ldd	r25, Z+1	; 0x01
    19e8:	8e 17       	cp	r24, r30
    19ea:	9f 07       	cpc	r25, r31
    19ec:	19 f7       	brne	.-58     	; 0x19b4 <chIQPutI+0x38>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;

  return Q_OK;
    19ee:	20 e0       	ldi	r18, 0x00	; 0
    19f0:	30 e0       	ldi	r19, 0x00	; 0
}
    19f2:	c9 01       	movw	r24, r18
    19f4:	df 91       	pop	r29
    19f6:	cf 91       	pop	r28
    19f8:	08 95       	ret
 */
msg_t chIQPutI(InputQueue *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
    19fa:	84 81       	ldd	r24, Z+4	; 0x04
    19fc:	95 81       	ldd	r25, Z+5	; 0x05
    19fe:	89 2b       	or	r24, r25
    1a00:	19 f4       	brne	.+6      	; 0x1a08 <chIQPutI+0x8c>
    1a02:	80 e0       	ldi	r24, 0x00	; 0
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	c6 cf       	rjmp	.-116    	; 0x1994 <chIQPutI+0x18>
    return Q_FULL;
    1a08:	2c ef       	ldi	r18, 0xFC	; 252
    1a0a:	3f ef       	ldi	r19, 0xFF	; 255
    1a0c:	e3 cf       	rjmp	.-58     	; 0x19d4 <chIQPutI+0x58>

00001a0e <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(InputQueue *iqp, systime_t time) {
    1a0e:	0f 93       	push	r16
    1a10:	1f 93       	push	r17
    1a12:	cf 93       	push	r28
    1a14:	df 93       	push	r29
    1a16:	ec 01       	movw	r28, r24
    1a18:	8b 01       	movw	r16, r22
  uint8_t b;

  chSysLock();
    1a1a:	f8 94       	cli
  if (iqp->q_notify)
    1a1c:	ee 85       	ldd	r30, Y+14	; 0x0e
    1a1e:	ff 85       	ldd	r31, Y+15	; 0x0f
    1a20:	30 97       	sbiw	r30, 0x00	; 0
    1a22:	09 f0       	breq	.+2      	; 0x1a26 <chIQGetTimeout+0x18>
    iqp->q_notify(iqp);
    1a24:	09 95       	icall

  while (chIQIsEmptyI(iqp)) {
    1a26:	8c 81       	ldd	r24, Y+4	; 0x04
    1a28:	9d 81       	ldd	r25, Y+5	; 0x05
    1a2a:	00 97       	sbiw	r24, 0x00	; 0
    1a2c:	71 f4       	brne	.+28     	; 0x1a4a <chIQGetTimeout+0x3c>
    msg_t msg;
    if ((msg = qwait((GenericQueue *)iqp, time)) < Q_OK) {
    1a2e:	b8 01       	movw	r22, r16
    1a30:	ce 01       	movw	r24, r28
    1a32:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <qwait>
    1a36:	9c 01       	movw	r18, r24
    1a38:	97 ff       	sbrs	r25, 7
    1a3a:	f5 cf       	rjmp	.-22     	; 0x1a26 <chIQGetTimeout+0x18>
      chSysUnlock();
    1a3c:	78 94       	sei
  if (iqp->q_rdptr >= iqp->q_top)
    iqp->q_rdptr = iqp->q_buffer;

  chSysUnlock();
  return b;
}
    1a3e:	c9 01       	movw	r24, r18
    1a40:	df 91       	pop	r29
    1a42:	cf 91       	pop	r28
    1a44:	1f 91       	pop	r17
    1a46:	0f 91       	pop	r16
    1a48:	08 95       	ret
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
    1a4a:	01 97       	sbiw	r24, 0x01	; 1
    1a4c:	9d 83       	std	Y+5, r25	; 0x05
    1a4e:	8c 83       	std	Y+4, r24	; 0x04
  b = *iqp->q_rdptr++;
    1a50:	ec 85       	ldd	r30, Y+12	; 0x0c
    1a52:	fd 85       	ldd	r31, Y+13	; 0x0d
    1a54:	21 91       	ld	r18, Z+
    1a56:	fd 87       	std	Y+13, r31	; 0x0d
    1a58:	ec 87       	std	Y+12, r30	; 0x0c
  if (iqp->q_rdptr >= iqp->q_top)
    1a5a:	88 85       	ldd	r24, Y+8	; 0x08
    1a5c:	99 85       	ldd	r25, Y+9	; 0x09
    1a5e:	e8 17       	cp	r30, r24
    1a60:	f9 07       	cpc	r31, r25
    1a62:	20 f0       	brcs	.+8      	; 0x1a6c <chIQGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
    1a64:	8e 81       	ldd	r24, Y+6	; 0x06
    1a66:	9f 81       	ldd	r25, Y+7	; 0x07
    1a68:	9d 87       	std	Y+13, r25	; 0x0d
    1a6a:	8c 87       	std	Y+12, r24	; 0x0c

  chSysUnlock();
    1a6c:	78 94       	sei
  return b;
    1a6e:	30 e0       	ldi	r19, 0x00	; 0
}
    1a70:	c9 01       	movw	r24, r18
    1a72:	df 91       	pop	r29
    1a74:	cf 91       	pop	r28
    1a76:	1f 91       	pop	r17
    1a78:	0f 91       	pop	r16
    1a7a:	08 95       	ret

00001a7c <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
    1a7c:	8f 92       	push	r8
    1a7e:	9f 92       	push	r9
    1a80:	af 92       	push	r10
    1a82:	bf 92       	push	r11
    1a84:	cf 92       	push	r12
    1a86:	df 92       	push	r13
    1a88:	ef 92       	push	r14
    1a8a:	ff 92       	push	r15
    1a8c:	0f 93       	push	r16
    1a8e:	1f 93       	push	r17
    1a90:	cf 93       	push	r28
    1a92:	df 93       	push	r29
    1a94:	ec 01       	movw	r28, r24
    1a96:	5b 01       	movw	r10, r22
    1a98:	4a 01       	movw	r8, r20
    1a9a:	89 01       	movw	r16, r18
  qnotify_t nfy = iqp->q_notify;
    1a9c:	ce 84       	ldd	r12, Y+14	; 0x0e
    1a9e:	df 84       	ldd	r13, Y+15	; 0x0f
  size_t r = 0;

  chDbgCheck(n > 0, "chIQReadTimeout");

  chSysLock();
    1aa0:	f8 94       	cli
 * @api
 */
size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
    1aa2:	e1 2c       	mov	r14, r1
    1aa4:	f1 2c       	mov	r15, r1

  chDbgCheck(n > 0, "chIQReadTimeout");

  chSysLock();
  while (TRUE) {
    if (nfy)
    1aa6:	c1 14       	cp	r12, r1
    1aa8:	d1 04       	cpc	r13, r1
    1aaa:	19 f0       	breq	.+6      	; 0x1ab2 <chIQReadTimeout+0x36>
      nfy(iqp);
    1aac:	ce 01       	movw	r24, r28
    1aae:	f6 01       	movw	r30, r12
    1ab0:	09 95       	icall

    while (chIQIsEmptyI(iqp)) {
    1ab2:	8c 81       	ldd	r24, Y+4	; 0x04
    1ab4:	9d 81       	ldd	r25, Y+5	; 0x05
    1ab6:	00 97       	sbiw	r24, 0x00	; 0
    1ab8:	a9 f4       	brne	.+42     	; 0x1ae4 <chIQReadTimeout+0x68>
      if (qwait((GenericQueue *)iqp, time) != Q_OK) {
    1aba:	b8 01       	movw	r22, r16
    1abc:	ce 01       	movw	r24, r28
    1abe:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <qwait>
    1ac2:	89 2b       	or	r24, r25
    1ac4:	b1 f3       	breq	.-20     	; 0x1ab2 <chIQReadTimeout+0x36>
        chSysUnlock();
    1ac6:	78 94       	sei
    if (--n == 0)
      return r;

    chSysLock();
  }
}
    1ac8:	c7 01       	movw	r24, r14
    1aca:	df 91       	pop	r29
    1acc:	cf 91       	pop	r28
    1ace:	1f 91       	pop	r17
    1ad0:	0f 91       	pop	r16
    1ad2:	ff 90       	pop	r15
    1ad4:	ef 90       	pop	r14
    1ad6:	df 90       	pop	r13
    1ad8:	cf 90       	pop	r12
    1ada:	bf 90       	pop	r11
    1adc:	af 90       	pop	r10
    1ade:	9f 90       	pop	r9
    1ae0:	8f 90       	pop	r8
    1ae2:	08 95       	ret
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
    1ae4:	01 97       	sbiw	r24, 0x01	; 1
    1ae6:	9d 83       	std	Y+5, r25	; 0x05
    1ae8:	8c 83       	std	Y+4, r24	; 0x04
    *bp++ = *iqp->q_rdptr++;
    1aea:	ec 85       	ldd	r30, Y+12	; 0x0c
    1aec:	fd 85       	ldd	r31, Y+13	; 0x0d
    1aee:	81 91       	ld	r24, Z+
    1af0:	d5 01       	movw	r26, r10
    1af2:	8d 93       	st	X+, r24
    1af4:	5d 01       	movw	r10, r26
    1af6:	fd 87       	std	Y+13, r31	; 0x0d
    1af8:	ec 87       	std	Y+12, r30	; 0x0c
    if (iqp->q_rdptr >= iqp->q_top)
    1afa:	88 85       	ldd	r24, Y+8	; 0x08
    1afc:	99 85       	ldd	r25, Y+9	; 0x09
    1afe:	e8 17       	cp	r30, r24
    1b00:	f9 07       	cpc	r31, r25
    1b02:	48 f4       	brcc	.+18     	; 0x1b16 <chIQReadTimeout+0x9a>
      iqp->q_rdptr = iqp->q_buffer;

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    1b04:	78 94       	sei
    r++;
    1b06:	bf ef       	ldi	r27, 0xFF	; 255
    1b08:	eb 1a       	sub	r14, r27
    1b0a:	fb 0a       	sbc	r15, r27
    if (--n == 0)
    1b0c:	8e 14       	cp	r8, r14
    1b0e:	9f 04       	cpc	r9, r15
    1b10:	d9 f2       	breq	.-74     	; 0x1ac8 <chIQReadTimeout+0x4c>
      return r;

    chSysLock();
    1b12:	f8 94       	cli
  }
    1b14:	c8 cf       	rjmp	.-112    	; 0x1aa6 <chIQReadTimeout+0x2a>
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
    if (iqp->q_rdptr >= iqp->q_top)
      iqp->q_rdptr = iqp->q_buffer;
    1b16:	8e 81       	ldd	r24, Y+6	; 0x06
    1b18:	9f 81       	ldd	r25, Y+7	; 0x07
    1b1a:	9d 87       	std	Y+13, r25	; 0x0d
    1b1c:	8c 87       	std	Y+12, r24	; 0x0c
    1b1e:	f2 cf       	rjmp	.-28     	; 0x1b04 <chIQReadTimeout+0x88>

00001b20 <chOQInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQInit(OutputQueue *oqp, uint8_t *bp, size_t size, qnotify_t onfy,
              void *link) {
    1b20:	0f 93       	push	r16
    1b22:	1f 93       	push	r17
    1b24:	fc 01       	movw	r30, r24

  queue_init(&oqp->q_waiting);
    1b26:	82 83       	std	Z+2, r24	; 0x02
    1b28:	f3 83       	std	Z+3, r31	; 0x03
    1b2a:	80 83       	st	Z, r24
    1b2c:	f1 83       	std	Z+1, r31	; 0x01
  oqp->q_counter = size;
    1b2e:	55 83       	std	Z+5, r21	; 0x05
    1b30:	44 83       	std	Z+4, r20	; 0x04
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
    1b32:	73 87       	std	Z+11, r23	; 0x0b
    1b34:	62 87       	std	Z+10, r22	; 0x0a
    1b36:	75 87       	std	Z+13, r23	; 0x0d
    1b38:	64 87       	std	Z+12, r22	; 0x0c
    1b3a:	77 83       	std	Z+7, r23	; 0x07
    1b3c:	66 83       	std	Z+6, r22	; 0x06
  oqp->q_top = bp + size;
    1b3e:	64 0f       	add	r22, r20
    1b40:	75 1f       	adc	r23, r21
    1b42:	71 87       	std	Z+9, r23	; 0x09
    1b44:	60 87       	std	Z+8, r22	; 0x08
  oqp->q_notify = onfy;
    1b46:	37 87       	std	Z+15, r19	; 0x0f
    1b48:	26 87       	std	Z+14, r18	; 0x0e
  oqp->q_link = link;
    1b4a:	11 8b       	std	Z+17, r17	; 0x11
    1b4c:	00 8b       	std	Z+16, r16	; 0x10
}
    1b4e:	1f 91       	pop	r17
    1b50:	0f 91       	pop	r16
    1b52:	08 95       	ret

00001b54 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p OutputQueue structure
 *
 * @iclass
 */
void chOQResetI(OutputQueue *oqp) {
    1b54:	0f 93       	push	r16
    1b56:	1f 93       	push	r17
    1b58:	cf 93       	push	r28
    1b5a:	df 93       	push	r29
    1b5c:	ec 01       	movw	r28, r24

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
    1b5e:	2e 81       	ldd	r18, Y+6	; 0x06
    1b60:	3f 81       	ldd	r19, Y+7	; 0x07
    1b62:	3b 87       	std	Y+11, r19	; 0x0b
    1b64:	2a 87       	std	Y+10, r18	; 0x0a
    1b66:	3d 87       	std	Y+13, r19	; 0x0d
    1b68:	2c 87       	std	Y+12, r18	; 0x0c
  oqp->q_counter = chQSizeI(oqp);
    1b6a:	88 85       	ldd	r24, Y+8	; 0x08
    1b6c:	99 85       	ldd	r25, Y+9	; 0x09
    1b6e:	82 1b       	sub	r24, r18
    1b70:	93 0b       	sbc	r25, r19
    1b72:	9d 83       	std	Y+5, r25	; 0x05
    1b74:	8c 83       	std	Y+4, r24	; 0x04
  while (notempty(&oqp->q_waiting))
    1b76:	88 81       	ld	r24, Y
    1b78:	99 81       	ldd	r25, Y+1	; 0x01
    1b7a:	8c 17       	cp	r24, r28
    1b7c:	9d 07       	cpc	r25, r29
    1b7e:	99 f0       	breq	.+38     	; 0x1ba6 <chOQResetI+0x52>
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_RESET;
    1b80:	0e ef       	ldi	r16, 0xFE	; 254
    1b82:	1f ef       	ldi	r17, 0xFF	; 255
    1b84:	dc 01       	movw	r26, r24
    1b86:	ed 91       	ld	r30, X+
    1b88:	fc 91       	ld	r31, X
    1b8a:	f9 83       	std	Y+1, r31	; 0x01
    1b8c:	e8 83       	st	Y, r30
    1b8e:	d3 83       	std	Z+3, r29	; 0x03
    1b90:	c2 83       	std	Z+2, r28	; 0x02
    1b92:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
    1b96:	fc 01       	movw	r30, r24
    1b98:	13 8b       	std	Z+19, r17	; 0x13
    1b9a:	02 8b       	std	Z+18, r16	; 0x12

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeI(oqp);
  while (notempty(&oqp->q_waiting))
    1b9c:	88 81       	ld	r24, Y
    1b9e:	99 81       	ldd	r25, Y+1	; 0x01
    1ba0:	8c 17       	cp	r24, r28
    1ba2:	9d 07       	cpc	r25, r29
    1ba4:	79 f7       	brne	.-34     	; 0x1b84 <chOQResetI+0x30>
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_RESET;
}
    1ba6:	df 91       	pop	r29
    1ba8:	cf 91       	pop	r28
    1baa:	1f 91       	pop	r17
    1bac:	0f 91       	pop	r16
    1bae:	08 95       	ret

00001bb0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(OutputQueue *oqp, uint8_t b, systime_t time) {
    1bb0:	ff 92       	push	r15
    1bb2:	0f 93       	push	r16
    1bb4:	1f 93       	push	r17
    1bb6:	cf 93       	push	r28
    1bb8:	df 93       	push	r29
    1bba:	ec 01       	movw	r28, r24
    1bbc:	f6 2e       	mov	r15, r22
    1bbe:	8a 01       	movw	r16, r20

  chSysLock();
    1bc0:	f8 94       	cli
  while (chOQIsFullI(oqp)) {
    1bc2:	8c 81       	ldd	r24, Y+4	; 0x04
    1bc4:	9d 81       	ldd	r25, Y+5	; 0x05
    1bc6:	00 97       	sbiw	r24, 0x00	; 0
    1bc8:	79 f4       	brne	.+30     	; 0x1be8 <chOQPutTimeout+0x38>
    msg_t msg;

    if ((msg = qwait((GenericQueue *)oqp, time)) < Q_OK) {
    1bca:	b8 01       	movw	r22, r16
    1bcc:	ce 01       	movw	r24, r28
    1bce:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <qwait>
    1bd2:	9c 01       	movw	r18, r24
    1bd4:	97 ff       	sbrs	r25, 7
    1bd6:	f5 cf       	rjmp	.-22     	; 0x1bc2 <chOQPutTimeout+0x12>
      chSysUnlock();
    1bd8:	78 94       	sei
  if (oqp->q_notify)
    oqp->q_notify(oqp);

  chSysUnlock();
  return Q_OK;
}
    1bda:	c9 01       	movw	r24, r18
    1bdc:	df 91       	pop	r29
    1bde:	cf 91       	pop	r28
    1be0:	1f 91       	pop	r17
    1be2:	0f 91       	pop	r16
    1be4:	ff 90       	pop	r15
    1be6:	08 95       	ret
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
    1be8:	01 97       	sbiw	r24, 0x01	; 1
    1bea:	9d 83       	std	Y+5, r25	; 0x05
    1bec:	8c 83       	std	Y+4, r24	; 0x04
  *oqp->q_wrptr++ = b;
    1bee:	ea 85       	ldd	r30, Y+10	; 0x0a
    1bf0:	fb 85       	ldd	r31, Y+11	; 0x0b
    1bf2:	f1 92       	st	Z+, r15
    1bf4:	fb 87       	std	Y+11, r31	; 0x0b
    1bf6:	ea 87       	std	Y+10, r30	; 0x0a
  if (oqp->q_wrptr >= oqp->q_top)
    1bf8:	88 85       	ldd	r24, Y+8	; 0x08
    1bfa:	99 85       	ldd	r25, Y+9	; 0x09
    1bfc:	e8 17       	cp	r30, r24
    1bfe:	f9 07       	cpc	r31, r25
    1c00:	20 f0       	brcs	.+8      	; 0x1c0a <chOQPutTimeout+0x5a>
    oqp->q_wrptr = oqp->q_buffer;
    1c02:	8e 81       	ldd	r24, Y+6	; 0x06
    1c04:	9f 81       	ldd	r25, Y+7	; 0x07
    1c06:	9b 87       	std	Y+11, r25	; 0x0b
    1c08:	8a 87       	std	Y+10, r24	; 0x0a

  if (oqp->q_notify)
    1c0a:	ee 85       	ldd	r30, Y+14	; 0x0e
    1c0c:	ff 85       	ldd	r31, Y+15	; 0x0f
    1c0e:	30 97       	sbiw	r30, 0x00	; 0
    1c10:	11 f0       	breq	.+4      	; 0x1c16 <chOQPutTimeout+0x66>
    oqp->q_notify(oqp);
    1c12:	ce 01       	movw	r24, r28
    1c14:	09 95       	icall

  chSysUnlock();
    1c16:	78 94       	sei
  return Q_OK;
    1c18:	20 e0       	ldi	r18, 0x00	; 0
    1c1a:	30 e0       	ldi	r19, 0x00	; 0
}
    1c1c:	c9 01       	movw	r24, r18
    1c1e:	df 91       	pop	r29
    1c20:	cf 91       	pop	r28
    1c22:	1f 91       	pop	r17
    1c24:	0f 91       	pop	r16
    1c26:	ff 90       	pop	r15
    1c28:	08 95       	ret

00001c2a <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(OutputQueue *oqp) {
    1c2a:	1f 93       	push	r17
    1c2c:	cf 93       	push	r28
    1c2e:	df 93       	push	r29
    1c30:	fc 01       	movw	r30, r24
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
    1c32:	a4 85       	ldd	r26, Z+12	; 0x0c
    1c34:	b5 85       	ldd	r27, Z+13	; 0x0d
    1c36:	82 85       	ldd	r24, Z+10	; 0x0a
    1c38:	93 85       	ldd	r25, Z+11	; 0x0b
    1c3a:	8a 17       	cp	r24, r26
    1c3c:	9b 07       	cpc	r25, r27
    1c3e:	61 f1       	breq	.+88     	; 0x1c98 <chOQGetI+0x6e>
    1c40:	84 81       	ldd	r24, Z+4	; 0x04
    1c42:	95 81       	ldd	r25, Z+5	; 0x05
    return Q_EMPTY;

  oqp->q_counter++;
    1c44:	01 96       	adiw	r24, 0x01	; 1
    1c46:	95 83       	std	Z+5, r25	; 0x05
    1c48:	84 83       	std	Z+4, r24	; 0x04
  b = *oqp->q_rdptr++;
    1c4a:	1d 91       	ld	r17, X+
    1c4c:	b5 87       	std	Z+13, r27	; 0x0d
    1c4e:	a4 87       	std	Z+12, r26	; 0x0c
  if (oqp->q_rdptr >= oqp->q_top)
    1c50:	80 85       	ldd	r24, Z+8	; 0x08
    1c52:	91 85       	ldd	r25, Z+9	; 0x09
    1c54:	a8 17       	cp	r26, r24
    1c56:	b9 07       	cpc	r27, r25
    1c58:	d0 f4       	brcc	.+52     	; 0x1c8e <chOQGetI+0x64>
    oqp->q_rdptr = oqp->q_buffer;

  if (notempty(&oqp->q_waiting))
    1c5a:	80 81       	ld	r24, Z
    1c5c:	91 81       	ldd	r25, Z+1	; 0x01
    1c5e:	8e 17       	cp	r24, r30
    1c60:	9f 07       	cpc	r25, r31
    1c62:	71 f0       	breq	.+28     	; 0x1c80 <chOQGetI+0x56>
    1c64:	ec 01       	movw	r28, r24
    1c66:	a8 81       	ld	r26, Y
    1c68:	b9 81       	ldd	r27, Y+1	; 0x01
    1c6a:	b1 83       	std	Z+1, r27	; 0x01
    1c6c:	a0 83       	st	Z, r26
    1c6e:	13 96       	adiw	r26, 0x03	; 3
    1c70:	fc 93       	st	X, r31
    1c72:	ee 93       	st	-X, r30
    1c74:	12 97       	sbiw	r26, 0x02	; 2
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_OK;
    1c76:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
    1c7a:	fc 01       	movw	r30, r24
    1c7c:	13 8a       	std	Z+19, r1	; 0x13
    1c7e:	12 8a       	std	Z+18, r1	; 0x12

  return b;
    1c80:	21 2f       	mov	r18, r17
    1c82:	30 e0       	ldi	r19, 0x00	; 0
}
    1c84:	c9 01       	movw	r24, r18
    1c86:	df 91       	pop	r29
    1c88:	cf 91       	pop	r28
    1c8a:	1f 91       	pop	r17
    1c8c:	08 95       	ret
    return Q_EMPTY;

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top)
    oqp->q_rdptr = oqp->q_buffer;
    1c8e:	86 81       	ldd	r24, Z+6	; 0x06
    1c90:	97 81       	ldd	r25, Z+7	; 0x07
    1c92:	95 87       	std	Z+13, r25	; 0x0d
    1c94:	84 87       	std	Z+12, r24	; 0x0c
    1c96:	e1 cf       	rjmp	.-62     	; 0x1c5a <chOQGetI+0x30>
msg_t chOQGetI(OutputQueue *oqp) {
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
    1c98:	84 81       	ldd	r24, Z+4	; 0x04
    1c9a:	95 81       	ldd	r25, Z+5	; 0x05
    1c9c:	89 2b       	or	r24, r25
    1c9e:	19 f4       	brne	.+6      	; 0x1ca6 <chOQGetI+0x7c>
    1ca0:	80 e0       	ldi	r24, 0x00	; 0
    1ca2:	90 e0       	ldi	r25, 0x00	; 0
    1ca4:	cf cf       	rjmp	.-98     	; 0x1c44 <chOQGetI+0x1a>
    return Q_EMPTY;
    1ca6:	2d ef       	ldi	r18, 0xFD	; 253
    1ca8:	3f ef       	ldi	r19, 0xFF	; 255
    1caa:	ec cf       	rjmp	.-40     	; 0x1c84 <chOQGetI+0x5a>

00001cac <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
    1cac:	8f 92       	push	r8
    1cae:	9f 92       	push	r9
    1cb0:	af 92       	push	r10
    1cb2:	bf 92       	push	r11
    1cb4:	cf 92       	push	r12
    1cb6:	df 92       	push	r13
    1cb8:	ef 92       	push	r14
    1cba:	ff 92       	push	r15
    1cbc:	0f 93       	push	r16
    1cbe:	1f 93       	push	r17
    1cc0:	cf 93       	push	r28
    1cc2:	df 93       	push	r29
    1cc4:	ec 01       	movw	r28, r24
    1cc6:	7b 01       	movw	r14, r22
    1cc8:	4a 01       	movw	r8, r20
    1cca:	59 01       	movw	r10, r18
  qnotify_t nfy = oqp->q_notify;
    1ccc:	ce 84       	ldd	r12, Y+14	; 0x0e
    1cce:	df 84       	ldd	r13, Y+15	; 0x0f
  size_t w = 0;

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
    1cd0:	f8 94       	cli
 * @api
 */
size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
    1cd2:	00 e0       	ldi	r16, 0x00	; 0
    1cd4:	10 e0       	ldi	r17, 0x00	; 0

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
  while (TRUE) {
    while (chOQIsFullI(oqp)) {
    1cd6:	8c 81       	ldd	r24, Y+4	; 0x04
    1cd8:	9d 81       	ldd	r25, Y+5	; 0x05
    1cda:	00 97       	sbiw	r24, 0x00	; 0
    1cdc:	31 f1       	breq	.+76     	; 0x1d2a <chOQWriteTimeout+0x7e>
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    1cde:	01 97       	sbiw	r24, 0x01	; 1
    1ce0:	9d 83       	std	Y+5, r25	; 0x05
    1ce2:	8c 83       	std	Y+4, r24	; 0x04
    *oqp->q_wrptr++ = *bp++;
    1ce4:	f7 01       	movw	r30, r14
    1ce6:	81 91       	ld	r24, Z+
    1ce8:	7f 01       	movw	r14, r30
    1cea:	aa 85       	ldd	r26, Y+10	; 0x0a
    1cec:	bb 85       	ldd	r27, Y+11	; 0x0b
    1cee:	8d 93       	st	X+, r24
    1cf0:	bb 87       	std	Y+11, r27	; 0x0b
    1cf2:	aa 87       	std	Y+10, r26	; 0x0a
    if (oqp->q_wrptr >= oqp->q_top)
    1cf4:	88 85       	ldd	r24, Y+8	; 0x08
    1cf6:	99 85       	ldd	r25, Y+9	; 0x09
    1cf8:	a8 17       	cp	r26, r24
    1cfa:	b9 07       	cpc	r27, r25
    1cfc:	20 f0       	brcs	.+8      	; 0x1d06 <chOQWriteTimeout+0x5a>
      oqp->q_wrptr = oqp->q_buffer;
    1cfe:	8e 81       	ldd	r24, Y+6	; 0x06
    1d00:	9f 81       	ldd	r25, Y+7	; 0x07
    1d02:	9b 87       	std	Y+11, r25	; 0x0b
    1d04:	8a 87       	std	Y+10, r24	; 0x0a

    if (nfy)
    1d06:	c1 14       	cp	r12, r1
    1d08:	d1 04       	cpc	r13, r1
    1d0a:	19 f0       	breq	.+6      	; 0x1d12 <chOQWriteTimeout+0x66>
      nfy(oqp);
    1d0c:	ce 01       	movw	r24, r28
    1d0e:	f6 01       	movw	r30, r12
    1d10:	09 95       	icall

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    1d12:	78 94       	sei
    w++;
    1d14:	0f 5f       	subi	r16, 0xFF	; 255
    1d16:	1f 4f       	sbci	r17, 0xFF	; 255
    if (--n == 0)
    1d18:	f1 e0       	ldi	r31, 0x01	; 1
    1d1a:	8f 1a       	sub	r8, r31
    1d1c:	91 08       	sbc	r9, r1
    1d1e:	61 f0       	breq	.+24     	; 0x1d38 <chOQWriteTimeout+0x8c>
      return w;
    chSysLock();
    1d20:	f8 94       	cli

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
  while (TRUE) {
    while (chOQIsFullI(oqp)) {
    1d22:	8c 81       	ldd	r24, Y+4	; 0x04
    1d24:	9d 81       	ldd	r25, Y+5	; 0x05
    1d26:	00 97       	sbiw	r24, 0x00	; 0
    1d28:	d1 f6       	brne	.-76     	; 0x1cde <chOQWriteTimeout+0x32>
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
    1d2a:	b5 01       	movw	r22, r10
    1d2c:	ce 01       	movw	r24, r28
    1d2e:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <qwait>
    1d32:	89 2b       	or	r24, r25
    1d34:	81 f2       	breq	.-96     	; 0x1cd6 <chOQWriteTimeout+0x2a>
        chSysUnlock();
    1d36:	78 94       	sei
    w++;
    if (--n == 0)
      return w;
    chSysLock();
  }
}
    1d38:	c8 01       	movw	r24, r16
    1d3a:	df 91       	pop	r29
    1d3c:	cf 91       	pop	r28
    1d3e:	1f 91       	pop	r17
    1d40:	0f 91       	pop	r16
    1d42:	ff 90       	pop	r15
    1d44:	ef 90       	pop	r14
    1d46:	df 90       	pop	r13
    1d48:	cf 90       	pop	r12
    1d4a:	bf 90       	pop	r11
    1d4c:	af 90       	pop	r10
    1d4e:	9f 90       	pop	r9
    1d50:	8f 90       	pop	r8
    1d52:	08 95       	ret

00001d54 <halInit>:
 *
 * @init
 */
void halInit(void) {

  hal_lld_init();
    1d54:	0e 94 4d 11 	call	0x229a	; 0x229a <hal_lld_init>

#if HAL_USE_TM || defined(__DOXYGEN__)
  tmInit();
#endif
#if HAL_USE_PAL || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    1d58:	8d e7       	ldi	r24, 0x7D	; 125
    1d5a:	91 e0       	ldi	r25, 0x01	; 1
    1d5c:	0e 94 80 11 	call	0x2300	; 0x2300 <_pal_lld_init>
#endif
#if HAL_USE_ADC || defined(__DOXYGEN__)
  adcInit();
    1d60:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <adcInit>
#endif
#if HAL_USE_MAC || defined(__DOXYGEN__)
  macInit();
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
    1d64:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <pwmInit>
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
    1d68:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <sdInit>
#endif
#if HAL_USE_SDC || defined(__DOXYGEN__)
  sdcInit();
#endif
#if HAL_USE_SPI || defined(__DOXYGEN__)
  spiInit();
    1d6c:	0e 94 87 10 	call	0x210e	; 0x210e <spiInit>
#endif
#if HAL_USE_RTC || defined(__DOXYGEN__)
  rtcInit();
#endif
  /* Board specific initialization.*/
  boardInit();
    1d70:	0c 94 76 18 	jmp	0x30ec	; 0x30ec <boardInit>

00001d74 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
    1d74:	0c 94 a5 13 	jmp	0x274a	; 0x274a <adc_lld_init>

00001d78 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    1d78:	fc 01       	movw	r30, r24

  adcp->state    = ADC_STOP;
    1d7a:	81 e0       	ldi	r24, 0x01	; 1
    1d7c:	80 83       	st	Z, r24
  adcp->config   = NULL;
    1d7e:	12 82       	std	Z+2, r1	; 0x02
    1d80:	11 82       	std	Z+1, r1	; 0x01
  adcp->samples  = NULL;
    1d82:	14 82       	std	Z+4, r1	; 0x04
    1d84:	13 82       	std	Z+3, r1	; 0x03
  adcp->depth    = 0;
    1d86:	16 82       	std	Z+6, r1	; 0x06
    1d88:	15 82       	std	Z+5, r1	; 0x05
  adcp->grpp     = NULL;
    1d8a:	10 86       	std	Z+8, r1	; 0x08
    1d8c:	17 82       	std	Z+7, r1	; 0x07
#if ADC_USE_WAIT
  adcp->thread   = NULL;
    1d8e:	12 86       	std	Z+10, r1	; 0x0a
    1d90:	11 86       	std	Z+9, r1	; 0x09
#endif /* ADC_USE_WAIT */
#if ADC_USE_MUTUAL_EXCLUSION
#if CH_USE_MUTEXES
  chMtxInit(&adcp->mutex);
    1d92:	cf 01       	movw	r24, r30
    1d94:	0b 96       	adiw	r24, 0x0b	; 11
    1d96:	0c 94 3e 06 	jmp	0xc7c	; 0xc7c <chMtxInit>

00001d9a <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
    1d9a:	cf 93       	push	r28
    1d9c:	df 93       	push	r29
    1d9e:	ec 01       	movw	r28, r24

  chDbgCheck(adcp != NULL, "adcStart");

  chSysLock();
    1da0:	f8 94       	cli
  chDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
              "adcStart(), #1", "invalid state");
  adcp->config = config;
    1da2:	7a 83       	std	Y+2, r23	; 0x02
    1da4:	69 83       	std	Y+1, r22	; 0x01
  adc_lld_start(adcp);
    1da6:	0e 94 b1 13 	call	0x2762	; 0x2762 <adc_lld_start>
  adcp->state = ADC_READY;
    1daa:	82 e0       	ldi	r24, 0x02	; 2
    1dac:	88 83       	st	Y, r24
  chSysUnlock();
    1dae:	78 94       	sei
}
    1db0:	df 91       	pop	r29
    1db2:	cf 91       	pop	r28
    1db4:	08 95       	ret

00001db6 <adcStop>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStop(ADCDriver *adcp) {
    1db6:	cf 93       	push	r28
    1db8:	df 93       	push	r29
    1dba:	ec 01       	movw	r28, r24

  chDbgCheck(adcp != NULL, "adcStop");

  chSysLock();
    1dbc:	f8 94       	cli
  chDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
              "adcStop(), #1", "invalid state");
  adc_lld_stop(adcp);
    1dbe:	0e 94 ca 13 	call	0x2794	; 0x2794 <adc_lld_stop>
  adcp->state = ADC_STOP;
    1dc2:	81 e0       	ldi	r24, 0x01	; 1
    1dc4:	88 83       	st	Y, r24
  chSysUnlock();
    1dc6:	78 94       	sei
}
    1dc8:	df 91       	pop	r29
    1dca:	cf 91       	pop	r28
    1dcc:	08 95       	ret

00001dce <adcStartConversion>:
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {

  chSysLock();
    1dce:	f8 94       	cli
  chDbgAssert((adcp->state == ADC_READY) ||
              (adcp->state == ADC_COMPLETE) ||
              (adcp->state == ADC_ERROR),
              "adcStartConversionI(), #1", "not ready");

  adcp->samples  = samples;
    1dd0:	fc 01       	movw	r30, r24
    1dd2:	54 83       	std	Z+4, r21	; 0x04
    1dd4:	43 83       	std	Z+3, r20	; 0x03
  adcp->depth    = depth;
    1dd6:	36 83       	std	Z+6, r19	; 0x06
    1dd8:	25 83       	std	Z+5, r18	; 0x05
  adcp->grpp     = grpp;
    1dda:	70 87       	std	Z+8, r23	; 0x08
    1ddc:	67 83       	std	Z+7, r22	; 0x07
  adcp->state    = ADC_ACTIVE;
    1dde:	23 e0       	ldi	r18, 0x03	; 3
    1de0:	20 83       	st	Z, r18
  adc_lld_start_conversion(adcp);
    1de2:	0e 94 d5 13 	call	0x27aa	; 0x27aa <adc_lld_start_conversion>
                        adcsample_t *samples,
                        size_t depth) {

  chSysLock();
  adcStartConversionI(adcp, grpp, samples, depth);
  chSysUnlock();
    1de6:	78 94       	sei
    1de8:	08 95       	ret

00001dea <adcStartConversionI>:
  chDbgAssert((adcp->state == ADC_READY) ||
              (adcp->state == ADC_COMPLETE) ||
              (adcp->state == ADC_ERROR),
              "adcStartConversionI(), #1", "not ready");

  adcp->samples  = samples;
    1dea:	fc 01       	movw	r30, r24
    1dec:	54 83       	std	Z+4, r21	; 0x04
    1dee:	43 83       	std	Z+3, r20	; 0x03
  adcp->depth    = depth;
    1df0:	36 83       	std	Z+6, r19	; 0x06
    1df2:	25 83       	std	Z+5, r18	; 0x05
  adcp->grpp     = grpp;
    1df4:	70 87       	std	Z+8, r23	; 0x08
    1df6:	67 83       	std	Z+7, r22	; 0x07
  adcp->state    = ADC_ACTIVE;
    1df8:	23 e0       	ldi	r18, 0x03	; 3
    1dfa:	20 83       	st	Z, r18
  adc_lld_start_conversion(adcp);
    1dfc:	0c 94 d5 13 	jmp	0x27aa	; 0x27aa <adc_lld_start_conversion>

00001e00 <adcStopConversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStopConversion(ADCDriver *adcp) {
    1e00:	cf 93       	push	r28
    1e02:	df 93       	push	r29
    1e04:	ec 01       	movw	r28, r24

  chDbgCheck(adcp != NULL, "adcStopConversion");

  chSysLock();
    1e06:	f8 94       	cli
  chDbgAssert((adcp->state == ADC_READY) ||
              (adcp->state == ADC_ACTIVE),
              "adcStopConversion(), #1", "invalid state");
  if (adcp->state != ADC_READY) {
    1e08:	88 81       	ld	r24, Y
    1e0a:	82 30       	cpi	r24, 0x02	; 2
    1e0c:	89 f0       	breq	.+34     	; 0x1e30 <adcStopConversion+0x30>
    adc_lld_stop_conversion(adcp);
    1e0e:	ce 01       	movw	r24, r28
    1e10:	0e 94 00 14 	call	0x2800	; 0x2800 <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
    1e14:	18 86       	std	Y+8, r1	; 0x08
    1e16:	1f 82       	std	Y+7, r1	; 0x07
    adcp->state = ADC_READY;
    1e18:	82 e0       	ldi	r24, 0x02	; 2
    1e1a:	88 83       	st	Y, r24
    _adc_reset_s(adcp);
    1e1c:	89 85       	ldd	r24, Y+9	; 0x09
    1e1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e20:	00 97       	sbiw	r24, 0x00	; 0
    1e22:	31 f0       	breq	.+12     	; 0x1e30 <adcStopConversion+0x30>
    1e24:	1a 86       	std	Y+10, r1	; 0x0a
    1e26:	19 86       	std	Y+9, r1	; 0x09
    1e28:	6e ef       	ldi	r22, 0xFE	; 254
    1e2a:	7f ef       	ldi	r23, 0xFF	; 255
    1e2c:	0e 94 b0 02 	call	0x560	; 0x560 <chSchWakeupS>
  }
  chSysUnlock();
    1e30:	78 94       	sei
}
    1e32:	df 91       	pop	r29
    1e34:	cf 91       	pop	r28
    1e36:	08 95       	ret

00001e38 <adcStopConversionI>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @iclass
 */
void adcStopConversionI(ADCDriver *adcp) {
    1e38:	cf 93       	push	r28
    1e3a:	df 93       	push	r29
    1e3c:	ec 01       	movw	r28, r24
  chDbgAssert((adcp->state == ADC_READY) ||
              (adcp->state == ADC_ACTIVE) ||
              (adcp->state == ADC_COMPLETE),
              "adcStopConversionI(), #1", "invalid state");

  if (adcp->state != ADC_READY) {
    1e3e:	88 81       	ld	r24, Y
    1e40:	82 30       	cpi	r24, 0x02	; 2
    1e42:	b1 f0       	breq	.+44     	; 0x1e70 <adcStopConversionI+0x38>
    adc_lld_stop_conversion(adcp);
    1e44:	ce 01       	movw	r24, r28
    1e46:	0e 94 00 14 	call	0x2800	; 0x2800 <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
    1e4a:	18 86       	std	Y+8, r1	; 0x08
    1e4c:	1f 82       	std	Y+7, r1	; 0x07
    adcp->state = ADC_READY;
    1e4e:	82 e0       	ldi	r24, 0x02	; 2
    1e50:	88 83       	st	Y, r24
    _adc_reset_i(adcp);
    1e52:	89 85       	ldd	r24, Y+9	; 0x09
    1e54:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e56:	00 97       	sbiw	r24, 0x00	; 0
    1e58:	59 f0       	breq	.+22     	; 0x1e70 <adcStopConversionI+0x38>
    1e5a:	1a 86       	std	Y+10, r1	; 0x0a
    1e5c:	19 86       	std	Y+9, r1	; 0x09
    1e5e:	2e ef       	ldi	r18, 0xFE	; 254
    1e60:	3f ef       	ldi	r19, 0xFF	; 255
    1e62:	fc 01       	movw	r30, r24
    1e64:	33 8b       	std	Z+19, r19	; 0x13
    1e66:	22 8b       	std	Z+18, r18	; 0x12
  }
}
    1e68:	df 91       	pop	r29
    1e6a:	cf 91       	pop	r28

  if (adcp->state != ADC_READY) {
    adc_lld_stop_conversion(adcp);
    adcp->grpp  = NULL;
    adcp->state = ADC_READY;
    _adc_reset_i(adcp);
    1e6c:	0c 94 34 02 	jmp	0x468	; 0x468 <chSchReadyI>
  }
}
    1e70:	df 91       	pop	r29
    1e72:	cf 91       	pop	r28
    1e74:	08 95       	ret

00001e76 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
    1e76:	cf 93       	push	r28
    1e78:	df 93       	push	r29
    1e7a:	ec 01       	movw	r28, r24
  msg_t msg;

  chSysLock();
    1e7c:	f8 94       	cli
  chDbgAssert((adcp->state == ADC_READY) ||
              (adcp->state == ADC_COMPLETE) ||
              (adcp->state == ADC_ERROR),
              "adcStartConversionI(), #1", "not ready");

  adcp->samples  = samples;
    1e7e:	5c 83       	std	Y+4, r21	; 0x04
    1e80:	4b 83       	std	Y+3, r20	; 0x03
  adcp->depth    = depth;
    1e82:	3e 83       	std	Y+6, r19	; 0x06
    1e84:	2d 83       	std	Y+5, r18	; 0x05
  adcp->grpp     = grpp;
    1e86:	78 87       	std	Y+8, r23	; 0x08
    1e88:	6f 83       	std	Y+7, r22	; 0x07
  adcp->state    = ADC_ACTIVE;
    1e8a:	83 e0       	ldi	r24, 0x03	; 3
    1e8c:	88 83       	st	Y, r24
  adc_lld_start_conversion(adcp);
    1e8e:	ce 01       	movw	r24, r28
    1e90:	0e 94 d5 13 	call	0x27aa	; 0x27aa <adc_lld_start_conversion>
  msg_t msg;

  chSysLock();
  chDbgAssert(adcp->thread == NULL, "adcConvert(), #1", "already waiting");
  adcStartConversionI(adcp, grpp, samples, depth);
  (adcp)->thread = chThdSelf();
    1e94:	80 91 3a 02 	lds	r24, 0x023A
    1e98:	90 91 3b 02 	lds	r25, 0x023B
    1e9c:	9a 87       	std	Y+10, r25	; 0x0a
    1e9e:	89 87       	std	Y+9, r24	; 0x09
  chSchGoSleepS(THD_STATE_SUSPENDED);
    1ea0:	82 e0       	ldi	r24, 0x02	; 2
    1ea2:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
  msg = chThdSelf()->p_u.rdymsg;
    1ea6:	e0 91 3a 02 	lds	r30, 0x023A
    1eaa:	f0 91 3b 02 	lds	r31, 0x023B
    1eae:	82 89       	ldd	r24, Z+18	; 0x12
    1eb0:	93 89       	ldd	r25, Z+19	; 0x13
  chSysUnlock();
    1eb2:	78 94       	sei
  return msg;
}
    1eb4:	df 91       	pop	r29
    1eb6:	cf 91       	pop	r28
    1eb8:	08 95       	ret

00001eba <adcAcquireBus>:
void adcAcquireBus(ADCDriver *adcp) {

  chDbgCheck(adcp != NULL, "adcAcquireBus");

#if CH_USE_MUTEXES
  chMtxLock(&adcp->mutex);
    1eba:	0b 96       	adiw	r24, 0x0b	; 11
    1ebc:	0c 94 06 07 	jmp	0xe0c	; 0xe0c <chMtxLock>

00001ec0 <adcReleaseBus>:

  chDbgCheck(adcp != NULL, "adcReleaseBus");

#if CH_USE_MUTEXES
  (void)adcp;
  chMtxUnlock();
    1ec0:	0c 94 44 07 	jmp	0xe88	; 0xe88 <chMtxUnlock>

00001ec4 <palReadBus>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @return              The bus logical states.
 *
 * @api
 */
ioportmask_t palReadBus(IOBus *bus) {
    1ec4:	fc 01       	movw	r30, r24

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palReadBus");

  return palReadGroup(bus->portid, bus->mask, bus->offset);
    1ec6:	a0 81       	ld	r26, Z
    1ec8:	b1 81       	ldd	r27, Z+1	; 0x01
    1eca:	2c 91       	ld	r18, X
    1ecc:	30 e0       	ldi	r19, 0x00	; 0
    1ece:	03 80       	ldd	r0, Z+3	; 0x03
    1ed0:	02 c0       	rjmp	.+4      	; 0x1ed6 <palReadBus+0x12>
    1ed2:	35 95       	asr	r19
    1ed4:	27 95       	ror	r18
    1ed6:	0a 94       	dec	r0
    1ed8:	e2 f7       	brpl	.-8      	; 0x1ed2 <palReadBus+0xe>
    1eda:	82 81       	ldd	r24, Z+2	; 0x02
}
    1edc:	82 23       	and	r24, r18
    1ede:	08 95       	ret

00001ee0 <palWriteBus>:
 *                      the bus width are masked so most significant bits are
 *                      lost.
 *
 * @api
 */
void palWriteBus(IOBus *bus, ioportmask_t bits) {
    1ee0:	fc 01       	movw	r30, r24

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palWriteBus");

  palWriteGroup(bus->portid, bus->mask, bus->offset, bits);
    1ee2:	a0 81       	ld	r26, Z
    1ee4:	b1 81       	ldd	r27, Z+1	; 0x01
    1ee6:	12 96       	adiw	r26, 0x02	; 2
    1ee8:	3c 91       	ld	r19, X
    1eea:	12 97       	sbiw	r26, 0x02	; 2
    1eec:	82 81       	ldd	r24, Z+2	; 0x02
    1eee:	23 81       	ldd	r18, Z+3	; 0x03
    1ef0:	68 23       	and	r22, r24
    1ef2:	02 2e       	mov	r0, r18
    1ef4:	01 c0       	rjmp	.+2      	; 0x1ef8 <palWriteBus+0x18>
    1ef6:	66 0f       	add	r22, r22
    1ef8:	0a 94       	dec	r0
    1efa:	ea f7       	brpl	.-6      	; 0x1ef6 <palWriteBus+0x16>
    1efc:	02 2e       	mov	r0, r18
    1efe:	01 c0       	rjmp	.+2      	; 0x1f02 <palWriteBus+0x22>
    1f00:	88 0f       	add	r24, r24
    1f02:	0a 94       	dec	r0
    1f04:	ea f7       	brpl	.-6      	; 0x1f00 <palWriteBus+0x20>
    1f06:	80 95       	com	r24
    1f08:	83 23       	and	r24, r19
    1f0a:	86 2b       	or	r24, r22
    1f0c:	12 96       	adiw	r26, 0x02	; 2
    1f0e:	8c 93       	st	X, r24
    1f10:	08 95       	ret

00001f12 <palSetBusMode>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @param[in] mode      the mode
 *
 * @api
 */
void palSetBusMode(IOBus *bus, iomode_t mode) {
    1f12:	fc 01       	movw	r30, r24
    1f14:	46 2f       	mov	r20, r22

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palSetBusMode");

  palSetGroupMode(bus->portid, bus->mask, bus->offset, mode);
    1f16:	82 81       	ldd	r24, Z+2	; 0x02
    1f18:	68 2f       	mov	r22, r24
    1f1a:	70 e0       	ldi	r23, 0x00	; 0
    1f1c:	03 80       	ldd	r0, Z+3	; 0x03
    1f1e:	02 c0       	rjmp	.+4      	; 0x1f24 <palSetBusMode+0x12>
    1f20:	66 0f       	add	r22, r22
    1f22:	77 1f       	adc	r23, r23
    1f24:	0a 94       	dec	r0
    1f26:	e2 f7       	brpl	.-8      	; 0x1f20 <palSetBusMode+0xe>
    1f28:	80 81       	ld	r24, Z
    1f2a:	91 81       	ldd	r25, Z+1	; 0x01
    1f2c:	0c 94 8e 11 	jmp	0x231c	; 0x231c <_pal_lld_setgroupmode>

00001f30 <pwmInit>:
 *
 * @init
 */
void pwmInit(void) {

  pwm_lld_init();
    1f30:	0c 94 32 15 	jmp	0x2a64	; 0x2a64 <pwm_lld_init>

00001f34 <pwmObjectInit>:
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
    1f34:	21 e0       	ldi	r18, 0x01	; 1
    1f36:	fc 01       	movw	r30, r24
    1f38:	20 83       	st	Z, r18
  pwmp->config   = NULL;
    1f3a:	12 82       	std	Z+2, r1	; 0x02
    1f3c:	11 82       	std	Z+1, r1	; 0x01
    1f3e:	08 95       	ret

00001f40 <pwmStart>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] config    pointer to a @p PWMConfig object
 *
 * @api
 */
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
    1f40:	cf 93       	push	r28
    1f42:	df 93       	push	r29
    1f44:	ec 01       	movw	r28, r24

  chDbgCheck((pwmp != NULL) && (config != NULL), "pwmStart");

  chSysLock();
    1f46:	f8 94       	cli
  chDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
              "pwmStart(), #1", "invalid state");
  pwmp->config = config;
    1f48:	7a 83       	std	Y+2, r23	; 0x02
    1f4a:	69 83       	std	Y+1, r22	; 0x01
  pwmp->period = config->period;
    1f4c:	fb 01       	movw	r30, r22
    1f4e:	84 81       	ldd	r24, Z+4	; 0x04
    1f50:	95 81       	ldd	r25, Z+5	; 0x05
    1f52:	9c 83       	std	Y+4, r25	; 0x04
    1f54:	8b 83       	std	Y+3, r24	; 0x03
  pwm_lld_start(pwmp);
    1f56:	ce 01       	movw	r24, r28
    1f58:	0e 94 46 15 	call	0x2a8c	; 0x2a8c <pwm_lld_start>
  pwmp->state = PWM_READY;
    1f5c:	82 e0       	ldi	r24, 0x02	; 2
    1f5e:	88 83       	st	Y, r24
  chSysUnlock();
    1f60:	78 94       	sei
}
    1f62:	df 91       	pop	r29
    1f64:	cf 91       	pop	r28
    1f66:	08 95       	ret

00001f68 <pwmStop>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @api
 */
void pwmStop(PWMDriver *pwmp) {
    1f68:	cf 93       	push	r28
    1f6a:	df 93       	push	r29
    1f6c:	ec 01       	movw	r28, r24

  chDbgCheck(pwmp != NULL, "pwmStop");

  chSysLock();
    1f6e:	f8 94       	cli
  chDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
              "pwmStop(), #1", "invalid state");
  pwm_lld_stop(pwmp);
    1f70:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <pwm_lld_stop>
  pwmp->state = PWM_STOP;
    1f74:	81 e0       	ldi	r24, 0x01	; 1
    1f76:	88 83       	st	Y, r24
  chSysUnlock();
    1f78:	78 94       	sei
}
    1f7a:	df 91       	pop	r29
    1f7c:	cf 91       	pop	r28
    1f7e:	08 95       	ret

00001f80 <pwmChangePeriod>:
 */
void pwmChangePeriod(PWMDriver *pwmp, pwmcnt_t period) {

  chDbgCheck(pwmp != NULL, "pwmChangePeriod");

  chSysLock();
    1f80:	f8 94       	cli
  chDbgAssert(pwmp->state == PWM_READY,
              "pwmChangePeriod(), #1", "invalid state");
  pwmChangePeriodI(pwmp, period);
    1f82:	fc 01       	movw	r30, r24
    1f84:	74 83       	std	Z+4, r23	; 0x04
    1f86:	63 83       	std	Z+3, r22	; 0x03
    1f88:	0e 94 78 15 	call	0x2af0	; 0x2af0 <pwm_lld_change_period>
  chSysUnlock();
    1f8c:	78 94       	sei
    1f8e:	08 95       	ret

00001f90 <pwmEnableChannel>:
                      pwmcnt_t width) {

  chDbgCheck((pwmp != NULL) && (channel < PWM_CHANNELS),
             "pwmEnableChannel");

  chSysLock();
    1f90:	f8 94       	cli
  chDbgAssert(pwmp->state == PWM_READY,
              "pwmEnableChannel(), #1", "not ready");
  pwm_lld_enable_channel(pwmp, channel, width);
    1f92:	0e 94 79 15 	call	0x2af2	; 0x2af2 <pwm_lld_enable_channel>
  chSysUnlock();
    1f96:	78 94       	sei
    1f98:	08 95       	ret

00001f9a <pwmDisableChannel>:
void pwmDisableChannel(PWMDriver *pwmp, pwmchannel_t channel) {

  chDbgCheck((pwmp != NULL) && (channel < PWM_CHANNELS),
             "pwmEnableChannel");

  chSysLock();
    1f9a:	f8 94       	cli
  chDbgAssert(pwmp->state == PWM_READY,
              "pwmDisableChannel(), #1", "not ready");
  pwm_lld_disable_channel(pwmp, channel);
    1f9c:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <pwm_lld_disable_channel>
  chSysUnlock();
    1fa0:	78 94       	sei
    1fa2:	08 95       	ret

00001fa4 <readt>:
  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
    1fa4:	05 96       	adiw	r24, 0x05	; 5
    1fa6:	0c 94 3e 0d 	jmp	0x1a7c	; 0x1a7c <chIQReadTimeout>

00001faa <read>:
                          n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    1faa:	2f ef       	ldi	r18, 0xFF	; 255
    1fac:	3f ef       	ldi	r19, 0xFF	; 255
    1fae:	05 96       	adiw	r24, 0x05	; 5
    1fb0:	0c 94 3e 0d 	jmp	0x1a7c	; 0x1a7c <chIQReadTimeout>

00001fb4 <writet>:
  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
    1fb4:	47 96       	adiw	r24, 0x17	; 23
    1fb6:	0c 94 56 0e 	jmp	0x1cac	; 0x1cac <chOQWriteTimeout>

00001fba <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    1fba:	2f ef       	ldi	r18, 0xFF	; 255
    1fbc:	3f ef       	ldi	r19, 0xFF	; 255
    1fbe:	47 96       	adiw	r24, 0x17	; 23
    1fc0:	0c 94 56 0e 	jmp	0x1cac	; 0x1cac <chOQWriteTimeout>

00001fc4 <gett>:
  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    1fc4:	05 96       	adiw	r24, 0x05	; 5
    1fc6:	0c 94 07 0d 	jmp	0x1a0e	; 0x1a0e <chIQGetTimeout>

00001fca <get>:
  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    1fca:	6f ef       	ldi	r22, 0xFF	; 255
    1fcc:	7f ef       	ldi	r23, 0xFF	; 255
    1fce:	05 96       	adiw	r24, 0x05	; 5
    1fd0:	0c 94 07 0d 	jmp	0x1a0e	; 0x1a0e <chIQGetTimeout>

00001fd4 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    1fd4:	47 96       	adiw	r24, 0x17	; 23
    1fd6:	0c 94 d8 0d 	jmp	0x1bb0	; 0x1bb0 <chOQPutTimeout>

00001fda <put>:
                         n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    1fda:	4f ef       	ldi	r20, 0xFF	; 255
    1fdc:	5f ef       	ldi	r21, 0xFF	; 255
    1fde:	47 96       	adiw	r24, 0x17	; 23
    1fe0:	0c 94 d8 0d 	jmp	0x1bb0	; 0x1bb0 <chOQPutTimeout>

00001fe4 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    1fe4:	0c 94 2d 12 	jmp	0x245a	; 0x245a <sd_lld_init>

00001fe8 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    1fe8:	ef 92       	push	r14
    1fea:	ff 92       	push	r15
    1fec:	0f 93       	push	r16
    1fee:	1f 93       	push	r17
    1ff0:	cf 93       	push	r28
    1ff2:	df 93       	push	r29
    1ff4:	ec 01       	movw	r28, r24
    1ff6:	9b 01       	movw	r18, r22
    1ff8:	7a 01       	movw	r14, r20

  sdp->vmt = &vmt;
    1ffa:	fc 01       	movw	r30, r24
    1ffc:	8a e6       	ldi	r24, 0x6A	; 106
    1ffe:	91 e0       	ldi	r25, 0x01	; 1
    2000:	81 93       	st	Z+, r24
    2002:	91 93       	st	Z+, r25
  chEvtInit(&sdp->event);
    2004:	fb 83       	std	Y+3, r31	; 0x03
    2006:	ea 83       	std	Y+2, r30	; 0x02
  sdp->state = SD_STOP;
    2008:	81 e0       	ldi	r24, 0x01	; 1
    200a:	8c 83       	std	Y+4, r24	; 0x04
  chIQInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    200c:	be 01       	movw	r22, r28
    200e:	67 5d       	subi	r22, 0xD7	; 215
    2010:	7f 4f       	sbci	r23, 0xFF	; 255
    2012:	8e 01       	movw	r16, r28
    2014:	40 e1       	ldi	r20, 0x10	; 16
    2016:	50 e0       	ldi	r21, 0x00	; 0
    2018:	ce 01       	movw	r24, r28
    201a:	05 96       	adiw	r24, 0x05	; 5
    201c:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <chIQInit>
  chOQInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    2020:	be 01       	movw	r22, r28
    2022:	67 5c       	subi	r22, 0xC7	; 199
    2024:	7f 4f       	sbci	r23, 0xFF	; 255
    2026:	97 01       	movw	r18, r14
    2028:	40 e1       	ldi	r20, 0x10	; 16
    202a:	50 e0       	ldi	r21, 0x00	; 0
    202c:	ce 01       	movw	r24, r28
    202e:	47 96       	adiw	r24, 0x17	; 23
    2030:	0e 94 90 0d 	call	0x1b20	; 0x1b20 <chOQInit>
}
    2034:	df 91       	pop	r29
    2036:	cf 91       	pop	r28
    2038:	1f 91       	pop	r17
    203a:	0f 91       	pop	r16
    203c:	ff 90       	pop	r15
    203e:	ef 90       	pop	r14
    2040:	08 95       	ret

00002042 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    2042:	cf 93       	push	r28
    2044:	df 93       	push	r29
    2046:	ec 01       	movw	r28, r24

  chDbgCheck(sdp != NULL, "sdStart");

  chSysLock();
    2048:	f8 94       	cli
  chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
              "sdStart(), #1",
              "invalid state");
  sd_lld_start(sdp, config);
    204a:	0e 94 35 12 	call	0x246a	; 0x246a <sd_lld_start>
  sdp->state = SD_READY;
    204e:	82 e0       	ldi	r24, 0x02	; 2
    2050:	8c 83       	std	Y+4, r24	; 0x04
  chSysUnlock();
    2052:	78 94       	sei
}
    2054:	df 91       	pop	r29
    2056:	cf 91       	pop	r28
    2058:	08 95       	ret

0000205a <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
    205a:	cf 93       	push	r28
    205c:	df 93       	push	r29
    205e:	ec 01       	movw	r28, r24

  chDbgCheck(sdp != NULL, "sdStop");

  chSysLock();
    2060:	f8 94       	cli
  chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
              "sdStop(), #1",
              "invalid state");
  sd_lld_stop(sdp);
    2062:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <sd_lld_stop>
  sdp->state = SD_STOP;
    2066:	81 e0       	ldi	r24, 0x01	; 1
    2068:	8c 83       	std	Y+4, r24	; 0x04
  chOQResetI(&sdp->oqueue);
    206a:	ce 01       	movw	r24, r28
    206c:	47 96       	adiw	r24, 0x17	; 23
    206e:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <chOQResetI>
  chIQResetI(&sdp->iqueue);
    2072:	ce 01       	movw	r24, r28
    2074:	05 96       	adiw	r24, 0x05	; 5
    2076:	0e 94 94 0c 	call	0x1928	; 0x1928 <chIQResetI>
  chSchRescheduleS();
    207a:	0e 94 8e 03 	call	0x71c	; 0x71c <chSchRescheduleS>
  chSysUnlock();
    207e:	78 94       	sei
}
    2080:	df 91       	pop	r29
    2082:	cf 91       	pop	r28
    2084:	08 95       	ret

00002086 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    2086:	1f 93       	push	r17
    2088:	cf 93       	push	r28
    208a:	df 93       	push	r29
    208c:	ec 01       	movw	r28, r24
    208e:	16 2f       	mov	r17, r22

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    2090:	89 85       	ldd	r24, Y+9	; 0x09
    2092:	9a 85       	ldd	r25, Y+10	; 0x0a
    2094:	89 2b       	or	r24, r25
    2096:	59 f0       	breq	.+22     	; 0x20ae <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    2098:	61 2f       	mov	r22, r17
    209a:	ce 01       	movw	r24, r28
    209c:	05 96       	adiw	r24, 0x05	; 5
    209e:	0e 94 be 0c 	call	0x197c	; 0x197c <chIQPutI>
    20a2:	97 fd       	sbrc	r25, 7
    20a4:	10 c0       	rjmp	.+32     	; 0x20c6 <sdIncomingDataI+0x40>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
    20a6:	df 91       	pop	r29
    20a8:	cf 91       	pop	r28
    20aa:	1f 91       	pop	r17
    20ac:	08 95       	ret

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    20ae:	64 e0       	ldi	r22, 0x04	; 4
    20b0:	ce 01       	movw	r24, r28
    20b2:	02 96       	adiw	r24, 0x02	; 2
    20b4:	0e 94 87 09 	call	0x130e	; 0x130e <chEvtBroadcastFlagsI>
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    20b8:	61 2f       	mov	r22, r17
    20ba:	ce 01       	movw	r24, r28
    20bc:	05 96       	adiw	r24, 0x05	; 5
    20be:	0e 94 be 0c 	call	0x197c	; 0x197c <chIQPutI>
    20c2:	97 ff       	sbrs	r25, 7
    20c4:	f0 cf       	rjmp	.-32     	; 0x20a6 <sdIncomingDataI+0x20>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    20c6:	60 e8       	ldi	r22, 0x80	; 128
    20c8:	ce 01       	movw	r24, r28
    20ca:	02 96       	adiw	r24, 0x02	; 2
}
    20cc:	df 91       	pop	r29
    20ce:	cf 91       	pop	r28
    20d0:	1f 91       	pop	r17
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    20d2:	0c 94 87 09 	jmp	0x130e	; 0x130e <chEvtBroadcastFlagsI>

000020d6 <sdRequestDataI>:
 * @retval Q_EMPTY      if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    20d6:	0f 93       	push	r16
    20d8:	1f 93       	push	r17
    20da:	cf 93       	push	r28
    20dc:	df 93       	push	r29
    20de:	8c 01       	movw	r16, r24
  msg_t  b;

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdRequestDataI");

  b = chOQGetI(&sdp->oqueue);
    20e0:	47 96       	adiw	r24, 0x17	; 23
    20e2:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <chOQGetI>
    20e6:	ec 01       	movw	r28, r24
  if (b < Q_OK)
    20e8:	97 fd       	sbrc	r25, 7
    20ea:	06 c0       	rjmp	.+12     	; 0x20f8 <sdRequestDataI+0x22>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
    20ec:	ce 01       	movw	r24, r28
    20ee:	df 91       	pop	r29
    20f0:	cf 91       	pop	r28
    20f2:	1f 91       	pop	r17
    20f4:	0f 91       	pop	r16
    20f6:	08 95       	ret
  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdRequestDataI");

  b = chOQGetI(&sdp->oqueue);
  if (b < Q_OK)
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    20f8:	68 e0       	ldi	r22, 0x08	; 8
    20fa:	c8 01       	movw	r24, r16
    20fc:	02 96       	adiw	r24, 0x02	; 2
    20fe:	0e 94 87 09 	call	0x130e	; 0x130e <chEvtBroadcastFlagsI>
  return b;
}
    2102:	ce 01       	movw	r24, r28
    2104:	df 91       	pop	r29
    2106:	cf 91       	pop	r28
    2108:	1f 91       	pop	r17
    210a:	0f 91       	pop	r16
    210c:	08 95       	ret

0000210e <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    210e:	0c 94 72 17 	jmp	0x2ee4	; 0x2ee4 <spi_lld_init>

00002112 <spiObjectInit>:
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
    2112:	21 e0       	ldi	r18, 0x01	; 1
    2114:	fc 01       	movw	r30, r24
    2116:	20 83       	st	Z, r18
  spip->config = NULL;
    2118:	12 82       	std	Z+2, r1	; 0x02
    211a:	11 82       	std	Z+1, r1	; 0x01
#if SPI_USE_WAIT
  spip->thread = NULL;
    211c:	14 82       	std	Z+4, r1	; 0x04
    211e:	13 82       	std	Z+3, r1	; 0x03
#endif /* SPI_USE_WAIT */
#if SPI_USE_MUTUAL_EXCLUSION
#if CH_USE_MUTEXES
  chMtxInit(&spip->mutex);
    2120:	05 96       	adiw	r24, 0x05	; 5
    2122:	0c 94 3e 06 	jmp	0xc7c	; 0xc7c <chMtxInit>

00002126 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    2126:	cf 93       	push	r28
    2128:	df 93       	push	r29
    212a:	ec 01       	movw	r28, r24

  chDbgCheck((spip != NULL) && (config != NULL), "spiStart");

  chSysLock();
    212c:	f8 94       	cli
  chDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
    212e:	88 81       	ld	r24, Y
    2130:	81 30       	cpi	r24, 0x01	; 1
    2132:	09 f0       	breq	.+2      	; 0x2136 <spiStart+0x10>
    2134:	88 81       	ld	r24, Y
              "spiStart(), #1", "invalid state");
  spip->config = config;
    2136:	7a 83       	std	Y+2, r23	; 0x02
    2138:	69 83       	std	Y+1, r22	; 0x01
  spi_lld_start(spip);
    213a:	ce 01       	movw	r24, r28
    213c:	0e 94 76 17 	call	0x2eec	; 0x2eec <spi_lld_start>
  spip->state = SPI_READY;
    2140:	82 e0       	ldi	r24, 0x02	; 2
    2142:	88 83       	st	Y, r24
  chSysUnlock();
    2144:	78 94       	sei
}
    2146:	df 91       	pop	r29
    2148:	cf 91       	pop	r28
    214a:	08 95       	ret

0000214c <spiStop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiStop(SPIDriver *spip) {
    214c:	cf 93       	push	r28
    214e:	df 93       	push	r29
    2150:	ec 01       	movw	r28, r24

  chDbgCheck(spip != NULL, "spiStop");

  chSysLock();
    2152:	f8 94       	cli
  chDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
    2154:	88 81       	ld	r24, Y
    2156:	81 30       	cpi	r24, 0x01	; 1
    2158:	09 f0       	breq	.+2      	; 0x215c <spiStop+0x10>
    215a:	88 81       	ld	r24, Y
              "spiStop(), #1", "invalid state");
  spi_lld_unselect(spip);
    215c:	ce 01       	movw	r24, r28
    215e:	0e 94 a9 17 	call	0x2f52	; 0x2f52 <spi_lld_unselect>
  spi_lld_stop(spip);
    2162:	ce 01       	movw	r24, r28
    2164:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <spi_lld_stop>
  spip->state = SPI_STOP;
    2168:	81 e0       	ldi	r24, 0x01	; 1
    216a:	88 83       	st	Y, r24
  chSysUnlock();
    216c:	78 94       	sei
}
    216e:	df 91       	pop	r29
    2170:	cf 91       	pop	r28
    2172:	08 95       	ret

00002174 <spiSelect>:
 */
void spiSelect(SPIDriver *spip) {

  chDbgCheck(spip != NULL, "spiSelect");

  chSysLock();
    2174:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiSelect(), #1", "not ready");
    2176:	fc 01       	movw	r30, r24
    2178:	20 81       	ld	r18, Z
  spiSelectI(spip);
    217a:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <spi_lld_select>
  chSysUnlock();
    217e:	78 94       	sei
    2180:	08 95       	ret

00002182 <spiUnselect>:
 */
void spiUnselect(SPIDriver *spip) {

  chDbgCheck(spip != NULL, "spiUnselect");

  chSysLock();
    2182:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiUnselect(), #1", "not ready");
    2184:	fc 01       	movw	r30, r24
    2186:	20 81       	ld	r18, Z
  spiUnselectI(spip);
    2188:	0e 94 a9 17 	call	0x2f52	; 0x2f52 <spi_lld_unselect>
  chSysUnlock();
    218c:	78 94       	sei
    218e:	08 95       	ret

00002190 <spiStartIgnore>:
 */
void spiStartIgnore(SPIDriver *spip, size_t n) {

  chDbgCheck((spip != NULL) && (n > 0), "spiStartIgnore");

  chSysLock();
    2190:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiStartIgnore(), #1", "not ready");
    2192:	fc 01       	movw	r30, r24
    2194:	20 81       	ld	r18, Z
  spiStartIgnoreI(spip, n);
    2196:	23 e0       	ldi	r18, 0x03	; 3
    2198:	20 83       	st	Z, r18
    219a:	0e 94 b0 17 	call	0x2f60	; 0x2f60 <spi_lld_ignore>
  chSysUnlock();
    219e:	78 94       	sei
    21a0:	08 95       	ret

000021a2 <spiStartExchange>:
                      const void *txbuf, void *rxbuf) {

  chDbgCheck((spip != NULL) && (n > 0) && (rxbuf != NULL) && (txbuf != NULL),
             "spiStartExchange");

  chSysLock();
    21a2:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiStartExchange(), #1", "not ready");
    21a4:	dc 01       	movw	r26, r24
    21a6:	ec 91       	ld	r30, X
  spiStartExchangeI(spip, n, txbuf, rxbuf);
    21a8:	e3 e0       	ldi	r30, 0x03	; 3
    21aa:	ec 93       	st	X, r30
    21ac:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <spi_lld_exchange>
  chSysUnlock();
    21b0:	78 94       	sei
    21b2:	08 95       	ret

000021b4 <spiStartSend>:
void spiStartSend(SPIDriver *spip, size_t n, const void *txbuf) {

  chDbgCheck((spip != NULL) && (n > 0) && (txbuf != NULL),
             "spiStartSend");

  chSysLock();
    21b4:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiStartSend(), #1", "not ready");
    21b6:	fc 01       	movw	r30, r24
    21b8:	20 81       	ld	r18, Z
  spiStartSendI(spip, n, txbuf);
    21ba:	23 e0       	ldi	r18, 0x03	; 3
    21bc:	20 83       	st	Z, r18
    21be:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <spi_lld_send>
  chSysUnlock();
    21c2:	78 94       	sei
    21c4:	08 95       	ret

000021c6 <spiStartReceive>:
void spiStartReceive(SPIDriver *spip, size_t n, void *rxbuf) {

  chDbgCheck((spip != NULL) && (n > 0) && (rxbuf != NULL),
             "spiStartReceive");

  chSysLock();
    21c6:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiStartReceive(), #1", "not ready");
    21c8:	fc 01       	movw	r30, r24
    21ca:	20 81       	ld	r18, Z
  spiStartReceiveI(spip, n, rxbuf);
    21cc:	23 e0       	ldi	r18, 0x03	; 3
    21ce:	20 83       	st	Z, r18
    21d0:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <spi_lld_receive>
  chSysUnlock();
    21d4:	78 94       	sei
    21d6:	08 95       	ret

000021d8 <spiIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiIgnore(SPIDriver *spip, size_t n) {
    21d8:	cf 93       	push	r28
    21da:	df 93       	push	r29
    21dc:	ec 01       	movw	r28, r24

  chDbgCheck((spip != NULL) && (n > 0), "spiIgnoreWait");

  chSysLock();
    21de:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiIgnore(), #1", "not ready");
    21e0:	88 81       	ld	r24, Y
  chDbgAssert(spip->config->end_cb == NULL, "spiIgnore(), #2", "has callback");
  spiStartIgnoreI(spip, n);
    21e2:	83 e0       	ldi	r24, 0x03	; 3
    21e4:	88 83       	st	Y, r24
    21e6:	ce 01       	movw	r24, r28
    21e8:	0e 94 b0 17 	call	0x2f60	; 0x2f60 <spi_lld_ignore>
  _spi_wait_s(spip);
    21ec:	80 91 3a 02 	lds	r24, 0x023A
    21f0:	90 91 3b 02 	lds	r25, 0x023B
    21f4:	9c 83       	std	Y+4, r25	; 0x04
    21f6:	8b 83       	std	Y+3, r24	; 0x03
    21f8:	82 e0       	ldi	r24, 0x02	; 2
    21fa:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
  chSysUnlock();
    21fe:	78 94       	sei
}
    2200:	df 91       	pop	r29
    2202:	cf 91       	pop	r28
    2204:	08 95       	ret

00002206 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
    2206:	cf 93       	push	r28
    2208:	df 93       	push	r29
    220a:	ec 01       	movw	r28, r24

  chDbgCheck((spip != NULL) && (n > 0) && (rxbuf != NULL) && (txbuf != NULL),
             "spiExchange");

  chSysLock();
    220c:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiExchange(), #1", "not ready");
    220e:	88 81       	ld	r24, Y
  chDbgAssert(spip->config->end_cb == NULL,
              "spiExchange(), #2", "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
    2210:	83 e0       	ldi	r24, 0x03	; 3
    2212:	88 83       	st	Y, r24
    2214:	ce 01       	movw	r24, r28
    2216:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <spi_lld_exchange>
  _spi_wait_s(spip);
    221a:	80 91 3a 02 	lds	r24, 0x023A
    221e:	90 91 3b 02 	lds	r25, 0x023B
    2222:	9c 83       	std	Y+4, r25	; 0x04
    2224:	8b 83       	std	Y+3, r24	; 0x03
    2226:	82 e0       	ldi	r24, 0x02	; 2
    2228:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
  chSysUnlock();
    222c:	78 94       	sei
}
    222e:	df 91       	pop	r29
    2230:	cf 91       	pop	r28
    2232:	08 95       	ret

00002234 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
    2234:	cf 93       	push	r28
    2236:	df 93       	push	r29
    2238:	ec 01       	movw	r28, r24

  chDbgCheck((spip != NULL) && (n > 0) && (txbuf != NULL), "spiSend");

  chSysLock();
    223a:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiSend(), #1", "not ready");
    223c:	88 81       	ld	r24, Y
  chDbgAssert(spip->config->end_cb == NULL, "spiSend(), #2", "has callback");
  spiStartSendI(spip, n, txbuf);
    223e:	83 e0       	ldi	r24, 0x03	; 3
    2240:	88 83       	st	Y, r24
    2242:	ce 01       	movw	r24, r28
    2244:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <spi_lld_send>
  _spi_wait_s(spip);
    2248:	80 91 3a 02 	lds	r24, 0x023A
    224c:	90 91 3b 02 	lds	r25, 0x023B
    2250:	9c 83       	std	Y+4, r25	; 0x04
    2252:	8b 83       	std	Y+3, r24	; 0x03
    2254:	82 e0       	ldi	r24, 0x02	; 2
    2256:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
  chSysUnlock();
    225a:	78 94       	sei
}
    225c:	df 91       	pop	r29
    225e:	cf 91       	pop	r28
    2260:	08 95       	ret

00002262 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
    2262:	cf 93       	push	r28
    2264:	df 93       	push	r29
    2266:	ec 01       	movw	r28, r24

  chDbgCheck((spip != NULL) && (n > 0) && (rxbuf != NULL),
             "spiReceive");

  chSysLock();
    2268:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiReceive(), #1", "not ready");
    226a:	88 81       	ld	r24, Y
  chDbgAssert(spip->config->end_cb == NULL,
              "spiReceive(), #2", "has callback");
  spiStartReceiveI(spip, n, rxbuf);
    226c:	83 e0       	ldi	r24, 0x03	; 3
    226e:	88 83       	st	Y, r24
    2270:	ce 01       	movw	r24, r28
    2272:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <spi_lld_receive>
  _spi_wait_s(spip);
    2276:	80 91 3a 02 	lds	r24, 0x023A
    227a:	90 91 3b 02 	lds	r25, 0x023B
    227e:	9c 83       	std	Y+4, r25	; 0x04
    2280:	8b 83       	std	Y+3, r24	; 0x03
    2282:	82 e0       	ldi	r24, 0x02	; 2
    2284:	0e 94 56 02 	call	0x4ac	; 0x4ac <chSchGoSleepS>
  chSysUnlock();
    2288:	78 94       	sei
}
    228a:	df 91       	pop	r29
    228c:	cf 91       	pop	r28
    228e:	08 95       	ret

00002290 <spiAcquireBus>:
void spiAcquireBus(SPIDriver *spip) {

  chDbgCheck(spip != NULL, "spiAcquireBus");

#if CH_USE_MUTEXES
  chMtxLock(&spip->mutex);
    2290:	05 96       	adiw	r24, 0x05	; 5
    2292:	0c 94 06 07 	jmp	0xe0c	; 0xe0c <chMtxLock>

00002296 <spiReleaseBus>:

  chDbgCheck(spip != NULL, "spiReleaseBus");

#if CH_USE_MUTEXES
  (void)spip;
  chMtxUnlock();
    2296:	0c 94 44 07 	jmp	0xe88	; 0xe88 <chMtxUnlock>

0000229a <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
    229a:	cf 93       	push	r28
     /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
    229c:	10 92 69 00 	sts	0x0069, r1
#ifdef EICRB
  EICRB  = 0x00;
#endif
  EIMSK  = 0x00;
    22a0:	1d ba       	out	0x1d, r1	; 29

  /*
   * Timer 0 setup.
   */
  TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.        */
    22a2:	c2 e0       	ldi	r28, 0x02	; 2
    22a4:	c4 bd       	out	0x24, r28	; 36
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.   */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.   */
  TCCR0B  = (0 << WGM02) ;				 /* CTC mode.        */
    22a6:	15 bc       	out	0x25, r1	; 37


static void setClock()
{
  
  uint8_t prescaler_index = findBestPrescaler(CH_FREQUENCY,ratio_base,clock_source_base,PRESCALER_SIZE_BASE);
    22a8:	25 e0       	ldi	r18, 0x05	; 5
    22aa:	45 e4       	ldi	r20, 0x45	; 69
    22ac:	51 e0       	ldi	r21, 0x01	; 1
    22ae:	6a e4       	ldi	r22, 0x4A	; 74
    22b0:	71 e0       	ldi	r23, 0x01	; 1
    22b2:	81 e7       	ldi	r24, 0x71	; 113
    22b4:	92 e0       	ldi	r25, 0x02	; 2
    22b6:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <findBestPrescaler>
  
  TCCR0B &= ~((1 << CS02)  | (1 << CS01)  | (1 << CS00));
    22ba:	95 b5       	in	r25, 0x25	; 37
    22bc:	98 7f       	andi	r25, 0xF8	; 248
    22be:	95 bd       	out	0x25, r25	; 37
  TCCR0B |=((clock_source_base[prescaler_index] & 0x07)<<CS00);
    22c0:	95 b5       	in	r25, 0x25	; 37
    22c2:	e8 2f       	mov	r30, r24
    22c4:	f0 e0       	ldi	r31, 0x00	; 0
    22c6:	df 01       	movw	r26, r30
    22c8:	ab 5b       	subi	r26, 0xBB	; 187
    22ca:	be 4f       	sbci	r27, 0xFE	; 254
    22cc:	8c 91       	ld	r24, X
    22ce:	87 70       	andi	r24, 0x07	; 7
    22d0:	89 2b       	or	r24, r25
    22d2:	85 bd       	out	0x25, r24	; 37
  OCR0A   = F_CPU / ratio_base[prescaler_index] /CH_FREQUENCY - 1;
    22d4:	ee 0f       	add	r30, r30
    22d6:	ff 1f       	adc	r31, r31
    22d8:	e6 5b       	subi	r30, 0xB6	; 182
    22da:	fe 4f       	sbci	r31, 0xFE	; 254
    22dc:	20 81       	ld	r18, Z
    22de:	31 81       	ldd	r19, Z+1	; 0x01
    22e0:	40 e0       	ldi	r20, 0x00	; 0
    22e2:	50 e0       	ldi	r21, 0x00	; 0
    22e4:	60 e0       	ldi	r22, 0x00	; 0
    22e6:	74 e6       	ldi	r23, 0x64	; 100
    22e8:	80 e0       	ldi	r24, 0x00	; 0
    22ea:	90 e0       	ldi	r25, 0x00	; 0
    22ec:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <__udivmodsi4>
    22f0:	21 50       	subi	r18, 0x01	; 1
    22f2:	27 bd       	out	0x27, r18	; 39
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.   */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.   */
  TCCR0B  = (0 << WGM02) ;				 /* CTC mode.        */
             setClock();  			 
  
  TCNT0   = 0;                                           /* Reset counter.   */
    22f4:	16 bc       	out	0x26, r1	; 38
  TIFR0   = (1 << OCF0A);                                /* Reset pending.   */
    22f6:	c5 bb       	out	0x15, r28	; 21
  TIMSK0  = (1 << OCIE0A);  
    22f8:	c0 93 6e 00 	sts	0x006E, r28
}
    22fc:	cf 91       	pop	r28
    22fe:	08 95       	ret

00002300 <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    2300:	fc 01       	movw	r30, r24
  PORTA = config->porta.out;
  DDRA = config->porta.dir;
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
    2302:	80 81       	ld	r24, Z
    2304:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
    2306:	81 81       	ldd	r24, Z+1	; 0x01
    2308:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
    230a:	82 81       	ldd	r24, Z+2	; 0x02
    230c:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
    230e:	83 81       	ldd	r24, Z+3	; 0x03
    2310:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
    2312:	84 81       	ldd	r24, Z+4	; 0x04
    2314:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
    2316:	85 81       	ldd	r24, Z+5	; 0x05
    2318:	8a b9       	out	0x0a, r24	; 10
    231a:	08 95       	ret

0000231c <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    231c:	fc 01       	movw	r30, r24

  switch (mode) {
    231e:	42 30       	cpi	r20, 0x02	; 2
    2320:	91 f0       	breq	.+36     	; 0x2346 <_pal_lld_setgroupmode+0x2a>
    2322:	78 f0       	brcs	.+30     	; 0x2342 <_pal_lld_setgroupmode+0x26>
    2324:	45 30       	cpi	r20, 0x05	; 5
    2326:	79 f0       	breq	.+30     	; 0x2346 <_pal_lld_setgroupmode+0x2a>
    2328:	46 30       	cpi	r20, 0x06	; 6
    232a:	a9 f0       	breq	.+42     	; 0x2356 <_pal_lld_setgroupmode+0x3a>
    232c:	43 30       	cpi	r20, 0x03	; 3
    232e:	b1 f4       	brne	.+44     	; 0x235c <_pal_lld_setgroupmode+0x40>
    port->dir &= ~mask;
    port->out &= ~mask;
	break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    2330:	91 81       	ldd	r25, Z+1	; 0x01
    2332:	86 2f       	mov	r24, r22
    2334:	80 95       	com	r24
    2336:	89 23       	and	r24, r25
    2338:	81 83       	std	Z+1, r24	; 0x01
    port->out |= mask;
    233a:	82 81       	ldd	r24, Z+2	; 0x02
    233c:	86 2b       	or	r24, r22
    233e:	82 83       	std	Z+2, r24	; 0x02
    break;
    2340:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
    2342:	41 11       	cpse	r20, r1
    2344:	0c c0       	rjmp	.+24     	; 0x235e <_pal_lld_setgroupmode+0x42>
  case PAL_MODE_RESET:
  case PAL_MODE_INPUT:
  case PAL_MODE_INPUT_ANALOG:
    port->dir &= ~mask;
    2346:	81 81       	ldd	r24, Z+1	; 0x01
    2348:	60 95       	com	r22
    234a:	86 23       	and	r24, r22
    234c:	81 83       	std	Z+1, r24	; 0x01
    port->out &= ~mask;
    234e:	82 81       	ldd	r24, Z+2	; 0x02
    2350:	86 23       	and	r24, r22
    2352:	82 83       	std	Z+2, r24	; 0x02
	break;
    2354:	08 95       	ret
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    port->out |= mask;
    break;
  case PAL_MODE_OUTPUT_PUSHPULL:
    port->dir |= mask;
    2356:	81 81       	ldd	r24, Z+1	; 0x01
    2358:	86 2b       	or	r24, r22
    235a:	81 83       	std	Z+1, r24	; 0x01
    235c:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
    235e:	41 30       	cpi	r20, 0x01	; 1
    2360:	39 f3       	breq	.-50     	; 0x2330 <_pal_lld_setgroupmode+0x14>
    2362:	08 95       	ret

00002364 <notify1>:

#if USE_AVR_USART0 || defined(__DOXYGEN__)
static void notify1(GenericQueue *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
    2364:	e1 ec       	ldi	r30, 0xC1	; 193
    2366:	f0 e0       	ldi	r31, 0x00	; 0
    2368:	80 81       	ld	r24, Z
    236a:	80 62       	ori	r24, 0x20	; 32
    236c:	80 83       	st	Z, r24
    236e:	08 95       	ret

00002370 <__vector_18>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(USART0_RX_vect) {
    2370:	1f 92       	push	r1
    2372:	0f 92       	push	r0
    2374:	0f b6       	in	r0, 0x3f	; 63
    2376:	0f 92       	push	r0
    2378:	11 24       	eor	r1, r1
    237a:	2f 93       	push	r18
    237c:	3f 93       	push	r19
    237e:	4f 93       	push	r20
    2380:	5f 93       	push	r21
    2382:	6f 93       	push	r22
    2384:	7f 93       	push	r23
    2386:	8f 93       	push	r24
    2388:	9f 93       	push	r25
    238a:	af 93       	push	r26
    238c:	bf 93       	push	r27
    238e:	ef 93       	push	r30
    2390:	ff 93       	push	r31
  uint8_t sra;

  CH_IRQ_PROLOGUE();

  sra = UCSR0A;
    2392:	80 91 c0 00 	lds	r24, 0x00C0
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    2396:	98 2f       	mov	r25, r24
    2398:	9c 71       	andi	r25, 0x1C	; 28
    239a:	e1 f4       	brne	.+56     	; 0x23d4 <__vector_18+0x64>
    set_error(sra, &SD1);
  chSysLockFromIsr();
  sdIncomingDataI(&SD1, UDR0);
    239c:	60 91 c6 00 	lds	r22, 0x00C6
    23a0:	8c e3       	ldi	r24, 0x3C	; 60
    23a2:	92 e0       	ldi	r25, 0x02	; 2
    23a4:	0e 94 43 10 	call	0x2086	; 0x2086 <sdIncomingDataI>
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
    23a8:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
    23ac:	81 11       	cpse	r24, r1
    23ae:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
    23b2:	ff 91       	pop	r31
    23b4:	ef 91       	pop	r30
    23b6:	bf 91       	pop	r27
    23b8:	af 91       	pop	r26
    23ba:	9f 91       	pop	r25
    23bc:	8f 91       	pop	r24
    23be:	7f 91       	pop	r23
    23c0:	6f 91       	pop	r22
    23c2:	5f 91       	pop	r21
    23c4:	4f 91       	pop	r20
    23c6:	3f 91       	pop	r19
    23c8:	2f 91       	pop	r18
    23ca:	0f 90       	pop	r0
    23cc:	0f be       	out	0x3f, r0	; 63
    23ce:	0f 90       	pop	r0
    23d0:	1f 90       	pop	r1
    23d2:	18 95       	reti
    upe = (1 << UPE1);
    fe = (1 << FE1);
  }
#endif

  if (sra & dor)
    23d4:	83 fd       	sbrc	r24, 3
    23d6:	0a c0       	rjmp	.+20     	; 0x23ec <__vector_18+0x7c>
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void set_error(uint8_t sra, SerialDriver *sdp) {
  flagsmask_t sts = 0;
    23d8:	60 e0       	ldi	r22, 0x00	; 0
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    23da:	82 fd       	sbrc	r24, 2
    sts |= SD_PARITY_ERROR;
    23dc:	60 62       	ori	r22, 0x20	; 32
  if (sra & fe)
    23de:	84 fd       	sbrc	r24, 4
    sts |= SD_FRAMING_ERROR;
    23e0:	60 64       	ori	r22, 0x40	; 64
  chSysLockFromIsr();
  chnAddFlagsI(sdp, sts);
    23e2:	8e e3       	ldi	r24, 0x3E	; 62
    23e4:	92 e0       	ldi	r25, 0x02	; 2
    23e6:	0e 94 87 09 	call	0x130e	; 0x130e <chEvtBroadcastFlagsI>
    23ea:	d8 cf       	rjmp	.-80     	; 0x239c <__vector_18+0x2c>
    fe = (1 << FE1);
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
    23ec:	60 e8       	ldi	r22, 0x80	; 128
    23ee:	f5 cf       	rjmp	.-22     	; 0x23da <__vector_18+0x6a>

000023f0 <__vector_19>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(USART0_UDRE_vect) {
    23f0:	1f 92       	push	r1
    23f2:	0f 92       	push	r0
    23f4:	0f b6       	in	r0, 0x3f	; 63
    23f6:	0f 92       	push	r0
    23f8:	11 24       	eor	r1, r1
    23fa:	2f 93       	push	r18
    23fc:	3f 93       	push	r19
    23fe:	4f 93       	push	r20
    2400:	5f 93       	push	r21
    2402:	6f 93       	push	r22
    2404:	7f 93       	push	r23
    2406:	8f 93       	push	r24
    2408:	9f 93       	push	r25
    240a:	af 93       	push	r26
    240c:	bf 93       	push	r27
    240e:	ef 93       	push	r30
    2410:	ff 93       	push	r31
  msg_t b;

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
  b = sdRequestDataI(&SD1);
    2412:	8c e3       	ldi	r24, 0x3C	; 60
    2414:	92 e0       	ldi	r25, 0x02	; 2
    2416:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <sdRequestDataI>
  chSysUnlockFromIsr();
  if (b < Q_OK)
    241a:	97 fd       	sbrc	r25, 7
    241c:	18 c0       	rjmp	.+48     	; 0x244e <__vector_19+0x5e>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
    241e:	80 93 c6 00 	sts	0x00C6, r24

  CH_IRQ_EPILOGUE();
    2422:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
    2426:	81 11       	cpse	r24, r1
    2428:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
    242c:	ff 91       	pop	r31
    242e:	ef 91       	pop	r30
    2430:	bf 91       	pop	r27
    2432:	af 91       	pop	r26
    2434:	9f 91       	pop	r25
    2436:	8f 91       	pop	r24
    2438:	7f 91       	pop	r23
    243a:	6f 91       	pop	r22
    243c:	5f 91       	pop	r21
    243e:	4f 91       	pop	r20
    2440:	3f 91       	pop	r19
    2442:	2f 91       	pop	r18
    2444:	0f 90       	pop	r0
    2446:	0f be       	out	0x3f, r0	; 63
    2448:	0f 90       	pop	r0
    244a:	1f 90       	pop	r1
    244c:	18 95       	reti

  chSysLockFromIsr();
  b = sdRequestDataI(&SD1);
  chSysUnlockFromIsr();
  if (b < Q_OK)
    UCSR0B &= ~(1 << UDRIE0);
    244e:	80 91 c1 00 	lds	r24, 0x00C1
    2452:	8f 7d       	andi	r24, 0xDF	; 223
    2454:	80 93 c1 00 	sts	0x00C1, r24
    2458:	e4 cf       	rjmp	.-56     	; 0x2422 <__vector_19+0x32>

0000245a <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if USE_AVR_USART0
  sdObjectInit(&SD1, NULL, notify1);
    245a:	42 eb       	ldi	r20, 0xB2	; 178
    245c:	51 e1       	ldi	r21, 0x11	; 17
    245e:	60 e0       	ldi	r22, 0x00	; 0
    2460:	70 e0       	ldi	r23, 0x00	; 0
    2462:	8c e3       	ldi	r24, 0x3C	; 60
    2464:	92 e0       	ldi	r25, 0x02	; 2
    2466:	0c 94 f4 0f 	jmp	0x1fe8	; 0x1fe8 <sdObjectInit>

0000246a <sd_lld_start>:
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    246a:	61 15       	cp	r22, r1
    246c:	71 05       	cpc	r23, r1
    246e:	e1 f0       	breq	.+56     	; 0x24a8 <sd_lld_start+0x3e>
    config = &default_config;

#if USE_AVR_USART0
  if (&SD1 == sdp) {
    2470:	8c 53       	subi	r24, 0x3C	; 60
    2472:	92 40       	sbci	r25, 0x02	; 2
    2474:	09 f0       	breq	.+2      	; 0x2478 <sd_lld_start+0xe>
    2476:	08 95       	ret
 *
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart0_init(const SerialConfig *config) {

  UBRR0L = config->sc_brr;
    2478:	fb 01       	movw	r30, r22
    247a:	80 81       	ld	r24, Z
    247c:	80 93 c4 00 	sts	0x00C4, r24
  UBRR0H = config->sc_brr >> 8;
    2480:	81 81       	ldd	r24, Z+1	; 0x01
    2482:	80 93 c5 00 	sts	0x00C5, r24
  UCSR0A = 0;
    2486:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    248a:	88 e9       	ldi	r24, 0x98	; 152
    248c:	80 93 c1 00 	sts	0x00C1, r24
  switch (config->sc_bits_per_char) {
    2490:	82 81       	ldd	r24, Z+2	; 0x02
    2492:	81 30       	cpi	r24, 0x01	; 1
    2494:	79 f0       	breq	.+30     	; 0x24b4 <sd_lld_start+0x4a>
    2496:	58 f0       	brcs	.+22     	; 0x24ae <sd_lld_start+0x44>
    2498:	82 30       	cpi	r24, 0x02	; 2
    249a:	c9 f0       	breq	.+50     	; 0x24ce <sd_lld_start+0x64>
    249c:	84 30       	cpi	r24, 0x04	; 4
    249e:	71 f0       	breq	.+28     	; 0x24bc <sd_lld_start+0x52>
    UCSR0B |= (1 << UCSZ02);
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_8:
  default:
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    24a0:	86 e0       	ldi	r24, 0x06	; 6
    24a2:	80 93 c2 00 	sts	0x00C2, r24
    24a6:	08 95       	ret
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
    24a8:	6a e7       	ldi	r22, 0x7A	; 122
    24aa:	71 e0       	ldi	r23, 0x01	; 1
    24ac:	e1 cf       	rjmp	.-62     	; 0x2470 <sd_lld_start+0x6>
  UBRR0H = config->sc_brr >> 8;
  UCSR0A = 0;
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
  switch (config->sc_bits_per_char) {
  case USART_CHAR_SIZE_5:
    UCSR0C = 0;
    24ae:	10 92 c2 00 	sts	0x00C2, r1
    24b2:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    UCSR0C = (1 << UCSZ00);
    24b4:	82 e0       	ldi	r24, 0x02	; 2
    24b6:	80 93 c2 00 	sts	0x00C2, r24
    24ba:	08 95       	ret
    break;
  case USART_CHAR_SIZE_7:
    UCSR0C = (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_9:
    UCSR0B |= (1 << UCSZ02);
    24bc:	80 91 c1 00 	lds	r24, 0x00C1
    24c0:	84 60       	ori	r24, 0x04	; 4
    24c2:	80 93 c1 00 	sts	0x00C1, r24
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    24c6:	86 e0       	ldi	r24, 0x06	; 6
    24c8:	80 93 c2 00 	sts	0x00C2, r24
    24cc:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    UCSR0C = (1 << UCSZ00);
    break;
  case USART_CHAR_SIZE_7:
    UCSR0C = (1 << UCSZ01);
    24ce:	84 e0       	ldi	r24, 0x04	; 4
    24d0:	80 93 c2 00 	sts	0x00C2, r24
    24d4:	08 95       	ret

000024d6 <sd_lld_stop>:
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {

#if USE_AVR_USART0
  if (&SD1 == sdp)
    24d6:	8c 53       	subi	r24, 0x3C	; 60
    24d8:	92 40       	sbci	r25, 0x02	; 2
    24da:	09 f0       	breq	.+2      	; 0x24de <sd_lld_stop+0x8>
    24dc:	08 95       	ret
/**
 * @brief   USART0 de-initialization.
 */
static void usart0_deinit(void) {

  UCSR0A = 0;
    24de:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = 0;
    24e2:	10 92 c1 00 	sts	0x00C1, r1
  UCSR0C = 0;
    24e6:	10 92 c2 00 	sts	0x00C2, r1
    24ea:	08 95       	ret

000024ec <__vector_21>:
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

#include <util/delay.h>

CH_IRQ_HANDLER(ADC_vect) {
    24ec:	1f 92       	push	r1
    24ee:	0f 92       	push	r0
    24f0:	0f b6       	in	r0, 0x3f	; 63
    24f2:	0f 92       	push	r0
    24f4:	11 24       	eor	r1, r1
    24f6:	af 92       	push	r10
    24f8:	bf 92       	push	r11
    24fa:	cf 92       	push	r12
    24fc:	df 92       	push	r13
    24fe:	ef 92       	push	r14
    2500:	ff 92       	push	r15
    2502:	0f 93       	push	r16
    2504:	1f 93       	push	r17
    2506:	2f 93       	push	r18
    2508:	3f 93       	push	r19
    250a:	4f 93       	push	r20
    250c:	5f 93       	push	r21
    250e:	6f 93       	push	r22
    2510:	7f 93       	push	r23
    2512:	8f 93       	push	r24
    2514:	9f 93       	push	r25
    2516:	af 93       	push	r26
    2518:	bf 93       	push	r27
    251a:	cf 93       	push	r28
    251c:	df 93       	push	r29
    251e:	ef 93       	push	r30
    2520:	ff 93       	push	r31
 
  CH_IRQ_PROLOGUE();
	uint8_t low = ADCL;
    2522:	20 91 78 00 	lds	r18, 0x0078
	uint8_t high = ADCH;
    2526:	30 91 79 00 	lds	r19, 0x0079
	uint16_t result = (high << 8) | low;
	
	ADCD1.samples[ADCD1.currentBufferPosition] = result;
    252a:	e0 90 88 02 	lds	r14, 0x0288
    252e:	f0 90 89 02 	lds	r15, 0x0289
    2532:	e0 91 98 02 	lds	r30, 0x0298
    2536:	f0 91 99 02 	lds	r31, 0x0299
    253a:	ee 0f       	add	r30, r30
    253c:	ff 1f       	adc	r31, r31
    253e:	ee 0d       	add	r30, r14
    2540:	ff 1d       	adc	r31, r15
CH_IRQ_HANDLER(ADC_vect) {
 
  CH_IRQ_PROLOGUE();
	uint8_t low = ADCL;
	uint8_t high = ADCH;
	uint16_t result = (high << 8) | low;
    2542:	93 2f       	mov	r25, r19
    2544:	80 e0       	ldi	r24, 0x00	; 0
    2546:	82 2b       	or	r24, r18
	
	ADCD1.samples[ADCD1.currentBufferPosition] = result;
    2548:	91 83       	std	Z+1, r25	; 0x01
    254a:	80 83       	st	Z, r24
	ADCD1.currentBufferPosition++;
    254c:	20 91 98 02 	lds	r18, 0x0298
    2550:	30 91 99 02 	lds	r19, 0x0299
    2554:	2f 5f       	subi	r18, 0xFF	; 255
    2556:	3f 4f       	sbci	r19, 0xFF	; 255
    2558:	30 93 99 02 	sts	0x0299, r19
    255c:	20 93 98 02 	sts	0x0298, r18
	
	size_t bufferSize = ADCD1.depth * ADCD1.grpp->num_channels;
    2560:	e0 91 8a 02 	lds	r30, 0x028A
    2564:	f0 91 8b 02 	lds	r31, 0x028B
    2568:	c0 91 8c 02 	lds	r28, 0x028C
    256c:	d0 91 8d 02 	lds	r29, 0x028D
    2570:	69 81       	ldd	r22, Y+1	; 0x01
    2572:	7a 81       	ldd	r23, Y+2	; 0x02
    2574:	6e 9f       	mul	r22, r30
    2576:	60 01       	movw	r12, r0
    2578:	6f 9f       	mul	r22, r31
    257a:	d0 0c       	add	r13, r0
    257c:	7e 9f       	mul	r23, r30
    257e:	d0 0c       	add	r13, r0
    2580:	11 24       	eor	r1, r1
	size_t currentChannel = ADCD1.currentBufferPosition % ADCD1.grpp->num_channels;
    2582:	c9 01       	movw	r24, r18
    2584:	0e 94 4a 1e 	call	0x3c94	; 0x3c94 <__udivmodhi4>
    2588:	5c 01       	movw	r10, r24
	size_t currentIteration = ADCD1.currentBufferPosition / ADCD1.grpp->num_channels;
	if(ADCD1.grpp-> circular && currentChannel == 0 && currentIteration == ADCD1.depth/2)
    258a:	88 81       	ld	r24, Y
    258c:	88 23       	and	r24, r24
    258e:	21 f0       	breq	.+8      	; 0x2598 <__vector_21+0xac>
    2590:	a1 14       	cp	r10, r1
    2592:	b1 04       	cpc	r11, r1
    2594:	09 f4       	brne	.+2      	; 0x2598 <__vector_21+0xac>
    2596:	3f c0       	rjmp	.+126    	; 0x2616 <__vector_21+0x12a>
	{
	  _adc_isr_half_code(&ADCD1);
	  
	}
	
	if(ADCD1.currentBufferPosition == bufferSize)
    2598:	c2 16       	cp	r12, r18
    259a:	d3 06       	cpc	r13, r19
    259c:	09 f4       	brne	.+2      	; 0x25a0 <__vector_21+0xb4>
    259e:	54 c0       	rjmp	.+168    	; 0x2648 <__vector_21+0x15c>
	  _adc_isr_full_code(&ADCD1);
	}
	else
	{
	  
	  setAdcChannel(getAdcChannelNumberFromMask(ADCD1.grpp->channelsMask,currentChannel));
    25a0:	8d 81       	ldd	r24, Y+5	; 0x05
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t getAdcChannelNumberFromMask(uint8_t mask, uint8_t currentChannel)
{
     for(uint8_t i = 0; mask>0; i++)
    25a2:	88 23       	and	r24, r24
    25a4:	59 f0       	breq	.+22     	; 0x25bc <__vector_21+0xd0>
    25a6:	90 e0       	ldi	r25, 0x00	; 0
     {
	if(mask & 0x01)
    25a8:	80 ff       	sbrs	r24, 0
    25aa:	04 c0       	rjmp	.+8      	; 0x25b4 <__vector_21+0xc8>
	  {
	      if(!currentChannel)
    25ac:	aa 20       	and	r10, r10
    25ae:	09 f4       	brne	.+2      	; 0x25b2 <__vector_21+0xc6>
    25b0:	92 c0       	rjmp	.+292    	; 0x26d6 <__vector_21+0x1ea>
		return i;
	      currentChannel--;
    25b2:	aa 94       	dec	r10
	  }
        mask >>= 1;
    25b4:	86 95       	lsr	r24
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t getAdcChannelNumberFromMask(uint8_t mask, uint8_t currentChannel)
{
     for(uint8_t i = 0; mask>0; i++)
    25b6:	9f 5f       	subi	r25, 0xFF	; 255
    25b8:	81 11       	cpse	r24, r1
    25ba:	f6 cf       	rjmp	.-20     	; 0x25a8 <__vector_21+0xbc>
     /* error, should never reach this line */
}

static void setAdcChannel(uint8_t channelNum)
{
	ADMUX = (ADMUX & 0xf8) | (channelNum & 0x07);
    25bc:	80 91 7c 00 	lds	r24, 0x007C
    25c0:	07 70       	andi	r16, 0x07	; 7
    25c2:	11 27       	eor	r17, r17
    25c4:	88 7f       	andi	r24, 0xF8	; 248
    25c6:	80 2b       	or	r24, r16
    25c8:	80 93 7c 00 	sts	0x007C, r24
	}
	else
	{
	  
	  setAdcChannel(getAdcChannelNumberFromMask(ADCD1.grpp->channelsMask,currentChannel));
	  ADCSRA |= 1<<ADSC;
    25cc:	80 91 7a 00 	lds	r24, 0x007A
    25d0:	80 64       	ori	r24, 0x40	; 64
    25d2:	80 93 7a 00 	sts	0x007A, r24
	}
 
  CH_IRQ_EPILOGUE();
    25d6:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
    25da:	81 11       	cpse	r24, r1
    25dc:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
    25e0:	ff 91       	pop	r31
    25e2:	ef 91       	pop	r30
    25e4:	df 91       	pop	r29
    25e6:	cf 91       	pop	r28
    25e8:	bf 91       	pop	r27
    25ea:	af 91       	pop	r26
    25ec:	9f 91       	pop	r25
    25ee:	8f 91       	pop	r24
    25f0:	7f 91       	pop	r23
    25f2:	6f 91       	pop	r22
    25f4:	5f 91       	pop	r21
    25f6:	4f 91       	pop	r20
    25f8:	3f 91       	pop	r19
    25fa:	2f 91       	pop	r18
    25fc:	1f 91       	pop	r17
    25fe:	0f 91       	pop	r16
    2600:	ff 90       	pop	r15
    2602:	ef 90       	pop	r14
    2604:	df 90       	pop	r13
    2606:	cf 90       	pop	r12
    2608:	bf 90       	pop	r11
    260a:	af 90       	pop	r10
    260c:	0f 90       	pop	r0
    260e:	0f be       	out	0x3f, r0	; 63
    2610:	0f 90       	pop	r0
    2612:	1f 90       	pop	r1
    2614:	18 95       	reti
	ADCD1.currentBufferPosition++;
	
	size_t bufferSize = ADCD1.depth * ADCD1.grpp->num_channels;
	size_t currentChannel = ADCD1.currentBufferPosition % ADCD1.grpp->num_channels;
	size_t currentIteration = ADCD1.currentBufferPosition / ADCD1.grpp->num_channels;
	if(ADCD1.grpp-> circular && currentChannel == 0 && currentIteration == ADCD1.depth/2)
    2616:	af 01       	movw	r20, r30
    2618:	56 95       	lsr	r21
    261a:	47 95       	ror	r20
    261c:	46 17       	cp	r20, r22
    261e:	57 07       	cpc	r21, r23
    2620:	09 f0       	breq	.+2      	; 0x2624 <__vector_21+0x138>
    2622:	ba cf       	rjmp	.-140    	; 0x2598 <__vector_21+0xac>
	{
	  _adc_isr_half_code(&ADCD1);
    2624:	eb 81       	ldd	r30, Y+3	; 0x03
    2626:	fc 81       	ldd	r31, Y+4	; 0x04
    2628:	30 97       	sbiw	r30, 0x00	; 0
    262a:	09 f4       	brne	.+2      	; 0x262e <__vector_21+0x142>
    262c:	b5 cf       	rjmp	.-150    	; 0x2598 <__vector_21+0xac>
    262e:	b7 01       	movw	r22, r14
    2630:	85 e8       	ldi	r24, 0x85	; 133
    2632:	92 e0       	ldi	r25, 0x02	; 2
    2634:	09 95       	icall
    2636:	20 91 98 02 	lds	r18, 0x0298
    263a:	30 91 99 02 	lds	r19, 0x0299
    263e:	c0 91 8c 02 	lds	r28, 0x028C
    2642:	d0 91 8d 02 	lds	r29, 0x028D
    2646:	a8 cf       	rjmp	.-176    	; 0x2598 <__vector_21+0xac>
	  
	}
	
	if(ADCD1.currentBufferPosition == bufferSize)
	{
	  _adc_isr_full_code(&ADCD1);
    2648:	88 81       	ld	r24, Y
    264a:	81 11       	cpse	r24, r1
    264c:	47 c0       	rjmp	.+142    	; 0x26dc <__vector_21+0x1f0>
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
    ADCSRA &= ~(1<<ADSC);
    264e:	80 91 7a 00 	lds	r24, 0x007A
    2652:	8f 7b       	andi	r24, 0xBF	; 191
    2654:	80 93 7a 00 	sts	0x007A, r24
	  
	}
	
	if(ADCD1.currentBufferPosition == bufferSize)
	{
	  _adc_isr_full_code(&ADCD1);
    2658:	eb 81       	ldd	r30, Y+3	; 0x03
    265a:	fc 81       	ldd	r31, Y+4	; 0x04
    265c:	30 97       	sbiw	r30, 0x00	; 0
    265e:	09 f4       	brne	.+2      	; 0x2662 <__vector_21+0x176>
    2660:	60 c0       	rjmp	.+192    	; 0x2722 <__vector_21+0x236>
    2662:	84 e0       	ldi	r24, 0x04	; 4
    2664:	80 93 85 02 	sts	0x0285, r24
    2668:	40 91 8a 02 	lds	r20, 0x028A
    266c:	50 91 8b 02 	lds	r21, 0x028B
    2670:	42 30       	cpi	r20, 0x02	; 2
    2672:	51 05       	cpc	r21, r1
    2674:	08 f4       	brcc	.+2      	; 0x2678 <__vector_21+0x18c>
    2676:	61 c0       	rjmp	.+194    	; 0x273a <__vector_21+0x24e>
    2678:	56 95       	lsr	r21
    267a:	47 95       	ror	r20
    267c:	89 81       	ldd	r24, Y+1	; 0x01
    267e:	9a 81       	ldd	r25, Y+2	; 0x02
    2680:	88 0f       	add	r24, r24
    2682:	99 1f       	adc	r25, r25
    2684:	84 9f       	mul	r24, r20
    2686:	90 01       	movw	r18, r0
    2688:	85 9f       	mul	r24, r21
    268a:	30 0d       	add	r19, r0
    268c:	94 9f       	mul	r25, r20
    268e:	30 0d       	add	r19, r0
    2690:	11 24       	eor	r1, r1
    2692:	60 91 88 02 	lds	r22, 0x0288
    2696:	70 91 89 02 	lds	r23, 0x0289
    269a:	62 0f       	add	r22, r18
    269c:	73 1f       	adc	r23, r19
    269e:	85 e8       	ldi	r24, 0x85	; 133
    26a0:	92 e0       	ldi	r25, 0x02	; 2
    26a2:	09 95       	icall
    26a4:	80 91 85 02 	lds	r24, 0x0285
    26a8:	84 30       	cpi	r24, 0x04	; 4
    26aa:	d9 f1       	breq	.+118    	; 0x2722 <__vector_21+0x236>
    26ac:	10 92 8d 02 	sts	0x028D, r1
    26b0:	10 92 8c 02 	sts	0x028C, r1
    26b4:	80 91 8e 02 	lds	r24, 0x028E
    26b8:	90 91 8f 02 	lds	r25, 0x028F
    26bc:	00 97       	sbiw	r24, 0x00	; 0
    26be:	09 f4       	brne	.+2      	; 0x26c2 <__vector_21+0x1d6>
    26c0:	8a cf       	rjmp	.-236    	; 0x25d6 <__vector_21+0xea>
    26c2:	10 92 8f 02 	sts	0x028F, r1
    26c6:	10 92 8e 02 	sts	0x028E, r1
    26ca:	fc 01       	movw	r30, r24
    26cc:	13 8a       	std	Z+19, r1	; 0x13
    26ce:	12 8a       	std	Z+18, r1	; 0x12
    26d0:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
    26d4:	80 cf       	rjmp	.-256    	; 0x25d6 <__vector_21+0xea>
     for(uint8_t i = 0; mask>0; i++)
     {
	if(mask & 0x01)
	  {
	      if(!currentChannel)
		return i;
    26d6:	09 2f       	mov	r16, r25
    26d8:	10 e0       	ldi	r17, 0x00	; 0
    26da:	70 cf       	rjmp	.-288    	; 0x25bc <__vector_21+0xd0>
	  
	}
	
	if(ADCD1.currentBufferPosition == bufferSize)
	{
	  _adc_isr_full_code(&ADCD1);
    26dc:	eb 81       	ldd	r30, Y+3	; 0x03
    26de:	fc 81       	ldd	r31, Y+4	; 0x04
    26e0:	30 97       	sbiw	r30, 0x00	; 0
    26e2:	09 f4       	brne	.+2      	; 0x26e6 <__vector_21+0x1fa>
    26e4:	78 cf       	rjmp	.-272    	; 0x25d6 <__vector_21+0xea>
    26e6:	40 91 8a 02 	lds	r20, 0x028A
    26ea:	50 91 8b 02 	lds	r21, 0x028B
    26ee:	42 30       	cpi	r20, 0x02	; 2
    26f0:	51 05       	cpc	r21, r1
    26f2:	d8 f0       	brcs	.+54     	; 0x272a <__vector_21+0x23e>
    26f4:	56 95       	lsr	r21
    26f6:	47 95       	ror	r20
    26f8:	89 81       	ldd	r24, Y+1	; 0x01
    26fa:	9a 81       	ldd	r25, Y+2	; 0x02
    26fc:	88 0f       	add	r24, r24
    26fe:	99 1f       	adc	r25, r25
    2700:	84 9f       	mul	r24, r20
    2702:	90 01       	movw	r18, r0
    2704:	85 9f       	mul	r24, r21
    2706:	30 0d       	add	r19, r0
    2708:	94 9f       	mul	r25, r20
    270a:	30 0d       	add	r19, r0
    270c:	11 24       	eor	r1, r1
    270e:	60 91 88 02 	lds	r22, 0x0288
    2712:	70 91 89 02 	lds	r23, 0x0289
    2716:	62 0f       	add	r22, r18
    2718:	73 1f       	adc	r23, r19
    271a:	85 e8       	ldi	r24, 0x85	; 133
    271c:	92 e0       	ldi	r25, 0x02	; 2
    271e:	09 95       	icall
    2720:	5a cf       	rjmp	.-332    	; 0x25d6 <__vector_21+0xea>
    2722:	82 e0       	ldi	r24, 0x02	; 2
    2724:	80 93 85 02 	sts	0x0285, r24
    2728:	c1 cf       	rjmp	.-126    	; 0x26ac <__vector_21+0x1c0>
    272a:	60 91 88 02 	lds	r22, 0x0288
    272e:	70 91 89 02 	lds	r23, 0x0289
    2732:	85 e8       	ldi	r24, 0x85	; 133
    2734:	92 e0       	ldi	r25, 0x02	; 2
    2736:	09 95       	icall
    2738:	4e cf       	rjmp	.-356    	; 0x25d6 <__vector_21+0xea>
    273a:	60 91 88 02 	lds	r22, 0x0288
    273e:	70 91 89 02 	lds	r23, 0x0289
    2742:	85 e8       	ldi	r24, 0x85	; 133
    2744:	92 e0       	ldi	r25, 0x02	; 2
    2746:	09 95       	icall
    2748:	ad cf       	rjmp	.-166    	; 0x26a4 <__vector_21+0x1b8>

0000274a <adc_lld_init>:
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
    adcObjectInit(&ADCD1);
    274a:	85 e8       	ldi	r24, 0x85	; 133
    274c:	92 e0       	ldi	r25, 0x02	; 2
    274e:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <adcObjectInit>
    ADCSRA =(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0) |   //prescaler 128, unico valore possibile a 20Mhz
    2752:	8f e0       	ldi	r24, 0x0F	; 15
    2754:	80 93 7a 00 	sts	0x007A, r24
	     (1<<ADIE) ; 	//interrupt

    ADCSRB=0; //single shot
    2758:	10 92 7b 00 	sts	0x007B, r1
    ADMUX=(0<<REFS1)| (0<<REFS0); //uso aref, vale solo per arduino. arduino ha aref collegato
    275c:	10 92 7c 00 	sts	0x007C, r1
    2760:	08 95       	ret

00002762 <adc_lld_start>:
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  if (adcp->state == ADC_STOP) {
    2762:	dc 01       	movw	r26, r24
    2764:	2c 91       	ld	r18, X
    2766:	21 30       	cpi	r18, 0x01	; 1
    2768:	79 f0       	breq	.+30     	; 0x2788 <adc_lld_start+0x26>
    /* Clock activation.*/
    ADCSRA |= (1<<ADEN);
  }
  
  if (adcp->config != NULL)    
    276a:	dc 01       	movw	r26, r24
    276c:	11 96       	adiw	r26, 0x01	; 1
    276e:	ed 91       	ld	r30, X+
    2770:	fc 91       	ld	r31, X
    2772:	12 97       	sbiw	r26, 0x02	; 2
    2774:	30 97       	sbiw	r30, 0x00	; 0
    2776:	39 f0       	breq	.+14     	; 0x2786 <adc_lld_start+0x24>
  {
      ADMUX = (adcp->config->analog_reference << REFS0);
    2778:	80 81       	ld	r24, Z
    277a:	82 95       	swap	r24
    277c:	88 0f       	add	r24, r24
    277e:	88 0f       	add	r24, r24
    2780:	80 7c       	andi	r24, 0xC0	; 192
    2782:	80 93 7c 00 	sts	0x007C, r24
    2786:	08 95       	ret
 */
void adc_lld_start(ADCDriver *adcp) {

  if (adcp->state == ADC_STOP) {
    /* Clock activation.*/
    ADCSRA |= (1<<ADEN);
    2788:	20 91 7a 00 	lds	r18, 0x007A
    278c:	20 68       	ori	r18, 0x80	; 128
    278e:	20 93 7a 00 	sts	0x007A, r18
    2792:	eb cf       	rjmp	.-42     	; 0x276a <adc_lld_start+0x8>

00002794 <adc_lld_stop>:
 *
 * @notapi
 */
void adc_lld_stop(ADCDriver *adcp) {

  if (adcp->state == ADC_READY) {
    2794:	fc 01       	movw	r30, r24
    2796:	80 81       	ld	r24, Z
    2798:	82 30       	cpi	r24, 0x02	; 2
    279a:	09 f0       	breq	.+2      	; 0x279e <adc_lld_stop+0xa>
    279c:	08 95       	ret
    /* Clock de-activation.*/
    ADCSRA &= ~(1<<ADEN);  
    279e:	80 91 7a 00 	lds	r24, 0x007A
    27a2:	8f 77       	andi	r24, 0x7F	; 127
    27a4:	80 93 7a 00 	sts	0x007A, r24
    27a8:	08 95       	ret

000027aa <adc_lld_start_conversion>:
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
	adcp->currentBufferPosition=0;
    27aa:	dc 01       	movw	r26, r24
    27ac:	54 96       	adiw	r26, 0x14	; 20
    27ae:	1c 92       	st	X, r1
    27b0:	1e 92       	st	-X, r1
    27b2:	53 97       	sbiw	r26, 0x13	; 19
	
	setAdcChannel(getAdcChannelNumberFromMask(adcp->grpp->channelsMask,0));
    27b4:	17 96       	adiw	r26, 0x07	; 7
    27b6:	ed 91       	ld	r30, X+
    27b8:	fc 91       	ld	r31, X
    27ba:	18 97       	sbiw	r26, 0x08	; 8
    27bc:	85 81       	ldd	r24, Z+5	; 0x05
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t getAdcChannelNumberFromMask(uint8_t mask, uint8_t currentChannel)
{
     for(uint8_t i = 0; mask>0; i++)
    27be:	88 23       	and	r24, r24
    27c0:	51 f0       	breq	.+20     	; 0x27d6 <adc_lld_start_conversion+0x2c>
     {
	if(mask & 0x01)
    27c2:	80 fd       	sbrc	r24, 0
    27c4:	1a c0       	rjmp	.+52     	; 0x27fa <adc_lld_start_conversion+0x50>
    27c6:	90 e0       	ldi	r25, 0x00	; 0
    27c8:	02 c0       	rjmp	.+4      	; 0x27ce <adc_lld_start_conversion+0x24>
    27ca:	80 fd       	sbrc	r24, 0
    27cc:	13 c0       	rjmp	.+38     	; 0x27f4 <adc_lld_start_conversion+0x4a>
	  {
	      if(!currentChannel)
		return i;
	      currentChannel--;
	  }
        mask >>= 1;
    27ce:	86 95       	lsr	r24
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t getAdcChannelNumberFromMask(uint8_t mask, uint8_t currentChannel)
{
     for(uint8_t i = 0; mask>0; i++)
    27d0:	9f 5f       	subi	r25, 0xFF	; 255
    27d2:	81 11       	cpse	r24, r1
    27d4:	fa cf       	rjmp	.-12     	; 0x27ca <adc_lld_start_conversion+0x20>
     /* error, should never reach this line */
}

static void setAdcChannel(uint8_t channelNum)
{
	ADMUX = (ADMUX & 0xf8) | (channelNum & 0x07);
    27d6:	40 91 7c 00 	lds	r20, 0x007C
    27da:	c9 01       	movw	r24, r18
    27dc:	87 70       	andi	r24, 0x07	; 7
    27de:	99 27       	eor	r25, r25
    27e0:	48 7f       	andi	r20, 0xF8	; 248
    27e2:	48 2b       	or	r20, r24
    27e4:	40 93 7c 00 	sts	0x007C, r20
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
	adcp->currentBufferPosition=0;
	
	setAdcChannel(getAdcChannelNumberFromMask(adcp->grpp->channelsMask,0));
	ADCSRA |= 1<<ADSC;
    27e8:	80 91 7a 00 	lds	r24, 0x007A
    27ec:	80 64       	ori	r24, 0x40	; 64
    27ee:	80 93 7a 00 	sts	0x007A, r24
    27f2:	08 95       	ret
    27f4:	29 2f       	mov	r18, r25
    27f6:	30 e0       	ldi	r19, 0x00	; 0
    27f8:	ee cf       	rjmp	.-36     	; 0x27d6 <adc_lld_start_conversion+0x2c>

static size_t getAdcChannelNumberFromMask(uint8_t mask, uint8_t currentChannel)
{
     for(uint8_t i = 0; mask>0; i++)
     {
	if(mask & 0x01)
    27fa:	20 e0       	ldi	r18, 0x00	; 0
    27fc:	30 e0       	ldi	r19, 0x00	; 0
    27fe:	eb cf       	rjmp	.-42     	; 0x27d6 <adc_lld_start_conversion+0x2c>

00002800 <adc_lld_stop_conversion>:
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
    ADCSRA &= ~(1<<ADSC);
    2800:	ea e7       	ldi	r30, 0x7A	; 122
    2802:	f0 e0       	ldi	r31, 0x00	; 0
    2804:	80 81       	ld	r24, Z
    2806:	8f 7b       	andi	r24, 0xBF	; 191
    2808:	80 83       	st	Z, r24
    280a:	08 95       	ret

0000280c <getTimerIndex>:

uint8_t getTimerIndex(PWMDriver *gptp)
{
    uint8_t index = 0;
#if USE_AVR_PWM1 || defined(__DOXYGEN__)
    if (gptp == &PWMD1) return index;
    280c:	8f 59       	subi	r24, 0x9F	; 159
    280e:	92 40       	sbci	r25, 0x02	; 2
    2810:	09 f0       	breq	.+2      	; 0x2814 <getTimerIndex+0x8>
    2812:	08 95       	ret
    2814:	80 e0       	ldi	r24, 0x00	; 0
#endif
#if USE_AVR_PWM5 || defined(__DOXYGEN__)
    if (gptp == &PWMD1) return index;
    else index++;
#endif
}
    2816:	08 95       	ret

00002818 <__vector_13>:
 *
 *
 */
#if USE_AVR_PWM1 || defined(__DOXYGEN__)
CH_IRQ_HANDLER(TIMER1_OVF_vect)
{
    2818:	1f 92       	push	r1
    281a:	0f 92       	push	r0
    281c:	0f b6       	in	r0, 0x3f	; 63
    281e:	0f 92       	push	r0
    2820:	11 24       	eor	r1, r1
    2822:	2f 93       	push	r18
    2824:	3f 93       	push	r19
    2826:	4f 93       	push	r20
    2828:	5f 93       	push	r21
    282a:	6f 93       	push	r22
    282c:	7f 93       	push	r23
    282e:	8f 93       	push	r24
    2830:	9f 93       	push	r25
    2832:	af 93       	push	r26
    2834:	bf 93       	push	r27
    2836:	ef 93       	push	r30
    2838:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD1.config->callback(&PWMD1);
    283a:	e0 91 a0 02 	lds	r30, 0x02A0
    283e:	f0 91 a1 02 	lds	r31, 0x02A1
    2842:	06 80       	ldd	r0, Z+6	; 0x06
    2844:	f7 81       	ldd	r31, Z+7	; 0x07
    2846:	e0 2d       	mov	r30, r0
    2848:	8f e9       	ldi	r24, 0x9F	; 159
    284a:	92 e0       	ldi	r25, 0x02	; 2
    284c:	09 95       	icall
    CH_IRQ_EPILOGUE();
    284e:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
    2852:	81 11       	cpse	r24, r1
    2854:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
    2858:	ff 91       	pop	r31
    285a:	ef 91       	pop	r30
    285c:	bf 91       	pop	r27
    285e:	af 91       	pop	r26
    2860:	9f 91       	pop	r25
    2862:	8f 91       	pop	r24
    2864:	7f 91       	pop	r23
    2866:	6f 91       	pop	r22
    2868:	5f 91       	pop	r21
    286a:	4f 91       	pop	r20
    286c:	3f 91       	pop	r19
    286e:	2f 91       	pop	r18
    2870:	0f 90       	pop	r0
    2872:	0f be       	out	0x3f, r0	; 63
    2874:	0f 90       	pop	r0
    2876:	1f 90       	pop	r1
    2878:	18 95       	reti

0000287a <__vector_11>:
CH_IRQ_HANDLER(TIMER1_COMPA_vect)
{
    287a:	1f 92       	push	r1
    287c:	0f 92       	push	r0
    287e:	0f b6       	in	r0, 0x3f	; 63
    2880:	0f 92       	push	r0
    2882:	11 24       	eor	r1, r1
    2884:	2f 93       	push	r18
    2886:	3f 93       	push	r19
    2888:	4f 93       	push	r20
    288a:	5f 93       	push	r21
    288c:	6f 93       	push	r22
    288e:	7f 93       	push	r23
    2890:	8f 93       	push	r24
    2892:	9f 93       	push	r25
    2894:	af 93       	push	r26
    2896:	bf 93       	push	r27
    2898:	ef 93       	push	r30
    289a:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD1.config->channels[0].callback(&PWMD1);
    289c:	e0 91 a0 02 	lds	r30, 0x02A0
    28a0:	f0 91 a1 02 	lds	r31, 0x02A1
    28a4:	04 84       	ldd	r0, Z+12	; 0x0c
    28a6:	f5 85       	ldd	r31, Z+13	; 0x0d
    28a8:	e0 2d       	mov	r30, r0
    28aa:	8f e9       	ldi	r24, 0x9F	; 159
    28ac:	92 e0       	ldi	r25, 0x02	; 2
    28ae:	09 95       	icall
    CH_IRQ_EPILOGUE();
    28b0:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
    28b4:	81 11       	cpse	r24, r1
    28b6:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
    28ba:	ff 91       	pop	r31
    28bc:	ef 91       	pop	r30
    28be:	bf 91       	pop	r27
    28c0:	af 91       	pop	r26
    28c2:	9f 91       	pop	r25
    28c4:	8f 91       	pop	r24
    28c6:	7f 91       	pop	r23
    28c8:	6f 91       	pop	r22
    28ca:	5f 91       	pop	r21
    28cc:	4f 91       	pop	r20
    28ce:	3f 91       	pop	r19
    28d0:	2f 91       	pop	r18
    28d2:	0f 90       	pop	r0
    28d4:	0f be       	out	0x3f, r0	; 63
    28d6:	0f 90       	pop	r0
    28d8:	1f 90       	pop	r1
    28da:	18 95       	reti

000028dc <__vector_12>:
CH_IRQ_HANDLER(TIMER1_COMPB_vect)
{
    28dc:	1f 92       	push	r1
    28de:	0f 92       	push	r0
    28e0:	0f b6       	in	r0, 0x3f	; 63
    28e2:	0f 92       	push	r0
    28e4:	11 24       	eor	r1, r1
    28e6:	2f 93       	push	r18
    28e8:	3f 93       	push	r19
    28ea:	4f 93       	push	r20
    28ec:	5f 93       	push	r21
    28ee:	6f 93       	push	r22
    28f0:	7f 93       	push	r23
    28f2:	8f 93       	push	r24
    28f4:	9f 93       	push	r25
    28f6:	af 93       	push	r26
    28f8:	bf 93       	push	r27
    28fa:	ef 93       	push	r30
    28fc:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD1.config->channels[1].callback(&PWMD1);
    28fe:	e0 91 a0 02 	lds	r30, 0x02A0
    2902:	f0 91 a1 02 	lds	r31, 0x02A1
    2906:	02 88       	ldd	r0, Z+18	; 0x12
    2908:	f3 89       	ldd	r31, Z+19	; 0x13
    290a:	e0 2d       	mov	r30, r0
    290c:	8f e9       	ldi	r24, 0x9F	; 159
    290e:	92 e0       	ldi	r25, 0x02	; 2
    2910:	09 95       	icall
    CH_IRQ_EPILOGUE();
    2912:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
    2916:	81 11       	cpse	r24, r1
    2918:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
    291c:	ff 91       	pop	r31
    291e:	ef 91       	pop	r30
    2920:	bf 91       	pop	r27
    2922:	af 91       	pop	r26
    2924:	9f 91       	pop	r25
    2926:	8f 91       	pop	r24
    2928:	7f 91       	pop	r23
    292a:	6f 91       	pop	r22
    292c:	5f 91       	pop	r21
    292e:	4f 91       	pop	r20
    2930:	3f 91       	pop	r19
    2932:	2f 91       	pop	r18
    2934:	0f 90       	pop	r0
    2936:	0f be       	out	0x3f, r0	; 63
    2938:	0f 90       	pop	r0
    293a:	1f 90       	pop	r1
    293c:	18 95       	reti

0000293e <__vector_9>:
}
#endif
#endif
#if USE_AVR_PWM2 || defined(__DOXYGEN__)
CH_IRQ_HANDLER(TIMER2_OVF_vect)
{
    293e:	1f 92       	push	r1
    2940:	0f 92       	push	r0
    2942:	0f b6       	in	r0, 0x3f	; 63
    2944:	0f 92       	push	r0
    2946:	11 24       	eor	r1, r1
    2948:	2f 93       	push	r18
    294a:	3f 93       	push	r19
    294c:	4f 93       	push	r20
    294e:	5f 93       	push	r21
    2950:	6f 93       	push	r22
    2952:	7f 93       	push	r23
    2954:	8f 93       	push	r24
    2956:	9f 93       	push	r25
    2958:	af 93       	push	r26
    295a:	bf 93       	push	r27
    295c:	ef 93       	push	r30
    295e:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD2.config->callback(&PWMD2);
    2960:	e0 91 9b 02 	lds	r30, 0x029B
    2964:	f0 91 9c 02 	lds	r31, 0x029C
    2968:	06 80       	ldd	r0, Z+6	; 0x06
    296a:	f7 81       	ldd	r31, Z+7	; 0x07
    296c:	e0 2d       	mov	r30, r0
    296e:	8a e9       	ldi	r24, 0x9A	; 154
    2970:	92 e0       	ldi	r25, 0x02	; 2
    2972:	09 95       	icall
    CH_IRQ_EPILOGUE();
    2974:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
    2978:	81 11       	cpse	r24, r1
    297a:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
    297e:	ff 91       	pop	r31
    2980:	ef 91       	pop	r30
    2982:	bf 91       	pop	r27
    2984:	af 91       	pop	r26
    2986:	9f 91       	pop	r25
    2988:	8f 91       	pop	r24
    298a:	7f 91       	pop	r23
    298c:	6f 91       	pop	r22
    298e:	5f 91       	pop	r21
    2990:	4f 91       	pop	r20
    2992:	3f 91       	pop	r19
    2994:	2f 91       	pop	r18
    2996:	0f 90       	pop	r0
    2998:	0f be       	out	0x3f, r0	; 63
    299a:	0f 90       	pop	r0
    299c:	1f 90       	pop	r1
    299e:	18 95       	reti

000029a0 <__vector_7>:
CH_IRQ_HANDLER(TIMER2_COMPA_vect)
{
    29a0:	1f 92       	push	r1
    29a2:	0f 92       	push	r0
    29a4:	0f b6       	in	r0, 0x3f	; 63
    29a6:	0f 92       	push	r0
    29a8:	11 24       	eor	r1, r1
    29aa:	2f 93       	push	r18
    29ac:	3f 93       	push	r19
    29ae:	4f 93       	push	r20
    29b0:	5f 93       	push	r21
    29b2:	6f 93       	push	r22
    29b4:	7f 93       	push	r23
    29b6:	8f 93       	push	r24
    29b8:	9f 93       	push	r25
    29ba:	af 93       	push	r26
    29bc:	bf 93       	push	r27
    29be:	ef 93       	push	r30
    29c0:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD2.config->channels[0].callback(&PWMD2);
    29c2:	e0 91 9b 02 	lds	r30, 0x029B
    29c6:	f0 91 9c 02 	lds	r31, 0x029C
    29ca:	04 84       	ldd	r0, Z+12	; 0x0c
    29cc:	f5 85       	ldd	r31, Z+13	; 0x0d
    29ce:	e0 2d       	mov	r30, r0
    29d0:	8a e9       	ldi	r24, 0x9A	; 154
    29d2:	92 e0       	ldi	r25, 0x02	; 2
    29d4:	09 95       	icall
    CH_IRQ_EPILOGUE();
    29d6:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
    29da:	81 11       	cpse	r24, r1
    29dc:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
    29e0:	ff 91       	pop	r31
    29e2:	ef 91       	pop	r30
    29e4:	bf 91       	pop	r27
    29e6:	af 91       	pop	r26
    29e8:	9f 91       	pop	r25
    29ea:	8f 91       	pop	r24
    29ec:	7f 91       	pop	r23
    29ee:	6f 91       	pop	r22
    29f0:	5f 91       	pop	r21
    29f2:	4f 91       	pop	r20
    29f4:	3f 91       	pop	r19
    29f6:	2f 91       	pop	r18
    29f8:	0f 90       	pop	r0
    29fa:	0f be       	out	0x3f, r0	; 63
    29fc:	0f 90       	pop	r0
    29fe:	1f 90       	pop	r1
    2a00:	18 95       	reti

00002a02 <__vector_8>:
CH_IRQ_HANDLER(TIMER2_COMPB_vect)
{
    2a02:	1f 92       	push	r1
    2a04:	0f 92       	push	r0
    2a06:	0f b6       	in	r0, 0x3f	; 63
    2a08:	0f 92       	push	r0
    2a0a:	11 24       	eor	r1, r1
    2a0c:	2f 93       	push	r18
    2a0e:	3f 93       	push	r19
    2a10:	4f 93       	push	r20
    2a12:	5f 93       	push	r21
    2a14:	6f 93       	push	r22
    2a16:	7f 93       	push	r23
    2a18:	8f 93       	push	r24
    2a1a:	9f 93       	push	r25
    2a1c:	af 93       	push	r26
    2a1e:	bf 93       	push	r27
    2a20:	ef 93       	push	r30
    2a22:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD2.config->channels[1].callback(&PWMD2);
    2a24:	e0 91 9b 02 	lds	r30, 0x029B
    2a28:	f0 91 9c 02 	lds	r31, 0x029C
    2a2c:	02 88       	ldd	r0, Z+18	; 0x12
    2a2e:	f3 89       	ldd	r31, Z+19	; 0x13
    2a30:	e0 2d       	mov	r30, r0
    2a32:	8a e9       	ldi	r24, 0x9A	; 154
    2a34:	92 e0       	ldi	r25, 0x02	; 2
    2a36:	09 95       	icall
    CH_IRQ_EPILOGUE();
    2a38:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
    2a3c:	81 11       	cpse	r24, r1
    2a3e:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
    2a42:	ff 91       	pop	r31
    2a44:	ef 91       	pop	r30
    2a46:	bf 91       	pop	r27
    2a48:	af 91       	pop	r26
    2a4a:	9f 91       	pop	r25
    2a4c:	8f 91       	pop	r24
    2a4e:	7f 91       	pop	r23
    2a50:	6f 91       	pop	r22
    2a52:	5f 91       	pop	r21
    2a54:	4f 91       	pop	r20
    2a56:	3f 91       	pop	r19
    2a58:	2f 91       	pop	r18
    2a5a:	0f 90       	pop	r0
    2a5c:	0f be       	out	0x3f, r0	; 63
    2a5e:	0f 90       	pop	r0
    2a60:	1f 90       	pop	r1
    2a62:	18 95       	reti

00002a64 <pwm_lld_init>:
 */
void pwm_lld_init(void)
{

#if USE_AVR_PWM1 || defined(__DOXYGEN__)
    pwmObjectInit(&PWMD1);
    2a64:	8f e9       	ldi	r24, 0x9F	; 159
    2a66:	92 e0       	ldi	r25, 0x02	; 2
    2a68:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <pwmObjectInit>
    TCCR1A = (0<<WGM11) | (1<<WGM10);   //fast pwm 8 bit
    2a6c:	81 e0       	ldi	r24, 0x01	; 1
    2a6e:	80 93 80 00 	sts	0x0080, r24
    TCCR1B = (1<<WGM12) | (0<<WGM13);  //fast pwm 8 bit
    2a72:	88 e0       	ldi	r24, 0x08	; 8
    2a74:	80 93 81 00 	sts	0x0081, r24
#endif
#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    pwmObjectInit(&PWMD2);
    2a78:	8a e9       	ldi	r24, 0x9A	; 154
    2a7a:	92 e0       	ldi	r25, 0x02	; 2
    2a7c:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <pwmObjectInit>
    TCCR2A = (1<<WGM21) | (1<<WGM20);   //fast pwm 8 bit
    2a80:	83 e0       	ldi	r24, 0x03	; 3
    2a82:	80 93 b0 00 	sts	0x00B0, r24
    TCCR2B = (0<<WGM22);  //fast pwm 8 bit
    2a86:	10 92 b1 00 	sts	0x00B1, r1
    2a8a:	08 95       	ret

00002a8c <pwm_lld_start>:
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp)
{

    if ( pwmp->state == PWM_STOP)
    2a8c:	fc 01       	movw	r30, r24
    2a8e:	20 81       	ld	r18, Z
    2a90:	21 30       	cpi	r18, 0x01	; 1
    2a92:	09 f0       	breq	.+2      	; 0x2a96 <pwm_lld_start+0xa>
    2a94:	08 95       	ret
    {
        /* Clock activation.*/

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
        if(pwmp == &PWMD2)
    2a96:	8a 59       	subi	r24, 0x9A	; 154
    2a98:	92 40       	sbci	r25, 0x02	; 2
    2a9a:	69 f0       	breq	.+26     	; 0x2ab6 <pwm_lld_start+0x2a>
            return;
        }
#endif
//{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
        uint8_t index = getTimerIndex(pwmp);
        *timer_registers_table[index][1] |= (1<<CS12) |(0<<CS11) | (1<<CS10);
    2a9c:	e0 91 02 01 	lds	r30, 0x0102
    2aa0:	f0 91 03 01 	lds	r31, 0x0103
    2aa4:	80 81       	ld	r24, Z
    2aa6:	85 60       	ori	r24, 0x05	; 5
    2aa8:	80 83       	st	Z, r24
        *timer_registers_table[index][10] = (1<<TOIE1);
    2aaa:	e0 91 14 01 	lds	r30, 0x0114
    2aae:	f0 91 15 01 	lds	r31, 0x0115
    2ab2:	20 83       	st	Z, r18
    2ab4:	08 95       	ret
        /* Clock activation.*/

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
        if(pwmp == &PWMD2)
        {
            TCCR2B |= (0<<CS22) |(0<<CS21) | (1<<CS20); //parti col no prescaling
    2ab6:	80 91 b1 00 	lds	r24, 0x00B1
    2aba:	81 60       	ori	r24, 0x01	; 1
    2abc:	80 93 b1 00 	sts	0x00B1, r24
            if(pwmp->config->callback != NULL)
    2ac0:	e0 91 9b 02 	lds	r30, 0x029B
    2ac4:	f0 91 9c 02 	lds	r31, 0x029C
    2ac8:	86 81       	ldd	r24, Z+6	; 0x06
    2aca:	97 81       	ldd	r25, Z+7	; 0x07
    2acc:	89 2b       	or	r24, r25
    2ace:	11 f3       	breq	.-60     	; 0x2a94 <pwm_lld_start+0x8>
                TIMSK2 = (1<<TOIE2);
    2ad0:	20 93 70 00 	sts	0x0070, r18
    2ad4:	08 95       	ret

00002ad6 <pwm_lld_stop>:
 */
void pwm_lld_stop(PWMDriver *pwmp)
{
//{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
    uint8_t index = getTimerIndex(pwmp);
    *timer_registers_table[index][1] &= ~((1<<CS12) |(1<<CS11) | (1<<CS10));
    2ad6:	e0 91 02 01 	lds	r30, 0x0102
    2ada:	f0 91 03 01 	lds	r31, 0x0103
    2ade:	80 81       	ld	r24, Z
    2ae0:	88 7f       	andi	r24, 0xF8	; 248
    2ae2:	80 83       	st	Z, r24
    *timer_registers_table[index][11] = 0;
    2ae4:	e0 91 16 01 	lds	r30, 0x0116
    2ae8:	f0 91 17 01 	lds	r31, 0x0117
    2aec:	10 82       	st	Z, r1
    2aee:	08 95       	ret

00002af0 <pwm_lld_change_period>:
 * @param[in] period    new cycle time in ticks
 *
 * @notapi
 */
void pwm_lld_change_period(PWMDriver *pwmp, pwmcnt_t period)
{
    2af0:	08 95       	ret

00002af2 <pwm_lld_enable_channel>:
 * @notapi
 */
void pwm_lld_enable_channel(PWMDriver *pwmp,
                            pwmchannel_t channel,
                            pwmcnt_t width)
{
    2af2:	af 92       	push	r10
    2af4:	bf 92       	push	r11
    2af6:	cf 92       	push	r12
    2af8:	df 92       	push	r13
    2afa:	ef 92       	push	r14
    2afc:	ff 92       	push	r15
    2afe:	0f 93       	push	r16
    2b00:	1f 93       	push	r17
    2b02:	cf 93       	push	r28
    2b04:	df 93       	push	r29
    2b06:	ec 01       	movw	r28, r24
    2b08:	b6 2e       	mov	r11, r22
    uint32_t val = width;
    val *= 256;
    2b0a:	ca 01       	movw	r24, r20
    2b0c:	a0 e0       	ldi	r26, 0x00	; 0
    2b0e:	b0 e0       	ldi	r27, 0x00	; 0
    2b10:	66 27       	eor	r22, r22
    2b12:	78 2f       	mov	r23, r24
    2b14:	89 2f       	mov	r24, r25
    2b16:	9a 2f       	mov	r25, r26
    val /= (uint32_t)pwmp->period;
    2b18:	2b 81       	ldd	r18, Y+3	; 0x03
    2b1a:	3c 81       	ldd	r19, Y+4	; 0x04
    2b1c:	40 e0       	ldi	r20, 0x00	; 0
    2b1e:	50 e0       	ldi	r21, 0x00	; 0
    2b20:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <__udivmodsi4>
    2b24:	89 01       	movw	r16, r18
    2b26:	9a 01       	movw	r18, r20
    2b28:	0f 3f       	cpi	r16, 0xFF	; 255
    2b2a:	11 05       	cpc	r17, r1
    2b2c:	21 05       	cpc	r18, r1
    2b2e:	31 05       	cpc	r19, r1
    2b30:	29 f0       	breq	.+10     	; 0x2b3c <pwm_lld_enable_channel+0x4a>
    2b32:	20 f0       	brcs	.+8      	; 0x2b3c <pwm_lld_enable_channel+0x4a>
    2b34:	0f ef       	ldi	r16, 0xFF	; 255
    2b36:	10 e0       	ldi	r17, 0x00	; 0
    2b38:	20 e0       	ldi	r18, 0x00	; 0
    2b3a:	30 e0       	ldi	r19, 0x00	; 0
    if(val > 0x00FF)
        val = 0xFF;

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    if(pwmp == &PWMD2)
    2b3c:	42 e0       	ldi	r20, 0x02	; 2
    2b3e:	ca 39       	cpi	r28, 0x9A	; 154
    2b40:	d4 07       	cpc	r29, r20
    2b42:	09 f4       	brne	.+2      	; 0x2b46 <pwm_lld_enable_channel+0x54>
    2b44:	8a c0       	rjmp	.+276    	; 0x2c5a <pwm_lld_enable_channel+0x168>
    }
#endif

    //{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2b46:	4b 2d       	mov	r20, r11
    2b48:	50 e0       	ldi	r21, 0x00	; 0
    2b4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b4e:	da 01       	movw	r26, r20
    2b50:	aa 0f       	add	r26, r26
    2b52:	bb 1f       	adc	r27, r27
    2b54:	cd 01       	movw	r24, r26
    2b56:	84 0f       	add	r24, r20
    2b58:	95 1f       	adc	r25, r21
    2b5a:	88 0f       	add	r24, r24
    2b5c:	99 1f       	adc	r25, r25
    2b5e:	e8 0f       	add	r30, r24
    2b60:	f9 1f       	adc	r31, r25
    2b62:	c0 84       	ldd	r12, Z+8	; 0x08
    2b64:	d1 84       	ldd	r13, Z+9	; 0x09
    2b66:	e2 84       	ldd	r14, Z+10	; 0x0a
    2b68:	f3 84       	ldd	r15, Z+11	; 0x0b
    2b6a:	e0 91 00 01 	lds	r30, 0x0100
    2b6e:	f0 91 01 01 	lds	r31, 0x0101
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2b72:	a0 80       	ld	r10, Z
    }
#endif

    //{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2b74:	8b 2d       	mov	r24, r11
    2b76:	81 95       	neg	r24
    2b78:	88 0f       	add	r24, r24
    2b7a:	89 5f       	subi	r24, 0xF9	; 249
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2b7c:	61 e0       	ldi	r22, 0x01	; 1
    2b7e:	70 e0       	ldi	r23, 0x00	; 0
    2b80:	b6 2e       	mov	r11, r22
    2b82:	01 c0       	rjmp	.+2      	; 0x2b86 <pwm_lld_enable_channel+0x94>
    2b84:	bb 0c       	add	r11, r11
    2b86:	8a 95       	dec	r24
    2b88:	ea f7       	brpl	.-6      	; 0x2b84 <pwm_lld_enable_channel+0x92>
    }
#endif

    //{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2b8a:	83 e0       	ldi	r24, 0x03	; 3
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	84 1b       	sub	r24, r20
    2b90:	95 0b       	sbc	r25, r21
    2b92:	88 0f       	add	r24, r24
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2b94:	08 2e       	mov	r0, r24
    2b96:	01 c0       	rjmp	.+2      	; 0x2b9a <pwm_lld_enable_channel+0xa8>
    2b98:	66 0f       	add	r22, r22
    2b9a:	0a 94       	dec	r0
    2b9c:	ea f7       	brpl	.-6      	; 0x2b98 <pwm_lld_enable_channel+0xa6>
    2b9e:	6b 29       	or	r22, r11
    2ba0:	96 2f       	mov	r25, r22
    2ba2:	90 95       	com	r25
    2ba4:	9a 21       	and	r25, r10
    2ba6:	90 83       	st	Z, r25
    if(PWM_OUTPUT_ACTIVE_HIGH ==mode )
    2ba8:	81 e0       	ldi	r24, 0x01	; 1
    2baa:	c8 16       	cp	r12, r24
    2bac:	d1 04       	cpc	r13, r1
    2bae:	e1 04       	cpc	r14, r1
    2bb0:	f1 04       	cpc	r15, r1
    2bb2:	09 f4       	brne	.+2      	; 0x2bb6 <pwm_lld_enable_channel+0xc4>
    2bb4:	4e c0       	rjmp	.+156    	; 0x2c52 <pwm_lld_enable_channel+0x160>
        *TCCRnA |=  ((1<<COMnx1) | (0<<COMnx0)); //non inverting mode
    if(PWM_OUTPUT_ACTIVE_LOW ==mode)
    2bb6:	82 e0       	ldi	r24, 0x02	; 2
    2bb8:	c8 16       	cp	r12, r24
    2bba:	d1 04       	cpc	r13, r1
    2bbc:	e1 04       	cpc	r14, r1
    2bbe:	f1 04       	cpc	r15, r1
    2bc0:	09 f4       	brne	.+2      	; 0x2bc4 <pwm_lld_enable_channel+0xd2>
    2bc2:	43 c0       	rjmp	.+134    	; 0x2c4a <pwm_lld_enable_channel+0x158>
#endif

    //{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    *timer_registers_table[index][2*channel+2] = 0;
    2bc4:	ca 01       	movw	r24, r20
    2bc6:	01 96       	adiw	r24, 0x01	; 1
    2bc8:	fc 01       	movw	r30, r24
    2bca:	ee 0f       	add	r30, r30
    2bcc:	ff 1f       	adc	r31, r31
    2bce:	ee 0f       	add	r30, r30
    2bd0:	ff 1f       	adc	r31, r31
    2bd2:	e0 50       	subi	r30, 0x00	; 0
    2bd4:	ff 4f       	sbci	r31, 0xFF	; 255
    2bd6:	01 90       	ld	r0, Z+
    2bd8:	f0 81       	ld	r31, Z
    2bda:	e0 2d       	mov	r30, r0
    2bdc:	10 82       	st	Z, r1
    *timer_registers_table[index][2*channel+3] = val;
    2bde:	fa 01       	movw	r30, r20
    2be0:	ee 0f       	add	r30, r30
    2be2:	ff 1f       	adc	r31, r31
    2be4:	ee 0f       	add	r30, r30
    2be6:	ff 1f       	adc	r31, r31
    2be8:	ea 5f       	subi	r30, 0xFA	; 250
    2bea:	fe 4f       	sbci	r31, 0xFE	; 254
    2bec:	01 90       	ld	r0, Z+
    2bee:	f0 81       	ld	r31, Z
    2bf0:	e0 2d       	mov	r30, r0
    2bf2:	00 83       	st	Z, r16
    *timer_registers_table[index][10] |= (1<< (channel + 1));
    2bf4:	e0 91 14 01 	lds	r30, 0x0114
    2bf8:	f0 91 15 01 	lds	r31, 0x0115
    2bfc:	90 81       	ld	r25, Z
    2bfe:	21 e0       	ldi	r18, 0x01	; 1
    2c00:	30 e0       	ldi	r19, 0x00	; 0
    2c02:	01 c0       	rjmp	.+2      	; 0x2c06 <pwm_lld_enable_channel+0x114>
    2c04:	22 0f       	add	r18, r18
    2c06:	8a 95       	dec	r24
    2c08:	ea f7       	brpl	.-6      	; 0x2c04 <pwm_lld_enable_channel+0x112>
    2c0a:	92 2b       	or	r25, r18
    2c0c:	90 83       	st	Z, r25
    if(pwmp->config->channels[channel].callback != NULL)
    2c0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c10:	fa 81       	ldd	r31, Y+2	; 0x02
    2c12:	4a 0f       	add	r20, r26
    2c14:	5b 1f       	adc	r21, r27
    2c16:	44 0f       	add	r20, r20
    2c18:	55 1f       	adc	r21, r21
    2c1a:	e4 0f       	add	r30, r20
    2c1c:	f5 1f       	adc	r31, r21
    2c1e:	84 85       	ldd	r24, Z+12	; 0x0c
    2c20:	95 85       	ldd	r25, Z+13	; 0x0d
    2c22:	89 2b       	or	r24, r25
    2c24:	39 f0       	breq	.+14     	; 0x2c34 <pwm_lld_enable_channel+0x142>
    {
        *timer_registers_table[index][11] |= (1<< (channel + 1));
    2c26:	e0 91 16 01 	lds	r30, 0x0116
    2c2a:	f0 91 17 01 	lds	r31, 0x0117
    2c2e:	80 81       	ld	r24, Z
    2c30:	82 2b       	or	r24, r18
    2c32:	80 83       	st	Z, r24

    }

}
    2c34:	df 91       	pop	r29
    2c36:	cf 91       	pop	r28
    2c38:	1f 91       	pop	r17
    2c3a:	0f 91       	pop	r16
    2c3c:	ff 90       	pop	r15
    2c3e:	ef 90       	pop	r14
    2c40:	df 90       	pop	r13
    2c42:	cf 90       	pop	r12
    2c44:	bf 90       	pop	r11
    2c46:	af 90       	pop	r10
    2c48:	08 95       	ret
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    if(PWM_OUTPUT_ACTIVE_HIGH ==mode )
        *TCCRnA |=  ((1<<COMnx1) | (0<<COMnx0)); //non inverting mode
    if(PWM_OUTPUT_ACTIVE_LOW ==mode)
        *TCCRnA |= (1<<COMnx1) | (1<<COMnx0); //inverting mode
    2c4a:	80 81       	ld	r24, Z
    2c4c:	86 2b       	or	r24, r22
    2c4e:	80 83       	st	Z, r24
    2c50:	b9 cf       	rjmp	.-142    	; 0x2bc4 <pwm_lld_enable_channel+0xd2>
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    if(PWM_OUTPUT_ACTIVE_HIGH ==mode )
        *TCCRnA |=  ((1<<COMnx1) | (0<<COMnx0)); //non inverting mode
    2c52:	80 81       	ld	r24, Z
    2c54:	8b 29       	or	r24, r11
    2c56:	80 83       	st	Z, r24
    2c58:	b5 cf       	rjmp	.-150    	; 0x2bc4 <pwm_lld_enable_channel+0xd2>
        val = 0xFF;

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    if(pwmp == &PWMD2)
    {
        pwm_configure_hw_channel(&TCCR2A,7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2c5a:	8b 2d       	mov	r24, r11
    2c5c:	90 e0       	ldi	r25, 0x00	; 0
    2c5e:	60 91 9b 02 	lds	r22, 0x029B
    2c62:	70 91 9c 02 	lds	r23, 0x029C
    2c66:	fc 01       	movw	r30, r24
    2c68:	ee 0f       	add	r30, r30
    2c6a:	ff 1f       	adc	r31, r31
    2c6c:	df 01       	movw	r26, r30
    2c6e:	a8 0f       	add	r26, r24
    2c70:	b9 1f       	adc	r27, r25
    2c72:	aa 0f       	add	r26, r26
    2c74:	bb 1f       	adc	r27, r27
    2c76:	a6 0f       	add	r26, r22
    2c78:	b7 1f       	adc	r27, r23
    2c7a:	18 96       	adiw	r26, 0x08	; 8
    2c7c:	cd 90       	ld	r12, X+
    2c7e:	dd 90       	ld	r13, X+
    2c80:	ed 90       	ld	r14, X+
    2c82:	fc 90       	ld	r15, X
    2c84:	1b 97       	sbiw	r26, 0x0b	; 11
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2c86:	d0 91 b0 00 	lds	r29, 0x00B0
        val = 0xFF;

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    if(pwmp == &PWMD2)
    {
        pwm_configure_hw_channel(&TCCR2A,7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2c8a:	4b 2d       	mov	r20, r11
    2c8c:	41 95       	neg	r20
    2c8e:	44 0f       	add	r20, r20
    2c90:	49 5f       	subi	r20, 0xF9	; 249
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2c92:	a1 e0       	ldi	r26, 0x01	; 1
    2c94:	b0 e0       	ldi	r27, 0x00	; 0
    2c96:	ca 2f       	mov	r28, r26
    2c98:	01 c0       	rjmp	.+2      	; 0x2c9c <pwm_lld_enable_channel+0x1aa>
    2c9a:	cc 0f       	add	r28, r28
    2c9c:	4a 95       	dec	r20
    2c9e:	ea f7       	brpl	.-6      	; 0x2c9a <pwm_lld_enable_channel+0x1a8>
        val = 0xFF;

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    if(pwmp == &PWMD2)
    {
        pwm_configure_hw_channel(&TCCR2A,7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2ca0:	43 e0       	ldi	r20, 0x03	; 3
    2ca2:	50 e0       	ldi	r21, 0x00	; 0
    2ca4:	48 1b       	sub	r20, r24
    2ca6:	59 0b       	sbc	r21, r25
    2ca8:	44 0f       	add	r20, r20
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2caa:	04 2e       	mov	r0, r20
    2cac:	01 c0       	rjmp	.+2      	; 0x2cb0 <pwm_lld_enable_channel+0x1be>
    2cae:	aa 0f       	add	r26, r26
    2cb0:	0a 94       	dec	r0
    2cb2:	ea f7       	brpl	.-6      	; 0x2cae <pwm_lld_enable_channel+0x1bc>
    2cb4:	ac 2b       	or	r26, r28
    2cb6:	5a 2f       	mov	r21, r26
    2cb8:	50 95       	com	r21
    2cba:	5d 23       	and	r21, r29
    2cbc:	50 93 b0 00 	sts	0x00B0, r21
    if(PWM_OUTPUT_ACTIVE_HIGH ==mode )
    2cc0:	41 e0       	ldi	r20, 0x01	; 1
    2cc2:	c4 16       	cp	r12, r20
    2cc4:	d1 04       	cpc	r13, r1
    2cc6:	e1 04       	cpc	r14, r1
    2cc8:	f1 04       	cpc	r15, r1
    2cca:	79 f1       	breq	.+94     	; 0x2d2a <pwm_lld_enable_channel+0x238>
        *TCCRnA |=  ((1<<COMnx1) | (0<<COMnx0)); //non inverting mode
    if(PWM_OUTPUT_ACTIVE_LOW ==mode)
    2ccc:	42 e0       	ldi	r20, 0x02	; 2
    2cce:	c4 16       	cp	r12, r20
    2cd0:	d1 04       	cpc	r13, r1
    2cd2:	e1 04       	cpc	r14, r1
    2cd4:	f1 04       	cpc	r15, r1
    2cd6:	29 f4       	brne	.+10     	; 0x2ce2 <pwm_lld_enable_channel+0x1f0>
        *TCCRnA |= (1<<COMnx1) | (1<<COMnx0); //inverting mode
    2cd8:	40 91 b0 00 	lds	r20, 0x00B0
    2cdc:	4a 2b       	or	r20, r26
    2cde:	40 93 b0 00 	sts	0x00B0, r20

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    if(pwmp == &PWMD2)
    {
        pwm_configure_hw_channel(&TCCR2A,7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
        TIMSK2 |= (1<< (channel + 1));
    2ce2:	c0 91 70 00 	lds	r28, 0x0070
    2ce6:	dc 01       	movw	r26, r24
    2ce8:	11 96       	adiw	r26, 0x01	; 1
    2cea:	41 e0       	ldi	r20, 0x01	; 1
    2cec:	50 e0       	ldi	r21, 0x00	; 0
    2cee:	0a 2e       	mov	r0, r26
    2cf0:	01 c0       	rjmp	.+2      	; 0x2cf4 <pwm_lld_enable_channel+0x202>
    2cf2:	44 0f       	add	r20, r20
    2cf4:	0a 94       	dec	r0
    2cf6:	ea f7       	brpl	.-6      	; 0x2cf2 <pwm_lld_enable_channel+0x200>
    2cf8:	c4 2b       	or	r28, r20
    2cfa:	c0 93 70 00 	sts	0x0070, r28
        if(pwmp->config->channels[channel].callback != NULL)
    2cfe:	e8 0f       	add	r30, r24
    2d00:	f9 1f       	adc	r31, r25
    2d02:	ee 0f       	add	r30, r30
    2d04:	ff 1f       	adc	r31, r31
    2d06:	e6 0f       	add	r30, r22
    2d08:	f7 1f       	adc	r31, r23
    2d0a:	84 85       	ldd	r24, Z+12	; 0x0c
    2d0c:	95 85       	ldd	r25, Z+13	; 0x0d
    2d0e:	89 2b       	or	r24, r25
    2d10:	09 f4       	brne	.+2      	; 0x2d14 <pwm_lld_enable_channel+0x222>
    2d12:	90 cf       	rjmp	.-224    	; 0x2c34 <pwm_lld_enable_channel+0x142>
            switch(channel)
    2d14:	b1 10       	cpse	r11, r1
    2d16:	03 c0       	rjmp	.+6      	; 0x2d1e <pwm_lld_enable_channel+0x22c>
            {
            case 0:
                OCR2A = val;
    2d18:	00 93 b3 00 	sts	0x00B3, r16
                break;
    2d1c:	8b cf       	rjmp	.-234    	; 0x2c34 <pwm_lld_enable_channel+0x142>
    if(pwmp == &PWMD2)
    {
        pwm_configure_hw_channel(&TCCR2A,7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
        TIMSK2 |= (1<< (channel + 1));
        if(pwmp->config->channels[channel].callback != NULL)
            switch(channel)
    2d1e:	81 e0       	ldi	r24, 0x01	; 1
    2d20:	b8 12       	cpse	r11, r24
    2d22:	88 cf       	rjmp	.-240    	; 0x2c34 <pwm_lld_enable_channel+0x142>
            {
            case 0:
                OCR2A = val;
                break;
            case 1:
                OCR2B = val;
    2d24:	00 93 b4 00 	sts	0x00B4, r16
                break;
    2d28:	85 cf       	rjmp	.-246    	; 0x2c34 <pwm_lld_enable_channel+0x142>
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    if(PWM_OUTPUT_ACTIVE_HIGH ==mode )
        *TCCRnA |=  ((1<<COMnx1) | (0<<COMnx0)); //non inverting mode
    2d2a:	40 91 b0 00 	lds	r20, 0x00B0
    2d2e:	4c 2b       	or	r20, r28
    2d30:	40 93 b0 00 	sts	0x00B0, r20
    2d34:	d6 cf       	rjmp	.-84     	; 0x2ce2 <pwm_lld_enable_channel+0x1f0>

00002d36 <pwm_lld_disable_channel>:
 * @param[in] channel   PWM channel identifier (0...PWM_CHANNELS-1)
 *
 * @notapi
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel)
{
    2d36:	cf 93       	push	r28
    2d38:	df 93       	push	r29
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,PWM_OUTPUT_DISABLED);
    2d3a:	46 2f       	mov	r20, r22
    2d3c:	50 e0       	ldi	r21, 0x00	; 0
    2d3e:	e0 91 00 01 	lds	r30, 0x0100
    2d42:	f0 91 01 01 	lds	r31, 0x0101
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2d46:	a0 81       	ld	r26, Z
 * @notapi
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel)
{
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,PWM_OUTPUT_DISABLED);
    2d48:	23 e0       	ldi	r18, 0x03	; 3
    2d4a:	30 e0       	ldi	r19, 0x00	; 0
    2d4c:	24 1b       	sub	r18, r20
    2d4e:	35 0b       	sbc	r19, r21
    2d50:	22 0f       	add	r18, r18
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2d52:	81 e0       	ldi	r24, 0x01	; 1
    2d54:	90 e0       	ldi	r25, 0x00	; 0
    2d56:	ec 01       	movw	r28, r24
    2d58:	02 c0       	rjmp	.+4      	; 0x2d5e <pwm_lld_disable_channel+0x28>
    2d5a:	cc 0f       	add	r28, r28
    2d5c:	dd 1f       	adc	r29, r29
    2d5e:	2a 95       	dec	r18
    2d60:	e2 f7       	brpl	.-8      	; 0x2d5a <pwm_lld_disable_channel+0x24>
    2d62:	9e 01       	movw	r18, r28
 * @notapi
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel)
{
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,PWM_OUTPUT_DISABLED);
    2d64:	61 95       	neg	r22
    2d66:	66 0f       	add	r22, r22
    2d68:	69 5f       	subi	r22, 0xF9	; 249
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2d6a:	ec 01       	movw	r28, r24
    2d6c:	02 c0       	rjmp	.+4      	; 0x2d72 <pwm_lld_disable_channel+0x3c>
    2d6e:	cc 0f       	add	r28, r28
    2d70:	dd 1f       	adc	r29, r29
    2d72:	6a 95       	dec	r22
    2d74:	e2 f7       	brpl	.-8      	; 0x2d6e <pwm_lld_disable_channel+0x38>
    2d76:	2c 2b       	or	r18, r28
    2d78:	20 95       	com	r18
    2d7a:	2a 23       	and	r18, r26
    2d7c:	20 83       	st	Z, r18
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel)
{
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,PWM_OUTPUT_DISABLED);
    *timer_registers_table[index][11] &= ~(1<< (channel + 1));
    2d7e:	e0 91 16 01 	lds	r30, 0x0116
    2d82:	f0 91 17 01 	lds	r31, 0x0117
    2d86:	20 81       	ld	r18, Z
    2d88:	4f 5f       	subi	r20, 0xFF	; 255
    2d8a:	5f 4f       	sbci	r21, 0xFF	; 255
    2d8c:	04 2e       	mov	r0, r20
    2d8e:	01 c0       	rjmp	.+2      	; 0x2d92 <pwm_lld_disable_channel+0x5c>
    2d90:	88 0f       	add	r24, r24
    2d92:	0a 94       	dec	r0
    2d94:	ea f7       	brpl	.-6      	; 0x2d90 <pwm_lld_disable_channel+0x5a>
    2d96:	80 95       	com	r24
    2d98:	82 23       	and	r24, r18
    2d9a:	80 83       	st	Z, r24
}
    2d9c:	df 91       	pop	r29
    2d9e:	cf 91       	pop	r28
    2da0:	08 95       	ret

00002da2 <spi_start_transmission>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void spi_start_transmission(SPIDriver *spip)
{
    2da2:	cf 93       	push	r28
    2da4:	df 93       	push	r29
    2da6:	1f 92       	push	r1
    2da8:	cd b7       	in	r28, 0x3d	; 61
    2daa:	de b7       	in	r29, 0x3e	; 62
    2dac:	fc 01       	movw	r30, r24
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip->untransmitted_bytes> 0)
    2dae:	85 85       	ldd	r24, Z+13	; 0x0d
    2db0:	96 85       	ldd	r25, Z+14	; 0x0e
    2db2:	18 16       	cp	r1, r24
    2db4:	19 06       	cpc	r1, r25
    2db6:	84 f4       	brge	.+32     	; 0x2dd8 <spi_start_transmission+0x36>
    {
        if(spip->tx_buffer != NULL)
    2db8:	a7 85       	ldd	r26, Z+15	; 0x0f
    2dba:	b0 89       	ldd	r27, Z+16	; 0x10
    2dbc:	10 97       	sbiw	r26, 0x00	; 0
    2dbe:	81 f0       	breq	.+32     	; 0x2de0 <spi_start_transmission+0x3e>
        {
            SPDR =  *spip->tx_buffer;
    2dc0:	8c 91       	ld	r24, X
    2dc2:	8e bd       	out	0x2e, r24	; 46
            spip->tx_buffer++;
    2dc4:	87 85       	ldd	r24, Z+15	; 0x0f
    2dc6:	90 89       	ldd	r25, Z+16	; 0x10
    2dc8:	01 96       	adiw	r24, 0x01	; 1
    2dca:	90 8b       	std	Z+16, r25	; 0x10
    2dcc:	87 87       	std	Z+15, r24	; 0x0f
        else
        {
            volatile uint8_t tempSPDR = SPDR;
            SPDR = tempSPDR;
        }
        spip->untransmitted_bytes--;
    2dce:	85 85       	ldd	r24, Z+13	; 0x0d
    2dd0:	96 85       	ldd	r25, Z+14	; 0x0e
    2dd2:	01 97       	sbiw	r24, 0x01	; 1
    2dd4:	96 87       	std	Z+14, r25	; 0x0e
    2dd6:	85 87       	std	Z+13, r24	; 0x0d
    }

#endif


}
    2dd8:	0f 90       	pop	r0
    2dda:	df 91       	pop	r29
    2ddc:	cf 91       	pop	r28
    2dde:	08 95       	ret
            SPDR =  *spip->tx_buffer;
            spip->tx_buffer++;
        }
        else
        {
            volatile uint8_t tempSPDR = SPDR;
    2de0:	8e b5       	in	r24, 0x2e	; 46
    2de2:	89 83       	std	Y+1, r24	; 0x01
            SPDR = tempSPDR;
    2de4:	89 81       	ldd	r24, Y+1	; 0x01
    2de6:	8e bd       	out	0x2e, r24	; 46
    2de8:	f2 cf       	rjmp	.-28     	; 0x2dce <spi_start_transmission+0x2c>

00002dea <__vector_17>:
/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/
#if USE_AVR_SPI1 || defined(__DOXYGEN_)
CH_IRQ_HANDLER(SPI_STC_vect)   //SPI1 interrupt
{
    2dea:	1f 92       	push	r1
    2dec:	0f 92       	push	r0
    2dee:	0f b6       	in	r0, 0x3f	; 63
    2df0:	0f 92       	push	r0
    2df2:	11 24       	eor	r1, r1
    2df4:	2f 93       	push	r18
    2df6:	3f 93       	push	r19
    2df8:	4f 93       	push	r20
    2dfa:	5f 93       	push	r21
    2dfc:	6f 93       	push	r22
    2dfe:	7f 93       	push	r23
    2e00:	8f 93       	push	r24
    2e02:	9f 93       	push	r25
    2e04:	af 93       	push	r26
    2e06:	bf 93       	push	r27
    2e08:	ef 93       	push	r30
    2e0a:	ff 93       	push	r31

    CH_IRQ_PROLOGUE();

    if(SPCR & (1<<MSTR))
    2e0c:	0c b4       	in	r0, 0x2c	; 44
    2e0e:	04 fe       	sbrs	r0, 4
    2e10:	1d c0       	rjmp	.+58     	; 0x2e4c <__vector_17+0x62>
    {
        if(SPID1.rx_buffer != NULL)
    2e12:	e0 91 b5 02 	lds	r30, 0x02B5
    2e16:	f0 91 b6 02 	lds	r31, 0x02B6
    2e1a:	30 97       	sbiw	r30, 0x00	; 0
    2e1c:	59 f0       	breq	.+22     	; 0x2e34 <__vector_17+0x4a>
        {
            *SPID1.rx_buffer=SPDR;
    2e1e:	8e b5       	in	r24, 0x2e	; 46
    2e20:	80 83       	st	Z, r24
            SPID1.rx_buffer++;
    2e22:	80 91 b5 02 	lds	r24, 0x02B5
    2e26:	90 91 b6 02 	lds	r25, 0x02B6
    2e2a:	01 96       	adiw	r24, 0x01	; 1
    2e2c:	90 93 b6 02 	sts	0x02B6, r25
    2e30:	80 93 b5 02 	sts	0x02B5, r24
        }
        if(SPID1.untransmitted_bytes> 0)
    2e34:	80 91 b1 02 	lds	r24, 0x02B1
    2e38:	90 91 b2 02 	lds	r25, 0x02B2
    2e3c:	18 16       	cp	r1, r24
    2e3e:	19 06       	cpc	r1, r25
    2e40:	3c f5       	brge	.+78     	; 0x2e90 <__vector_17+0xa6>
        {
            spi_start_transmission(&SPID1);
    2e42:	84 ea       	ldi	r24, 0xA4	; 164
    2e44:	92 e0       	ldi	r25, 0x02	; 2
    2e46:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <spi_start_transmission>
    2e4a:	0c c0       	rjmp	.+24     	; 0x2e64 <__vector_17+0x7a>

        }
    }
    else
    {
        if(SPID1.config->slave_cb == NULL)
    2e4c:	e0 91 a5 02 	lds	r30, 0x02A5
    2e50:	f0 91 a6 02 	lds	r31, 0x02A6
    2e54:	03 80       	ldd	r0, Z+3	; 0x03
    2e56:	f4 81       	ldd	r31, Z+4	; 0x04
    2e58:	e0 2d       	mov	r30, r0
    2e5a:	30 97       	sbiw	r30, 0x00	; 0
    2e5c:	e9 f1       	breq	.+122    	; 0x2ed8 <__vector_17+0xee>
            SPDR = SPID1.config->slave_cb(&SPID1,SPDR);
        SPCR |=(1<<MSTR);
    2e5e:	8c b5       	in	r24, 0x2c	; 44
    2e60:	80 61       	ori	r24, 0x10	; 16
    2e62:	8c bd       	out	0x2c, r24	; 44

    }

    CH_IRQ_EPILOGUE();
    2e64:	0e 94 fe 02 	call	0x5fc	; 0x5fc <chSchIsPreemptionRequired>
    2e68:	81 11       	cpse	r24, r1
    2e6a:	0e 94 9e 03 	call	0x73c	; 0x73c <chSchDoReschedule>
}
    2e6e:	ff 91       	pop	r31
    2e70:	ef 91       	pop	r30
    2e72:	bf 91       	pop	r27
    2e74:	af 91       	pop	r26
    2e76:	9f 91       	pop	r25
    2e78:	8f 91       	pop	r24
    2e7a:	7f 91       	pop	r23
    2e7c:	6f 91       	pop	r22
    2e7e:	5f 91       	pop	r21
    2e80:	4f 91       	pop	r20
    2e82:	3f 91       	pop	r19
    2e84:	2f 91       	pop	r18
    2e86:	0f 90       	pop	r0
    2e88:	0f be       	out	0x3f, r0	; 63
    2e8a:	0f 90       	pop	r0
    2e8c:	1f 90       	pop	r1
    2e8e:	18 95       	reti
        {
            spi_start_transmission(&SPID1);
        }
        else
        {
            _spi_isr_code(&SPID1);
    2e90:	e0 91 a5 02 	lds	r30, 0x02A5
    2e94:	f0 91 a6 02 	lds	r31, 0x02A6
    2e98:	01 90       	ld	r0, Z+
    2e9a:	f0 81       	ld	r31, Z
    2e9c:	e0 2d       	mov	r30, r0
    2e9e:	30 97       	sbiw	r30, 0x00	; 0
    2ea0:	b9 f0       	breq	.+46     	; 0x2ed0 <__vector_17+0xe6>
    2ea2:	84 e0       	ldi	r24, 0x04	; 4
    2ea4:	80 93 a4 02 	sts	0x02A4, r24
    2ea8:	84 ea       	ldi	r24, 0xA4	; 164
    2eaa:	92 e0       	ldi	r25, 0x02	; 2
    2eac:	09 95       	icall
    2eae:	80 91 a4 02 	lds	r24, 0x02A4
    2eb2:	84 30       	cpi	r24, 0x04	; 4
    2eb4:	69 f0       	breq	.+26     	; 0x2ed0 <__vector_17+0xe6>
    2eb6:	80 91 a7 02 	lds	r24, 0x02A7
    2eba:	90 91 a8 02 	lds	r25, 0x02A8
    2ebe:	00 97       	sbiw	r24, 0x00	; 0
    2ec0:	89 f2       	breq	.-94     	; 0x2e64 <__vector_17+0x7a>
    2ec2:	10 92 a8 02 	sts	0x02A8, r1
    2ec6:	10 92 a7 02 	sts	0x02A7, r1
    2eca:	0e 94 34 02 	call	0x468	; 0x468 <chSchReadyI>
    2ece:	ca cf       	rjmp	.-108    	; 0x2e64 <__vector_17+0x7a>
    2ed0:	82 e0       	ldi	r24, 0x02	; 2
    2ed2:	80 93 a4 02 	sts	0x02A4, r24
    2ed6:	ef cf       	rjmp	.-34     	; 0x2eb6 <__vector_17+0xcc>
        }
    }
    else
    {
        if(SPID1.config->slave_cb == NULL)
            SPDR = SPID1.config->slave_cb(&SPID1,SPDR);
    2ed8:	6e b5       	in	r22, 0x2e	; 46
    2eda:	84 ea       	ldi	r24, 0xA4	; 164
    2edc:	92 e0       	ldi	r25, 0x02	; 2
    2ede:	09 95       	icall
    2ee0:	8e bd       	out	0x2e, r24	; 46
    2ee2:	bd cf       	rjmp	.-134    	; 0x2e5e <__vector_17+0x74>

00002ee4 <spi_lld_init>:
void spi_lld_init(void)
{


#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    spiObjectInit(&SPID1);
    2ee4:	84 ea       	ldi	r24, 0xA4	; 164
    2ee6:	92 e0       	ldi	r25, 0x02	; 2
    2ee8:	0c 94 89 10 	jmp	0x2112	; 0x2112 <spiObjectInit>

00002eec <spi_lld_start>:
 * @notapi
 */
void spi_lld_start(SPIDriver *spip)
{

    if (spip->state == SPI_STOP)
    2eec:	fc 01       	movw	r30, r24
    2eee:	20 81       	ld	r18, Z
    2ef0:	21 30       	cpi	r18, 0x01	; 1
    2ef2:	21 f0       	breq	.+8      	; 0x2efc <spi_lld_start+0x10>
#endif

    }
    /* Configuration.*/
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    2ef4:	84 5a       	subi	r24, 0xA4	; 164
    2ef6:	92 40       	sbci	r25, 0x02	; 2
    2ef8:	91 f0       	breq	.+36     	; 0x2f1e <spi_lld_start+0x32>
    2efa:	08 95       	ret

    if (spip->state == SPI_STOP)
    {
        /* Clock activation.*/
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
        if(spip == &SPID1)
    2efc:	84 5a       	subi	r24, 0xA4	; 164
    2efe:	92 40       	sbci	r25, 0x02	; 2
    2f00:	e1 f7       	brne	.-8      	; 0x2efa <spi_lld_start+0xe>
        {
            SPCR = (1<<MSTR)|
                   (1<<SPIE)| //enable interrupt
                   (1<<SPR1)|(1<<SPR0)| //Clk/128
                   ((spip->config->spi_mode & 0x3)<<CPHA);
    2f02:	e0 91 a5 02 	lds	r30, 0x02A5
    2f06:	f0 91 a6 02 	lds	r31, 0x02A6
    2f0a:	82 81       	ldd	r24, Z+2	; 0x02
    2f0c:	83 70       	andi	r24, 0x03	; 3
    2f0e:	90 e0       	ldi	r25, 0x00	; 0
    2f10:	88 0f       	add	r24, r24
    2f12:	99 1f       	adc	r25, r25
    2f14:	88 0f       	add	r24, r24
    2f16:	99 1f       	adc	r25, r25
    {
        /* Clock activation.*/
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
        if(spip == &SPID1)
        {
            SPCR = (1<<MSTR)|
    2f18:	83 69       	ori	r24, 0x93	; 147
    2f1a:	9f 6f       	ori	r25, 0xFF	; 255
    2f1c:	8c bd       	out	0x2c, r24	; 44
    /* Configuration.*/
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    {
        /*mosi, sck and ss output*/
        PORT_SPI1 |= (1<<SPI1_SCK)|(1<<SPI1_MOSI)|(1<<SPI1_SS);
    2f1e:	85 b1       	in	r24, 0x05	; 5
    2f20:	8c 62       	ori	r24, 0x2C	; 44
    2f22:	85 b9       	out	0x05, r24	; 5
        PORT_SPI1 &= ~(1<<SPI1_MISO);
    2f24:	2c 98       	cbi	0x05, 4	; 5
        SPCR |= (1<<SPE);
    2f26:	8c b5       	in	r24, 0x2c	; 44
    2f28:	80 64       	ori	r24, 0x40	; 64
    2f2a:	8c bd       	out	0x2c, r24	; 44
    2f2c:	08 95       	ret

00002f2e <spi_lld_stop>:
 * @notapi
 */
void spi_lld_stop(SPIDriver *spip)
{
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    2f2e:	84 5a       	subi	r24, 0xA4	; 164
    2f30:	92 40       	sbci	r25, 0x02	; 2
    2f32:	09 f0       	breq	.+2      	; 0x2f36 <spi_lld_stop+0x8>
    2f34:	08 95       	ret
    {
        /*all input*/
        PORT_SPI1 &= ~((1<<SPI1_MISO)|(1<<SPI1_SCK)|(1<<SPI1_MOSI)|(1<<SPI1_SS));
    2f36:	85 b1       	in	r24, 0x05	; 5
    2f38:	83 7c       	andi	r24, 0xC3	; 195
    2f3a:	85 b9       	out	0x05, r24	; 5
        SPCR &=~(1<<SPE);
    2f3c:	8c b5       	in	r24, 0x2c	; 44
    2f3e:	8f 7b       	andi	r24, 0xBF	; 191
    2f40:	8c bd       	out	0x2c, r24	; 44
    2f42:	08 95       	ret

00002f44 <spi_lld_select>:
 */
void spi_lld_select(SPIDriver *spip)
{

#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    2f44:	84 5a       	subi	r24, 0xA4	; 164
    2f46:	92 40       	sbci	r25, 0x02	; 2
    2f48:	09 f0       	breq	.+2      	; 0x2f4c <spi_lld_select+0x8>
    2f4a:	08 95       	ret
    {

        PORT_SPI1 &= ~_BV(SPI1_SS);
    2f4c:	2a 98       	cbi	0x05, 2	; 5
        DDR_SPI1  |= _BV(SPI1_SS);
    2f4e:	22 9a       	sbi	0x04, 2	; 4
    2f50:	08 95       	ret

00002f52 <spi_lld_unselect>:
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip)
{
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    2f52:	84 5a       	subi	r24, 0xA4	; 164
    2f54:	92 40       	sbci	r25, 0x02	; 2
    2f56:	09 f0       	breq	.+2      	; 0x2f5a <spi_lld_unselect+0x8>
    2f58:	08 95       	ret
    {
        DDR_SPI1  &= ~_BV(SPI1_SS);
    2f5a:	22 98       	cbi	0x04, 2	; 4
        PORT_SPI1 |= _BV(SPI1_SS);
    2f5c:	2a 9a       	sbi	0x05, 2	; 5
    2f5e:	08 95       	ret

00002f60 <spi_lld_ignore>:

}

static void spi_setup_transmission(SPIDriver *spip,size_t n, const uint8_t *txbuf, uint8_t *rxbuf)
{
    spip->tx_buffer= txbuf;
    2f60:	fc 01       	movw	r30, r24
    2f62:	10 8a       	std	Z+16, r1	; 0x10
    2f64:	17 86       	std	Z+15, r1	; 0x0f
    spip->rx_buffer= rxbuf;
    2f66:	12 8a       	std	Z+18, r1	; 0x12
    2f68:	11 8a       	std	Z+17, r1	; 0x11
    spip->untransmitted_bytes= n;
    2f6a:	76 87       	std	Z+14, r23	; 0x0e
    2f6c:	65 87       	std	Z+13, r22	; 0x0d
 * @notapi
 */
void spi_lld_ignore(SPIDriver *spip, size_t n)
{
    spi_setup_transmission(spip, n, NULL,NULL);
    spi_start_transmission(spip);
    2f6e:	0c 94 d1 16 	jmp	0x2da2	; 0x2da2 <spi_start_transmission>

00002f72 <spi_lld_exchange>:

}

static void spi_setup_transmission(SPIDriver *spip,size_t n, const uint8_t *txbuf, uint8_t *rxbuf)
{
    spip->tx_buffer= txbuf;
    2f72:	fc 01       	movw	r30, r24
    2f74:	50 8b       	std	Z+16, r21	; 0x10
    2f76:	47 87       	std	Z+15, r20	; 0x0f
    spip->rx_buffer= rxbuf;
    2f78:	32 8b       	std	Z+18, r19	; 0x12
    2f7a:	21 8b       	std	Z+17, r18	; 0x11
    spip->untransmitted_bytes= n;
    2f7c:	76 87       	std	Z+14, r23	; 0x0e
    2f7e:	65 87       	std	Z+13, r22	; 0x0d
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf)
{
    spi_setup_transmission(spip, n, txbuf, rxbuf);
    spi_start_transmission(spip);
    2f80:	0c 94 d1 16 	jmp	0x2da2	; 0x2da2 <spi_start_transmission>

00002f84 <spi_lld_send>:

}

static void spi_setup_transmission(SPIDriver *spip,size_t n, const uint8_t *txbuf, uint8_t *rxbuf)
{
    spip->tx_buffer= txbuf;
    2f84:	fc 01       	movw	r30, r24
    2f86:	50 8b       	std	Z+16, r21	; 0x10
    2f88:	47 87       	std	Z+15, r20	; 0x0f
    spip->rx_buffer= rxbuf;
    2f8a:	12 8a       	std	Z+18, r1	; 0x12
    2f8c:	11 8a       	std	Z+17, r1	; 0x11
    spip->untransmitted_bytes= n;
    2f8e:	76 87       	std	Z+14, r23	; 0x0e
    2f90:	65 87       	std	Z+13, r22	; 0x0d
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf)
{
    spi_setup_transmission(spip, n, txbuf, NULL);
    spi_start_transmission(spip);
    2f92:	0c 94 d1 16 	jmp	0x2da2	; 0x2da2 <spi_start_transmission>

00002f96 <spi_lld_receive>:

}

static void spi_setup_transmission(SPIDriver *spip,size_t n, const uint8_t *txbuf, uint8_t *rxbuf)
{
    spip->tx_buffer= txbuf;
    2f96:	fc 01       	movw	r30, r24
    2f98:	10 8a       	std	Z+16, r1	; 0x10
    2f9a:	17 86       	std	Z+15, r1	; 0x0f
    spip->rx_buffer= rxbuf;
    2f9c:	52 8b       	std	Z+18, r21	; 0x12
    2f9e:	41 8b       	std	Z+17, r20	; 0x11
    spip->untransmitted_bytes= n;
    2fa0:	76 87       	std	Z+14, r23	; 0x0e
    2fa2:	65 87       	std	Z+13, r22	; 0x0d
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf)
{
    spi_setup_transmission(spip, n, NULL, rxbuf);
    spi_start_transmission(spip);
    2fa4:	0c 94 d1 16 	jmp	0x2da2	; 0x2da2 <spi_start_transmission>

00002fa8 <spi_lld_polled_exchange>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint8_t spi_lld_polled_exchange(SPIDriver *spip, uint8_t frame)
{
    2fa8:	fc 01       	movw	r30, r24
    while(spip->state !=SPI_READY)
    2faa:	80 81       	ld	r24, Z
    2fac:	82 30       	cpi	r24, 0x02	; 2
    2fae:	e9 f7       	brne	.-6      	; 0x2faa <spi_lld_polled_exchange+0x2>
        ;
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    2fb0:	e4 5a       	subi	r30, 0xA4	; 164
    2fb2:	f2 40       	sbci	r31, 0x02	; 2
    2fb4:	09 f0       	breq	.+2      	; 0x2fb8 <spi_lld_polled_exchange+0x10>
        SPCR |= (1<<SPIE);
        return retval;

    }
#endif
}
    2fb6:	08 95       	ret
    while(spip->state !=SPI_READY)
        ;
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    {
        SPCR &= ~(1<<SPIE);
    2fb8:	8c b5       	in	r24, 0x2c	; 44
    2fba:	8f 77       	andi	r24, 0x7F	; 127
    2fbc:	8c bd       	out	0x2c, r24	; 44

        SPDR = frame;
    2fbe:	6e bd       	out	0x2e, r22	; 46

        while(!(SPSR & (1<<SPIF)))
    2fc0:	0d b4       	in	r0, 0x2d	; 45
    2fc2:	07 fe       	sbrs	r0, 7
    2fc4:	fd cf       	rjmp	.-6      	; 0x2fc0 <spi_lld_polled_exchange+0x18>
            ;
        uint8_t retval = SPDR; //this is needed to clear spif
    2fc6:	8e b5       	in	r24, 0x2e	; 46
        SPCR |= (1<<SPIE);
    2fc8:	9c b5       	in	r25, 0x2c	; 44
    2fca:	90 68       	ori	r25, 0x80	; 128
    2fcc:	9c bd       	out	0x2c, r25	; 44
    2fce:	08 95       	ret

00002fd0 <findBestPrescaler>:
uint16_t ratio_extended[]={1024,256,128,64,32,8,1};
uint8_t clock_source_extended[]={7,6,5,4,3,2,1};


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
{
    2fd0:	4f 92       	push	r4
    2fd2:	5f 92       	push	r5
    2fd4:	6f 92       	push	r6
    2fd6:	7f 92       	push	r7
    2fd8:	8f 92       	push	r8
    2fda:	9f 92       	push	r9
    2fdc:	af 92       	push	r10
    2fde:	bf 92       	push	r11
    2fe0:	cf 92       	push	r12
    2fe2:	df 92       	push	r13
    2fe4:	ef 92       	push	r14
    2fe6:	ff 92       	push	r15
    2fe8:	0f 93       	push	r16
    2fea:	1f 93       	push	r17
    2fec:	cf 93       	push	r28
    2fee:	df 93       	push	r29
    2ff0:	5c 01       	movw	r10, r24
    2ff2:	eb 01       	movw	r28, r22
    2ff4:	82 2e       	mov	r8, r18
  uint8_t i;
  for(i=0;i<n;i++)
    2ff6:	22 23       	and	r18, r18
    2ff8:	09 f4       	brne	.+2      	; 0x2ffc <findBestPrescaler+0x2c>
    2ffa:	5f c0       	rjmp	.+190    	; 0x30ba <findBestPrescaler+0xea>
  {
    uint32_t result = F_CPU/ratio[i]/frequency;
    2ffc:	08 81       	ld	r16, Y
    2ffe:	19 81       	ldd	r17, Y+1	; 0x01
    3000:	6c 01       	movw	r12, r24
    3002:	e1 2c       	mov	r14, r1
    3004:	f1 2c       	mov	r15, r1
    3006:	98 01       	movw	r18, r16
    3008:	40 e0       	ldi	r20, 0x00	; 0
    300a:	50 e0       	ldi	r21, 0x00	; 0
    300c:	60 e0       	ldi	r22, 0x00	; 0
    300e:	74 e2       	ldi	r23, 0x24	; 36
    3010:	84 ef       	ldi	r24, 0xF4	; 244
    3012:	90 e0       	ldi	r25, 0x00	; 0
    3014:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <__udivmodsi4>
    3018:	ca 01       	movw	r24, r20
    301a:	b9 01       	movw	r22, r18
    301c:	a7 01       	movw	r20, r14
    301e:	96 01       	movw	r18, r12
    3020:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <__udivmodsi4>
    3024:	29 01       	movw	r4, r18
    3026:	3a 01       	movw	r6, r20
    if(result > 256UL)
    3028:	21 e0       	ldi	r18, 0x01	; 1
    302a:	42 16       	cp	r4, r18
    302c:	52 06       	cpc	r5, r18
    302e:	61 04       	cpc	r6, r1
    3030:	71 04       	cpc	r7, r1
    3032:	08 f0       	brcs	.+2      	; 0x3036 <findBestPrescaler+0x66>
    3034:	58 c0       	rjmp	.+176    	; 0x30e6 <findBestPrescaler+0x116>
       return (i-1);
    if(result * ratio[i] * frequency == F_CPU)
    3036:	98 01       	movw	r18, r16
    3038:	d5 01       	movw	r26, r10
    303a:	0e 94 2e 1e 	call	0x3c5c	; 0x3c5c <__umulhisi3>
    303e:	9b 01       	movw	r18, r22
    3040:	ac 01       	movw	r20, r24
    3042:	c3 01       	movw	r24, r6
    3044:	b2 01       	movw	r22, r4
    3046:	0e 94 3a 1e 	call	0x3c74	; 0x3c74 <__mulsi3>
    304a:	61 15       	cp	r22, r1
    304c:	74 42       	sbci	r23, 0x24	; 36
    304e:	84 4f       	sbci	r24, 0xF4	; 244
    3050:	91 05       	cpc	r25, r1
    3052:	09 f4       	brne	.+2      	; 0x3056 <findBestPrescaler+0x86>
    3054:	46 c0       	rjmp	.+140    	; 0x30e2 <findBestPrescaler+0x112>
uint8_t clock_source_base[]={5,4,3,2,1};
uint16_t ratio_extended[]={1024,256,128,64,32,8,1};
uint8_t clock_source_extended[]={7,6,5,4,3,2,1};


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
    3056:	8e 01       	movw	r16, r28
    3058:	0e 5f       	subi	r16, 0xFE	; 254
    305a:	1f 4f       	sbci	r17, 0xFF	; 255
{
  uint8_t i;
  for(i=0;i<n;i++)
    305c:	91 2c       	mov	r9, r1
    305e:	2a c0       	rjmp	.+84     	; 0x30b4 <findBestPrescaler+0xe4>
  {
    uint32_t result = F_CPU/ratio[i]/frequency;
    3060:	f8 01       	movw	r30, r16
    3062:	c1 91       	ld	r28, Z+
    3064:	d1 91       	ld	r29, Z+
    3066:	8f 01       	movw	r16, r30
    3068:	9e 01       	movw	r18, r28
    306a:	40 e0       	ldi	r20, 0x00	; 0
    306c:	50 e0       	ldi	r21, 0x00	; 0
    306e:	60 e0       	ldi	r22, 0x00	; 0
    3070:	74 e2       	ldi	r23, 0x24	; 36
    3072:	84 ef       	ldi	r24, 0xF4	; 244
    3074:	90 e0       	ldi	r25, 0x00	; 0
    3076:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <__udivmodsi4>
    307a:	ca 01       	movw	r24, r20
    307c:	b9 01       	movw	r22, r18
    307e:	a7 01       	movw	r20, r14
    3080:	96 01       	movw	r18, r12
    3082:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <__udivmodsi4>
    3086:	29 01       	movw	r4, r18
    3088:	3a 01       	movw	r6, r20
    if(result > 256UL)
    308a:	21 30       	cpi	r18, 0x01	; 1
    308c:	f1 e0       	ldi	r31, 0x01	; 1
    308e:	3f 07       	cpc	r19, r31
    3090:	41 05       	cpc	r20, r1
    3092:	51 05       	cpc	r21, r1
    3094:	98 f4       	brcc	.+38     	; 0x30bc <findBestPrescaler+0xec>
       return (i-1);
    if(result * ratio[i] * frequency == F_CPU)
    3096:	9e 01       	movw	r18, r28
    3098:	d5 01       	movw	r26, r10
    309a:	0e 94 2e 1e 	call	0x3c5c	; 0x3c5c <__umulhisi3>
    309e:	9b 01       	movw	r18, r22
    30a0:	ac 01       	movw	r20, r24
    30a2:	c3 01       	movw	r24, r6
    30a4:	b2 01       	movw	r22, r4
    30a6:	0e 94 3a 1e 	call	0x3c74	; 0x3c74 <__mulsi3>
    30aa:	61 15       	cp	r22, r1
    30ac:	74 42       	sbci	r23, 0x24	; 36
    30ae:	84 4f       	sbci	r24, 0xF4	; 244
    30b0:	91 05       	cpc	r25, r1
    30b2:	29 f0       	breq	.+10     	; 0x30be <findBestPrescaler+0xee>


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
{
  uint8_t i;
  for(i=0;i<n;i++)
    30b4:	93 94       	inc	r9
    30b6:	98 10       	cpse	r9, r8
    30b8:	d3 cf       	rjmp	.-90     	; 0x3060 <findBestPrescaler+0x90>
    30ba:	02 c0       	rjmp	.+4      	; 0x30c0 <findBestPrescaler+0xf0>
    30bc:	9a 94       	dec	r9
    30be:	89 2d       	mov	r24, r9
       return (i-1);
    if(result * ratio[i] * frequency == F_CPU)
      return i;
  };
  
    30c0:	df 91       	pop	r29
    30c2:	cf 91       	pop	r28
    30c4:	1f 91       	pop	r17
    30c6:	0f 91       	pop	r16
    30c8:	ff 90       	pop	r15
    30ca:	ef 90       	pop	r14
    30cc:	df 90       	pop	r13
    30ce:	cf 90       	pop	r12
    30d0:	bf 90       	pop	r11
    30d2:	af 90       	pop	r10
    30d4:	9f 90       	pop	r9
    30d6:	8f 90       	pop	r8
    30d8:	7f 90       	pop	r7
    30da:	6f 90       	pop	r6
    30dc:	5f 90       	pop	r5
    30de:	4f 90       	pop	r4
    30e0:	08 95       	ret


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
{
  uint8_t i;
  for(i=0;i<n;i++)
    30e2:	91 2c       	mov	r9, r1
    30e4:	ec cf       	rjmp	.-40     	; 0x30be <findBestPrescaler+0xee>
  {
    uint32_t result = F_CPU/ratio[i]/frequency;
    if(result > 256UL)
    30e6:	99 24       	eor	r9, r9
    30e8:	9a 94       	dec	r9
       return (i-1);
    30ea:	e9 cf       	rjmp	.-46     	; 0x30be <findBestPrescaler+0xee>

000030ec <boardInit>:
 * Board-specific initialization code.
 */



void boardInit(void) {
    30ec:	08 95       	ret

000030ee <tmrcb>:
 */

#include "ch.h"
#include "evtimer.h"

static void tmrcb(void *p) {
    30ee:	cf 93       	push	r28
    30f0:	df 93       	push	r29
    30f2:	ec 01       	movw	r28, r24
  EvTimer *etp = p;

  chSysLockFromIsr();
  chEvtBroadcastI(&etp->et_es);
    30f4:	60 e0       	ldi	r22, 0x00	; 0
    30f6:	0a 96       	adiw	r24, 0x0a	; 10
    30f8:	0e 94 87 09 	call	0x130e	; 0x130e <chEvtBroadcastFlagsI>
  chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    30fc:	6c 85       	ldd	r22, Y+12	; 0x0c
    30fe:	7d 85       	ldd	r23, Y+13	; 0x0d
    3100:	9e 01       	movw	r18, r28
    3102:	47 e7       	ldi	r20, 0x77	; 119
    3104:	58 e1       	ldi	r21, 0x18	; 24
    3106:	ce 01       	movw	r24, r28
  chSysUnlockFromIsr();
}
    3108:	df 91       	pop	r29
    310a:	cf 91       	pop	r28
static void tmrcb(void *p) {
  EvTimer *etp = p;

  chSysLockFromIsr();
  chEvtBroadcastI(&etp->et_es);
  chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    310c:	0c 94 5f 01 	jmp	0x2be	; 0x2be <chVTSetI>

00003110 <evtStart>:
 *
 * @param etp pointer to an initialized @p EvTimer structure.
 */
void evtStart(EvTimer *etp) {

  chSysLock();
    3110:	f8 94       	cli

  if (!chVTIsArmedI(&etp->et_vt))
    3112:	fc 01       	movw	r30, r24
    3114:	26 81       	ldd	r18, Z+6	; 0x06
    3116:	37 81       	ldd	r19, Z+7	; 0x07
    3118:	23 2b       	or	r18, r19
    311a:	11 f0       	breq	.+4      	; 0x3120 <evtStart+0x10>
    chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);

  chSysUnlock();
    311c:	78 94       	sei
    311e:	08 95       	ret
void evtStart(EvTimer *etp) {

  chSysLock();

  if (!chVTIsArmedI(&etp->et_vt))
    chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    3120:	64 85       	ldd	r22, Z+12	; 0x0c
    3122:	75 85       	ldd	r23, Z+13	; 0x0d
    3124:	9c 01       	movw	r18, r24
    3126:	47 e7       	ldi	r20, 0x77	; 119
    3128:	58 e1       	ldi	r21, 0x18	; 24
    312a:	0e 94 5f 01 	call	0x2be	; 0x2be <chVTSetI>

  chSysUnlock();
    312e:	78 94       	sei
    3130:	08 95       	ret

00003132 <evtStop>:
 *
 * @param etp pointer to an initialized @p EvTimer structure.
 */
void evtStop(EvTimer *etp) {

  chVTReset(&etp->et_vt);
    3132:	f8 94       	cli
    3134:	fc 01       	movw	r30, r24
    3136:	26 81       	ldd	r18, Z+6	; 0x06
    3138:	37 81       	ldd	r19, Z+7	; 0x07
    313a:	23 2b       	or	r18, r19
    313c:	11 f0       	breq	.+4      	; 0x3142 <evtStop+0x10>
    313e:	0e 94 9b 01 	call	0x336	; 0x336 <chVTResetI>
    3142:	78 94       	sei
    3144:	08 95       	ret

00003146 <long_to_string_with_divisor.constprop.0>:
#include "chprintf.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 100000

static char *long_to_string_with_divisor(char *p,
    3146:	3f 92       	push	r3
    3148:	4f 92       	push	r4
    314a:	5f 92       	push	r5
    314c:	6f 92       	push	r6
    314e:	7f 92       	push	r7
    3150:	8f 92       	push	r8
    3152:	9f 92       	push	r9
    3154:	af 92       	push	r10
    3156:	bf 92       	push	r11
    3158:	cf 92       	push	r12
    315a:	df 92       	push	r13
    315c:	ef 92       	push	r14
    315e:	ff 92       	push	r15
    3160:	0f 93       	push	r16
    3162:	1f 93       	push	r17
    3164:	cf 93       	push	r28
    3166:	df 93       	push	r29
    3168:	00 d0       	rcall	.+0      	; 0x316a <long_to_string_with_divisor.constprop.0+0x24>
    316a:	00 d0       	rcall	.+0      	; 0x316c <long_to_string_with_divisor.constprop.0+0x26>
    316c:	cd b7       	in	r28, 0x3d	; 61
    316e:	de b7       	in	r29, 0x3e	; 62
    3170:	9c 83       	std	Y+4, r25	; 0x04
    3172:	8b 83       	std	Y+3, r24	; 0x03
    3174:	2a 01       	movw	r4, r20
    3176:	3b 01       	movw	r6, r22
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
    3178:	0b 96       	adiw	r24, 0x0b	; 11
    317a:	9a 83       	std	Y+2, r25	; 0x02
    317c:	89 83       	std	Y+1, r24	; 0x01
    317e:	49 01       	movw	r8, r18
    3180:	a1 2c       	mov	r10, r1
    3182:	b1 2c       	mov	r11, r1
    3184:	6a 01       	movw	r12, r20
    3186:	7b 01       	movw	r14, r22
    3188:	8c 01       	movw	r16, r24
  do {
    i = (int)(l % radix);
    318a:	b2 01       	movw	r22, r4
    318c:	c3 01       	movw	r24, r6
    318e:	a5 01       	movw	r20, r10
    3190:	94 01       	movw	r18, r8
    3192:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <__divmodsi4>
    i += '0';
    3196:	cb 01       	movw	r24, r22
    3198:	c0 96       	adiw	r24, 0x30	; 48
    if (i > '9')
    319a:	8a 33       	cpi	r24, 0x3A	; 58
    319c:	91 05       	cpc	r25, r1
    319e:	14 f0       	brlt	.+4      	; 0x31a4 <long_to_string_with_divisor.constprop.0+0x5e>
      i += 'A' - '0' - 10;
    31a0:	cb 01       	movw	r24, r22
    31a2:	c7 96       	adiw	r24, 0x37	; 55
    *--q = i;
    31a4:	38 2e       	mov	r3, r24
    31a6:	d8 01       	movw	r26, r16
    31a8:	8e 93       	st	-X, r24
    31aa:	8d 01       	movw	r16, r26
    l /= radix;
    31ac:	b2 01       	movw	r22, r4
    31ae:	c3 01       	movw	r24, r6
    31b0:	a5 01       	movw	r20, r10
    31b2:	94 01       	movw	r18, r8
    31b4:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <__divmodsi4>
    31b8:	29 01       	movw	r4, r18
    31ba:	3a 01       	movw	r6, r20
  } while ((ll /= radix) != 0);
    31bc:	c7 01       	movw	r24, r14
    31be:	b6 01       	movw	r22, r12
    31c0:	a5 01       	movw	r20, r10
    31c2:	94 01       	movw	r18, r8
    31c4:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <__divmodsi4>
    31c8:	69 01       	movw	r12, r18
    31ca:	7a 01       	movw	r14, r20
    31cc:	21 15       	cp	r18, r1
    31ce:	31 05       	cpc	r19, r1
    31d0:	41 05       	cpc	r20, r1
    31d2:	51 05       	cpc	r21, r1
    31d4:	d1 f6       	brne	.-76     	; 0x318a <long_to_string_with_divisor.constprop.0+0x44>
#include "chprintf.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 100000

static char *long_to_string_with_divisor(char *p,
    31d6:	f8 01       	movw	r30, r16
    31d8:	31 96       	adiw	r30, 0x01	; 1
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
    31da:	89 81       	ldd	r24, Y+1	; 0x01
    31dc:	9a 81       	ldd	r25, Y+2	; 0x02
    31de:	80 1b       	sub	r24, r16
    31e0:	91 0b       	sbc	r25, r17
#include "chprintf.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 100000

static char *long_to_string_with_divisor(char *p,
    31e2:	2b 81       	ldd	r18, Y+3	; 0x03
    31e4:	3c 81       	ldd	r19, Y+4	; 0x04
    31e6:	82 0f       	add	r24, r18
    31e8:	93 1f       	adc	r25, r19
    31ea:	01 c0       	rjmp	.+2      	; 0x31ee <long_to_string_with_divisor.constprop.0+0xa8>
    31ec:	31 90       	ld	r3, Z+
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
    31ee:	ab 81       	ldd	r26, Y+3	; 0x03
    31f0:	bc 81       	ldd	r27, Y+4	; 0x04
    31f2:	3d 92       	st	X+, r3
    31f4:	bc 83       	std	Y+4, r27	; 0x04
    31f6:	ab 83       	std	Y+3, r26	; 0x03
  while (--i);
    31f8:	a8 17       	cp	r26, r24
    31fa:	b9 07       	cpc	r27, r25
    31fc:	b9 f7       	brne	.-18     	; 0x31ec <long_to_string_with_divisor.constprop.0+0xa6>

  return p;
}
    31fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3200:	9c 81       	ldd	r25, Y+4	; 0x04
    3202:	0f 90       	pop	r0
    3204:	0f 90       	pop	r0
    3206:	0f 90       	pop	r0
    3208:	0f 90       	pop	r0
    320a:	df 91       	pop	r29
    320c:	cf 91       	pop	r28
    320e:	1f 91       	pop	r17
    3210:	0f 91       	pop	r16
    3212:	ff 90       	pop	r15
    3214:	ef 90       	pop	r14
    3216:	df 90       	pop	r13
    3218:	cf 90       	pop	r12
    321a:	bf 90       	pop	r11
    321c:	af 90       	pop	r10
    321e:	9f 90       	pop	r9
    3220:	8f 90       	pop	r8
    3222:	7f 90       	pop	r7
    3224:	6f 90       	pop	r6
    3226:	5f 90       	pop	r5
    3228:	4f 90       	pop	r4
    322a:	3f 90       	pop	r3
    322c:	08 95       	ret

0000322e <chprintf>:
 *          .
 *
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 */
void chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
    322e:	2f 92       	push	r2
    3230:	3f 92       	push	r3
    3232:	4f 92       	push	r4
    3234:	5f 92       	push	r5
    3236:	6f 92       	push	r6
    3238:	7f 92       	push	r7
    323a:	8f 92       	push	r8
    323c:	9f 92       	push	r9
    323e:	af 92       	push	r10
    3240:	bf 92       	push	r11
    3242:	cf 92       	push	r12
    3244:	df 92       	push	r13
    3246:	ef 92       	push	r14
    3248:	ff 92       	push	r15
    324a:	0f 93       	push	r16
    324c:	1f 93       	push	r17
    324e:	cf 93       	push	r28
    3250:	df 93       	push	r29
    3252:	cd b7       	in	r28, 0x3d	; 61
    3254:	de b7       	in	r29, 0x3e	; 62
    3256:	60 97       	sbiw	r28, 0x10	; 16
    3258:	0f b6       	in	r0, 0x3f	; 63
    325a:	f8 94       	cli
    325c:	de bf       	out	0x3e, r29	; 62
    325e:	0f be       	out	0x3f, r0	; 63
    3260:	cd bf       	out	0x3d, r28	; 61
    3262:	cd a0       	ldd	r12, Y+37	; 0x25
    3264:	de a0       	ldd	r13, Y+38	; 0x26
    3266:	ef a0       	ldd	r14, Y+39	; 0x27
    3268:	f8 a4       	ldd	r15, Y+40	; 0x28
  char tmpbuf[2*MAX_FILLER + 1];
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  va_start(ap, fmt);
    326a:	5e 01       	movw	r10, r28
    326c:	29 e2       	ldi	r18, 0x29	; 41
    326e:	a2 0e       	add	r10, r18
    3270:	b1 1c       	adc	r11, r1
      else
        l = va_arg(ap, int);
      p = ltoa(p, l, c);
      break;
    default:
      *p++ = c;
    3272:	ce 01       	movw	r24, r28
    3274:	02 96       	adiw	r24, 0x02	; 2
    3276:	9e 87       	std	Y+14, r25	; 0x0e
    3278:	8d 87       	std	Y+13, r24	; 0x0d
    327a:	22 24       	eor	r2, r2
    327c:	23 94       	inc	r2
    327e:	31 2c       	mov	r3, r1
    3280:	2c 0e       	add	r2, r28
    3282:	3d 1e       	adc	r3, r29
    3284:	82 19       	sub	r24, r2
    3286:	93 09       	sbc	r25, r3
    3288:	98 8b       	std	Y+16, r25	; 0x10
    328a:	8f 87       	std	Y+15, r24	; 0x0f
  char tmpbuf[MAX_FILLER + 1];
#endif

  va_start(ap, fmt);
  while (TRUE) {
    c = *fmt++;
    328c:	d7 01       	movw	r26, r14
    328e:	6d 91       	ld	r22, X+
    3290:	8d 01       	movw	r16, r26
    if (c == 0) {
    3292:	66 23       	and	r22, r22
    3294:	81 f0       	breq	.+32     	; 0x32b6 <chprintf+0x88>
      va_end(ap);
      return;
    }
    if (c != '%') {
    3296:	65 32       	cpi	r22, 0x25	; 37
    3298:	39 f1       	breq	.+78     	; 0x32e8 <chprintf+0xba>
      chSequentialStreamPut(chp, (uint8_t)c);
    329a:	d6 01       	movw	r26, r12
    329c:	ed 91       	ld	r30, X+
    329e:	fc 91       	ld	r31, X
    32a0:	04 80       	ldd	r0, Z+4	; 0x04
    32a2:	f5 81       	ldd	r31, Z+5	; 0x05
    32a4:	e0 2d       	mov	r30, r0
    32a6:	c6 01       	movw	r24, r12
    32a8:	09 95       	icall
  char tmpbuf[MAX_FILLER + 1];
#endif

  va_start(ap, fmt);
  while (TRUE) {
    c = *fmt++;
    32aa:	78 01       	movw	r14, r16
    32ac:	d7 01       	movw	r26, r14
    32ae:	6d 91       	ld	r22, X+
    32b0:	8d 01       	movw	r16, r26
    if (c == 0) {
    32b2:	61 11       	cpse	r22, r1
    32b4:	f0 cf       	rjmp	.-32     	; 0x3296 <chprintf+0x68>
    while (width) {
      chSequentialStreamPut(chp, (uint8_t)filler);
      width--;
    }
  }
}
    32b6:	60 96       	adiw	r28, 0x10	; 16
    32b8:	0f b6       	in	r0, 0x3f	; 63
    32ba:	f8 94       	cli
    32bc:	de bf       	out	0x3e, r29	; 62
    32be:	0f be       	out	0x3f, r0	; 63
    32c0:	cd bf       	out	0x3d, r28	; 61
    32c2:	df 91       	pop	r29
    32c4:	cf 91       	pop	r28
    32c6:	1f 91       	pop	r17
    32c8:	0f 91       	pop	r16
    32ca:	ff 90       	pop	r15
    32cc:	ef 90       	pop	r14
    32ce:	df 90       	pop	r13
    32d0:	cf 90       	pop	r12
    32d2:	bf 90       	pop	r11
    32d4:	af 90       	pop	r10
    32d6:	9f 90       	pop	r9
    32d8:	8f 90       	pop	r8
    32da:	7f 90       	pop	r7
    32dc:	6f 90       	pop	r6
    32de:	5f 90       	pop	r5
    32e0:	4f 90       	pop	r4
    32e2:	3f 90       	pop	r3
    32e4:	2f 90       	pop	r2
    32e6:	08 95       	ret
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
    32e8:	f7 01       	movw	r30, r14
    32ea:	21 81       	ldd	r18, Z+1	; 0x01
    32ec:	2d 32       	cpi	r18, 0x2D	; 45
    32ee:	09 f4       	brne	.+2      	; 0x32f2 <chprintf+0xc4>
    32f0:	f2 c0       	rjmp	.+484    	; 0x34d6 <chprintf+0x2a8>
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    32f2:	41 2c       	mov	r4, r1
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '.') {
    32f4:	2e 32       	cpi	r18, 0x2E	; 46
    32f6:	09 f4       	brne	.+2      	; 0x32fa <chprintf+0xcc>
    32f8:	e6 c0       	rjmp	.+460    	; 0x34c6 <chprintf+0x298>
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    32fa:	b0 e2       	ldi	r27, 0x20	; 32
    32fc:	5b 2e       	mov	r5, r27
 *          .
 *
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 */
void chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
    32fe:	f8 01       	movw	r30, r16
    3300:	31 96       	adiw	r30, 0x01	; 1
    3302:	78 01       	movw	r14, r16
    filler = ' ';
    if (*fmt == '.') {
      fmt++;
      filler = '0';
    }
    width = 0;
    3304:	00 e0       	ldi	r16, 0x00	; 0
    3306:	10 e0       	ldi	r17, 0x00	; 0
    3308:	13 c0       	rjmp	.+38     	; 0x3330 <chprintf+0x102>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
    330a:	d5 01       	movw	r26, r10
    330c:	3c 91       	ld	r19, X
    330e:	82 e0       	ldi	r24, 0x02	; 2
    3310:	a8 0e       	add	r10, r24
    3312:	b1 1c       	adc	r11, r1
      else
        break;
      width = width * 10 + c;
    3314:	c8 01       	movw	r24, r16
    3316:	88 0f       	add	r24, r24
    3318:	99 1f       	adc	r25, r25
    331a:	00 0f       	add	r16, r16
    331c:	11 1f       	adc	r17, r17
    331e:	00 0f       	add	r16, r16
    3320:	11 1f       	adc	r17, r17
    3322:	00 0f       	add	r16, r16
    3324:	11 1f       	adc	r17, r17
    3326:	08 0f       	add	r16, r24
    3328:	19 1f       	adc	r17, r25
    332a:	03 0f       	add	r16, r19
    332c:	11 1d       	adc	r17, r1
    332e:	21 91       	ld	r18, Z+
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
    3330:	bf ef       	ldi	r27, 0xFF	; 255
    3332:	eb 1a       	sub	r14, r27
    3334:	fb 0a       	sbc	r15, r27
      if (c >= '0' && c <= '9')
    3336:	32 2f       	mov	r19, r18
    3338:	30 53       	subi	r19, 0x30	; 48
    333a:	3a 30       	cpi	r19, 0x0A	; 10
    333c:	58 f3       	brcs	.-42     	; 0x3314 <chprintf+0xe6>
        c -= '0';
      else if (c == '*')
    333e:	2a 32       	cpi	r18, 0x2A	; 42
    3340:	21 f3       	breq	.-56     	; 0x330a <chprintf+0xdc>
    3342:	f5 01       	movw	r30, r10
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
    3344:	2e 32       	cpi	r18, 0x2E	; 46
    3346:	09 f4       	brne	.+2      	; 0x334a <chprintf+0x11c>
    3348:	9e c0       	rjmp	.+316    	; 0x3486 <chprintf+0x258>
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    334a:	80 e0       	ldi	r24, 0x00	; 0
    334c:	90 e0       	ldi	r25, 0x00	; 0
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
    334e:	2c 36       	cpi	r18, 0x6C	; 108
    3350:	09 f4       	brne	.+2      	; 0x3354 <chprintf+0x126>
    3352:	81 c0       	rjmp	.+258    	; 0x3456 <chprintf+0x228>
    3354:	2c 34       	cpi	r18, 0x4C	; 76
    3356:	09 f4       	brne	.+2      	; 0x335a <chprintf+0x12c>
    3358:	7e c0       	rjmp	.+252    	; 0x3456 <chprintf+0x228>
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
    335a:	32 2f       	mov	r19, r18
    335c:	31 54       	subi	r19, 0x41	; 65
    335e:	41 e0       	ldi	r20, 0x01	; 1
    3360:	3a 31       	cpi	r19, 0x1A	; 26
    3362:	08 f0       	brcs	.+2      	; 0x3366 <chprintf+0x138>
    3364:	40 e0       	ldi	r20, 0x00	; 0

    /* Command decoding.*/
    switch (c) {
    3366:	23 36       	cpi	r18, 0x63	; 99
    3368:	09 f4       	brne	.+2      	; 0x336c <chprintf+0x13e>
    336a:	82 c0       	rjmp	.+260    	; 0x3470 <chprintf+0x242>
    336c:	24 36       	cpi	r18, 0x64	; 100
    336e:	08 f0       	brcs	.+2      	; 0x3372 <chprintf+0x144>
    3370:	4d c0       	rjmp	.+154    	; 0x340c <chprintf+0x1de>
    3372:	2f 34       	cpi	r18, 0x4F	; 79
    3374:	09 f4       	brne	.+2      	; 0x3378 <chprintf+0x14a>
    3376:	e1 c0       	rjmp	.+450    	; 0x353a <chprintf+0x30c>
    3378:	08 f0       	brcs	.+2      	; 0x337c <chprintf+0x14e>
    337a:	04 c1       	rjmp	.+520    	; 0x3584 <chprintf+0x356>
    337c:	24 34       	cpi	r18, 0x44	; 68
    337e:	09 f4       	brne	.+2      	; 0x3382 <chprintf+0x154>
    3380:	4d c0       	rjmp	.+154    	; 0x341c <chprintf+0x1ee>
      else
        l = va_arg(ap, int);
      p = ltoa(p, l, c);
      break;
    default:
      *p++ = c;
    3382:	29 83       	std	Y+1, r18	; 0x01
    3384:	6f 84       	ldd	r6, Y+15	; 0x0f
    3386:	78 88       	ldd	r7, Y+16	; 0x10
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    3388:	41 01       	movw	r8, r2
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
    338a:	06 19       	sub	r16, r6
    338c:	17 09       	sbc	r17, r7
    338e:	17 fd       	sbrc	r17, 7
    3390:	5f c0       	rjmp	.+190    	; 0x3450 <chprintf+0x222>
      width = 0;
    if (left_align == FALSE)
    3392:	41 10       	cpse	r4, r1
    3394:	15 c0       	rjmp	.+42     	; 0x33c0 <chprintf+0x192>
      width = -width;
    3396:	11 95       	neg	r17
    3398:	01 95       	neg	r16
    339a:	11 09       	sbc	r17, r1
    if (width < 0) {
    339c:	89 f0       	breq	.+34     	; 0x33c0 <chprintf+0x192>
      if (*s == '-' && filler == '0') {
    339e:	d4 01       	movw	r26, r8
    33a0:	8c 91       	ld	r24, X
    33a2:	8d 32       	cpi	r24, 0x2D	; 45
    33a4:	09 f4       	brne	.+2      	; 0x33a8 <chprintf+0x17a>
    33a6:	11 c1       	rjmp	.+546    	; 0x35ca <chprintf+0x39c>
        chSequentialStreamPut(chp, (uint8_t)*s++);
        i--;
      }
      do
        chSequentialStreamPut(chp, (uint8_t)filler);
    33a8:	d6 01       	movw	r26, r12
    33aa:	ed 91       	ld	r30, X+
    33ac:	fc 91       	ld	r31, X
    33ae:	04 80       	ldd	r0, Z+4	; 0x04
    33b0:	f5 81       	ldd	r31, Z+5	; 0x05
    33b2:	e0 2d       	mov	r30, r0
    33b4:	65 2d       	mov	r22, r5
    33b6:	c6 01       	movw	r24, r12
    33b8:	09 95       	icall
      while (++width != 0);
    33ba:	0f 5f       	subi	r16, 0xFF	; 255
    33bc:	1f 4f       	sbci	r17, 0xFF	; 255
    33be:	a1 f7       	brne	.-24     	; 0x33a8 <chprintf+0x17a>
    }
    while (--i >= 0)
    33c0:	16 14       	cp	r1, r6
    33c2:	17 04       	cpc	r1, r7
    33c4:	fc f4       	brge	.+62     	; 0x3404 <chprintf+0x1d6>
 *          .
 *
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 */
void chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
    33c6:	68 0c       	add	r6, r8
    33c8:	79 1c       	adc	r7, r9
      do
        chSequentialStreamPut(chp, (uint8_t)filler);
      while (++width != 0);
    }
    while (--i >= 0)
      chSequentialStreamPut(chp, (uint8_t)*s++);
    33ca:	f4 01       	movw	r30, r8
    33cc:	61 91       	ld	r22, Z+
    33ce:	4f 01       	movw	r8, r30
    33d0:	d6 01       	movw	r26, r12
    33d2:	ed 91       	ld	r30, X+
    33d4:	fc 91       	ld	r31, X
    33d6:	04 80       	ldd	r0, Z+4	; 0x04
    33d8:	f5 81       	ldd	r31, Z+5	; 0x05
    33da:	e0 2d       	mov	r30, r0
    33dc:	c6 01       	movw	r24, r12
    33de:	09 95       	icall
      }
      do
        chSequentialStreamPut(chp, (uint8_t)filler);
      while (++width != 0);
    }
    while (--i >= 0)
    33e0:	86 14       	cp	r8, r6
    33e2:	97 04       	cpc	r9, r7
    33e4:	91 f7       	brne	.-28     	; 0x33ca <chprintf+0x19c>
      chSequentialStreamPut(chp, (uint8_t)*s++);

    while (width) {
    33e6:	01 15       	cp	r16, r1
    33e8:	11 05       	cpc	r17, r1
    33ea:	09 f4       	brne	.+2      	; 0x33ee <chprintf+0x1c0>
    33ec:	4f cf       	rjmp	.-354    	; 0x328c <chprintf+0x5e>
      chSequentialStreamPut(chp, (uint8_t)filler);
    33ee:	d6 01       	movw	r26, r12
    33f0:	ed 91       	ld	r30, X+
    33f2:	fc 91       	ld	r31, X
    33f4:	04 80       	ldd	r0, Z+4	; 0x04
    33f6:	f5 81       	ldd	r31, Z+5	; 0x05
    33f8:	e0 2d       	mov	r30, r0
    33fa:	65 2d       	mov	r22, r5
    33fc:	c6 01       	movw	r24, r12
    33fe:	09 95       	icall
      width--;
    3400:	01 50       	subi	r16, 0x01	; 1
    3402:	11 09       	sbc	r17, r1
      while (++width != 0);
    }
    while (--i >= 0)
      chSequentialStreamPut(chp, (uint8_t)*s++);

    while (width) {
    3404:	01 15       	cp	r16, r1
    3406:	11 05       	cpc	r17, r1
    3408:	91 f7       	brne	.-28     	; 0x33ee <chprintf+0x1c0>
    340a:	40 cf       	rjmp	.-384    	; 0x328c <chprintf+0x5e>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    340c:	23 37       	cpi	r18, 0x73	; 115
    340e:	09 f4       	brne	.+2      	; 0x3412 <chprintf+0x1e4>
    3410:	6b c0       	rjmp	.+214    	; 0x34e8 <chprintf+0x2ba>
    3412:	08 f0       	brcs	.+2      	; 0x3416 <chprintf+0x1e8>
    3414:	af c0       	rjmp	.+350    	; 0x3574 <chprintf+0x346>
    3416:	24 36       	cpi	r18, 0x64	; 100
    3418:	09 f0       	breq	.+2      	; 0x341c <chprintf+0x1ee>
    341a:	8c c0       	rjmp	.+280    	; 0x3534 <chprintf+0x306>
      for (p = s; *p && (--precision >= 0); p++)
        ;
      break;
    case 'D':
    case 'd':
      if (is_long)
    341c:	41 11       	cpse	r20, r1
    341e:	bd c0       	rjmp	.+378    	; 0x359a <chprintf+0x36c>
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
    3420:	22 e0       	ldi	r18, 0x02	; 2
    3422:	a2 0e       	add	r10, r18
    3424:	b1 1c       	adc	r11, r1
    3426:	40 81       	ld	r20, Z
    3428:	51 81       	ldd	r21, Z+1	; 0x01
    342a:	66 27       	eor	r22, r22
    342c:	57 fd       	sbrc	r21, 7
    342e:	60 95       	com	r22
    3430:	76 2f       	mov	r23, r22
      if (l < 0) {
    3432:	77 fd       	sbrc	r23, 7
    3434:	bb c0       	rjmp	.+374    	; 0x35ac <chprintf+0x37e>
    }
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    3436:	c1 01       	movw	r24, r2
  return p;
}

static char *ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
    3438:	2a e0       	ldi	r18, 0x0A	; 10
    343a:	30 e0       	ldi	r19, 0x00	; 0
    343c:	0e 94 a3 18 	call	0x3146	; 0x3146 <long_to_string_with_divisor.constprop.0>
    3440:	3c 01       	movw	r6, r24
    3442:	62 18       	sub	r6, r2
    3444:	73 08       	sbc	r7, r3
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    3446:	41 01       	movw	r8, r2
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
    3448:	06 19       	sub	r16, r6
    344a:	17 09       	sbc	r17, r7
    344c:	17 ff       	sbrs	r17, 7
    344e:	a1 cf       	rjmp	.-190    	; 0x3392 <chprintf+0x164>
    3450:	00 e0       	ldi	r16, 0x00	; 0
    3452:	10 e0       	ldi	r17, 0x00	; 0
    3454:	9e cf       	rjmp	.-196    	; 0x3392 <chprintf+0x164>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
    3456:	d7 01       	movw	r26, r14
    3458:	3c 91       	ld	r19, X
    345a:	33 23       	and	r19, r19
    345c:	09 f4       	brne	.+2      	; 0x3460 <chprintf+0x232>
    345e:	42 c0       	rjmp	.+132    	; 0x34e4 <chprintf+0x2b6>
        c = *fmt++;
    3460:	bf ef       	ldi	r27, 0xFF	; 255
    3462:	eb 1a       	sub	r14, r27
    3464:	fb 0a       	sbc	r15, r27
    3466:	23 2f       	mov	r18, r19
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
    3468:	41 e0       	ldi	r20, 0x01	; 1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    346a:	23 36       	cpi	r18, 0x63	; 99
    346c:	09 f0       	breq	.+2      	; 0x3470 <chprintf+0x242>
    346e:	7e cf       	rjmp	.-260    	; 0x336c <chprintf+0x13e>
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
    3470:	22 e0       	ldi	r18, 0x02	; 2
    3472:	a2 0e       	add	r10, r18
    3474:	b1 1c       	adc	r11, r1
    3476:	80 81       	ld	r24, Z
    3478:	89 83       	std	Y+1, r24	; 0x01
    347a:	6f 84       	ldd	r6, Y+15	; 0x0f
    347c:	78 88       	ldd	r7, Y+16	; 0x10
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
    347e:	30 e2       	ldi	r19, 0x20	; 32
    3480:	53 2e       	mov	r5, r19
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    3482:	41 01       	movw	r8, r2
    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    3484:	82 cf       	rjmp	.-252    	; 0x338a <chprintf+0x15c>
    3486:	f7 01       	movw	r30, r14
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
    3488:	80 e0       	ldi	r24, 0x00	; 0
    348a:	90 e0       	ldi	r25, 0x00	; 0
    348c:	12 c0       	rjmp	.+36     	; 0x34b2 <chprintf+0x284>
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
    348e:	d5 01       	movw	r26, r10
    3490:	4c 91       	ld	r20, X
    3492:	22 e0       	ldi	r18, 0x02	; 2
    3494:	a2 0e       	add	r10, r18
    3496:	b1 1c       	adc	r11, r1
        else
          break;
        precision *= 10;
    3498:	9c 01       	movw	r18, r24
    349a:	22 0f       	add	r18, r18
    349c:	33 1f       	adc	r19, r19
    349e:	88 0f       	add	r24, r24
    34a0:	99 1f       	adc	r25, r25
    34a2:	88 0f       	add	r24, r24
    34a4:	99 1f       	adc	r25, r25
    34a6:	88 0f       	add	r24, r24
    34a8:	99 1f       	adc	r25, r25
    34aa:	82 0f       	add	r24, r18
    34ac:	93 1f       	adc	r25, r19
        precision += c;
    34ae:	84 0f       	add	r24, r20
    34b0:	91 1d       	adc	r25, r1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
    34b2:	21 91       	ld	r18, Z+
    34b4:	7f 01       	movw	r14, r30
        if (c >= '0' && c <= '9')
    34b6:	42 2f       	mov	r20, r18
    34b8:	40 53       	subi	r20, 0x30	; 48
    34ba:	4a 30       	cpi	r20, 0x0A	; 10
    34bc:	68 f3       	brcs	.-38     	; 0x3498 <chprintf+0x26a>
          c -= '0';
        else if (c == '*')
    34be:	2a 32       	cpi	r18, 0x2A	; 42
    34c0:	31 f3       	breq	.-52     	; 0x348e <chprintf+0x260>
    34c2:	f5 01       	movw	r30, r10
    34c4:	44 cf       	rjmp	.-376    	; 0x334e <chprintf+0x120>
    34c6:	d8 01       	movw	r26, r16
    34c8:	11 96       	adiw	r26, 0x01	; 1
    34ca:	2c 91       	ld	r18, X
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '.') {
      fmt++;
    34cc:	0f 5f       	subi	r16, 0xFF	; 255
    34ce:	1f 4f       	sbci	r17, 0xFF	; 255
      filler = '0';
    34d0:	80 e3       	ldi	r24, 0x30	; 48
    34d2:	58 2e       	mov	r5, r24
    34d4:	14 cf       	rjmp	.-472    	; 0x32fe <chprintf+0xd0>
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
    34d6:	87 01       	movw	r16, r14
    34d8:	0e 5f       	subi	r16, 0xFE	; 254
    34da:	1f 4f       	sbci	r17, 0xFF	; 255
    34dc:	22 81       	ldd	r18, Z+2	; 0x02
      left_align = TRUE;
    34de:	44 24       	eor	r4, r4
    34e0:	43 94       	inc	r4
    34e2:	08 cf       	rjmp	.-496    	; 0x32f4 <chprintf+0xc6>
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
    34e4:	41 e0       	ldi	r20, 0x01	; 1
    34e6:	3f cf       	rjmp	.-386    	; 0x3366 <chprintf+0x138>
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
    34e8:	32 e0       	ldi	r19, 0x02	; 2
    34ea:	a3 0e       	add	r10, r19
    34ec:	b1 1c       	adc	r11, r1
    34ee:	80 80       	ld	r8, Z
    34f0:	91 80       	ldd	r9, Z+1	; 0x01
    34f2:	81 14       	cp	r8, r1
    34f4:	91 04       	cpc	r9, r1
    34f6:	09 f4       	brne	.+2      	; 0x34fa <chprintf+0x2cc>
    34f8:	7b c0       	rjmp	.+246    	; 0x35f0 <chprintf+0x3c2>
        s = "(null)";
      if (precision == 0)
    34fa:	00 97       	sbiw	r24, 0x00	; 0
    34fc:	09 f4       	brne	.+2      	; 0x3500 <chprintf+0x2d2>
    34fe:	62 c0       	rjmp	.+196    	; 0x35c4 <chprintf+0x396>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    3500:	d4 01       	movw	r26, r8
    3502:	2c 91       	ld	r18, X
    3504:	22 23       	and	r18, r18
    3506:	09 f4       	brne	.+2      	; 0x350a <chprintf+0x2dc>
    3508:	78 c0       	rjmp	.+240    	; 0x35fa <chprintf+0x3cc>
 *          .
 *
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 */
void chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
    350a:	94 01       	movw	r18, r8
    350c:	2f 5f       	subi	r18, 0xFF	; 255
    350e:	3f 4f       	sbci	r19, 0xFF	; 255
    3510:	82 0f       	add	r24, r18
    3512:	93 1f       	adc	r25, r19
    3514:	03 c0       	rjmp	.+6      	; 0x351c <chprintf+0x2ee>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    3516:	28 17       	cp	r18, r24
    3518:	39 07       	cpc	r19, r25
    351a:	31 f0       	breq	.+12     	; 0x3528 <chprintf+0x2fa>
    351c:	f9 01       	movw	r30, r18
    351e:	2f 5f       	subi	r18, 0xFF	; 255
    3520:	3f 4f       	sbci	r19, 0xFF	; 255
    3522:	40 81       	ld	r20, Z
    3524:	41 11       	cpse	r20, r1
    3526:	f7 cf       	rjmp	.-18     	; 0x3516 <chprintf+0x2e8>
    3528:	3f 01       	movw	r6, r30
    352a:	68 18       	sub	r6, r8
    352c:	79 08       	sbc	r7, r9
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
    352e:	90 e2       	ldi	r25, 0x20	; 32
    3530:	59 2e       	mov	r5, r25
    3532:	2b cf       	rjmp	.-426    	; 0x338a <chprintf+0x15c>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    3534:	2f 36       	cpi	r18, 0x6F	; 111
    3536:	09 f0       	breq	.+2      	; 0x353a <chprintf+0x30c>
    3538:	24 cf       	rjmp	.-440    	; 0x3382 <chprintf+0x154>
    353a:	28 e0       	ldi	r18, 0x08	; 8
    353c:	30 e0       	ldi	r19, 0x00	; 0
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
unsigned_common:
      if (is_long)
    353e:	44 23       	and	r20, r20
    3540:	79 f0       	breq	.+30     	; 0x3560 <chprintf+0x332>
        l = va_arg(ap, long);
    3542:	84 e0       	ldi	r24, 0x04	; 4
    3544:	a8 0e       	add	r10, r24
    3546:	b1 1c       	adc	r11, r1
    3548:	40 81       	ld	r20, Z
    354a:	51 81       	ldd	r21, Z+1	; 0x01
    354c:	62 81       	ldd	r22, Z+2	; 0x02
    354e:	73 81       	ldd	r23, Z+3	; 0x03
  return p;
}

static char *ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
    3550:	c1 01       	movw	r24, r2
    3552:	0e 94 a3 18 	call	0x3146	; 0x3146 <long_to_string_with_divisor.constprop.0>
    3556:	3c 01       	movw	r6, r24
    3558:	62 18       	sub	r6, r2
    355a:	73 08       	sbc	r7, r3
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    355c:	41 01       	movw	r8, r2
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      p = ltoa(p, l, c);
      break;
    355e:	15 cf       	rjmp	.-470    	; 0x338a <chprintf+0x15c>
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
    3560:	92 e0       	ldi	r25, 0x02	; 2
    3562:	a9 0e       	add	r10, r25
    3564:	b1 1c       	adc	r11, r1
    3566:	40 81       	ld	r20, Z
    3568:	51 81       	ldd	r21, Z+1	; 0x01
    356a:	66 27       	eor	r22, r22
    356c:	57 fd       	sbrc	r21, 7
    356e:	60 95       	com	r22
    3570:	76 2f       	mov	r23, r22
    3572:	ee cf       	rjmp	.-36     	; 0x3550 <chprintf+0x322>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    3574:	25 37       	cpi	r18, 0x75	; 117
    3576:	41 f0       	breq	.+16     	; 0x3588 <chprintf+0x35a>
    3578:	28 37       	cpi	r18, 0x78	; 120
    357a:	09 f0       	breq	.+2      	; 0x357e <chprintf+0x350>
    357c:	02 cf       	rjmp	.-508    	; 0x3382 <chprintf+0x154>
    357e:	20 e1       	ldi	r18, 0x10	; 16
    3580:	30 e0       	ldi	r19, 0x00	; 0
    3582:	dd cf       	rjmp	.-70     	; 0x353e <chprintf+0x310>
    3584:	25 35       	cpi	r18, 0x55	; 85
    3586:	19 f4       	brne	.+6      	; 0x358e <chprintf+0x360>
    3588:	2a e0       	ldi	r18, 0x0A	; 10
    358a:	30 e0       	ldi	r19, 0x00	; 0
    358c:	d8 cf       	rjmp	.-80     	; 0x353e <chprintf+0x310>
    358e:	28 35       	cpi	r18, 0x58	; 88
    3590:	09 f0       	breq	.+2      	; 0x3594 <chprintf+0x366>
    3592:	f7 ce       	rjmp	.-530    	; 0x3382 <chprintf+0x154>
    3594:	20 e1       	ldi	r18, 0x10	; 16
    3596:	30 e0       	ldi	r19, 0x00	; 0
    3598:	d2 cf       	rjmp	.-92     	; 0x353e <chprintf+0x310>
        ;
      break;
    case 'D':
    case 'd':
      if (is_long)
        l = va_arg(ap, long);
    359a:	b4 e0       	ldi	r27, 0x04	; 4
    359c:	ab 0e       	add	r10, r27
    359e:	b1 1c       	adc	r11, r1
    35a0:	40 81       	ld	r20, Z
    35a2:	51 81       	ldd	r21, Z+1	; 0x01
    35a4:	62 81       	ldd	r22, Z+2	; 0x02
    35a6:	73 81       	ldd	r23, Z+3	; 0x03
      else
        l = va_arg(ap, int);
      if (l < 0) {
    35a8:	77 ff       	sbrs	r23, 7
    35aa:	45 cf       	rjmp	.-374    	; 0x3436 <chprintf+0x208>
        *p++ = '-';
    35ac:	8d e2       	ldi	r24, 0x2D	; 45
    35ae:	89 83       	std	Y+1, r24	; 0x01
        l = -l;
    35b0:	70 95       	com	r23
    35b2:	60 95       	com	r22
    35b4:	50 95       	com	r21
    35b6:	41 95       	neg	r20
    35b8:	5f 4f       	sbci	r21, 0xFF	; 255
    35ba:	6f 4f       	sbci	r22, 0xFF	; 255
    35bc:	7f 4f       	sbci	r23, 0xFF	; 255
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
    35be:	8d 85       	ldd	r24, Y+13	; 0x0d
    35c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    35c2:	3a cf       	rjmp	.-396    	; 0x3438 <chprintf+0x20a>
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
    35c4:	8f ef       	ldi	r24, 0xFF	; 255
    35c6:	9f e7       	ldi	r25, 0x7F	; 127
    35c8:	9b cf       	rjmp	.-202    	; 0x3500 <chprintf+0x2d2>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
    35ca:	b0 e3       	ldi	r27, 0x30	; 48
    35cc:	5b 12       	cpse	r5, r27
    35ce:	ec ce       	rjmp	.-552    	; 0x33a8 <chprintf+0x17a>
        chSequentialStreamPut(chp, (uint8_t)*s++);
    35d0:	ef ef       	ldi	r30, 0xFF	; 255
    35d2:	8e 1a       	sub	r8, r30
    35d4:	9e 0a       	sbc	r9, r30
    35d6:	d6 01       	movw	r26, r12
    35d8:	ed 91       	ld	r30, X+
    35da:	fc 91       	ld	r31, X
    35dc:	04 80       	ldd	r0, Z+4	; 0x04
    35de:	f5 81       	ldd	r31, Z+5	; 0x05
    35e0:	e0 2d       	mov	r30, r0
    35e2:	6d e2       	ldi	r22, 0x2D	; 45
    35e4:	c6 01       	movw	r24, r12
    35e6:	09 95       	icall
        i--;
    35e8:	b1 e0       	ldi	r27, 0x01	; 1
    35ea:	6b 1a       	sub	r6, r27
    35ec:	71 08       	sbc	r7, r1
    35ee:	dc ce       	rjmp	.-584    	; 0x33a8 <chprintf+0x17a>
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
    35f0:	28 e8       	ldi	r18, 0x88	; 136
    35f2:	82 2e       	mov	r8, r18
    35f4:	21 e0       	ldi	r18, 0x01	; 1
    35f6:	92 2e       	mov	r9, r18
    35f8:	80 cf       	rjmp	.-256    	; 0x34fa <chprintf+0x2cc>
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    35fa:	61 2c       	mov	r6, r1
    35fc:	71 2c       	mov	r7, r1
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
    35fe:	80 e2       	ldi	r24, 0x20	; 32
    3600:	58 2e       	mov	r5, r24
    3602:	c3 ce       	rjmp	.-634    	; 0x338a <chprintf+0x15c>

00003604 <main>:
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */


  halInit();
    3604:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <halInit>
  chSysInit();
    3608:	0e 94 ce 00 	call	0x19c	; 0x19c <chSysInit>
  

  sdStart(&SD1, NULL);
    360c:	60 e0       	ldi	r22, 0x00	; 0
    360e:	70 e0       	ldi	r23, 0x00	; 0
    3610:	8c e3       	ldi	r24, 0x3C	; 60
    3612:	92 e0       	ldi	r25, 0x02	; 2
    3614:	0e 94 21 10 	call	0x2042	; 0x2042 <sdStart>
  uint8_t a = 0;
    3618:	f1 2c       	mov	r15, r1
  while(1){
      a++;
      chprintf(&SD1,"a: %4.4x\n",a);
    361a:	0f e8       	ldi	r16, 0x8F	; 143
    361c:	11 e0       	ldi	r17, 0x01	; 1
    361e:	cc e3       	ldi	r28, 0x3C	; 60
    3620:	d2 e0       	ldi	r29, 0x02	; 2
  

  sdStart(&SD1, NULL);
  uint8_t a = 0;
  while(1){
      a++;
    3622:	f3 94       	inc	r15
      chprintf(&SD1,"a: %4.4x\n",a);
    3624:	1f 92       	push	r1
    3626:	ff 92       	push	r15
    3628:	1f 93       	push	r17
    362a:	0f 93       	push	r16
    362c:	df 93       	push	r29
    362e:	cf 93       	push	r28
    3630:	0e 94 17 19 	call	0x322e	; 0x322e <chprintf>
      
      chThdSleepMilliseconds(20);
    3634:	8c e0       	ldi	r24, 0x0C	; 12
    3636:	90 e0       	ldi	r25, 0x00	; 0
    3638:	0e 94 62 04 	call	0x8c4	; 0x8c4 <chThdSleep>
    363c:	0f 90       	pop	r0
    363e:	0f 90       	pop	r0
    3640:	0f 90       	pop	r0
    3642:	0f 90       	pop	r0
    3644:	0f 90       	pop	r0
    3646:	0f 90       	pop	r0
    3648:	ec cf       	rjmp	.-40     	; 0x3622 <main+0x1e>

0000364a <vfprintf>:
    364a:	ac e0       	ldi	r26, 0x0C	; 12
    364c:	b0 e0       	ldi	r27, 0x00	; 0
    364e:	eb e2       	ldi	r30, 0x2B	; 43
    3650:	fb e1       	ldi	r31, 0x1B	; 27
    3652:	0c 94 a0 1e 	jmp	0x3d40	; 0x3d40 <__prologue_saves__+0x8>
    3656:	6c 01       	movw	r12, r24
    3658:	3b 01       	movw	r6, r22
    365a:	8a 01       	movw	r16, r20
    365c:	fc 01       	movw	r30, r24
    365e:	17 82       	std	Z+7, r1	; 0x07
    3660:	16 82       	std	Z+6, r1	; 0x06
    3662:	83 81       	ldd	r24, Z+3	; 0x03
    3664:	81 fd       	sbrc	r24, 1
    3666:	03 c0       	rjmp	.+6      	; 0x366e <vfprintf+0x24>
    3668:	1f c1       	rjmp	.+574    	; 0x38a8 <vfprintf+0x25e>
    366a:	85 01       	movw	r16, r10
    366c:	04 c0       	rjmp	.+8      	; 0x3676 <vfprintf+0x2c>
    366e:	4e 01       	movw	r8, r28
    3670:	08 94       	sec
    3672:	81 1c       	adc	r8, r1
    3674:	91 1c       	adc	r9, r1
    3676:	f6 01       	movw	r30, r12
    3678:	e3 80       	ldd	r14, Z+3	; 0x03
    367a:	f3 01       	movw	r30, r6
    367c:	e3 fc       	sbrc	r14, 3
    367e:	85 91       	lpm	r24, Z+
    3680:	e3 fe       	sbrs	r14, 3
    3682:	81 91       	ld	r24, Z+
    3684:	3f 01       	movw	r6, r30
    3686:	88 23       	and	r24, r24
    3688:	09 f4       	brne	.+2      	; 0x368c <vfprintf+0x42>
    368a:	0a c1       	rjmp	.+532    	; 0x38a0 <vfprintf+0x256>
    368c:	85 32       	cpi	r24, 0x25	; 37
    368e:	39 f4       	brne	.+14     	; 0x369e <vfprintf+0x54>
    3690:	e3 fc       	sbrc	r14, 3
    3692:	25 91       	lpm	r18, Z+
    3694:	e3 fe       	sbrs	r14, 3
    3696:	21 91       	ld	r18, Z+
    3698:	3f 01       	movw	r6, r30
    369a:	25 32       	cpi	r18, 0x25	; 37
    369c:	19 f5       	brne	.+70     	; 0x36e4 <vfprintf+0x9a>
    369e:	90 e0       	ldi	r25, 0x00	; 0
    36a0:	b6 01       	movw	r22, r12
    36a2:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <fputc>
    36a6:	58 01       	movw	r10, r16
    36a8:	e0 cf       	rjmp	.-64     	; 0x366a <vfprintf+0x20>
    36aa:	22 23       	and	r18, r18
    36ac:	09 f4       	brne	.+2      	; 0x36b0 <vfprintf+0x66>
    36ae:	f8 c0       	rjmp	.+496    	; 0x38a0 <vfprintf+0x256>
    36b0:	88 e6       	ldi	r24, 0x68	; 104
    36b2:	90 e0       	ldi	r25, 0x00	; 0
    36b4:	62 2f       	mov	r22, r18
    36b6:	70 e0       	ldi	r23, 0x00	; 0
    36b8:	2c 87       	std	Y+12, r18	; 0x0c
    36ba:	0e 94 e6 1e 	call	0x3dcc	; 0x3dcc <strchr_P>
    36be:	2c 85       	ldd	r18, Y+12	; 0x0c
    36c0:	00 97       	sbiw	r24, 0x00	; 0
    36c2:	49 f4       	brne	.+18     	; 0x36d6 <vfprintf+0x8c>
    36c4:	23 32       	cpi	r18, 0x23	; 35
    36c6:	19 f4       	brne	.+6      	; 0x36ce <vfprintf+0x84>
    36c8:	f0 e1       	ldi	r31, 0x10	; 16
    36ca:	ff 2a       	or	r15, r31
    36cc:	04 c0       	rjmp	.+8      	; 0x36d6 <vfprintf+0x8c>
    36ce:	2c 36       	cpi	r18, 0x6C	; 108
    36d0:	79 f4       	brne	.+30     	; 0x36f0 <vfprintf+0xa6>
    36d2:	20 e8       	ldi	r18, 0x80	; 128
    36d4:	f2 2a       	or	r15, r18
    36d6:	f3 01       	movw	r30, r6
    36d8:	e3 fc       	sbrc	r14, 3
    36da:	25 91       	lpm	r18, Z+
    36dc:	e3 fe       	sbrs	r14, 3
    36de:	21 91       	ld	r18, Z+
    36e0:	3f 01       	movw	r6, r30
    36e2:	01 c0       	rjmp	.+2      	; 0x36e6 <vfprintf+0x9c>
    36e4:	ff 24       	eor	r15, r15
    36e6:	f7 fe       	sbrs	r15, 7
    36e8:	e0 cf       	rjmp	.-64     	; 0x36aa <vfprintf+0x60>
    36ea:	22 23       	and	r18, r18
    36ec:	09 f4       	brne	.+2      	; 0x36f0 <vfprintf+0xa6>
    36ee:	d8 c0       	rjmp	.+432    	; 0x38a0 <vfprintf+0x256>
    36f0:	88 e7       	ldi	r24, 0x78	; 120
    36f2:	90 e0       	ldi	r25, 0x00	; 0
    36f4:	62 2f       	mov	r22, r18
    36f6:	70 e0       	ldi	r23, 0x00	; 0
    36f8:	2c 87       	std	Y+12, r18	; 0x0c
    36fa:	0e 94 e6 1e 	call	0x3dcc	; 0x3dcc <strchr_P>
    36fe:	2c 85       	ldd	r18, Y+12	; 0x0c
    3700:	00 97       	sbiw	r24, 0x00	; 0
    3702:	41 f0       	breq	.+16     	; 0x3714 <vfprintf+0xca>
    3704:	64 e0       	ldi	r22, 0x04	; 4
    3706:	a6 2e       	mov	r10, r22
    3708:	b1 2c       	mov	r11, r1
    370a:	a0 0e       	add	r10, r16
    370c:	b1 1e       	adc	r11, r17
    370e:	8f e3       	ldi	r24, 0x3F	; 63
    3710:	90 e0       	ldi	r25, 0x00	; 0
    3712:	0f c0       	rjmp	.+30     	; 0x3732 <vfprintf+0xe8>
    3714:	23 36       	cpi	r18, 0x63	; 99
    3716:	29 f0       	breq	.+10     	; 0x3722 <vfprintf+0xd8>
    3718:	23 37       	cpi	r18, 0x73	; 115
    371a:	89 f0       	breq	.+34     	; 0x373e <vfprintf+0xf4>
    371c:	23 35       	cpi	r18, 0x53	; 83
    371e:	29 f5       	brne	.+74     	; 0x376a <vfprintf+0x120>
    3720:	0c c0       	rjmp	.+24     	; 0x373a <vfprintf+0xf0>
    3722:	52 e0       	ldi	r21, 0x02	; 2
    3724:	a5 2e       	mov	r10, r21
    3726:	b1 2c       	mov	r11, r1
    3728:	a0 0e       	add	r10, r16
    372a:	b1 1e       	adc	r11, r17
    372c:	f8 01       	movw	r30, r16
    372e:	80 81       	ld	r24, Z
    3730:	91 81       	ldd	r25, Z+1	; 0x01
    3732:	b6 01       	movw	r22, r12
    3734:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <fputc>
    3738:	98 cf       	rjmp	.-208    	; 0x366a <vfprintf+0x20>
    373a:	f1 e0       	ldi	r31, 0x01	; 1
    373c:	ff 2a       	or	r15, r31
    373e:	42 e0       	ldi	r20, 0x02	; 2
    3740:	a4 2e       	mov	r10, r20
    3742:	b1 2c       	mov	r11, r1
    3744:	a0 0e       	add	r10, r16
    3746:	b1 1e       	adc	r11, r17
    3748:	f8 01       	movw	r30, r16
    374a:	00 81       	ld	r16, Z
    374c:	11 81       	ldd	r17, Z+1	; 0x01
    374e:	04 c0       	rjmp	.+8      	; 0x3758 <vfprintf+0x10e>
    3750:	90 e0       	ldi	r25, 0x00	; 0
    3752:	b6 01       	movw	r22, r12
    3754:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <fputc>
    3758:	f8 01       	movw	r30, r16
    375a:	f0 fc       	sbrc	r15, 0
    375c:	85 91       	lpm	r24, Z+
    375e:	f0 fe       	sbrs	r15, 0
    3760:	81 91       	ld	r24, Z+
    3762:	8f 01       	movw	r16, r30
    3764:	88 23       	and	r24, r24
    3766:	a1 f7       	brne	.-24     	; 0x3750 <vfprintf+0x106>
    3768:	80 cf       	rjmp	.-256    	; 0x366a <vfprintf+0x20>
    376a:	24 36       	cpi	r18, 0x64	; 100
    376c:	11 f0       	breq	.+4      	; 0x3772 <vfprintf+0x128>
    376e:	29 36       	cpi	r18, 0x69	; 105
    3770:	61 f5       	brne	.+88     	; 0x37ca <vfprintf+0x180>
    3772:	f7 fe       	sbrs	r15, 7
    3774:	0b c0       	rjmp	.+22     	; 0x378c <vfprintf+0x142>
    3776:	34 e0       	ldi	r19, 0x04	; 4
    3778:	a3 2e       	mov	r10, r19
    377a:	b1 2c       	mov	r11, r1
    377c:	a0 0e       	add	r10, r16
    377e:	b1 1e       	adc	r11, r17
    3780:	f8 01       	movw	r30, r16
    3782:	80 81       	ld	r24, Z
    3784:	91 81       	ldd	r25, Z+1	; 0x01
    3786:	a2 81       	ldd	r26, Z+2	; 0x02
    3788:	b3 81       	ldd	r27, Z+3	; 0x03
    378a:	0c c0       	rjmp	.+24     	; 0x37a4 <vfprintf+0x15a>
    378c:	22 e0       	ldi	r18, 0x02	; 2
    378e:	a2 2e       	mov	r10, r18
    3790:	b1 2c       	mov	r11, r1
    3792:	a0 0e       	add	r10, r16
    3794:	b1 1e       	adc	r11, r17
    3796:	f8 01       	movw	r30, r16
    3798:	80 81       	ld	r24, Z
    379a:	91 81       	ldd	r25, Z+1	; 0x01
    379c:	aa 27       	eor	r26, r26
    379e:	97 fd       	sbrc	r25, 7
    37a0:	a0 95       	com	r26
    37a2:	ba 2f       	mov	r27, r26
    37a4:	ff ee       	ldi	r31, 0xEF	; 239
    37a6:	ff 22       	and	r15, r31
    37a8:	b7 ff       	sbrs	r27, 7
    37aa:	09 c0       	rjmp	.+18     	; 0x37be <vfprintf+0x174>
    37ac:	b0 95       	com	r27
    37ae:	a0 95       	com	r26
    37b0:	90 95       	com	r25
    37b2:	81 95       	neg	r24
    37b4:	9f 4f       	sbci	r25, 0xFF	; 255
    37b6:	af 4f       	sbci	r26, 0xFF	; 255
    37b8:	bf 4f       	sbci	r27, 0xFF	; 255
    37ba:	20 e4       	ldi	r18, 0x40	; 64
    37bc:	f2 2a       	or	r15, r18
    37be:	bc 01       	movw	r22, r24
    37c0:	cd 01       	movw	r24, r26
    37c2:	a4 01       	movw	r20, r8
    37c4:	2a e0       	ldi	r18, 0x0A	; 10
    37c6:	30 e0       	ldi	r19, 0x00	; 0
    37c8:	3b c0       	rjmp	.+118    	; 0x3840 <vfprintf+0x1f6>
    37ca:	20 37       	cpi	r18, 0x70	; 112
    37cc:	99 f0       	breq	.+38     	; 0x37f4 <vfprintf+0x1aa>
    37ce:	21 37       	cpi	r18, 0x71	; 113
    37d0:	30 f4       	brcc	.+12     	; 0x37de <vfprintf+0x194>
    37d2:	28 35       	cpi	r18, 0x58	; 88
    37d4:	b1 f0       	breq	.+44     	; 0x3802 <vfprintf+0x1b8>
    37d6:	2f 36       	cpi	r18, 0x6F	; 111
    37d8:	09 f0       	breq	.+2      	; 0x37dc <vfprintf+0x192>
    37da:	62 c0       	rjmp	.+196    	; 0x38a0 <vfprintf+0x256>
    37dc:	17 c0       	rjmp	.+46     	; 0x380c <vfprintf+0x1c2>
    37de:	25 37       	cpi	r18, 0x75	; 117
    37e0:	21 f0       	breq	.+8      	; 0x37ea <vfprintf+0x1a0>
    37e2:	28 37       	cpi	r18, 0x78	; 120
    37e4:	09 f0       	breq	.+2      	; 0x37e8 <vfprintf+0x19e>
    37e6:	5c c0       	rjmp	.+184    	; 0x38a0 <vfprintf+0x256>
    37e8:	07 c0       	rjmp	.+14     	; 0x37f8 <vfprintf+0x1ae>
    37ea:	8f ee       	ldi	r24, 0xEF	; 239
    37ec:	f8 22       	and	r15, r24
    37ee:	2a e0       	ldi	r18, 0x0A	; 10
    37f0:	30 e0       	ldi	r19, 0x00	; 0
    37f2:	0e c0       	rjmp	.+28     	; 0x3810 <vfprintf+0x1c6>
    37f4:	e0 e1       	ldi	r30, 0x10	; 16
    37f6:	fe 2a       	or	r15, r30
    37f8:	f4 e2       	ldi	r31, 0x24	; 36
    37fa:	ff 2a       	or	r15, r31
    37fc:	20 e1       	ldi	r18, 0x10	; 16
    37fe:	30 e0       	ldi	r19, 0x00	; 0
    3800:	07 c0       	rjmp	.+14     	; 0x3810 <vfprintf+0x1c6>
    3802:	24 e0       	ldi	r18, 0x04	; 4
    3804:	f2 2a       	or	r15, r18
    3806:	20 e1       	ldi	r18, 0x10	; 16
    3808:	32 e0       	ldi	r19, 0x02	; 2
    380a:	02 c0       	rjmp	.+4      	; 0x3810 <vfprintf+0x1c6>
    380c:	28 e0       	ldi	r18, 0x08	; 8
    380e:	30 e0       	ldi	r19, 0x00	; 0
    3810:	f7 fe       	sbrs	r15, 7
    3812:	0b c0       	rjmp	.+22     	; 0x382a <vfprintf+0x1e0>
    3814:	94 e0       	ldi	r25, 0x04	; 4
    3816:	a9 2e       	mov	r10, r25
    3818:	b1 2c       	mov	r11, r1
    381a:	a0 0e       	add	r10, r16
    381c:	b1 1e       	adc	r11, r17
    381e:	f8 01       	movw	r30, r16
    3820:	60 81       	ld	r22, Z
    3822:	71 81       	ldd	r23, Z+1	; 0x01
    3824:	82 81       	ldd	r24, Z+2	; 0x02
    3826:	93 81       	ldd	r25, Z+3	; 0x03
    3828:	0a c0       	rjmp	.+20     	; 0x383e <vfprintf+0x1f4>
    382a:	82 e0       	ldi	r24, 0x02	; 2
    382c:	a8 2e       	mov	r10, r24
    382e:	b1 2c       	mov	r11, r1
    3830:	a0 0e       	add	r10, r16
    3832:	b1 1e       	adc	r11, r17
    3834:	f8 01       	movw	r30, r16
    3836:	60 81       	ld	r22, Z
    3838:	71 81       	ldd	r23, Z+1	; 0x01
    383a:	80 e0       	ldi	r24, 0x00	; 0
    383c:	90 e0       	ldi	r25, 0x00	; 0
    383e:	a4 01       	movw	r20, r8
    3840:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <__ultoa_invert>
    3844:	08 2f       	mov	r16, r24
    3846:	08 19       	sub	r16, r8
    3848:	ef 2c       	mov	r14, r15
    384a:	ff 24       	eor	r15, r15
    384c:	e6 fe       	sbrs	r14, 6
    384e:	05 c0       	rjmp	.+10     	; 0x385a <vfprintf+0x210>
    3850:	8d e2       	ldi	r24, 0x2D	; 45
    3852:	90 e0       	ldi	r25, 0x00	; 0
    3854:	b6 01       	movw	r22, r12
    3856:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <fputc>
    385a:	e4 fe       	sbrs	r14, 4
    385c:	15 c0       	rjmp	.+42     	; 0x3888 <vfprintf+0x23e>
    385e:	fe 01       	movw	r30, r28
    3860:	e0 0f       	add	r30, r16
    3862:	f1 1d       	adc	r31, r1
    3864:	80 81       	ld	r24, Z
    3866:	80 33       	cpi	r24, 0x30	; 48
    3868:	79 f0       	breq	.+30     	; 0x3888 <vfprintf+0x23e>
    386a:	80 e3       	ldi	r24, 0x30	; 48
    386c:	90 e0       	ldi	r25, 0x00	; 0
    386e:	b6 01       	movw	r22, r12
    3870:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <fputc>
    3874:	e2 fe       	sbrs	r14, 2
    3876:	08 c0       	rjmp	.+16     	; 0x3888 <vfprintf+0x23e>
    3878:	c7 01       	movw	r24, r14
    387a:	80 72       	andi	r24, 0x20	; 32
    387c:	90 70       	andi	r25, 0x00	; 0
    387e:	88 5a       	subi	r24, 0xA8	; 168
    3880:	9f 4f       	sbci	r25, 0xFF	; 255
    3882:	b6 01       	movw	r22, r12
    3884:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <fputc>
    3888:	01 50       	subi	r16, 0x01	; 1
    388a:	f4 01       	movw	r30, r8
    388c:	e0 0f       	add	r30, r16
    388e:	f1 1d       	adc	r31, r1
    3890:	80 81       	ld	r24, Z
    3892:	90 e0       	ldi	r25, 0x00	; 0
    3894:	b6 01       	movw	r22, r12
    3896:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <fputc>
    389a:	00 23       	and	r16, r16
    389c:	a9 f7       	brne	.-22     	; 0x3888 <vfprintf+0x23e>
    389e:	e5 ce       	rjmp	.-566    	; 0x366a <vfprintf+0x20>
    38a0:	f6 01       	movw	r30, r12
    38a2:	86 81       	ldd	r24, Z+6	; 0x06
    38a4:	97 81       	ldd	r25, Z+7	; 0x07
    38a6:	02 c0       	rjmp	.+4      	; 0x38ac <vfprintf+0x262>
    38a8:	8f ef       	ldi	r24, 0xFF	; 255
    38aa:	9f ef       	ldi	r25, 0xFF	; 255
    38ac:	2c 96       	adiw	r28, 0x0c	; 12
    38ae:	ee e0       	ldi	r30, 0x0E	; 14
    38b0:	0c 94 bc 1e 	jmp	0x3d78	; 0x3d78 <__epilogue_restores__+0x8>

000038b4 <putval>:
    38b4:	20 fd       	sbrc	r18, 0
    38b6:	09 c0       	rjmp	.+18     	; 0x38ca <putval+0x16>
    38b8:	fc 01       	movw	r30, r24
    38ba:	23 fd       	sbrc	r18, 3
    38bc:	05 c0       	rjmp	.+10     	; 0x38c8 <putval+0x14>
    38be:	22 ff       	sbrs	r18, 2
    38c0:	02 c0       	rjmp	.+4      	; 0x38c6 <putval+0x12>
    38c2:	73 83       	std	Z+3, r23	; 0x03
    38c4:	62 83       	std	Z+2, r22	; 0x02
    38c6:	51 83       	std	Z+1, r21	; 0x01
    38c8:	40 83       	st	Z, r20
    38ca:	08 95       	ret

000038cc <mulacc>:
    38cc:	cf 92       	push	r12
    38ce:	df 92       	push	r13
    38d0:	ef 92       	push	r14
    38d2:	ff 92       	push	r15
    38d4:	6b 01       	movw	r12, r22
    38d6:	7c 01       	movw	r14, r24
    38d8:	44 fd       	sbrc	r20, 4
    38da:	10 c0       	rjmp	.+32     	; 0x38fc <mulacc+0x30>
    38dc:	46 fd       	sbrc	r20, 6
    38de:	10 c0       	rjmp	.+32     	; 0x3900 <mulacc+0x34>
    38e0:	d6 01       	movw	r26, r12
    38e2:	f7 01       	movw	r30, r14
    38e4:	aa 0f       	add	r26, r26
    38e6:	bb 1f       	adc	r27, r27
    38e8:	ee 1f       	adc	r30, r30
    38ea:	ff 1f       	adc	r31, r31
    38ec:	10 94       	com	r1
    38ee:	d1 f7       	brne	.-12     	; 0x38e4 <mulacc+0x18>
    38f0:	ca 0e       	add	r12, r26
    38f2:	db 1e       	adc	r13, r27
    38f4:	ee 1e       	adc	r14, r30
    38f6:	ff 1e       	adc	r15, r31
    38f8:	81 e0       	ldi	r24, 0x01	; 1
    38fa:	03 c0       	rjmp	.+6      	; 0x3902 <mulacc+0x36>
    38fc:	83 e0       	ldi	r24, 0x03	; 3
    38fe:	01 c0       	rjmp	.+2      	; 0x3902 <mulacc+0x36>
    3900:	84 e0       	ldi	r24, 0x04	; 4
    3902:	cc 0c       	add	r12, r12
    3904:	dd 1c       	adc	r13, r13
    3906:	ee 1c       	adc	r14, r14
    3908:	ff 1c       	adc	r15, r15
    390a:	81 50       	subi	r24, 0x01	; 1
    390c:	d1 f7       	brne	.-12     	; 0x3902 <mulacc+0x36>
    390e:	c2 0e       	add	r12, r18
    3910:	d1 1c       	adc	r13, r1
    3912:	e1 1c       	adc	r14, r1
    3914:	f1 1c       	adc	r15, r1
    3916:	b6 01       	movw	r22, r12
    3918:	c7 01       	movw	r24, r14
    391a:	ff 90       	pop	r15
    391c:	ef 90       	pop	r14
    391e:	df 90       	pop	r13
    3920:	cf 90       	pop	r12
    3922:	08 95       	ret

00003924 <skip_spaces>:
    3924:	0f 93       	push	r16
    3926:	1f 93       	push	r17
    3928:	cf 93       	push	r28
    392a:	df 93       	push	r29
    392c:	8c 01       	movw	r16, r24
    392e:	c8 01       	movw	r24, r16
    3930:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <fgetc>
    3934:	ec 01       	movw	r28, r24
    3936:	97 fd       	sbrc	r25, 7
    3938:	08 c0       	rjmp	.+16     	; 0x394a <skip_spaces+0x26>
    393a:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <isspace>
    393e:	00 97       	sbiw	r24, 0x00	; 0
    3940:	b1 f7       	brne	.-20     	; 0x392e <skip_spaces+0xa>
    3942:	ce 01       	movw	r24, r28
    3944:	b8 01       	movw	r22, r16
    3946:	0e 94 5d 1f 	call	0x3eba	; 0x3eba <ungetc>
    394a:	ce 01       	movw	r24, r28
    394c:	df 91       	pop	r29
    394e:	cf 91       	pop	r28
    3950:	1f 91       	pop	r17
    3952:	0f 91       	pop	r16
    3954:	08 95       	ret

00003956 <conv_int>:
    3956:	a0 e0       	ldi	r26, 0x00	; 0
    3958:	b0 e0       	ldi	r27, 0x00	; 0
    395a:	e1 eb       	ldi	r30, 0xB1	; 177
    395c:	fc e1       	ldi	r31, 0x1C	; 28
    395e:	0c 94 a4 1e 	jmp	0x3d48	; 0x3d48 <__prologue_saves__+0x10>
    3962:	8c 01       	movw	r16, r24
    3964:	d6 2f       	mov	r29, r22
    3966:	5a 01       	movw	r10, r20
    3968:	c2 2f       	mov	r28, r18
    396a:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <fgetc>
    396e:	8b 32       	cpi	r24, 0x2B	; 43
    3970:	19 f0       	breq	.+6      	; 0x3978 <conv_int+0x22>
    3972:	8d 32       	cpi	r24, 0x2D	; 45
    3974:	49 f4       	brne	.+18     	; 0x3988 <conv_int+0x32>
    3976:	c0 68       	ori	r28, 0x80	; 128
    3978:	d1 50       	subi	r29, 0x01	; 1
    397a:	09 f4       	brne	.+2      	; 0x397e <conv_int+0x28>
    397c:	61 c0       	rjmp	.+194    	; 0x3a40 <conv_int+0xea>
    397e:	c8 01       	movw	r24, r16
    3980:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <fgetc>
    3984:	97 fd       	sbrc	r25, 7
    3986:	5c c0       	rjmp	.+184    	; 0x3a40 <conv_int+0xea>
    3988:	cd 7f       	andi	r28, 0xFD	; 253
    398a:	2c 2f       	mov	r18, r28
    398c:	20 73       	andi	r18, 0x30	; 48
    398e:	d1 f4       	brne	.+52     	; 0x39c4 <conv_int+0x6e>
    3990:	80 33       	cpi	r24, 0x30	; 48
    3992:	c1 f4       	brne	.+48     	; 0x39c4 <conv_int+0x6e>
    3994:	d1 50       	subi	r29, 0x01	; 1
    3996:	09 f4       	brne	.+2      	; 0x399a <conv_int+0x44>
    3998:	3e c0       	rjmp	.+124    	; 0x3a16 <conv_int+0xc0>
    399a:	c8 01       	movw	r24, r16
    399c:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <fgetc>
    39a0:	97 fd       	sbrc	r25, 7
    39a2:	39 c0       	rjmp	.+114    	; 0x3a16 <conv_int+0xc0>
    39a4:	c2 60       	ori	r28, 0x02	; 2
    39a6:	88 37       	cpi	r24, 0x78	; 120
    39a8:	11 f0       	breq	.+4      	; 0x39ae <conv_int+0x58>
    39aa:	88 35       	cpi	r24, 0x58	; 88
    39ac:	49 f4       	brne	.+18     	; 0x39c0 <conv_int+0x6a>
    39ae:	c0 64       	ori	r28, 0x40	; 64
    39b0:	d1 50       	subi	r29, 0x01	; 1
    39b2:	89 f1       	breq	.+98     	; 0x3a16 <conv_int+0xc0>
    39b4:	c8 01       	movw	r24, r16
    39b6:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <fgetc>
    39ba:	97 ff       	sbrs	r25, 7
    39bc:	03 c0       	rjmp	.+6      	; 0x39c4 <conv_int+0x6e>
    39be:	2b c0       	rjmp	.+86     	; 0x3a16 <conv_int+0xc0>
    39c0:	c6 ff       	sbrs	r28, 6
    39c2:	c0 61       	ori	r28, 0x10	; 16
    39c4:	cc 24       	eor	r12, r12
    39c6:	dd 24       	eor	r13, r13
    39c8:	76 01       	movw	r14, r12
    39ca:	28 2f       	mov	r18, r24
    39cc:	20 53       	subi	r18, 0x30	; 48
    39ce:	28 30       	cpi	r18, 0x08	; 8
    39d0:	80 f0       	brcs	.+32     	; 0x39f2 <conv_int+0x9c>
    39d2:	c4 fd       	sbrc	r28, 4
    39d4:	09 c0       	rjmp	.+18     	; 0x39e8 <conv_int+0x92>
    39d6:	2a 30       	cpi	r18, 0x0A	; 10
    39d8:	60 f0       	brcs	.+24     	; 0x39f2 <conv_int+0x9c>
    39da:	c6 ff       	sbrs	r28, 6
    39dc:	05 c0       	rjmp	.+10     	; 0x39e8 <conv_int+0x92>
    39de:	2f 7d       	andi	r18, 0xDF	; 223
    39e0:	32 2f       	mov	r19, r18
    39e2:	31 51       	subi	r19, 0x11	; 17
    39e4:	36 30       	cpi	r19, 0x06	; 6
    39e6:	20 f0       	brcs	.+8      	; 0x39f0 <conv_int+0x9a>
    39e8:	b8 01       	movw	r22, r16
    39ea:	0e 94 5d 1f 	call	0x3eba	; 0x3eba <ungetc>
    39ee:	10 c0       	rjmp	.+32     	; 0x3a10 <conv_int+0xba>
    39f0:	27 50       	subi	r18, 0x07	; 7
    39f2:	c7 01       	movw	r24, r14
    39f4:	b6 01       	movw	r22, r12
    39f6:	4c 2f       	mov	r20, r28
    39f8:	0e 94 66 1c 	call	0x38cc	; 0x38cc <mulacc>
    39fc:	6b 01       	movw	r12, r22
    39fe:	7c 01       	movw	r14, r24
    3a00:	c2 60       	ori	r28, 0x02	; 2
    3a02:	d1 50       	subi	r29, 0x01	; 1
    3a04:	59 f0       	breq	.+22     	; 0x3a1c <conv_int+0xc6>
    3a06:	c8 01       	movw	r24, r16
    3a08:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <fgetc>
    3a0c:	97 ff       	sbrs	r25, 7
    3a0e:	dd cf       	rjmp	.-70     	; 0x39ca <conv_int+0x74>
    3a10:	c1 fd       	sbrc	r28, 1
    3a12:	04 c0       	rjmp	.+8      	; 0x3a1c <conv_int+0xc6>
    3a14:	15 c0       	rjmp	.+42     	; 0x3a40 <conv_int+0xea>
    3a16:	cc 24       	eor	r12, r12
    3a18:	dd 24       	eor	r13, r13
    3a1a:	76 01       	movw	r14, r12
    3a1c:	c7 ff       	sbrs	r28, 7
    3a1e:	08 c0       	rjmp	.+16     	; 0x3a30 <conv_int+0xda>
    3a20:	f0 94       	com	r15
    3a22:	e0 94       	com	r14
    3a24:	d0 94       	com	r13
    3a26:	c0 94       	com	r12
    3a28:	c1 1c       	adc	r12, r1
    3a2a:	d1 1c       	adc	r13, r1
    3a2c:	e1 1c       	adc	r14, r1
    3a2e:	f1 1c       	adc	r15, r1
    3a30:	c5 01       	movw	r24, r10
    3a32:	b7 01       	movw	r22, r14
    3a34:	a6 01       	movw	r20, r12
    3a36:	2c 2f       	mov	r18, r28
    3a38:	0e 94 5a 1c 	call	0x38b4	; 0x38b4 <putval>
    3a3c:	81 e0       	ldi	r24, 0x01	; 1
    3a3e:	01 c0       	rjmp	.+2      	; 0x3a42 <conv_int+0xec>
    3a40:	80 e0       	ldi	r24, 0x00	; 0
    3a42:	cd b7       	in	r28, 0x3d	; 61
    3a44:	de b7       	in	r29, 0x3e	; 62
    3a46:	ea e0       	ldi	r30, 0x0A	; 10
    3a48:	0c 94 c0 1e 	jmp	0x3d80	; 0x3d80 <__epilogue_restores__+0x10>

00003a4c <vfscanf>:
    3a4c:	a1 e0       	ldi	r26, 0x01	; 1
    3a4e:	b0 e0       	ldi	r27, 0x00	; 0
    3a50:	ec e2       	ldi	r30, 0x2C	; 44
    3a52:	fd e1       	ldi	r31, 0x1D	; 29
    3a54:	0c 94 9f 1e 	jmp	0x3d3e	; 0x3d3e <__prologue_saves__+0x6>
    3a58:	7c 01       	movw	r14, r24
    3a5a:	4b 01       	movw	r8, r22
    3a5c:	3a 01       	movw	r6, r20
    3a5e:	fc 01       	movw	r30, r24
    3a60:	17 82       	std	Z+7, r1	; 0x07
    3a62:	16 82       	std	Z+6, r1	; 0x06
    3a64:	bb 24       	eor	r11, r11
    3a66:	e3 c0       	rjmp	.+454    	; 0x3c2e <vfscanf+0x1e2>
    3a68:	81 2f       	mov	r24, r17
    3a6a:	90 e0       	ldi	r25, 0x00	; 0
    3a6c:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <isspace>
    3a70:	00 97       	sbiw	r24, 0x00	; 0
    3a72:	21 f0       	breq	.+8      	; 0x3a7c <vfscanf+0x30>
    3a74:	c7 01       	movw	r24, r14
    3a76:	0e 94 92 1c 	call	0x3924	; 0x3924 <skip_spaces>
    3a7a:	d9 c0       	rjmp	.+434    	; 0x3c2e <vfscanf+0x1e2>
    3a7c:	15 32       	cpi	r17, 0x25	; 37
    3a7e:	41 f4       	brne	.+16     	; 0x3a90 <vfscanf+0x44>
    3a80:	f4 01       	movw	r30, r8
    3a82:	03 fd       	sbrc	r16, 3
    3a84:	35 91       	lpm	r19, Z+
    3a86:	03 ff       	sbrs	r16, 3
    3a88:	31 91       	ld	r19, Z+
    3a8a:	4f 01       	movw	r8, r30
    3a8c:	35 32       	cpi	r19, 0x25	; 37
    3a8e:	61 f4       	brne	.+24     	; 0x3aa8 <vfscanf+0x5c>
    3a90:	c7 01       	movw	r24, r14
    3a92:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <fgetc>
    3a96:	97 fd       	sbrc	r25, 7
    3a98:	d6 c0       	rjmp	.+428    	; 0x3c46 <vfscanf+0x1fa>
    3a9a:	18 17       	cp	r17, r24
    3a9c:	09 f4       	brne	.+2      	; 0x3aa0 <vfscanf+0x54>
    3a9e:	c7 c0       	rjmp	.+398    	; 0x3c2e <vfscanf+0x1e2>
    3aa0:	b7 01       	movw	r22, r14
    3aa2:	0e 94 5d 1f 	call	0x3eba	; 0x3eba <ungetc>
    3aa6:	d1 c0       	rjmp	.+418    	; 0x3c4a <vfscanf+0x1fe>
    3aa8:	3a 32       	cpi	r19, 0x2A	; 42
    3aaa:	41 f4       	brne	.+16     	; 0x3abc <vfscanf+0x70>
    3aac:	03 fd       	sbrc	r16, 3
    3aae:	35 91       	lpm	r19, Z+
    3ab0:	03 ff       	sbrs	r16, 3
    3ab2:	31 91       	ld	r19, Z+
    3ab4:	4f 01       	movw	r8, r30
    3ab6:	aa 24       	eor	r10, r10
    3ab8:	a3 94       	inc	r10
    3aba:	01 c0       	rjmp	.+2      	; 0x3abe <vfscanf+0x72>
    3abc:	aa 24       	eor	r10, r10
    3abe:	55 24       	eor	r5, r5
    3ac0:	10 c0       	rjmp	.+32     	; 0x3ae2 <vfscanf+0x96>
    3ac2:	f2 e0       	ldi	r31, 0x02	; 2
    3ac4:	af 2a       	or	r10, r31
    3ac6:	65 2d       	mov	r22, r5
    3ac8:	70 e0       	ldi	r23, 0x00	; 0
    3aca:	80 e0       	ldi	r24, 0x00	; 0
    3acc:	90 e0       	ldi	r25, 0x00	; 0
    3ace:	40 e2       	ldi	r20, 0x20	; 32
    3ad0:	0e 94 66 1c 	call	0x38cc	; 0x38cc <mulacc>
    3ad4:	56 2e       	mov	r5, r22
    3ad6:	f4 01       	movw	r30, r8
    3ad8:	03 fd       	sbrc	r16, 3
    3ada:	35 91       	lpm	r19, Z+
    3adc:	03 ff       	sbrs	r16, 3
    3ade:	31 91       	ld	r19, Z+
    3ae0:	4f 01       	movw	r8, r30
    3ae2:	23 2f       	mov	r18, r19
    3ae4:	20 53       	subi	r18, 0x30	; 48
    3ae6:	2a 30       	cpi	r18, 0x0A	; 10
    3ae8:	60 f3       	brcs	.-40     	; 0x3ac2 <vfscanf+0x76>
    3aea:	a1 fe       	sbrs	r10, 1
    3aec:	03 c0       	rjmp	.+6      	; 0x3af4 <vfscanf+0xa8>
    3aee:	55 20       	and	r5, r5
    3af0:	19 f4       	brne	.+6      	; 0x3af8 <vfscanf+0xac>
    3af2:	ab c0       	rjmp	.+342    	; 0x3c4a <vfscanf+0x1fe>
    3af4:	55 24       	eor	r5, r5
    3af6:	5a 94       	dec	r5
    3af8:	38 36       	cpi	r19, 0x68	; 104
    3afa:	19 f0       	breq	.+6      	; 0x3b02 <vfscanf+0xb6>
    3afc:	3c 36       	cpi	r19, 0x6C	; 108
    3afe:	99 f4       	brne	.+38     	; 0x3b26 <vfscanf+0xda>
    3b00:	0a c0       	rjmp	.+20     	; 0x3b16 <vfscanf+0xca>
    3b02:	f4 01       	movw	r30, r8
    3b04:	03 fd       	sbrc	r16, 3
    3b06:	35 91       	lpm	r19, Z+
    3b08:	03 ff       	sbrs	r16, 3
    3b0a:	31 91       	ld	r19, Z+
    3b0c:	4f 01       	movw	r8, r30
    3b0e:	38 36       	cpi	r19, 0x68	; 104
    3b10:	51 f4       	brne	.+20     	; 0x3b26 <vfscanf+0xda>
    3b12:	f8 e0       	ldi	r31, 0x08	; 8
    3b14:	af 2a       	or	r10, r31
    3b16:	44 e0       	ldi	r20, 0x04	; 4
    3b18:	a4 2a       	or	r10, r20
    3b1a:	f4 01       	movw	r30, r8
    3b1c:	03 fd       	sbrc	r16, 3
    3b1e:	35 91       	lpm	r19, Z+
    3b20:	03 ff       	sbrs	r16, 3
    3b22:	31 91       	ld	r19, Z+
    3b24:	4f 01       	movw	r8, r30
    3b26:	33 23       	and	r19, r19
    3b28:	09 f4       	brne	.+2      	; 0x3b2c <vfscanf+0xe0>
    3b2a:	8f c0       	rjmp	.+286    	; 0x3c4a <vfscanf+0x1fe>
    3b2c:	8f e7       	ldi	r24, 0x7F	; 127
    3b2e:	90 e0       	ldi	r25, 0x00	; 0
    3b30:	63 2f       	mov	r22, r19
    3b32:	70 e0       	ldi	r23, 0x00	; 0
    3b34:	39 83       	std	Y+1, r19	; 0x01
    3b36:	0e 94 e6 1e 	call	0x3dcc	; 0x3dcc <strchr_P>
    3b3a:	39 81       	ldd	r19, Y+1	; 0x01
    3b3c:	00 97       	sbiw	r24, 0x00	; 0
    3b3e:	09 f4       	brne	.+2      	; 0x3b42 <vfscanf+0xf6>
    3b40:	84 c0       	rjmp	.+264    	; 0x3c4a <vfscanf+0x1fe>
    3b42:	8a 2d       	mov	r24, r10
    3b44:	a0 fc       	sbrc	r10, 0
    3b46:	08 c0       	rjmp	.+16     	; 0x3b58 <vfscanf+0x10c>
    3b48:	f3 01       	movw	r30, r6
    3b4a:	00 81       	ld	r16, Z
    3b4c:	11 81       	ldd	r17, Z+1	; 0x01
    3b4e:	42 e0       	ldi	r20, 0x02	; 2
    3b50:	50 e0       	ldi	r21, 0x00	; 0
    3b52:	64 0e       	add	r6, r20
    3b54:	75 1e       	adc	r7, r21
    3b56:	02 c0       	rjmp	.+4      	; 0x3b5c <vfscanf+0x110>
    3b58:	00 e0       	ldi	r16, 0x00	; 0
    3b5a:	10 e0       	ldi	r17, 0x00	; 0
    3b5c:	3e 36       	cpi	r19, 0x6E	; 110
    3b5e:	51 f4       	brne	.+20     	; 0x3b74 <vfscanf+0x128>
    3b60:	f7 01       	movw	r30, r14
    3b62:	46 81       	ldd	r20, Z+6	; 0x06
    3b64:	57 81       	ldd	r21, Z+7	; 0x07
    3b66:	60 e0       	ldi	r22, 0x00	; 0
    3b68:	70 e0       	ldi	r23, 0x00	; 0
    3b6a:	c8 01       	movw	r24, r16
    3b6c:	2a 2d       	mov	r18, r10
    3b6e:	0e 94 5a 1c 	call	0x38b4	; 0x38b4 <putval>
    3b72:	5d c0       	rjmp	.+186    	; 0x3c2e <vfscanf+0x1e2>
    3b74:	33 36       	cpi	r19, 0x63	; 99
    3b76:	91 f4       	brne	.+36     	; 0x3b9c <vfscanf+0x150>
    3b78:	81 fd       	sbrc	r24, 1
    3b7a:	02 c0       	rjmp	.+4      	; 0x3b80 <vfscanf+0x134>
    3b7c:	55 24       	eor	r5, r5
    3b7e:	53 94       	inc	r5
    3b80:	c7 01       	movw	r24, r14
    3b82:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <fgetc>
    3b86:	97 fd       	sbrc	r25, 7
    3b88:	5e c0       	rjmp	.+188    	; 0x3c46 <vfscanf+0x1fa>
    3b8a:	01 15       	cp	r16, r1
    3b8c:	11 05       	cpc	r17, r1
    3b8e:	19 f0       	breq	.+6      	; 0x3b96 <vfscanf+0x14a>
    3b90:	f8 01       	movw	r30, r16
    3b92:	81 93       	st	Z+, r24
    3b94:	8f 01       	movw	r16, r30
    3b96:	5a 94       	dec	r5
    3b98:	99 f7       	brne	.-26     	; 0x3b80 <vfscanf+0x134>
    3b9a:	47 c0       	rjmp	.+142    	; 0x3c2a <vfscanf+0x1de>
    3b9c:	c7 01       	movw	r24, r14
    3b9e:	39 83       	std	Y+1, r19	; 0x01
    3ba0:	0e 94 92 1c 	call	0x3924	; 0x3924 <skip_spaces>
    3ba4:	39 81       	ldd	r19, Y+1	; 0x01
    3ba6:	97 fd       	sbrc	r25, 7
    3ba8:	4e c0       	rjmp	.+156    	; 0x3c46 <vfscanf+0x1fa>
    3baa:	3f 36       	cpi	r19, 0x6F	; 111
    3bac:	61 f1       	breq	.+88     	; 0x3c06 <vfscanf+0x1ba>
    3bae:	30 37       	cpi	r19, 0x70	; 112
    3bb0:	28 f4       	brcc	.+10     	; 0x3bbc <vfscanf+0x170>
    3bb2:	34 36       	cpi	r19, 0x64	; 100
    3bb4:	29 f1       	breq	.+74     	; 0x3c00 <vfscanf+0x1b4>
    3bb6:	39 36       	cpi	r19, 0x69	; 105
    3bb8:	49 f5       	brne	.+82     	; 0x3c0c <vfscanf+0x1c0>
    3bba:	2a c0       	rjmp	.+84     	; 0x3c10 <vfscanf+0x1c4>
    3bbc:	33 37       	cpi	r19, 0x73	; 115
    3bbe:	19 f0       	breq	.+6      	; 0x3bc6 <vfscanf+0x17a>
    3bc0:	35 37       	cpi	r19, 0x75	; 117
    3bc2:	21 f5       	brne	.+72     	; 0x3c0c <vfscanf+0x1c0>
    3bc4:	1d c0       	rjmp	.+58     	; 0x3c00 <vfscanf+0x1b4>
    3bc6:	c7 01       	movw	r24, r14
    3bc8:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <fgetc>
    3bcc:	6c 01       	movw	r12, r24
    3bce:	97 fd       	sbrc	r25, 7
    3bd0:	11 c0       	rjmp	.+34     	; 0x3bf4 <vfscanf+0x1a8>
    3bd2:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <isspace>
    3bd6:	00 97       	sbiw	r24, 0x00	; 0
    3bd8:	29 f0       	breq	.+10     	; 0x3be4 <vfscanf+0x198>
    3bda:	c6 01       	movw	r24, r12
    3bdc:	b7 01       	movw	r22, r14
    3bde:	0e 94 5d 1f 	call	0x3eba	; 0x3eba <ungetc>
    3be2:	08 c0       	rjmp	.+16     	; 0x3bf4 <vfscanf+0x1a8>
    3be4:	01 15       	cp	r16, r1
    3be6:	11 05       	cpc	r17, r1
    3be8:	19 f0       	breq	.+6      	; 0x3bf0 <vfscanf+0x1a4>
    3bea:	f8 01       	movw	r30, r16
    3bec:	c1 92       	st	Z+, r12
    3bee:	8f 01       	movw	r16, r30
    3bf0:	5a 94       	dec	r5
    3bf2:	49 f7       	brne	.-46     	; 0x3bc6 <vfscanf+0x17a>
    3bf4:	01 15       	cp	r16, r1
    3bf6:	11 05       	cpc	r17, r1
    3bf8:	c1 f0       	breq	.+48     	; 0x3c2a <vfscanf+0x1de>
    3bfa:	f8 01       	movw	r30, r16
    3bfc:	10 82       	st	Z, r1
    3bfe:	15 c0       	rjmp	.+42     	; 0x3c2a <vfscanf+0x1de>
    3c00:	f0 e2       	ldi	r31, 0x20	; 32
    3c02:	af 2a       	or	r10, r31
    3c04:	05 c0       	rjmp	.+10     	; 0x3c10 <vfscanf+0x1c4>
    3c06:	40 e1       	ldi	r20, 0x10	; 16
    3c08:	a4 2a       	or	r10, r20
    3c0a:	02 c0       	rjmp	.+4      	; 0x3c10 <vfscanf+0x1c4>
    3c0c:	50 e4       	ldi	r21, 0x40	; 64
    3c0e:	a5 2a       	or	r10, r21
    3c10:	c7 01       	movw	r24, r14
    3c12:	65 2d       	mov	r22, r5
    3c14:	a8 01       	movw	r20, r16
    3c16:	2a 2d       	mov	r18, r10
    3c18:	0e 94 ab 1c 	call	0x3956	; 0x3956 <conv_int>
    3c1c:	88 23       	and	r24, r24
    3c1e:	29 f4       	brne	.+10     	; 0x3c2a <vfscanf+0x1de>
    3c20:	f7 01       	movw	r30, r14
    3c22:	83 81       	ldd	r24, Z+3	; 0x03
    3c24:	80 73       	andi	r24, 0x30	; 48
    3c26:	79 f4       	brne	.+30     	; 0x3c46 <vfscanf+0x1fa>
    3c28:	10 c0       	rjmp	.+32     	; 0x3c4a <vfscanf+0x1fe>
    3c2a:	a0 fe       	sbrs	r10, 0
    3c2c:	b3 94       	inc	r11
    3c2e:	f7 01       	movw	r30, r14
    3c30:	03 81       	ldd	r16, Z+3	; 0x03
    3c32:	f4 01       	movw	r30, r8
    3c34:	03 fd       	sbrc	r16, 3
    3c36:	15 91       	lpm	r17, Z+
    3c38:	03 ff       	sbrs	r16, 3
    3c3a:	11 91       	ld	r17, Z+
    3c3c:	4f 01       	movw	r8, r30
    3c3e:	11 23       	and	r17, r17
    3c40:	09 f0       	breq	.+2      	; 0x3c44 <vfscanf+0x1f8>
    3c42:	12 cf       	rjmp	.-476    	; 0x3a68 <vfscanf+0x1c>
    3c44:	02 c0       	rjmp	.+4      	; 0x3c4a <vfscanf+0x1fe>
    3c46:	bb 20       	and	r11, r11
    3c48:	19 f0       	breq	.+6      	; 0x3c50 <vfscanf+0x204>
    3c4a:	8b 2d       	mov	r24, r11
    3c4c:	90 e0       	ldi	r25, 0x00	; 0
    3c4e:	02 c0       	rjmp	.+4      	; 0x3c54 <vfscanf+0x208>
    3c50:	8f ef       	ldi	r24, 0xFF	; 255
    3c52:	9f ef       	ldi	r25, 0xFF	; 255
    3c54:	21 96       	adiw	r28, 0x01	; 1
    3c56:	ef e0       	ldi	r30, 0x0F	; 15
    3c58:	0c 94 bb 1e 	jmp	0x3d76	; 0x3d76 <__epilogue_restores__+0x6>

00003c5c <__umulhisi3>:
    3c5c:	a2 9f       	mul	r26, r18
    3c5e:	b0 01       	movw	r22, r0
    3c60:	b3 9f       	mul	r27, r19
    3c62:	c0 01       	movw	r24, r0
    3c64:	a3 9f       	mul	r26, r19
    3c66:	01 d0       	rcall	.+2      	; 0x3c6a <__umulhisi3+0xe>
    3c68:	b2 9f       	mul	r27, r18
    3c6a:	70 0d       	add	r23, r0
    3c6c:	81 1d       	adc	r24, r1
    3c6e:	11 24       	eor	r1, r1
    3c70:	91 1d       	adc	r25, r1
    3c72:	08 95       	ret

00003c74 <__mulsi3>:
    3c74:	db 01       	movw	r26, r22
    3c76:	8f 93       	push	r24
    3c78:	9f 93       	push	r25
    3c7a:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <__muluhisi3>
    3c7e:	bf 91       	pop	r27
    3c80:	af 91       	pop	r26
    3c82:	a2 9f       	mul	r26, r18
    3c84:	80 0d       	add	r24, r0
    3c86:	91 1d       	adc	r25, r1
    3c88:	a3 9f       	mul	r26, r19
    3c8a:	90 0d       	add	r25, r0
    3c8c:	b2 9f       	mul	r27, r18
    3c8e:	90 0d       	add	r25, r0
    3c90:	11 24       	eor	r1, r1
    3c92:	08 95       	ret

00003c94 <__udivmodhi4>:
    3c94:	aa 1b       	sub	r26, r26
    3c96:	bb 1b       	sub	r27, r27
    3c98:	51 e1       	ldi	r21, 0x11	; 17
    3c9a:	07 c0       	rjmp	.+14     	; 0x3caa <__udivmodhi4_ep>

00003c9c <__udivmodhi4_loop>:
    3c9c:	aa 1f       	adc	r26, r26
    3c9e:	bb 1f       	adc	r27, r27
    3ca0:	a6 17       	cp	r26, r22
    3ca2:	b7 07       	cpc	r27, r23
    3ca4:	10 f0       	brcs	.+4      	; 0x3caa <__udivmodhi4_ep>
    3ca6:	a6 1b       	sub	r26, r22
    3ca8:	b7 0b       	sbc	r27, r23

00003caa <__udivmodhi4_ep>:
    3caa:	88 1f       	adc	r24, r24
    3cac:	99 1f       	adc	r25, r25
    3cae:	5a 95       	dec	r21
    3cb0:	a9 f7       	brne	.-22     	; 0x3c9c <__udivmodhi4_loop>
    3cb2:	80 95       	com	r24
    3cb4:	90 95       	com	r25
    3cb6:	bc 01       	movw	r22, r24
    3cb8:	cd 01       	movw	r24, r26
    3cba:	08 95       	ret

00003cbc <__udivmodsi4>:
    3cbc:	a1 e2       	ldi	r26, 0x21	; 33
    3cbe:	1a 2e       	mov	r1, r26
    3cc0:	aa 1b       	sub	r26, r26
    3cc2:	bb 1b       	sub	r27, r27
    3cc4:	fd 01       	movw	r30, r26
    3cc6:	0d c0       	rjmp	.+26     	; 0x3ce2 <__udivmodsi4_ep>

00003cc8 <__udivmodsi4_loop>:
    3cc8:	aa 1f       	adc	r26, r26
    3cca:	bb 1f       	adc	r27, r27
    3ccc:	ee 1f       	adc	r30, r30
    3cce:	ff 1f       	adc	r31, r31
    3cd0:	a2 17       	cp	r26, r18
    3cd2:	b3 07       	cpc	r27, r19
    3cd4:	e4 07       	cpc	r30, r20
    3cd6:	f5 07       	cpc	r31, r21
    3cd8:	20 f0       	brcs	.+8      	; 0x3ce2 <__udivmodsi4_ep>
    3cda:	a2 1b       	sub	r26, r18
    3cdc:	b3 0b       	sbc	r27, r19
    3cde:	e4 0b       	sbc	r30, r20
    3ce0:	f5 0b       	sbc	r31, r21

00003ce2 <__udivmodsi4_ep>:
    3ce2:	66 1f       	adc	r22, r22
    3ce4:	77 1f       	adc	r23, r23
    3ce6:	88 1f       	adc	r24, r24
    3ce8:	99 1f       	adc	r25, r25
    3cea:	1a 94       	dec	r1
    3cec:	69 f7       	brne	.-38     	; 0x3cc8 <__udivmodsi4_loop>
    3cee:	60 95       	com	r22
    3cf0:	70 95       	com	r23
    3cf2:	80 95       	com	r24
    3cf4:	90 95       	com	r25
    3cf6:	9b 01       	movw	r18, r22
    3cf8:	ac 01       	movw	r20, r24
    3cfa:	bd 01       	movw	r22, r26
    3cfc:	cf 01       	movw	r24, r30
    3cfe:	08 95       	ret

00003d00 <__divmodsi4>:
    3d00:	05 2e       	mov	r0, r21
    3d02:	97 fb       	bst	r25, 7
    3d04:	16 f4       	brtc	.+4      	; 0x3d0a <__divmodsi4+0xa>
    3d06:	00 94       	com	r0
    3d08:	07 d0       	rcall	.+14     	; 0x3d18 <__divmodsi4_neg1>
    3d0a:	57 fd       	sbrc	r21, 7
    3d0c:	0d d0       	rcall	.+26     	; 0x3d28 <__divmodsi4_neg2>
    3d0e:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <__udivmodsi4>
    3d12:	07 fc       	sbrc	r0, 7
    3d14:	09 d0       	rcall	.+18     	; 0x3d28 <__divmodsi4_neg2>
    3d16:	7e f4       	brtc	.+30     	; 0x3d36 <__divmodsi4_exit>

00003d18 <__divmodsi4_neg1>:
    3d18:	90 95       	com	r25
    3d1a:	80 95       	com	r24
    3d1c:	70 95       	com	r23
    3d1e:	61 95       	neg	r22
    3d20:	7f 4f       	sbci	r23, 0xFF	; 255
    3d22:	8f 4f       	sbci	r24, 0xFF	; 255
    3d24:	9f 4f       	sbci	r25, 0xFF	; 255
    3d26:	08 95       	ret

00003d28 <__divmodsi4_neg2>:
    3d28:	50 95       	com	r21
    3d2a:	40 95       	com	r20
    3d2c:	30 95       	com	r19
    3d2e:	21 95       	neg	r18
    3d30:	3f 4f       	sbci	r19, 0xFF	; 255
    3d32:	4f 4f       	sbci	r20, 0xFF	; 255
    3d34:	5f 4f       	sbci	r21, 0xFF	; 255

00003d36 <__divmodsi4_exit>:
    3d36:	08 95       	ret

00003d38 <__prologue_saves__>:
    3d38:	2f 92       	push	r2
    3d3a:	3f 92       	push	r3
    3d3c:	4f 92       	push	r4
    3d3e:	5f 92       	push	r5
    3d40:	6f 92       	push	r6
    3d42:	7f 92       	push	r7
    3d44:	8f 92       	push	r8
    3d46:	9f 92       	push	r9
    3d48:	af 92       	push	r10
    3d4a:	bf 92       	push	r11
    3d4c:	cf 92       	push	r12
    3d4e:	df 92       	push	r13
    3d50:	ef 92       	push	r14
    3d52:	ff 92       	push	r15
    3d54:	0f 93       	push	r16
    3d56:	1f 93       	push	r17
    3d58:	cf 93       	push	r28
    3d5a:	df 93       	push	r29
    3d5c:	cd b7       	in	r28, 0x3d	; 61
    3d5e:	de b7       	in	r29, 0x3e	; 62
    3d60:	ca 1b       	sub	r28, r26
    3d62:	db 0b       	sbc	r29, r27
    3d64:	0f b6       	in	r0, 0x3f	; 63
    3d66:	f8 94       	cli
    3d68:	de bf       	out	0x3e, r29	; 62
    3d6a:	0f be       	out	0x3f, r0	; 63
    3d6c:	cd bf       	out	0x3d, r28	; 61
    3d6e:	09 94       	ijmp

00003d70 <__epilogue_restores__>:
    3d70:	2a 88       	ldd	r2, Y+18	; 0x12
    3d72:	39 88       	ldd	r3, Y+17	; 0x11
    3d74:	48 88       	ldd	r4, Y+16	; 0x10
    3d76:	5f 84       	ldd	r5, Y+15	; 0x0f
    3d78:	6e 84       	ldd	r6, Y+14	; 0x0e
    3d7a:	7d 84       	ldd	r7, Y+13	; 0x0d
    3d7c:	8c 84       	ldd	r8, Y+12	; 0x0c
    3d7e:	9b 84       	ldd	r9, Y+11	; 0x0b
    3d80:	aa 84       	ldd	r10, Y+10	; 0x0a
    3d82:	b9 84       	ldd	r11, Y+9	; 0x09
    3d84:	c8 84       	ldd	r12, Y+8	; 0x08
    3d86:	df 80       	ldd	r13, Y+7	; 0x07
    3d88:	ee 80       	ldd	r14, Y+6	; 0x06
    3d8a:	fd 80       	ldd	r15, Y+5	; 0x05
    3d8c:	0c 81       	ldd	r16, Y+4	; 0x04
    3d8e:	1b 81       	ldd	r17, Y+3	; 0x03
    3d90:	aa 81       	ldd	r26, Y+2	; 0x02
    3d92:	b9 81       	ldd	r27, Y+1	; 0x01
    3d94:	ce 0f       	add	r28, r30
    3d96:	d1 1d       	adc	r29, r1
    3d98:	0f b6       	in	r0, 0x3f	; 63
    3d9a:	f8 94       	cli
    3d9c:	de bf       	out	0x3e, r29	; 62
    3d9e:	0f be       	out	0x3f, r0	; 63
    3da0:	cd bf       	out	0x3d, r28	; 61
    3da2:	ed 01       	movw	r28, r26
    3da4:	08 95       	ret

00003da6 <__muluhisi3>:
    3da6:	0e 94 2e 1e 	call	0x3c5c	; 0x3c5c <__umulhisi3>
    3daa:	a5 9f       	mul	r26, r21
    3dac:	90 0d       	add	r25, r0
    3dae:	b4 9f       	mul	r27, r20
    3db0:	90 0d       	add	r25, r0
    3db2:	a4 9f       	mul	r26, r20
    3db4:	80 0d       	add	r24, r0
    3db6:	91 1d       	adc	r25, r1
    3db8:	11 24       	eor	r1, r1
    3dba:	08 95       	ret

00003dbc <isspace>:
    3dbc:	91 11       	cpse	r25, r1
    3dbe:	f8 c0       	rjmp	.+496    	; 0x3fb0 <__ctype_isfalse>
    3dc0:	80 32       	cpi	r24, 0x20	; 32
    3dc2:	19 f0       	breq	.+6      	; 0x3dca <isspace+0xe>
    3dc4:	89 50       	subi	r24, 0x09	; 9
    3dc6:	85 50       	subi	r24, 0x05	; 5
    3dc8:	d0 f7       	brcc	.-12     	; 0x3dbe <isspace+0x2>
    3dca:	08 95       	ret

00003dcc <strchr_P>:
    3dcc:	fc 01       	movw	r30, r24
    3dce:	05 90       	lpm	r0, Z+
    3dd0:	06 16       	cp	r0, r22
    3dd2:	21 f0       	breq	.+8      	; 0x3ddc <strchr_P+0x10>
    3dd4:	00 20       	and	r0, r0
    3dd6:	d9 f7       	brne	.-10     	; 0x3dce <strchr_P+0x2>
    3dd8:	c0 01       	movw	r24, r0
    3dda:	08 95       	ret
    3ddc:	31 97       	sbiw	r30, 0x01	; 1
    3dde:	cf 01       	movw	r24, r30
    3de0:	08 95       	ret

00003de2 <fgetc>:
    3de2:	cf 93       	push	r28
    3de4:	df 93       	push	r29
    3de6:	ec 01       	movw	r28, r24
    3de8:	2b 81       	ldd	r18, Y+3	; 0x03
    3dea:	20 ff       	sbrs	r18, 0
    3dec:	35 c0       	rjmp	.+106    	; 0x3e58 <fgetc+0x76>
    3dee:	26 ff       	sbrs	r18, 6
    3df0:	09 c0       	rjmp	.+18     	; 0x3e04 <fgetc+0x22>
    3df2:	2f 7b       	andi	r18, 0xBF	; 191
    3df4:	2b 83       	std	Y+3, r18	; 0x03
    3df6:	8e 81       	ldd	r24, Y+6	; 0x06
    3df8:	9f 81       	ldd	r25, Y+7	; 0x07
    3dfa:	01 96       	adiw	r24, 0x01	; 1
    3dfc:	9f 83       	std	Y+7, r25	; 0x07
    3dfe:	8e 83       	std	Y+6, r24	; 0x06
    3e00:	8a 81       	ldd	r24, Y+2	; 0x02
    3e02:	28 c0       	rjmp	.+80     	; 0x3e54 <fgetc+0x72>
    3e04:	22 ff       	sbrs	r18, 2
    3e06:	0f c0       	rjmp	.+30     	; 0x3e26 <fgetc+0x44>
    3e08:	e8 81       	ld	r30, Y
    3e0a:	f9 81       	ldd	r31, Y+1	; 0x01
    3e0c:	80 81       	ld	r24, Z
    3e0e:	99 27       	eor	r25, r25
    3e10:	87 fd       	sbrc	r24, 7
    3e12:	90 95       	com	r25
    3e14:	00 97       	sbiw	r24, 0x00	; 0
    3e16:	19 f4       	brne	.+6      	; 0x3e1e <fgetc+0x3c>
    3e18:	20 62       	ori	r18, 0x20	; 32
    3e1a:	2b 83       	std	Y+3, r18	; 0x03
    3e1c:	1d c0       	rjmp	.+58     	; 0x3e58 <fgetc+0x76>
    3e1e:	31 96       	adiw	r30, 0x01	; 1
    3e20:	f9 83       	std	Y+1, r31	; 0x01
    3e22:	e8 83       	st	Y, r30
    3e24:	11 c0       	rjmp	.+34     	; 0x3e48 <fgetc+0x66>
    3e26:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e28:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e2a:	ce 01       	movw	r24, r28
    3e2c:	09 95       	icall
    3e2e:	97 ff       	sbrs	r25, 7
    3e30:	0b c0       	rjmp	.+22     	; 0x3e48 <fgetc+0x66>
    3e32:	2b 81       	ldd	r18, Y+3	; 0x03
    3e34:	3f ef       	ldi	r19, 0xFF	; 255
    3e36:	8f 3f       	cpi	r24, 0xFF	; 255
    3e38:	93 07       	cpc	r25, r19
    3e3a:	11 f4       	brne	.+4      	; 0x3e40 <fgetc+0x5e>
    3e3c:	80 e1       	ldi	r24, 0x10	; 16
    3e3e:	01 c0       	rjmp	.+2      	; 0x3e42 <fgetc+0x60>
    3e40:	80 e2       	ldi	r24, 0x20	; 32
    3e42:	82 2b       	or	r24, r18
    3e44:	8b 83       	std	Y+3, r24	; 0x03
    3e46:	08 c0       	rjmp	.+16     	; 0x3e58 <fgetc+0x76>
    3e48:	2e 81       	ldd	r18, Y+6	; 0x06
    3e4a:	3f 81       	ldd	r19, Y+7	; 0x07
    3e4c:	2f 5f       	subi	r18, 0xFF	; 255
    3e4e:	3f 4f       	sbci	r19, 0xFF	; 255
    3e50:	3f 83       	std	Y+7, r19	; 0x07
    3e52:	2e 83       	std	Y+6, r18	; 0x06
    3e54:	90 e0       	ldi	r25, 0x00	; 0
    3e56:	02 c0       	rjmp	.+4      	; 0x3e5c <fgetc+0x7a>
    3e58:	8f ef       	ldi	r24, 0xFF	; 255
    3e5a:	9f ef       	ldi	r25, 0xFF	; 255
    3e5c:	df 91       	pop	r29
    3e5e:	cf 91       	pop	r28
    3e60:	08 95       	ret

00003e62 <fputc>:
    3e62:	0f 93       	push	r16
    3e64:	1f 93       	push	r17
    3e66:	cf 93       	push	r28
    3e68:	df 93       	push	r29
    3e6a:	8c 01       	movw	r16, r24
    3e6c:	eb 01       	movw	r28, r22
    3e6e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e70:	81 ff       	sbrs	r24, 1
    3e72:	1b c0       	rjmp	.+54     	; 0x3eaa <fputc+0x48>
    3e74:	82 ff       	sbrs	r24, 2
    3e76:	0d c0       	rjmp	.+26     	; 0x3e92 <fputc+0x30>
    3e78:	2e 81       	ldd	r18, Y+6	; 0x06
    3e7a:	3f 81       	ldd	r19, Y+7	; 0x07
    3e7c:	8c 81       	ldd	r24, Y+4	; 0x04
    3e7e:	9d 81       	ldd	r25, Y+5	; 0x05
    3e80:	28 17       	cp	r18, r24
    3e82:	39 07       	cpc	r19, r25
    3e84:	64 f4       	brge	.+24     	; 0x3e9e <fputc+0x3c>
    3e86:	e8 81       	ld	r30, Y
    3e88:	f9 81       	ldd	r31, Y+1	; 0x01
    3e8a:	01 93       	st	Z+, r16
    3e8c:	f9 83       	std	Y+1, r31	; 0x01
    3e8e:	e8 83       	st	Y, r30
    3e90:	06 c0       	rjmp	.+12     	; 0x3e9e <fputc+0x3c>
    3e92:	e8 85       	ldd	r30, Y+8	; 0x08
    3e94:	f9 85       	ldd	r31, Y+9	; 0x09
    3e96:	80 2f       	mov	r24, r16
    3e98:	09 95       	icall
    3e9a:	00 97       	sbiw	r24, 0x00	; 0
    3e9c:	31 f4       	brne	.+12     	; 0x3eaa <fputc+0x48>
    3e9e:	8e 81       	ldd	r24, Y+6	; 0x06
    3ea0:	9f 81       	ldd	r25, Y+7	; 0x07
    3ea2:	01 96       	adiw	r24, 0x01	; 1
    3ea4:	9f 83       	std	Y+7, r25	; 0x07
    3ea6:	8e 83       	std	Y+6, r24	; 0x06
    3ea8:	02 c0       	rjmp	.+4      	; 0x3eae <fputc+0x4c>
    3eaa:	0f ef       	ldi	r16, 0xFF	; 255
    3eac:	1f ef       	ldi	r17, 0xFF	; 255
    3eae:	c8 01       	movw	r24, r16
    3eb0:	df 91       	pop	r29
    3eb2:	cf 91       	pop	r28
    3eb4:	1f 91       	pop	r17
    3eb6:	0f 91       	pop	r16
    3eb8:	08 95       	ret

00003eba <ungetc>:
    3eba:	fb 01       	movw	r30, r22
    3ebc:	23 81       	ldd	r18, Z+3	; 0x03
    3ebe:	20 ff       	sbrs	r18, 0
    3ec0:	13 c0       	rjmp	.+38     	; 0x3ee8 <ungetc+0x2e>
    3ec2:	26 fd       	sbrc	r18, 6
    3ec4:	11 c0       	rjmp	.+34     	; 0x3ee8 <ungetc+0x2e>
    3ec6:	3f ef       	ldi	r19, 0xFF	; 255
    3ec8:	8f 3f       	cpi	r24, 0xFF	; 255
    3eca:	93 07       	cpc	r25, r19
    3ecc:	81 f0       	breq	.+32     	; 0x3eee <ungetc+0x34>
    3ece:	82 83       	std	Z+2, r24	; 0x02
    3ed0:	92 2f       	mov	r25, r18
    3ed2:	90 64       	ori	r25, 0x40	; 64
    3ed4:	9f 7d       	andi	r25, 0xDF	; 223
    3ed6:	93 83       	std	Z+3, r25	; 0x03
    3ed8:	26 81       	ldd	r18, Z+6	; 0x06
    3eda:	37 81       	ldd	r19, Z+7	; 0x07
    3edc:	21 50       	subi	r18, 0x01	; 1
    3ede:	30 40       	sbci	r19, 0x00	; 0
    3ee0:	37 83       	std	Z+7, r19	; 0x07
    3ee2:	26 83       	std	Z+6, r18	; 0x06
    3ee4:	90 e0       	ldi	r25, 0x00	; 0
    3ee6:	08 95       	ret
    3ee8:	8f ef       	ldi	r24, 0xFF	; 255
    3eea:	9f ef       	ldi	r25, 0xFF	; 255
    3eec:	08 95       	ret
    3eee:	8f ef       	ldi	r24, 0xFF	; 255
    3ef0:	9f ef       	ldi	r25, 0xFF	; 255
    3ef2:	08 95       	ret

00003ef4 <__ultoa_invert>:
    3ef4:	fa 01       	movw	r30, r20
    3ef6:	aa 27       	eor	r26, r26
    3ef8:	28 30       	cpi	r18, 0x08	; 8
    3efa:	51 f1       	breq	.+84     	; 0x3f50 <__ultoa_invert+0x5c>
    3efc:	20 31       	cpi	r18, 0x10	; 16
    3efe:	81 f1       	breq	.+96     	; 0x3f60 <__ultoa_invert+0x6c>
    3f00:	e8 94       	clt
    3f02:	6f 93       	push	r22
    3f04:	6e 7f       	andi	r22, 0xFE	; 254
    3f06:	6e 5f       	subi	r22, 0xFE	; 254
    3f08:	7f 4f       	sbci	r23, 0xFF	; 255
    3f0a:	8f 4f       	sbci	r24, 0xFF	; 255
    3f0c:	9f 4f       	sbci	r25, 0xFF	; 255
    3f0e:	af 4f       	sbci	r26, 0xFF	; 255
    3f10:	b1 e0       	ldi	r27, 0x01	; 1
    3f12:	3e d0       	rcall	.+124    	; 0x3f90 <__ultoa_invert+0x9c>
    3f14:	b4 e0       	ldi	r27, 0x04	; 4
    3f16:	3c d0       	rcall	.+120    	; 0x3f90 <__ultoa_invert+0x9c>
    3f18:	67 0f       	add	r22, r23
    3f1a:	78 1f       	adc	r23, r24
    3f1c:	89 1f       	adc	r24, r25
    3f1e:	9a 1f       	adc	r25, r26
    3f20:	a1 1d       	adc	r26, r1
    3f22:	68 0f       	add	r22, r24
    3f24:	79 1f       	adc	r23, r25
    3f26:	8a 1f       	adc	r24, r26
    3f28:	91 1d       	adc	r25, r1
    3f2a:	a1 1d       	adc	r26, r1
    3f2c:	6a 0f       	add	r22, r26
    3f2e:	71 1d       	adc	r23, r1
    3f30:	81 1d       	adc	r24, r1
    3f32:	91 1d       	adc	r25, r1
    3f34:	a1 1d       	adc	r26, r1
    3f36:	20 d0       	rcall	.+64     	; 0x3f78 <__ultoa_invert+0x84>
    3f38:	09 f4       	brne	.+2      	; 0x3f3c <__ultoa_invert+0x48>
    3f3a:	68 94       	set
    3f3c:	3f 91       	pop	r19
    3f3e:	2a e0       	ldi	r18, 0x0A	; 10
    3f40:	26 9f       	mul	r18, r22
    3f42:	11 24       	eor	r1, r1
    3f44:	30 19       	sub	r19, r0
    3f46:	30 5d       	subi	r19, 0xD0	; 208
    3f48:	31 93       	st	Z+, r19
    3f4a:	de f6       	brtc	.-74     	; 0x3f02 <__ultoa_invert+0xe>
    3f4c:	cf 01       	movw	r24, r30
    3f4e:	08 95       	ret
    3f50:	46 2f       	mov	r20, r22
    3f52:	47 70       	andi	r20, 0x07	; 7
    3f54:	40 5d       	subi	r20, 0xD0	; 208
    3f56:	41 93       	st	Z+, r20
    3f58:	b3 e0       	ldi	r27, 0x03	; 3
    3f5a:	0f d0       	rcall	.+30     	; 0x3f7a <__ultoa_invert+0x86>
    3f5c:	c9 f7       	brne	.-14     	; 0x3f50 <__ultoa_invert+0x5c>
    3f5e:	f6 cf       	rjmp	.-20     	; 0x3f4c <__ultoa_invert+0x58>
    3f60:	46 2f       	mov	r20, r22
    3f62:	4f 70       	andi	r20, 0x0F	; 15
    3f64:	40 5d       	subi	r20, 0xD0	; 208
    3f66:	4a 33       	cpi	r20, 0x3A	; 58
    3f68:	18 f0       	brcs	.+6      	; 0x3f70 <__ultoa_invert+0x7c>
    3f6a:	49 5d       	subi	r20, 0xD9	; 217
    3f6c:	31 fd       	sbrc	r19, 1
    3f6e:	40 52       	subi	r20, 0x20	; 32
    3f70:	41 93       	st	Z+, r20
    3f72:	02 d0       	rcall	.+4      	; 0x3f78 <__ultoa_invert+0x84>
    3f74:	a9 f7       	brne	.-22     	; 0x3f60 <__ultoa_invert+0x6c>
    3f76:	ea cf       	rjmp	.-44     	; 0x3f4c <__ultoa_invert+0x58>
    3f78:	b4 e0       	ldi	r27, 0x04	; 4
    3f7a:	a6 95       	lsr	r26
    3f7c:	97 95       	ror	r25
    3f7e:	87 95       	ror	r24
    3f80:	77 95       	ror	r23
    3f82:	67 95       	ror	r22
    3f84:	ba 95       	dec	r27
    3f86:	c9 f7       	brne	.-14     	; 0x3f7a <__ultoa_invert+0x86>
    3f88:	00 97       	sbiw	r24, 0x00	; 0
    3f8a:	61 05       	cpc	r22, r1
    3f8c:	71 05       	cpc	r23, r1
    3f8e:	08 95       	ret
    3f90:	9b 01       	movw	r18, r22
    3f92:	ac 01       	movw	r20, r24
    3f94:	0a 2e       	mov	r0, r26
    3f96:	06 94       	lsr	r0
    3f98:	57 95       	ror	r21
    3f9a:	47 95       	ror	r20
    3f9c:	37 95       	ror	r19
    3f9e:	27 95       	ror	r18
    3fa0:	ba 95       	dec	r27
    3fa2:	c9 f7       	brne	.-14     	; 0x3f96 <__ultoa_invert+0xa2>
    3fa4:	62 0f       	add	r22, r18
    3fa6:	73 1f       	adc	r23, r19
    3fa8:	84 1f       	adc	r24, r20
    3faa:	95 1f       	adc	r25, r21
    3fac:	a0 1d       	adc	r26, r0
    3fae:	08 95       	ret

00003fb0 <__ctype_isfalse>:
    3fb0:	99 27       	eor	r25, r25
    3fb2:	88 27       	eor	r24, r24

00003fb4 <__ctype_istrue>:
    3fb4:	08 95       	ret

00003fb6 <_exit>:
    3fb6:	f8 94       	cli

00003fb8 <__stop_program>:
    3fb8:	ff cf       	rjmp	.-2      	; 0x3fb8 <__stop_program>
