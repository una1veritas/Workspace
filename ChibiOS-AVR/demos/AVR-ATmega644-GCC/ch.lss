
ch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009c  00800100  00003fd6  0000406a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003fd6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000011d  0080019c  0080019c  00004106  2**0
                  ALLOC
  3 .stab         000031bc  00000000  00000000  00004108  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000103b  00000000  00000000  000072c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000082ff  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000005d0  00000000  00000000  00008310  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000ed40  00000000  00000000  000088e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003ed7  00000000  00000000  00017620  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000032d3  00000000  00000000  0001b4f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001acc  00000000  00000000  0001e7cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001bda  00000000  00000000  00020298  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00007b0f  00000000  00000000  00021e72  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000220  00000000  00000000  00029981  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__ctors_end>
       4:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
       8:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
       c:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      10:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      14:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      18:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      1c:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      20:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      24:	0c 94 de 14 	jmp	0x29bc	; 0x29bc <__vector_9>
      28:	0c 94 0f 15 	jmp	0x2a1e	; 0x2a1e <__vector_10>
      2c:	0c 94 ad 14 	jmp	0x295a	; 0x295a <__vector_11>
      30:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      34:	0c 94 4b 14 	jmp	0x2896	; 0x2896 <__vector_13>
      38:	0c 94 7c 14 	jmp	0x28f8	; 0x28f8 <__vector_14>
      3c:	0c 94 1a 14 	jmp	0x2834	; 0x2834 <__vector_15>
      40:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__vector_16>
      44:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      48:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      4c:	0c 94 03 17 	jmp	0x2e06	; 0x2e06 <__vector_19>
      50:	0c 94 c6 11 	jmp	0x238c	; 0x238c <__vector_20>
      54:	0c 94 06 12 	jmp	0x240c	; 0x240c <__vector_21>
      58:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      5c:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      60:	0c 94 84 12 	jmp	0x2508	; 0x2508 <__vector_24>
      64:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      68:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      6c:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      70:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      74:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>
      78:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__bad_interrupt>

0000007c <__c.1844>:
      7c:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

0000008c <__c.1850>:
      8c:	45 46 47 65 66 67 00                                EFGefg.

00000093 <__c.1977>:
      93:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000009e <__ctors_end>:
      9e:	11 24       	eor	r1, r1
      a0:	1f be       	out	0x3f, r1	; 63
      a2:	cf ef       	ldi	r28, 0xFF	; 255
      a4:	d0 e1       	ldi	r29, 0x10	; 16
      a6:	de bf       	out	0x3e, r29	; 62
      a8:	cd bf       	out	0x3d, r28	; 61

000000aa <__do_copy_data>:
      aa:	11 e0       	ldi	r17, 0x01	; 1
      ac:	a0 e0       	ldi	r26, 0x00	; 0
      ae:	b1 e0       	ldi	r27, 0x01	; 1
      b0:	e6 ed       	ldi	r30, 0xD6	; 214
      b2:	ff e3       	ldi	r31, 0x3F	; 63
      b4:	02 c0       	rjmp	.+4      	; 0xba <__do_copy_data+0x10>
      b6:	05 90       	lpm	r0, Z+
      b8:	0d 92       	st	X+, r0
      ba:	ac 39       	cpi	r26, 0x9C	; 156
      bc:	b1 07       	cpc	r27, r17
      be:	d9 f7       	brne	.-10     	; 0xb6 <__do_copy_data+0xc>

000000c0 <__do_clear_bss>:
      c0:	12 e0       	ldi	r17, 0x02	; 2
      c2:	ac e9       	ldi	r26, 0x9C	; 156
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	01 c0       	rjmp	.+2      	; 0xca <.do_clear_bss_start>

000000c8 <.do_clear_bss_loop>:
      c8:	1d 92       	st	X+, r1

000000ca <.do_clear_bss_start>:
      ca:	a9 3b       	cpi	r26, 0xB9	; 185
      cc:	b1 07       	cpc	r27, r17
      ce:	e1 f7       	brne	.-8      	; 0xc8 <.do_clear_bss_loop>
      d0:	0e 94 10 1b 	call	0x3620	; 0x3620 <main>
      d4:	0c 94 e9 1f 	jmp	0x3fd2	; 0x3fd2 <_exit>

000000d8 <__bad_interrupt>:
      d8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000dc <__vector_16>:


/**
 * @brief   Timer0 interrupt handler.
 */
CH_IRQ_HANDLER(TIMER0_COMPA_vect) {
      dc:	1f 92       	push	r1
      de:	0f 92       	push	r0
      e0:	0f b6       	in	r0, 0x3f	; 63
      e2:	0f 92       	push	r0
      e4:	11 24       	eor	r1, r1
      e6:	2f 93       	push	r18
      e8:	3f 93       	push	r19
      ea:	4f 93       	push	r20
      ec:	5f 93       	push	r21
      ee:	6f 93       	push	r22
      f0:	7f 93       	push	r23
      f2:	8f 93       	push	r24
      f4:	9f 93       	push	r25
      f6:	af 93       	push	r26
      f8:	bf 93       	push	r27
      fa:	ef 93       	push	r30
      fc:	ff 93       	push	r31

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
  chSysTimerHandlerI();
      fe:	0e 94 01 01 	call	0x202	; 0x202 <chSysTimerHandlerI>
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
     102:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
     106:	81 11       	cpse	r24, r1
     108:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
     10c:	ff 91       	pop	r31
     10e:	ef 91       	pop	r30
     110:	bf 91       	pop	r27
     112:	af 91       	pop	r26
     114:	9f 91       	pop	r25
     116:	8f 91       	pop	r24
     118:	7f 91       	pop	r23
     11a:	6f 91       	pop	r22
     11c:	5f 91       	pop	r21
     11e:	4f 91       	pop	r20
     120:	3f 91       	pop	r19
     122:	2f 91       	pop	r18
     124:	0f 90       	pop	r0
     126:	0f be       	out	0x3f, r0	; 63
     128:	0f 90       	pop	r0
     12a:	1f 90       	pop	r1
     12c:	18 95       	reti

0000012e <port_switch>:
#if !defined(__DOXYGEN__)
__attribute__((naked, weak))
#endif
void port_switch(Thread *ntp, Thread *otp) {

  asm volatile ("push    r2");
     12e:	2f 92       	push	r2
  asm volatile ("push    r3");
     130:	3f 92       	push	r3
  asm volatile ("push    r4");
     132:	4f 92       	push	r4
  asm volatile ("push    r5");
     134:	5f 92       	push	r5
  asm volatile ("push    r6");
     136:	6f 92       	push	r6
  asm volatile ("push    r7");
     138:	7f 92       	push	r7
  asm volatile ("push    r8");
     13a:	8f 92       	push	r8
  asm volatile ("push    r9");
     13c:	9f 92       	push	r9
  asm volatile ("push    r10");
     13e:	af 92       	push	r10
  asm volatile ("push    r11");
     140:	bf 92       	push	r11
  asm volatile ("push    r12");
     142:	cf 92       	push	r12
  asm volatile ("push    r13");
     144:	df 92       	push	r13
  asm volatile ("push    r14");
     146:	ef 92       	push	r14
  asm volatile ("push    r15");
     148:	ff 92       	push	r15
  asm volatile ("push    r16");
     14a:	0f 93       	push	r16
  asm volatile ("push    r17");
     14c:	1f 93       	push	r17
  asm volatile ("push    r28");
     14e:	cf 93       	push	r28
  asm volatile ("push    r29");
     150:	df 93       	push	r29

  asm volatile ("movw    r30, r22");
     152:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
     154:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
     156:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
     158:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
     15a:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
     15c:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
     15e:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
     160:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
     162:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
     164:	0e be       	out	0x3e, r0	; 62

  asm volatile ("pop     r29");
     166:	df 91       	pop	r29
  asm volatile ("pop     r28");
     168:	cf 91       	pop	r28
  asm volatile ("pop     r17");
     16a:	1f 91       	pop	r17
  asm volatile ("pop     r16");
     16c:	0f 91       	pop	r16
  asm volatile ("pop     r15");
     16e:	ff 90       	pop	r15
  asm volatile ("pop     r14");
     170:	ef 90       	pop	r14
  asm volatile ("pop     r13");
     172:	df 90       	pop	r13
  asm volatile ("pop     r12");
     174:	cf 90       	pop	r12
  asm volatile ("pop     r11");
     176:	bf 90       	pop	r11
  asm volatile ("pop     r10");
     178:	af 90       	pop	r10
  asm volatile ("pop     r9");
     17a:	9f 90       	pop	r9
  asm volatile ("pop     r8");
     17c:	8f 90       	pop	r8
  asm volatile ("pop     r7");
     17e:	7f 90       	pop	r7
  asm volatile ("pop     r6");
     180:	6f 90       	pop	r6
  asm volatile ("pop     r5");
     182:	5f 90       	pop	r5
  asm volatile ("pop     r4");
     184:	4f 90       	pop	r4
  asm volatile ("pop     r3");
     186:	3f 90       	pop	r3
  asm volatile ("pop     r2");
     188:	2f 90       	pop	r2
  asm volatile ("ret");
     18a:	08 95       	ret

0000018c <port_halt>:
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void port_halt(void) {

  port_disable();
     18c:	f8 94       	cli
     18e:	ff cf       	rjmp	.-2      	; 0x18e <port_halt+0x2>

00000190 <_port_thread_start>:
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
     190:	78 94       	sei
  asm volatile ("movw    r24, r4");
     192:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
     194:	f1 01       	movw	r30, r2
  asm volatile ("icall");
     196:	09 95       	icall
  asm volatile ("call    chThdExit");
     198:	0e 94 c7 04 	call	0x98e	; 0x98e <chThdExit>
     19c:	08 95       	ret

0000019e <_idle_thread>:
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
     19e:	e0 91 3c 02 	lds	r30, 0x023C
     1a2:	f0 91 3d 02 	lds	r31, 0x023D
     1a6:	85 e8       	ldi	r24, 0x85	; 133
     1a8:	91 e0       	ldi	r25, 0x01	; 1
     1aa:	94 87       	std	Z+12, r25	; 0x0c
     1ac:	83 87       	std	Z+11, r24	; 0x0b
     1ae:	ff cf       	rjmp	.-2      	; 0x1ae <_idle_thread+0x10>

000001b0 <chSysInit>:
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
     1b0:	0f 93       	push	r16
     1b2:	1f 93       	push	r17
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
     1b4:	0e 94 2b 02 	call	0x456	; 0x456 <_scheduler_init>
  _vt_init();
     1b8:	0e 94 56 01 	call	0x2ac	; 0x2ac <_vt_init>
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
     1bc:	60 e4       	ldi	r22, 0x40	; 64
     1be:	8c e9       	ldi	r24, 0x9C	; 156
     1c0:	91 e0       	ldi	r25, 0x01	; 1
     1c2:	0e 94 b2 03 	call	0x764	; 0x764 <_thread_init>
     1c6:	90 93 3d 02 	sts	0x023D, r25
     1ca:	80 93 3c 02 	sts	0x023C, r24
  currp->p_state = THD_STATE_CURRENT;
     1ce:	21 e0       	ldi	r18, 0x01	; 1
     1d0:	fc 01       	movw	r30, r24
     1d2:	25 87       	std	Z+13, r18	; 0x0d
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
     1d4:	78 94       	sei

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
     1d6:	e0 91 3c 02 	lds	r30, 0x023C
     1da:	f0 91 3d 02 	lds	r31, 0x023D
     1de:	84 e5       	ldi	r24, 0x54	; 84
     1e0:	91 e0       	ldi	r25, 0x01	; 1
     1e2:	94 87       	std	Z+12, r25	; 0x0c
     1e4:	83 87       	std	Z+11, r24	; 0x0b

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
     1e6:	00 e0       	ldi	r16, 0x00	; 0
     1e8:	10 e0       	ldi	r17, 0x00	; 0
     1ea:	2f ec       	ldi	r18, 0xCF	; 207
     1ec:	30 e0       	ldi	r19, 0x00	; 0
     1ee:	41 e0       	ldi	r20, 0x01	; 1
     1f0:	6d e6       	ldi	r22, 0x6D	; 109
     1f2:	70 e0       	ldi	r23, 0x00	; 0
     1f4:	8c eb       	ldi	r24, 0xBC	; 188
     1f6:	91 e0       	ldi	r25, 0x01	; 1
     1f8:	0e 94 33 04 	call	0x866	; 0x866 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
     1fc:	1f 91       	pop	r17
     1fe:	0f 91       	pop	r16
     200:	08 95       	ret

00000202 <chSysTimerHandlerI>:
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     202:	0f 93       	push	r16
     204:	1f 93       	push	r17
     206:	cf 93       	push	r28
     208:	df 93       	push	r29

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
     20a:	e0 91 3c 02 	lds	r30, 0x023C
     20e:	f0 91 3d 02 	lds	r31, 0x023D
     212:	87 85       	ldd	r24, Z+15	; 0x0f
     214:	88 23       	and	r24, r24
     216:	11 f0       	breq	.+4      	; 0x21c <chSysTimerHandlerI+0x1a>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
     218:	81 50       	subi	r24, 0x01	; 1
     21a:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
     21c:	80 89       	ldd	r24, Z+16	; 0x10
     21e:	91 89       	ldd	r25, Z+17	; 0x11
     220:	01 96       	adiw	r24, 0x01	; 1
     222:	91 8b       	std	Z+17, r25	; 0x11
     224:	80 8b       	std	Z+16, r24	; 0x10
#endif
  chVTDoTickI();
     226:	80 91 2f 02 	lds	r24, 0x022F
     22a:	90 91 30 02 	lds	r25, 0x0230
     22e:	01 96       	adiw	r24, 0x01	; 1
     230:	90 93 30 02 	sts	0x0230, r25
     234:	80 93 2f 02 	sts	0x022F, r24
     238:	a0 91 29 02 	lds	r26, 0x0229
     23c:	b0 91 2a 02 	lds	r27, 0x022A
     240:	82 e0       	ldi	r24, 0x02	; 2
     242:	a9 32       	cpi	r26, 0x29	; 41
     244:	b8 07       	cpc	r27, r24
     246:	69 f1       	breq	.+90     	; 0x2a2 <chSysTimerHandlerI+0xa0>
     248:	14 96       	adiw	r26, 0x04	; 4
     24a:	8d 91       	ld	r24, X+
     24c:	9c 91       	ld	r25, X
     24e:	15 97       	sbiw	r26, 0x05	; 5
     250:	01 97       	sbiw	r24, 0x01	; 1
     252:	15 96       	adiw	r26, 0x05	; 5
     254:	9c 93       	st	X, r25
     256:	8e 93       	st	-X, r24
     258:	14 97       	sbiw	r26, 0x04	; 4
     25a:	89 2b       	or	r24, r25
     25c:	11 f5       	brne	.+68     	; 0x2a2 <chSysTimerHandlerI+0xa0>
     25e:	09 e2       	ldi	r16, 0x29	; 41
     260:	12 e0       	ldi	r17, 0x02	; 2
     262:	16 96       	adiw	r26, 0x06	; 6
     264:	ed 91       	ld	r30, X+
     266:	fc 91       	ld	r31, X
     268:	17 97       	sbiw	r26, 0x07	; 7
     26a:	17 96       	adiw	r26, 0x07	; 7
     26c:	1c 92       	st	X, r1
     26e:	1e 92       	st	-X, r1
     270:	16 97       	sbiw	r26, 0x06	; 6
     272:	cd 91       	ld	r28, X+
     274:	dc 91       	ld	r29, X
     276:	11 97       	sbiw	r26, 0x01	; 1
     278:	1b 83       	std	Y+3, r17	; 0x03
     27a:	0a 83       	std	Y+2, r16	; 0x02
     27c:	d0 93 2a 02 	sts	0x022A, r29
     280:	c0 93 29 02 	sts	0x0229, r28
     284:	18 96       	adiw	r26, 0x08	; 8
     286:	8d 91       	ld	r24, X+
     288:	9c 91       	ld	r25, X
     28a:	19 97       	sbiw	r26, 0x09	; 9
     28c:	09 95       	icall
     28e:	a0 91 29 02 	lds	r26, 0x0229
     292:	b0 91 2a 02 	lds	r27, 0x022A
     296:	14 96       	adiw	r26, 0x04	; 4
     298:	8d 91       	ld	r24, X+
     29a:	9c 91       	ld	r25, X
     29c:	15 97       	sbiw	r26, 0x05	; 5
     29e:	89 2b       	or	r24, r25
     2a0:	01 f3       	breq	.-64     	; 0x262 <chSysTimerHandlerI+0x60>
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
     2a2:	df 91       	pop	r29
     2a4:	cf 91       	pop	r28
     2a6:	1f 91       	pop	r17
     2a8:	0f 91       	pop	r16
     2aa:	08 95       	ret

000002ac <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
     2ac:	e9 e2       	ldi	r30, 0x29	; 41
     2ae:	f2 e0       	ldi	r31, 0x02	; 2
     2b0:	f0 93 2c 02 	sts	0x022C, r31
     2b4:	e0 93 2b 02 	sts	0x022B, r30
     2b8:	f1 83       	std	Z+1, r31	; 0x01
     2ba:	e0 83       	st	Z, r30
  vtlist.vt_time = (systime_t)-1;
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	9f ef       	ldi	r25, 0xFF	; 255
     2c0:	90 93 2e 02 	sts	0x022E, r25
     2c4:	80 93 2d 02 	sts	0x022D, r24
  vtlist.vt_systime = 0;
     2c8:	10 92 30 02 	sts	0x0230, r1
     2cc:	10 92 2f 02 	sts	0x022F, r1
     2d0:	08 95       	ret

000002d2 <chVTSetI>:
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
     2d2:	cf 93       	push	r28
     2d4:	df 93       	push	r29
     2d6:	dc 01       	movw	r26, r24

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
     2d8:	19 96       	adiw	r26, 0x09	; 9
     2da:	3c 93       	st	X, r19
     2dc:	2e 93       	st	-X, r18
     2de:	18 97       	sbiw	r26, 0x08	; 8
  vtp->vt_func = vtfunc;
     2e0:	17 96       	adiw	r26, 0x07	; 7
     2e2:	5c 93       	st	X, r21
     2e4:	4e 93       	st	-X, r20
     2e6:	16 97       	sbiw	r26, 0x06	; 6
  p = vtlist.vt_next;
     2e8:	e0 91 29 02 	lds	r30, 0x0229
     2ec:	f0 91 2a 02 	lds	r31, 0x022A
  while (p->vt_time < time) {
     2f0:	24 81       	ldd	r18, Z+4	; 0x04
     2f2:	35 81       	ldd	r19, Z+5	; 0x05
     2f4:	26 17       	cp	r18, r22
     2f6:	37 07       	cpc	r19, r23
     2f8:	50 f4       	brcc	.+20     	; 0x30e <chVTSetI+0x3c>
    time -= p->vt_time;
     2fa:	62 1b       	sub	r22, r18
     2fc:	73 0b       	sbc	r23, r19
    p = p->vt_next;
     2fe:	01 90       	ld	r0, Z+
     300:	f0 81       	ld	r31, Z
     302:	e0 2d       	mov	r30, r0
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
     304:	24 81       	ldd	r18, Z+4	; 0x04
     306:	35 81       	ldd	r19, Z+5	; 0x05
     308:	26 17       	cp	r18, r22
     30a:	37 07       	cpc	r19, r23
     30c:	b0 f3       	brcs	.-20     	; 0x2fa <chVTSetI+0x28>
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
     30e:	11 96       	adiw	r26, 0x01	; 1
     310:	fc 93       	st	X, r31
     312:	ee 93       	st	-X, r30
     314:	c2 81       	ldd	r28, Z+2	; 0x02
     316:	d3 81       	ldd	r29, Z+3	; 0x03
     318:	13 96       	adiw	r26, 0x03	; 3
     31a:	dc 93       	st	X, r29
     31c:	ce 93       	st	-X, r28
     31e:	12 97       	sbiw	r26, 0x02	; 2
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
     320:	b3 83       	std	Z+3, r27	; 0x03
     322:	a2 83       	std	Z+2, r26	; 0x02
     324:	b9 83       	std	Y+1, r27	; 0x01
     326:	a8 83       	st	Y, r26
  vtp->vt_time = time;
     328:	15 96       	adiw	r26, 0x05	; 5
     32a:	7c 93       	st	X, r23
     32c:	6e 93       	st	-X, r22
     32e:	14 97       	sbiw	r26, 0x04	; 4
  if (p != (void *)&vtlist)
     330:	82 e0       	ldi	r24, 0x02	; 2
     332:	e9 32       	cpi	r30, 0x29	; 41
     334:	f8 07       	cpc	r31, r24
     336:	31 f0       	breq	.+12     	; 0x344 <chVTSetI+0x72>
    p->vt_time -= time;
     338:	84 81       	ldd	r24, Z+4	; 0x04
     33a:	95 81       	ldd	r25, Z+5	; 0x05
     33c:	86 1b       	sub	r24, r22
     33e:	97 0b       	sbc	r25, r23
     340:	95 83       	std	Z+5, r25	; 0x05
     342:	84 83       	std	Z+4, r24	; 0x04
}
     344:	df 91       	pop	r29
     346:	cf 91       	pop	r28
     348:	08 95       	ret

0000034a <chVTResetI>:
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
     34a:	cf 93       	push	r28
     34c:	df 93       	push	r29
     34e:	fc 01       	movw	r30, r24
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
     350:	a0 81       	ld	r26, Z
     352:	b1 81       	ldd	r27, Z+1	; 0x01
     354:	82 e0       	ldi	r24, 0x02	; 2
     356:	a9 32       	cpi	r26, 0x29	; 41
     358:	b8 07       	cpc	r27, r24
     35a:	61 f0       	breq	.+24     	; 0x374 <chVTResetI+0x2a>
    vtp->vt_next->vt_time += vtp->vt_time;
     35c:	14 96       	adiw	r26, 0x04	; 4
     35e:	8d 91       	ld	r24, X+
     360:	9c 91       	ld	r25, X
     362:	15 97       	sbiw	r26, 0x05	; 5
     364:	24 81       	ldd	r18, Z+4	; 0x04
     366:	35 81       	ldd	r19, Z+5	; 0x05
     368:	82 0f       	add	r24, r18
     36a:	93 1f       	adc	r25, r19
     36c:	15 96       	adiw	r26, 0x05	; 5
     36e:	9c 93       	st	X, r25
     370:	8e 93       	st	-X, r24
     372:	14 97       	sbiw	r26, 0x04	; 4
  vtp->vt_prev->vt_next = vtp->vt_next;
     374:	c2 81       	ldd	r28, Z+2	; 0x02
     376:	d3 81       	ldd	r29, Z+3	; 0x03
     378:	b9 83       	std	Y+1, r27	; 0x01
     37a:	a8 83       	st	Y, r26
  vtp->vt_next->vt_prev = vtp->vt_prev;
     37c:	a0 81       	ld	r26, Z
     37e:	b1 81       	ldd	r27, Z+1	; 0x01
     380:	13 96       	adiw	r26, 0x03	; 3
     382:	dc 93       	st	X, r29
     384:	ce 93       	st	-X, r28
     386:	12 97       	sbiw	r26, 0x02	; 2
  vtp->vt_func = (vtfunc_t)NULL;
     388:	17 82       	std	Z+7, r1	; 0x07
     38a:	16 82       	std	Z+6, r1	; 0x06
}
     38c:	df 91       	pop	r29
     38e:	cf 91       	pop	r28
     390:	08 95       	ret

00000392 <chTimeIsWithin>:
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
     392:	20 91 2f 02 	lds	r18, 0x022F
     396:	30 91 30 02 	lds	r19, 0x0230
  return end > start ? (time >= start) && (time < end) :
     39a:	86 17       	cp	r24, r22
     39c:	97 07       	cpc	r25, r23
     39e:	50 f4       	brcc	.+20     	; 0x3b4 <chTimeIsWithin+0x22>
     3a0:	28 17       	cp	r18, r24
     3a2:	39 07       	cpc	r19, r25
     3a4:	28 f0       	brcs	.+10     	; 0x3b0 <chTimeIsWithin+0x1e>
                       (time >= start) || (time < end);
     3a6:	81 e0       	ldi	r24, 0x01	; 1
     3a8:	26 17       	cp	r18, r22
     3aa:	37 07       	cpc	r19, r23
     3ac:	08 f4       	brcc	.+2      	; 0x3b0 <chTimeIsWithin+0x1e>
}
     3ae:	08 95       	ret
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {

  systime_t time = chTimeNow();
  return end > start ? (time >= start) && (time < end) :
                       (time >= start) || (time < end);
     3b0:	80 e0       	ldi	r24, 0x00	; 0
     3b2:	08 95       	ret
     3b4:	28 17       	cp	r18, r24
     3b6:	39 07       	cpc	r19, r25
     3b8:	b0 f3       	brcs	.-20     	; 0x3a6 <chTimeIsWithin+0x14>
     3ba:	81 e0       	ldi	r24, 0x01	; 1
}
     3bc:	08 95       	ret

000003be <wakeup>:

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
     3be:	cf 93       	push	r28
     3c0:	df 93       	push	r29
     3c2:	dc 01       	movw	r26, r24
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
  switch (tp->p_state) {
     3c4:	1d 96       	adiw	r26, 0x0d	; 13
     3c6:	8c 91       	ld	r24, X
     3c8:	1d 97       	sbiw	r26, 0x0d	; 13
     3ca:	83 30       	cpi	r24, 0x03	; 3
     3cc:	71 f1       	breq	.+92     	; 0x42a <wakeup+0x6c>
     3ce:	40 f1       	brcs	.+80     	; 0x420 <wakeup+0x62>
     3d0:	85 30       	cpi	r24, 0x05	; 5
     3d2:	91 f1       	breq	.+100    	; 0x438 <wakeup+0x7a>
     3d4:	8d 30       	cpi	r24, 0x0D	; 13
     3d6:	81 f1       	breq	.+96     	; 0x438 <wakeup+0x7a>
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
     3d8:	8f ef       	ldi	r24, 0xFF	; 255
     3da:	9f ef       	ldi	r25, 0xFF	; 255
     3dc:	53 96       	adiw	r26, 0x13	; 19
     3de:	9c 93       	st	X, r25
     3e0:	8e 93       	st	-X, r24
     3e2:	52 97       	sbiw	r26, 0x12	; 18
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     3e4:	1d 96       	adiw	r26, 0x0d	; 13
     3e6:	1c 92       	st	X, r1
     3e8:	1d 97       	sbiw	r26, 0x0d	; 13
     3ea:	14 96       	adiw	r26, 0x04	; 4
     3ec:	9c 91       	ld	r25, X
     3ee:	14 97       	sbiw	r26, 0x04	; 4
  cp = (Thread *)&rlist.r_queue;
     3f0:	e1 e3       	ldi	r30, 0x31	; 49
     3f2:	f2 e0       	ldi	r31, 0x02	; 2
  do {
    cp = cp->p_next;
     3f4:	01 90       	ld	r0, Z+
     3f6:	f0 81       	ld	r31, Z
     3f8:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     3fa:	84 81       	ldd	r24, Z+4	; 0x04
     3fc:	89 17       	cp	r24, r25
     3fe:	d0 f7       	brcc	.-12     	; 0x3f4 <wakeup+0x36>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     400:	11 96       	adiw	r26, 0x01	; 1
     402:	fc 93       	st	X, r31
     404:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     406:	c2 81       	ldd	r28, Z+2	; 0x02
     408:	d3 81       	ldd	r29, Z+3	; 0x03
     40a:	13 96       	adiw	r26, 0x03	; 3
     40c:	dc 93       	st	X, r29
     40e:	ce 93       	st	-X, r28
     410:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     412:	b3 83       	std	Z+3, r27	; 0x03
     414:	a2 83       	std	Z+2, r26	; 0x02
     416:	b9 83       	std	Y+1, r27	; 0x01
     418:	a8 83       	st	Y, r26
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromIsr();
}
     41a:	df 91       	pop	r29
     41c:	cf 91       	pop	r28
     41e:	08 95       	ret
 */
static void wakeup(void *p) {
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
  switch (tp->p_state) {
     420:	81 11       	cpse	r24, r1
     422:	da cf       	rjmp	.-76     	; 0x3d8 <wakeup+0x1a>
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromIsr();
}
     424:	df 91       	pop	r29
     426:	cf 91       	pop	r28
     428:	08 95       	ret
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
     42a:	52 96       	adiw	r26, 0x12	; 18
     42c:	ed 91       	ld	r30, X+
     42e:	fc 91       	ld	r31, X
     430:	53 97       	sbiw	r26, 0x13	; 19
     432:	84 81       	ldd	r24, Z+4	; 0x04
     434:	8f 5f       	subi	r24, 0xFF	; 255
     436:	84 83       	std	Z+4, r24	; 0x04
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     438:	12 96       	adiw	r26, 0x02	; 2
     43a:	ed 91       	ld	r30, X+
     43c:	fc 91       	ld	r31, X
     43e:	13 97       	sbiw	r26, 0x03	; 3
     440:	8d 91       	ld	r24, X+
     442:	9c 91       	ld	r25, X
     444:	11 97       	sbiw	r26, 0x01	; 1
     446:	91 83       	std	Z+1, r25	; 0x01
     448:	80 83       	st	Z, r24
  tp->p_next->p_prev = tp->p_prev;
     44a:	cd 91       	ld	r28, X+
     44c:	dc 91       	ld	r29, X
     44e:	11 97       	sbiw	r26, 0x01	; 1
     450:	fb 83       	std	Y+3, r31	; 0x03
     452:	ea 83       	std	Y+2, r30	; 0x02
     454:	c1 cf       	rjmp	.-126    	; 0x3d8 <wakeup+0x1a>

00000456 <_scheduler_init>:
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
     456:	e1 e3       	ldi	r30, 0x31	; 49
     458:	f2 e0       	ldi	r31, 0x02	; 2
     45a:	f0 93 34 02 	sts	0x0234, r31
     45e:	e0 93 33 02 	sts	0x0233, r30
     462:	f1 83       	std	Z+1, r31	; 0x01
     464:	e0 83       	st	Z, r30
  rlist.r_prio = NOPRIO;
     466:	10 92 35 02 	sts	0x0235, r1
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
     46a:	f0 93 3b 02 	sts	0x023B, r31
     46e:	e0 93 3a 02 	sts	0x023A, r30
     472:	f0 93 39 02 	sts	0x0239, r31
     476:	e0 93 38 02 	sts	0x0238, r30
     47a:	08 95       	ret

0000047c <chSchReadyI>:
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
     47c:	cf 93       	push	r28
     47e:	df 93       	push	r29
     480:	dc 01       	movw	r26, r24
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     482:	1d 96       	adiw	r26, 0x0d	; 13
     484:	1c 92       	st	X, r1
     486:	1d 97       	sbiw	r26, 0x0d	; 13
     488:	14 96       	adiw	r26, 0x04	; 4
     48a:	9c 91       	ld	r25, X
     48c:	14 97       	sbiw	r26, 0x04	; 4
  cp = (Thread *)&rlist.r_queue;
     48e:	e1 e3       	ldi	r30, 0x31	; 49
     490:	f2 e0       	ldi	r31, 0x02	; 2
  do {
    cp = cp->p_next;
     492:	01 90       	ld	r0, Z+
     494:	f0 81       	ld	r31, Z
     496:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     498:	84 81       	ldd	r24, Z+4	; 0x04
     49a:	89 17       	cp	r24, r25
     49c:	d0 f7       	brcc	.-12     	; 0x492 <chSchReadyI+0x16>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     49e:	11 96       	adiw	r26, 0x01	; 1
     4a0:	fc 93       	st	X, r31
     4a2:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     4a4:	c2 81       	ldd	r28, Z+2	; 0x02
     4a6:	d3 81       	ldd	r29, Z+3	; 0x03
     4a8:	13 96       	adiw	r26, 0x03	; 3
     4aa:	dc 93       	st	X, r29
     4ac:	ce 93       	st	-X, r28
     4ae:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     4b0:	b3 83       	std	Z+3, r27	; 0x03
     4b2:	a2 83       	std	Z+2, r26	; 0x02
     4b4:	b9 83       	std	Y+1, r27	; 0x01
     4b6:	a8 83       	st	Y, r26
  return tp;
}
     4b8:	cd 01       	movw	r24, r26
     4ba:	df 91       	pop	r29
     4bc:	cf 91       	pop	r28
     4be:	08 95       	ret

000004c0 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
     4c0:	cf 93       	push	r28
     4c2:	df 93       	push	r29
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
     4c4:	2c e3       	ldi	r18, 0x3C	; 60
     4c6:	32 e0       	ldi	r19, 0x02	; 2
     4c8:	d9 01       	movw	r26, r18
     4ca:	6d 91       	ld	r22, X+
     4cc:	7c 91       	ld	r23, X
     4ce:	fb 01       	movw	r30, r22
     4d0:	85 87       	std	Z+13, r24	; 0x0d
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
     4d2:	84 e1       	ldi	r24, 0x14	; 20
     4d4:	87 87       	std	Z+15, r24	; 0x0f
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     4d6:	e1 e3       	ldi	r30, 0x31	; 49
     4d8:	f2 e0       	ldi	r31, 0x02	; 2
     4da:	80 81       	ld	r24, Z
     4dc:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     4de:	dc 01       	movw	r26, r24
     4e0:	cd 91       	ld	r28, X+
     4e2:	dc 91       	ld	r29, X
     4e4:	11 97       	sbiw	r26, 0x01	; 1
     4e6:	d1 83       	std	Z+1, r29	; 0x01
     4e8:	c0 83       	st	Z, r28
     4ea:	fb 83       	std	Y+3, r31	; 0x03
     4ec:	ea 83       	std	Y+2, r30	; 0x02
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
     4ee:	f9 01       	movw	r30, r18
     4f0:	91 83       	std	Z+1, r25	; 0x01
     4f2:	80 83       	st	Z, r24
  currp->p_state = THD_STATE_CURRENT;
     4f4:	21 e0       	ldi	r18, 0x01	; 1
     4f6:	1d 96       	adiw	r26, 0x0d	; 13
     4f8:	2c 93       	st	X, r18
  chSysSwitch(currp, otp);
}
     4fa:	df 91       	pop	r29
     4fc:	cf 91       	pop	r28
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
  chSysSwitch(currp, otp);
     4fe:	0c 94 97 00 	jmp	0x12e	; 0x12e <port_switch>

00000502 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
     502:	1f 93       	push	r17
     504:	cf 93       	push	r28
     506:	df 93       	push	r29
     508:	cd b7       	in	r28, 0x3d	; 61
     50a:	de b7       	in	r29, 0x3e	; 62
     50c:	2a 97       	sbiw	r28, 0x0a	; 10
     50e:	0f b6       	in	r0, 0x3f	; 63
     510:	f8 94       	cli
     512:	de bf       	out	0x3e, r29	; 62
     514:	0f be       	out	0x3f, r0	; 63
     516:	cd bf       	out	0x3d, r28	; 61
     518:	18 2f       	mov	r17, r24

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
     51a:	6f 3f       	cpi	r22, 0xFF	; 255
     51c:	8f ef       	ldi	r24, 0xFF	; 255
     51e:	78 07       	cpc	r23, r24
     520:	29 f1       	breq	.+74     	; 0x56c <chSchGoSleepTimeoutS+0x6a>
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
     522:	20 91 3c 02 	lds	r18, 0x023C
     526:	30 91 3d 02 	lds	r19, 0x023D
     52a:	4f ed       	ldi	r20, 0xDF	; 223
     52c:	51 e0       	ldi	r21, 0x01	; 1
     52e:	ce 01       	movw	r24, r28
     530:	01 96       	adiw	r24, 0x01	; 1
     532:	0e 94 69 01 	call	0x2d2	; 0x2d2 <chVTSetI>
    chSchGoSleepS(newstate);
     536:	81 2f       	mov	r24, r17
     538:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
     53c:	8f 81       	ldd	r24, Y+7	; 0x07
     53e:	98 85       	ldd	r25, Y+8	; 0x08
     540:	89 2b       	or	r24, r25
     542:	21 f0       	breq	.+8      	; 0x54c <chSchGoSleepTimeoutS+0x4a>
      chVTResetI(&vt);
     544:	ce 01       	movw	r24, r28
     546:	01 96       	adiw	r24, 0x01	; 1
     548:	0e 94 a5 01 	call	0x34a	; 0x34a <chVTResetI>
  }
  else
    chSchGoSleepS(newstate);
  return currp->p_u.rdymsg;
     54c:	e0 91 3c 02 	lds	r30, 0x023C
     550:	f0 91 3d 02 	lds	r31, 0x023D
}
     554:	82 89       	ldd	r24, Z+18	; 0x12
     556:	93 89       	ldd	r25, Z+19	; 0x13
     558:	2a 96       	adiw	r28, 0x0a	; 10
     55a:	0f b6       	in	r0, 0x3f	; 63
     55c:	f8 94       	cli
     55e:	de bf       	out	0x3e, r29	; 62
     560:	0f be       	out	0x3f, r0	; 63
     562:	cd bf       	out	0x3d, r28	; 61
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	08 95       	ret
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt))
      chVTResetI(&vt);
  }
  else
    chSchGoSleepS(newstate);
     56c:	81 2f       	mov	r24, r17
     56e:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
     572:	ec cf       	rjmp	.-40     	; 0x54c <chSchGoSleepTimeoutS+0x4a>

00000574 <chSchWakeupS>:
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
     574:	cf 93       	push	r28
     576:	df 93       	push	r29
     578:	dc 01       	movw	r26, r24

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
     57a:	53 96       	adiw	r26, 0x13	; 19
     57c:	7c 93       	st	X, r23
     57e:	6e 93       	st	-X, r22
     580:	52 97       	sbiw	r26, 0x12	; 18
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
     582:	14 96       	adiw	r26, 0x04	; 4
     584:	2c 91       	ld	r18, X
     586:	14 97       	sbiw	r26, 0x04	; 4
     588:	c0 91 3c 02 	lds	r28, 0x023C
     58c:	d0 91 3d 02 	lds	r29, 0x023D
     590:	9c 81       	ldd	r25, Y+4	; 0x04
     592:	92 17       	cp	r25, r18
     594:	d8 f0       	brcs	.+54     	; 0x5cc <chSchWakeupS+0x58>
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     596:	1d 96       	adiw	r26, 0x0d	; 13
     598:	1c 92       	st	X, r1
     59a:	1d 97       	sbiw	r26, 0x0d	; 13
  cp = (Thread *)&rlist.r_queue;
     59c:	e1 e3       	ldi	r30, 0x31	; 49
     59e:	f2 e0       	ldi	r31, 0x02	; 2
  do {
    cp = cp->p_next;
     5a0:	01 90       	ld	r0, Z+
     5a2:	f0 81       	ld	r31, Z
     5a4:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     5a6:	84 81       	ldd	r24, Z+4	; 0x04
     5a8:	82 17       	cp	r24, r18
     5aa:	d0 f7       	brcc	.-12     	; 0x5a0 <chSchWakeupS+0x2c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     5ac:	11 96       	adiw	r26, 0x01	; 1
     5ae:	fc 93       	st	X, r31
     5b0:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     5b2:	c2 81       	ldd	r28, Z+2	; 0x02
     5b4:	d3 81       	ldd	r29, Z+3	; 0x03
     5b6:	13 96       	adiw	r26, 0x03	; 3
     5b8:	dc 93       	st	X, r29
     5ba:	ce 93       	st	-X, r28
     5bc:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     5be:	b3 83       	std	Z+3, r27	; 0x03
     5c0:	a2 83       	std	Z+2, r26	; 0x02
     5c2:	b9 83       	std	Y+1, r27	; 0x01
     5c4:	a8 83       	st	Y, r26
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
     5c6:	df 91       	pop	r29
     5c8:	cf 91       	pop	r28
     5ca:	08 95       	ret
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     5cc:	1d 86       	std	Y+13, r1	; 0x0d
  cp = (Thread *)&rlist.r_queue;
     5ce:	e1 e3       	ldi	r30, 0x31	; 49
     5d0:	f2 e0       	ldi	r31, 0x02	; 2
  do {
    cp = cp->p_next;
     5d2:	01 90       	ld	r0, Z+
     5d4:	f0 81       	ld	r31, Z
     5d6:	e0 2d       	mov	r30, r0
  } while (cp->p_prio >= tp->p_prio);
     5d8:	84 81       	ldd	r24, Z+4	; 0x04
     5da:	89 17       	cp	r24, r25
     5dc:	d0 f7       	brcc	.-12     	; 0x5d2 <chSchWakeupS+0x5e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     5de:	f9 83       	std	Y+1, r31	; 0x01
     5e0:	e8 83       	st	Y, r30
  tp->p_prev = cp->p_prev;
     5e2:	82 81       	ldd	r24, Z+2	; 0x02
     5e4:	93 81       	ldd	r25, Z+3	; 0x03
     5e6:	9b 83       	std	Y+3, r25	; 0x03
     5e8:	8a 83       	std	Y+2, r24	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     5ea:	d3 83       	std	Z+3, r29	; 0x03
     5ec:	c2 83       	std	Z+2, r28	; 0x02
     5ee:	fc 01       	movw	r30, r24
     5f0:	d1 83       	std	Z+1, r29	; 0x01
     5f2:	c0 83       	st	Z, r28
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
     5f4:	b0 93 3d 02 	sts	0x023D, r27
     5f8:	a0 93 3c 02 	sts	0x023C, r26
    ntp->p_state = THD_STATE_CURRENT;
     5fc:	81 e0       	ldi	r24, 0x01	; 1
     5fe:	1d 96       	adiw	r26, 0x0d	; 13
     600:	8c 93       	st	X, r24
     602:	1d 97       	sbiw	r26, 0x0d	; 13
    chSysSwitch(ntp, otp);
     604:	be 01       	movw	r22, r28
     606:	cd 01       	movw	r24, r26
  }
}
     608:	df 91       	pop	r29
     60a:	cf 91       	pop	r28
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
     60c:	0c 94 97 00 	jmp	0x12e	; 0x12e <port_switch>

00000610 <chSchIsPreemptionRequired>:
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_ISPREEMPTIONREQUIRED) || defined(__DOXYGEN__)
bool_t chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&rlist.r_queue);
     610:	e0 91 31 02 	lds	r30, 0x0231
     614:	f0 91 32 02 	lds	r31, 0x0232
     618:	24 81       	ldd	r18, Z+4	; 0x04
  tprio_t p2 = currp->p_prio;
     61a:	e0 91 3c 02 	lds	r30, 0x023C
     61e:	f0 91 3d 02 	lds	r31, 0x023D
     622:	94 81       	ldd	r25, Z+4	; 0x04
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
     624:	87 85       	ldd	r24, Z+15	; 0x0f
     626:	81 11       	cpse	r24, r1
     628:	04 c0       	rjmp	.+8      	; 0x632 <chSchIsPreemptionRequired+0x22>
     62a:	81 e0       	ldi	r24, 0x01	; 1
     62c:	29 17       	cp	r18, r25
     62e:	20 f0       	brcs	.+8      	; 0x638 <chSchIsPreemptionRequired+0x28>
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
     630:	08 95       	ret
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
     632:	81 e0       	ldi	r24, 0x01	; 1
     634:	92 17       	cp	r25, r18
     636:	e0 f3       	brcs	.-8      	; 0x630 <chSchIsPreemptionRequired+0x20>
     638:	80 e0       	ldi	r24, 0x00	; 0
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
     63a:	08 95       	ret

0000063c <chSchDoRescheduleBehind>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
  Thread *otp;

  otp = currp;
     640:	a0 91 3c 02 	lds	r26, 0x023C
     644:	b0 91 3d 02 	lds	r27, 0x023D
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     648:	80 91 31 02 	lds	r24, 0x0231
     64c:	90 91 32 02 	lds	r25, 0x0232

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     650:	ec 01       	movw	r28, r24
     652:	e8 81       	ld	r30, Y
     654:	f9 81       	ldd	r31, Y+1	; 0x01
     656:	f0 93 32 02 	sts	0x0232, r31
     65a:	e0 93 31 02 	sts	0x0231, r30
     65e:	21 e3       	ldi	r18, 0x31	; 49
     660:	32 e0       	ldi	r19, 0x02	; 2
     662:	33 83       	std	Z+3, r19	; 0x03
     664:	22 83       	std	Z+2, r18	; 0x02
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
     666:	90 93 3d 02 	sts	0x023D, r25
     66a:	80 93 3c 02 	sts	0x023C, r24
  currp->p_state = THD_STATE_CURRENT;
     66e:	21 e0       	ldi	r18, 0x01	; 1
     670:	2d 87       	std	Y+13, r18	; 0x0d
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
     672:	24 e1       	ldi	r18, 0x14	; 20
     674:	1f 96       	adiw	r26, 0x0f	; 15
     676:	2c 93       	st	X, r18
     678:	1f 97       	sbiw	r26, 0x0f	; 15
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
     67a:	1d 96       	adiw	r26, 0x0d	; 13
     67c:	1c 92       	st	X, r1
     67e:	1d 97       	sbiw	r26, 0x0d	; 13
     680:	14 96       	adiw	r26, 0x04	; 4
     682:	3c 91       	ld	r19, X
     684:	14 97       	sbiw	r26, 0x04	; 4
     686:	fc 01       	movw	r30, r24
     688:	03 c0       	rjmp	.+6      	; 0x690 <chSchDoRescheduleBehind+0x54>
     68a:	01 90       	ld	r0, Z+
     68c:	f0 81       	ld	r31, Z
     68e:	e0 2d       	mov	r30, r0
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
     690:	24 81       	ldd	r18, Z+4	; 0x04
     692:	23 17       	cp	r18, r19
     694:	d0 f7       	brcc	.-12     	; 0x68a <chSchDoRescheduleBehind+0x4e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     696:	11 96       	adiw	r26, 0x01	; 1
     698:	fc 93       	st	X, r31
     69a:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
     69c:	c2 81       	ldd	r28, Z+2	; 0x02
     69e:	d3 81       	ldd	r29, Z+3	; 0x03
     6a0:	13 96       	adiw	r26, 0x03	; 3
     6a2:	dc 93       	st	X, r29
     6a4:	ce 93       	st	-X, r28
     6a6:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
     6a8:	b3 83       	std	Z+3, r27	; 0x03
     6aa:	a2 83       	std	Z+2, r26	; 0x02
     6ac:	b9 83       	std	Y+1, r27	; 0x01
     6ae:	a8 83       	st	Y, r26
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
     6b0:	bd 01       	movw	r22, r26
}
     6b2:	df 91       	pop	r29
     6b4:	cf 91       	pop	r28
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
     6b6:	0c 94 97 00 	jmp	0x12e	; 0x12e <port_switch>

000006ba <chSchDoRescheduleAhead>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
     6ba:	cf 93       	push	r28
     6bc:	df 93       	push	r29
  Thread *otp, *cp;

  otp = currp;
     6be:	a0 91 3c 02 	lds	r26, 0x023C
     6c2:	b0 91 3d 02 	lds	r27, 0x023D
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     6c6:	80 91 31 02 	lds	r24, 0x0231
     6ca:	90 91 32 02 	lds	r25, 0x0232

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     6ce:	ec 01       	movw	r28, r24
     6d0:	e8 81       	ld	r30, Y
     6d2:	f9 81       	ldd	r31, Y+1	; 0x01
     6d4:	f0 93 32 02 	sts	0x0232, r31
     6d8:	e0 93 31 02 	sts	0x0231, r30
     6dc:	21 e3       	ldi	r18, 0x31	; 49
     6de:	32 e0       	ldi	r19, 0x02	; 2
     6e0:	33 83       	std	Z+3, r19	; 0x03
     6e2:	22 83       	std	Z+2, r18	; 0x02
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
     6e4:	90 93 3d 02 	sts	0x023D, r25
     6e8:	80 93 3c 02 	sts	0x023C, r24
  currp->p_state = THD_STATE_CURRENT;
     6ec:	21 e0       	ldi	r18, 0x01	; 1
     6ee:	2d 87       	std	Y+13, r18	; 0x0d

  otp->p_state = THD_STATE_READY;
     6f0:	1d 96       	adiw	r26, 0x0d	; 13
     6f2:	1c 92       	st	X, r1
     6f4:	1d 97       	sbiw	r26, 0x0d	; 13
     6f6:	14 96       	adiw	r26, 0x04	; 4
     6f8:	3c 91       	ld	r19, X
     6fa:	14 97       	sbiw	r26, 0x04	; 4
     6fc:	fc 01       	movw	r30, r24
     6fe:	03 c0       	rjmp	.+6      	; 0x706 <chSchDoRescheduleAhead+0x4c>
     700:	01 90       	ld	r0, Z+
     702:	f0 81       	ld	r31, Z
     704:	e0 2d       	mov	r30, r0
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
     706:	24 81       	ldd	r18, Z+4	; 0x04
     708:	32 17       	cp	r19, r18
     70a:	d0 f3       	brcs	.-12     	; 0x700 <chSchDoRescheduleAhead+0x46>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
     70c:	11 96       	adiw	r26, 0x01	; 1
     70e:	fc 93       	st	X, r31
     710:	ee 93       	st	-X, r30
  otp->p_prev = cp->p_prev;
     712:	c2 81       	ldd	r28, Z+2	; 0x02
     714:	d3 81       	ldd	r29, Z+3	; 0x03
     716:	13 96       	adiw	r26, 0x03	; 3
     718:	dc 93       	st	X, r29
     71a:	ce 93       	st	-X, r28
     71c:	12 97       	sbiw	r26, 0x02	; 2
  otp->p_prev->p_next = cp->p_prev = otp;
     71e:	b3 83       	std	Z+3, r27	; 0x03
     720:	a2 83       	std	Z+2, r26	; 0x02
     722:	b9 83       	std	Y+1, r27	; 0x01
     724:	a8 83       	st	Y, r26

  chSysSwitch(currp, otp);
     726:	bd 01       	movw	r22, r26
}
     728:	df 91       	pop	r29
     72a:	cf 91       	pop	r28
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
     72c:	0c 94 97 00 	jmp	0x12e	; 0x12e <port_switch>

00000730 <chSchRescheduleS>:
#if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI())
     730:	a0 91 31 02 	lds	r26, 0x0231
     734:	b0 91 32 02 	lds	r27, 0x0232
     738:	e0 91 3c 02 	lds	r30, 0x023C
     73c:	f0 91 3d 02 	lds	r31, 0x023D
     740:	14 96       	adiw	r26, 0x04	; 4
     742:	9c 91       	ld	r25, X
     744:	84 81       	ldd	r24, Z+4	; 0x04
     746:	89 17       	cp	r24, r25
     748:	08 f0       	brcs	.+2      	; 0x74c <chSchRescheduleS+0x1c>
     74a:	08 95       	ret
    chSchDoRescheduleAhead();
     74c:	0c 94 5d 03 	jmp	0x6ba	; 0x6ba <chSchDoRescheduleAhead>

00000750 <chSchDoReschedule>:
void chSchDoReschedule(void) {

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
     750:	e0 91 3c 02 	lds	r30, 0x023C
     754:	f0 91 3d 02 	lds	r31, 0x023D
     758:	87 85       	ldd	r24, Z+15	; 0x0f
     75a:	81 11       	cpse	r24, r1
    chSchDoRescheduleBehind();
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
     75c:	0c 94 5d 03 	jmp	0x6ba	; 0x6ba <chSchDoRescheduleAhead>
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
     760:	0c 94 1e 03 	jmp	0x63c	; 0x63c <chSchDoRescheduleBehind>

00000764 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {
     764:	cf 93       	push	r28
     766:	df 93       	push	r29
     768:	fc 01       	movw	r30, r24

  tp->p_prio = prio;
     76a:	64 83       	std	Z+4, r22	; 0x04
  tp->p_state = THD_STATE_SUSPENDED;
     76c:	82 e0       	ldi	r24, 0x02	; 2
     76e:	85 87       	std	Z+13, r24	; 0x0d
  tp->p_flags = THD_MEM_MODE_STATIC;
     770:	16 86       	std	Z+14, r1	; 0x0e
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
     772:	84 e1       	ldi	r24, 0x14	; 20
     774:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
     776:	67 8f       	std	Z+31, r22	; 0x1f
  tp->p_mtxlist = NULL;
     778:	16 8e       	std	Z+30, r1	; 0x1e
     77a:	15 8e       	std	Z+29, r1	; 0x1d
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
     77c:	14 8e       	std	Z+28, r1	; 0x1c
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
     77e:	11 8a       	std	Z+17, r1	; 0x11
     780:	10 8a       	std	Z+16, r1	; 0x10
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
     782:	14 86       	std	Z+12, r1	; 0x0c
     784:	13 86       	std	Z+11, r1	; 0x0b
  REG_INSERT(tp);
     786:	81 e3       	ldi	r24, 0x31	; 49
     788:	92 e0       	ldi	r25, 0x02	; 2
     78a:	90 87       	std	Z+8, r25	; 0x08
     78c:	87 83       	std	Z+7, r24	; 0x07
     78e:	ca e3       	ldi	r28, 0x3A	; 58
     790:	d2 e0       	ldi	r29, 0x02	; 2
     792:	a8 81       	ld	r26, Y
     794:	b9 81       	ldd	r27, Y+1	; 0x01
     796:	b2 87       	std	Z+10, r27	; 0x0a
     798:	a1 87       	std	Z+9, r26	; 0x09
     79a:	f9 83       	std	Y+1, r31	; 0x01
     79c:	e8 83       	st	Y, r30
     79e:	18 96       	adiw	r26, 0x08	; 8
     7a0:	fc 93       	st	X, r31
     7a2:	ee 93       	st	-X, r30
     7a4:	17 97       	sbiw	r26, 0x07	; 7
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
     7a6:	cf 01       	movw	r24, r30
     7a8:	44 96       	adiw	r24, 0x14	; 20
     7aa:	95 8b       	std	Z+21, r25	; 0x15
     7ac:	84 8b       	std	Z+20, r24	; 0x14
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
     7ae:	cf 01       	movw	r24, r30
     7b0:	46 96       	adiw	r24, 0x16	; 22
     7b2:	91 8f       	std	Z+25, r25	; 0x19
     7b4:	80 8f       	std	Z+24, r24	; 0x18
     7b6:	97 8b       	std	Z+23, r25	; 0x17
     7b8:	86 8b       	std	Z+22, r24	; 0x16
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
}
     7ba:	cf 01       	movw	r24, r30
     7bc:	df 91       	pop	r29
     7be:	cf 91       	pop	r28
     7c0:	08 95       	ret

000007c2 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
     7c2:	0f 93       	push	r16
     7c4:	1f 93       	push	r17
     7c6:	cf 93       	push	r28
     7c8:	df 93       	push	r29
     7ca:	fc 01       	movw	r30, r24
  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
     7cc:	65 51       	subi	r22, 0x15	; 21
     7ce:	71 09       	sbc	r23, r1
     7d0:	68 0f       	add	r22, r24
     7d2:	79 1f       	adc	r23, r25
     7d4:	76 83       	std	Z+6, r23	; 0x06
     7d6:	65 83       	std	Z+5, r22	; 0x05
     7d8:	db 01       	movw	r26, r22
     7da:	52 96       	adiw	r26, 0x12	; 18
     7dc:	2c 93       	st	X, r18
     7de:	a5 81       	ldd	r26, Z+5	; 0x05
     7e0:	b6 81       	ldd	r27, Z+6	; 0x06
     7e2:	51 96       	adiw	r26, 0x11	; 17
     7e4:	3c 93       	st	X, r19
     7e6:	a5 81       	ldd	r26, Z+5	; 0x05
     7e8:	b6 81       	ldd	r27, Z+6	; 0x06
     7ea:	50 96       	adiw	r26, 0x10	; 16
     7ec:	0c 93       	st	X, r16
     7ee:	a5 81       	ldd	r26, Z+5	; 0x05
     7f0:	b6 81       	ldd	r27, Z+6	; 0x06
     7f2:	1f 96       	adiw	r26, 0x0f	; 15
     7f4:	1c 93       	st	X, r17
     7f6:	a5 81       	ldd	r26, Z+5	; 0x05
     7f8:	b6 81       	ldd	r27, Z+6	; 0x06
     7fa:	88 ec       	ldi	r24, 0xC8	; 200
     7fc:	90 e0       	ldi	r25, 0x00	; 0
     7fe:	53 96       	adiw	r26, 0x13	; 19
     800:	9c 93       	st	X, r25
     802:	a5 81       	ldd	r26, Z+5	; 0x05
     804:	b6 81       	ldd	r27, Z+6	; 0x06
     806:	54 96       	adiw	r26, 0x14	; 20
     808:	8c 93       	st	X, r24
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
     80a:	44 83       	std	Z+4, r20	; 0x04
  tp->p_state = THD_STATE_SUSPENDED;
     80c:	82 e0       	ldi	r24, 0x02	; 2
     80e:	85 87       	std	Z+13, r24	; 0x0d
  tp->p_flags = THD_MEM_MODE_STATIC;
     810:	16 86       	std	Z+14, r1	; 0x0e
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
     812:	84 e1       	ldi	r24, 0x14	; 20
     814:	87 87       	std	Z+15, r24	; 0x0f
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
     816:	47 8f       	std	Z+31, r20	; 0x1f
  tp->p_mtxlist = NULL;
     818:	16 8e       	std	Z+30, r1	; 0x1e
     81a:	15 8e       	std	Z+29, r1	; 0x1d
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
     81c:	14 8e       	std	Z+28, r1	; 0x1c
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
     81e:	11 8a       	std	Z+17, r1	; 0x11
     820:	10 8a       	std	Z+16, r1	; 0x10
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
     822:	14 86       	std	Z+12, r1	; 0x0c
     824:	13 86       	std	Z+11, r1	; 0x0b
  REG_INSERT(tp);
     826:	81 e3       	ldi	r24, 0x31	; 49
     828:	92 e0       	ldi	r25, 0x02	; 2
     82a:	90 87       	std	Z+8, r25	; 0x08
     82c:	87 83       	std	Z+7, r24	; 0x07
     82e:	ca e3       	ldi	r28, 0x3A	; 58
     830:	d2 e0       	ldi	r29, 0x02	; 2
     832:	a8 81       	ld	r26, Y
     834:	b9 81       	ldd	r27, Y+1	; 0x01
     836:	b2 87       	std	Z+10, r27	; 0x0a
     838:	a1 87       	std	Z+9, r26	; 0x09
     83a:	f9 83       	std	Y+1, r31	; 0x01
     83c:	e8 83       	st	Y, r30
     83e:	18 96       	adiw	r26, 0x08	; 8
     840:	fc 93       	st	X, r31
     842:	ee 93       	st	-X, r30
     844:	17 97       	sbiw	r26, 0x07	; 7
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
     846:	cf 01       	movw	r24, r30
     848:	44 96       	adiw	r24, 0x14	; 20
     84a:	95 8b       	std	Z+21, r25	; 0x15
     84c:	84 8b       	std	Z+20, r24	; 0x14
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
     84e:	cf 01       	movw	r24, r30
     850:	46 96       	adiw	r24, 0x16	; 22
     852:	91 8f       	std	Z+25, r25	; 0x19
     854:	80 8f       	std	Z+24, r24	; 0x18
     856:	97 8b       	std	Z+23, r25	; 0x17
     858:	86 8b       	std	Z+22, r24	; 0x16
  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
  return _thread_init(tp, prio);
}
     85a:	cf 01       	movw	r24, r30
     85c:	df 91       	pop	r29
     85e:	cf 91       	pop	r28
     860:	1f 91       	pop	r17
     862:	0f 91       	pop	r16
     864:	08 95       	ret

00000866 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
     866:	0f 93       	push	r16
     868:	1f 93       	push	r17
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
     86a:	f8 94       	cli
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
     86c:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <chThdCreateI>
     870:	8c 01       	movw	r16, r24
     872:	60 e0       	ldi	r22, 0x00	; 0
     874:	70 e0       	ldi	r23, 0x00	; 0
     876:	0e 94 ba 02 	call	0x574	; 0x574 <chSchWakeupS>
  chSysUnlock();
     87a:	78 94       	sei
  return tp;
}
     87c:	c8 01       	movw	r24, r16
     87e:	1f 91       	pop	r17
     880:	0f 91       	pop	r16
     882:	08 95       	ret

00000884 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
     884:	cf 93       	push	r28
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");

  chSysLock();
     886:	f8 94       	cli
#if CH_USE_MUTEXES
  oldprio = currp->p_realprio;
     888:	e0 91 3c 02 	lds	r30, 0x023C
     88c:	f0 91 3d 02 	lds	r31, 0x023D
     890:	c7 8d       	ldd	r28, Z+31	; 0x1f
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
     892:	94 81       	ldd	r25, Z+4	; 0x04
     894:	c9 17       	cp	r28, r25
     896:	11 f0       	breq	.+4      	; 0x89c <chThdSetPriority+0x18>
     898:	98 17       	cp	r25, r24
     89a:	08 f4       	brcc	.+2      	; 0x89e <chThdSetPriority+0x1a>
    currp->p_prio = newprio;
     89c:	84 83       	std	Z+4, r24	; 0x04
  currp->p_realprio = newprio;
     89e:	87 8f       	std	Z+31, r24	; 0x1f
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
     8a0:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  chSysUnlock();
     8a4:	78 94       	sei
  return oldprio;
}
     8a6:	8c 2f       	mov	r24, r28
     8a8:	cf 91       	pop	r28
     8aa:	08 95       	ret

000008ac <chThdResume>:
 * @param[in] tp        pointer to the thread
 * @return              The pointer to the thread.
 *
 * @api
 */
Thread *chThdResume(Thread *tp) {
     8ac:	cf 93       	push	r28
     8ae:	df 93       	push	r29
     8b0:	d8 2f       	mov	r29, r24
     8b2:	c9 2f       	mov	r28, r25

  chSysLock();
     8b4:	f8 94       	cli
  chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
              "chThdResume(), #1",
              "thread not in THD_STATE_SUSPENDED state");
  chSchWakeupS(tp, RDY_OK);
     8b6:	60 e0       	ldi	r22, 0x00	; 0
     8b8:	70 e0       	ldi	r23, 0x00	; 0
     8ba:	0e 94 ba 02 	call	0x574	; 0x574 <chSchWakeupS>
  chSysUnlock();
     8be:	78 94       	sei
  return tp;
}
     8c0:	8d 2f       	mov	r24, r29
     8c2:	9c 2f       	mov	r25, r28
     8c4:	df 91       	pop	r29
     8c6:	cf 91       	pop	r28
     8c8:	08 95       	ret

000008ca <chThdTerminate>:
 *
 * @api
 */
void chThdTerminate(Thread *tp) {

  chSysLock();
     8ca:	f8 94       	cli
  tp->p_flags |= THD_TERMINATE;
     8cc:	fc 01       	movw	r30, r24
     8ce:	26 85       	ldd	r18, Z+14	; 0x0e
     8d0:	24 60       	ori	r18, 0x04	; 4
     8d2:	26 87       	std	Z+14, r18	; 0x0e
  chSysUnlock();
     8d4:	78 94       	sei
     8d6:	08 95       	ret

000008d8 <chThdSleep>:
 */
void chThdSleep(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
     8d8:	f8 94       	cli
  chThdSleepS(time);
     8da:	bc 01       	movw	r22, r24
     8dc:	86 e0       	ldi	r24, 0x06	; 6
     8de:	0e 94 81 02 	call	0x502	; 0x502 <chSchGoSleepTimeoutS>
  chSysUnlock();
     8e2:	78 94       	sei
     8e4:	08 95       	ret

000008e6 <chThdSleepUntil>:
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
     8e6:	f8 94       	cli
  if ((time -= chTimeNow()) > 0)
     8e8:	20 91 2f 02 	lds	r18, 0x022F
     8ec:	30 91 30 02 	lds	r19, 0x0230
     8f0:	82 1b       	sub	r24, r18
     8f2:	93 0b       	sbc	r25, r19
     8f4:	21 f0       	breq	.+8      	; 0x8fe <chThdSleepUntil+0x18>
    chThdSleepS(time);
     8f6:	bc 01       	movw	r22, r24
     8f8:	86 e0       	ldi	r24, 0x06	; 6
     8fa:	0e 94 81 02 	call	0x502	; 0x502 <chSchGoSleepTimeoutS>
  chSysUnlock();
     8fe:	78 94       	sei
     900:	08 95       	ret

00000902 <chThdYield>:
 *
 * @api
 */
void chThdYield(void) {

  chSysLock();
     902:	f8 94       	cli
  chSchDoYieldS();
     904:	a0 91 31 02 	lds	r26, 0x0231
     908:	b0 91 32 02 	lds	r27, 0x0232
     90c:	e0 91 3c 02 	lds	r30, 0x023C
     910:	f0 91 3d 02 	lds	r31, 0x023D
     914:	14 96       	adiw	r26, 0x04	; 4
     916:	9c 91       	ld	r25, X
     918:	84 81       	ldd	r24, Z+4	; 0x04
     91a:	98 17       	cp	r25, r24
     91c:	10 f0       	brcs	.+4      	; 0x922 <chThdYield+0x20>
     91e:	0e 94 1e 03 	call	0x63c	; 0x63c <chSchDoRescheduleBehind>
  chSysUnlock();
     922:	78 94       	sei
     924:	08 95       	ret

00000926 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
     926:	0f 93       	push	r16
     928:	1f 93       	push	r17
     92a:	cf 93       	push	r28
     92c:	df 93       	push	r29
  Thread *tp = currp;
     92e:	c0 91 3c 02 	lds	r28, 0x023C
     932:	d0 91 3d 02 	lds	r29, 0x023D

  tp->p_u.exitcode = msg;
     936:	9b 8b       	std	Y+19, r25	; 0x13
     938:	8a 8b       	std	Y+18, r24	; 0x12
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
     93a:	8c 89       	ldd	r24, Y+20	; 0x14
     93c:	9d 89       	ldd	r25, Y+21	; 0x15
     93e:	8e 01       	movw	r16, r28
     940:	0c 5e       	subi	r16, 0xEC	; 236
     942:	1f 4f       	sbci	r17, 0xFF	; 255
     944:	80 17       	cp	r24, r16
     946:	91 07       	cpc	r25, r17
     948:	61 f0       	breq	.+24     	; 0x962 <chThdExitS+0x3c>
}

static INLINE Thread *list_remove(ThreadsList *tlp) {

  Thread *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
     94a:	fc 01       	movw	r30, r24
     94c:	20 81       	ld	r18, Z
     94e:	31 81       	ldd	r19, Z+1	; 0x01
     950:	3d 8b       	std	Y+21, r19	; 0x15
     952:	2c 8b       	std	Y+20, r18	; 0x14
    chSchReadyI(list_remove(&tp->p_waiting));
     954:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
     958:	8c 89       	ldd	r24, Y+20	; 0x14
     95a:	9d 89       	ldd	r25, Y+21	; 0x15
     95c:	80 17       	cp	r24, r16
     95e:	91 07       	cpc	r25, r17
     960:	a1 f7       	brne	.-24     	; 0x94a <chThdExitS+0x24>
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
     962:	8e 85       	ldd	r24, Y+14	; 0x0e
     964:	83 70       	andi	r24, 0x03	; 3
     966:	61 f4       	brne	.+24     	; 0x980 <chThdExitS+0x5a>
    REG_REMOVE(tp);
     968:	e9 85       	ldd	r30, Y+9	; 0x09
     96a:	fa 85       	ldd	r31, Y+10	; 0x0a
     96c:	8f 81       	ldd	r24, Y+7	; 0x07
     96e:	98 85       	ldd	r25, Y+8	; 0x08
     970:	90 87       	std	Z+8, r25	; 0x08
     972:	87 83       	std	Z+7, r24	; 0x07
     974:	af 81       	ldd	r26, Y+7	; 0x07
     976:	b8 85       	ldd	r27, Y+8	; 0x08
     978:	1a 96       	adiw	r26, 0x0a	; 10
     97a:	fc 93       	st	X, r31
     97c:	ee 93       	st	-X, r30
     97e:	19 97       	sbiw	r26, 0x09	; 9
#endif
  chSchGoSleepS(THD_STATE_FINAL);
     980:	8e e0       	ldi	r24, 0x0E	; 14
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
     982:	df 91       	pop	r29
     984:	cf 91       	pop	r28
     986:	1f 91       	pop	r17
     988:	0f 91       	pop	r16
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    REG_REMOVE(tp);
#endif
  chSchGoSleepS(THD_STATE_FINAL);
     98a:	0c 94 60 02 	jmp	0x4c0	; 0x4c0 <chSchGoSleepS>

0000098e <chThdExit>:
 *
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
     98e:	f8 94       	cli
  chThdExitS(msg);
     990:	0c 94 93 04 	jmp	0x926	; 0x926 <chThdExitS>

00000994 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(Thread *tp) {
     994:	cf 93       	push	r28
     996:	df 93       	push	r29
     998:	ec 01       	movw	r28, r24
  msg_t msg;

  chDbgCheck(tp != NULL, "chThdWait");

  chSysLock();
     99a:	f8 94       	cli
  chDbgAssert(tp != currp, "chThdWait(), #1", "waiting self");
#if CH_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "chThdWait(), #2", "not referenced");
#endif
  if (tp->p_state != THD_STATE_FINAL) {
     99c:	8d 85       	ldd	r24, Y+13	; 0x0d
     99e:	8e 30       	cpi	r24, 0x0E	; 14
     9a0:	69 f0       	breq	.+26     	; 0x9bc <chThdWait+0x28>
    list_insert(currp, &tp->p_waiting);
     9a2:	e0 91 3c 02 	lds	r30, 0x023C
     9a6:	f0 91 3d 02 	lds	r31, 0x023D
  return tp;
}

static INLINE void list_insert(Thread *tp, ThreadsList *tlp) {

  tp->p_next = tlp->p_next;
     9aa:	8c 89       	ldd	r24, Y+20	; 0x14
     9ac:	9d 89       	ldd	r25, Y+21	; 0x15
     9ae:	91 83       	std	Z+1, r25	; 0x01
     9b0:	80 83       	st	Z, r24
  tlp->p_next = tp;
     9b2:	fd 8b       	std	Y+21, r31	; 0x15
     9b4:	ec 8b       	std	Y+20, r30	; 0x14
    chSchGoSleepS(THD_STATE_WTEXIT);
     9b6:	87 e0       	ldi	r24, 0x07	; 7
     9b8:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
     9bc:	8a 89       	ldd	r24, Y+18	; 0x12
     9be:	9b 89       	ldd	r25, Y+19	; 0x13
  chSysUnlock();
     9c0:	78 94       	sei
#if CH_USE_DYNAMIC
  chThdRelease(tp);
#endif
  return msg;
}
     9c2:	df 91       	pop	r29
     9c4:	cf 91       	pop	r28
     9c6:	08 95       	ret

000009c8 <chRegFirstThread>:
 * @api
 */
Thread *chRegFirstThread(void) {
  Thread *tp;

  chSysLock();
     9c8:	f8 94       	cli
  tp = rlist.r_newer;
     9ca:	e8 e3       	ldi	r30, 0x38	; 56
     9cc:	f2 e0       	ldi	r31, 0x02	; 2
     9ce:	80 81       	ld	r24, Z
     9d0:	91 81       	ldd	r25, Z+1	; 0x01
#if CH_USE_DYNAMIC
  tp->p_refs++;
#endif
  chSysUnlock();
     9d2:	78 94       	sei
  return tp;
}
     9d4:	08 95       	ret

000009d6 <chRegNextThread>:
 * @api
 */
Thread *chRegNextThread(Thread *tp) {
  Thread *ntp;

  chSysLock();
     9d6:	f8 94       	cli
  ntp = tp->p_newer;
     9d8:	fc 01       	movw	r30, r24
     9da:	27 81       	ldd	r18, Z+7	; 0x07
     9dc:	30 85       	ldd	r19, Z+8	; 0x08
  if (ntp == (Thread *)&rlist)
     9de:	f2 e0       	ldi	r31, 0x02	; 2
     9e0:	21 33       	cpi	r18, 0x31	; 49
     9e2:	3f 07       	cpc	r19, r31
     9e4:	19 f0       	breq	.+6      	; 0x9ec <chRegNextThread+0x16>
    chDbgAssert(ntp->p_refs < 255, "chRegNextThread(), #1",
                "too many references");
    ntp->p_refs++;
  }
#endif
  chSysUnlock();
     9e6:	78 94       	sei
#if CH_USE_DYNAMIC
  chThdRelease(tp);
#endif
  return ntp;
}
     9e8:	c9 01       	movw	r24, r18
     9ea:	08 95       	ret
  Thread *ntp;

  chSysLock();
  ntp = tp->p_newer;
  if (ntp == (Thread *)&rlist)
    ntp = NULL;
     9ec:	20 e0       	ldi	r18, 0x00	; 0
     9ee:	30 e0       	ldi	r19, 0x00	; 0
     9f0:	fa cf       	rjmp	.-12     	; 0x9e6 <chRegNextThread+0x10>

000009f2 <chSemInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemInit(Semaphore *sp, cnt_t n) {
     9f2:	fc 01       	movw	r30, r24

  chDbgCheck((sp != NULL) && (n >= 0), "chSemInit");

  queue_init(&sp->s_queue);
     9f4:	82 83       	std	Z+2, r24	; 0x02
     9f6:	f3 83       	std	Z+3, r31	; 0x03
     9f8:	80 83       	st	Z, r24
     9fa:	f1 83       	std	Z+1, r31	; 0x01
  sp->s_cnt = n;
     9fc:	64 83       	std	Z+4, r22	; 0x04
     9fe:	08 95       	ret

00000a00 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(Semaphore *sp, cnt_t n) {
     a00:	ff 92       	push	r15
     a02:	0f 93       	push	r16
     a04:	1f 93       	push	r17
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
     a0a:	ec 01       	movw	r28, r24
  cnt_t cnt;

  chDbgCheckClassI();
  chDbgCheck((sp != NULL) && (n >= 0), "chSemResetI");
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
     a0c:	fc 80       	ldd	r15, Y+4	; 0x04
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemResetI(), #1",
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
     a0e:	6c 83       	std	Y+4, r22	; 0x04
  while (++cnt <= 0)
     a10:	f3 94       	inc	r15
     a12:	1f 14       	cp	r1, r15
     a14:	b4 f0       	brlt	.+44     	; 0xa42 <chSemResetI+0x42>
    chSchReadyI(lifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_RESET;
     a16:	0e ef       	ldi	r16, 0xFE	; 254
     a18:	1f ef       	ldi	r17, 0xFF	; 255
  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
  return tp;
}

static INLINE Thread *lifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_prev;
     a1a:	8a 81       	ldd	r24, Y+2	; 0x02
     a1c:	9b 81       	ldd	r25, Y+3	; 0x03

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
     a1e:	dc 01       	movw	r26, r24
     a20:	12 96       	adiw	r26, 0x02	; 2
     a22:	ed 91       	ld	r30, X+
     a24:	fc 91       	ld	r31, X
     a26:	13 97       	sbiw	r26, 0x03	; 3
     a28:	fb 83       	std	Y+3, r31	; 0x03
     a2a:	ea 83       	std	Y+2, r30	; 0x02
     a2c:	d1 83       	std	Z+1, r29	; 0x01
     a2e:	c0 83       	st	Z, r28
     a30:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
     a34:	fc 01       	movw	r30, r24
     a36:	13 8b       	std	Z+19, r17	; 0x13
     a38:	02 8b       	std	Z+18, r16	; 0x12
              "chSemResetI(), #1",
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= 0)
     a3a:	f3 94       	inc	r15
     a3c:	f1 e0       	ldi	r31, 0x01	; 1
     a3e:	ff 12       	cpse	r15, r31
     a40:	ec cf       	rjmp	.-40     	; 0xa1a <chSemResetI+0x1a>
    chSchReadyI(lifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_RESET;
}
     a42:	df 91       	pop	r29
     a44:	cf 91       	pop	r28
     a46:	1f 91       	pop	r17
     a48:	0f 91       	pop	r16
     a4a:	ff 90       	pop	r15
     a4c:	08 95       	ret

00000a4e <chSemReset>:
 *
 * @api
 */
void chSemReset(Semaphore *sp, cnt_t n) {

  chSysLock();
     a4e:	f8 94       	cli
  chSemResetI(sp, n);
     a50:	0e 94 00 05 	call	0xa00	; 0xa00 <chSemResetI>
  chSchRescheduleS();
     a54:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  chSysUnlock();
     a58:	78 94       	sei
     a5a:	08 95       	ret

00000a5c <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(Semaphore *sp) {
     a5c:	cf 93       	push	r28
     a5e:	df 93       	push	r29
     a60:	fc 01       	movw	r30, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
     a62:	84 81       	ldd	r24, Z+4	; 0x04
     a64:	81 50       	subi	r24, 0x01	; 1
     a66:	84 83       	std	Z+4, r24	; 0x04
     a68:	87 fd       	sbrc	r24, 7
     a6a:	06 c0       	rjmp	.+12     	; 0xa78 <chSemWaitS+0x1c>
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
    return currp->p_u.rdymsg;
  }
  return RDY_OK;
     a6c:	20 e0       	ldi	r18, 0x00	; 0
     a6e:	30 e0       	ldi	r19, 0x00	; 0
}
     a70:	c9 01       	movw	r24, r18
     a72:	df 91       	pop	r29
     a74:	cf 91       	pop	r28
     a76:	08 95       	ret
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    currp->p_u.wtobjp = sp;
     a78:	a0 91 3c 02 	lds	r26, 0x023C
     a7c:	b0 91 3d 02 	lds	r27, 0x023D
     a80:	53 96       	adiw	r26, 0x13	; 19
     a82:	fc 93       	st	X, r31
     a84:	ee 93       	st	-X, r30
     a86:	52 97       	sbiw	r26, 0x12	; 18
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
     a88:	11 96       	adiw	r26, 0x01	; 1
     a8a:	fc 93       	st	X, r31
     a8c:	ee 93       	st	-X, r30
  tp->p_prev = tqp->p_prev;
     a8e:	c2 81       	ldd	r28, Z+2	; 0x02
     a90:	d3 81       	ldd	r29, Z+3	; 0x03
     a92:	13 96       	adiw	r26, 0x03	; 3
     a94:	dc 93       	st	X, r29
     a96:	ce 93       	st	-X, r28
     a98:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = tqp->p_prev = tp;
     a9a:	b3 83       	std	Z+3, r27	; 0x03
     a9c:	a2 83       	std	Z+2, r26	; 0x02
     a9e:	b9 83       	std	Y+1, r27	; 0x01
     aa0:	a8 83       	st	Y, r26
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
     aa2:	83 e0       	ldi	r24, 0x03	; 3
     aa4:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
    return currp->p_u.rdymsg;
     aa8:	e0 91 3c 02 	lds	r30, 0x023C
     aac:	f0 91 3d 02 	lds	r31, 0x023D
     ab0:	22 89       	ldd	r18, Z+18	; 0x12
     ab2:	33 89       	ldd	r19, Z+19	; 0x13
  }
  return RDY_OK;
}
     ab4:	c9 01       	movw	r24, r18
     ab6:	df 91       	pop	r29
     ab8:	cf 91       	pop	r28
     aba:	08 95       	ret

00000abc <chSemWait>:
 * @api
 */
msg_t chSemWait(Semaphore *sp) {
  msg_t msg;

  chSysLock();
     abc:	f8 94       	cli
  msg = chSemWaitS(sp);
     abe:	0e 94 2e 05 	call	0xa5c	; 0xa5c <chSemWaitS>
  chSysUnlock();
     ac2:	78 94       	sei
  return msg;
}
     ac4:	08 95       	ret

00000ac6 <chSemWaitTimeoutS>:
 * @retval RDY_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(Semaphore *sp, systime_t time) {
     ac6:	cf 93       	push	r28
     ac8:	df 93       	push	r29
     aca:	fc 01       	movw	r30, r24

  chDbgCheckClassS();
  chDbgCheck(sp != NULL, "chSemWaitTimeoutS");
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
     acc:	94 81       	ldd	r25, Z+4	; 0x04
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
     ace:	89 2f       	mov	r24, r25
     ad0:	81 50       	subi	r24, 0x01	; 1
     ad2:	84 83       	std	Z+4, r24	; 0x04
     ad4:	87 fd       	sbrc	r24, 7
     ad6:	06 c0       	rjmp	.+12     	; 0xae4 <chSemWaitTimeoutS+0x1e>
    }
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
  }
  return RDY_OK;
     ad8:	20 e0       	ldi	r18, 0x00	; 0
     ada:	30 e0       	ldi	r19, 0x00	; 0
}
     adc:	c9 01       	movw	r24, r18
     ade:	df 91       	pop	r29
     ae0:	cf 91       	pop	r28
     ae2:	08 95       	ret
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
     ae4:	61 15       	cp	r22, r1
     ae6:	71 05       	cpc	r23, r1
     ae8:	d1 f0       	breq	.+52     	; 0xb1e <chSemWaitTimeoutS+0x58>
      sp->s_cnt++;
      return RDY_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
     aea:	a0 91 3c 02 	lds	r26, 0x023C
     aee:	b0 91 3d 02 	lds	r27, 0x023D
     af2:	53 96       	adiw	r26, 0x13	; 19
     af4:	fc 93       	st	X, r31
     af6:	ee 93       	st	-X, r30
     af8:	52 97       	sbiw	r26, 0x12	; 18
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
     afa:	11 96       	adiw	r26, 0x01	; 1
     afc:	fc 93       	st	X, r31
     afe:	ee 93       	st	-X, r30
  tp->p_prev = tqp->p_prev;
     b00:	c2 81       	ldd	r28, Z+2	; 0x02
     b02:	d3 81       	ldd	r29, Z+3	; 0x03
     b04:	13 96       	adiw	r26, 0x03	; 3
     b06:	dc 93       	st	X, r29
     b08:	ce 93       	st	-X, r28
     b0a:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = tqp->p_prev = tp;
     b0c:	b3 83       	std	Z+3, r27	; 0x03
     b0e:	a2 83       	std	Z+2, r26	; 0x02
     b10:	b9 83       	std	Y+1, r27	; 0x01
     b12:	a8 83       	st	Y, r26
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
     b14:	83 e0       	ldi	r24, 0x03	; 3
  }
  return RDY_OK;
}
     b16:	df 91       	pop	r29
     b18:	cf 91       	pop	r28
      sp->s_cnt++;
      return RDY_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);
    return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
     b1a:	0c 94 81 02 	jmp	0x502	; 0x502 <chSchGoSleepTimeoutS>
              "chSemWaitTimeoutS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
     b1e:	94 83       	std	Z+4, r25	; 0x04
      return RDY_TIMEOUT;
     b20:	2f ef       	ldi	r18, 0xFF	; 255
     b22:	3f ef       	ldi	r19, 0xFF	; 255
     b24:	db cf       	rjmp	.-74     	; 0xadc <chSemWaitTimeoutS+0x16>

00000b26 <chSemWaitTimeout>:
 * @api
 */
msg_t chSemWaitTimeout(Semaphore *sp, systime_t time) {
  msg_t msg;

  chSysLock();
     b26:	f8 94       	cli
  msg = chSemWaitTimeoutS(sp, time);
     b28:	0e 94 63 05 	call	0xac6	; 0xac6 <chSemWaitTimeoutS>
  chSysUnlock();
     b2c:	78 94       	sei
  return msg;
}
     b2e:	08 95       	ret

00000b30 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p Semaphore structure
 *
 * @api
 */
void chSemSignal(Semaphore *sp) {
     b30:	cf 93       	push	r28
     b32:	df 93       	push	r29
     b34:	fc 01       	movw	r30, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemSignal(), #1",
              "inconsistent semaphore");

  chSysLock();
     b36:	f8 94       	cli
  if (++sp->s_cnt <= 0)
     b38:	84 81       	ldd	r24, Z+4	; 0x04
     b3a:	8f 5f       	subi	r24, 0xFF	; 255
     b3c:	84 83       	std	Z+4, r24	; 0x04
     b3e:	18 16       	cp	r1, r24
     b40:	24 f4       	brge	.+8      	; 0xb4a <chSemSignal+0x1a>
    chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
  chSysUnlock();
     b42:	78 94       	sei
}
     b44:	df 91       	pop	r29
     b46:	cf 91       	pop	r28
     b48:	08 95       	ret
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     b4a:	80 81       	ld	r24, Z
     b4c:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     b4e:	ec 01       	movw	r28, r24
     b50:	a8 81       	ld	r26, Y
     b52:	b9 81       	ldd	r27, Y+1	; 0x01
     b54:	b1 83       	std	Z+1, r27	; 0x01
     b56:	a0 83       	st	Z, r26
     b58:	13 96       	adiw	r26, 0x03	; 3
     b5a:	fc 93       	st	X, r31
     b5c:	ee 93       	st	-X, r30
     b5e:	12 97       	sbiw	r26, 0x02	; 2
              "chSemSignal(), #1",
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= 0)
    chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
     b60:	60 e0       	ldi	r22, 0x00	; 0
     b62:	70 e0       	ldi	r23, 0x00	; 0
     b64:	0e 94 ba 02 	call	0x574	; 0x574 <chSchWakeupS>
  chSysUnlock();
     b68:	78 94       	sei
}
     b6a:	df 91       	pop	r29
     b6c:	cf 91       	pop	r28
     b6e:	08 95       	ret

00000b70 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p Semaphore structure
 *
 * @iclass
 */
void chSemSignalI(Semaphore *sp) {
     b70:	cf 93       	push	r28
     b72:	df 93       	push	r29
     b74:	fc 01       	movw	r30, r24
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemSignalI(), #1",
              "inconsistent semaphore");

  if (++sp->s_cnt <= 0) {
     b76:	84 81       	ldd	r24, Z+4	; 0x04
     b78:	8f 5f       	subi	r24, 0xFF	; 255
     b7a:	84 83       	std	Z+4, r24	; 0x04
     b7c:	18 16       	cp	r1, r24
     b7e:	1c f4       	brge	.+6      	; 0xb86 <chSemSignalI+0x16>
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
    chSchReadyI(tp);
  }
}
     b80:	df 91       	pop	r29
     b82:	cf 91       	pop	r28
     b84:	08 95       	ret
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     b86:	80 81       	ld	r24, Z
     b88:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     b8a:	ec 01       	movw	r28, r24
     b8c:	a8 81       	ld	r26, Y
     b8e:	b9 81       	ldd	r27, Y+1	; 0x01
     b90:	b1 83       	std	Z+1, r27	; 0x01
     b92:	a0 83       	st	Z, r26
     b94:	13 96       	adiw	r26, 0x03	; 3
     b96:	fc 93       	st	X, r31
     b98:	ee 93       	st	-X, r30
     b9a:	12 97       	sbiw	r26, 0x02	; 2

  if (++sp->s_cnt <= 0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
     b9c:	1b 8a       	std	Y+19, r1	; 0x13
     b9e:	1a 8a       	std	Y+18, r1	; 0x12
    chSchReadyI(tp);
  }
}
     ba0:	df 91       	pop	r29
     ba2:	cf 91       	pop	r28
  if (++sp->s_cnt <= 0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    Thread *tp = fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = RDY_OK;
    chSchReadyI(tp);
     ba4:	0c 94 3e 02 	jmp	0x47c	; 0x47c <chSchReadyI>

00000ba8 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(Semaphore *sp, cnt_t n) {
     ba8:	1f 93       	push	r17
     baa:	cf 93       	push	r28
     bac:	df 93       	push	r29
     bae:	ec 01       	movw	r28, r24
     bb0:	16 2f       	mov	r17, r22
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     bb2:	16 16       	cp	r1, r22
     bb4:	1c f0       	brlt	.+6      	; 0xbbc <chSemAddCounterI+0x14>
     bb6:	17 c0       	rjmp	.+46     	; 0xbe6 <chSemAddCounterI+0x3e>
    if (++sp->s_cnt <= 0)
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
    n--;
     bb8:	11 50       	subi	r17, 0x01	; 1
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     bba:	a9 f0       	breq	.+42     	; 0xbe6 <chSemAddCounterI+0x3e>
    if (++sp->s_cnt <= 0)
     bbc:	8c 81       	ldd	r24, Y+4	; 0x04
     bbe:	8f 5f       	subi	r24, 0xFF	; 255
     bc0:	8c 83       	std	Y+4, r24	; 0x04
     bc2:	18 16       	cp	r1, r24
     bc4:	cc f3       	brlt	.-14     	; 0xbb8 <chSemAddCounterI+0x10>
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     bc6:	88 81       	ld	r24, Y
     bc8:	99 81       	ldd	r25, Y+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     bca:	dc 01       	movw	r26, r24
     bcc:	ed 91       	ld	r30, X+
     bce:	fc 91       	ld	r31, X
     bd0:	f9 83       	std	Y+1, r31	; 0x01
     bd2:	e8 83       	st	Y, r30
     bd4:	d3 83       	std	Z+3, r29	; 0x03
     bd6:	c2 83       	std	Z+2, r28	; 0x02
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
     bd8:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
     bdc:	fc 01       	movw	r30, r24
     bde:	13 8a       	std	Z+19, r1	; 0x13
     be0:	12 8a       	std	Z+18, r1	; 0x12
    n--;
     be2:	11 50       	subi	r17, 0x01	; 1
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemAddCounterI(), #1",
              "inconsistent semaphore");

  while (n > 0) {
     be4:	59 f7       	brne	.-42     	; 0xbbc <chSemAddCounterI+0x14>
    if (++sp->s_cnt <= 0)
      chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
    n--;
  }
}
     be6:	df 91       	pop	r29
     be8:	cf 91       	pop	r28
     bea:	1f 91       	pop	r17
     bec:	08 95       	ret

00000bee <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(Semaphore *sps, Semaphore *spw) {
     bee:	0f 93       	push	r16
     bf0:	1f 93       	push	r17
     bf2:	cf 93       	push	r28
     bf4:	df 93       	push	r29
     bf6:	fc 01       	movw	r30, r24
     bf8:	eb 01       	movw	r28, r22
  chDbgAssert(((spw->s_cnt >= 0) && isempty(&spw->s_queue)) ||
              ((spw->s_cnt < 0) && notempty(&spw->s_queue)),
              "chSemSignalWait(), #2",
              "inconsistent semaphore");

  chSysLock();
     bfa:	f8 94       	cli
  if (++sps->s_cnt <= 0)
     bfc:	84 81       	ldd	r24, Z+4	; 0x04
     bfe:	8f 5f       	subi	r24, 0xFF	; 255
     c00:	84 83       	std	Z+4, r24	; 0x04
     c02:	18 16       	cp	r1, r24
     c04:	9c f5       	brge	.+102    	; 0xc6c <chSemSignalWait+0x7e>
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
  if (--spw->s_cnt < 0) {
     c06:	8c 81       	ldd	r24, Y+4	; 0x04
     c08:	81 50       	subi	r24, 0x01	; 1
     c0a:	8c 83       	std	Y+4, r24	; 0x04
     c0c:	87 fd       	sbrc	r24, 7
     c0e:	0b c0       	rjmp	.+22     	; 0xc26 <chSemSignalWait+0x38>
    ctp->p_u.wtobjp = spw;
    chSchGoSleepS(THD_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
     c10:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
    msg = RDY_OK;
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	30 e0       	ldi	r19, 0x00	; 0
  }
  chSysUnlock();
     c18:	78 94       	sei
  return msg;
}
     c1a:	c9 01       	movw	r24, r18
     c1c:	df 91       	pop	r29
     c1e:	cf 91       	pop	r28
     c20:	1f 91       	pop	r17
     c22:	0f 91       	pop	r16
     c24:	08 95       	ret

  chSysLock();
  if (++sps->s_cnt <= 0)
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
  if (--spw->s_cnt < 0) {
    Thread *ctp = currp;
     c26:	00 91 3c 02 	lds	r16, 0x023C
     c2a:	10 91 3d 02 	lds	r17, 0x023D
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
     c2e:	d8 01       	movw	r26, r16
     c30:	11 96       	adiw	r26, 0x01	; 1
     c32:	dc 93       	st	X, r29
     c34:	ce 93       	st	-X, r28
  tp->p_prev = tqp->p_prev;
     c36:	ea 81       	ldd	r30, Y+2	; 0x02
     c38:	fb 81       	ldd	r31, Y+3	; 0x03
     c3a:	13 96       	adiw	r26, 0x03	; 3
     c3c:	fc 93       	st	X, r31
     c3e:	ee 93       	st	-X, r30
     c40:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = tqp->p_prev = tp;
     c42:	1b 83       	std	Y+3, r17	; 0x03
     c44:	0a 83       	std	Y+2, r16	; 0x02
     c46:	11 83       	std	Z+1, r17	; 0x01
     c48:	00 83       	st	Z, r16
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtobjp = spw;
     c4a:	53 96       	adiw	r26, 0x13	; 19
     c4c:	dc 93       	st	X, r29
     c4e:	ce 93       	st	-X, r28
     c50:	52 97       	sbiw	r26, 0x12	; 18
    chSchGoSleepS(THD_STATE_WTSEM);
     c52:	83 e0       	ldi	r24, 0x03	; 3
     c54:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
     c58:	f8 01       	movw	r30, r16
     c5a:	22 89       	ldd	r18, Z+18	; 0x12
     c5c:	33 89       	ldd	r19, Z+19	; 0x13
  }
  else {
    chSchRescheduleS();
    msg = RDY_OK;
  }
  chSysUnlock();
     c5e:	78 94       	sei
  return msg;
}
     c60:	c9 01       	movw	r24, r18
     c62:	df 91       	pop	r29
     c64:	cf 91       	pop	r28
     c66:	1f 91       	pop	r17
     c68:	0f 91       	pop	r16
     c6a:	08 95       	ret
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     c6c:	80 81       	ld	r24, Z
     c6e:	91 81       	ldd	r25, Z+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     c70:	dc 01       	movw	r26, r24
     c72:	2d 91       	ld	r18, X+
     c74:	3c 91       	ld	r19, X
     c76:	31 83       	std	Z+1, r19	; 0x01
     c78:	20 83       	st	Z, r18
     c7a:	d9 01       	movw	r26, r18
     c7c:	13 96       	adiw	r26, 0x03	; 3
     c7e:	fc 93       	st	X, r31
     c80:	ee 93       	st	-X, r30
     c82:	12 97       	sbiw	r26, 0x02	; 2
              "chSemSignalWait(), #2",
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= 0)
    chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
     c84:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
     c88:	fc 01       	movw	r30, r24
     c8a:	13 8a       	std	Z+19, r1	; 0x13
     c8c:	12 8a       	std	Z+18, r1	; 0x12
     c8e:	bb cf       	rjmp	.-138    	; 0xc06 <chSemSignalWait+0x18>

00000c90 <chMtxInit>:
 *
 * @param[out] mp       pointer to a @p Mutex structure
 *
 * @init
 */
void chMtxInit(Mutex *mp) {
     c90:	fc 01       	movw	r30, r24

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
     c92:	82 83       	std	Z+2, r24	; 0x02
     c94:	f3 83       	std	Z+3, r31	; 0x03
     c96:	80 83       	st	Z, r24
     c98:	f1 83       	std	Z+1, r31	; 0x01
  mp->m_owner = NULL;
     c9a:	15 82       	std	Z+5, r1	; 0x05
     c9c:	14 82       	std	Z+4, r1	; 0x04
     c9e:	08 95       	ret

00000ca0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @sclass
 */
void chMtxLockS(Mutex *mp) {
     ca0:	0f 93       	push	r16
     ca2:	1f 93       	push	r17
     ca4:	cf 93       	push	r28
     ca6:	df 93       	push	r29
     ca8:	8c 01       	movw	r16, r24
  Thread *ctp = currp;
     caa:	c0 91 3c 02 	lds	r28, 0x023C
     cae:	d0 91 3d 02 	lds	r29, 0x023D

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxLockS");

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
     cb2:	dc 01       	movw	r26, r24
     cb4:	14 96       	adiw	r26, 0x04	; 4
     cb6:	ed 91       	ld	r30, X+
     cb8:	fc 91       	ld	r31, X
     cba:	15 97       	sbiw	r26, 0x05	; 5
     cbc:	30 97       	sbiw	r30, 0x00	; 0
     cbe:	09 f4       	brne	.+2      	; 0xcc2 <chMtxLockS+0x22>
     cc0:	9f c0       	rjmp	.+318    	; 0xe00 <chMtxLockS+0x160>
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
     cc2:	4c 81       	ldd	r20, Y+4	; 0x04
     cc4:	84 81       	ldd	r24, Z+4	; 0x04
     cc6:	84 17       	cp	r24, r20
     cc8:	48 f4       	brcc	.+18     	; 0xcdc <chMtxLockS+0x3c>
      /* Make priority of thread tp match the running thread's priority.*/
      tp->p_prio = ctp->p_prio;
     cca:	44 83       	std	Z+4, r20	; 0x04
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
     ccc:	85 85       	ldd	r24, Z+13	; 0x0d
     cce:	84 30       	cpi	r24, 0x04	; 4
     cd0:	09 f4       	brne	.+2      	; 0xcd4 <chMtxLockS+0x34>
     cd2:	60 c0       	rjmp	.+192    	; 0xd94 <chMtxLockS+0xf4>
     cd4:	85 30       	cpi	r24, 0x05	; 5
     cd6:	91 f1       	breq	.+100    	; 0xd3c <chMtxLockS+0x9c>
     cd8:	88 23       	and	r24, r24
     cda:	f1 f0       	breq	.+60     	; 0xd18 <chMtxLockS+0x78>
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
     cdc:	f8 01       	movw	r30, r16
  do {
    cp = cp->p_next;
     cde:	01 90       	ld	r0, Z+
     ce0:	f0 81       	ld	r31, Z
     ce2:	e0 2d       	mov	r30, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     ce4:	0e 17       	cp	r16, r30
     ce6:	1f 07       	cpc	r17, r31
     ce8:	21 f0       	breq	.+8      	; 0xcf2 <chMtxLockS+0x52>
     cea:	94 81       	ldd	r25, Z+4	; 0x04
     cec:	8c 81       	ldd	r24, Y+4	; 0x04
     cee:	98 17       	cp	r25, r24
     cf0:	b0 f7       	brcc	.-20     	; 0xcde <chMtxLockS+0x3e>
  tp->p_next = cp;
     cf2:	f9 83       	std	Y+1, r31	; 0x01
     cf4:	e8 83       	st	Y, r30
  tp->p_prev = cp->p_prev;
     cf6:	a2 81       	ldd	r26, Z+2	; 0x02
     cf8:	b3 81       	ldd	r27, Z+3	; 0x03
     cfa:	bb 83       	std	Y+3, r27	; 0x03
     cfc:	aa 83       	std	Y+2, r26	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     cfe:	d3 83       	std	Z+3, r29	; 0x03
     d00:	c2 83       	std	Z+2, r28	; 0x02
     d02:	cd 93       	st	X+, r28
     d04:	dc 93       	st	X, r29
      }
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
    ctp->p_u.wtobjp = mp;
     d06:	1b 8b       	std	Y+19, r17	; 0x13
     d08:	0a 8b       	std	Y+18, r16	; 0x12
    chSchGoSleepS(THD_STATE_WTMTX);
     d0a:	84 e0       	ldi	r24, 0x04	; 4
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	1f 91       	pop	r17
     d12:	0f 91       	pop	r16
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
    ctp->p_u.wtobjp = mp;
    chSchGoSleepS(THD_STATE_WTMTX);
     d14:	0c 94 60 02 	jmp	0x4c0	; 0x4c0 <chSchGoSleepS>
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     d18:	22 81       	ldd	r18, Z+2	; 0x02
     d1a:	33 81       	ldd	r19, Z+3	; 0x03
     d1c:	80 81       	ld	r24, Z
     d1e:	91 81       	ldd	r25, Z+1	; 0x01
     d20:	d9 01       	movw	r26, r18
     d22:	8d 93       	st	X+, r24
     d24:	9c 93       	st	X, r25
  tp->p_next->p_prev = tp->p_prev;
     d26:	80 81       	ld	r24, Z
     d28:	91 81       	ldd	r25, Z+1	; 0x01
     d2a:	dc 01       	movw	r26, r24
     d2c:	13 96       	adiw	r26, 0x03	; 3
     d2e:	3c 93       	st	X, r19
     d30:	2e 93       	st	-X, r18
     d32:	12 97       	sbiw	r26, 0x02	; 2
#if CH_DBG_ENABLE_ASSERTS
        /* Prevents an assertion in chSchReadyI().*/
        tp->p_state = THD_STATE_CURRENT;
#endif
        /* Re-enqueues tp with its new priority on the ready list.*/
        chSchReadyI(dequeue(tp));
     d34:	cf 01       	movw	r24, r30
     d36:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
        break;
     d3a:	d0 cf       	rjmp	.-96     	; 0xcdc <chMtxLockS+0x3c>
#endif
#if CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY
      case THD_STATE_SNDMSGQ:
#endif
        /* Re-enqueues tp with its new priority on the queue.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
     d3c:	82 89       	ldd	r24, Z+18	; 0x12
     d3e:	93 89       	ldd	r25, Z+19	; 0x13
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     d40:	62 81       	ldd	r22, Z+2	; 0x02
     d42:	73 81       	ldd	r23, Z+3	; 0x03
     d44:	20 81       	ld	r18, Z
     d46:	31 81       	ldd	r19, Z+1	; 0x01
     d48:	db 01       	movw	r26, r22
     d4a:	2d 93       	st	X+, r18
     d4c:	3c 93       	st	X, r19
  tp->p_next->p_prev = tp->p_prev;
     d4e:	20 81       	ld	r18, Z
     d50:	31 81       	ldd	r19, Z+1	; 0x01
     d52:	d9 01       	movw	r26, r18
     d54:	13 96       	adiw	r26, 0x03	; 3
     d56:	7c 93       	st	X, r23
     d58:	6e 93       	st	-X, r22
     d5a:	12 97       	sbiw	r26, 0x02	; 2
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
     d5c:	dc 01       	movw	r26, r24
  do {
    cp = cp->p_next;
     d5e:	0d 90       	ld	r0, X+
     d60:	bc 91       	ld	r27, X
     d62:	a0 2d       	mov	r26, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     d64:	8a 17       	cp	r24, r26
     d66:	9b 07       	cpc	r25, r27
     d68:	29 f0       	breq	.+10     	; 0xd74 <chMtxLockS+0xd4>
     d6a:	14 96       	adiw	r26, 0x04	; 4
     d6c:	2c 91       	ld	r18, X
     d6e:	14 97       	sbiw	r26, 0x04	; 4
     d70:	24 17       	cp	r18, r20
     d72:	a8 f7       	brcc	.-22     	; 0xd5e <chMtxLockS+0xbe>
  tp->p_next = cp;
     d74:	b1 83       	std	Z+1, r27	; 0x01
     d76:	a0 83       	st	Z, r26
  tp->p_prev = cp->p_prev;
     d78:	12 96       	adiw	r26, 0x02	; 2
     d7a:	8d 91       	ld	r24, X+
     d7c:	9c 91       	ld	r25, X
     d7e:	13 97       	sbiw	r26, 0x03	; 3
     d80:	93 83       	std	Z+3, r25	; 0x03
     d82:	82 83       	std	Z+2, r24	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     d84:	13 96       	adiw	r26, 0x03	; 3
     d86:	fc 93       	st	X, r31
     d88:	ee 93       	st	-X, r30
     d8a:	12 97       	sbiw	r26, 0x02	; 2
     d8c:	dc 01       	movw	r26, r24
     d8e:	ed 93       	st	X+, r30
     d90:	fc 93       	st	X, r31
     d92:	a4 cf       	rjmp	.-184    	; 0xcdc <chMtxLockS+0x3c>
      tp->p_prio = ctp->p_prio;
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
      case THD_STATE_WTMTX:
        /* Re-enqueues the mutex owner with its new priority.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
     d94:	82 89       	ldd	r24, Z+18	; 0x12
     d96:	93 89       	ldd	r25, Z+19	; 0x13
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
     d98:	62 81       	ldd	r22, Z+2	; 0x02
     d9a:	73 81       	ldd	r23, Z+3	; 0x03
     d9c:	20 81       	ld	r18, Z
     d9e:	31 81       	ldd	r19, Z+1	; 0x01
     da0:	db 01       	movw	r26, r22
     da2:	2d 93       	st	X+, r18
     da4:	3c 93       	st	X, r19
  tp->p_next->p_prev = tp->p_prev;
     da6:	20 81       	ld	r18, Z
     da8:	31 81       	ldd	r19, Z+1	; 0x01
     daa:	d9 01       	movw	r26, r18
     dac:	13 96       	adiw	r26, 0x03	; 3
     dae:	7c 93       	st	X, r23
     db0:	6e 93       	st	-X, r22
     db2:	12 97       	sbiw	r26, 0x02	; 2
     db4:	dc 01       	movw	r26, r24
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
     db6:	0d 90       	ld	r0, X+
     db8:	bc 91       	ld	r27, X
     dba:	a0 2d       	mov	r26, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     dbc:	8a 17       	cp	r24, r26
     dbe:	9b 07       	cpc	r25, r27
     dc0:	69 f1       	breq	.+90     	; 0xe1c <chMtxLockS+0x17c>
     dc2:	14 96       	adiw	r26, 0x04	; 4
     dc4:	2c 91       	ld	r18, X
     dc6:	14 97       	sbiw	r26, 0x04	; 4
     dc8:	24 17       	cp	r18, r20
     dca:	a8 f7       	brcc	.-22     	; 0xdb6 <chMtxLockS+0x116>
  tp->p_next = cp;
     dcc:	b1 83       	std	Z+1, r27	; 0x01
     dce:	a0 83       	st	Z, r26
  tp->p_prev = cp->p_prev;
     dd0:	12 96       	adiw	r26, 0x02	; 2
     dd2:	2d 91       	ld	r18, X+
     dd4:	3c 91       	ld	r19, X
     dd6:	13 97       	sbiw	r26, 0x03	; 3
     dd8:	33 83       	std	Z+3, r19	; 0x03
     dda:	22 83       	std	Z+2, r18	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
     ddc:	13 96       	adiw	r26, 0x03	; 3
     dde:	fc 93       	st	X, r31
     de0:	ee 93       	st	-X, r30
     de2:	12 97       	sbiw	r26, 0x02	; 2
     de4:	d9 01       	movw	r26, r18
     de6:	ed 93       	st	X+, r30
     de8:	fc 93       	st	X, r31
        tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
     dea:	dc 01       	movw	r26, r24
     dec:	14 96       	adiw	r26, 0x04	; 4
     dee:	ed 91       	ld	r30, X+
     df0:	fc 91       	ld	r31, X
     df2:	15 97       	sbiw	r26, 0x05	; 5
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       owning thread? */
    while (tp->p_prio < ctp->p_prio) {
     df4:	4c 81       	ldd	r20, Y+4	; 0x04
     df6:	84 81       	ldd	r24, Z+4	; 0x04
     df8:	84 17       	cp	r24, r20
     dfa:	08 f4       	brcc	.+2      	; 0xdfe <chMtxLockS+0x15e>
     dfc:	66 cf       	rjmp	.-308    	; 0xcca <chMtxLockS+0x2a>
     dfe:	6e cf       	rjmp	.-292    	; 0xcdc <chMtxLockS+0x3c>
    chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
    chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
  }
  else {
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
     e00:	fc 01       	movw	r30, r24
     e02:	d5 83       	std	Z+5, r29	; 0x05
     e04:	c4 83       	std	Z+4, r28	; 0x04
    mp->m_next = ctp->p_mtxlist;
     e06:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e08:	9e 8d       	ldd	r25, Y+30	; 0x1e
     e0a:	97 83       	std	Z+7, r25	; 0x07
     e0c:	86 83       	std	Z+6, r24	; 0x06
    ctp->p_mtxlist = mp;
     e0e:	1e 8f       	std	Y+30, r17	; 0x1e
     e10:	0d 8f       	std	Y+29, r16	; 0x1d
  }
}
     e12:	df 91       	pop	r29
     e14:	cf 91       	pop	r28
     e16:	1f 91       	pop	r17
     e18:	0f 91       	pop	r16
     e1a:	08 95       	ret
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
     e1c:	dc 01       	movw	r26, r24
     e1e:	d6 cf       	rjmp	.-84     	; 0xdcc <chMtxLockS+0x12c>

00000e20 <chMtxLock>:
 *
 * @api
 */
void chMtxLock(Mutex *mp) {

  chSysLock();
     e20:	f8 94       	cli

  chMtxLockS(mp);
     e22:	0e 94 50 06 	call	0xca0	; 0xca0 <chMtxLockS>

  chSysUnlock();
     e26:	78 94       	sei
     e28:	08 95       	ret

00000e2a <chMtxTryLock>:
 * @api
 */
bool_t chMtxTryLock(Mutex *mp) {
  bool_t b;

  chSysLock();
     e2a:	f8 94       	cli
bool_t chMtxTryLockS(Mutex *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
     e2c:	dc 01       	movw	r26, r24
     e2e:	14 96       	adiw	r26, 0x04	; 4
     e30:	2d 91       	ld	r18, X+
     e32:	3c 91       	ld	r19, X
     e34:	15 97       	sbiw	r26, 0x05	; 5
     e36:	23 2b       	or	r18, r19
     e38:	19 f0       	breq	.+6      	; 0xe40 <chMtxTryLock+0x16>
    return FALSE;
     e3a:	80 e0       	ldi	r24, 0x00	; 0

  chSysLock();

  b = chMtxTryLockS(mp);

  chSysUnlock();
     e3c:	78 94       	sei
  return b;
}
     e3e:	08 95       	ret
  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
    return FALSE;
  mp->m_owner = currp;
     e40:	e0 91 3c 02 	lds	r30, 0x023C
     e44:	f0 91 3d 02 	lds	r31, 0x023D
     e48:	15 96       	adiw	r26, 0x05	; 5
     e4a:	fc 93       	st	X, r31
     e4c:	ee 93       	st	-X, r30
     e4e:	14 97       	sbiw	r26, 0x04	; 4
  mp->m_next = currp->p_mtxlist;
     e50:	25 8d       	ldd	r18, Z+29	; 0x1d
     e52:	36 8d       	ldd	r19, Z+30	; 0x1e
     e54:	17 96       	adiw	r26, 0x07	; 7
     e56:	3c 93       	st	X, r19
     e58:	2e 93       	st	-X, r18
     e5a:	16 97       	sbiw	r26, 0x06	; 6
  currp->p_mtxlist = mp;
     e5c:	96 8f       	std	Z+30, r25	; 0x1e
     e5e:	85 8f       	std	Z+29, r24	; 0x1d
  return TRUE;
     e60:	81 e0       	ldi	r24, 0x01	; 1

  chSysLock();

  b = chMtxTryLockS(mp);

  chSysUnlock();
     e62:	78 94       	sei
  return b;
}
     e64:	08 95       	ret

00000e66 <chMtxTryLockS>:
bool_t chMtxTryLockS(Mutex *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
     e66:	dc 01       	movw	r26, r24
     e68:	14 96       	adiw	r26, 0x04	; 4
     e6a:	2d 91       	ld	r18, X+
     e6c:	3c 91       	ld	r19, X
     e6e:	15 97       	sbiw	r26, 0x05	; 5
     e70:	23 2b       	or	r18, r19
     e72:	11 f0       	breq	.+4      	; 0xe78 <chMtxTryLockS+0x12>
    return FALSE;
     e74:	80 e0       	ldi	r24, 0x00	; 0
  mp->m_owner = currp;
  mp->m_next = currp->p_mtxlist;
  currp->p_mtxlist = mp;
  return TRUE;
}
     e76:	08 95       	ret
  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
    return FALSE;
  mp->m_owner = currp;
     e78:	e0 91 3c 02 	lds	r30, 0x023C
     e7c:	f0 91 3d 02 	lds	r31, 0x023D
     e80:	15 96       	adiw	r26, 0x05	; 5
     e82:	fc 93       	st	X, r31
     e84:	ee 93       	st	-X, r30
     e86:	14 97       	sbiw	r26, 0x04	; 4
  mp->m_next = currp->p_mtxlist;
     e88:	25 8d       	ldd	r18, Z+29	; 0x1d
     e8a:	36 8d       	ldd	r19, Z+30	; 0x1e
     e8c:	17 96       	adiw	r26, 0x07	; 7
     e8e:	3c 93       	st	X, r19
     e90:	2e 93       	st	-X, r18
     e92:	16 97       	sbiw	r26, 0x06	; 6
  currp->p_mtxlist = mp;
     e94:	96 8f       	std	Z+30, r25	; 0x1e
     e96:	85 8f       	std	Z+29, r24	; 0x1d
  return TRUE;
     e98:	81 e0       	ldi	r24, 0x01	; 1
     e9a:	08 95       	ret

00000e9c <chMtxUnlock>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @api
 */
Mutex *chMtxUnlock(void) {
     e9c:	cf 93       	push	r28
     e9e:	df 93       	push	r29
  Thread *ctp = currp;
     ea0:	80 91 3c 02 	lds	r24, 0x023C
     ea4:	90 91 3d 02 	lds	r25, 0x023D
  Mutex *ump, *mp;

  chSysLock();
     ea8:	f8 94       	cli
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
              "chMtxUnlock(), #2",
              "ownership failure");
  /* Removes the top Mutex from the Thread's owned mutexes list and marks it
     as not owned.*/
  ump = ctp->p_mtxlist;
     eaa:	dc 01       	movw	r26, r24
     eac:	5d 96       	adiw	r26, 0x1d	; 29
     eae:	cd 91       	ld	r28, X+
     eb0:	dc 91       	ld	r29, X
     eb2:	5e 97       	sbiw	r26, 0x1e	; 30
  ctp->p_mtxlist = ump->m_next;
     eb4:	ee 81       	ldd	r30, Y+6	; 0x06
     eb6:	ff 81       	ldd	r31, Y+7	; 0x07
     eb8:	5e 96       	adiw	r26, 0x1e	; 30
     eba:	fc 93       	st	X, r31
     ebc:	ee 93       	st	-X, r30
     ebe:	5d 97       	sbiw	r26, 0x1d	; 29
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
     ec0:	28 81       	ld	r18, Y
     ec2:	39 81       	ldd	r19, Y+1	; 0x01
     ec4:	2c 17       	cp	r18, r28
     ec6:	3d 07       	cpc	r19, r29
     ec8:	89 f1       	breq	.+98     	; 0xf2c <chMtxUnlock+0x90>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
     eca:	5f 96       	adiw	r26, 0x1f	; 31
     ecc:	3c 91       	ld	r19, X
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     ece:	30 97       	sbiw	r30, 0x00	; 0
     ed0:	79 f0       	breq	.+30     	; 0xef0 <chMtxUnlock+0x54>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
     ed2:	a0 81       	ld	r26, Z
     ed4:	b1 81       	ldd	r27, Z+1	; 0x01
     ed6:	ae 17       	cp	r26, r30
     ed8:	bf 07       	cpc	r27, r31
     eda:	29 f0       	breq	.+10     	; 0xee6 <chMtxUnlock+0x4a>
     edc:	14 96       	adiw	r26, 0x04	; 4
     ede:	2c 91       	ld	r18, X
     ee0:	32 17       	cp	r19, r18
     ee2:	08 f4       	brcc	.+2      	; 0xee6 <chMtxUnlock+0x4a>
     ee4:	32 2f       	mov	r19, r18
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
     ee6:	06 80       	ldd	r0, Z+6	; 0x06
     ee8:	f7 81       	ldd	r31, Z+7	; 0x07
     eea:	e0 2d       	mov	r30, r0

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     eec:	30 97       	sbiw	r30, 0x00	; 0
     eee:	89 f7       	brne	.-30     	; 0xed2 <chMtxUnlock+0x36>
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    /* Assigns to the current thread the highest priority among all the
       waiting threads.*/
    ctp->p_prio = newprio;
     ef0:	fc 01       	movw	r30, r24
     ef2:	34 83       	std	Z+4, r19	; 0x04
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     ef4:	e8 81       	ld	r30, Y
     ef6:	f9 81       	ldd	r31, Y+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     ef8:	a0 81       	ld	r26, Z
     efa:	b1 81       	ldd	r27, Z+1	; 0x01
     efc:	b9 83       	std	Y+1, r27	; 0x01
     efe:	a8 83       	st	Y, r26
     f00:	13 96       	adiw	r26, 0x03	; 3
     f02:	dc 93       	st	X, r29
     f04:	ce 93       	st	-X, r28
     f06:	12 97       	sbiw	r26, 0x02	; 2
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    ump->m_owner = tp;
     f08:	fd 83       	std	Y+5, r31	; 0x05
     f0a:	ec 83       	std	Y+4, r30	; 0x04
    ump->m_next = tp->p_mtxlist;
     f0c:	85 8d       	ldd	r24, Z+29	; 0x1d
     f0e:	96 8d       	ldd	r25, Z+30	; 0x1e
     f10:	9f 83       	std	Y+7, r25	; 0x07
     f12:	8e 83       	std	Y+6, r24	; 0x06
    tp->p_mtxlist = ump;
     f14:	d6 8f       	std	Z+30, r29	; 0x1e
     f16:	c5 8f       	std	Z+29, r28	; 0x1d
    chSchWakeupS(tp, RDY_OK);
     f18:	60 e0       	ldi	r22, 0x00	; 0
     f1a:	70 e0       	ldi	r23, 0x00	; 0
     f1c:	cf 01       	movw	r24, r30
     f1e:	0e 94 ba 02 	call	0x574	; 0x574 <chSchWakeupS>
  }
  else
    ump->m_owner = NULL;
  chSysUnlock();
     f22:	78 94       	sei
  return ump;
}
     f24:	ce 01       	movw	r24, r28
     f26:	df 91       	pop	r29
     f28:	cf 91       	pop	r28
     f2a:	08 95       	ret
    ump->m_next = tp->p_mtxlist;
    tp->p_mtxlist = ump;
    chSchWakeupS(tp, RDY_OK);
  }
  else
    ump->m_owner = NULL;
     f2c:	1d 82       	std	Y+5, r1	; 0x05
     f2e:	1c 82       	std	Y+4, r1	; 0x04
  chSysUnlock();
     f30:	78 94       	sei
  return ump;
}
     f32:	ce 01       	movw	r24, r28
     f34:	df 91       	pop	r29
     f36:	cf 91       	pop	r28
     f38:	08 95       	ret

00000f3a <chMtxUnlockS>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @sclass
 */
Mutex *chMtxUnlockS(void) {
     f3a:	cf 93       	push	r28
     f3c:	df 93       	push	r29
  Thread *ctp = currp;
     f3e:	80 91 3c 02 	lds	r24, 0x023C
     f42:	90 91 3d 02 	lds	r25, 0x023D
              "chMtxUnlockS(), #2",
              "ownership failure");

  /* Removes the top Mutex from the owned mutexes list and marks it as not
     owned.*/
  ump = ctp->p_mtxlist;
     f46:	dc 01       	movw	r26, r24
     f48:	5d 96       	adiw	r26, 0x1d	; 29
     f4a:	cd 91       	ld	r28, X+
     f4c:	dc 91       	ld	r29, X
     f4e:	5e 97       	sbiw	r26, 0x1e	; 30
  ctp->p_mtxlist = ump->m_next;
     f50:	ee 81       	ldd	r30, Y+6	; 0x06
     f52:	ff 81       	ldd	r31, Y+7	; 0x07
     f54:	5e 96       	adiw	r26, 0x1e	; 30
     f56:	fc 93       	st	X, r31
     f58:	ee 93       	st	-X, r30
     f5a:	5d 97       	sbiw	r26, 0x1d	; 29
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
     f5c:	28 81       	ld	r18, Y
     f5e:	39 81       	ldd	r19, Y+1	; 0x01
     f60:	2c 17       	cp	r18, r28
     f62:	3d 07       	cpc	r19, r29
     f64:	71 f1       	breq	.+92     	; 0xfc2 <chMtxUnlockS+0x88>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
     f66:	5f 96       	adiw	r26, 0x1f	; 31
     f68:	3c 91       	ld	r19, X
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     f6a:	30 97       	sbiw	r30, 0x00	; 0
     f6c:	79 f0       	breq	.+30     	; 0xf8c <chMtxUnlockS+0x52>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
     f6e:	a0 81       	ld	r26, Z
     f70:	b1 81       	ldd	r27, Z+1	; 0x01
     f72:	ae 17       	cp	r26, r30
     f74:	bf 07       	cpc	r27, r31
     f76:	29 f0       	breq	.+10     	; 0xf82 <chMtxUnlockS+0x48>
     f78:	14 96       	adiw	r26, 0x04	; 4
     f7a:	2c 91       	ld	r18, X
     f7c:	32 17       	cp	r19, r18
     f7e:	08 f4       	brcc	.+2      	; 0xf82 <chMtxUnlockS+0x48>
     f80:	32 2f       	mov	r19, r18
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
     f82:	06 80       	ldd	r0, Z+6	; 0x06
     f84:	f7 81       	ldd	r31, Z+7	; 0x07
     f86:	e0 2d       	mov	r30, r0

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
     f88:	30 97       	sbiw	r30, 0x00	; 0
     f8a:	89 f7       	brne	.-30     	; 0xf6e <chMtxUnlockS+0x34>
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    ctp->p_prio = newprio;
     f8c:	fc 01       	movw	r30, r24
     f8e:	34 83       	std	Z+4, r19	; 0x04
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
     f90:	e8 81       	ld	r30, Y
     f92:	f9 81       	ldd	r31, Y+1	; 0x01

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
     f94:	a0 81       	ld	r26, Z
     f96:	b1 81       	ldd	r27, Z+1	; 0x01
     f98:	b9 83       	std	Y+1, r27	; 0x01
     f9a:	a8 83       	st	Y, r26
     f9c:	13 96       	adiw	r26, 0x03	; 3
     f9e:	dc 93       	st	X, r29
     fa0:	ce 93       	st	-X, r28
     fa2:	12 97       	sbiw	r26, 0x02	; 2
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
    ump->m_owner = tp;
     fa4:	fd 83       	std	Y+5, r31	; 0x05
     fa6:	ec 83       	std	Y+4, r30	; 0x04
    ump->m_next = tp->p_mtxlist;
     fa8:	85 8d       	ldd	r24, Z+29	; 0x1d
     faa:	96 8d       	ldd	r25, Z+30	; 0x1e
     fac:	9f 83       	std	Y+7, r25	; 0x07
     fae:	8e 83       	std	Y+6, r24	; 0x06
    tp->p_mtxlist = ump;
     fb0:	d6 8f       	std	Z+30, r29	; 0x1e
     fb2:	c5 8f       	std	Z+29, r28	; 0x1d
    chSchReadyI(tp);
     fb4:	cf 01       	movw	r24, r30
     fb6:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
  }
  else
    ump->m_owner = NULL;
  return ump;
}
     fba:	ce 01       	movw	r24, r28
     fbc:	df 91       	pop	r29
     fbe:	cf 91       	pop	r28
     fc0:	08 95       	ret
    ump->m_next = tp->p_mtxlist;
    tp->p_mtxlist = ump;
    chSchReadyI(tp);
  }
  else
    ump->m_owner = NULL;
     fc2:	1d 82       	std	Y+5, r1	; 0x05
     fc4:	1c 82       	std	Y+4, r1	; 0x04
  return ump;
}
     fc6:	ce 01       	movw	r24, r28
     fc8:	df 91       	pop	r29
     fca:	cf 91       	pop	r28
     fcc:	08 95       	ret

00000fce <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
     fce:	0f 93       	push	r16
     fd0:	1f 93       	push	r17
     fd2:	cf 93       	push	r28
     fd4:	df 93       	push	r29
  Thread *ctp = currp;
     fd6:	00 91 3c 02 	lds	r16, 0x023C
     fda:	10 91 3d 02 	lds	r17, 0x023D

  chSysLock();
     fde:	f8 94       	cli
  if (ctp->p_mtxlist != NULL) {
     fe0:	d8 01       	movw	r26, r16
     fe2:	5d 96       	adiw	r26, 0x1d	; 29
     fe4:	ed 91       	ld	r30, X+
     fe6:	fc 91       	ld	r31, X
     fe8:	5e 97       	sbiw	r26, 0x1e	; 30
     fea:	30 97       	sbiw	r30, 0x00	; 0
     fec:	f9 f4       	brne	.+62     	; 0x102c <chMtxUnlockAll+0x5e>
     fee:	38 c0       	rjmp	.+112    	; 0x1060 <chMtxUnlockAll+0x92>
     ff0:	8d 91       	ld	r24, X+
     ff2:	9c 91       	ld	r25, X
     ff4:	11 97       	sbiw	r26, 0x01	; 1
     ff6:	91 83       	std	Z+1, r25	; 0x01
     ff8:	80 83       	st	Z, r24
     ffa:	ec 01       	movw	r28, r24
     ffc:	fb 83       	std	Y+3, r31	; 0x03
     ffe:	ea 83       	std	Y+2, r30	; 0x02
    do {
      Mutex *ump = ctp->p_mtxlist;
      ctp->p_mtxlist = ump->m_next;
      if (chMtxQueueNotEmptyS(ump)) {
        Thread *tp = fifo_remove(&ump->m_queue);
        ump->m_owner = tp;
    1000:	b5 83       	std	Z+5, r27	; 0x05
    1002:	a4 83       	std	Z+4, r26	; 0x04
        ump->m_next = tp->p_mtxlist;
    1004:	5d 96       	adiw	r26, 0x1d	; 29
    1006:	8d 91       	ld	r24, X+
    1008:	9c 91       	ld	r25, X
    100a:	5e 97       	sbiw	r26, 0x1e	; 30
    100c:	97 83       	std	Z+7, r25	; 0x07
    100e:	86 83       	std	Z+6, r24	; 0x06
        tp->p_mtxlist = ump;
    1010:	5e 96       	adiw	r26, 0x1e	; 30
    1012:	fc 93       	st	X, r31
    1014:	ee 93       	st	-X, r30
    1016:	5d 97       	sbiw	r26, 0x1d	; 29
        chSchReadyI(tp);
    1018:	cd 01       	movw	r24, r26
    101a:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
      }
      else
        ump->m_owner = NULL;
    } while (ctp->p_mtxlist != NULL);
    101e:	d8 01       	movw	r26, r16
    1020:	5d 96       	adiw	r26, 0x1d	; 29
    1022:	ed 91       	ld	r30, X+
    1024:	fc 91       	ld	r31, X
    1026:	5e 97       	sbiw	r26, 0x1e	; 30
    1028:	30 97       	sbiw	r30, 0x00	; 0
    102a:	99 f0       	breq	.+38     	; 0x1052 <chMtxUnlockAll+0x84>

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      Mutex *ump = ctp->p_mtxlist;
      ctp->p_mtxlist = ump->m_next;
    102c:	86 81       	ldd	r24, Z+6	; 0x06
    102e:	97 81       	ldd	r25, Z+7	; 0x07
    1030:	e8 01       	movw	r28, r16
    1032:	9e 8f       	std	Y+30, r25	; 0x1e
    1034:	8d 8f       	std	Y+29, r24	; 0x1d
      if (chMtxQueueNotEmptyS(ump)) {
    1036:	a0 81       	ld	r26, Z
    1038:	b1 81       	ldd	r27, Z+1	; 0x01
    103a:	ae 17       	cp	r26, r30
    103c:	bf 07       	cpc	r27, r31
    103e:	c1 f6       	brne	.-80     	; 0xff0 <chMtxUnlockAll+0x22>
        ump->m_next = tp->p_mtxlist;
        tp->p_mtxlist = ump;
        chSchReadyI(tp);
      }
      else
        ump->m_owner = NULL;
    1040:	15 82       	std	Z+5, r1	; 0x05
    1042:	14 82       	std	Z+4, r1	; 0x04
    } while (ctp->p_mtxlist != NULL);
    1044:	d8 01       	movw	r26, r16
    1046:	5d 96       	adiw	r26, 0x1d	; 29
    1048:	ed 91       	ld	r30, X+
    104a:	fc 91       	ld	r31, X
    104c:	5e 97       	sbiw	r26, 0x1e	; 30
    104e:	30 97       	sbiw	r30, 0x00	; 0
    1050:	69 f7       	brne	.-38     	; 0x102c <chMtxUnlockAll+0x5e>
    ctp->p_prio = ctp->p_realprio;
    1052:	5f 96       	adiw	r26, 0x1f	; 31
    1054:	8c 91       	ld	r24, X
    1056:	5f 97       	sbiw	r26, 0x1f	; 31
    1058:	14 96       	adiw	r26, 0x04	; 4
    105a:	8c 93       	st	X, r24
    chSchRescheduleS();
    105c:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  }
  chSysUnlock();
    1060:	78 94       	sei
}
    1062:	df 91       	pop	r29
    1064:	cf 91       	pop	r28
    1066:	1f 91       	pop	r17
    1068:	0f 91       	pop	r16
    106a:	08 95       	ret

0000106c <chCondInit>:
 *
 * @param[out] cp       pointer to a @p CondVar structure
 *
 * @init
 */
void chCondInit(CondVar *cp) {
    106c:	fc 01       	movw	r30, r24

  chDbgCheck(cp != NULL, "chCondInit");

  queue_init(&cp->c_queue);
    106e:	82 83       	std	Z+2, r24	; 0x02
    1070:	f3 83       	std	Z+3, r31	; 0x03
    1072:	80 83       	st	Z, r24
    1074:	f1 83       	std	Z+1, r31	; 0x01
    1076:	08 95       	ret

00001078 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @api
 */
void chCondSignal(CondVar *cp) {
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	fc 01       	movw	r30, r24

  chDbgCheck(cp != NULL, "chCondSignal");

  chSysLock();
    107e:	f8 94       	cli
  if (notempty(&cp->c_queue))
    1080:	80 81       	ld	r24, Z
    1082:	91 81       	ldd	r25, Z+1	; 0x01
    1084:	8e 17       	cp	r24, r30
    1086:	9f 07       	cpc	r25, r31
    1088:	69 f0       	breq	.+26     	; 0x10a4 <chCondSignal+0x2c>
    108a:	ec 01       	movw	r28, r24
    108c:	a8 81       	ld	r26, Y
    108e:	b9 81       	ldd	r27, Y+1	; 0x01
    1090:	b1 83       	std	Z+1, r27	; 0x01
    1092:	a0 83       	st	Z, r26
    1094:	13 96       	adiw	r26, 0x03	; 3
    1096:	fc 93       	st	X, r31
    1098:	ee 93       	st	-X, r30
    109a:	12 97       	sbiw	r26, 0x02	; 2
    chSchWakeupS(fifo_remove(&cp->c_queue), RDY_OK);
    109c:	60 e0       	ldi	r22, 0x00	; 0
    109e:	70 e0       	ldi	r23, 0x00	; 0
    10a0:	0e 94 ba 02 	call	0x574	; 0x574 <chSchWakeupS>
  chSysUnlock();
    10a4:	78 94       	sei
}
    10a6:	df 91       	pop	r29
    10a8:	cf 91       	pop	r28
    10aa:	08 95       	ret

000010ac <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @iclass
 */
void chCondSignalI(CondVar *cp) {
    10ac:	cf 93       	push	r28
    10ae:	df 93       	push	r29
    10b0:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(cp != NULL, "chCondSignalI");

  if (notempty(&cp->c_queue))
    10b2:	80 81       	ld	r24, Z
    10b4:	91 81       	ldd	r25, Z+1	; 0x01
    10b6:	8e 17       	cp	r24, r30
    10b8:	9f 07       	cpc	r25, r31
    10ba:	71 f0       	breq	.+28     	; 0x10d8 <chCondSignalI+0x2c>
    10bc:	ec 01       	movw	r28, r24
    10be:	a8 81       	ld	r26, Y
    10c0:	b9 81       	ldd	r27, Y+1	; 0x01
    10c2:	b1 83       	std	Z+1, r27	; 0x01
    10c4:	a0 83       	st	Z, r26
    10c6:	13 96       	adiw	r26, 0x03	; 3
    10c8:	fc 93       	st	X, r31
    10ca:	ee 93       	st	-X, r30
    10cc:	12 97       	sbiw	r26, 0x02	; 2
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_OK;
    10ce:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
    10d2:	fc 01       	movw	r30, r24
    10d4:	13 8a       	std	Z+19, r1	; 0x13
    10d6:	12 8a       	std	Z+18, r1	; 0x12
}
    10d8:	df 91       	pop	r29
    10da:	cf 91       	pop	r28
    10dc:	08 95       	ret

000010de <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p CondVar structure
 *
 * @iclass
 */
void chCondBroadcastI(CondVar *cp) {
    10de:	0f 93       	push	r16
    10e0:	1f 93       	push	r17
    10e2:	cf 93       	push	r28
    10e4:	df 93       	push	r29
    10e6:	ec 01       	movw	r28, r24
  chDbgCheck(cp != NULL, "chCondBroadcastI");

  /* Empties the condition variable queue and inserts all the Threads into the
     ready list in FIFO order. The wakeup message is set to @p RDY_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (cp->c_queue.p_next != (void *)&cp->c_queue)
    10e8:	88 81       	ld	r24, Y
    10ea:	99 81       	ldd	r25, Y+1	; 0x01
    10ec:	8c 17       	cp	r24, r28
    10ee:	9d 07       	cpc	r25, r29
    10f0:	99 f0       	breq	.+38     	; 0x1118 <__stack+0x19>
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_RESET;
    10f2:	0e ef       	ldi	r16, 0xFE	; 254
    10f4:	1f ef       	ldi	r17, 0xFF	; 255
    10f6:	dc 01       	movw	r26, r24
    10f8:	ed 91       	ld	r30, X+
    10fa:	fc 91       	ld	r31, X
    10fc:	f9 83       	std	Y+1, r31	; 0x01
    10fe:	e8 83       	st	Y, r30
    1100:	d3 83       	std	Z+3, r29	; 0x03
    1102:	c2 83       	std	Z+2, r28	; 0x02
    1104:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
    1108:	fc 01       	movw	r30, r24
    110a:	13 8b       	std	Z+19, r17	; 0x13
    110c:	02 8b       	std	Z+18, r16	; 0x12
  chDbgCheck(cp != NULL, "chCondBroadcastI");

  /* Empties the condition variable queue and inserts all the Threads into the
     ready list in FIFO order. The wakeup message is set to @p RDY_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (cp->c_queue.p_next != (void *)&cp->c_queue)
    110e:	88 81       	ld	r24, Y
    1110:	99 81       	ldd	r25, Y+1	; 0x01
    1112:	8c 17       	cp	r24, r28
    1114:	9d 07       	cpc	r25, r29
    1116:	79 f7       	brne	.-34     	; 0x10f6 <chCondBroadcastI+0x18>
    chSchReadyI(fifo_remove(&cp->c_queue))->p_u.rdymsg = RDY_RESET;
}
    1118:	df 91       	pop	r29
    111a:	cf 91       	pop	r28
    111c:	1f 91       	pop	r17
    111e:	0f 91       	pop	r16
    1120:	08 95       	ret

00001122 <chCondBroadcast>:
 *
 * @api
 */
void chCondBroadcast(CondVar *cp) {

  chSysLock();
    1122:	f8 94       	cli
  chCondBroadcastI(cp);
    1124:	0e 94 6f 08 	call	0x10de	; 0x10de <chCondBroadcastI>
  chSchRescheduleS();
    1128:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  chSysUnlock();
    112c:	78 94       	sei
    112e:	08 95       	ret

00001130 <chCondWaitS>:
 * @retval RDY_RESET    if the condvar has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(CondVar *cp) {
    1130:	ef 92       	push	r14
    1132:	ff 92       	push	r15
    1134:	0f 93       	push	r16
    1136:	1f 93       	push	r17
    1138:	cf 93       	push	r28
    113a:	df 93       	push	r29
    113c:	7c 01       	movw	r14, r24
  Thread *ctp = currp;
    113e:	c0 91 3c 02 	lds	r28, 0x023C
    1142:	d0 91 3d 02 	lds	r29, 0x023D
  chDbgCheck(cp != NULL, "chCondWaitS");
  chDbgAssert(ctp->p_mtxlist != NULL,
              "chCondWaitS(), #1",
              "not owning a mutex");

  mp = chMtxUnlockS();
    1146:	0e 94 9d 07 	call	0xf3a	; 0xf3a <chMtxUnlockS>
    114a:	8c 01       	movw	r16, r24
  ctp->p_u.wtobjp = cp;
    114c:	ea 8a       	std	Y+18, r14	; 0x12
    114e:	fb 8a       	std	Y+19, r15	; 0x13
  prio_insert(ctp, &cp->c_queue);
    1150:	d7 01       	movw	r26, r14
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
    1152:	f7 01       	movw	r30, r14
    1154:	04 c0       	rjmp	.+8      	; 0x115e <chCondWaitS+0x2e>
  do {
    cp = cp->p_next;
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    1156:	94 81       	ldd	r25, Z+4	; 0x04
    1158:	8c 81       	ldd	r24, Y+4	; 0x04
    115a:	98 17       	cp	r25, r24
    115c:	28 f1       	brcs	.+74     	; 0x11a8 <chCondWaitS+0x78>
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
    115e:	01 90       	ld	r0, Z+
    1160:	f0 81       	ld	r31, Z
    1162:	e0 2d       	mov	r30, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    1164:	ae 17       	cp	r26, r30
    1166:	bf 07       	cpc	r27, r31
    1168:	b1 f7       	brne	.-20     	; 0x1156 <chCondWaitS+0x26>
  tp->p_next = cp;
    116a:	b9 83       	std	Y+1, r27	; 0x01
    116c:	a8 83       	st	Y, r26
  tp->p_prev = cp->p_prev;
    116e:	12 96       	adiw	r26, 0x02	; 2
    1170:	ed 91       	ld	r30, X+
    1172:	fc 91       	ld	r31, X
    1174:	13 97       	sbiw	r26, 0x03	; 3
    1176:	fb 83       	std	Y+3, r31	; 0x03
    1178:	ea 83       	std	Y+2, r30	; 0x02
  tp->p_prev->p_next = cp->p_prev = tp;
    117a:	13 96       	adiw	r26, 0x03	; 3
    117c:	dc 93       	st	X, r29
    117e:	ce 93       	st	-X, r28
    1180:	12 97       	sbiw	r26, 0x02	; 2
    1182:	d1 83       	std	Z+1, r29	; 0x01
    1184:	c0 83       	st	Z, r28
  chSchGoSleepS(THD_STATE_WTCOND);
    1186:	85 e0       	ldi	r24, 0x05	; 5
    1188:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
    118c:	fa 88       	ldd	r15, Y+18	; 0x12
    118e:	cb 89       	ldd	r28, Y+19	; 0x13
  chMtxLockS(mp);
    1190:	c8 01       	movw	r24, r16
    1192:	0e 94 50 06 	call	0xca0	; 0xca0 <chMtxLockS>
  return msg;
}
    1196:	8f 2d       	mov	r24, r15
    1198:	9c 2f       	mov	r25, r28
    119a:	df 91       	pop	r29
    119c:	cf 91       	pop	r28
    119e:	1f 91       	pop	r17
    11a0:	0f 91       	pop	r16
    11a2:	ff 90       	pop	r15
    11a4:	ef 90       	pop	r14
    11a6:	08 95       	ret
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    11a8:	df 01       	movw	r26, r30
    11aa:	df cf       	rjmp	.-66     	; 0x116a <chCondWaitS+0x3a>

000011ac <chCondWait>:
 * @api
 */
msg_t chCondWait(CondVar *cp) {
  msg_t msg;

  chSysLock();
    11ac:	f8 94       	cli
  msg = chCondWaitS(cp);
    11ae:	0e 94 98 08 	call	0x1130	; 0x1130 <chCondWaitS>
  chSysUnlock();
    11b2:	78 94       	sei
  return msg;
}
    11b4:	08 95       	ret

000011b6 <chCondWaitTimeoutS>:
 * @retval RDY_TIMEOUT  if the condvar has not been signaled within the
 *                      specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(CondVar *cp, systime_t time) {
    11b6:	ef 92       	push	r14
    11b8:	ff 92       	push	r15
    11ba:	0f 93       	push	r16
    11bc:	1f 93       	push	r17
    11be:	cf 93       	push	r28
    11c0:	df 93       	push	r29
    11c2:	00 d0       	rcall	.+0      	; 0x11c4 <chCondWaitTimeoutS+0xe>
    11c4:	cd b7       	in	r28, 0x3d	; 61
    11c6:	de b7       	in	r29, 0x3e	; 62
    11c8:	7c 01       	movw	r14, r24
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE), "chCondWaitTimeoutS");
  chDbgAssert(currp->p_mtxlist != NULL,
              "chCondWaitTimeoutS(), #1",
              "not owning a mutex");

  mp = chMtxUnlockS();
    11ca:	69 83       	std	Y+1, r22	; 0x01
    11cc:	7a 83       	std	Y+2, r23	; 0x02
    11ce:	0e 94 9d 07 	call	0xf3a	; 0xf3a <chMtxUnlockS>
    11d2:	8c 01       	movw	r16, r24
  currp->p_u.wtobjp = cp;
    11d4:	40 91 3c 02 	lds	r20, 0x023C
    11d8:	50 91 3d 02 	lds	r21, 0x023D
    11dc:	da 01       	movw	r26, r20
    11de:	52 96       	adiw	r26, 0x12	; 18
    11e0:	ec 92       	st	X, r14
    11e2:	52 97       	sbiw	r26, 0x12	; 18
    11e4:	53 96       	adiw	r26, 0x13	; 19
    11e6:	fc 92       	st	X, r15
  prio_insert(currp, &cp->c_queue);
    11e8:	97 01       	movw	r18, r14
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {

  Thread *cp = (Thread *)tqp;
    11ea:	f7 01       	movw	r30, r14
    11ec:	7a 81       	ldd	r23, Y+2	; 0x02
    11ee:	69 81       	ldd	r22, Y+1	; 0x01
  do {
    cp = cp->p_next;
    11f0:	01 90       	ld	r0, Z+
    11f2:	f0 81       	ld	r31, Z
    11f4:	e0 2d       	mov	r30, r0
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
    11f6:	2e 17       	cp	r18, r30
    11f8:	3f 07       	cpc	r19, r31
    11fa:	31 f0       	breq	.+12     	; 0x1208 <chCondWaitTimeoutS+0x52>
    11fc:	94 81       	ldd	r25, Z+4	; 0x04
    11fe:	da 01       	movw	r26, r20
    1200:	14 96       	adiw	r26, 0x04	; 4
    1202:	8c 91       	ld	r24, X
    1204:	98 17       	cp	r25, r24
    1206:	a0 f7       	brcc	.-24     	; 0x11f0 <chCondWaitTimeoutS+0x3a>
  tp->p_next = cp;
    1208:	da 01       	movw	r26, r20
    120a:	11 96       	adiw	r26, 0x01	; 1
    120c:	fc 93       	st	X, r31
    120e:	ee 93       	st	-X, r30
  tp->p_prev = cp->p_prev;
    1210:	82 81       	ldd	r24, Z+2	; 0x02
    1212:	93 81       	ldd	r25, Z+3	; 0x03
    1214:	13 96       	adiw	r26, 0x03	; 3
    1216:	9c 93       	st	X, r25
    1218:	8e 93       	st	-X, r24
    121a:	12 97       	sbiw	r26, 0x02	; 2
  tp->p_prev->p_next = cp->p_prev = tp;
    121c:	53 83       	std	Z+3, r21	; 0x03
    121e:	42 83       	std	Z+2, r20	; 0x02
    1220:	fc 01       	movw	r30, r24
    1222:	51 83       	std	Z+1, r21	; 0x01
    1224:	40 83       	st	Z, r20
  msg = chSchGoSleepTimeoutS(THD_STATE_WTCOND, time);
    1226:	85 e0       	ldi	r24, 0x05	; 5
    1228:	0e 94 81 02 	call	0x502	; 0x502 <chSchGoSleepTimeoutS>
    122c:	7c 01       	movw	r14, r24
  if (msg != RDY_TIMEOUT)
    122e:	8f 3f       	cpi	r24, 0xFF	; 255
    1230:	ff ef       	ldi	r31, 0xFF	; 255
    1232:	9f 07       	cpc	r25, r31
    1234:	19 f0       	breq	.+6      	; 0x123c <chCondWaitTimeoutS+0x86>
    chMtxLockS(mp);
    1236:	c8 01       	movw	r24, r16
    1238:	0e 94 50 06 	call	0xca0	; 0xca0 <chMtxLockS>
  return msg;
}
    123c:	c7 01       	movw	r24, r14
    123e:	0f 90       	pop	r0
    1240:	0f 90       	pop	r0
    1242:	df 91       	pop	r29
    1244:	cf 91       	pop	r28
    1246:	1f 91       	pop	r17
    1248:	0f 91       	pop	r16
    124a:	ff 90       	pop	r15
    124c:	ef 90       	pop	r14
    124e:	08 95       	ret

00001250 <chCondWaitTimeout>:
 * @api
 */
msg_t chCondWaitTimeout(CondVar *cp, systime_t time) {
  msg_t msg;

  chSysLock();
    1250:	f8 94       	cli
  msg = chCondWaitTimeoutS(cp, time);
    1252:	0e 94 db 08 	call	0x11b6	; 0x11b6 <chCondWaitTimeoutS>
  chSysUnlock();
    1256:	78 94       	sei
  return msg;
}
    1258:	08 95       	ret

0000125a <chEvtRegisterMask>:
 * @param[in] mask      the mask of event flags to be ORed to the thread when
 *                      the event source is broadcasted
 *
 * @api
 */
void chEvtRegisterMask(EventSource *esp, EventListener *elp, eventmask_t mask) {
    125a:	fb 01       	movw	r30, r22

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtRegisterMask");

  chSysLock();
    125c:	f8 94       	cli
  elp->el_next     = esp->es_next;
    125e:	dc 01       	movw	r26, r24
    1260:	2d 91       	ld	r18, X+
    1262:	3c 91       	ld	r19, X
    1264:	11 97       	sbiw	r26, 0x01	; 1
    1266:	31 83       	std	Z+1, r19	; 0x01
    1268:	20 83       	st	Z, r18
  esp->es_next     = elp;
    126a:	6d 93       	st	X+, r22
    126c:	7c 93       	st	X, r23
  elp->el_listener = currp;
    126e:	80 91 3c 02 	lds	r24, 0x023C
    1272:	90 91 3d 02 	lds	r25, 0x023D
    1276:	93 83       	std	Z+3, r25	; 0x03
    1278:	82 83       	std	Z+2, r24	; 0x02
  elp->el_mask     = mask;
    127a:	44 83       	std	Z+4, r20	; 0x04
  elp->el_flags    = 0;
    127c:	15 82       	std	Z+5, r1	; 0x05
  chSysUnlock();
    127e:	78 94       	sei
    1280:	08 95       	ret

00001282 <chEvtUnregister>:
  EventListener *p;

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
  chSysLock();
    1282:	f8 94       	cli
void chEvtUnregister(EventSource *esp, EventListener *elp) {
  EventListener *p;

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
    1284:	fc 01       	movw	r30, r24
  chSysLock();
  while (p->el_next != (EventListener *)esp) {
    1286:	01 c0       	rjmp	.+2      	; 0x128a <chEvtUnregister+0x8>
    if (p->el_next == elp) {
    1288:	f9 01       	movw	r30, r18

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
  chSysLock();
  while (p->el_next != (EventListener *)esp) {
    128a:	20 81       	ld	r18, Z
    128c:	31 81       	ldd	r19, Z+1	; 0x01
    128e:	28 17       	cp	r18, r24
    1290:	39 07       	cpc	r19, r25
    1292:	41 f0       	breq	.+16     	; 0x12a4 <chEvtUnregister+0x22>
    if (p->el_next == elp) {
    1294:	62 17       	cp	r22, r18
    1296:	73 07       	cpc	r23, r19
    1298:	b9 f7       	brne	.-18     	; 0x1288 <chEvtUnregister+0x6>
      p->el_next = elp->el_next;
    129a:	db 01       	movw	r26, r22
    129c:	8d 91       	ld	r24, X+
    129e:	9c 91       	ld	r25, X
    12a0:	91 83       	std	Z+1, r25	; 0x01
    12a2:	80 83       	st	Z, r24
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
    12a4:	78 94       	sei
    12a6:	08 95       	ret

000012a8 <chEvtGetAndClearEvents>:
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t mask) {
  eventmask_t m;

  chSysLock();
    12a8:	f8 94       	cli

  m = currp->p_epending & mask;
    12aa:	e0 91 3c 02 	lds	r30, 0x023C
    12ae:	f0 91 3d 02 	lds	r31, 0x023D
    12b2:	24 8d       	ldd	r18, Z+28	; 0x1c
  currp->p_epending &= ~mask;
    12b4:	98 2f       	mov	r25, r24
    12b6:	90 95       	com	r25
    12b8:	92 23       	and	r25, r18
    12ba:	94 8f       	std	Z+28, r25	; 0x1c

  chSysUnlock();
    12bc:	78 94       	sei
  return m;
}
    12be:	82 23       	and	r24, r18
    12c0:	08 95       	ret

000012c2 <chEvtAddEvents>:
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t mask) {

  chSysLock();
    12c2:	f8 94       	cli

  mask = (currp->p_epending |= mask);
    12c4:	e0 91 3c 02 	lds	r30, 0x023C
    12c8:	f0 91 3d 02 	lds	r31, 0x023D
    12cc:	94 8d       	ldd	r25, Z+28	; 0x1c
    12ce:	89 2b       	or	r24, r25
    12d0:	84 8f       	std	Z+28, r24	; 0x1c

  chSysUnlock();
    12d2:	78 94       	sei
  return mask;
}
    12d4:	08 95       	ret

000012d6 <chEvtGetAndClearFlags>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
flagsmask_t chEvtGetAndClearFlags(EventListener *elp) {
    12d6:	fc 01       	movw	r30, r24
  flagsmask_t flags;

  chSysLock();
    12d8:	f8 94       	cli

  flags = elp->el_flags;
    12da:	85 81       	ldd	r24, Z+5	; 0x05
  elp->el_flags = 0;
    12dc:	15 82       	std	Z+5, r1	; 0x05

  chSysUnlock();
    12de:	78 94       	sei
  return flags;
}
    12e0:	08 95       	ret

000012e2 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(Thread *tp, eventmask_t mask) {
    12e2:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
    12e4:	84 8d       	ldd	r24, Z+28	; 0x1c
    12e6:	68 2b       	or	r22, r24
    12e8:	64 8f       	std	Z+28, r22	; 0x1c
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
    12ea:	85 85       	ldd	r24, Z+13	; 0x0d
    12ec:	88 30       	cpi	r24, 0x08	; 8
    12ee:	71 f0       	breq	.+28     	; 0x130c <chEvtSignalI+0x2a>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
    12f0:	89 30       	cpi	r24, 0x09	; 9
    12f2:	09 f0       	breq	.+2      	; 0x12f6 <chEvtSignalI+0x14>
    12f4:	08 95       	ret
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    12f6:	82 89       	ldd	r24, Z+18	; 0x12
    12f8:	68 23       	and	r22, r24

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
    12fa:	86 13       	cpse	r24, r22
    12fc:	fb cf       	rjmp	.-10     	; 0x12f4 <chEvtSignalI+0x12>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
    12fe:	cf 01       	movw	r24, r30
    1300:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
    1304:	fc 01       	movw	r30, r24
    1306:	13 8a       	std	Z+19, r1	; 0x13
    1308:	12 8a       	std	Z+18, r1	; 0x12
    130a:	08 95       	ret
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
    130c:	82 89       	ldd	r24, Z+18	; 0x12
    130e:	86 23       	and	r24, r22
  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
    1310:	b1 f7       	brne	.-20     	; 0x12fe <chEvtSignalI+0x1c>
    1312:	08 95       	ret

00001314 <chEvtSignal>:
 */
void chEvtSignal(Thread *tp, eventmask_t mask) {

  chDbgCheck(tp != NULL, "chEvtSignal");

  chSysLock();
    1314:	f8 94       	cli
  chEvtSignalI(tp, mask);
    1316:	0e 94 71 09 	call	0x12e2	; 0x12e2 <chEvtSignalI>
  chSchRescheduleS();
    131a:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  chSysUnlock();
    131e:	78 94       	sei
    1320:	08 95       	ret

00001322 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p EventSource structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(EventSource *esp, flagsmask_t flags) {
    1322:	ff 92       	push	r15
    1324:	0f 93       	push	r16
    1326:	1f 93       	push	r17
    1328:	cf 93       	push	r28
    132a:	df 93       	push	r29
    132c:	8c 01       	movw	r16, r24
    132e:	f6 2e       	mov	r15, r22
  EventListener *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
    1330:	fc 01       	movw	r30, r24
    1332:	c0 81       	ld	r28, Z
    1334:	d1 81       	ldd	r29, Z+1	; 0x01
  while (elp != (EventListener *)esp) {
    1336:	8c 17       	cp	r24, r28
    1338:	9d 07       	cpc	r25, r29
    133a:	71 f0       	breq	.+28     	; 0x1358 <chEvtBroadcastFlagsI+0x36>
    elp->el_flags |= flags;
    133c:	8d 81       	ldd	r24, Y+5	; 0x05
    133e:	8f 29       	or	r24, r15
    1340:	8d 83       	std	Y+5, r24	; 0x05
    chEvtSignalI(elp->el_listener, elp->el_mask);
    1342:	6c 81       	ldd	r22, Y+4	; 0x04
    1344:	8a 81       	ldd	r24, Y+2	; 0x02
    1346:	9b 81       	ldd	r25, Y+3	; 0x03
    1348:	0e 94 71 09 	call	0x12e2	; 0x12e2 <chEvtSignalI>
    elp = elp->el_next;
    134c:	09 90       	ld	r0, Y+
    134e:	d8 81       	ld	r29, Y
    1350:	c0 2d       	mov	r28, r0

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
  while (elp != (EventListener *)esp) {
    1352:	0c 17       	cp	r16, r28
    1354:	1d 07       	cpc	r17, r29
    1356:	91 f7       	brne	.-28     	; 0x133c <chEvtBroadcastFlagsI+0x1a>
    elp->el_flags |= flags;
    chEvtSignalI(elp->el_listener, elp->el_mask);
    elp = elp->el_next;
  }
}
    1358:	df 91       	pop	r29
    135a:	cf 91       	pop	r28
    135c:	1f 91       	pop	r17
    135e:	0f 91       	pop	r16
    1360:	ff 90       	pop	r15
    1362:	08 95       	ret

00001364 <chEvtBroadcastFlags>:
 *
 * @api
 */
void chEvtBroadcastFlags(EventSource *esp, flagsmask_t flags) {

  chSysLock();
    1364:	f8 94       	cli
  chEvtBroadcastFlagsI(esp, flags);
    1366:	0e 94 91 09 	call	0x1322	; 0x1322 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
    136a:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  chSysUnlock();
    136e:	78 94       	sei
    1370:	08 95       	ret

00001372 <chEvtGetAndClearFlagsI>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
flagsmask_t chEvtGetAndClearFlagsI(EventListener *elp) {
    1372:	fc 01       	movw	r30, r24
  flagsmask_t flags;

  flags = elp->el_flags;
    1374:	85 81       	ldd	r24, Z+5	; 0x05
  elp->el_flags = 0;
    1376:	15 82       	std	Z+5, r1	; 0x05

  return flags;
}
    1378:	08 95       	ret

0000137a <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t mask) {
    137a:	ef 92       	push	r14
    137c:	ff 92       	push	r15
    137e:	0f 93       	push	r16
    1380:	1f 93       	push	r17
    1382:	cf 93       	push	r28
    1384:	df 93       	push	r29
    1386:	8c 01       	movw	r16, r24
    1388:	e6 2e       	mov	r14, r22
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    138a:	66 23       	and	r22, r22
    138c:	01 f1       	breq	.+64     	; 0x13ce <chEvtDispatch+0x54>
    138e:	f1 2c       	mov	r15, r1
    if (mask & EVENT_MASK(eid)) {
    1390:	c1 e0       	ldi	r28, 0x01	; 1
    1392:	d0 e0       	ldi	r29, 0x00	; 0
    1394:	03 c0       	rjmp	.+6      	; 0x139c <chEvtDispatch+0x22>
                  "chEvtDispatch(), #1",
                  "null handler");
      mask &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
    1396:	f3 94       	inc	r15
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    1398:	ee 20       	and	r14, r14
    139a:	c9 f0       	breq	.+50     	; 0x13ce <chEvtDispatch+0x54>
    if (mask & EVENT_MASK(eid)) {
    139c:	9e 01       	movw	r18, r28
    139e:	0f 2c       	mov	r0, r15
    13a0:	01 c0       	rjmp	.+2      	; 0x13a4 <chEvtDispatch+0x2a>
    13a2:	22 0f       	add	r18, r18
    13a4:	0a 94       	dec	r0
    13a6:	ea f7       	brpl	.-6      	; 0x13a2 <chEvtDispatch+0x28>
    13a8:	8e 2d       	mov	r24, r14
    13aa:	82 23       	and	r24, r18
    13ac:	a1 f3       	breq	.-24     	; 0x1396 <chEvtDispatch+0x1c>
      chDbgAssert(handlers[eid] != NULL,
                  "chEvtDispatch(), #1",
                  "null handler");
      mask &= ~EVENT_MASK(eid);
    13ae:	20 95       	com	r18
    13b0:	e2 22       	and	r14, r18
      handlers[eid](eid);
    13b2:	ef 2d       	mov	r30, r15
    13b4:	f0 e0       	ldi	r31, 0x00	; 0
    13b6:	ee 0f       	add	r30, r30
    13b8:	ff 1f       	adc	r31, r31
    13ba:	e0 0f       	add	r30, r16
    13bc:	f1 1f       	adc	r31, r17
    13be:	01 90       	ld	r0, Z+
    13c0:	f0 81       	ld	r31, Z
    13c2:	e0 2d       	mov	r30, r0
    13c4:	8f 2d       	mov	r24, r15
    13c6:	09 95       	icall
    }
    eid++;
    13c8:	f3 94       	inc	r15
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
    13ca:	e1 10       	cpse	r14, r1
    13cc:	e7 cf       	rjmp	.-50     	; 0x139c <chEvtDispatch+0x22>
      mask &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
    13ce:	df 91       	pop	r29
    13d0:	cf 91       	pop	r28
    13d2:	1f 91       	pop	r17
    13d4:	0f 91       	pop	r16
    13d6:	ff 90       	pop	r15
    13d8:	ef 90       	pop	r14
    13da:	08 95       	ret

000013dc <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest id served and cleared event.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t mask) {
    13dc:	1f 93       	push	r17
    13de:	cf 93       	push	r28
    13e0:	df 93       	push	r29
    13e2:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    13e4:	c0 91 3c 02 	lds	r28, 0x023C
    13e8:	d0 91 3d 02 	lds	r29, 0x023D
  eventmask_t m;

  chSysLock();
    13ec:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    13ee:	2c 8d       	ldd	r18, Y+28	; 0x1c
    13f0:	98 2f       	mov	r25, r24
    13f2:	92 23       	and	r25, r18
    13f4:	39 f4       	brne	.+14     	; 0x1404 <chEvtWaitOne+0x28>
    ctp->p_u.ewmask = mask;
    13f6:	8a 8b       	std	Y+18, r24	; 0x12
    chSchGoSleepS(THD_STATE_WTOREVT);
    13f8:	88 e0       	ldi	r24, 0x08	; 8
    13fa:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
    m = ctp->p_epending & mask;
    13fe:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1400:	91 2f       	mov	r25, r17
    1402:	92 23       	and	r25, r18
  }
  m &= -m;
    1404:	89 2f       	mov	r24, r25
    1406:	81 95       	neg	r24
    1408:	89 23       	and	r24, r25
  ctp->p_epending &= ~m;
    140a:	98 2f       	mov	r25, r24
    140c:	90 95       	com	r25
    140e:	92 23       	and	r25, r18
    1410:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    1412:	78 94       	sei
  return m;
}
    1414:	df 91       	pop	r29
    1416:	cf 91       	pop	r28
    1418:	1f 91       	pop	r17
    141a:	08 95       	ret

0000141c <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
    141c:	1f 93       	push	r17
    141e:	cf 93       	push	r28
    1420:	df 93       	push	r29
    1422:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    1424:	c0 91 3c 02 	lds	r28, 0x023C
    1428:	d0 91 3d 02 	lds	r29, 0x023D
  eventmask_t m;

  chSysLock();
    142c:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    142e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1430:	82 23       	and	r24, r18
    1432:	39 f4       	brne	.+14     	; 0x1442 <chEvtWaitAny+0x26>
    ctp->p_u.ewmask = mask;
    1434:	1a 8b       	std	Y+18, r17	; 0x12
    chSchGoSleepS(THD_STATE_WTOREVT);
    1436:	88 e0       	ldi	r24, 0x08	; 8
    1438:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
    m = ctp->p_epending & mask;
    143c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    143e:	81 2f       	mov	r24, r17
    1440:	82 23       	and	r24, r18
  }
  ctp->p_epending &= ~m;
    1442:	98 2f       	mov	r25, r24
    1444:	90 95       	com	r25
    1446:	92 23       	and	r25, r18
    1448:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    144a:	78 94       	sei
  return m;
}
    144c:	df 91       	pop	r29
    144e:	cf 91       	pop	r28
    1450:	1f 91       	pop	r17
    1452:	08 95       	ret

00001454 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t mask) {
    1454:	1f 93       	push	r17
    1456:	cf 93       	push	r28
    1458:	df 93       	push	r29
    145a:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    145c:	c0 91 3c 02 	lds	r28, 0x023C
    1460:	d0 91 3d 02 	lds	r29, 0x023D

  chSysLock();
    1464:	f8 94       	cli

  if ((ctp->p_epending & mask) != mask) {
    1466:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1468:	89 23       	and	r24, r25
    146a:	81 17       	cp	r24, r17
    146c:	29 f0       	breq	.+10     	; 0x1478 <chEvtWaitAll+0x24>
    ctp->p_u.ewmask = mask;
    146e:	1a 8b       	std	Y+18, r17	; 0x12
    chSchGoSleepS(THD_STATE_WTANDEVT);
    1470:	89 e0       	ldi	r24, 0x09	; 9
    1472:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
    1476:	9c 8d       	ldd	r25, Y+28	; 0x1c
  }
  ctp->p_epending &= ~mask;
    1478:	81 2f       	mov	r24, r17
    147a:	80 95       	com	r24
    147c:	89 23       	and	r24, r25
    147e:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    1480:	78 94       	sei
  return mask;
}
    1482:	81 2f       	mov	r24, r17
    1484:	df 91       	pop	r29
    1486:	cf 91       	pop	r28
    1488:	1f 91       	pop	r17
    148a:	08 95       	ret

0000148c <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest id served and cleared event.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t mask, systime_t time) {
    148c:	0f 93       	push	r16
    148e:	1f 93       	push	r17
    1490:	cf 93       	push	r28
    1492:	df 93       	push	r29
    1494:	08 2f       	mov	r16, r24
  Thread *ctp = currp;
    1496:	c0 91 3c 02 	lds	r28, 0x023C
    149a:	d0 91 3d 02 	lds	r29, 0x023D
  eventmask_t m;

  chSysLock();
    149e:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    14a0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    14a2:	18 2f       	mov	r17, r24
    14a4:	19 23       	and	r17, r25
    14a6:	99 f4       	brne	.+38     	; 0x14ce <chEvtWaitOneTimeout+0x42>
    if (TIME_IMMEDIATE == time) {
    14a8:	61 15       	cp	r22, r1
    14aa:	71 05       	cpc	r23, r1
    14ac:	39 f4       	brne	.+14     	; 0x14bc <chEvtWaitOneTimeout+0x30>
    m = ctp->p_epending & mask;
  }
  m &= -m;
  ctp->p_epending &= ~m;

  chSysUnlock();
    14ae:	78 94       	sei
  return m;
}
    14b0:	81 2f       	mov	r24, r17
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	08 95       	ret
  if ((m = (ctp->p_epending & mask)) == 0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    14bc:	8a 8b       	std	Y+18, r24	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
    14be:	88 e0       	ldi	r24, 0x08	; 8
    14c0:	0e 94 81 02 	call	0x502	; 0x502 <chSchGoSleepTimeoutS>
    14c4:	97 fd       	sbrc	r25, 7
    14c6:	f3 cf       	rjmp	.-26     	; 0x14ae <chEvtWaitOneTimeout+0x22>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & mask;
    14c8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    14ca:	10 2f       	mov	r17, r16
    14cc:	19 23       	and	r17, r25
  }
  m &= -m;
    14ce:	81 2f       	mov	r24, r17
    14d0:	81 95       	neg	r24
    14d2:	18 23       	and	r17, r24
  ctp->p_epending &= ~m;
    14d4:	81 2f       	mov	r24, r17
    14d6:	80 95       	com	r24
    14d8:	89 23       	and	r24, r25
    14da:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    14dc:	78 94       	sei
  return m;
}
    14de:	81 2f       	mov	r24, r17
    14e0:	df 91       	pop	r29
    14e2:	cf 91       	pop	r28
    14e4:	1f 91       	pop	r17
    14e6:	0f 91       	pop	r16
    14e8:	08 95       	ret

000014ea <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t time) {
    14ea:	0f 93       	push	r16
    14ec:	1f 93       	push	r17
    14ee:	cf 93       	push	r28
    14f0:	df 93       	push	r29
    14f2:	08 2f       	mov	r16, r24
  Thread *ctp = currp;
    14f4:	c0 91 3c 02 	lds	r28, 0x023C
    14f8:	d0 91 3d 02 	lds	r29, 0x023D
  eventmask_t m;

  chSysLock();
    14fc:	f8 94       	cli

  if ((m = (ctp->p_epending & mask)) == 0) {
    14fe:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1500:	18 2f       	mov	r17, r24
    1502:	19 23       	and	r17, r25
    1504:	99 f4       	brne	.+38     	; 0x152c <chEvtWaitAnyTimeout+0x42>
    if (TIME_IMMEDIATE == time) {
    1506:	61 15       	cp	r22, r1
    1508:	71 05       	cpc	r23, r1
    150a:	39 f4       	brne	.+14     	; 0x151a <chEvtWaitAnyTimeout+0x30>
    }
    m = ctp->p_epending & mask;
  }
  ctp->p_epending &= ~m;

  chSysUnlock();
    150c:	78 94       	sei
  return m;
}
    150e:	81 2f       	mov	r24, r17
    1510:	df 91       	pop	r29
    1512:	cf 91       	pop	r28
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	08 95       	ret
  if ((m = (ctp->p_epending & mask)) == 0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    151a:	8a 8b       	std	Y+18, r24	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
    151c:	88 e0       	ldi	r24, 0x08	; 8
    151e:	0e 94 81 02 	call	0x502	; 0x502 <chSchGoSleepTimeoutS>
    1522:	97 fd       	sbrc	r25, 7
    1524:	f3 cf       	rjmp	.-26     	; 0x150c <chEvtWaitAnyTimeout+0x22>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & mask;
    1526:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1528:	10 2f       	mov	r17, r16
    152a:	19 23       	and	r17, r25
  }
  ctp->p_epending &= ~m;
    152c:	81 2f       	mov	r24, r17
    152e:	80 95       	com	r24
    1530:	89 23       	and	r24, r25
    1532:	8c 8f       	std	Y+28, r24	; 0x1c

  chSysUnlock();
    1534:	78 94       	sei
  return m;
}
    1536:	81 2f       	mov	r24, r17
    1538:	df 91       	pop	r29
    153a:	cf 91       	pop	r28
    153c:	1f 91       	pop	r17
    153e:	0f 91       	pop	r16
    1540:	08 95       	ret

00001542 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t mask, systime_t time) {
    1542:	1f 93       	push	r17
    1544:	cf 93       	push	r28
    1546:	df 93       	push	r29
    1548:	18 2f       	mov	r17, r24
  Thread *ctp = currp;
    154a:	c0 91 3c 02 	lds	r28, 0x023C
    154e:	d0 91 3d 02 	lds	r29, 0x023D

  chSysLock();
    1552:	f8 94       	cli

  if ((ctp->p_epending & mask) != mask) {
    1554:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1556:	91 2f       	mov	r25, r17
    1558:	98 23       	and	r25, r24
    155a:	91 17       	cp	r25, r17
    155c:	89 f0       	breq	.+34     	; 0x1580 <chEvtWaitAllTimeout+0x3e>
    if (TIME_IMMEDIATE == time) {
    155e:	61 15       	cp	r22, r1
    1560:	71 05       	cpc	r23, r1
    1562:	39 f4       	brne	.+14     	; 0x1572 <chEvtWaitAllTimeout+0x30>
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    if (chSchGoSleepTimeoutS(THD_STATE_WTANDEVT, time) < RDY_OK) {
      chSysUnlock();
    1564:	78 94       	sei
      return (eventmask_t)0;
    1566:	10 e0       	ldi	r17, 0x00	; 0
  }
  ctp->p_epending &= ~mask;

  chSysUnlock();
  return mask;
}
    1568:	81 2f       	mov	r24, r17
    156a:	df 91       	pop	r29
    156c:	cf 91       	pop	r28
    156e:	1f 91       	pop	r17
    1570:	08 95       	ret
  if ((ctp->p_epending & mask) != mask) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = mask;
    1572:	1a 8b       	std	Y+18, r17	; 0x12
    if (chSchGoSleepTimeoutS(THD_STATE_WTANDEVT, time) < RDY_OK) {
    1574:	89 e0       	ldi	r24, 0x09	; 9
    1576:	0e 94 81 02 	call	0x502	; 0x502 <chSchGoSleepTimeoutS>
    157a:	97 fd       	sbrc	r25, 7
    157c:	f3 cf       	rjmp	.-26     	; 0x1564 <chEvtWaitAllTimeout+0x22>
    157e:	8c 8d       	ldd	r24, Y+28	; 0x1c
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~mask;
    1580:	91 2f       	mov	r25, r17
    1582:	90 95       	com	r25
    1584:	98 23       	and	r25, r24
    1586:	9c 8f       	std	Y+28, r25	; 0x1c

  chSysUnlock();
    1588:	78 94       	sei
  return mask;
}
    158a:	81 2f       	mov	r24, r17
    158c:	df 91       	pop	r29
    158e:	cf 91       	pop	r28
    1590:	1f 91       	pop	r17
    1592:	08 95       	ret

00001594 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(Thread *tp, msg_t msg) {
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	fc 01       	movw	r30, r24
  Thread *ctp = currp;
    159a:	c0 91 3c 02 	lds	r28, 0x023C
    159e:	d0 91 3d 02 	lds	r29, 0x023D

  chDbgCheck(tp != NULL, "chMsgSend");

  chSysLock();
    15a2:	f8 94       	cli
  ctp->p_msg = msg;
    15a4:	7b 8f       	std	Y+27, r23	; 0x1b
    15a6:	6a 8f       	std	Y+26, r22	; 0x1a
  ctp->p_u.wtobjp = &tp->p_msgqueue;
    15a8:	46 96       	adiw	r24, 0x16	; 22
    15aa:	9b 8b       	std	Y+19, r25	; 0x13
    15ac:	8a 8b       	std	Y+18, r24	; 0x12
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
    15ae:	99 83       	std	Y+1, r25	; 0x01
    15b0:	88 83       	st	Y, r24
  tp->p_prev = tqp->p_prev;
    15b2:	a0 8d       	ldd	r26, Z+24	; 0x18
    15b4:	b1 8d       	ldd	r27, Z+25	; 0x19
    15b6:	bb 83       	std	Y+3, r27	; 0x03
    15b8:	aa 83       	std	Y+2, r26	; 0x02
  tp->p_prev->p_next = tqp->p_prev = tp;
    15ba:	d1 8f       	std	Z+25, r29	; 0x19
    15bc:	c0 8f       	std	Z+24, r28	; 0x18
    15be:	cd 93       	st	X+, r28
    15c0:	dc 93       	st	X, r29
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == THD_STATE_WTMSG)
    15c2:	85 85       	ldd	r24, Z+13	; 0x0d
    15c4:	8c 30       	cpi	r24, 0x0C	; 12
    15c6:	49 f0       	breq	.+18     	; 0x15da <chMsgSend+0x46>
    chSchReadyI(tp);
  chSchGoSleepS(THD_STATE_SNDMSGQ);
    15c8:	8a e0       	ldi	r24, 0x0A	; 10
    15ca:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
    15ce:	8a 89       	ldd	r24, Y+18	; 0x12
    15d0:	9b 89       	ldd	r25, Y+19	; 0x13
  chSysUnlock();
    15d2:	78 94       	sei
  return msg;
}
    15d4:	df 91       	pop	r29
    15d6:	cf 91       	pop	r28
    15d8:	08 95       	ret
  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == THD_STATE_WTMSG)
    chSchReadyI(tp);
    15da:	cf 01       	movw	r24, r30
    15dc:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
    15e0:	f3 cf       	rjmp	.-26     	; 0x15c8 <chMsgSend+0x34>

000015e2 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
Thread *chMsgWait(void) {
    15e2:	cf 93       	push	r28
    15e4:	df 93       	push	r29
  Thread *tp;

  chSysLock();
    15e6:	f8 94       	cli
  if (!chMsgIsPendingI(currp))
    15e8:	a0 91 3c 02 	lds	r26, 0x023C
    15ec:	b0 91 3d 02 	lds	r27, 0x023D
    15f0:	56 96       	adiw	r26, 0x16	; 22
    15f2:	ed 91       	ld	r30, X+
    15f4:	fc 91       	ld	r31, X
    15f6:	57 97       	sbiw	r26, 0x17	; 23
    15f8:	cd 01       	movw	r24, r26
    15fa:	46 96       	adiw	r24, 0x16	; 22
    15fc:	e8 17       	cp	r30, r24
    15fe:	f9 07       	cpc	r31, r25
    1600:	79 f0       	breq	.+30     	; 0x1620 <chMsgWait+0x3e>
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    1602:	c0 81       	ld	r28, Z
    1604:	d1 81       	ldd	r29, Z+1	; 0x01
    1606:	57 96       	adiw	r26, 0x17	; 23
    1608:	dc 93       	st	X, r29
    160a:	ce 93       	st	-X, r28
    160c:	56 97       	sbiw	r26, 0x16	; 22
    160e:	9b 83       	std	Y+3, r25	; 0x03
    1610:	8a 83       	std	Y+2, r24	; 0x02
    chSchGoSleepS(THD_STATE_WTMSG);
  tp = fifo_remove(&currp->p_msgqueue);
  tp->p_state = THD_STATE_SNDMSG;
    1612:	8b e0       	ldi	r24, 0x0B	; 11
    1614:	85 87       	std	Z+13, r24	; 0x0d
  chSysUnlock();
    1616:	78 94       	sei
  return tp;
}
    1618:	cf 01       	movw	r24, r30
    161a:	df 91       	pop	r29
    161c:	cf 91       	pop	r28
    161e:	08 95       	ret
Thread *chMsgWait(void) {
  Thread *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp))
    chSchGoSleepS(THD_STATE_WTMSG);
    1620:	8c e0       	ldi	r24, 0x0C	; 12
    1622:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
    1626:	a0 91 3c 02 	lds	r26, 0x023C
    162a:	b0 91 3d 02 	lds	r27, 0x023D
    162e:	56 96       	adiw	r26, 0x16	; 22
    1630:	ed 91       	ld	r30, X+
    1632:	fc 91       	ld	r31, X
    1634:	57 97       	sbiw	r26, 0x17	; 23
    1636:	cd 01       	movw	r24, r26
    1638:	46 96       	adiw	r24, 0x16	; 22
    163a:	e3 cf       	rjmp	.-58     	; 0x1602 <chMsgWait+0x20>

0000163c <chMsgRelease>:
 *
 * @api
 */
void chMsgRelease(Thread *tp, msg_t msg) {

  chSysLock();
    163c:	f8 94       	cli
  chDbgAssert(tp->p_state == THD_STATE_SNDMSG,
              "chMsgRelease(), #1", "invalid state");
  chMsgReleaseS(tp, msg);
    163e:	0e 94 ba 02 	call	0x574	; 0x574 <chSchWakeupS>
  chSysUnlock();
    1642:	78 94       	sei
    1644:	08 95       	ret

00001646 <chMBInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBInit(Mailbox *mbp, msg_t *buf, cnt_t n) {
    1646:	cf 93       	push	r28
    1648:	df 93       	push	r29
    164a:	ec 01       	movw	r28, r24

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0), "chMBInit");

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
    164c:	7f 83       	std	Y+7, r23	; 0x07
    164e:	6e 83       	std	Y+6, r22	; 0x06
    1650:	7d 83       	std	Y+5, r23	; 0x05
    1652:	6c 83       	std	Y+4, r22	; 0x04
    1654:	79 83       	std	Y+1, r23	; 0x01
    1656:	68 83       	st	Y, r22
  mbp->mb_top = &buf[n];
    1658:	24 2f       	mov	r18, r20
    165a:	22 0f       	add	r18, r18
    165c:	33 0b       	sbc	r19, r19
    165e:	26 0f       	add	r18, r22
    1660:	37 1f       	adc	r19, r23
    1662:	3b 83       	std	Y+3, r19	; 0x03
    1664:	2a 83       	std	Y+2, r18	; 0x02
  chSemInit(&mbp->mb_emptysem, n);
    1666:	64 2f       	mov	r22, r20
    1668:	0d 96       	adiw	r24, 0x0d	; 13
    166a:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <chSemInit>
  chSemInit(&mbp->mb_fullsem, 0);
    166e:	60 e0       	ldi	r22, 0x00	; 0
    1670:	ce 01       	movw	r24, r28
    1672:	08 96       	adiw	r24, 0x08	; 8
}
    1674:	df 91       	pop	r29
    1676:	cf 91       	pop	r28
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0), "chMBInit");

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
  mbp->mb_top = &buf[n];
  chSemInit(&mbp->mb_emptysem, n);
  chSemInit(&mbp->mb_fullsem, 0);
    1678:	0c 94 f9 04 	jmp	0x9f2	; 0x9f2 <chSemInit>

0000167c <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized Mailbox object
 *
 * @api
 */
void chMBReset(Mailbox *mbp) {
    167c:	cf 93       	push	r28
    167e:	df 93       	push	r29
    1680:	ec 01       	movw	r28, r24

  chDbgCheck(mbp != NULL, "chMBReset");

  chSysLock();
    1682:	f8 94       	cli
  mbp->mb_wrptr = mbp->mb_rdptr = mbp->mb_buffer;
    1684:	88 81       	ld	r24, Y
    1686:	99 81       	ldd	r25, Y+1	; 0x01
    1688:	9f 83       	std	Y+7, r25	; 0x07
    168a:	8e 83       	std	Y+6, r24	; 0x06
    168c:	9d 83       	std	Y+5, r25	; 0x05
    168e:	8c 83       	std	Y+4, r24	; 0x04
  chSemResetI(&mbp->mb_emptysem, mbp->mb_top - mbp->mb_buffer);
    1690:	6a 81       	ldd	r22, Y+2	; 0x02
    1692:	7b 81       	ldd	r23, Y+3	; 0x03
    1694:	68 1b       	sub	r22, r24
    1696:	79 0b       	sbc	r23, r25
    1698:	75 95       	asr	r23
    169a:	67 95       	ror	r22
    169c:	ce 01       	movw	r24, r28
    169e:	0d 96       	adiw	r24, 0x0d	; 13
    16a0:	0e 94 00 05 	call	0xa00	; 0xa00 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, 0);
    16a4:	60 e0       	ldi	r22, 0x00	; 0
    16a6:	ce 01       	movw	r24, r28
    16a8:	08 96       	adiw	r24, 0x08	; 8
    16aa:	0e 94 00 05 	call	0xa00	; 0xa00 <chSemResetI>
  chSchRescheduleS();
    16ae:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  chSysUnlock();
    16b2:	78 94       	sei
}
    16b4:	df 91       	pop	r29
    16b6:	cf 91       	pop	r28
    16b8:	08 95       	ret

000016ba <chMBPostS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(Mailbox *mbp, msg_t msg, systime_t time) {
    16ba:	ef 92       	push	r14
    16bc:	ff 92       	push	r15
    16be:	0f 93       	push	r16
    16c0:	1f 93       	push	r17
    16c2:	cf 93       	push	r28
    16c4:	df 93       	push	r29
    16c6:	ec 01       	movw	r28, r24
    16c8:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL, "chMBPostS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
    16ca:	ba 01       	movw	r22, r20
    16cc:	0d 96       	adiw	r24, 0x0d	; 13
    16ce:	0e 94 63 05 	call	0xac6	; 0xac6 <chSemWaitTimeoutS>
    16d2:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    16d4:	00 97       	sbiw	r24, 0x00	; 0
    16d6:	89 f4       	brne	.+34     	; 0x16fa <chMBPostS+0x40>
    *mbp->mb_wrptr++ = msg;
    16d8:	ec 81       	ldd	r30, Y+4	; 0x04
    16da:	fd 81       	ldd	r31, Y+5	; 0x05
    16dc:	e1 92       	st	Z+, r14
    16de:	f1 92       	st	Z+, r15
    16e0:	fd 83       	std	Y+5, r31	; 0x05
    16e2:	ec 83       	std	Y+4, r30	; 0x04
    if (mbp->mb_wrptr >= mbp->mb_top)
    16e4:	8a 81       	ldd	r24, Y+2	; 0x02
    16e6:	9b 81       	ldd	r25, Y+3	; 0x03
    16e8:	e8 17       	cp	r30, r24
    16ea:	f9 07       	cpc	r31, r25
    16ec:	70 f4       	brcc	.+28     	; 0x170a <chMBPostS+0x50>
      mbp->mb_wrptr = mbp->mb_buffer;
    chSemSignalI(&mbp->mb_fullsem);
    16ee:	ce 01       	movw	r24, r28
    16f0:	08 96       	adiw	r24, 0x08	; 8
    16f2:	0e 94 b8 05 	call	0xb70	; 0xb70 <chSemSignalI>
    chSchRescheduleS();
    16f6:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  }
  return rdymsg;
}
    16fa:	c8 01       	movw	r24, r16
    16fc:	df 91       	pop	r29
    16fe:	cf 91       	pop	r28
    1700:	1f 91       	pop	r17
    1702:	0f 91       	pop	r16
    1704:	ff 90       	pop	r15
    1706:	ef 90       	pop	r14
    1708:	08 95       	ret

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == RDY_OK) {
    *mbp->mb_wrptr++ = msg;
    if (mbp->mb_wrptr >= mbp->mb_top)
      mbp->mb_wrptr = mbp->mb_buffer;
    170a:	88 81       	ld	r24, Y
    170c:	99 81       	ldd	r25, Y+1	; 0x01
    170e:	9d 83       	std	Y+5, r25	; 0x05
    1710:	8c 83       	std	Y+4, r24	; 0x04
    1712:	ed cf       	rjmp	.-38     	; 0x16ee <chMBPostS+0x34>

00001714 <chMBPost>:
 * @api
 */
msg_t chMBPost(Mailbox *mbp, msg_t msg, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    1714:	f8 94       	cli
  rdymsg = chMBPostS(mbp, msg, time);
    1716:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <chMBPostS>
  chSysUnlock();
    171a:	78 94       	sei
  return rdymsg;
}
    171c:	08 95       	ret

0000171e <chMBPostI>:
 * @retval RDY_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(Mailbox *mbp, msg_t msg) {
    171e:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    1720:	81 89       	ldd	r24, Z+17	; 0x11
    1722:	18 16       	cp	r1, r24
    1724:	d4 f4       	brge	.+52     	; 0x175a <chMBPostI+0x3c>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
    1726:	81 50       	subi	r24, 0x01	; 1
    1728:	81 8b       	std	Z+17, r24	; 0x11
  *mbp->mb_wrptr++ = msg;
    172a:	a4 81       	ldd	r26, Z+4	; 0x04
    172c:	b5 81       	ldd	r27, Z+5	; 0x05
    172e:	6d 93       	st	X+, r22
    1730:	7d 93       	st	X+, r23
    1732:	b5 83       	std	Z+5, r27	; 0x05
    1734:	a4 83       	std	Z+4, r26	; 0x04
  if (mbp->mb_wrptr >= mbp->mb_top)
    1736:	82 81       	ldd	r24, Z+2	; 0x02
    1738:	93 81       	ldd	r25, Z+3	; 0x03
    173a:	a8 17       	cp	r26, r24
    173c:	b9 07       	cpc	r27, r25
    173e:	40 f4       	brcc	.+16     	; 0x1750 <chMBPostI+0x32>
    mbp->mb_wrptr = mbp->mb_buffer;
  chSemSignalI(&mbp->mb_fullsem);
    1740:	cf 01       	movw	r24, r30
    1742:	08 96       	adiw	r24, 0x08	; 8
    1744:	0e 94 b8 05 	call	0xb70	; 0xb70 <chSemSignalI>
  return RDY_OK;
    1748:	20 e0       	ldi	r18, 0x00	; 0
    174a:	30 e0       	ldi	r19, 0x00	; 0
}
    174c:	c9 01       	movw	r24, r18
    174e:	08 95       	ret
  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top)
    mbp->mb_wrptr = mbp->mb_buffer;
    1750:	80 81       	ld	r24, Z
    1752:	91 81       	ldd	r25, Z+1	; 0x01
    1754:	95 83       	std	Z+5, r25	; 0x05
    1756:	84 83       	std	Z+4, r24	; 0x04
    1758:	f3 cf       	rjmp	.-26     	; 0x1740 <chMBPostI+0x22>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
    175a:	2f ef       	ldi	r18, 0xFF	; 255
    175c:	3f ef       	ldi	r19, 0xFF	; 255
    175e:	f6 cf       	rjmp	.-20     	; 0x174c <chMBPostI+0x2e>

00001760 <chMBPostAheadS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(Mailbox *mbp, msg_t msg, systime_t time) {
    1760:	ef 92       	push	r14
    1762:	ff 92       	push	r15
    1764:	0f 93       	push	r16
    1766:	1f 93       	push	r17
    1768:	cf 93       	push	r28
    176a:	df 93       	push	r29
    176c:	ec 01       	movw	r28, r24
    176e:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL, "chMBPostAheadS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
    1770:	ba 01       	movw	r22, r20
    1772:	0d 96       	adiw	r24, 0x0d	; 13
    1774:	0e 94 63 05 	call	0xac6	; 0xac6 <chSemWaitTimeoutS>
    1778:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    177a:	00 97       	sbiw	r24, 0x00	; 0
    177c:	91 f4       	brne	.+36     	; 0x17a2 <chMBPostAheadS+0x42>
    if (--mbp->mb_rdptr < mbp->mb_buffer)
    177e:	ee 81       	ldd	r30, Y+6	; 0x06
    1780:	ff 81       	ldd	r31, Y+7	; 0x07
    1782:	32 97       	sbiw	r30, 0x02	; 2
    1784:	ff 83       	std	Y+7, r31	; 0x07
    1786:	ee 83       	std	Y+6, r30	; 0x06
    1788:	88 81       	ld	r24, Y
    178a:	99 81       	ldd	r25, Y+1	; 0x01
    178c:	e8 17       	cp	r30, r24
    178e:	f9 07       	cpc	r31, r25
    1790:	80 f0       	brcs	.+32     	; 0x17b2 <chMBPostAheadS+0x52>
      mbp->mb_rdptr = mbp->mb_top - 1;
    *mbp->mb_rdptr = msg;
    1792:	f1 82       	std	Z+1, r15	; 0x01
    1794:	e0 82       	st	Z, r14
    chSemSignalI(&mbp->mb_fullsem);
    1796:	ce 01       	movw	r24, r28
    1798:	08 96       	adiw	r24, 0x08	; 8
    179a:	0e 94 b8 05 	call	0xb70	; 0xb70 <chSemSignalI>
    chSchRescheduleS();
    179e:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  }
  return rdymsg;
}
    17a2:	c8 01       	movw	r24, r16
    17a4:	df 91       	pop	r29
    17a6:	cf 91       	pop	r28
    17a8:	1f 91       	pop	r17
    17aa:	0f 91       	pop	r16
    17ac:	ff 90       	pop	r15
    17ae:	ef 90       	pop	r14
    17b0:	08 95       	ret
  chDbgCheck(mbp != NULL, "chMBPostAheadS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == RDY_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer)
      mbp->mb_rdptr = mbp->mb_top - 1;
    17b2:	ea 81       	ldd	r30, Y+2	; 0x02
    17b4:	fb 81       	ldd	r31, Y+3	; 0x03
    17b6:	32 97       	sbiw	r30, 0x02	; 2
    17b8:	ff 83       	std	Y+7, r31	; 0x07
    17ba:	ee 83       	std	Y+6, r30	; 0x06
    17bc:	ea cf       	rjmp	.-44     	; 0x1792 <chMBPostAheadS+0x32>

000017be <chMBPostAhead>:
 * @api
 */
msg_t chMBPostAhead(Mailbox *mbp, msg_t msg, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    17be:	f8 94       	cli
  rdymsg = chMBPostAheadS(mbp, msg, time);
    17c0:	0e 94 b0 0b 	call	0x1760	; 0x1760 <chMBPostAheadS>
  chSysUnlock();
    17c4:	78 94       	sei
  return rdymsg;
}
    17c6:	08 95       	ret

000017c8 <chMBPostAheadI>:
 * @retval RDY_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(Mailbox *mbp, msg_t msg) {
    17c8:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostAheadI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    17ca:	81 89       	ldd	r24, Z+17	; 0x11
    17cc:	18 16       	cp	r1, r24
    17ce:	e4 f4       	brge	.+56     	; 0x1808 <chMBPostAheadI+0x40>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
    17d0:	81 50       	subi	r24, 0x01	; 1
    17d2:	81 8b       	std	Z+17, r24	; 0x11
  if (--mbp->mb_rdptr < mbp->mb_buffer)
    17d4:	a6 81       	ldd	r26, Z+6	; 0x06
    17d6:	b7 81       	ldd	r27, Z+7	; 0x07
    17d8:	12 97       	sbiw	r26, 0x02	; 2
    17da:	b7 83       	std	Z+7, r27	; 0x07
    17dc:	a6 83       	std	Z+6, r26	; 0x06
    17de:	80 81       	ld	r24, Z
    17e0:	91 81       	ldd	r25, Z+1	; 0x01
    17e2:	a8 17       	cp	r26, r24
    17e4:	b9 07       	cpc	r27, r25
    17e6:	50 f0       	brcs	.+20     	; 0x17fc <chMBPostAheadI+0x34>
    mbp->mb_rdptr = mbp->mb_top - 1;
  *mbp->mb_rdptr = msg;
    17e8:	6d 93       	st	X+, r22
    17ea:	7c 93       	st	X, r23
  chSemSignalI(&mbp->mb_fullsem);
    17ec:	cf 01       	movw	r24, r30
    17ee:	08 96       	adiw	r24, 0x08	; 8
    17f0:	0e 94 b8 05 	call	0xb70	; 0xb70 <chSemSignalI>
  return RDY_OK;
    17f4:	20 e0       	ldi	r18, 0x00	; 0
    17f6:	30 e0       	ldi	r19, 0x00	; 0
}
    17f8:	c9 01       	movw	r24, r18
    17fa:	08 95       	ret

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer)
    mbp->mb_rdptr = mbp->mb_top - 1;
    17fc:	a2 81       	ldd	r26, Z+2	; 0x02
    17fe:	b3 81       	ldd	r27, Z+3	; 0x03
    1800:	12 97       	sbiw	r26, 0x02	; 2
    1802:	b7 83       	std	Z+7, r27	; 0x07
    1804:	a6 83       	std	Z+6, r26	; 0x06
    1806:	f0 cf       	rjmp	.-32     	; 0x17e8 <chMBPostAheadI+0x20>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL, "chMBPostAheadI");

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0)
    return RDY_TIMEOUT;
    1808:	2f ef       	ldi	r18, 0xFF	; 255
    180a:	3f ef       	ldi	r19, 0xFF	; 255
    180c:	f5 cf       	rjmp	.-22     	; 0x17f8 <chMBPostAheadI+0x30>

0000180e <chMBFetchS>:
 * @retval RDY_RESET    if the mailbox has been reset while waiting.
 * @retval RDY_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(Mailbox *mbp, msg_t *msgp, systime_t time) {
    180e:	ef 92       	push	r14
    1810:	ff 92       	push	r15
    1812:	0f 93       	push	r16
    1814:	1f 93       	push	r17
    1816:	cf 93       	push	r28
    1818:	df 93       	push	r29
    181a:	ec 01       	movw	r28, r24
    181c:	7b 01       	movw	r14, r22
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchS");

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
    181e:	ba 01       	movw	r22, r20
    1820:	08 96       	adiw	r24, 0x08	; 8
    1822:	0e 94 63 05 	call	0xac6	; 0xac6 <chSemWaitTimeoutS>
    1826:	8c 01       	movw	r16, r24
  if (rdymsg == RDY_OK) {
    1828:	00 97       	sbiw	r24, 0x00	; 0
    182a:	a1 f4       	brne	.+40     	; 0x1854 <chMBFetchS+0x46>
    *msgp = *mbp->mb_rdptr++;
    182c:	ee 81       	ldd	r30, Y+6	; 0x06
    182e:	ff 81       	ldd	r31, Y+7	; 0x07
    1830:	81 91       	ld	r24, Z+
    1832:	91 91       	ld	r25, Z+
    1834:	d7 01       	movw	r26, r14
    1836:	8d 93       	st	X+, r24
    1838:	9c 93       	st	X, r25
    183a:	ff 83       	std	Y+7, r31	; 0x07
    183c:	ee 83       	std	Y+6, r30	; 0x06
    if (mbp->mb_rdptr >= mbp->mb_top)
    183e:	8a 81       	ldd	r24, Y+2	; 0x02
    1840:	9b 81       	ldd	r25, Y+3	; 0x03
    1842:	e8 17       	cp	r30, r24
    1844:	f9 07       	cpc	r31, r25
    1846:	70 f4       	brcc	.+28     	; 0x1864 <chMBFetchS+0x56>
      mbp->mb_rdptr = mbp->mb_buffer;
    chSemSignalI(&mbp->mb_emptysem);
    1848:	ce 01       	movw	r24, r28
    184a:	0d 96       	adiw	r24, 0x0d	; 13
    184c:	0e 94 b8 05 	call	0xb70	; 0xb70 <chSemSignalI>
    chSchRescheduleS();
    1850:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  }
  return rdymsg;
}
    1854:	c8 01       	movw	r24, r16
    1856:	df 91       	pop	r29
    1858:	cf 91       	pop	r28
    185a:	1f 91       	pop	r17
    185c:	0f 91       	pop	r16
    185e:	ff 90       	pop	r15
    1860:	ef 90       	pop	r14
    1862:	08 95       	ret

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == RDY_OK) {
    *msgp = *mbp->mb_rdptr++;
    if (mbp->mb_rdptr >= mbp->mb_top)
      mbp->mb_rdptr = mbp->mb_buffer;
    1864:	88 81       	ld	r24, Y
    1866:	99 81       	ldd	r25, Y+1	; 0x01
    1868:	9f 83       	std	Y+7, r25	; 0x07
    186a:	8e 83       	std	Y+6, r24	; 0x06
    186c:	ed cf       	rjmp	.-38     	; 0x1848 <chMBFetchS+0x3a>

0000186e <chMBFetch>:
 * @api
 */
msg_t chMBFetch(Mailbox *mbp, msg_t *msgp, systime_t time) {
  msg_t rdymsg;

  chSysLock();
    186e:	f8 94       	cli
  rdymsg = chMBFetchS(mbp, msgp, time);
    1870:	0e 94 07 0c 	call	0x180e	; 0x180e <chMBFetchS>
  chSysUnlock();
    1874:	78 94       	sei
  return rdymsg;
}
    1876:	08 95       	ret

00001878 <chMBFetchI>:
 * @retval RDY_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(Mailbox *mbp, msg_t *msgp) {
    1878:	cf 93       	push	r28
    187a:	df 93       	push	r29
    187c:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchI");

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    187e:	84 85       	ldd	r24, Z+12	; 0x0c
    1880:	18 16       	cp	r1, r24
    1882:	fc f4       	brge	.+62     	; 0x18c2 <chMBFetchI+0x4a>
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_fullsem);
    1884:	81 50       	subi	r24, 0x01	; 1
    1886:	84 87       	std	Z+12, r24	; 0x0c
  *msgp = *mbp->mb_rdptr++;
    1888:	a6 81       	ldd	r26, Z+6	; 0x06
    188a:	b7 81       	ldd	r27, Z+7	; 0x07
    188c:	8d 91       	ld	r24, X+
    188e:	9d 91       	ld	r25, X+
    1890:	eb 01       	movw	r28, r22
    1892:	99 83       	std	Y+1, r25	; 0x01
    1894:	88 83       	st	Y, r24
    1896:	b7 83       	std	Z+7, r27	; 0x07
    1898:	a6 83       	std	Z+6, r26	; 0x06
  if (mbp->mb_rdptr >= mbp->mb_top)
    189a:	82 81       	ldd	r24, Z+2	; 0x02
    189c:	93 81       	ldd	r25, Z+3	; 0x03
    189e:	a8 17       	cp	r26, r24
    18a0:	b9 07       	cpc	r27, r25
    18a2:	50 f4       	brcc	.+20     	; 0x18b8 <chMBFetchI+0x40>
    mbp->mb_rdptr = mbp->mb_buffer;
  chSemSignalI(&mbp->mb_emptysem);
    18a4:	cf 01       	movw	r24, r30
    18a6:	0d 96       	adiw	r24, 0x0d	; 13
    18a8:	0e 94 b8 05 	call	0xb70	; 0xb70 <chSemSignalI>
  return RDY_OK;
    18ac:	20 e0       	ldi	r18, 0x00	; 0
    18ae:	30 e0       	ldi	r19, 0x00	; 0
}
    18b0:	c9 01       	movw	r24, r18
    18b2:	df 91       	pop	r29
    18b4:	cf 91       	pop	r28
    18b6:	08 95       	ret
  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    return RDY_TIMEOUT;
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top)
    mbp->mb_rdptr = mbp->mb_buffer;
    18b8:	80 81       	ld	r24, Z
    18ba:	91 81       	ldd	r25, Z+1	; 0x01
    18bc:	97 83       	std	Z+7, r25	; 0x07
    18be:	86 83       	std	Z+6, r24	; 0x06
    18c0:	f1 cf       	rjmp	.-30     	; 0x18a4 <chMBFetchI+0x2c>

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL), "chMBFetchI");

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0)
    return RDY_TIMEOUT;
    18c2:	2f ef       	ldi	r18, 0xFF	; 255
    18c4:	3f ef       	ldi	r19, 0xFF	; 255
    18c6:	f4 cf       	rjmp	.-24     	; 0x18b0 <chMBFetchI+0x38>

000018c8 <qwait>:
 *                      released from threads queue.
 * @retval Q_OK         is the normal exit, thread signaled.
 * @retval Q_RESET      if the queue has been reset.
 * @retval Q_TIMEOUT    if the queue operation timed out.
 */
static msg_t qwait(GenericQueue *qp, systime_t time) {
    18c8:	cf 93       	push	r28
    18ca:	df 93       	push	r29

  if (TIME_IMMEDIATE == time)
    18cc:	61 15       	cp	r22, r1
    18ce:	71 05       	cpc	r23, r1
    18d0:	b1 f0       	breq	.+44     	; 0x18fe <qwait+0x36>
    return Q_TIMEOUT;
  currp->p_u.wtobjp = qp;
    18d2:	e0 91 3c 02 	lds	r30, 0x023C
    18d6:	f0 91 3d 02 	lds	r31, 0x023D
    18da:	93 8b       	std	Z+19, r25	; 0x13
    18dc:	82 8b       	std	Z+18, r24	; 0x12
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
    18de:	91 83       	std	Z+1, r25	; 0x01
    18e0:	80 83       	st	Z, r24
  tp->p_prev = tqp->p_prev;
    18e2:	ec 01       	movw	r28, r24
    18e4:	aa 81       	ldd	r26, Y+2	; 0x02
    18e6:	bb 81       	ldd	r27, Y+3	; 0x03
    18e8:	b3 83       	std	Z+3, r27	; 0x03
    18ea:	a2 83       	std	Z+2, r26	; 0x02
  tp->p_prev->p_next = tqp->p_prev = tp;
    18ec:	fb 83       	std	Y+3, r31	; 0x03
    18ee:	ea 83       	std	Y+2, r30	; 0x02
    18f0:	ed 93       	st	X+, r30
    18f2:	fc 93       	st	X, r31
  queue_insert(currp, &qp->q_waiting);
  return chSchGoSleepTimeoutS(THD_STATE_WTQUEUE, time);
    18f4:	8d e0       	ldi	r24, 0x0D	; 13
}
    18f6:	df 91       	pop	r29
    18f8:	cf 91       	pop	r28

  if (TIME_IMMEDIATE == time)
    return Q_TIMEOUT;
  currp->p_u.wtobjp = qp;
  queue_insert(currp, &qp->q_waiting);
  return chSchGoSleepTimeoutS(THD_STATE_WTQUEUE, time);
    18fa:	0c 94 81 02 	jmp	0x502	; 0x502 <chSchGoSleepTimeoutS>
}
    18fe:	8f ef       	ldi	r24, 0xFF	; 255
    1900:	9f ef       	ldi	r25, 0xFF	; 255
    1902:	df 91       	pop	r29
    1904:	cf 91       	pop	r28
    1906:	08 95       	ret

00001908 <chIQInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQInit(InputQueue *iqp, uint8_t *bp, size_t size, qnotify_t infy,
              void *link) {
    1908:	0f 93       	push	r16
    190a:	1f 93       	push	r17
    190c:	fc 01       	movw	r30, r24

  queue_init(&iqp->q_waiting);
    190e:	82 83       	std	Z+2, r24	; 0x02
    1910:	f3 83       	std	Z+3, r31	; 0x03
    1912:	80 83       	st	Z, r24
    1914:	f1 83       	std	Z+1, r31	; 0x01
  iqp->q_counter = 0;
    1916:	15 82       	std	Z+5, r1	; 0x05
    1918:	14 82       	std	Z+4, r1	; 0x04
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
    191a:	73 87       	std	Z+11, r23	; 0x0b
    191c:	62 87       	std	Z+10, r22	; 0x0a
    191e:	75 87       	std	Z+13, r23	; 0x0d
    1920:	64 87       	std	Z+12, r22	; 0x0c
    1922:	77 83       	std	Z+7, r23	; 0x07
    1924:	66 83       	std	Z+6, r22	; 0x06
  iqp->q_top = bp + size;
    1926:	46 0f       	add	r20, r22
    1928:	57 1f       	adc	r21, r23
    192a:	51 87       	std	Z+9, r21	; 0x09
    192c:	40 87       	std	Z+8, r20	; 0x08
  iqp->q_notify = infy;
    192e:	37 87       	std	Z+15, r19	; 0x0f
    1930:	26 87       	std	Z+14, r18	; 0x0e
  iqp->q_link = link;
    1932:	11 8b       	std	Z+17, r17	; 0x11
    1934:	00 8b       	std	Z+16, r16	; 0x10
}
    1936:	1f 91       	pop	r17
    1938:	0f 91       	pop	r16
    193a:	08 95       	ret

0000193c <chIQResetI>:
 *
 * @param[in] iqp       pointer to an @p InputQueue structure
 *
 * @iclass
 */
void chIQResetI(InputQueue *iqp) {
    193c:	0f 93       	push	r16
    193e:	1f 93       	push	r17
    1940:	cf 93       	push	r28
    1942:	df 93       	push	r29
    1944:	ec 01       	movw	r28, r24

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
    1946:	8e 81       	ldd	r24, Y+6	; 0x06
    1948:	9f 81       	ldd	r25, Y+7	; 0x07
    194a:	9b 87       	std	Y+11, r25	; 0x0b
    194c:	8a 87       	std	Y+10, r24	; 0x0a
    194e:	9d 87       	std	Y+13, r25	; 0x0d
    1950:	8c 87       	std	Y+12, r24	; 0x0c
  iqp->q_counter = 0;
    1952:	1d 82       	std	Y+5, r1	; 0x05
    1954:	1c 82       	std	Y+4, r1	; 0x04
  while (notempty(&iqp->q_waiting))
    1956:	88 81       	ld	r24, Y
    1958:	99 81       	ldd	r25, Y+1	; 0x01
    195a:	8c 17       	cp	r24, r28
    195c:	9d 07       	cpc	r25, r29
    195e:	99 f0       	breq	.+38     	; 0x1986 <chIQResetI+0x4a>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_RESET;
    1960:	0e ef       	ldi	r16, 0xFE	; 254
    1962:	1f ef       	ldi	r17, 0xFF	; 255
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
    1964:	dc 01       	movw	r26, r24
    1966:	ed 91       	ld	r30, X+
    1968:	fc 91       	ld	r31, X
    196a:	f9 83       	std	Y+1, r31	; 0x01
    196c:	e8 83       	st	Y, r30
    196e:	d3 83       	std	Z+3, r29	; 0x03
    1970:	c2 83       	std	Z+2, r28	; 0x02
    1972:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
    1976:	fc 01       	movw	r30, r24
    1978:	13 8b       	std	Z+19, r17	; 0x13
    197a:	02 8b       	std	Z+18, r16	; 0x12

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
  while (notempty(&iqp->q_waiting))
    197c:	88 81       	ld	r24, Y
    197e:	99 81       	ldd	r25, Y+1	; 0x01
    1980:	8c 17       	cp	r24, r28
    1982:	9d 07       	cpc	r25, r29
    1984:	79 f7       	brne	.-34     	; 0x1964 <chIQResetI+0x28>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_RESET;
}
    1986:	df 91       	pop	r29
    1988:	cf 91       	pop	r28
    198a:	1f 91       	pop	r17
    198c:	0f 91       	pop	r16
    198e:	08 95       	ret

00001990 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(InputQueue *iqp, uint8_t b) {
    1990:	cf 93       	push	r28
    1992:	df 93       	push	r29
    1994:	fc 01       	movw	r30, r24

  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
    1996:	a2 85       	ldd	r26, Z+10	; 0x0a
    1998:	b3 85       	ldd	r27, Z+11	; 0x0b
    199a:	84 85       	ldd	r24, Z+12	; 0x0c
    199c:	95 85       	ldd	r25, Z+13	; 0x0d
    199e:	a8 17       	cp	r26, r24
    19a0:	b9 07       	cpc	r27, r25
    19a2:	a9 f1       	breq	.+106    	; 0x1a0e <chIQPutI+0x7e>
    19a4:	84 81       	ldd	r24, Z+4	; 0x04
    19a6:	95 81       	ldd	r25, Z+5	; 0x05
    return Q_FULL;

  iqp->q_counter++;
    19a8:	01 96       	adiw	r24, 0x01	; 1
    19aa:	95 83       	std	Z+5, r25	; 0x05
    19ac:	84 83       	std	Z+4, r24	; 0x04
  *iqp->q_wrptr++ = b;
    19ae:	6d 93       	st	X+, r22
    19b0:	b3 87       	std	Z+11, r27	; 0x0b
    19b2:	a2 87       	std	Z+10, r26	; 0x0a
  if (iqp->q_wrptr >= iqp->q_top)
    19b4:	80 85       	ldd	r24, Z+8	; 0x08
    19b6:	91 85       	ldd	r25, Z+9	; 0x09
    19b8:	a8 17       	cp	r26, r24
    19ba:	b9 07       	cpc	r27, r25
    19bc:	c8 f4       	brcc	.+50     	; 0x19f0 <chIQPutI+0x60>
    iqp->q_wrptr = iqp->q_buffer;

  if (notempty(&iqp->q_waiting))
    19be:	80 81       	ld	r24, Z
    19c0:	91 81       	ldd	r25, Z+1	; 0x01
    19c2:	8e 17       	cp	r24, r30
    19c4:	9f 07       	cpc	r25, r31
    19c6:	e9 f0       	breq	.+58     	; 0x1a02 <chIQPutI+0x72>
    19c8:	ec 01       	movw	r28, r24
    19ca:	a8 81       	ld	r26, Y
    19cc:	b9 81       	ldd	r27, Y+1	; 0x01
    19ce:	b1 83       	std	Z+1, r27	; 0x01
    19d0:	a0 83       	st	Z, r26
    19d2:	13 96       	adiw	r26, 0x03	; 3
    19d4:	fc 93       	st	X, r31
    19d6:	ee 93       	st	-X, r30
    19d8:	12 97       	sbiw	r26, 0x02	; 2
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;
    19da:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
    19de:	fc 01       	movw	r30, r24
    19e0:	13 8a       	std	Z+19, r1	; 0x13
    19e2:	12 8a       	std	Z+18, r1	; 0x12

  return Q_OK;
    19e4:	20 e0       	ldi	r18, 0x00	; 0
    19e6:	30 e0       	ldi	r19, 0x00	; 0
}
    19e8:	c9 01       	movw	r24, r18
    19ea:	df 91       	pop	r29
    19ec:	cf 91       	pop	r28
    19ee:	08 95       	ret
    return Q_FULL;

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top)
    iqp->q_wrptr = iqp->q_buffer;
    19f0:	86 81       	ldd	r24, Z+6	; 0x06
    19f2:	97 81       	ldd	r25, Z+7	; 0x07
    19f4:	93 87       	std	Z+11, r25	; 0x0b
    19f6:	82 87       	std	Z+10, r24	; 0x0a

  if (notempty(&iqp->q_waiting))
    19f8:	80 81       	ld	r24, Z
    19fa:	91 81       	ldd	r25, Z+1	; 0x01
    19fc:	8e 17       	cp	r24, r30
    19fe:	9f 07       	cpc	r25, r31
    1a00:	19 f7       	brne	.-58     	; 0x19c8 <chIQPutI+0x38>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;

  return Q_OK;
    1a02:	20 e0       	ldi	r18, 0x00	; 0
    1a04:	30 e0       	ldi	r19, 0x00	; 0
}
    1a06:	c9 01       	movw	r24, r18
    1a08:	df 91       	pop	r29
    1a0a:	cf 91       	pop	r28
    1a0c:	08 95       	ret
 */
msg_t chIQPutI(InputQueue *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
    1a0e:	84 81       	ldd	r24, Z+4	; 0x04
    1a10:	95 81       	ldd	r25, Z+5	; 0x05
    1a12:	89 2b       	or	r24, r25
    1a14:	19 f4       	brne	.+6      	; 0x1a1c <chIQPutI+0x8c>
    1a16:	80 e0       	ldi	r24, 0x00	; 0
    1a18:	90 e0       	ldi	r25, 0x00	; 0
    1a1a:	c6 cf       	rjmp	.-116    	; 0x19a8 <chIQPutI+0x18>
    return Q_FULL;
    1a1c:	2c ef       	ldi	r18, 0xFC	; 252
    1a1e:	3f ef       	ldi	r19, 0xFF	; 255
    1a20:	e3 cf       	rjmp	.-58     	; 0x19e8 <chIQPutI+0x58>

00001a22 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(InputQueue *iqp, systime_t time) {
    1a22:	0f 93       	push	r16
    1a24:	1f 93       	push	r17
    1a26:	cf 93       	push	r28
    1a28:	df 93       	push	r29
    1a2a:	ec 01       	movw	r28, r24
    1a2c:	8b 01       	movw	r16, r22
  uint8_t b;

  chSysLock();
    1a2e:	f8 94       	cli
  if (iqp->q_notify)
    1a30:	ee 85       	ldd	r30, Y+14	; 0x0e
    1a32:	ff 85       	ldd	r31, Y+15	; 0x0f
    1a34:	30 97       	sbiw	r30, 0x00	; 0
    1a36:	09 f0       	breq	.+2      	; 0x1a3a <chIQGetTimeout+0x18>
    iqp->q_notify(iqp);
    1a38:	09 95       	icall

  while (chIQIsEmptyI(iqp)) {
    1a3a:	8c 81       	ldd	r24, Y+4	; 0x04
    1a3c:	9d 81       	ldd	r25, Y+5	; 0x05
    1a3e:	00 97       	sbiw	r24, 0x00	; 0
    1a40:	71 f4       	brne	.+28     	; 0x1a5e <chIQGetTimeout+0x3c>
    msg_t msg;
    if ((msg = qwait((GenericQueue *)iqp, time)) < Q_OK) {
    1a42:	b8 01       	movw	r22, r16
    1a44:	ce 01       	movw	r24, r28
    1a46:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <qwait>
    1a4a:	9c 01       	movw	r18, r24
    1a4c:	97 ff       	sbrs	r25, 7
    1a4e:	f5 cf       	rjmp	.-22     	; 0x1a3a <chIQGetTimeout+0x18>
      chSysUnlock();
    1a50:	78 94       	sei
  if (iqp->q_rdptr >= iqp->q_top)
    iqp->q_rdptr = iqp->q_buffer;

  chSysUnlock();
  return b;
}
    1a52:	c9 01       	movw	r24, r18
    1a54:	df 91       	pop	r29
    1a56:	cf 91       	pop	r28
    1a58:	1f 91       	pop	r17
    1a5a:	0f 91       	pop	r16
    1a5c:	08 95       	ret
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
    1a5e:	01 97       	sbiw	r24, 0x01	; 1
    1a60:	9d 83       	std	Y+5, r25	; 0x05
    1a62:	8c 83       	std	Y+4, r24	; 0x04
  b = *iqp->q_rdptr++;
    1a64:	ec 85       	ldd	r30, Y+12	; 0x0c
    1a66:	fd 85       	ldd	r31, Y+13	; 0x0d
    1a68:	21 91       	ld	r18, Z+
    1a6a:	fd 87       	std	Y+13, r31	; 0x0d
    1a6c:	ec 87       	std	Y+12, r30	; 0x0c
  if (iqp->q_rdptr >= iqp->q_top)
    1a6e:	88 85       	ldd	r24, Y+8	; 0x08
    1a70:	99 85       	ldd	r25, Y+9	; 0x09
    1a72:	e8 17       	cp	r30, r24
    1a74:	f9 07       	cpc	r31, r25
    1a76:	20 f0       	brcs	.+8      	; 0x1a80 <chIQGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
    1a78:	8e 81       	ldd	r24, Y+6	; 0x06
    1a7a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a7c:	9d 87       	std	Y+13, r25	; 0x0d
    1a7e:	8c 87       	std	Y+12, r24	; 0x0c

  chSysUnlock();
    1a80:	78 94       	sei
  return b;
    1a82:	30 e0       	ldi	r19, 0x00	; 0
}
    1a84:	c9 01       	movw	r24, r18
    1a86:	df 91       	pop	r29
    1a88:	cf 91       	pop	r28
    1a8a:	1f 91       	pop	r17
    1a8c:	0f 91       	pop	r16
    1a8e:	08 95       	ret

00001a90 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
    1a90:	8f 92       	push	r8
    1a92:	9f 92       	push	r9
    1a94:	af 92       	push	r10
    1a96:	bf 92       	push	r11
    1a98:	cf 92       	push	r12
    1a9a:	df 92       	push	r13
    1a9c:	ef 92       	push	r14
    1a9e:	ff 92       	push	r15
    1aa0:	0f 93       	push	r16
    1aa2:	1f 93       	push	r17
    1aa4:	cf 93       	push	r28
    1aa6:	df 93       	push	r29
    1aa8:	ec 01       	movw	r28, r24
    1aaa:	5b 01       	movw	r10, r22
    1aac:	4a 01       	movw	r8, r20
    1aae:	89 01       	movw	r16, r18
  qnotify_t nfy = iqp->q_notify;
    1ab0:	ce 84       	ldd	r12, Y+14	; 0x0e
    1ab2:	df 84       	ldd	r13, Y+15	; 0x0f
  size_t r = 0;

  chDbgCheck(n > 0, "chIQReadTimeout");

  chSysLock();
    1ab4:	f8 94       	cli
 * @api
 */
size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
    1ab6:	e1 2c       	mov	r14, r1
    1ab8:	f1 2c       	mov	r15, r1

  chDbgCheck(n > 0, "chIQReadTimeout");

  chSysLock();
  while (TRUE) {
    if (nfy)
    1aba:	c1 14       	cp	r12, r1
    1abc:	d1 04       	cpc	r13, r1
    1abe:	19 f0       	breq	.+6      	; 0x1ac6 <chIQReadTimeout+0x36>
      nfy(iqp);
    1ac0:	ce 01       	movw	r24, r28
    1ac2:	f6 01       	movw	r30, r12
    1ac4:	09 95       	icall

    while (chIQIsEmptyI(iqp)) {
    1ac6:	8c 81       	ldd	r24, Y+4	; 0x04
    1ac8:	9d 81       	ldd	r25, Y+5	; 0x05
    1aca:	00 97       	sbiw	r24, 0x00	; 0
    1acc:	a9 f4       	brne	.+42     	; 0x1af8 <chIQReadTimeout+0x68>
      if (qwait((GenericQueue *)iqp, time) != Q_OK) {
    1ace:	b8 01       	movw	r22, r16
    1ad0:	ce 01       	movw	r24, r28
    1ad2:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <qwait>
    1ad6:	89 2b       	or	r24, r25
    1ad8:	b1 f3       	breq	.-20     	; 0x1ac6 <chIQReadTimeout+0x36>
        chSysUnlock();
    1ada:	78 94       	sei
    if (--n == 0)
      return r;

    chSysLock();
  }
}
    1adc:	c7 01       	movw	r24, r14
    1ade:	df 91       	pop	r29
    1ae0:	cf 91       	pop	r28
    1ae2:	1f 91       	pop	r17
    1ae4:	0f 91       	pop	r16
    1ae6:	ff 90       	pop	r15
    1ae8:	ef 90       	pop	r14
    1aea:	df 90       	pop	r13
    1aec:	cf 90       	pop	r12
    1aee:	bf 90       	pop	r11
    1af0:	af 90       	pop	r10
    1af2:	9f 90       	pop	r9
    1af4:	8f 90       	pop	r8
    1af6:	08 95       	ret
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
    1af8:	01 97       	sbiw	r24, 0x01	; 1
    1afa:	9d 83       	std	Y+5, r25	; 0x05
    1afc:	8c 83       	std	Y+4, r24	; 0x04
    *bp++ = *iqp->q_rdptr++;
    1afe:	ec 85       	ldd	r30, Y+12	; 0x0c
    1b00:	fd 85       	ldd	r31, Y+13	; 0x0d
    1b02:	81 91       	ld	r24, Z+
    1b04:	d5 01       	movw	r26, r10
    1b06:	8d 93       	st	X+, r24
    1b08:	5d 01       	movw	r10, r26
    1b0a:	fd 87       	std	Y+13, r31	; 0x0d
    1b0c:	ec 87       	std	Y+12, r30	; 0x0c
    if (iqp->q_rdptr >= iqp->q_top)
    1b0e:	88 85       	ldd	r24, Y+8	; 0x08
    1b10:	99 85       	ldd	r25, Y+9	; 0x09
    1b12:	e8 17       	cp	r30, r24
    1b14:	f9 07       	cpc	r31, r25
    1b16:	48 f4       	brcc	.+18     	; 0x1b2a <chIQReadTimeout+0x9a>
      iqp->q_rdptr = iqp->q_buffer;

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    1b18:	78 94       	sei
    r++;
    1b1a:	bf ef       	ldi	r27, 0xFF	; 255
    1b1c:	eb 1a       	sub	r14, r27
    1b1e:	fb 0a       	sbc	r15, r27
    if (--n == 0)
    1b20:	8e 14       	cp	r8, r14
    1b22:	9f 04       	cpc	r9, r15
    1b24:	d9 f2       	breq	.-74     	; 0x1adc <chIQReadTimeout+0x4c>
      return r;

    chSysLock();
    1b26:	f8 94       	cli
  }
    1b28:	c8 cf       	rjmp	.-112    	; 0x1aba <chIQReadTimeout+0x2a>
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
    if (iqp->q_rdptr >= iqp->q_top)
      iqp->q_rdptr = iqp->q_buffer;
    1b2a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b2c:	9f 81       	ldd	r25, Y+7	; 0x07
    1b2e:	9d 87       	std	Y+13, r25	; 0x0d
    1b30:	8c 87       	std	Y+12, r24	; 0x0c
    1b32:	f2 cf       	rjmp	.-28     	; 0x1b18 <chIQReadTimeout+0x88>

00001b34 <chOQInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQInit(OutputQueue *oqp, uint8_t *bp, size_t size, qnotify_t onfy,
              void *link) {
    1b34:	0f 93       	push	r16
    1b36:	1f 93       	push	r17
    1b38:	fc 01       	movw	r30, r24

  queue_init(&oqp->q_waiting);
    1b3a:	82 83       	std	Z+2, r24	; 0x02
    1b3c:	f3 83       	std	Z+3, r31	; 0x03
    1b3e:	80 83       	st	Z, r24
    1b40:	f1 83       	std	Z+1, r31	; 0x01
  oqp->q_counter = size;
    1b42:	55 83       	std	Z+5, r21	; 0x05
    1b44:	44 83       	std	Z+4, r20	; 0x04
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
    1b46:	73 87       	std	Z+11, r23	; 0x0b
    1b48:	62 87       	std	Z+10, r22	; 0x0a
    1b4a:	75 87       	std	Z+13, r23	; 0x0d
    1b4c:	64 87       	std	Z+12, r22	; 0x0c
    1b4e:	77 83       	std	Z+7, r23	; 0x07
    1b50:	66 83       	std	Z+6, r22	; 0x06
  oqp->q_top = bp + size;
    1b52:	64 0f       	add	r22, r20
    1b54:	75 1f       	adc	r23, r21
    1b56:	71 87       	std	Z+9, r23	; 0x09
    1b58:	60 87       	std	Z+8, r22	; 0x08
  oqp->q_notify = onfy;
    1b5a:	37 87       	std	Z+15, r19	; 0x0f
    1b5c:	26 87       	std	Z+14, r18	; 0x0e
  oqp->q_link = link;
    1b5e:	11 8b       	std	Z+17, r17	; 0x11
    1b60:	00 8b       	std	Z+16, r16	; 0x10
}
    1b62:	1f 91       	pop	r17
    1b64:	0f 91       	pop	r16
    1b66:	08 95       	ret

00001b68 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p OutputQueue structure
 *
 * @iclass
 */
void chOQResetI(OutputQueue *oqp) {
    1b68:	0f 93       	push	r16
    1b6a:	1f 93       	push	r17
    1b6c:	cf 93       	push	r28
    1b6e:	df 93       	push	r29
    1b70:	ec 01       	movw	r28, r24

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
    1b72:	2e 81       	ldd	r18, Y+6	; 0x06
    1b74:	3f 81       	ldd	r19, Y+7	; 0x07
    1b76:	3b 87       	std	Y+11, r19	; 0x0b
    1b78:	2a 87       	std	Y+10, r18	; 0x0a
    1b7a:	3d 87       	std	Y+13, r19	; 0x0d
    1b7c:	2c 87       	std	Y+12, r18	; 0x0c
  oqp->q_counter = chQSizeI(oqp);
    1b7e:	88 85       	ldd	r24, Y+8	; 0x08
    1b80:	99 85       	ldd	r25, Y+9	; 0x09
    1b82:	82 1b       	sub	r24, r18
    1b84:	93 0b       	sbc	r25, r19
    1b86:	9d 83       	std	Y+5, r25	; 0x05
    1b88:	8c 83       	std	Y+4, r24	; 0x04
  while (notempty(&oqp->q_waiting))
    1b8a:	88 81       	ld	r24, Y
    1b8c:	99 81       	ldd	r25, Y+1	; 0x01
    1b8e:	8c 17       	cp	r24, r28
    1b90:	9d 07       	cpc	r25, r29
    1b92:	99 f0       	breq	.+38     	; 0x1bba <chOQResetI+0x52>
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_RESET;
    1b94:	0e ef       	ldi	r16, 0xFE	; 254
    1b96:	1f ef       	ldi	r17, 0xFF	; 255
    1b98:	dc 01       	movw	r26, r24
    1b9a:	ed 91       	ld	r30, X+
    1b9c:	fc 91       	ld	r31, X
    1b9e:	f9 83       	std	Y+1, r31	; 0x01
    1ba0:	e8 83       	st	Y, r30
    1ba2:	d3 83       	std	Z+3, r29	; 0x03
    1ba4:	c2 83       	std	Z+2, r28	; 0x02
    1ba6:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
    1baa:	fc 01       	movw	r30, r24
    1bac:	13 8b       	std	Z+19, r17	; 0x13
    1bae:	02 8b       	std	Z+18, r16	; 0x12

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeI(oqp);
  while (notempty(&oqp->q_waiting))
    1bb0:	88 81       	ld	r24, Y
    1bb2:	99 81       	ldd	r25, Y+1	; 0x01
    1bb4:	8c 17       	cp	r24, r28
    1bb6:	9d 07       	cpc	r25, r29
    1bb8:	79 f7       	brne	.-34     	; 0x1b98 <chOQResetI+0x30>
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_RESET;
}
    1bba:	df 91       	pop	r29
    1bbc:	cf 91       	pop	r28
    1bbe:	1f 91       	pop	r17
    1bc0:	0f 91       	pop	r16
    1bc2:	08 95       	ret

00001bc4 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(OutputQueue *oqp, uint8_t b, systime_t time) {
    1bc4:	ff 92       	push	r15
    1bc6:	0f 93       	push	r16
    1bc8:	1f 93       	push	r17
    1bca:	cf 93       	push	r28
    1bcc:	df 93       	push	r29
    1bce:	ec 01       	movw	r28, r24
    1bd0:	f6 2e       	mov	r15, r22
    1bd2:	8a 01       	movw	r16, r20

  chSysLock();
    1bd4:	f8 94       	cli
  while (chOQIsFullI(oqp)) {
    1bd6:	8c 81       	ldd	r24, Y+4	; 0x04
    1bd8:	9d 81       	ldd	r25, Y+5	; 0x05
    1bda:	00 97       	sbiw	r24, 0x00	; 0
    1bdc:	79 f4       	brne	.+30     	; 0x1bfc <chOQPutTimeout+0x38>
    msg_t msg;

    if ((msg = qwait((GenericQueue *)oqp, time)) < Q_OK) {
    1bde:	b8 01       	movw	r22, r16
    1be0:	ce 01       	movw	r24, r28
    1be2:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <qwait>
    1be6:	9c 01       	movw	r18, r24
    1be8:	97 ff       	sbrs	r25, 7
    1bea:	f5 cf       	rjmp	.-22     	; 0x1bd6 <chOQPutTimeout+0x12>
      chSysUnlock();
    1bec:	78 94       	sei
  if (oqp->q_notify)
    oqp->q_notify(oqp);

  chSysUnlock();
  return Q_OK;
}
    1bee:	c9 01       	movw	r24, r18
    1bf0:	df 91       	pop	r29
    1bf2:	cf 91       	pop	r28
    1bf4:	1f 91       	pop	r17
    1bf6:	0f 91       	pop	r16
    1bf8:	ff 90       	pop	r15
    1bfa:	08 95       	ret
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
    1bfc:	01 97       	sbiw	r24, 0x01	; 1
    1bfe:	9d 83       	std	Y+5, r25	; 0x05
    1c00:	8c 83       	std	Y+4, r24	; 0x04
  *oqp->q_wrptr++ = b;
    1c02:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c04:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c06:	f1 92       	st	Z+, r15
    1c08:	fb 87       	std	Y+11, r31	; 0x0b
    1c0a:	ea 87       	std	Y+10, r30	; 0x0a
  if (oqp->q_wrptr >= oqp->q_top)
    1c0c:	88 85       	ldd	r24, Y+8	; 0x08
    1c0e:	99 85       	ldd	r25, Y+9	; 0x09
    1c10:	e8 17       	cp	r30, r24
    1c12:	f9 07       	cpc	r31, r25
    1c14:	20 f0       	brcs	.+8      	; 0x1c1e <chOQPutTimeout+0x5a>
    oqp->q_wrptr = oqp->q_buffer;
    1c16:	8e 81       	ldd	r24, Y+6	; 0x06
    1c18:	9f 81       	ldd	r25, Y+7	; 0x07
    1c1a:	9b 87       	std	Y+11, r25	; 0x0b
    1c1c:	8a 87       	std	Y+10, r24	; 0x0a

  if (oqp->q_notify)
    1c1e:	ee 85       	ldd	r30, Y+14	; 0x0e
    1c20:	ff 85       	ldd	r31, Y+15	; 0x0f
    1c22:	30 97       	sbiw	r30, 0x00	; 0
    1c24:	11 f0       	breq	.+4      	; 0x1c2a <chOQPutTimeout+0x66>
    oqp->q_notify(oqp);
    1c26:	ce 01       	movw	r24, r28
    1c28:	09 95       	icall

  chSysUnlock();
    1c2a:	78 94       	sei
  return Q_OK;
    1c2c:	20 e0       	ldi	r18, 0x00	; 0
    1c2e:	30 e0       	ldi	r19, 0x00	; 0
}
    1c30:	c9 01       	movw	r24, r18
    1c32:	df 91       	pop	r29
    1c34:	cf 91       	pop	r28
    1c36:	1f 91       	pop	r17
    1c38:	0f 91       	pop	r16
    1c3a:	ff 90       	pop	r15
    1c3c:	08 95       	ret

00001c3e <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(OutputQueue *oqp) {
    1c3e:	1f 93       	push	r17
    1c40:	cf 93       	push	r28
    1c42:	df 93       	push	r29
    1c44:	fc 01       	movw	r30, r24
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
    1c46:	a4 85       	ldd	r26, Z+12	; 0x0c
    1c48:	b5 85       	ldd	r27, Z+13	; 0x0d
    1c4a:	82 85       	ldd	r24, Z+10	; 0x0a
    1c4c:	93 85       	ldd	r25, Z+11	; 0x0b
    1c4e:	8a 17       	cp	r24, r26
    1c50:	9b 07       	cpc	r25, r27
    1c52:	61 f1       	breq	.+88     	; 0x1cac <chOQGetI+0x6e>
    1c54:	84 81       	ldd	r24, Z+4	; 0x04
    1c56:	95 81       	ldd	r25, Z+5	; 0x05
    return Q_EMPTY;

  oqp->q_counter++;
    1c58:	01 96       	adiw	r24, 0x01	; 1
    1c5a:	95 83       	std	Z+5, r25	; 0x05
    1c5c:	84 83       	std	Z+4, r24	; 0x04
  b = *oqp->q_rdptr++;
    1c5e:	1d 91       	ld	r17, X+
    1c60:	b5 87       	std	Z+13, r27	; 0x0d
    1c62:	a4 87       	std	Z+12, r26	; 0x0c
  if (oqp->q_rdptr >= oqp->q_top)
    1c64:	80 85       	ldd	r24, Z+8	; 0x08
    1c66:	91 85       	ldd	r25, Z+9	; 0x09
    1c68:	a8 17       	cp	r26, r24
    1c6a:	b9 07       	cpc	r27, r25
    1c6c:	d0 f4       	brcc	.+52     	; 0x1ca2 <chOQGetI+0x64>
    oqp->q_rdptr = oqp->q_buffer;

  if (notempty(&oqp->q_waiting))
    1c6e:	80 81       	ld	r24, Z
    1c70:	91 81       	ldd	r25, Z+1	; 0x01
    1c72:	8e 17       	cp	r24, r30
    1c74:	9f 07       	cpc	r25, r31
    1c76:	71 f0       	breq	.+28     	; 0x1c94 <chOQGetI+0x56>
    1c78:	ec 01       	movw	r28, r24
    1c7a:	a8 81       	ld	r26, Y
    1c7c:	b9 81       	ldd	r27, Y+1	; 0x01
    1c7e:	b1 83       	std	Z+1, r27	; 0x01
    1c80:	a0 83       	st	Z, r26
    1c82:	13 96       	adiw	r26, 0x03	; 3
    1c84:	fc 93       	st	X, r31
    1c86:	ee 93       	st	-X, r30
    1c88:	12 97       	sbiw	r26, 0x02	; 2
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_OK;
    1c8a:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
    1c8e:	fc 01       	movw	r30, r24
    1c90:	13 8a       	std	Z+19, r1	; 0x13
    1c92:	12 8a       	std	Z+18, r1	; 0x12

  return b;
    1c94:	21 2f       	mov	r18, r17
    1c96:	30 e0       	ldi	r19, 0x00	; 0
}
    1c98:	c9 01       	movw	r24, r18
    1c9a:	df 91       	pop	r29
    1c9c:	cf 91       	pop	r28
    1c9e:	1f 91       	pop	r17
    1ca0:	08 95       	ret
    return Q_EMPTY;

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top)
    oqp->q_rdptr = oqp->q_buffer;
    1ca2:	86 81       	ldd	r24, Z+6	; 0x06
    1ca4:	97 81       	ldd	r25, Z+7	; 0x07
    1ca6:	95 87       	std	Z+13, r25	; 0x0d
    1ca8:	84 87       	std	Z+12, r24	; 0x0c
    1caa:	e1 cf       	rjmp	.-62     	; 0x1c6e <chOQGetI+0x30>
msg_t chOQGetI(OutputQueue *oqp) {
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
    1cac:	84 81       	ldd	r24, Z+4	; 0x04
    1cae:	95 81       	ldd	r25, Z+5	; 0x05
    1cb0:	89 2b       	or	r24, r25
    1cb2:	19 f4       	brne	.+6      	; 0x1cba <chOQGetI+0x7c>
    1cb4:	80 e0       	ldi	r24, 0x00	; 0
    1cb6:	90 e0       	ldi	r25, 0x00	; 0
    1cb8:	cf cf       	rjmp	.-98     	; 0x1c58 <chOQGetI+0x1a>
    return Q_EMPTY;
    1cba:	2d ef       	ldi	r18, 0xFD	; 253
    1cbc:	3f ef       	ldi	r19, 0xFF	; 255
    1cbe:	ec cf       	rjmp	.-40     	; 0x1c98 <chOQGetI+0x5a>

00001cc0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
    1cc0:	8f 92       	push	r8
    1cc2:	9f 92       	push	r9
    1cc4:	af 92       	push	r10
    1cc6:	bf 92       	push	r11
    1cc8:	cf 92       	push	r12
    1cca:	df 92       	push	r13
    1ccc:	ef 92       	push	r14
    1cce:	ff 92       	push	r15
    1cd0:	0f 93       	push	r16
    1cd2:	1f 93       	push	r17
    1cd4:	cf 93       	push	r28
    1cd6:	df 93       	push	r29
    1cd8:	ec 01       	movw	r28, r24
    1cda:	7b 01       	movw	r14, r22
    1cdc:	4a 01       	movw	r8, r20
    1cde:	59 01       	movw	r10, r18
  qnotify_t nfy = oqp->q_notify;
    1ce0:	ce 84       	ldd	r12, Y+14	; 0x0e
    1ce2:	df 84       	ldd	r13, Y+15	; 0x0f
  size_t w = 0;

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
    1ce4:	f8 94       	cli
 * @api
 */
size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
    1ce6:	00 e0       	ldi	r16, 0x00	; 0
    1ce8:	10 e0       	ldi	r17, 0x00	; 0

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
  while (TRUE) {
    while (chOQIsFullI(oqp)) {
    1cea:	8c 81       	ldd	r24, Y+4	; 0x04
    1cec:	9d 81       	ldd	r25, Y+5	; 0x05
    1cee:	00 97       	sbiw	r24, 0x00	; 0
    1cf0:	31 f1       	breq	.+76     	; 0x1d3e <chOQWriteTimeout+0x7e>
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    1cf2:	01 97       	sbiw	r24, 0x01	; 1
    1cf4:	9d 83       	std	Y+5, r25	; 0x05
    1cf6:	8c 83       	std	Y+4, r24	; 0x04
    *oqp->q_wrptr++ = *bp++;
    1cf8:	f7 01       	movw	r30, r14
    1cfa:	81 91       	ld	r24, Z+
    1cfc:	7f 01       	movw	r14, r30
    1cfe:	aa 85       	ldd	r26, Y+10	; 0x0a
    1d00:	bb 85       	ldd	r27, Y+11	; 0x0b
    1d02:	8d 93       	st	X+, r24
    1d04:	bb 87       	std	Y+11, r27	; 0x0b
    1d06:	aa 87       	std	Y+10, r26	; 0x0a
    if (oqp->q_wrptr >= oqp->q_top)
    1d08:	88 85       	ldd	r24, Y+8	; 0x08
    1d0a:	99 85       	ldd	r25, Y+9	; 0x09
    1d0c:	a8 17       	cp	r26, r24
    1d0e:	b9 07       	cpc	r27, r25
    1d10:	20 f0       	brcs	.+8      	; 0x1d1a <chOQWriteTimeout+0x5a>
      oqp->q_wrptr = oqp->q_buffer;
    1d12:	8e 81       	ldd	r24, Y+6	; 0x06
    1d14:	9f 81       	ldd	r25, Y+7	; 0x07
    1d16:	9b 87       	std	Y+11, r25	; 0x0b
    1d18:	8a 87       	std	Y+10, r24	; 0x0a

    if (nfy)
    1d1a:	c1 14       	cp	r12, r1
    1d1c:	d1 04       	cpc	r13, r1
    1d1e:	19 f0       	breq	.+6      	; 0x1d26 <chOQWriteTimeout+0x66>
      nfy(oqp);
    1d20:	ce 01       	movw	r24, r28
    1d22:	f6 01       	movw	r30, r12
    1d24:	09 95       	icall

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    1d26:	78 94       	sei
    w++;
    1d28:	0f 5f       	subi	r16, 0xFF	; 255
    1d2a:	1f 4f       	sbci	r17, 0xFF	; 255
    if (--n == 0)
    1d2c:	f1 e0       	ldi	r31, 0x01	; 1
    1d2e:	8f 1a       	sub	r8, r31
    1d30:	91 08       	sbc	r9, r1
    1d32:	61 f0       	breq	.+24     	; 0x1d4c <chOQWriteTimeout+0x8c>
      return w;
    chSysLock();
    1d34:	f8 94       	cli

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
  while (TRUE) {
    while (chOQIsFullI(oqp)) {
    1d36:	8c 81       	ldd	r24, Y+4	; 0x04
    1d38:	9d 81       	ldd	r25, Y+5	; 0x05
    1d3a:	00 97       	sbiw	r24, 0x00	; 0
    1d3c:	d1 f6       	brne	.-76     	; 0x1cf2 <chOQWriteTimeout+0x32>
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
    1d3e:	b5 01       	movw	r22, r10
    1d40:	ce 01       	movw	r24, r28
    1d42:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <qwait>
    1d46:	89 2b       	or	r24, r25
    1d48:	81 f2       	breq	.-96     	; 0x1cea <chOQWriteTimeout+0x2a>
        chSysUnlock();
    1d4a:	78 94       	sei
    w++;
    if (--n == 0)
      return w;
    chSysLock();
  }
}
    1d4c:	c8 01       	movw	r24, r16
    1d4e:	df 91       	pop	r29
    1d50:	cf 91       	pop	r28
    1d52:	1f 91       	pop	r17
    1d54:	0f 91       	pop	r16
    1d56:	ff 90       	pop	r15
    1d58:	ef 90       	pop	r14
    1d5a:	df 90       	pop	r13
    1d5c:	cf 90       	pop	r12
    1d5e:	bf 90       	pop	r11
    1d60:	af 90       	pop	r10
    1d62:	9f 90       	pop	r9
    1d64:	8f 90       	pop	r8
    1d66:	08 95       	ret

00001d68 <halInit>:
 *
 * @init
 */
void halInit(void) {

  hal_lld_init();
    1d68:	0e 94 57 11 	call	0x22ae	; 0x22ae <hal_lld_init>

#if HAL_USE_TM || defined(__DOXYGEN__)
  tmInit();
#endif
#if HAL_USE_PAL || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    1d6c:	8d e7       	ldi	r24, 0x7D	; 125
    1d6e:	91 e0       	ldi	r25, 0x01	; 1
    1d70:	0e 94 8a 11 	call	0x2314	; 0x2314 <_pal_lld_init>
#endif
#if HAL_USE_ADC || defined(__DOXYGEN__)
  adcInit();
    1d74:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <adcInit>
#endif
#if HAL_USE_MAC || defined(__DOXYGEN__)
  macInit();
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
    1d78:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <pwmInit>
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
    1d7c:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <sdInit>
#endif
#if HAL_USE_SDC || defined(__DOXYGEN__)
  sdcInit();
#endif
#if HAL_USE_SPI || defined(__DOXYGEN__)
  spiInit();
    1d80:	0e 94 91 10 	call	0x2122	; 0x2122 <spiInit>
#endif
#if HAL_USE_RTC || defined(__DOXYGEN__)
  rtcInit();
#endif
  /* Board specific initialization.*/
  boardInit();
    1d84:	0c 94 84 18 	jmp	0x3108	; 0x3108 <boardInit>

00001d88 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
    1d88:	0c 94 b3 13 	jmp	0x2766	; 0x2766 <adc_lld_init>

00001d8c <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    1d8c:	fc 01       	movw	r30, r24

  adcp->state    = ADC_STOP;
    1d8e:	81 e0       	ldi	r24, 0x01	; 1
    1d90:	80 83       	st	Z, r24
  adcp->config   = NULL;
    1d92:	12 82       	std	Z+2, r1	; 0x02
    1d94:	11 82       	std	Z+1, r1	; 0x01
  adcp->samples  = NULL;
    1d96:	14 82       	std	Z+4, r1	; 0x04
    1d98:	13 82       	std	Z+3, r1	; 0x03
  adcp->depth    = 0;
    1d9a:	16 82       	std	Z+6, r1	; 0x06
    1d9c:	15 82       	std	Z+5, r1	; 0x05
  adcp->grpp     = NULL;
    1d9e:	10 86       	std	Z+8, r1	; 0x08
    1da0:	17 82       	std	Z+7, r1	; 0x07
#if ADC_USE_WAIT
  adcp->thread   = NULL;
    1da2:	12 86       	std	Z+10, r1	; 0x0a
    1da4:	11 86       	std	Z+9, r1	; 0x09
#endif /* ADC_USE_WAIT */
#if ADC_USE_MUTUAL_EXCLUSION
#if CH_USE_MUTEXES
  chMtxInit(&adcp->mutex);
    1da6:	cf 01       	movw	r24, r30
    1da8:	0b 96       	adiw	r24, 0x0b	; 11
    1daa:	0c 94 48 06 	jmp	0xc90	; 0xc90 <chMtxInit>

00001dae <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
    1dae:	cf 93       	push	r28
    1db0:	df 93       	push	r29
    1db2:	ec 01       	movw	r28, r24

  chDbgCheck(adcp != NULL, "adcStart");

  chSysLock();
    1db4:	f8 94       	cli
  chDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
              "adcStart(), #1", "invalid state");
  adcp->config = config;
    1db6:	7a 83       	std	Y+2, r23	; 0x02
    1db8:	69 83       	std	Y+1, r22	; 0x01
  adc_lld_start(adcp);
    1dba:	0e 94 bf 13 	call	0x277e	; 0x277e <adc_lld_start>
  adcp->state = ADC_READY;
    1dbe:	82 e0       	ldi	r24, 0x02	; 2
    1dc0:	88 83       	st	Y, r24
  chSysUnlock();
    1dc2:	78 94       	sei
}
    1dc4:	df 91       	pop	r29
    1dc6:	cf 91       	pop	r28
    1dc8:	08 95       	ret

00001dca <adcStop>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStop(ADCDriver *adcp) {
    1dca:	cf 93       	push	r28
    1dcc:	df 93       	push	r29
    1dce:	ec 01       	movw	r28, r24

  chDbgCheck(adcp != NULL, "adcStop");

  chSysLock();
    1dd0:	f8 94       	cli
  chDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
              "adcStop(), #1", "invalid state");
  adc_lld_stop(adcp);
    1dd2:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <adc_lld_stop>
  adcp->state = ADC_STOP;
    1dd6:	81 e0       	ldi	r24, 0x01	; 1
    1dd8:	88 83       	st	Y, r24
  chSysUnlock();
    1dda:	78 94       	sei
}
    1ddc:	df 91       	pop	r29
    1dde:	cf 91       	pop	r28
    1de0:	08 95       	ret

00001de2 <adcStartConversion>:
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {

  chSysLock();
    1de2:	f8 94       	cli
  chDbgAssert((adcp->state == ADC_READY) ||
              (adcp->state == ADC_COMPLETE) ||
              (adcp->state == ADC_ERROR),
              "adcStartConversionI(), #1", "not ready");

  adcp->samples  = samples;
    1de4:	fc 01       	movw	r30, r24
    1de6:	54 83       	std	Z+4, r21	; 0x04
    1de8:	43 83       	std	Z+3, r20	; 0x03
  adcp->depth    = depth;
    1dea:	36 83       	std	Z+6, r19	; 0x06
    1dec:	25 83       	std	Z+5, r18	; 0x05
  adcp->grpp     = grpp;
    1dee:	70 87       	std	Z+8, r23	; 0x08
    1df0:	67 83       	std	Z+7, r22	; 0x07
  adcp->state    = ADC_ACTIVE;
    1df2:	23 e0       	ldi	r18, 0x03	; 3
    1df4:	20 83       	st	Z, r18
  adc_lld_start_conversion(adcp);
    1df6:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <adc_lld_start_conversion>
                        adcsample_t *samples,
                        size_t depth) {

  chSysLock();
  adcStartConversionI(adcp, grpp, samples, depth);
  chSysUnlock();
    1dfa:	78 94       	sei
    1dfc:	08 95       	ret

00001dfe <adcStartConversionI>:
  chDbgAssert((adcp->state == ADC_READY) ||
              (adcp->state == ADC_COMPLETE) ||
              (adcp->state == ADC_ERROR),
              "adcStartConversionI(), #1", "not ready");

  adcp->samples  = samples;
    1dfe:	fc 01       	movw	r30, r24
    1e00:	54 83       	std	Z+4, r21	; 0x04
    1e02:	43 83       	std	Z+3, r20	; 0x03
  adcp->depth    = depth;
    1e04:	36 83       	std	Z+6, r19	; 0x06
    1e06:	25 83       	std	Z+5, r18	; 0x05
  adcp->grpp     = grpp;
    1e08:	70 87       	std	Z+8, r23	; 0x08
    1e0a:	67 83       	std	Z+7, r22	; 0x07
  adcp->state    = ADC_ACTIVE;
    1e0c:	23 e0       	ldi	r18, 0x03	; 3
    1e0e:	20 83       	st	Z, r18
  adc_lld_start_conversion(adcp);
    1e10:	0c 94 e3 13 	jmp	0x27c6	; 0x27c6 <adc_lld_start_conversion>

00001e14 <adcStopConversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStopConversion(ADCDriver *adcp) {
    1e14:	cf 93       	push	r28
    1e16:	df 93       	push	r29
    1e18:	ec 01       	movw	r28, r24

  chDbgCheck(adcp != NULL, "adcStopConversion");

  chSysLock();
    1e1a:	f8 94       	cli
  chDbgAssert((adcp->state == ADC_READY) ||
              (adcp->state == ADC_ACTIVE),
              "adcStopConversion(), #1", "invalid state");
  if (adcp->state != ADC_READY) {
    1e1c:	88 81       	ld	r24, Y
    1e1e:	82 30       	cpi	r24, 0x02	; 2
    1e20:	89 f0       	breq	.+34     	; 0x1e44 <adcStopConversion+0x30>
    adc_lld_stop_conversion(adcp);
    1e22:	ce 01       	movw	r24, r28
    1e24:	0e 94 0e 14 	call	0x281c	; 0x281c <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
    1e28:	18 86       	std	Y+8, r1	; 0x08
    1e2a:	1f 82       	std	Y+7, r1	; 0x07
    adcp->state = ADC_READY;
    1e2c:	82 e0       	ldi	r24, 0x02	; 2
    1e2e:	88 83       	st	Y, r24
    _adc_reset_s(adcp);
    1e30:	89 85       	ldd	r24, Y+9	; 0x09
    1e32:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e34:	00 97       	sbiw	r24, 0x00	; 0
    1e36:	31 f0       	breq	.+12     	; 0x1e44 <adcStopConversion+0x30>
    1e38:	1a 86       	std	Y+10, r1	; 0x0a
    1e3a:	19 86       	std	Y+9, r1	; 0x09
    1e3c:	6e ef       	ldi	r22, 0xFE	; 254
    1e3e:	7f ef       	ldi	r23, 0xFF	; 255
    1e40:	0e 94 ba 02 	call	0x574	; 0x574 <chSchWakeupS>
  }
  chSysUnlock();
    1e44:	78 94       	sei
}
    1e46:	df 91       	pop	r29
    1e48:	cf 91       	pop	r28
    1e4a:	08 95       	ret

00001e4c <adcStopConversionI>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @iclass
 */
void adcStopConversionI(ADCDriver *adcp) {
    1e4c:	cf 93       	push	r28
    1e4e:	df 93       	push	r29
    1e50:	ec 01       	movw	r28, r24
  chDbgAssert((adcp->state == ADC_READY) ||
              (adcp->state == ADC_ACTIVE) ||
              (adcp->state == ADC_COMPLETE),
              "adcStopConversionI(), #1", "invalid state");

  if (adcp->state != ADC_READY) {
    1e52:	88 81       	ld	r24, Y
    1e54:	82 30       	cpi	r24, 0x02	; 2
    1e56:	b1 f0       	breq	.+44     	; 0x1e84 <adcStopConversionI+0x38>
    adc_lld_stop_conversion(adcp);
    1e58:	ce 01       	movw	r24, r28
    1e5a:	0e 94 0e 14 	call	0x281c	; 0x281c <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
    1e5e:	18 86       	std	Y+8, r1	; 0x08
    1e60:	1f 82       	std	Y+7, r1	; 0x07
    adcp->state = ADC_READY;
    1e62:	82 e0       	ldi	r24, 0x02	; 2
    1e64:	88 83       	st	Y, r24
    _adc_reset_i(adcp);
    1e66:	89 85       	ldd	r24, Y+9	; 0x09
    1e68:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e6a:	00 97       	sbiw	r24, 0x00	; 0
    1e6c:	59 f0       	breq	.+22     	; 0x1e84 <adcStopConversionI+0x38>
    1e6e:	1a 86       	std	Y+10, r1	; 0x0a
    1e70:	19 86       	std	Y+9, r1	; 0x09
    1e72:	2e ef       	ldi	r18, 0xFE	; 254
    1e74:	3f ef       	ldi	r19, 0xFF	; 255
    1e76:	fc 01       	movw	r30, r24
    1e78:	33 8b       	std	Z+19, r19	; 0x13
    1e7a:	22 8b       	std	Z+18, r18	; 0x12
  }
}
    1e7c:	df 91       	pop	r29
    1e7e:	cf 91       	pop	r28

  if (adcp->state != ADC_READY) {
    adc_lld_stop_conversion(adcp);
    adcp->grpp  = NULL;
    adcp->state = ADC_READY;
    _adc_reset_i(adcp);
    1e80:	0c 94 3e 02 	jmp	0x47c	; 0x47c <chSchReadyI>
  }
}
    1e84:	df 91       	pop	r29
    1e86:	cf 91       	pop	r28
    1e88:	08 95       	ret

00001e8a <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
    1e8a:	cf 93       	push	r28
    1e8c:	df 93       	push	r29
    1e8e:	ec 01       	movw	r28, r24
  msg_t msg;

  chSysLock();
    1e90:	f8 94       	cli
  chDbgAssert((adcp->state == ADC_READY) ||
              (adcp->state == ADC_COMPLETE) ||
              (adcp->state == ADC_ERROR),
              "adcStartConversionI(), #1", "not ready");

  adcp->samples  = samples;
    1e92:	5c 83       	std	Y+4, r21	; 0x04
    1e94:	4b 83       	std	Y+3, r20	; 0x03
  adcp->depth    = depth;
    1e96:	3e 83       	std	Y+6, r19	; 0x06
    1e98:	2d 83       	std	Y+5, r18	; 0x05
  adcp->grpp     = grpp;
    1e9a:	78 87       	std	Y+8, r23	; 0x08
    1e9c:	6f 83       	std	Y+7, r22	; 0x07
  adcp->state    = ADC_ACTIVE;
    1e9e:	83 e0       	ldi	r24, 0x03	; 3
    1ea0:	88 83       	st	Y, r24
  adc_lld_start_conversion(adcp);
    1ea2:	ce 01       	movw	r24, r28
    1ea4:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <adc_lld_start_conversion>
  msg_t msg;

  chSysLock();
  chDbgAssert(adcp->thread == NULL, "adcConvert(), #1", "already waiting");
  adcStartConversionI(adcp, grpp, samples, depth);
  (adcp)->thread = chThdSelf();
    1ea8:	80 91 3c 02 	lds	r24, 0x023C
    1eac:	90 91 3d 02 	lds	r25, 0x023D
    1eb0:	9a 87       	std	Y+10, r25	; 0x0a
    1eb2:	89 87       	std	Y+9, r24	; 0x09
  chSchGoSleepS(THD_STATE_SUSPENDED);
    1eb4:	82 e0       	ldi	r24, 0x02	; 2
    1eb6:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
  msg = chThdSelf()->p_u.rdymsg;
    1eba:	e0 91 3c 02 	lds	r30, 0x023C
    1ebe:	f0 91 3d 02 	lds	r31, 0x023D
    1ec2:	82 89       	ldd	r24, Z+18	; 0x12
    1ec4:	93 89       	ldd	r25, Z+19	; 0x13
  chSysUnlock();
    1ec6:	78 94       	sei
  return msg;
}
    1ec8:	df 91       	pop	r29
    1eca:	cf 91       	pop	r28
    1ecc:	08 95       	ret

00001ece <adcAcquireBus>:
void adcAcquireBus(ADCDriver *adcp) {

  chDbgCheck(adcp != NULL, "adcAcquireBus");

#if CH_USE_MUTEXES
  chMtxLock(&adcp->mutex);
    1ece:	0b 96       	adiw	r24, 0x0b	; 11
    1ed0:	0c 94 10 07 	jmp	0xe20	; 0xe20 <chMtxLock>

00001ed4 <adcReleaseBus>:

  chDbgCheck(adcp != NULL, "adcReleaseBus");

#if CH_USE_MUTEXES
  (void)adcp;
  chMtxUnlock();
    1ed4:	0c 94 4e 07 	jmp	0xe9c	; 0xe9c <chMtxUnlock>

00001ed8 <palReadBus>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @return              The bus logical states.
 *
 * @api
 */
ioportmask_t palReadBus(IOBus *bus) {
    1ed8:	fc 01       	movw	r30, r24

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palReadBus");

  return palReadGroup(bus->portid, bus->mask, bus->offset);
    1eda:	a0 81       	ld	r26, Z
    1edc:	b1 81       	ldd	r27, Z+1	; 0x01
    1ede:	2c 91       	ld	r18, X
    1ee0:	30 e0       	ldi	r19, 0x00	; 0
    1ee2:	03 80       	ldd	r0, Z+3	; 0x03
    1ee4:	02 c0       	rjmp	.+4      	; 0x1eea <palReadBus+0x12>
    1ee6:	35 95       	asr	r19
    1ee8:	27 95       	ror	r18
    1eea:	0a 94       	dec	r0
    1eec:	e2 f7       	brpl	.-8      	; 0x1ee6 <palReadBus+0xe>
    1eee:	82 81       	ldd	r24, Z+2	; 0x02
}
    1ef0:	82 23       	and	r24, r18
    1ef2:	08 95       	ret

00001ef4 <palWriteBus>:
 *                      the bus width are masked so most significant bits are
 *                      lost.
 *
 * @api
 */
void palWriteBus(IOBus *bus, ioportmask_t bits) {
    1ef4:	fc 01       	movw	r30, r24

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palWriteBus");

  palWriteGroup(bus->portid, bus->mask, bus->offset, bits);
    1ef6:	a0 81       	ld	r26, Z
    1ef8:	b1 81       	ldd	r27, Z+1	; 0x01
    1efa:	12 96       	adiw	r26, 0x02	; 2
    1efc:	3c 91       	ld	r19, X
    1efe:	12 97       	sbiw	r26, 0x02	; 2
    1f00:	82 81       	ldd	r24, Z+2	; 0x02
    1f02:	23 81       	ldd	r18, Z+3	; 0x03
    1f04:	68 23       	and	r22, r24
    1f06:	02 2e       	mov	r0, r18
    1f08:	01 c0       	rjmp	.+2      	; 0x1f0c <palWriteBus+0x18>
    1f0a:	66 0f       	add	r22, r22
    1f0c:	0a 94       	dec	r0
    1f0e:	ea f7       	brpl	.-6      	; 0x1f0a <palWriteBus+0x16>
    1f10:	02 2e       	mov	r0, r18
    1f12:	01 c0       	rjmp	.+2      	; 0x1f16 <palWriteBus+0x22>
    1f14:	88 0f       	add	r24, r24
    1f16:	0a 94       	dec	r0
    1f18:	ea f7       	brpl	.-6      	; 0x1f14 <palWriteBus+0x20>
    1f1a:	80 95       	com	r24
    1f1c:	83 23       	and	r24, r19
    1f1e:	86 2b       	or	r24, r22
    1f20:	12 96       	adiw	r26, 0x02	; 2
    1f22:	8c 93       	st	X, r24
    1f24:	08 95       	ret

00001f26 <palSetBusMode>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @param[in] mode      the mode
 *
 * @api
 */
void palSetBusMode(IOBus *bus, iomode_t mode) {
    1f26:	fc 01       	movw	r30, r24
    1f28:	46 2f       	mov	r20, r22

  chDbgCheck((bus != NULL) &&
             (bus->offset < PAL_IOPORTS_WIDTH), "palSetBusMode");

  palSetGroupMode(bus->portid, bus->mask, bus->offset, mode);
    1f2a:	82 81       	ldd	r24, Z+2	; 0x02
    1f2c:	68 2f       	mov	r22, r24
    1f2e:	70 e0       	ldi	r23, 0x00	; 0
    1f30:	03 80       	ldd	r0, Z+3	; 0x03
    1f32:	02 c0       	rjmp	.+4      	; 0x1f38 <palSetBusMode+0x12>
    1f34:	66 0f       	add	r22, r22
    1f36:	77 1f       	adc	r23, r23
    1f38:	0a 94       	dec	r0
    1f3a:	e2 f7       	brpl	.-8      	; 0x1f34 <palSetBusMode+0xe>
    1f3c:	80 81       	ld	r24, Z
    1f3e:	91 81       	ldd	r25, Z+1	; 0x01
    1f40:	0c 94 9c 11 	jmp	0x2338	; 0x2338 <_pal_lld_setgroupmode>

00001f44 <pwmInit>:
 *
 * @init
 */
void pwmInit(void) {

  pwm_lld_init();
    1f44:	0c 94 40 15 	jmp	0x2a80	; 0x2a80 <pwm_lld_init>

00001f48 <pwmObjectInit>:
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
    1f48:	21 e0       	ldi	r18, 0x01	; 1
    1f4a:	fc 01       	movw	r30, r24
    1f4c:	20 83       	st	Z, r18
  pwmp->config   = NULL;
    1f4e:	12 82       	std	Z+2, r1	; 0x02
    1f50:	11 82       	std	Z+1, r1	; 0x01
    1f52:	08 95       	ret

00001f54 <pwmStart>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] config    pointer to a @p PWMConfig object
 *
 * @api
 */
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
    1f54:	cf 93       	push	r28
    1f56:	df 93       	push	r29
    1f58:	ec 01       	movw	r28, r24

  chDbgCheck((pwmp != NULL) && (config != NULL), "pwmStart");

  chSysLock();
    1f5a:	f8 94       	cli
  chDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
              "pwmStart(), #1", "invalid state");
  pwmp->config = config;
    1f5c:	7a 83       	std	Y+2, r23	; 0x02
    1f5e:	69 83       	std	Y+1, r22	; 0x01
  pwmp->period = config->period;
    1f60:	fb 01       	movw	r30, r22
    1f62:	84 81       	ldd	r24, Z+4	; 0x04
    1f64:	95 81       	ldd	r25, Z+5	; 0x05
    1f66:	9c 83       	std	Y+4, r25	; 0x04
    1f68:	8b 83       	std	Y+3, r24	; 0x03
  pwm_lld_start(pwmp);
    1f6a:	ce 01       	movw	r24, r28
    1f6c:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <pwm_lld_start>
  pwmp->state = PWM_READY;
    1f70:	82 e0       	ldi	r24, 0x02	; 2
    1f72:	88 83       	st	Y, r24
  chSysUnlock();
    1f74:	78 94       	sei
}
    1f76:	df 91       	pop	r29
    1f78:	cf 91       	pop	r28
    1f7a:	08 95       	ret

00001f7c <pwmStop>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @api
 */
void pwmStop(PWMDriver *pwmp) {
    1f7c:	cf 93       	push	r28
    1f7e:	df 93       	push	r29
    1f80:	ec 01       	movw	r28, r24

  chDbgCheck(pwmp != NULL, "pwmStop");

  chSysLock();
    1f82:	f8 94       	cli
  chDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
              "pwmStop(), #1", "invalid state");
  pwm_lld_stop(pwmp);
    1f84:	0e 94 79 15 	call	0x2af2	; 0x2af2 <pwm_lld_stop>
  pwmp->state = PWM_STOP;
    1f88:	81 e0       	ldi	r24, 0x01	; 1
    1f8a:	88 83       	st	Y, r24
  chSysUnlock();
    1f8c:	78 94       	sei
}
    1f8e:	df 91       	pop	r29
    1f90:	cf 91       	pop	r28
    1f92:	08 95       	ret

00001f94 <pwmChangePeriod>:
 */
void pwmChangePeriod(PWMDriver *pwmp, pwmcnt_t period) {

  chDbgCheck(pwmp != NULL, "pwmChangePeriod");

  chSysLock();
    1f94:	f8 94       	cli
  chDbgAssert(pwmp->state == PWM_READY,
              "pwmChangePeriod(), #1", "invalid state");
  pwmChangePeriodI(pwmp, period);
    1f96:	fc 01       	movw	r30, r24
    1f98:	74 83       	std	Z+4, r23	; 0x04
    1f9a:	63 83       	std	Z+3, r22	; 0x03
    1f9c:	0e 94 86 15 	call	0x2b0c	; 0x2b0c <pwm_lld_change_period>
  chSysUnlock();
    1fa0:	78 94       	sei
    1fa2:	08 95       	ret

00001fa4 <pwmEnableChannel>:
                      pwmcnt_t width) {

  chDbgCheck((pwmp != NULL) && (channel < PWM_CHANNELS),
             "pwmEnableChannel");

  chSysLock();
    1fa4:	f8 94       	cli
  chDbgAssert(pwmp->state == PWM_READY,
              "pwmEnableChannel(), #1", "not ready");
  pwm_lld_enable_channel(pwmp, channel, width);
    1fa6:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <pwm_lld_enable_channel>
  chSysUnlock();
    1faa:	78 94       	sei
    1fac:	08 95       	ret

00001fae <pwmDisableChannel>:
void pwmDisableChannel(PWMDriver *pwmp, pwmchannel_t channel) {

  chDbgCheck((pwmp != NULL) && (channel < PWM_CHANNELS),
             "pwmEnableChannel");

  chSysLock();
    1fae:	f8 94       	cli
  chDbgAssert(pwmp->state == PWM_READY,
              "pwmDisableChannel(), #1", "not ready");
  pwm_lld_disable_channel(pwmp, channel);
    1fb0:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <pwm_lld_disable_channel>
  chSysUnlock();
    1fb4:	78 94       	sei
    1fb6:	08 95       	ret

00001fb8 <readt>:
  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
    1fb8:	05 96       	adiw	r24, 0x05	; 5
    1fba:	0c 94 48 0d 	jmp	0x1a90	; 0x1a90 <chIQReadTimeout>

00001fbe <read>:
                          n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    1fbe:	2f ef       	ldi	r18, 0xFF	; 255
    1fc0:	3f ef       	ldi	r19, 0xFF	; 255
    1fc2:	05 96       	adiw	r24, 0x05	; 5
    1fc4:	0c 94 48 0d 	jmp	0x1a90	; 0x1a90 <chIQReadTimeout>

00001fc8 <writet>:
  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
    1fc8:	47 96       	adiw	r24, 0x17	; 23
    1fca:	0c 94 60 0e 	jmp	0x1cc0	; 0x1cc0 <chOQWriteTimeout>

00001fce <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    1fce:	2f ef       	ldi	r18, 0xFF	; 255
    1fd0:	3f ef       	ldi	r19, 0xFF	; 255
    1fd2:	47 96       	adiw	r24, 0x17	; 23
    1fd4:	0c 94 60 0e 	jmp	0x1cc0	; 0x1cc0 <chOQWriteTimeout>

00001fd8 <gett>:
  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    1fd8:	05 96       	adiw	r24, 0x05	; 5
    1fda:	0c 94 11 0d 	jmp	0x1a22	; 0x1a22 <chIQGetTimeout>

00001fde <get>:
  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    1fde:	6f ef       	ldi	r22, 0xFF	; 255
    1fe0:	7f ef       	ldi	r23, 0xFF	; 255
    1fe2:	05 96       	adiw	r24, 0x05	; 5
    1fe4:	0c 94 11 0d 	jmp	0x1a22	; 0x1a22 <chIQGetTimeout>

00001fe8 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    1fe8:	47 96       	adiw	r24, 0x17	; 23
    1fea:	0c 94 e2 0d 	jmp	0x1bc4	; 0x1bc4 <chOQPutTimeout>

00001fee <put>:
                         n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    1fee:	4f ef       	ldi	r20, 0xFF	; 255
    1ff0:	5f ef       	ldi	r21, 0xFF	; 255
    1ff2:	47 96       	adiw	r24, 0x17	; 23
    1ff4:	0c 94 e2 0d 	jmp	0x1bc4	; 0x1bc4 <chOQPutTimeout>

00001ff8 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    1ff8:	0c 94 3b 12 	jmp	0x2476	; 0x2476 <sd_lld_init>

00001ffc <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    1ffc:	ef 92       	push	r14
    1ffe:	ff 92       	push	r15
    2000:	0f 93       	push	r16
    2002:	1f 93       	push	r17
    2004:	cf 93       	push	r28
    2006:	df 93       	push	r29
    2008:	ec 01       	movw	r28, r24
    200a:	9b 01       	movw	r18, r22
    200c:	7a 01       	movw	r14, r20

  sdp->vmt = &vmt;
    200e:	fc 01       	movw	r30, r24
    2010:	8a e6       	ldi	r24, 0x6A	; 106
    2012:	91 e0       	ldi	r25, 0x01	; 1
    2014:	81 93       	st	Z+, r24
    2016:	91 93       	st	Z+, r25
  chEvtInit(&sdp->event);
    2018:	fb 83       	std	Y+3, r31	; 0x03
    201a:	ea 83       	std	Y+2, r30	; 0x02
  sdp->state = SD_STOP;
    201c:	81 e0       	ldi	r24, 0x01	; 1
    201e:	8c 83       	std	Y+4, r24	; 0x04
  chIQInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    2020:	be 01       	movw	r22, r28
    2022:	67 5d       	subi	r22, 0xD7	; 215
    2024:	7f 4f       	sbci	r23, 0xFF	; 255
    2026:	8e 01       	movw	r16, r28
    2028:	40 e1       	ldi	r20, 0x10	; 16
    202a:	50 e0       	ldi	r21, 0x00	; 0
    202c:	ce 01       	movw	r24, r28
    202e:	05 96       	adiw	r24, 0x05	; 5
    2030:	0e 94 84 0c 	call	0x1908	; 0x1908 <chIQInit>
  chOQInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    2034:	be 01       	movw	r22, r28
    2036:	67 5c       	subi	r22, 0xC7	; 199
    2038:	7f 4f       	sbci	r23, 0xFF	; 255
    203a:	97 01       	movw	r18, r14
    203c:	40 e1       	ldi	r20, 0x10	; 16
    203e:	50 e0       	ldi	r21, 0x00	; 0
    2040:	ce 01       	movw	r24, r28
    2042:	47 96       	adiw	r24, 0x17	; 23
    2044:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <chOQInit>
}
    2048:	df 91       	pop	r29
    204a:	cf 91       	pop	r28
    204c:	1f 91       	pop	r17
    204e:	0f 91       	pop	r16
    2050:	ff 90       	pop	r15
    2052:	ef 90       	pop	r14
    2054:	08 95       	ret

00002056 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    2056:	cf 93       	push	r28
    2058:	df 93       	push	r29
    205a:	ec 01       	movw	r28, r24

  chDbgCheck(sdp != NULL, "sdStart");

  chSysLock();
    205c:	f8 94       	cli
  chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
              "sdStart(), #1",
              "invalid state");
  sd_lld_start(sdp, config);
    205e:	0e 94 43 12 	call	0x2486	; 0x2486 <sd_lld_start>
  sdp->state = SD_READY;
    2062:	82 e0       	ldi	r24, 0x02	; 2
    2064:	8c 83       	std	Y+4, r24	; 0x04
  chSysUnlock();
    2066:	78 94       	sei
}
    2068:	df 91       	pop	r29
    206a:	cf 91       	pop	r28
    206c:	08 95       	ret

0000206e <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
    206e:	cf 93       	push	r28
    2070:	df 93       	push	r29
    2072:	ec 01       	movw	r28, r24

  chDbgCheck(sdp != NULL, "sdStop");

  chSysLock();
    2074:	f8 94       	cli
  chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
              "sdStop(), #1",
              "invalid state");
  sd_lld_stop(sdp);
    2076:	0e 94 79 12 	call	0x24f2	; 0x24f2 <sd_lld_stop>
  sdp->state = SD_STOP;
    207a:	81 e0       	ldi	r24, 0x01	; 1
    207c:	8c 83       	std	Y+4, r24	; 0x04
  chOQResetI(&sdp->oqueue);
    207e:	ce 01       	movw	r24, r28
    2080:	47 96       	adiw	r24, 0x17	; 23
    2082:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <chOQResetI>
  chIQResetI(&sdp->iqueue);
    2086:	ce 01       	movw	r24, r28
    2088:	05 96       	adiw	r24, 0x05	; 5
    208a:	0e 94 9e 0c 	call	0x193c	; 0x193c <chIQResetI>
  chSchRescheduleS();
    208e:	0e 94 98 03 	call	0x730	; 0x730 <chSchRescheduleS>
  chSysUnlock();
    2092:	78 94       	sei
}
    2094:	df 91       	pop	r29
    2096:	cf 91       	pop	r28
    2098:	08 95       	ret

0000209a <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    209a:	1f 93       	push	r17
    209c:	cf 93       	push	r28
    209e:	df 93       	push	r29
    20a0:	ec 01       	movw	r28, r24
    20a2:	16 2f       	mov	r17, r22

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    20a4:	89 85       	ldd	r24, Y+9	; 0x09
    20a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    20a8:	89 2b       	or	r24, r25
    20aa:	59 f0       	breq	.+22     	; 0x20c2 <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    20ac:	61 2f       	mov	r22, r17
    20ae:	ce 01       	movw	r24, r28
    20b0:	05 96       	adiw	r24, 0x05	; 5
    20b2:	0e 94 c8 0c 	call	0x1990	; 0x1990 <chIQPutI>
    20b6:	97 fd       	sbrc	r25, 7
    20b8:	10 c0       	rjmp	.+32     	; 0x20da <sdIncomingDataI+0x40>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
    20ba:	df 91       	pop	r29
    20bc:	cf 91       	pop	r28
    20be:	1f 91       	pop	r17
    20c0:	08 95       	ret

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    20c2:	64 e0       	ldi	r22, 0x04	; 4
    20c4:	ce 01       	movw	r24, r28
    20c6:	02 96       	adiw	r24, 0x02	; 2
    20c8:	0e 94 91 09 	call	0x1322	; 0x1322 <chEvtBroadcastFlagsI>
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    20cc:	61 2f       	mov	r22, r17
    20ce:	ce 01       	movw	r24, r28
    20d0:	05 96       	adiw	r24, 0x05	; 5
    20d2:	0e 94 c8 0c 	call	0x1990	; 0x1990 <chIQPutI>
    20d6:	97 ff       	sbrs	r25, 7
    20d8:	f0 cf       	rjmp	.-32     	; 0x20ba <sdIncomingDataI+0x20>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    20da:	60 e8       	ldi	r22, 0x80	; 128
    20dc:	ce 01       	movw	r24, r28
    20de:	02 96       	adiw	r24, 0x02	; 2
}
    20e0:	df 91       	pop	r29
    20e2:	cf 91       	pop	r28
    20e4:	1f 91       	pop	r17
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    20e6:	0c 94 91 09 	jmp	0x1322	; 0x1322 <chEvtBroadcastFlagsI>

000020ea <sdRequestDataI>:
 * @retval Q_EMPTY      if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    20ea:	0f 93       	push	r16
    20ec:	1f 93       	push	r17
    20ee:	cf 93       	push	r28
    20f0:	df 93       	push	r29
    20f2:	8c 01       	movw	r16, r24
  msg_t  b;

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdRequestDataI");

  b = chOQGetI(&sdp->oqueue);
    20f4:	47 96       	adiw	r24, 0x17	; 23
    20f6:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <chOQGetI>
    20fa:	ec 01       	movw	r28, r24
  if (b < Q_OK)
    20fc:	97 fd       	sbrc	r25, 7
    20fe:	06 c0       	rjmp	.+12     	; 0x210c <sdRequestDataI+0x22>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
    2100:	ce 01       	movw	r24, r28
    2102:	df 91       	pop	r29
    2104:	cf 91       	pop	r28
    2106:	1f 91       	pop	r17
    2108:	0f 91       	pop	r16
    210a:	08 95       	ret
  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdRequestDataI");

  b = chOQGetI(&sdp->oqueue);
  if (b < Q_OK)
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    210c:	68 e0       	ldi	r22, 0x08	; 8
    210e:	c8 01       	movw	r24, r16
    2110:	02 96       	adiw	r24, 0x02	; 2
    2112:	0e 94 91 09 	call	0x1322	; 0x1322 <chEvtBroadcastFlagsI>
  return b;
}
    2116:	ce 01       	movw	r24, r28
    2118:	df 91       	pop	r29
    211a:	cf 91       	pop	r28
    211c:	1f 91       	pop	r17
    211e:	0f 91       	pop	r16
    2120:	08 95       	ret

00002122 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    2122:	0c 94 80 17 	jmp	0x2f00	; 0x2f00 <spi_lld_init>

00002126 <spiObjectInit>:
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
    2126:	21 e0       	ldi	r18, 0x01	; 1
    2128:	fc 01       	movw	r30, r24
    212a:	20 83       	st	Z, r18
  spip->config = NULL;
    212c:	12 82       	std	Z+2, r1	; 0x02
    212e:	11 82       	std	Z+1, r1	; 0x01
#if SPI_USE_WAIT
  spip->thread = NULL;
    2130:	14 82       	std	Z+4, r1	; 0x04
    2132:	13 82       	std	Z+3, r1	; 0x03
#endif /* SPI_USE_WAIT */
#if SPI_USE_MUTUAL_EXCLUSION
#if CH_USE_MUTEXES
  chMtxInit(&spip->mutex);
    2134:	05 96       	adiw	r24, 0x05	; 5
    2136:	0c 94 48 06 	jmp	0xc90	; 0xc90 <chMtxInit>

0000213a <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    213a:	cf 93       	push	r28
    213c:	df 93       	push	r29
    213e:	ec 01       	movw	r28, r24

  chDbgCheck((spip != NULL) && (config != NULL), "spiStart");

  chSysLock();
    2140:	f8 94       	cli
  chDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
    2142:	88 81       	ld	r24, Y
    2144:	81 30       	cpi	r24, 0x01	; 1
    2146:	09 f0       	breq	.+2      	; 0x214a <spiStart+0x10>
    2148:	88 81       	ld	r24, Y
              "spiStart(), #1", "invalid state");
  spip->config = config;
    214a:	7a 83       	std	Y+2, r23	; 0x02
    214c:	69 83       	std	Y+1, r22	; 0x01
  spi_lld_start(spip);
    214e:	ce 01       	movw	r24, r28
    2150:	0e 94 84 17 	call	0x2f08	; 0x2f08 <spi_lld_start>
  spip->state = SPI_READY;
    2154:	82 e0       	ldi	r24, 0x02	; 2
    2156:	88 83       	st	Y, r24
  chSysUnlock();
    2158:	78 94       	sei
}
    215a:	df 91       	pop	r29
    215c:	cf 91       	pop	r28
    215e:	08 95       	ret

00002160 <spiStop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiStop(SPIDriver *spip) {
    2160:	cf 93       	push	r28
    2162:	df 93       	push	r29
    2164:	ec 01       	movw	r28, r24

  chDbgCheck(spip != NULL, "spiStop");

  chSysLock();
    2166:	f8 94       	cli
  chDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
    2168:	88 81       	ld	r24, Y
    216a:	81 30       	cpi	r24, 0x01	; 1
    216c:	09 f0       	breq	.+2      	; 0x2170 <spiStop+0x10>
    216e:	88 81       	ld	r24, Y
              "spiStop(), #1", "invalid state");
  spi_lld_unselect(spip);
    2170:	ce 01       	movw	r24, r28
    2172:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <spi_lld_unselect>
  spi_lld_stop(spip);
    2176:	ce 01       	movw	r24, r28
    2178:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <spi_lld_stop>
  spip->state = SPI_STOP;
    217c:	81 e0       	ldi	r24, 0x01	; 1
    217e:	88 83       	st	Y, r24
  chSysUnlock();
    2180:	78 94       	sei
}
    2182:	df 91       	pop	r29
    2184:	cf 91       	pop	r28
    2186:	08 95       	ret

00002188 <spiSelect>:
 */
void spiSelect(SPIDriver *spip) {

  chDbgCheck(spip != NULL, "spiSelect");

  chSysLock();
    2188:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiSelect(), #1", "not ready");
    218a:	fc 01       	movw	r30, r24
    218c:	20 81       	ld	r18, Z
  spiSelectI(spip);
    218e:	0e 94 b0 17 	call	0x2f60	; 0x2f60 <spi_lld_select>
  chSysUnlock();
    2192:	78 94       	sei
    2194:	08 95       	ret

00002196 <spiUnselect>:
 */
void spiUnselect(SPIDriver *spip) {

  chDbgCheck(spip != NULL, "spiUnselect");

  chSysLock();
    2196:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiUnselect(), #1", "not ready");
    2198:	fc 01       	movw	r30, r24
    219a:	20 81       	ld	r18, Z
  spiUnselectI(spip);
    219c:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <spi_lld_unselect>
  chSysUnlock();
    21a0:	78 94       	sei
    21a2:	08 95       	ret

000021a4 <spiStartIgnore>:
 */
void spiStartIgnore(SPIDriver *spip, size_t n) {

  chDbgCheck((spip != NULL) && (n > 0), "spiStartIgnore");

  chSysLock();
    21a4:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiStartIgnore(), #1", "not ready");
    21a6:	fc 01       	movw	r30, r24
    21a8:	20 81       	ld	r18, Z
  spiStartIgnoreI(spip, n);
    21aa:	23 e0       	ldi	r18, 0x03	; 3
    21ac:	20 83       	st	Z, r18
    21ae:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <spi_lld_ignore>
  chSysUnlock();
    21b2:	78 94       	sei
    21b4:	08 95       	ret

000021b6 <spiStartExchange>:
                      const void *txbuf, void *rxbuf) {

  chDbgCheck((spip != NULL) && (n > 0) && (rxbuf != NULL) && (txbuf != NULL),
             "spiStartExchange");

  chSysLock();
    21b6:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiStartExchange(), #1", "not ready");
    21b8:	dc 01       	movw	r26, r24
    21ba:	ec 91       	ld	r30, X
  spiStartExchangeI(spip, n, txbuf, rxbuf);
    21bc:	e3 e0       	ldi	r30, 0x03	; 3
    21be:	ec 93       	st	X, r30
    21c0:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <spi_lld_exchange>
  chSysUnlock();
    21c4:	78 94       	sei
    21c6:	08 95       	ret

000021c8 <spiStartSend>:
void spiStartSend(SPIDriver *spip, size_t n, const void *txbuf) {

  chDbgCheck((spip != NULL) && (n > 0) && (txbuf != NULL),
             "spiStartSend");

  chSysLock();
    21c8:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiStartSend(), #1", "not ready");
    21ca:	fc 01       	movw	r30, r24
    21cc:	20 81       	ld	r18, Z
  spiStartSendI(spip, n, txbuf);
    21ce:	23 e0       	ldi	r18, 0x03	; 3
    21d0:	20 83       	st	Z, r18
    21d2:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <spi_lld_send>
  chSysUnlock();
    21d6:	78 94       	sei
    21d8:	08 95       	ret

000021da <spiStartReceive>:
void spiStartReceive(SPIDriver *spip, size_t n, void *rxbuf) {

  chDbgCheck((spip != NULL) && (n > 0) && (rxbuf != NULL),
             "spiStartReceive");

  chSysLock();
    21da:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiStartReceive(), #1", "not ready");
    21dc:	fc 01       	movw	r30, r24
    21de:	20 81       	ld	r18, Z
  spiStartReceiveI(spip, n, rxbuf);
    21e0:	23 e0       	ldi	r18, 0x03	; 3
    21e2:	20 83       	st	Z, r18
    21e4:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <spi_lld_receive>
  chSysUnlock();
    21e8:	78 94       	sei
    21ea:	08 95       	ret

000021ec <spiIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiIgnore(SPIDriver *spip, size_t n) {
    21ec:	cf 93       	push	r28
    21ee:	df 93       	push	r29
    21f0:	ec 01       	movw	r28, r24

  chDbgCheck((spip != NULL) && (n > 0), "spiIgnoreWait");

  chSysLock();
    21f2:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiIgnore(), #1", "not ready");
    21f4:	88 81       	ld	r24, Y
  chDbgAssert(spip->config->end_cb == NULL, "spiIgnore(), #2", "has callback");
  spiStartIgnoreI(spip, n);
    21f6:	83 e0       	ldi	r24, 0x03	; 3
    21f8:	88 83       	st	Y, r24
    21fa:	ce 01       	movw	r24, r28
    21fc:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <spi_lld_ignore>
  _spi_wait_s(spip);
    2200:	80 91 3c 02 	lds	r24, 0x023C
    2204:	90 91 3d 02 	lds	r25, 0x023D
    2208:	9c 83       	std	Y+4, r25	; 0x04
    220a:	8b 83       	std	Y+3, r24	; 0x03
    220c:	82 e0       	ldi	r24, 0x02	; 2
    220e:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
  chSysUnlock();
    2212:	78 94       	sei
}
    2214:	df 91       	pop	r29
    2216:	cf 91       	pop	r28
    2218:	08 95       	ret

0000221a <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
    221a:	cf 93       	push	r28
    221c:	df 93       	push	r29
    221e:	ec 01       	movw	r28, r24

  chDbgCheck((spip != NULL) && (n > 0) && (rxbuf != NULL) && (txbuf != NULL),
             "spiExchange");

  chSysLock();
    2220:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiExchange(), #1", "not ready");
    2222:	88 81       	ld	r24, Y
  chDbgAssert(spip->config->end_cb == NULL,
              "spiExchange(), #2", "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
    2224:	83 e0       	ldi	r24, 0x03	; 3
    2226:	88 83       	st	Y, r24
    2228:	ce 01       	movw	r24, r28
    222a:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <spi_lld_exchange>
  _spi_wait_s(spip);
    222e:	80 91 3c 02 	lds	r24, 0x023C
    2232:	90 91 3d 02 	lds	r25, 0x023D
    2236:	9c 83       	std	Y+4, r25	; 0x04
    2238:	8b 83       	std	Y+3, r24	; 0x03
    223a:	82 e0       	ldi	r24, 0x02	; 2
    223c:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
  chSysUnlock();
    2240:	78 94       	sei
}
    2242:	df 91       	pop	r29
    2244:	cf 91       	pop	r28
    2246:	08 95       	ret

00002248 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
    2248:	cf 93       	push	r28
    224a:	df 93       	push	r29
    224c:	ec 01       	movw	r28, r24

  chDbgCheck((spip != NULL) && (n > 0) && (txbuf != NULL), "spiSend");

  chSysLock();
    224e:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiSend(), #1", "not ready");
    2250:	88 81       	ld	r24, Y
  chDbgAssert(spip->config->end_cb == NULL, "spiSend(), #2", "has callback");
  spiStartSendI(spip, n, txbuf);
    2252:	83 e0       	ldi	r24, 0x03	; 3
    2254:	88 83       	st	Y, r24
    2256:	ce 01       	movw	r24, r28
    2258:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <spi_lld_send>
  _spi_wait_s(spip);
    225c:	80 91 3c 02 	lds	r24, 0x023C
    2260:	90 91 3d 02 	lds	r25, 0x023D
    2264:	9c 83       	std	Y+4, r25	; 0x04
    2266:	8b 83       	std	Y+3, r24	; 0x03
    2268:	82 e0       	ldi	r24, 0x02	; 2
    226a:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
  chSysUnlock();
    226e:	78 94       	sei
}
    2270:	df 91       	pop	r29
    2272:	cf 91       	pop	r28
    2274:	08 95       	ret

00002276 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
    2276:	cf 93       	push	r28
    2278:	df 93       	push	r29
    227a:	ec 01       	movw	r28, r24

  chDbgCheck((spip != NULL) && (n > 0) && (rxbuf != NULL),
             "spiReceive");

  chSysLock();
    227c:	f8 94       	cli
  chDbgAssert(spip->state == SPI_READY, "spiReceive(), #1", "not ready");
    227e:	88 81       	ld	r24, Y
  chDbgAssert(spip->config->end_cb == NULL,
              "spiReceive(), #2", "has callback");
  spiStartReceiveI(spip, n, rxbuf);
    2280:	83 e0       	ldi	r24, 0x03	; 3
    2282:	88 83       	st	Y, r24
    2284:	ce 01       	movw	r24, r28
    2286:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <spi_lld_receive>
  _spi_wait_s(spip);
    228a:	80 91 3c 02 	lds	r24, 0x023C
    228e:	90 91 3d 02 	lds	r25, 0x023D
    2292:	9c 83       	std	Y+4, r25	; 0x04
    2294:	8b 83       	std	Y+3, r24	; 0x03
    2296:	82 e0       	ldi	r24, 0x02	; 2
    2298:	0e 94 60 02 	call	0x4c0	; 0x4c0 <chSchGoSleepS>
  chSysUnlock();
    229c:	78 94       	sei
}
    229e:	df 91       	pop	r29
    22a0:	cf 91       	pop	r28
    22a2:	08 95       	ret

000022a4 <spiAcquireBus>:
void spiAcquireBus(SPIDriver *spip) {

  chDbgCheck(spip != NULL, "spiAcquireBus");

#if CH_USE_MUTEXES
  chMtxLock(&spip->mutex);
    22a4:	05 96       	adiw	r24, 0x05	; 5
    22a6:	0c 94 10 07 	jmp	0xe20	; 0xe20 <chMtxLock>

000022aa <spiReleaseBus>:

  chDbgCheck(spip != NULL, "spiReleaseBus");

#if CH_USE_MUTEXES
  (void)spip;
  chMtxUnlock();
    22aa:	0c 94 4e 07 	jmp	0xe9c	; 0xe9c <chMtxUnlock>

000022ae <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
    22ae:	cf 93       	push	r28
     /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
    22b0:	10 92 69 00 	sts	0x0069, r1
#ifdef EICRB
  EICRB  = 0x00;
#endif
  EIMSK  = 0x00;
    22b4:	1d ba       	out	0x1d, r1	; 29

  /*
   * Timer 0 setup.
   */
  TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.        */
    22b6:	c2 e0       	ldi	r28, 0x02	; 2
    22b8:	c4 bd       	out	0x24, r28	; 36
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.   */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.   */
  TCCR0B  = (0 << WGM02) ;				 /* CTC mode.        */
    22ba:	15 bc       	out	0x25, r1	; 37


static void setClock()
{
  
  uint8_t prescaler_index = findBestPrescaler(CH_FREQUENCY,ratio_base,clock_source_base,PRESCALER_SIZE_BASE);
    22bc:	25 e0       	ldi	r18, 0x05	; 5
    22be:	45 e4       	ldi	r20, 0x45	; 69
    22c0:	51 e0       	ldi	r21, 0x01	; 1
    22c2:	6a e4       	ldi	r22, 0x4A	; 74
    22c4:	71 e0       	ldi	r23, 0x01	; 1
    22c6:	81 e7       	ldi	r24, 0x71	; 113
    22c8:	92 e0       	ldi	r25, 0x02	; 2
    22ca:	0e 94 f6 17 	call	0x2fec	; 0x2fec <findBestPrescaler>
  
  TCCR0B &= ~((1 << CS02)  | (1 << CS01)  | (1 << CS00));
    22ce:	95 b5       	in	r25, 0x25	; 37
    22d0:	98 7f       	andi	r25, 0xF8	; 248
    22d2:	95 bd       	out	0x25, r25	; 37
  TCCR0B |=((clock_source_base[prescaler_index] & 0x07)<<CS00);
    22d4:	95 b5       	in	r25, 0x25	; 37
    22d6:	e8 2f       	mov	r30, r24
    22d8:	f0 e0       	ldi	r31, 0x00	; 0
    22da:	df 01       	movw	r26, r30
    22dc:	ab 5b       	subi	r26, 0xBB	; 187
    22de:	be 4f       	sbci	r27, 0xFE	; 254
    22e0:	8c 91       	ld	r24, X
    22e2:	87 70       	andi	r24, 0x07	; 7
    22e4:	89 2b       	or	r24, r25
    22e6:	85 bd       	out	0x25, r24	; 37
  OCR0A   = F_CPU / ratio_base[prescaler_index] /CH_FREQUENCY - 1;
    22e8:	ee 0f       	add	r30, r30
    22ea:	ff 1f       	adc	r31, r31
    22ec:	e6 5b       	subi	r30, 0xB6	; 182
    22ee:	fe 4f       	sbci	r31, 0xFE	; 254
    22f0:	20 81       	ld	r18, Z
    22f2:	31 81       	ldd	r19, Z+1	; 0x01
    22f4:	40 e0       	ldi	r20, 0x00	; 0
    22f6:	50 e0       	ldi	r21, 0x00	; 0
    22f8:	60 e0       	ldi	r22, 0x00	; 0
    22fa:	7d e7       	ldi	r23, 0x7D	; 125
    22fc:	80 e0       	ldi	r24, 0x00	; 0
    22fe:	90 e0       	ldi	r25, 0x00	; 0
    2300:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <__udivmodsi4>
    2304:	21 50       	subi	r18, 0x01	; 1
    2306:	27 bd       	out	0x27, r18	; 39
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.   */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.   */
  TCCR0B  = (0 << WGM02) ;				 /* CTC mode.        */
             setClock();  			 
  
  TCNT0   = 0;                                           /* Reset counter.   */
    2308:	16 bc       	out	0x26, r1	; 38
  TIFR0   = (1 << OCF0A);                                /* Reset pending.   */
    230a:	c5 bb       	out	0x15, r28	; 21
  TIMSK0  = (1 << OCIE0A);  
    230c:	c0 93 6e 00 	sts	0x006E, r28
}
    2310:	cf 91       	pop	r28
    2312:	08 95       	ret

00002314 <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    2314:	fc 01       	movw	r30, r24

#if defined(PORTA) || defined(__DOXYGEN__)
  PORTA = config->porta.out;
    2316:	80 81       	ld	r24, Z
    2318:	82 b9       	out	0x02, r24	; 2
  DDRA = config->porta.dir;
    231a:	81 81       	ldd	r24, Z+1	; 0x01
    231c:	81 b9       	out	0x01, r24	; 1
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
    231e:	82 81       	ldd	r24, Z+2	; 0x02
    2320:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
    2322:	83 81       	ldd	r24, Z+3	; 0x03
    2324:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
    2326:	84 81       	ldd	r24, Z+4	; 0x04
    2328:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
    232a:	85 81       	ldd	r24, Z+5	; 0x05
    232c:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
    232e:	86 81       	ldd	r24, Z+6	; 0x06
    2330:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
    2332:	87 81       	ldd	r24, Z+7	; 0x07
    2334:	8a b9       	out	0x0a, r24	; 10
    2336:	08 95       	ret

00002338 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    2338:	fc 01       	movw	r30, r24

  switch (mode) {
    233a:	42 30       	cpi	r20, 0x02	; 2
    233c:	91 f0       	breq	.+36     	; 0x2362 <_pal_lld_setgroupmode+0x2a>
    233e:	78 f0       	brcs	.+30     	; 0x235e <_pal_lld_setgroupmode+0x26>
    2340:	45 30       	cpi	r20, 0x05	; 5
    2342:	79 f0       	breq	.+30     	; 0x2362 <_pal_lld_setgroupmode+0x2a>
    2344:	46 30       	cpi	r20, 0x06	; 6
    2346:	a9 f0       	breq	.+42     	; 0x2372 <_pal_lld_setgroupmode+0x3a>
    2348:	43 30       	cpi	r20, 0x03	; 3
    234a:	b1 f4       	brne	.+44     	; 0x2378 <_pal_lld_setgroupmode+0x40>
    port->dir &= ~mask;
    port->out &= ~mask;
	break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    234c:	91 81       	ldd	r25, Z+1	; 0x01
    234e:	86 2f       	mov	r24, r22
    2350:	80 95       	com	r24
    2352:	89 23       	and	r24, r25
    2354:	81 83       	std	Z+1, r24	; 0x01
    port->out |= mask;
    2356:	82 81       	ldd	r24, Z+2	; 0x02
    2358:	86 2b       	or	r24, r22
    235a:	82 83       	std	Z+2, r24	; 0x02
    break;
    235c:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
    235e:	41 11       	cpse	r20, r1
    2360:	0c c0       	rjmp	.+24     	; 0x237a <_pal_lld_setgroupmode+0x42>
  case PAL_MODE_RESET:
  case PAL_MODE_INPUT:
  case PAL_MODE_INPUT_ANALOG:
    port->dir &= ~mask;
    2362:	81 81       	ldd	r24, Z+1	; 0x01
    2364:	60 95       	com	r22
    2366:	86 23       	and	r24, r22
    2368:	81 83       	std	Z+1, r24	; 0x01
    port->out &= ~mask;
    236a:	82 81       	ldd	r24, Z+2	; 0x02
    236c:	86 23       	and	r24, r22
    236e:	82 83       	std	Z+2, r24	; 0x02
	break;
    2370:	08 95       	ret
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    port->out |= mask;
    break;
  case PAL_MODE_OUTPUT_PUSHPULL:
    port->dir |= mask;
    2372:	81 81       	ldd	r24, Z+1	; 0x01
    2374:	86 2b       	or	r24, r22
    2376:	81 83       	std	Z+1, r24	; 0x01
    2378:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
    237a:	41 30       	cpi	r20, 0x01	; 1
    237c:	39 f3       	breq	.-50     	; 0x234c <_pal_lld_setgroupmode+0x14>
    237e:	08 95       	ret

00002380 <notify1>:

#if USE_AVR_USART0 || defined(__DOXYGEN__)
static void notify1(GenericQueue *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
    2380:	e1 ec       	ldi	r30, 0xC1	; 193
    2382:	f0 e0       	ldi	r31, 0x00	; 0
    2384:	80 81       	ld	r24, Z
    2386:	80 62       	ori	r24, 0x20	; 32
    2388:	80 83       	st	Z, r24
    238a:	08 95       	ret

0000238c <__vector_20>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(USART0_RX_vect) {
    238c:	1f 92       	push	r1
    238e:	0f 92       	push	r0
    2390:	0f b6       	in	r0, 0x3f	; 63
    2392:	0f 92       	push	r0
    2394:	11 24       	eor	r1, r1
    2396:	2f 93       	push	r18
    2398:	3f 93       	push	r19
    239a:	4f 93       	push	r20
    239c:	5f 93       	push	r21
    239e:	6f 93       	push	r22
    23a0:	7f 93       	push	r23
    23a2:	8f 93       	push	r24
    23a4:	9f 93       	push	r25
    23a6:	af 93       	push	r26
    23a8:	bf 93       	push	r27
    23aa:	ef 93       	push	r30
    23ac:	ff 93       	push	r31
  uint8_t sra;

  CH_IRQ_PROLOGUE();

  sra = UCSR0A;
    23ae:	80 91 c0 00 	lds	r24, 0x00C0
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    23b2:	98 2f       	mov	r25, r24
    23b4:	9c 71       	andi	r25, 0x1C	; 28
    23b6:	e1 f4       	brne	.+56     	; 0x23f0 <__vector_20+0x64>
    set_error(sra, &SD1);
  chSysLockFromIsr();
  sdIncomingDataI(&SD1, UDR0);
    23b8:	60 91 c6 00 	lds	r22, 0x00C6
    23bc:	8e e3       	ldi	r24, 0x3E	; 62
    23be:	92 e0       	ldi	r25, 0x02	; 2
    23c0:	0e 94 4d 10 	call	0x209a	; 0x209a <sdIncomingDataI>
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
    23c4:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
    23c8:	81 11       	cpse	r24, r1
    23ca:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
    23ce:	ff 91       	pop	r31
    23d0:	ef 91       	pop	r30
    23d2:	bf 91       	pop	r27
    23d4:	af 91       	pop	r26
    23d6:	9f 91       	pop	r25
    23d8:	8f 91       	pop	r24
    23da:	7f 91       	pop	r23
    23dc:	6f 91       	pop	r22
    23de:	5f 91       	pop	r21
    23e0:	4f 91       	pop	r20
    23e2:	3f 91       	pop	r19
    23e4:	2f 91       	pop	r18
    23e6:	0f 90       	pop	r0
    23e8:	0f be       	out	0x3f, r0	; 63
    23ea:	0f 90       	pop	r0
    23ec:	1f 90       	pop	r1
    23ee:	18 95       	reti
    upe = (1 << UPE1);
    fe = (1 << FE1);
  }
#endif

  if (sra & dor)
    23f0:	83 fd       	sbrc	r24, 3
    23f2:	0a c0       	rjmp	.+20     	; 0x2408 <__vector_20+0x7c>
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void set_error(uint8_t sra, SerialDriver *sdp) {
  flagsmask_t sts = 0;
    23f4:	60 e0       	ldi	r22, 0x00	; 0
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    23f6:	82 fd       	sbrc	r24, 2
    sts |= SD_PARITY_ERROR;
    23f8:	60 62       	ori	r22, 0x20	; 32
  if (sra & fe)
    23fa:	84 fd       	sbrc	r24, 4
    sts |= SD_FRAMING_ERROR;
    23fc:	60 64       	ori	r22, 0x40	; 64
  chSysLockFromIsr();
  chnAddFlagsI(sdp, sts);
    23fe:	80 e4       	ldi	r24, 0x40	; 64
    2400:	92 e0       	ldi	r25, 0x02	; 2
    2402:	0e 94 91 09 	call	0x1322	; 0x1322 <chEvtBroadcastFlagsI>
    2406:	d8 cf       	rjmp	.-80     	; 0x23b8 <__vector_20+0x2c>
    fe = (1 << FE1);
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
    2408:	60 e8       	ldi	r22, 0x80	; 128
    240a:	f5 cf       	rjmp	.-22     	; 0x23f6 <__vector_20+0x6a>

0000240c <__vector_21>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(USART0_UDRE_vect) {
    240c:	1f 92       	push	r1
    240e:	0f 92       	push	r0
    2410:	0f b6       	in	r0, 0x3f	; 63
    2412:	0f 92       	push	r0
    2414:	11 24       	eor	r1, r1
    2416:	2f 93       	push	r18
    2418:	3f 93       	push	r19
    241a:	4f 93       	push	r20
    241c:	5f 93       	push	r21
    241e:	6f 93       	push	r22
    2420:	7f 93       	push	r23
    2422:	8f 93       	push	r24
    2424:	9f 93       	push	r25
    2426:	af 93       	push	r26
    2428:	bf 93       	push	r27
    242a:	ef 93       	push	r30
    242c:	ff 93       	push	r31
  msg_t b;

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
  b = sdRequestDataI(&SD1);
    242e:	8e e3       	ldi	r24, 0x3E	; 62
    2430:	92 e0       	ldi	r25, 0x02	; 2
    2432:	0e 94 75 10 	call	0x20ea	; 0x20ea <sdRequestDataI>
  chSysUnlockFromIsr();
  if (b < Q_OK)
    2436:	97 fd       	sbrc	r25, 7
    2438:	18 c0       	rjmp	.+48     	; 0x246a <__vector_21+0x5e>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
    243a:	80 93 c6 00 	sts	0x00C6, r24

  CH_IRQ_EPILOGUE();
    243e:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
    2442:	81 11       	cpse	r24, r1
    2444:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
    2448:	ff 91       	pop	r31
    244a:	ef 91       	pop	r30
    244c:	bf 91       	pop	r27
    244e:	af 91       	pop	r26
    2450:	9f 91       	pop	r25
    2452:	8f 91       	pop	r24
    2454:	7f 91       	pop	r23
    2456:	6f 91       	pop	r22
    2458:	5f 91       	pop	r21
    245a:	4f 91       	pop	r20
    245c:	3f 91       	pop	r19
    245e:	2f 91       	pop	r18
    2460:	0f 90       	pop	r0
    2462:	0f be       	out	0x3f, r0	; 63
    2464:	0f 90       	pop	r0
    2466:	1f 90       	pop	r1
    2468:	18 95       	reti

  chSysLockFromIsr();
  b = sdRequestDataI(&SD1);
  chSysUnlockFromIsr();
  if (b < Q_OK)
    UCSR0B &= ~(1 << UDRIE0);
    246a:	80 91 c1 00 	lds	r24, 0x00C1
    246e:	8f 7d       	andi	r24, 0xDF	; 223
    2470:	80 93 c1 00 	sts	0x00C1, r24
    2474:	e4 cf       	rjmp	.-56     	; 0x243e <__vector_21+0x32>

00002476 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if USE_AVR_USART0
  sdObjectInit(&SD1, NULL, notify1);
    2476:	40 ec       	ldi	r20, 0xC0	; 192
    2478:	51 e1       	ldi	r21, 0x11	; 17
    247a:	60 e0       	ldi	r22, 0x00	; 0
    247c:	70 e0       	ldi	r23, 0x00	; 0
    247e:	8e e3       	ldi	r24, 0x3E	; 62
    2480:	92 e0       	ldi	r25, 0x02	; 2
    2482:	0c 94 fe 0f 	jmp	0x1ffc	; 0x1ffc <sdObjectInit>

00002486 <sd_lld_start>:
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    2486:	61 15       	cp	r22, r1
    2488:	71 05       	cpc	r23, r1
    248a:	e1 f0       	breq	.+56     	; 0x24c4 <sd_lld_start+0x3e>
    config = &default_config;

#if USE_AVR_USART0
  if (&SD1 == sdp) {
    248c:	8e 53       	subi	r24, 0x3E	; 62
    248e:	92 40       	sbci	r25, 0x02	; 2
    2490:	09 f0       	breq	.+2      	; 0x2494 <sd_lld_start+0xe>
    2492:	08 95       	ret
 *
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart0_init(const SerialConfig *config) {

  UBRR0L = config->sc_brr;
    2494:	fb 01       	movw	r30, r22
    2496:	80 81       	ld	r24, Z
    2498:	80 93 c4 00 	sts	0x00C4, r24
  UBRR0H = config->sc_brr >> 8;
    249c:	81 81       	ldd	r24, Z+1	; 0x01
    249e:	80 93 c5 00 	sts	0x00C5, r24
  UCSR0A = 0;
    24a2:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    24a6:	88 e9       	ldi	r24, 0x98	; 152
    24a8:	80 93 c1 00 	sts	0x00C1, r24
  switch (config->sc_bits_per_char) {
    24ac:	82 81       	ldd	r24, Z+2	; 0x02
    24ae:	81 30       	cpi	r24, 0x01	; 1
    24b0:	79 f0       	breq	.+30     	; 0x24d0 <sd_lld_start+0x4a>
    24b2:	58 f0       	brcs	.+22     	; 0x24ca <sd_lld_start+0x44>
    24b4:	82 30       	cpi	r24, 0x02	; 2
    24b6:	c9 f0       	breq	.+50     	; 0x24ea <sd_lld_start+0x64>
    24b8:	84 30       	cpi	r24, 0x04	; 4
    24ba:	71 f0       	breq	.+28     	; 0x24d8 <sd_lld_start+0x52>
    UCSR0B |= (1 << UCSZ02);
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_8:
  default:
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    24bc:	86 e0       	ldi	r24, 0x06	; 6
    24be:	80 93 c2 00 	sts	0x00C2, r24
    24c2:	08 95       	ret
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
    24c4:	6a e7       	ldi	r22, 0x7A	; 122
    24c6:	71 e0       	ldi	r23, 0x01	; 1
    24c8:	e1 cf       	rjmp	.-62     	; 0x248c <sd_lld_start+0x6>
  UBRR0H = config->sc_brr >> 8;
  UCSR0A = 0;
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
  switch (config->sc_bits_per_char) {
  case USART_CHAR_SIZE_5:
    UCSR0C = 0;
    24ca:	10 92 c2 00 	sts	0x00C2, r1
    24ce:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    UCSR0C = (1 << UCSZ00);
    24d0:	82 e0       	ldi	r24, 0x02	; 2
    24d2:	80 93 c2 00 	sts	0x00C2, r24
    24d6:	08 95       	ret
    break;
  case USART_CHAR_SIZE_7:
    UCSR0C = (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_9:
    UCSR0B |= (1 << UCSZ02);
    24d8:	80 91 c1 00 	lds	r24, 0x00C1
    24dc:	84 60       	ori	r24, 0x04	; 4
    24de:	80 93 c1 00 	sts	0x00C1, r24
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
    24e2:	86 e0       	ldi	r24, 0x06	; 6
    24e4:	80 93 c2 00 	sts	0x00C2, r24
    24e8:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    UCSR0C = (1 << UCSZ00);
    break;
  case USART_CHAR_SIZE_7:
    UCSR0C = (1 << UCSZ01);
    24ea:	84 e0       	ldi	r24, 0x04	; 4
    24ec:	80 93 c2 00 	sts	0x00C2, r24
    24f0:	08 95       	ret

000024f2 <sd_lld_stop>:
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {

#if USE_AVR_USART0
  if (&SD1 == sdp)
    24f2:	8e 53       	subi	r24, 0x3E	; 62
    24f4:	92 40       	sbci	r25, 0x02	; 2
    24f6:	09 f0       	breq	.+2      	; 0x24fa <sd_lld_stop+0x8>
    24f8:	08 95       	ret
/**
 * @brief   USART0 de-initialization.
 */
static void usart0_deinit(void) {

  UCSR0A = 0;
    24fa:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = 0;
    24fe:	10 92 c1 00 	sts	0x00C1, r1
  UCSR0C = 0;
    2502:	10 92 c2 00 	sts	0x00C2, r1
    2506:	08 95       	ret

00002508 <__vector_24>:
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

#include <util/delay.h>

CH_IRQ_HANDLER(ADC_vect) {
    2508:	1f 92       	push	r1
    250a:	0f 92       	push	r0
    250c:	0f b6       	in	r0, 0x3f	; 63
    250e:	0f 92       	push	r0
    2510:	11 24       	eor	r1, r1
    2512:	af 92       	push	r10
    2514:	bf 92       	push	r11
    2516:	cf 92       	push	r12
    2518:	df 92       	push	r13
    251a:	ef 92       	push	r14
    251c:	ff 92       	push	r15
    251e:	0f 93       	push	r16
    2520:	1f 93       	push	r17
    2522:	2f 93       	push	r18
    2524:	3f 93       	push	r19
    2526:	4f 93       	push	r20
    2528:	5f 93       	push	r21
    252a:	6f 93       	push	r22
    252c:	7f 93       	push	r23
    252e:	8f 93       	push	r24
    2530:	9f 93       	push	r25
    2532:	af 93       	push	r26
    2534:	bf 93       	push	r27
    2536:	cf 93       	push	r28
    2538:	df 93       	push	r29
    253a:	ef 93       	push	r30
    253c:	ff 93       	push	r31
 
  CH_IRQ_PROLOGUE();
	uint8_t low = ADCL;
    253e:	20 91 78 00 	lds	r18, 0x0078
	uint8_t high = ADCH;
    2542:	30 91 79 00 	lds	r19, 0x0079
	uint16_t result = (high << 8) | low;
	
	ADCD1.samples[ADCD1.currentBufferPosition] = result;
    2546:	e0 90 8a 02 	lds	r14, 0x028A
    254a:	f0 90 8b 02 	lds	r15, 0x028B
    254e:	e0 91 9a 02 	lds	r30, 0x029A
    2552:	f0 91 9b 02 	lds	r31, 0x029B
    2556:	ee 0f       	add	r30, r30
    2558:	ff 1f       	adc	r31, r31
    255a:	ee 0d       	add	r30, r14
    255c:	ff 1d       	adc	r31, r15
CH_IRQ_HANDLER(ADC_vect) {
 
  CH_IRQ_PROLOGUE();
	uint8_t low = ADCL;
	uint8_t high = ADCH;
	uint16_t result = (high << 8) | low;
    255e:	93 2f       	mov	r25, r19
    2560:	80 e0       	ldi	r24, 0x00	; 0
    2562:	82 2b       	or	r24, r18
	
	ADCD1.samples[ADCD1.currentBufferPosition] = result;
    2564:	91 83       	std	Z+1, r25	; 0x01
    2566:	80 83       	st	Z, r24
	ADCD1.currentBufferPosition++;
    2568:	20 91 9a 02 	lds	r18, 0x029A
    256c:	30 91 9b 02 	lds	r19, 0x029B
    2570:	2f 5f       	subi	r18, 0xFF	; 255
    2572:	3f 4f       	sbci	r19, 0xFF	; 255
    2574:	30 93 9b 02 	sts	0x029B, r19
    2578:	20 93 9a 02 	sts	0x029A, r18
	
	size_t bufferSize = ADCD1.depth * ADCD1.grpp->num_channels;
    257c:	e0 91 8c 02 	lds	r30, 0x028C
    2580:	f0 91 8d 02 	lds	r31, 0x028D
    2584:	c0 91 8e 02 	lds	r28, 0x028E
    2588:	d0 91 8f 02 	lds	r29, 0x028F
    258c:	69 81       	ldd	r22, Y+1	; 0x01
    258e:	7a 81       	ldd	r23, Y+2	; 0x02
    2590:	6e 9f       	mul	r22, r30
    2592:	60 01       	movw	r12, r0
    2594:	6f 9f       	mul	r22, r31
    2596:	d0 0c       	add	r13, r0
    2598:	7e 9f       	mul	r23, r30
    259a:	d0 0c       	add	r13, r0
    259c:	11 24       	eor	r1, r1
	size_t currentChannel = ADCD1.currentBufferPosition % ADCD1.grpp->num_channels;
    259e:	c9 01       	movw	r24, r18
    25a0:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <__udivmodhi4>
    25a4:	5c 01       	movw	r10, r24
	size_t currentIteration = ADCD1.currentBufferPosition / ADCD1.grpp->num_channels;
	if(ADCD1.grpp-> circular && currentChannel == 0 && currentIteration == ADCD1.depth/2)
    25a6:	88 81       	ld	r24, Y
    25a8:	88 23       	and	r24, r24
    25aa:	21 f0       	breq	.+8      	; 0x25b4 <__vector_24+0xac>
    25ac:	a1 14       	cp	r10, r1
    25ae:	b1 04       	cpc	r11, r1
    25b0:	09 f4       	brne	.+2      	; 0x25b4 <__vector_24+0xac>
    25b2:	3f c0       	rjmp	.+126    	; 0x2632 <__vector_24+0x12a>
	{
	  _adc_isr_half_code(&ADCD1);
	  
	}
	
	if(ADCD1.currentBufferPosition == bufferSize)
    25b4:	c2 16       	cp	r12, r18
    25b6:	d3 06       	cpc	r13, r19
    25b8:	09 f4       	brne	.+2      	; 0x25bc <__vector_24+0xb4>
    25ba:	54 c0       	rjmp	.+168    	; 0x2664 <__vector_24+0x15c>
	  _adc_isr_full_code(&ADCD1);
	}
	else
	{
	  
	  setAdcChannel(getAdcChannelNumberFromMask(ADCD1.grpp->channelsMask,currentChannel));
    25bc:	8d 81       	ldd	r24, Y+5	; 0x05
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t getAdcChannelNumberFromMask(uint8_t mask, uint8_t currentChannel)
{
     for(uint8_t i = 0; mask>0; i++)
    25be:	88 23       	and	r24, r24
    25c0:	59 f0       	breq	.+22     	; 0x25d8 <__vector_24+0xd0>
    25c2:	90 e0       	ldi	r25, 0x00	; 0
     {
	if(mask & 0x01)
    25c4:	80 ff       	sbrs	r24, 0
    25c6:	04 c0       	rjmp	.+8      	; 0x25d0 <__vector_24+0xc8>
	  {
	      if(!currentChannel)
    25c8:	aa 20       	and	r10, r10
    25ca:	09 f4       	brne	.+2      	; 0x25ce <__vector_24+0xc6>
    25cc:	92 c0       	rjmp	.+292    	; 0x26f2 <__vector_24+0x1ea>
		return i;
	      currentChannel--;
    25ce:	aa 94       	dec	r10
	  }
        mask >>= 1;
    25d0:	86 95       	lsr	r24
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t getAdcChannelNumberFromMask(uint8_t mask, uint8_t currentChannel)
{
     for(uint8_t i = 0; mask>0; i++)
    25d2:	9f 5f       	subi	r25, 0xFF	; 255
    25d4:	81 11       	cpse	r24, r1
    25d6:	f6 cf       	rjmp	.-20     	; 0x25c4 <__vector_24+0xbc>
     /* error, should never reach this line */
}

static void setAdcChannel(uint8_t channelNum)
{
	ADMUX = (ADMUX & 0xf8) | (channelNum & 0x07);
    25d8:	80 91 7c 00 	lds	r24, 0x007C
    25dc:	07 70       	andi	r16, 0x07	; 7
    25de:	11 27       	eor	r17, r17
    25e0:	88 7f       	andi	r24, 0xF8	; 248
    25e2:	80 2b       	or	r24, r16
    25e4:	80 93 7c 00 	sts	0x007C, r24
	}
	else
	{
	  
	  setAdcChannel(getAdcChannelNumberFromMask(ADCD1.grpp->channelsMask,currentChannel));
	  ADCSRA |= 1<<ADSC;
    25e8:	80 91 7a 00 	lds	r24, 0x007A
    25ec:	80 64       	ori	r24, 0x40	; 64
    25ee:	80 93 7a 00 	sts	0x007A, r24
	}
 
  CH_IRQ_EPILOGUE();
    25f2:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
    25f6:	81 11       	cpse	r24, r1
    25f8:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
    25fc:	ff 91       	pop	r31
    25fe:	ef 91       	pop	r30
    2600:	df 91       	pop	r29
    2602:	cf 91       	pop	r28
    2604:	bf 91       	pop	r27
    2606:	af 91       	pop	r26
    2608:	9f 91       	pop	r25
    260a:	8f 91       	pop	r24
    260c:	7f 91       	pop	r23
    260e:	6f 91       	pop	r22
    2610:	5f 91       	pop	r21
    2612:	4f 91       	pop	r20
    2614:	3f 91       	pop	r19
    2616:	2f 91       	pop	r18
    2618:	1f 91       	pop	r17
    261a:	0f 91       	pop	r16
    261c:	ff 90       	pop	r15
    261e:	ef 90       	pop	r14
    2620:	df 90       	pop	r13
    2622:	cf 90       	pop	r12
    2624:	bf 90       	pop	r11
    2626:	af 90       	pop	r10
    2628:	0f 90       	pop	r0
    262a:	0f be       	out	0x3f, r0	; 63
    262c:	0f 90       	pop	r0
    262e:	1f 90       	pop	r1
    2630:	18 95       	reti
	ADCD1.currentBufferPosition++;
	
	size_t bufferSize = ADCD1.depth * ADCD1.grpp->num_channels;
	size_t currentChannel = ADCD1.currentBufferPosition % ADCD1.grpp->num_channels;
	size_t currentIteration = ADCD1.currentBufferPosition / ADCD1.grpp->num_channels;
	if(ADCD1.grpp-> circular && currentChannel == 0 && currentIteration == ADCD1.depth/2)
    2632:	af 01       	movw	r20, r30
    2634:	56 95       	lsr	r21
    2636:	47 95       	ror	r20
    2638:	46 17       	cp	r20, r22
    263a:	57 07       	cpc	r21, r23
    263c:	09 f0       	breq	.+2      	; 0x2640 <__vector_24+0x138>
    263e:	ba cf       	rjmp	.-140    	; 0x25b4 <__vector_24+0xac>
	{
	  _adc_isr_half_code(&ADCD1);
    2640:	eb 81       	ldd	r30, Y+3	; 0x03
    2642:	fc 81       	ldd	r31, Y+4	; 0x04
    2644:	30 97       	sbiw	r30, 0x00	; 0
    2646:	09 f4       	brne	.+2      	; 0x264a <__vector_24+0x142>
    2648:	b5 cf       	rjmp	.-150    	; 0x25b4 <__vector_24+0xac>
    264a:	b7 01       	movw	r22, r14
    264c:	87 e8       	ldi	r24, 0x87	; 135
    264e:	92 e0       	ldi	r25, 0x02	; 2
    2650:	09 95       	icall
    2652:	20 91 9a 02 	lds	r18, 0x029A
    2656:	30 91 9b 02 	lds	r19, 0x029B
    265a:	c0 91 8e 02 	lds	r28, 0x028E
    265e:	d0 91 8f 02 	lds	r29, 0x028F
    2662:	a8 cf       	rjmp	.-176    	; 0x25b4 <__vector_24+0xac>
	  
	}
	
	if(ADCD1.currentBufferPosition == bufferSize)
	{
	  _adc_isr_full_code(&ADCD1);
    2664:	88 81       	ld	r24, Y
    2666:	81 11       	cpse	r24, r1
    2668:	47 c0       	rjmp	.+142    	; 0x26f8 <__vector_24+0x1f0>
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
    ADCSRA &= ~(1<<ADSC);
    266a:	80 91 7a 00 	lds	r24, 0x007A
    266e:	8f 7b       	andi	r24, 0xBF	; 191
    2670:	80 93 7a 00 	sts	0x007A, r24
	  
	}
	
	if(ADCD1.currentBufferPosition == bufferSize)
	{
	  _adc_isr_full_code(&ADCD1);
    2674:	eb 81       	ldd	r30, Y+3	; 0x03
    2676:	fc 81       	ldd	r31, Y+4	; 0x04
    2678:	30 97       	sbiw	r30, 0x00	; 0
    267a:	09 f4       	brne	.+2      	; 0x267e <__vector_24+0x176>
    267c:	60 c0       	rjmp	.+192    	; 0x273e <__vector_24+0x236>
    267e:	84 e0       	ldi	r24, 0x04	; 4
    2680:	80 93 87 02 	sts	0x0287, r24
    2684:	40 91 8c 02 	lds	r20, 0x028C
    2688:	50 91 8d 02 	lds	r21, 0x028D
    268c:	42 30       	cpi	r20, 0x02	; 2
    268e:	51 05       	cpc	r21, r1
    2690:	08 f4       	brcc	.+2      	; 0x2694 <__vector_24+0x18c>
    2692:	61 c0       	rjmp	.+194    	; 0x2756 <__vector_24+0x24e>
    2694:	56 95       	lsr	r21
    2696:	47 95       	ror	r20
    2698:	89 81       	ldd	r24, Y+1	; 0x01
    269a:	9a 81       	ldd	r25, Y+2	; 0x02
    269c:	88 0f       	add	r24, r24
    269e:	99 1f       	adc	r25, r25
    26a0:	84 9f       	mul	r24, r20
    26a2:	90 01       	movw	r18, r0
    26a4:	85 9f       	mul	r24, r21
    26a6:	30 0d       	add	r19, r0
    26a8:	94 9f       	mul	r25, r20
    26aa:	30 0d       	add	r19, r0
    26ac:	11 24       	eor	r1, r1
    26ae:	60 91 8a 02 	lds	r22, 0x028A
    26b2:	70 91 8b 02 	lds	r23, 0x028B
    26b6:	62 0f       	add	r22, r18
    26b8:	73 1f       	adc	r23, r19
    26ba:	87 e8       	ldi	r24, 0x87	; 135
    26bc:	92 e0       	ldi	r25, 0x02	; 2
    26be:	09 95       	icall
    26c0:	80 91 87 02 	lds	r24, 0x0287
    26c4:	84 30       	cpi	r24, 0x04	; 4
    26c6:	d9 f1       	breq	.+118    	; 0x273e <__vector_24+0x236>
    26c8:	10 92 8f 02 	sts	0x028F, r1
    26cc:	10 92 8e 02 	sts	0x028E, r1
    26d0:	80 91 90 02 	lds	r24, 0x0290
    26d4:	90 91 91 02 	lds	r25, 0x0291
    26d8:	00 97       	sbiw	r24, 0x00	; 0
    26da:	09 f4       	brne	.+2      	; 0x26de <__vector_24+0x1d6>
    26dc:	8a cf       	rjmp	.-236    	; 0x25f2 <__vector_24+0xea>
    26de:	10 92 91 02 	sts	0x0291, r1
    26e2:	10 92 90 02 	sts	0x0290, r1
    26e6:	fc 01       	movw	r30, r24
    26e8:	13 8a       	std	Z+19, r1	; 0x13
    26ea:	12 8a       	std	Z+18, r1	; 0x12
    26ec:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
    26f0:	80 cf       	rjmp	.-256    	; 0x25f2 <__vector_24+0xea>
     for(uint8_t i = 0; mask>0; i++)
     {
	if(mask & 0x01)
	  {
	      if(!currentChannel)
		return i;
    26f2:	09 2f       	mov	r16, r25
    26f4:	10 e0       	ldi	r17, 0x00	; 0
    26f6:	70 cf       	rjmp	.-288    	; 0x25d8 <__vector_24+0xd0>
	  
	}
	
	if(ADCD1.currentBufferPosition == bufferSize)
	{
	  _adc_isr_full_code(&ADCD1);
    26f8:	eb 81       	ldd	r30, Y+3	; 0x03
    26fa:	fc 81       	ldd	r31, Y+4	; 0x04
    26fc:	30 97       	sbiw	r30, 0x00	; 0
    26fe:	09 f4       	brne	.+2      	; 0x2702 <__vector_24+0x1fa>
    2700:	78 cf       	rjmp	.-272    	; 0x25f2 <__vector_24+0xea>
    2702:	40 91 8c 02 	lds	r20, 0x028C
    2706:	50 91 8d 02 	lds	r21, 0x028D
    270a:	42 30       	cpi	r20, 0x02	; 2
    270c:	51 05       	cpc	r21, r1
    270e:	d8 f0       	brcs	.+54     	; 0x2746 <__vector_24+0x23e>
    2710:	56 95       	lsr	r21
    2712:	47 95       	ror	r20
    2714:	89 81       	ldd	r24, Y+1	; 0x01
    2716:	9a 81       	ldd	r25, Y+2	; 0x02
    2718:	88 0f       	add	r24, r24
    271a:	99 1f       	adc	r25, r25
    271c:	84 9f       	mul	r24, r20
    271e:	90 01       	movw	r18, r0
    2720:	85 9f       	mul	r24, r21
    2722:	30 0d       	add	r19, r0
    2724:	94 9f       	mul	r25, r20
    2726:	30 0d       	add	r19, r0
    2728:	11 24       	eor	r1, r1
    272a:	60 91 8a 02 	lds	r22, 0x028A
    272e:	70 91 8b 02 	lds	r23, 0x028B
    2732:	62 0f       	add	r22, r18
    2734:	73 1f       	adc	r23, r19
    2736:	87 e8       	ldi	r24, 0x87	; 135
    2738:	92 e0       	ldi	r25, 0x02	; 2
    273a:	09 95       	icall
    273c:	5a cf       	rjmp	.-332    	; 0x25f2 <__vector_24+0xea>
    273e:	82 e0       	ldi	r24, 0x02	; 2
    2740:	80 93 87 02 	sts	0x0287, r24
    2744:	c1 cf       	rjmp	.-126    	; 0x26c8 <__vector_24+0x1c0>
    2746:	60 91 8a 02 	lds	r22, 0x028A
    274a:	70 91 8b 02 	lds	r23, 0x028B
    274e:	87 e8       	ldi	r24, 0x87	; 135
    2750:	92 e0       	ldi	r25, 0x02	; 2
    2752:	09 95       	icall
    2754:	4e cf       	rjmp	.-356    	; 0x25f2 <__vector_24+0xea>
    2756:	60 91 8a 02 	lds	r22, 0x028A
    275a:	70 91 8b 02 	lds	r23, 0x028B
    275e:	87 e8       	ldi	r24, 0x87	; 135
    2760:	92 e0       	ldi	r25, 0x02	; 2
    2762:	09 95       	icall
    2764:	ad cf       	rjmp	.-166    	; 0x26c0 <__vector_24+0x1b8>

00002766 <adc_lld_init>:
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
    adcObjectInit(&ADCD1);
    2766:	87 e8       	ldi	r24, 0x87	; 135
    2768:	92 e0       	ldi	r25, 0x02	; 2
    276a:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <adcObjectInit>
    ADCSRA =(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0) |   //prescaler 128, unico valore possibile a 20Mhz
    276e:	8f e0       	ldi	r24, 0x0F	; 15
    2770:	80 93 7a 00 	sts	0x007A, r24
	     (1<<ADIE) ; 	//interrupt

    ADCSRB=0; //single shot
    2774:	10 92 7b 00 	sts	0x007B, r1
    ADMUX=(0<<REFS1)| (0<<REFS0); //uso aref, vale solo per arduino. arduino ha aref collegato
    2778:	10 92 7c 00 	sts	0x007C, r1
    277c:	08 95       	ret

0000277e <adc_lld_start>:
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  if (adcp->state == ADC_STOP) {
    277e:	dc 01       	movw	r26, r24
    2780:	2c 91       	ld	r18, X
    2782:	21 30       	cpi	r18, 0x01	; 1
    2784:	79 f0       	breq	.+30     	; 0x27a4 <adc_lld_start+0x26>
    /* Clock activation.*/
    ADCSRA |= (1<<ADEN);
  }
  
  if (adcp->config != NULL)    
    2786:	dc 01       	movw	r26, r24
    2788:	11 96       	adiw	r26, 0x01	; 1
    278a:	ed 91       	ld	r30, X+
    278c:	fc 91       	ld	r31, X
    278e:	12 97       	sbiw	r26, 0x02	; 2
    2790:	30 97       	sbiw	r30, 0x00	; 0
    2792:	39 f0       	breq	.+14     	; 0x27a2 <adc_lld_start+0x24>
  {
      ADMUX = (adcp->config->analog_reference << REFS0);
    2794:	80 81       	ld	r24, Z
    2796:	82 95       	swap	r24
    2798:	88 0f       	add	r24, r24
    279a:	88 0f       	add	r24, r24
    279c:	80 7c       	andi	r24, 0xC0	; 192
    279e:	80 93 7c 00 	sts	0x007C, r24
    27a2:	08 95       	ret
 */
void adc_lld_start(ADCDriver *adcp) {

  if (adcp->state == ADC_STOP) {
    /* Clock activation.*/
    ADCSRA |= (1<<ADEN);
    27a4:	20 91 7a 00 	lds	r18, 0x007A
    27a8:	20 68       	ori	r18, 0x80	; 128
    27aa:	20 93 7a 00 	sts	0x007A, r18
    27ae:	eb cf       	rjmp	.-42     	; 0x2786 <adc_lld_start+0x8>

000027b0 <adc_lld_stop>:
 *
 * @notapi
 */
void adc_lld_stop(ADCDriver *adcp) {

  if (adcp->state == ADC_READY) {
    27b0:	fc 01       	movw	r30, r24
    27b2:	80 81       	ld	r24, Z
    27b4:	82 30       	cpi	r24, 0x02	; 2
    27b6:	09 f0       	breq	.+2      	; 0x27ba <adc_lld_stop+0xa>
    27b8:	08 95       	ret
    /* Clock de-activation.*/
    ADCSRA &= ~(1<<ADEN);  
    27ba:	80 91 7a 00 	lds	r24, 0x007A
    27be:	8f 77       	andi	r24, 0x7F	; 127
    27c0:	80 93 7a 00 	sts	0x007A, r24
    27c4:	08 95       	ret

000027c6 <adc_lld_start_conversion>:
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
	adcp->currentBufferPosition=0;
    27c6:	dc 01       	movw	r26, r24
    27c8:	54 96       	adiw	r26, 0x14	; 20
    27ca:	1c 92       	st	X, r1
    27cc:	1e 92       	st	-X, r1
    27ce:	53 97       	sbiw	r26, 0x13	; 19
	
	setAdcChannel(getAdcChannelNumberFromMask(adcp->grpp->channelsMask,0));
    27d0:	17 96       	adiw	r26, 0x07	; 7
    27d2:	ed 91       	ld	r30, X+
    27d4:	fc 91       	ld	r31, X
    27d6:	18 97       	sbiw	r26, 0x08	; 8
    27d8:	85 81       	ldd	r24, Z+5	; 0x05
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t getAdcChannelNumberFromMask(uint8_t mask, uint8_t currentChannel)
{
     for(uint8_t i = 0; mask>0; i++)
    27da:	88 23       	and	r24, r24
    27dc:	51 f0       	breq	.+20     	; 0x27f2 <adc_lld_start_conversion+0x2c>
     {
	if(mask & 0x01)
    27de:	80 fd       	sbrc	r24, 0
    27e0:	1a c0       	rjmp	.+52     	; 0x2816 <adc_lld_start_conversion+0x50>
    27e2:	90 e0       	ldi	r25, 0x00	; 0
    27e4:	02 c0       	rjmp	.+4      	; 0x27ea <adc_lld_start_conversion+0x24>
    27e6:	80 fd       	sbrc	r24, 0
    27e8:	13 c0       	rjmp	.+38     	; 0x2810 <adc_lld_start_conversion+0x4a>
	  {
	      if(!currentChannel)
		return i;
	      currentChannel--;
	  }
        mask >>= 1;
    27ea:	86 95       	lsr	r24
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t getAdcChannelNumberFromMask(uint8_t mask, uint8_t currentChannel)
{
     for(uint8_t i = 0; mask>0; i++)
    27ec:	9f 5f       	subi	r25, 0xFF	; 255
    27ee:	81 11       	cpse	r24, r1
    27f0:	fa cf       	rjmp	.-12     	; 0x27e6 <adc_lld_start_conversion+0x20>
     /* error, should never reach this line */
}

static void setAdcChannel(uint8_t channelNum)
{
	ADMUX = (ADMUX & 0xf8) | (channelNum & 0x07);
    27f2:	40 91 7c 00 	lds	r20, 0x007C
    27f6:	c9 01       	movw	r24, r18
    27f8:	87 70       	andi	r24, 0x07	; 7
    27fa:	99 27       	eor	r25, r25
    27fc:	48 7f       	andi	r20, 0xF8	; 248
    27fe:	48 2b       	or	r20, r24
    2800:	40 93 7c 00 	sts	0x007C, r20
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
	adcp->currentBufferPosition=0;
	
	setAdcChannel(getAdcChannelNumberFromMask(adcp->grpp->channelsMask,0));
	ADCSRA |= 1<<ADSC;
    2804:	80 91 7a 00 	lds	r24, 0x007A
    2808:	80 64       	ori	r24, 0x40	; 64
    280a:	80 93 7a 00 	sts	0x007A, r24
    280e:	08 95       	ret
    2810:	29 2f       	mov	r18, r25
    2812:	30 e0       	ldi	r19, 0x00	; 0
    2814:	ee cf       	rjmp	.-36     	; 0x27f2 <adc_lld_start_conversion+0x2c>

static size_t getAdcChannelNumberFromMask(uint8_t mask, uint8_t currentChannel)
{
     for(uint8_t i = 0; mask>0; i++)
     {
	if(mask & 0x01)
    2816:	20 e0       	ldi	r18, 0x00	; 0
    2818:	30 e0       	ldi	r19, 0x00	; 0
    281a:	eb cf       	rjmp	.-42     	; 0x27f2 <adc_lld_start_conversion+0x2c>

0000281c <adc_lld_stop_conversion>:
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
    ADCSRA &= ~(1<<ADSC);
    281c:	ea e7       	ldi	r30, 0x7A	; 122
    281e:	f0 e0       	ldi	r31, 0x00	; 0
    2820:	80 81       	ld	r24, Z
    2822:	8f 7b       	andi	r24, 0xBF	; 191
    2824:	80 83       	st	Z, r24
    2826:	08 95       	ret

00002828 <getTimerIndex>:

uint8_t getTimerIndex(PWMDriver *gptp)
{
    uint8_t index = 0;
#if USE_AVR_PWM1 || defined(__DOXYGEN__)
    if (gptp == &PWMD1) return index;
    2828:	81 5a       	subi	r24, 0xA1	; 161
    282a:	92 40       	sbci	r25, 0x02	; 2
    282c:	09 f0       	breq	.+2      	; 0x2830 <getTimerIndex+0x8>
    282e:	08 95       	ret
    2830:	80 e0       	ldi	r24, 0x00	; 0
#endif
#if USE_AVR_PWM5 || defined(__DOXYGEN__)
    if (gptp == &PWMD1) return index;
    else index++;
#endif
}
    2832:	08 95       	ret

00002834 <__vector_15>:
 *
 *
 */
#if USE_AVR_PWM1 || defined(__DOXYGEN__)
CH_IRQ_HANDLER(TIMER1_OVF_vect)
{
    2834:	1f 92       	push	r1
    2836:	0f 92       	push	r0
    2838:	0f b6       	in	r0, 0x3f	; 63
    283a:	0f 92       	push	r0
    283c:	11 24       	eor	r1, r1
    283e:	2f 93       	push	r18
    2840:	3f 93       	push	r19
    2842:	4f 93       	push	r20
    2844:	5f 93       	push	r21
    2846:	6f 93       	push	r22
    2848:	7f 93       	push	r23
    284a:	8f 93       	push	r24
    284c:	9f 93       	push	r25
    284e:	af 93       	push	r26
    2850:	bf 93       	push	r27
    2852:	ef 93       	push	r30
    2854:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD1.config->callback(&PWMD1);
    2856:	e0 91 a2 02 	lds	r30, 0x02A2
    285a:	f0 91 a3 02 	lds	r31, 0x02A3
    285e:	06 80       	ldd	r0, Z+6	; 0x06
    2860:	f7 81       	ldd	r31, Z+7	; 0x07
    2862:	e0 2d       	mov	r30, r0
    2864:	81 ea       	ldi	r24, 0xA1	; 161
    2866:	92 e0       	ldi	r25, 0x02	; 2
    2868:	09 95       	icall
    CH_IRQ_EPILOGUE();
    286a:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
    286e:	81 11       	cpse	r24, r1
    2870:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
    2874:	ff 91       	pop	r31
    2876:	ef 91       	pop	r30
    2878:	bf 91       	pop	r27
    287a:	af 91       	pop	r26
    287c:	9f 91       	pop	r25
    287e:	8f 91       	pop	r24
    2880:	7f 91       	pop	r23
    2882:	6f 91       	pop	r22
    2884:	5f 91       	pop	r21
    2886:	4f 91       	pop	r20
    2888:	3f 91       	pop	r19
    288a:	2f 91       	pop	r18
    288c:	0f 90       	pop	r0
    288e:	0f be       	out	0x3f, r0	; 63
    2890:	0f 90       	pop	r0
    2892:	1f 90       	pop	r1
    2894:	18 95       	reti

00002896 <__vector_13>:
CH_IRQ_HANDLER(TIMER1_COMPA_vect)
{
    2896:	1f 92       	push	r1
    2898:	0f 92       	push	r0
    289a:	0f b6       	in	r0, 0x3f	; 63
    289c:	0f 92       	push	r0
    289e:	11 24       	eor	r1, r1
    28a0:	2f 93       	push	r18
    28a2:	3f 93       	push	r19
    28a4:	4f 93       	push	r20
    28a6:	5f 93       	push	r21
    28a8:	6f 93       	push	r22
    28aa:	7f 93       	push	r23
    28ac:	8f 93       	push	r24
    28ae:	9f 93       	push	r25
    28b0:	af 93       	push	r26
    28b2:	bf 93       	push	r27
    28b4:	ef 93       	push	r30
    28b6:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD1.config->channels[0].callback(&PWMD1);
    28b8:	e0 91 a2 02 	lds	r30, 0x02A2
    28bc:	f0 91 a3 02 	lds	r31, 0x02A3
    28c0:	04 84       	ldd	r0, Z+12	; 0x0c
    28c2:	f5 85       	ldd	r31, Z+13	; 0x0d
    28c4:	e0 2d       	mov	r30, r0
    28c6:	81 ea       	ldi	r24, 0xA1	; 161
    28c8:	92 e0       	ldi	r25, 0x02	; 2
    28ca:	09 95       	icall
    CH_IRQ_EPILOGUE();
    28cc:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
    28d0:	81 11       	cpse	r24, r1
    28d2:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
    28d6:	ff 91       	pop	r31
    28d8:	ef 91       	pop	r30
    28da:	bf 91       	pop	r27
    28dc:	af 91       	pop	r26
    28de:	9f 91       	pop	r25
    28e0:	8f 91       	pop	r24
    28e2:	7f 91       	pop	r23
    28e4:	6f 91       	pop	r22
    28e6:	5f 91       	pop	r21
    28e8:	4f 91       	pop	r20
    28ea:	3f 91       	pop	r19
    28ec:	2f 91       	pop	r18
    28ee:	0f 90       	pop	r0
    28f0:	0f be       	out	0x3f, r0	; 63
    28f2:	0f 90       	pop	r0
    28f4:	1f 90       	pop	r1
    28f6:	18 95       	reti

000028f8 <__vector_14>:
CH_IRQ_HANDLER(TIMER1_COMPB_vect)
{
    28f8:	1f 92       	push	r1
    28fa:	0f 92       	push	r0
    28fc:	0f b6       	in	r0, 0x3f	; 63
    28fe:	0f 92       	push	r0
    2900:	11 24       	eor	r1, r1
    2902:	2f 93       	push	r18
    2904:	3f 93       	push	r19
    2906:	4f 93       	push	r20
    2908:	5f 93       	push	r21
    290a:	6f 93       	push	r22
    290c:	7f 93       	push	r23
    290e:	8f 93       	push	r24
    2910:	9f 93       	push	r25
    2912:	af 93       	push	r26
    2914:	bf 93       	push	r27
    2916:	ef 93       	push	r30
    2918:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD1.config->channels[1].callback(&PWMD1);
    291a:	e0 91 a2 02 	lds	r30, 0x02A2
    291e:	f0 91 a3 02 	lds	r31, 0x02A3
    2922:	02 88       	ldd	r0, Z+18	; 0x12
    2924:	f3 89       	ldd	r31, Z+19	; 0x13
    2926:	e0 2d       	mov	r30, r0
    2928:	81 ea       	ldi	r24, 0xA1	; 161
    292a:	92 e0       	ldi	r25, 0x02	; 2
    292c:	09 95       	icall
    CH_IRQ_EPILOGUE();
    292e:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
    2932:	81 11       	cpse	r24, r1
    2934:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
    2938:	ff 91       	pop	r31
    293a:	ef 91       	pop	r30
    293c:	bf 91       	pop	r27
    293e:	af 91       	pop	r26
    2940:	9f 91       	pop	r25
    2942:	8f 91       	pop	r24
    2944:	7f 91       	pop	r23
    2946:	6f 91       	pop	r22
    2948:	5f 91       	pop	r21
    294a:	4f 91       	pop	r20
    294c:	3f 91       	pop	r19
    294e:	2f 91       	pop	r18
    2950:	0f 90       	pop	r0
    2952:	0f be       	out	0x3f, r0	; 63
    2954:	0f 90       	pop	r0
    2956:	1f 90       	pop	r1
    2958:	18 95       	reti

0000295a <__vector_11>:
}
#endif
#endif
#if USE_AVR_PWM2 || defined(__DOXYGEN__)
CH_IRQ_HANDLER(TIMER2_OVF_vect)
{
    295a:	1f 92       	push	r1
    295c:	0f 92       	push	r0
    295e:	0f b6       	in	r0, 0x3f	; 63
    2960:	0f 92       	push	r0
    2962:	11 24       	eor	r1, r1
    2964:	2f 93       	push	r18
    2966:	3f 93       	push	r19
    2968:	4f 93       	push	r20
    296a:	5f 93       	push	r21
    296c:	6f 93       	push	r22
    296e:	7f 93       	push	r23
    2970:	8f 93       	push	r24
    2972:	9f 93       	push	r25
    2974:	af 93       	push	r26
    2976:	bf 93       	push	r27
    2978:	ef 93       	push	r30
    297a:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD2.config->callback(&PWMD2);
    297c:	e0 91 9d 02 	lds	r30, 0x029D
    2980:	f0 91 9e 02 	lds	r31, 0x029E
    2984:	06 80       	ldd	r0, Z+6	; 0x06
    2986:	f7 81       	ldd	r31, Z+7	; 0x07
    2988:	e0 2d       	mov	r30, r0
    298a:	8c e9       	ldi	r24, 0x9C	; 156
    298c:	92 e0       	ldi	r25, 0x02	; 2
    298e:	09 95       	icall
    CH_IRQ_EPILOGUE();
    2990:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
    2994:	81 11       	cpse	r24, r1
    2996:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
    299a:	ff 91       	pop	r31
    299c:	ef 91       	pop	r30
    299e:	bf 91       	pop	r27
    29a0:	af 91       	pop	r26
    29a2:	9f 91       	pop	r25
    29a4:	8f 91       	pop	r24
    29a6:	7f 91       	pop	r23
    29a8:	6f 91       	pop	r22
    29aa:	5f 91       	pop	r21
    29ac:	4f 91       	pop	r20
    29ae:	3f 91       	pop	r19
    29b0:	2f 91       	pop	r18
    29b2:	0f 90       	pop	r0
    29b4:	0f be       	out	0x3f, r0	; 63
    29b6:	0f 90       	pop	r0
    29b8:	1f 90       	pop	r1
    29ba:	18 95       	reti

000029bc <__vector_9>:
CH_IRQ_HANDLER(TIMER2_COMPA_vect)
{
    29bc:	1f 92       	push	r1
    29be:	0f 92       	push	r0
    29c0:	0f b6       	in	r0, 0x3f	; 63
    29c2:	0f 92       	push	r0
    29c4:	11 24       	eor	r1, r1
    29c6:	2f 93       	push	r18
    29c8:	3f 93       	push	r19
    29ca:	4f 93       	push	r20
    29cc:	5f 93       	push	r21
    29ce:	6f 93       	push	r22
    29d0:	7f 93       	push	r23
    29d2:	8f 93       	push	r24
    29d4:	9f 93       	push	r25
    29d6:	af 93       	push	r26
    29d8:	bf 93       	push	r27
    29da:	ef 93       	push	r30
    29dc:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD2.config->channels[0].callback(&PWMD2);
    29de:	e0 91 9d 02 	lds	r30, 0x029D
    29e2:	f0 91 9e 02 	lds	r31, 0x029E
    29e6:	04 84       	ldd	r0, Z+12	; 0x0c
    29e8:	f5 85       	ldd	r31, Z+13	; 0x0d
    29ea:	e0 2d       	mov	r30, r0
    29ec:	8c e9       	ldi	r24, 0x9C	; 156
    29ee:	92 e0       	ldi	r25, 0x02	; 2
    29f0:	09 95       	icall
    CH_IRQ_EPILOGUE();
    29f2:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
    29f6:	81 11       	cpse	r24, r1
    29f8:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
    29fc:	ff 91       	pop	r31
    29fe:	ef 91       	pop	r30
    2a00:	bf 91       	pop	r27
    2a02:	af 91       	pop	r26
    2a04:	9f 91       	pop	r25
    2a06:	8f 91       	pop	r24
    2a08:	7f 91       	pop	r23
    2a0a:	6f 91       	pop	r22
    2a0c:	5f 91       	pop	r21
    2a0e:	4f 91       	pop	r20
    2a10:	3f 91       	pop	r19
    2a12:	2f 91       	pop	r18
    2a14:	0f 90       	pop	r0
    2a16:	0f be       	out	0x3f, r0	; 63
    2a18:	0f 90       	pop	r0
    2a1a:	1f 90       	pop	r1
    2a1c:	18 95       	reti

00002a1e <__vector_10>:
CH_IRQ_HANDLER(TIMER2_COMPB_vect)
{
    2a1e:	1f 92       	push	r1
    2a20:	0f 92       	push	r0
    2a22:	0f b6       	in	r0, 0x3f	; 63
    2a24:	0f 92       	push	r0
    2a26:	11 24       	eor	r1, r1
    2a28:	2f 93       	push	r18
    2a2a:	3f 93       	push	r19
    2a2c:	4f 93       	push	r20
    2a2e:	5f 93       	push	r21
    2a30:	6f 93       	push	r22
    2a32:	7f 93       	push	r23
    2a34:	8f 93       	push	r24
    2a36:	9f 93       	push	r25
    2a38:	af 93       	push	r26
    2a3a:	bf 93       	push	r27
    2a3c:	ef 93       	push	r30
    2a3e:	ff 93       	push	r31
    CH_IRQ_PROLOGUE();
    PWMD2.config->channels[1].callback(&PWMD2);
    2a40:	e0 91 9d 02 	lds	r30, 0x029D
    2a44:	f0 91 9e 02 	lds	r31, 0x029E
    2a48:	02 88       	ldd	r0, Z+18	; 0x12
    2a4a:	f3 89       	ldd	r31, Z+19	; 0x13
    2a4c:	e0 2d       	mov	r30, r0
    2a4e:	8c e9       	ldi	r24, 0x9C	; 156
    2a50:	92 e0       	ldi	r25, 0x02	; 2
    2a52:	09 95       	icall
    CH_IRQ_EPILOGUE();
    2a54:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
    2a58:	81 11       	cpse	r24, r1
    2a5a:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
    2a5e:	ff 91       	pop	r31
    2a60:	ef 91       	pop	r30
    2a62:	bf 91       	pop	r27
    2a64:	af 91       	pop	r26
    2a66:	9f 91       	pop	r25
    2a68:	8f 91       	pop	r24
    2a6a:	7f 91       	pop	r23
    2a6c:	6f 91       	pop	r22
    2a6e:	5f 91       	pop	r21
    2a70:	4f 91       	pop	r20
    2a72:	3f 91       	pop	r19
    2a74:	2f 91       	pop	r18
    2a76:	0f 90       	pop	r0
    2a78:	0f be       	out	0x3f, r0	; 63
    2a7a:	0f 90       	pop	r0
    2a7c:	1f 90       	pop	r1
    2a7e:	18 95       	reti

00002a80 <pwm_lld_init>:
 */
void pwm_lld_init(void)
{

#if USE_AVR_PWM1 || defined(__DOXYGEN__)
    pwmObjectInit(&PWMD1);
    2a80:	81 ea       	ldi	r24, 0xA1	; 161
    2a82:	92 e0       	ldi	r25, 0x02	; 2
    2a84:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <pwmObjectInit>
    TCCR1A = (0<<WGM11) | (1<<WGM10);   //fast pwm 8 bit
    2a88:	81 e0       	ldi	r24, 0x01	; 1
    2a8a:	80 93 80 00 	sts	0x0080, r24
    TCCR1B = (1<<WGM12) | (0<<WGM13);  //fast pwm 8 bit
    2a8e:	88 e0       	ldi	r24, 0x08	; 8
    2a90:	80 93 81 00 	sts	0x0081, r24
#endif
#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    pwmObjectInit(&PWMD2);
    2a94:	8c e9       	ldi	r24, 0x9C	; 156
    2a96:	92 e0       	ldi	r25, 0x02	; 2
    2a98:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <pwmObjectInit>
    TCCR2A = (1<<WGM21) | (1<<WGM20);   //fast pwm 8 bit
    2a9c:	83 e0       	ldi	r24, 0x03	; 3
    2a9e:	80 93 b0 00 	sts	0x00B0, r24
    TCCR2B = (0<<WGM22);  //fast pwm 8 bit
    2aa2:	10 92 b1 00 	sts	0x00B1, r1
    2aa6:	08 95       	ret

00002aa8 <pwm_lld_start>:
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp)
{

    if ( pwmp->state == PWM_STOP)
    2aa8:	fc 01       	movw	r30, r24
    2aaa:	20 81       	ld	r18, Z
    2aac:	21 30       	cpi	r18, 0x01	; 1
    2aae:	09 f0       	breq	.+2      	; 0x2ab2 <pwm_lld_start+0xa>
    2ab0:	08 95       	ret
    {
        /* Clock activation.*/

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
        if(pwmp == &PWMD2)
    2ab2:	8c 59       	subi	r24, 0x9C	; 156
    2ab4:	92 40       	sbci	r25, 0x02	; 2
    2ab6:	69 f0       	breq	.+26     	; 0x2ad2 <pwm_lld_start+0x2a>
            return;
        }
#endif
//{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
        uint8_t index = getTimerIndex(pwmp);
        *timer_registers_table[index][1] |= (1<<CS12) |(0<<CS11) | (1<<CS10);
    2ab8:	e0 91 02 01 	lds	r30, 0x0102
    2abc:	f0 91 03 01 	lds	r31, 0x0103
    2ac0:	80 81       	ld	r24, Z
    2ac2:	85 60       	ori	r24, 0x05	; 5
    2ac4:	80 83       	st	Z, r24
        *timer_registers_table[index][10] = (1<<TOIE1);
    2ac6:	e0 91 14 01 	lds	r30, 0x0114
    2aca:	f0 91 15 01 	lds	r31, 0x0115
    2ace:	20 83       	st	Z, r18
    2ad0:	08 95       	ret
        /* Clock activation.*/

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
        if(pwmp == &PWMD2)
        {
            TCCR2B |= (0<<CS22) |(0<<CS21) | (1<<CS20); //parti col no prescaling
    2ad2:	80 91 b1 00 	lds	r24, 0x00B1
    2ad6:	81 60       	ori	r24, 0x01	; 1
    2ad8:	80 93 b1 00 	sts	0x00B1, r24
            if(pwmp->config->callback != NULL)
    2adc:	e0 91 9d 02 	lds	r30, 0x029D
    2ae0:	f0 91 9e 02 	lds	r31, 0x029E
    2ae4:	86 81       	ldd	r24, Z+6	; 0x06
    2ae6:	97 81       	ldd	r25, Z+7	; 0x07
    2ae8:	89 2b       	or	r24, r25
    2aea:	11 f3       	breq	.-60     	; 0x2ab0 <pwm_lld_start+0x8>
                TIMSK2 = (1<<TOIE2);
    2aec:	20 93 70 00 	sts	0x0070, r18
    2af0:	08 95       	ret

00002af2 <pwm_lld_stop>:
 */
void pwm_lld_stop(PWMDriver *pwmp)
{
//{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
    uint8_t index = getTimerIndex(pwmp);
    *timer_registers_table[index][1] &= ~((1<<CS12) |(1<<CS11) | (1<<CS10));
    2af2:	e0 91 02 01 	lds	r30, 0x0102
    2af6:	f0 91 03 01 	lds	r31, 0x0103
    2afa:	80 81       	ld	r24, Z
    2afc:	88 7f       	andi	r24, 0xF8	; 248
    2afe:	80 83       	st	Z, r24
    *timer_registers_table[index][11] = 0;
    2b00:	e0 91 16 01 	lds	r30, 0x0116
    2b04:	f0 91 17 01 	lds	r31, 0x0117
    2b08:	10 82       	st	Z, r1
    2b0a:	08 95       	ret

00002b0c <pwm_lld_change_period>:
 * @param[in] period    new cycle time in ticks
 *
 * @notapi
 */
void pwm_lld_change_period(PWMDriver *pwmp, pwmcnt_t period)
{
    2b0c:	08 95       	ret

00002b0e <pwm_lld_enable_channel>:
 * @notapi
 */
void pwm_lld_enable_channel(PWMDriver *pwmp,
                            pwmchannel_t channel,
                            pwmcnt_t width)
{
    2b0e:	af 92       	push	r10
    2b10:	bf 92       	push	r11
    2b12:	cf 92       	push	r12
    2b14:	df 92       	push	r13
    2b16:	ef 92       	push	r14
    2b18:	ff 92       	push	r15
    2b1a:	0f 93       	push	r16
    2b1c:	1f 93       	push	r17
    2b1e:	cf 93       	push	r28
    2b20:	df 93       	push	r29
    2b22:	ec 01       	movw	r28, r24
    2b24:	b6 2e       	mov	r11, r22
    uint32_t val = width;
    val *= 256;
    2b26:	ca 01       	movw	r24, r20
    2b28:	a0 e0       	ldi	r26, 0x00	; 0
    2b2a:	b0 e0       	ldi	r27, 0x00	; 0
    2b2c:	66 27       	eor	r22, r22
    2b2e:	78 2f       	mov	r23, r24
    2b30:	89 2f       	mov	r24, r25
    2b32:	9a 2f       	mov	r25, r26
    val /= (uint32_t)pwmp->period;
    2b34:	2b 81       	ldd	r18, Y+3	; 0x03
    2b36:	3c 81       	ldd	r19, Y+4	; 0x04
    2b38:	40 e0       	ldi	r20, 0x00	; 0
    2b3a:	50 e0       	ldi	r21, 0x00	; 0
    2b3c:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <__udivmodsi4>
    2b40:	89 01       	movw	r16, r18
    2b42:	9a 01       	movw	r18, r20
    2b44:	0f 3f       	cpi	r16, 0xFF	; 255
    2b46:	11 05       	cpc	r17, r1
    2b48:	21 05       	cpc	r18, r1
    2b4a:	31 05       	cpc	r19, r1
    2b4c:	29 f0       	breq	.+10     	; 0x2b58 <pwm_lld_enable_channel+0x4a>
    2b4e:	20 f0       	brcs	.+8      	; 0x2b58 <pwm_lld_enable_channel+0x4a>
    2b50:	0f ef       	ldi	r16, 0xFF	; 255
    2b52:	10 e0       	ldi	r17, 0x00	; 0
    2b54:	20 e0       	ldi	r18, 0x00	; 0
    2b56:	30 e0       	ldi	r19, 0x00	; 0
    if(val > 0x00FF)
        val = 0xFF;

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    if(pwmp == &PWMD2)
    2b58:	42 e0       	ldi	r20, 0x02	; 2
    2b5a:	cc 39       	cpi	r28, 0x9C	; 156
    2b5c:	d4 07       	cpc	r29, r20
    2b5e:	09 f4       	brne	.+2      	; 0x2b62 <pwm_lld_enable_channel+0x54>
    2b60:	8a c0       	rjmp	.+276    	; 0x2c76 <pwm_lld_enable_channel+0x168>
    }
#endif

    //{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2b62:	4b 2d       	mov	r20, r11
    2b64:	50 e0       	ldi	r21, 0x00	; 0
    2b66:	e9 81       	ldd	r30, Y+1	; 0x01
    2b68:	fa 81       	ldd	r31, Y+2	; 0x02
    2b6a:	da 01       	movw	r26, r20
    2b6c:	aa 0f       	add	r26, r26
    2b6e:	bb 1f       	adc	r27, r27
    2b70:	cd 01       	movw	r24, r26
    2b72:	84 0f       	add	r24, r20
    2b74:	95 1f       	adc	r25, r21
    2b76:	88 0f       	add	r24, r24
    2b78:	99 1f       	adc	r25, r25
    2b7a:	e8 0f       	add	r30, r24
    2b7c:	f9 1f       	adc	r31, r25
    2b7e:	c0 84       	ldd	r12, Z+8	; 0x08
    2b80:	d1 84       	ldd	r13, Z+9	; 0x09
    2b82:	e2 84       	ldd	r14, Z+10	; 0x0a
    2b84:	f3 84       	ldd	r15, Z+11	; 0x0b
    2b86:	e0 91 00 01 	lds	r30, 0x0100
    2b8a:	f0 91 01 01 	lds	r31, 0x0101
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2b8e:	a0 80       	ld	r10, Z
    }
#endif

    //{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2b90:	8b 2d       	mov	r24, r11
    2b92:	81 95       	neg	r24
    2b94:	88 0f       	add	r24, r24
    2b96:	89 5f       	subi	r24, 0xF9	; 249
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2b98:	61 e0       	ldi	r22, 0x01	; 1
    2b9a:	70 e0       	ldi	r23, 0x00	; 0
    2b9c:	b6 2e       	mov	r11, r22
    2b9e:	01 c0       	rjmp	.+2      	; 0x2ba2 <pwm_lld_enable_channel+0x94>
    2ba0:	bb 0c       	add	r11, r11
    2ba2:	8a 95       	dec	r24
    2ba4:	ea f7       	brpl	.-6      	; 0x2ba0 <pwm_lld_enable_channel+0x92>
    }
#endif

    //{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2ba6:	83 e0       	ldi	r24, 0x03	; 3
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	84 1b       	sub	r24, r20
    2bac:	95 0b       	sbc	r25, r21
    2bae:	88 0f       	add	r24, r24
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2bb0:	08 2e       	mov	r0, r24
    2bb2:	01 c0       	rjmp	.+2      	; 0x2bb6 <pwm_lld_enable_channel+0xa8>
    2bb4:	66 0f       	add	r22, r22
    2bb6:	0a 94       	dec	r0
    2bb8:	ea f7       	brpl	.-6      	; 0x2bb4 <pwm_lld_enable_channel+0xa6>
    2bba:	6b 29       	or	r22, r11
    2bbc:	96 2f       	mov	r25, r22
    2bbe:	90 95       	com	r25
    2bc0:	9a 21       	and	r25, r10
    2bc2:	90 83       	st	Z, r25
    if(PWM_OUTPUT_ACTIVE_HIGH ==mode )
    2bc4:	81 e0       	ldi	r24, 0x01	; 1
    2bc6:	c8 16       	cp	r12, r24
    2bc8:	d1 04       	cpc	r13, r1
    2bca:	e1 04       	cpc	r14, r1
    2bcc:	f1 04       	cpc	r15, r1
    2bce:	09 f4       	brne	.+2      	; 0x2bd2 <pwm_lld_enable_channel+0xc4>
    2bd0:	4e c0       	rjmp	.+156    	; 0x2c6e <pwm_lld_enable_channel+0x160>
        *TCCRnA |=  ((1<<COMnx1) | (0<<COMnx0)); //non inverting mode
    if(PWM_OUTPUT_ACTIVE_LOW ==mode)
    2bd2:	82 e0       	ldi	r24, 0x02	; 2
    2bd4:	c8 16       	cp	r12, r24
    2bd6:	d1 04       	cpc	r13, r1
    2bd8:	e1 04       	cpc	r14, r1
    2bda:	f1 04       	cpc	r15, r1
    2bdc:	09 f4       	brne	.+2      	; 0x2be0 <pwm_lld_enable_channel+0xd2>
    2bde:	43 c0       	rjmp	.+134    	; 0x2c66 <pwm_lld_enable_channel+0x158>
#endif

    //{&TCCR1A,  &TCCR1B, &OCR1AH,&OCR1AL,&OCR1BH,&OCR1BL,&OCR1CH,&OCR1CL,&TCNT1H,&TCNT1L,&TIFR1,&TIMSK1},
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    *timer_registers_table[index][2*channel+2] = 0;
    2be0:	ca 01       	movw	r24, r20
    2be2:	01 96       	adiw	r24, 0x01	; 1
    2be4:	fc 01       	movw	r30, r24
    2be6:	ee 0f       	add	r30, r30
    2be8:	ff 1f       	adc	r31, r31
    2bea:	ee 0f       	add	r30, r30
    2bec:	ff 1f       	adc	r31, r31
    2bee:	e0 50       	subi	r30, 0x00	; 0
    2bf0:	ff 4f       	sbci	r31, 0xFF	; 255
    2bf2:	01 90       	ld	r0, Z+
    2bf4:	f0 81       	ld	r31, Z
    2bf6:	e0 2d       	mov	r30, r0
    2bf8:	10 82       	st	Z, r1
    *timer_registers_table[index][2*channel+3] = val;
    2bfa:	fa 01       	movw	r30, r20
    2bfc:	ee 0f       	add	r30, r30
    2bfe:	ff 1f       	adc	r31, r31
    2c00:	ee 0f       	add	r30, r30
    2c02:	ff 1f       	adc	r31, r31
    2c04:	ea 5f       	subi	r30, 0xFA	; 250
    2c06:	fe 4f       	sbci	r31, 0xFE	; 254
    2c08:	01 90       	ld	r0, Z+
    2c0a:	f0 81       	ld	r31, Z
    2c0c:	e0 2d       	mov	r30, r0
    2c0e:	00 83       	st	Z, r16
    *timer_registers_table[index][10] |= (1<< (channel + 1));
    2c10:	e0 91 14 01 	lds	r30, 0x0114
    2c14:	f0 91 15 01 	lds	r31, 0x0115
    2c18:	90 81       	ld	r25, Z
    2c1a:	21 e0       	ldi	r18, 0x01	; 1
    2c1c:	30 e0       	ldi	r19, 0x00	; 0
    2c1e:	01 c0       	rjmp	.+2      	; 0x2c22 <pwm_lld_enable_channel+0x114>
    2c20:	22 0f       	add	r18, r18
    2c22:	8a 95       	dec	r24
    2c24:	ea f7       	brpl	.-6      	; 0x2c20 <pwm_lld_enable_channel+0x112>
    2c26:	92 2b       	or	r25, r18
    2c28:	90 83       	st	Z, r25
    if(pwmp->config->channels[channel].callback != NULL)
    2c2a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c2c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c2e:	4a 0f       	add	r20, r26
    2c30:	5b 1f       	adc	r21, r27
    2c32:	44 0f       	add	r20, r20
    2c34:	55 1f       	adc	r21, r21
    2c36:	e4 0f       	add	r30, r20
    2c38:	f5 1f       	adc	r31, r21
    2c3a:	84 85       	ldd	r24, Z+12	; 0x0c
    2c3c:	95 85       	ldd	r25, Z+13	; 0x0d
    2c3e:	89 2b       	or	r24, r25
    2c40:	39 f0       	breq	.+14     	; 0x2c50 <pwm_lld_enable_channel+0x142>
    {
        *timer_registers_table[index][11] |= (1<< (channel + 1));
    2c42:	e0 91 16 01 	lds	r30, 0x0116
    2c46:	f0 91 17 01 	lds	r31, 0x0117
    2c4a:	80 81       	ld	r24, Z
    2c4c:	82 2b       	or	r24, r18
    2c4e:	80 83       	st	Z, r24

    }

}
    2c50:	df 91       	pop	r29
    2c52:	cf 91       	pop	r28
    2c54:	1f 91       	pop	r17
    2c56:	0f 91       	pop	r16
    2c58:	ff 90       	pop	r15
    2c5a:	ef 90       	pop	r14
    2c5c:	df 90       	pop	r13
    2c5e:	cf 90       	pop	r12
    2c60:	bf 90       	pop	r11
    2c62:	af 90       	pop	r10
    2c64:	08 95       	ret
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    if(PWM_OUTPUT_ACTIVE_HIGH ==mode )
        *TCCRnA |=  ((1<<COMnx1) | (0<<COMnx0)); //non inverting mode
    if(PWM_OUTPUT_ACTIVE_LOW ==mode)
        *TCCRnA |= (1<<COMnx1) | (1<<COMnx0); //inverting mode
    2c66:	80 81       	ld	r24, Z
    2c68:	86 2b       	or	r24, r22
    2c6a:	80 83       	st	Z, r24
    2c6c:	b9 cf       	rjmp	.-142    	; 0x2be0 <pwm_lld_enable_channel+0xd2>
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    if(PWM_OUTPUT_ACTIVE_HIGH ==mode )
        *TCCRnA |=  ((1<<COMnx1) | (0<<COMnx0)); //non inverting mode
    2c6e:	80 81       	ld	r24, Z
    2c70:	8b 29       	or	r24, r11
    2c72:	80 83       	st	Z, r24
    2c74:	b5 cf       	rjmp	.-150    	; 0x2be0 <pwm_lld_enable_channel+0xd2>
        val = 0xFF;

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    if(pwmp == &PWMD2)
    {
        pwm_configure_hw_channel(&TCCR2A,7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2c76:	8b 2d       	mov	r24, r11
    2c78:	90 e0       	ldi	r25, 0x00	; 0
    2c7a:	60 91 9d 02 	lds	r22, 0x029D
    2c7e:	70 91 9e 02 	lds	r23, 0x029E
    2c82:	fc 01       	movw	r30, r24
    2c84:	ee 0f       	add	r30, r30
    2c86:	ff 1f       	adc	r31, r31
    2c88:	df 01       	movw	r26, r30
    2c8a:	a8 0f       	add	r26, r24
    2c8c:	b9 1f       	adc	r27, r25
    2c8e:	aa 0f       	add	r26, r26
    2c90:	bb 1f       	adc	r27, r27
    2c92:	a6 0f       	add	r26, r22
    2c94:	b7 1f       	adc	r27, r23
    2c96:	18 96       	adiw	r26, 0x08	; 8
    2c98:	cd 90       	ld	r12, X+
    2c9a:	dd 90       	ld	r13, X+
    2c9c:	ed 90       	ld	r14, X+
    2c9e:	fc 90       	ld	r15, X
    2ca0:	1b 97       	sbiw	r26, 0x0b	; 11
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2ca2:	d0 91 b0 00 	lds	r29, 0x00B0
        val = 0xFF;

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    if(pwmp == &PWMD2)
    {
        pwm_configure_hw_channel(&TCCR2A,7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2ca6:	4b 2d       	mov	r20, r11
    2ca8:	41 95       	neg	r20
    2caa:	44 0f       	add	r20, r20
    2cac:	49 5f       	subi	r20, 0xF9	; 249
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2cae:	a1 e0       	ldi	r26, 0x01	; 1
    2cb0:	b0 e0       	ldi	r27, 0x00	; 0
    2cb2:	ca 2f       	mov	r28, r26
    2cb4:	01 c0       	rjmp	.+2      	; 0x2cb8 <pwm_lld_enable_channel+0x1aa>
    2cb6:	cc 0f       	add	r28, r28
    2cb8:	4a 95       	dec	r20
    2cba:	ea f7       	brpl	.-6      	; 0x2cb6 <pwm_lld_enable_channel+0x1a8>
        val = 0xFF;

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    if(pwmp == &PWMD2)
    {
        pwm_configure_hw_channel(&TCCR2A,7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
    2cbc:	43 e0       	ldi	r20, 0x03	; 3
    2cbe:	50 e0       	ldi	r21, 0x00	; 0
    2cc0:	48 1b       	sub	r20, r24
    2cc2:	59 0b       	sbc	r21, r25
    2cc4:	44 0f       	add	r20, r20
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2cc6:	04 2e       	mov	r0, r20
    2cc8:	01 c0       	rjmp	.+2      	; 0x2ccc <pwm_lld_enable_channel+0x1be>
    2cca:	aa 0f       	add	r26, r26
    2ccc:	0a 94       	dec	r0
    2cce:	ea f7       	brpl	.-6      	; 0x2cca <pwm_lld_enable_channel+0x1bc>
    2cd0:	ac 2b       	or	r26, r28
    2cd2:	5a 2f       	mov	r21, r26
    2cd4:	50 95       	com	r21
    2cd6:	5d 23       	and	r21, r29
    2cd8:	50 93 b0 00 	sts	0x00B0, r21
    if(PWM_OUTPUT_ACTIVE_HIGH ==mode )
    2cdc:	41 e0       	ldi	r20, 0x01	; 1
    2cde:	c4 16       	cp	r12, r20
    2ce0:	d1 04       	cpc	r13, r1
    2ce2:	e1 04       	cpc	r14, r1
    2ce4:	f1 04       	cpc	r15, r1
    2ce6:	79 f1       	breq	.+94     	; 0x2d46 <pwm_lld_enable_channel+0x238>
        *TCCRnA |=  ((1<<COMnx1) | (0<<COMnx0)); //non inverting mode
    if(PWM_OUTPUT_ACTIVE_LOW ==mode)
    2ce8:	42 e0       	ldi	r20, 0x02	; 2
    2cea:	c4 16       	cp	r12, r20
    2cec:	d1 04       	cpc	r13, r1
    2cee:	e1 04       	cpc	r14, r1
    2cf0:	f1 04       	cpc	r15, r1
    2cf2:	29 f4       	brne	.+10     	; 0x2cfe <pwm_lld_enable_channel+0x1f0>
        *TCCRnA |= (1<<COMnx1) | (1<<COMnx0); //inverting mode
    2cf4:	40 91 b0 00 	lds	r20, 0x00B0
    2cf8:	4a 2b       	or	r20, r26
    2cfa:	40 93 b0 00 	sts	0x00B0, r20

#if USE_AVR_PWM2 || defined(__DOXYGEN__)
    if(pwmp == &PWMD2)
    {
        pwm_configure_hw_channel(&TCCR2A,7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
        TIMSK2 |= (1<< (channel + 1));
    2cfe:	c0 91 70 00 	lds	r28, 0x0070
    2d02:	dc 01       	movw	r26, r24
    2d04:	11 96       	adiw	r26, 0x01	; 1
    2d06:	41 e0       	ldi	r20, 0x01	; 1
    2d08:	50 e0       	ldi	r21, 0x00	; 0
    2d0a:	0a 2e       	mov	r0, r26
    2d0c:	01 c0       	rjmp	.+2      	; 0x2d10 <pwm_lld_enable_channel+0x202>
    2d0e:	44 0f       	add	r20, r20
    2d10:	0a 94       	dec	r0
    2d12:	ea f7       	brpl	.-6      	; 0x2d0e <pwm_lld_enable_channel+0x200>
    2d14:	c4 2b       	or	r28, r20
    2d16:	c0 93 70 00 	sts	0x0070, r28
        if(pwmp->config->channels[channel].callback != NULL)
    2d1a:	e8 0f       	add	r30, r24
    2d1c:	f9 1f       	adc	r31, r25
    2d1e:	ee 0f       	add	r30, r30
    2d20:	ff 1f       	adc	r31, r31
    2d22:	e6 0f       	add	r30, r22
    2d24:	f7 1f       	adc	r31, r23
    2d26:	84 85       	ldd	r24, Z+12	; 0x0c
    2d28:	95 85       	ldd	r25, Z+13	; 0x0d
    2d2a:	89 2b       	or	r24, r25
    2d2c:	09 f4       	brne	.+2      	; 0x2d30 <pwm_lld_enable_channel+0x222>
    2d2e:	90 cf       	rjmp	.-224    	; 0x2c50 <pwm_lld_enable_channel+0x142>
            switch(channel)
    2d30:	b1 10       	cpse	r11, r1
    2d32:	03 c0       	rjmp	.+6      	; 0x2d3a <pwm_lld_enable_channel+0x22c>
            {
            case 0:
                OCR2A = val;
    2d34:	00 93 b3 00 	sts	0x00B3, r16
                break;
    2d38:	8b cf       	rjmp	.-234    	; 0x2c50 <pwm_lld_enable_channel+0x142>
    if(pwmp == &PWMD2)
    {
        pwm_configure_hw_channel(&TCCR2A,7-2*channel,6-2*channel,pwmp->config->channels[channel].mode);
        TIMSK2 |= (1<< (channel + 1));
        if(pwmp->config->channels[channel].callback != NULL)
            switch(channel)
    2d3a:	81 e0       	ldi	r24, 0x01	; 1
    2d3c:	b8 12       	cpse	r11, r24
    2d3e:	88 cf       	rjmp	.-240    	; 0x2c50 <pwm_lld_enable_channel+0x142>
            {
            case 0:
                OCR2A = val;
                break;
            case 1:
                OCR2B = val;
    2d40:	00 93 b4 00 	sts	0x00B4, r16
                break;
    2d44:	85 cf       	rjmp	.-246    	; 0x2c50 <pwm_lld_enable_channel+0x142>
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    if(PWM_OUTPUT_ACTIVE_HIGH ==mode )
        *TCCRnA |=  ((1<<COMnx1) | (0<<COMnx0)); //non inverting mode
    2d46:	40 91 b0 00 	lds	r20, 0x00B0
    2d4a:	4c 2b       	or	r20, r28
    2d4c:	40 93 b0 00 	sts	0x00B0, r20
    2d50:	d6 cf       	rjmp	.-84     	; 0x2cfe <pwm_lld_enable_channel+0x1f0>

00002d52 <pwm_lld_disable_channel>:
 * @param[in] channel   PWM channel identifier (0...PWM_CHANNELS-1)
 *
 * @notapi
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel)
{
    2d52:	cf 93       	push	r28
    2d54:	df 93       	push	r29
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,PWM_OUTPUT_DISABLED);
    2d56:	46 2f       	mov	r20, r22
    2d58:	50 e0       	ldi	r21, 0x00	; 0
    2d5a:	e0 91 00 01 	lds	r30, 0x0100
    2d5e:	f0 91 01 01 	lds	r31, 0x0101
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2d62:	a0 81       	ld	r26, Z
 * @notapi
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel)
{
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,PWM_OUTPUT_DISABLED);
    2d64:	23 e0       	ldi	r18, 0x03	; 3
    2d66:	30 e0       	ldi	r19, 0x00	; 0
    2d68:	24 1b       	sub	r18, r20
    2d6a:	35 0b       	sbc	r19, r21
    2d6c:	22 0f       	add	r18, r18
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2d6e:	81 e0       	ldi	r24, 0x01	; 1
    2d70:	90 e0       	ldi	r25, 0x00	; 0
    2d72:	ec 01       	movw	r28, r24
    2d74:	02 c0       	rjmp	.+4      	; 0x2d7a <pwm_lld_disable_channel+0x28>
    2d76:	cc 0f       	add	r28, r28
    2d78:	dd 1f       	adc	r29, r29
    2d7a:	2a 95       	dec	r18
    2d7c:	e2 f7       	brpl	.-8      	; 0x2d76 <pwm_lld_disable_channel+0x24>
    2d7e:	9e 01       	movw	r18, r28
 * @notapi
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel)
{
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,PWM_OUTPUT_DISABLED);
    2d80:	61 95       	neg	r22
    2d82:	66 0f       	add	r22, r22
    2d84:	69 5f       	subi	r22, 0xF9	; 249
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void pwm_configure_hw_channel(volatile uint8_t * TCCRnA, uint8_t COMnx1,uint8_t COMnx0, pwmmode_t mode)
{
    *TCCRnA &= ~((1<<COMnx1) | (1<<COMnx0));
    2d86:	ec 01       	movw	r28, r24
    2d88:	02 c0       	rjmp	.+4      	; 0x2d8e <pwm_lld_disable_channel+0x3c>
    2d8a:	cc 0f       	add	r28, r28
    2d8c:	dd 1f       	adc	r29, r29
    2d8e:	6a 95       	dec	r22
    2d90:	e2 f7       	brpl	.-8      	; 0x2d8a <pwm_lld_disable_channel+0x38>
    2d92:	2c 2b       	or	r18, r28
    2d94:	20 95       	com	r18
    2d96:	2a 23       	and	r18, r26
    2d98:	20 83       	st	Z, r18
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel)
{
    uint8_t index = getTimerIndex(pwmp);
    pwm_configure_hw_channel(timer_registers_table[index][0],7-2*channel,6-2*channel,PWM_OUTPUT_DISABLED);
    *timer_registers_table[index][11] &= ~(1<< (channel + 1));
    2d9a:	e0 91 16 01 	lds	r30, 0x0116
    2d9e:	f0 91 17 01 	lds	r31, 0x0117
    2da2:	20 81       	ld	r18, Z
    2da4:	4f 5f       	subi	r20, 0xFF	; 255
    2da6:	5f 4f       	sbci	r21, 0xFF	; 255
    2da8:	04 2e       	mov	r0, r20
    2daa:	01 c0       	rjmp	.+2      	; 0x2dae <pwm_lld_disable_channel+0x5c>
    2dac:	88 0f       	add	r24, r24
    2dae:	0a 94       	dec	r0
    2db0:	ea f7       	brpl	.-6      	; 0x2dac <pwm_lld_disable_channel+0x5a>
    2db2:	80 95       	com	r24
    2db4:	82 23       	and	r24, r18
    2db6:	80 83       	st	Z, r24
}
    2db8:	df 91       	pop	r29
    2dba:	cf 91       	pop	r28
    2dbc:	08 95       	ret

00002dbe <spi_start_transmission>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static void spi_start_transmission(SPIDriver *spip)
{
    2dbe:	cf 93       	push	r28
    2dc0:	df 93       	push	r29
    2dc2:	1f 92       	push	r1
    2dc4:	cd b7       	in	r28, 0x3d	; 61
    2dc6:	de b7       	in	r29, 0x3e	; 62
    2dc8:	fc 01       	movw	r30, r24
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip->untransmitted_bytes> 0)
    2dca:	85 85       	ldd	r24, Z+13	; 0x0d
    2dcc:	96 85       	ldd	r25, Z+14	; 0x0e
    2dce:	18 16       	cp	r1, r24
    2dd0:	19 06       	cpc	r1, r25
    2dd2:	84 f4       	brge	.+32     	; 0x2df4 <spi_start_transmission+0x36>
    {
        if(spip->tx_buffer != NULL)
    2dd4:	a7 85       	ldd	r26, Z+15	; 0x0f
    2dd6:	b0 89       	ldd	r27, Z+16	; 0x10
    2dd8:	10 97       	sbiw	r26, 0x00	; 0
    2dda:	81 f0       	breq	.+32     	; 0x2dfc <spi_start_transmission+0x3e>
        {
            SPDR =  *spip->tx_buffer;
    2ddc:	8c 91       	ld	r24, X
    2dde:	8e bd       	out	0x2e, r24	; 46
            spip->tx_buffer++;
    2de0:	87 85       	ldd	r24, Z+15	; 0x0f
    2de2:	90 89       	ldd	r25, Z+16	; 0x10
    2de4:	01 96       	adiw	r24, 0x01	; 1
    2de6:	90 8b       	std	Z+16, r25	; 0x10
    2de8:	87 87       	std	Z+15, r24	; 0x0f
        else
        {
            volatile uint8_t tempSPDR = SPDR;
            SPDR = tempSPDR;
        }
        spip->untransmitted_bytes--;
    2dea:	85 85       	ldd	r24, Z+13	; 0x0d
    2dec:	96 85       	ldd	r25, Z+14	; 0x0e
    2dee:	01 97       	sbiw	r24, 0x01	; 1
    2df0:	96 87       	std	Z+14, r25	; 0x0e
    2df2:	85 87       	std	Z+13, r24	; 0x0d
    }

#endif


}
    2df4:	0f 90       	pop	r0
    2df6:	df 91       	pop	r29
    2df8:	cf 91       	pop	r28
    2dfa:	08 95       	ret
            SPDR =  *spip->tx_buffer;
            spip->tx_buffer++;
        }
        else
        {
            volatile uint8_t tempSPDR = SPDR;
    2dfc:	8e b5       	in	r24, 0x2e	; 46
    2dfe:	89 83       	std	Y+1, r24	; 0x01
            SPDR = tempSPDR;
    2e00:	89 81       	ldd	r24, Y+1	; 0x01
    2e02:	8e bd       	out	0x2e, r24	; 46
    2e04:	f2 cf       	rjmp	.-28     	; 0x2dea <spi_start_transmission+0x2c>

00002e06 <__vector_19>:
/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/
#if USE_AVR_SPI1 || defined(__DOXYGEN_)
CH_IRQ_HANDLER(SPI_STC_vect)   //SPI1 interrupt
{
    2e06:	1f 92       	push	r1
    2e08:	0f 92       	push	r0
    2e0a:	0f b6       	in	r0, 0x3f	; 63
    2e0c:	0f 92       	push	r0
    2e0e:	11 24       	eor	r1, r1
    2e10:	2f 93       	push	r18
    2e12:	3f 93       	push	r19
    2e14:	4f 93       	push	r20
    2e16:	5f 93       	push	r21
    2e18:	6f 93       	push	r22
    2e1a:	7f 93       	push	r23
    2e1c:	8f 93       	push	r24
    2e1e:	9f 93       	push	r25
    2e20:	af 93       	push	r26
    2e22:	bf 93       	push	r27
    2e24:	ef 93       	push	r30
    2e26:	ff 93       	push	r31

    CH_IRQ_PROLOGUE();

    if(SPCR & (1<<MSTR))
    2e28:	0c b4       	in	r0, 0x2c	; 44
    2e2a:	04 fe       	sbrs	r0, 4
    2e2c:	1d c0       	rjmp	.+58     	; 0x2e68 <__vector_19+0x62>
    {
        if(SPID1.rx_buffer != NULL)
    2e2e:	e0 91 b7 02 	lds	r30, 0x02B7
    2e32:	f0 91 b8 02 	lds	r31, 0x02B8
    2e36:	30 97       	sbiw	r30, 0x00	; 0
    2e38:	59 f0       	breq	.+22     	; 0x2e50 <__vector_19+0x4a>
        {
            *SPID1.rx_buffer=SPDR;
    2e3a:	8e b5       	in	r24, 0x2e	; 46
    2e3c:	80 83       	st	Z, r24
            SPID1.rx_buffer++;
    2e3e:	80 91 b7 02 	lds	r24, 0x02B7
    2e42:	90 91 b8 02 	lds	r25, 0x02B8
    2e46:	01 96       	adiw	r24, 0x01	; 1
    2e48:	90 93 b8 02 	sts	0x02B8, r25
    2e4c:	80 93 b7 02 	sts	0x02B7, r24
        }
        if(SPID1.untransmitted_bytes> 0)
    2e50:	80 91 b3 02 	lds	r24, 0x02B3
    2e54:	90 91 b4 02 	lds	r25, 0x02B4
    2e58:	18 16       	cp	r1, r24
    2e5a:	19 06       	cpc	r1, r25
    2e5c:	3c f5       	brge	.+78     	; 0x2eac <__vector_19+0xa6>
        {
            spi_start_transmission(&SPID1);
    2e5e:	86 ea       	ldi	r24, 0xA6	; 166
    2e60:	92 e0       	ldi	r25, 0x02	; 2
    2e62:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <spi_start_transmission>
    2e66:	0c c0       	rjmp	.+24     	; 0x2e80 <__vector_19+0x7a>

        }
    }
    else
    {
        if(SPID1.config->slave_cb == NULL)
    2e68:	e0 91 a7 02 	lds	r30, 0x02A7
    2e6c:	f0 91 a8 02 	lds	r31, 0x02A8
    2e70:	03 80       	ldd	r0, Z+3	; 0x03
    2e72:	f4 81       	ldd	r31, Z+4	; 0x04
    2e74:	e0 2d       	mov	r30, r0
    2e76:	30 97       	sbiw	r30, 0x00	; 0
    2e78:	e9 f1       	breq	.+122    	; 0x2ef4 <__vector_19+0xee>
            SPDR = SPID1.config->slave_cb(&SPID1,SPDR);
        SPCR |=(1<<MSTR);
    2e7a:	8c b5       	in	r24, 0x2c	; 44
    2e7c:	80 61       	ori	r24, 0x10	; 16
    2e7e:	8c bd       	out	0x2c, r24	; 44

    }

    CH_IRQ_EPILOGUE();
    2e80:	0e 94 08 03 	call	0x610	; 0x610 <chSchIsPreemptionRequired>
    2e84:	81 11       	cpse	r24, r1
    2e86:	0e 94 a8 03 	call	0x750	; 0x750 <chSchDoReschedule>
}
    2e8a:	ff 91       	pop	r31
    2e8c:	ef 91       	pop	r30
    2e8e:	bf 91       	pop	r27
    2e90:	af 91       	pop	r26
    2e92:	9f 91       	pop	r25
    2e94:	8f 91       	pop	r24
    2e96:	7f 91       	pop	r23
    2e98:	6f 91       	pop	r22
    2e9a:	5f 91       	pop	r21
    2e9c:	4f 91       	pop	r20
    2e9e:	3f 91       	pop	r19
    2ea0:	2f 91       	pop	r18
    2ea2:	0f 90       	pop	r0
    2ea4:	0f be       	out	0x3f, r0	; 63
    2ea6:	0f 90       	pop	r0
    2ea8:	1f 90       	pop	r1
    2eaa:	18 95       	reti
        {
            spi_start_transmission(&SPID1);
        }
        else
        {
            _spi_isr_code(&SPID1);
    2eac:	e0 91 a7 02 	lds	r30, 0x02A7
    2eb0:	f0 91 a8 02 	lds	r31, 0x02A8
    2eb4:	01 90       	ld	r0, Z+
    2eb6:	f0 81       	ld	r31, Z
    2eb8:	e0 2d       	mov	r30, r0
    2eba:	30 97       	sbiw	r30, 0x00	; 0
    2ebc:	b9 f0       	breq	.+46     	; 0x2eec <__vector_19+0xe6>
    2ebe:	84 e0       	ldi	r24, 0x04	; 4
    2ec0:	80 93 a6 02 	sts	0x02A6, r24
    2ec4:	86 ea       	ldi	r24, 0xA6	; 166
    2ec6:	92 e0       	ldi	r25, 0x02	; 2
    2ec8:	09 95       	icall
    2eca:	80 91 a6 02 	lds	r24, 0x02A6
    2ece:	84 30       	cpi	r24, 0x04	; 4
    2ed0:	69 f0       	breq	.+26     	; 0x2eec <__vector_19+0xe6>
    2ed2:	80 91 a9 02 	lds	r24, 0x02A9
    2ed6:	90 91 aa 02 	lds	r25, 0x02AA
    2eda:	00 97       	sbiw	r24, 0x00	; 0
    2edc:	89 f2       	breq	.-94     	; 0x2e80 <__vector_19+0x7a>
    2ede:	10 92 aa 02 	sts	0x02AA, r1
    2ee2:	10 92 a9 02 	sts	0x02A9, r1
    2ee6:	0e 94 3e 02 	call	0x47c	; 0x47c <chSchReadyI>
    2eea:	ca cf       	rjmp	.-108    	; 0x2e80 <__vector_19+0x7a>
    2eec:	82 e0       	ldi	r24, 0x02	; 2
    2eee:	80 93 a6 02 	sts	0x02A6, r24
    2ef2:	ef cf       	rjmp	.-34     	; 0x2ed2 <__vector_19+0xcc>
        }
    }
    else
    {
        if(SPID1.config->slave_cb == NULL)
            SPDR = SPID1.config->slave_cb(&SPID1,SPDR);
    2ef4:	6e b5       	in	r22, 0x2e	; 46
    2ef6:	86 ea       	ldi	r24, 0xA6	; 166
    2ef8:	92 e0       	ldi	r25, 0x02	; 2
    2efa:	09 95       	icall
    2efc:	8e bd       	out	0x2e, r24	; 46
    2efe:	bd cf       	rjmp	.-134    	; 0x2e7a <__vector_19+0x74>

00002f00 <spi_lld_init>:
void spi_lld_init(void)
{


#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    spiObjectInit(&SPID1);
    2f00:	86 ea       	ldi	r24, 0xA6	; 166
    2f02:	92 e0       	ldi	r25, 0x02	; 2
    2f04:	0c 94 93 10 	jmp	0x2126	; 0x2126 <spiObjectInit>

00002f08 <spi_lld_start>:
 * @notapi
 */
void spi_lld_start(SPIDriver *spip)
{

    if (spip->state == SPI_STOP)
    2f08:	fc 01       	movw	r30, r24
    2f0a:	20 81       	ld	r18, Z
    2f0c:	21 30       	cpi	r18, 0x01	; 1
    2f0e:	21 f0       	breq	.+8      	; 0x2f18 <spi_lld_start+0x10>
#endif

    }
    /* Configuration.*/
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    2f10:	86 5a       	subi	r24, 0xA6	; 166
    2f12:	92 40       	sbci	r25, 0x02	; 2
    2f14:	91 f0       	breq	.+36     	; 0x2f3a <spi_lld_start+0x32>
    2f16:	08 95       	ret

    if (spip->state == SPI_STOP)
    {
        /* Clock activation.*/
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
        if(spip == &SPID1)
    2f18:	86 5a       	subi	r24, 0xA6	; 166
    2f1a:	92 40       	sbci	r25, 0x02	; 2
    2f1c:	e1 f7       	brne	.-8      	; 0x2f16 <spi_lld_start+0xe>
        {
            SPCR = (1<<MSTR)|
                   (1<<SPIE)| //enable interrupt
                   (1<<SPR1)|(1<<SPR0)| //Clk/128
                   ((spip->config->spi_mode & 0x3)<<CPHA);
    2f1e:	e0 91 a7 02 	lds	r30, 0x02A7
    2f22:	f0 91 a8 02 	lds	r31, 0x02A8
    2f26:	82 81       	ldd	r24, Z+2	; 0x02
    2f28:	83 70       	andi	r24, 0x03	; 3
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
    2f2c:	88 0f       	add	r24, r24
    2f2e:	99 1f       	adc	r25, r25
    2f30:	88 0f       	add	r24, r24
    2f32:	99 1f       	adc	r25, r25
    {
        /* Clock activation.*/
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
        if(spip == &SPID1)
        {
            SPCR = (1<<MSTR)|
    2f34:	83 69       	ori	r24, 0x93	; 147
    2f36:	9f 6f       	ori	r25, 0xFF	; 255
    2f38:	8c bd       	out	0x2c, r24	; 44
    /* Configuration.*/
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    {
        /*mosi, sck and ss output*/
        PORT_SPI1 |= (1<<SPI1_SCK)|(1<<SPI1_MOSI)|(1<<SPI1_SS);
    2f3a:	85 b1       	in	r24, 0x05	; 5
    2f3c:	80 6b       	ori	r24, 0xB0	; 176
    2f3e:	85 b9       	out	0x05, r24	; 5
        PORT_SPI1 &= ~(1<<SPI1_MISO);
    2f40:	2e 98       	cbi	0x05, 6	; 5
        SPCR |= (1<<SPE);
    2f42:	8c b5       	in	r24, 0x2c	; 44
    2f44:	80 64       	ori	r24, 0x40	; 64
    2f46:	8c bd       	out	0x2c, r24	; 44
    2f48:	08 95       	ret

00002f4a <spi_lld_stop>:
 * @notapi
 */
void spi_lld_stop(SPIDriver *spip)
{
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    2f4a:	86 5a       	subi	r24, 0xA6	; 166
    2f4c:	92 40       	sbci	r25, 0x02	; 2
    2f4e:	09 f0       	breq	.+2      	; 0x2f52 <spi_lld_stop+0x8>
    2f50:	08 95       	ret
    {
        /*all input*/
        PORT_SPI1 &= ~((1<<SPI1_MISO)|(1<<SPI1_SCK)|(1<<SPI1_MOSI)|(1<<SPI1_SS));
    2f52:	85 b1       	in	r24, 0x05	; 5
    2f54:	8f 70       	andi	r24, 0x0F	; 15
    2f56:	85 b9       	out	0x05, r24	; 5
        SPCR &=~(1<<SPE);
    2f58:	8c b5       	in	r24, 0x2c	; 44
    2f5a:	8f 7b       	andi	r24, 0xBF	; 191
    2f5c:	8c bd       	out	0x2c, r24	; 44
    2f5e:	08 95       	ret

00002f60 <spi_lld_select>:
 */
void spi_lld_select(SPIDriver *spip)
{

#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    2f60:	86 5a       	subi	r24, 0xA6	; 166
    2f62:	92 40       	sbci	r25, 0x02	; 2
    2f64:	09 f0       	breq	.+2      	; 0x2f68 <spi_lld_select+0x8>
    2f66:	08 95       	ret
    {

        PORT_SPI1 &= ~_BV(SPI1_SS);
    2f68:	2c 98       	cbi	0x05, 4	; 5
        DDR_SPI1  |= _BV(SPI1_SS);
    2f6a:	24 9a       	sbi	0x04, 4	; 4
    2f6c:	08 95       	ret

00002f6e <spi_lld_unselect>:
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip)
{
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    2f6e:	86 5a       	subi	r24, 0xA6	; 166
    2f70:	92 40       	sbci	r25, 0x02	; 2
    2f72:	09 f0       	breq	.+2      	; 0x2f76 <spi_lld_unselect+0x8>
    2f74:	08 95       	ret
    {
        DDR_SPI1  &= ~_BV(SPI1_SS);
    2f76:	24 98       	cbi	0x04, 4	; 4
        PORT_SPI1 |= _BV(SPI1_SS);
    2f78:	2c 9a       	sbi	0x05, 4	; 5
    2f7a:	08 95       	ret

00002f7c <spi_lld_ignore>:

}

static void spi_setup_transmission(SPIDriver *spip,size_t n, const uint8_t *txbuf, uint8_t *rxbuf)
{
    spip->tx_buffer= txbuf;
    2f7c:	fc 01       	movw	r30, r24
    2f7e:	10 8a       	std	Z+16, r1	; 0x10
    2f80:	17 86       	std	Z+15, r1	; 0x0f
    spip->rx_buffer= rxbuf;
    2f82:	12 8a       	std	Z+18, r1	; 0x12
    2f84:	11 8a       	std	Z+17, r1	; 0x11
    spip->untransmitted_bytes= n;
    2f86:	76 87       	std	Z+14, r23	; 0x0e
    2f88:	65 87       	std	Z+13, r22	; 0x0d
 * @notapi
 */
void spi_lld_ignore(SPIDriver *spip, size_t n)
{
    spi_setup_transmission(spip, n, NULL,NULL);
    spi_start_transmission(spip);
    2f8a:	0c 94 df 16 	jmp	0x2dbe	; 0x2dbe <spi_start_transmission>

00002f8e <spi_lld_exchange>:

}

static void spi_setup_transmission(SPIDriver *spip,size_t n, const uint8_t *txbuf, uint8_t *rxbuf)
{
    spip->tx_buffer= txbuf;
    2f8e:	fc 01       	movw	r30, r24
    2f90:	50 8b       	std	Z+16, r21	; 0x10
    2f92:	47 87       	std	Z+15, r20	; 0x0f
    spip->rx_buffer= rxbuf;
    2f94:	32 8b       	std	Z+18, r19	; 0x12
    2f96:	21 8b       	std	Z+17, r18	; 0x11
    spip->untransmitted_bytes= n;
    2f98:	76 87       	std	Z+14, r23	; 0x0e
    2f9a:	65 87       	std	Z+13, r22	; 0x0d
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf)
{
    spi_setup_transmission(spip, n, txbuf, rxbuf);
    spi_start_transmission(spip);
    2f9c:	0c 94 df 16 	jmp	0x2dbe	; 0x2dbe <spi_start_transmission>

00002fa0 <spi_lld_send>:

}

static void spi_setup_transmission(SPIDriver *spip,size_t n, const uint8_t *txbuf, uint8_t *rxbuf)
{
    spip->tx_buffer= txbuf;
    2fa0:	fc 01       	movw	r30, r24
    2fa2:	50 8b       	std	Z+16, r21	; 0x10
    2fa4:	47 87       	std	Z+15, r20	; 0x0f
    spip->rx_buffer= rxbuf;
    2fa6:	12 8a       	std	Z+18, r1	; 0x12
    2fa8:	11 8a       	std	Z+17, r1	; 0x11
    spip->untransmitted_bytes= n;
    2faa:	76 87       	std	Z+14, r23	; 0x0e
    2fac:	65 87       	std	Z+13, r22	; 0x0d
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf)
{
    spi_setup_transmission(spip, n, txbuf, NULL);
    spi_start_transmission(spip);
    2fae:	0c 94 df 16 	jmp	0x2dbe	; 0x2dbe <spi_start_transmission>

00002fb2 <spi_lld_receive>:

}

static void spi_setup_transmission(SPIDriver *spip,size_t n, const uint8_t *txbuf, uint8_t *rxbuf)
{
    spip->tx_buffer= txbuf;
    2fb2:	fc 01       	movw	r30, r24
    2fb4:	10 8a       	std	Z+16, r1	; 0x10
    2fb6:	17 86       	std	Z+15, r1	; 0x0f
    spip->rx_buffer= rxbuf;
    2fb8:	52 8b       	std	Z+18, r21	; 0x12
    2fba:	41 8b       	std	Z+17, r20	; 0x11
    spip->untransmitted_bytes= n;
    2fbc:	76 87       	std	Z+14, r23	; 0x0e
    2fbe:	65 87       	std	Z+13, r22	; 0x0d
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf)
{
    spi_setup_transmission(spip, n, NULL, rxbuf);
    spi_start_transmission(spip);
    2fc0:	0c 94 df 16 	jmp	0x2dbe	; 0x2dbe <spi_start_transmission>

00002fc4 <spi_lld_polled_exchange>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint8_t spi_lld_polled_exchange(SPIDriver *spip, uint8_t frame)
{
    2fc4:	fc 01       	movw	r30, r24
    while(spip->state !=SPI_READY)
    2fc6:	80 81       	ld	r24, Z
    2fc8:	82 30       	cpi	r24, 0x02	; 2
    2fca:	e9 f7       	brne	.-6      	; 0x2fc6 <spi_lld_polled_exchange+0x2>
        ;
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    2fcc:	e6 5a       	subi	r30, 0xA6	; 166
    2fce:	f2 40       	sbci	r31, 0x02	; 2
    2fd0:	09 f0       	breq	.+2      	; 0x2fd4 <spi_lld_polled_exchange+0x10>
        SPCR |= (1<<SPIE);
        return retval;

    }
#endif
}
    2fd2:	08 95       	ret
    while(spip->state !=SPI_READY)
        ;
#if USE_AVR_SPI1 || defined(__DOXYGEN__)
    if(spip == &SPID1)
    {
        SPCR &= ~(1<<SPIE);
    2fd4:	8c b5       	in	r24, 0x2c	; 44
    2fd6:	8f 77       	andi	r24, 0x7F	; 127
    2fd8:	8c bd       	out	0x2c, r24	; 44

        SPDR = frame;
    2fda:	6e bd       	out	0x2e, r22	; 46

        while(!(SPSR & (1<<SPIF)))
    2fdc:	0d b4       	in	r0, 0x2d	; 45
    2fde:	07 fe       	sbrs	r0, 7
    2fe0:	fd cf       	rjmp	.-6      	; 0x2fdc <spi_lld_polled_exchange+0x18>
            ;
        uint8_t retval = SPDR; //this is needed to clear spif
    2fe2:	8e b5       	in	r24, 0x2e	; 46
        SPCR |= (1<<SPIE);
    2fe4:	9c b5       	in	r25, 0x2c	; 44
    2fe6:	90 68       	ori	r25, 0x80	; 128
    2fe8:	9c bd       	out	0x2c, r25	; 44
    2fea:	08 95       	ret

00002fec <findBestPrescaler>:
uint16_t ratio_extended[]={1024,256,128,64,32,8,1};
uint8_t clock_source_extended[]={7,6,5,4,3,2,1};


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
{
    2fec:	4f 92       	push	r4
    2fee:	5f 92       	push	r5
    2ff0:	6f 92       	push	r6
    2ff2:	7f 92       	push	r7
    2ff4:	8f 92       	push	r8
    2ff6:	9f 92       	push	r9
    2ff8:	af 92       	push	r10
    2ffa:	bf 92       	push	r11
    2ffc:	cf 92       	push	r12
    2ffe:	df 92       	push	r13
    3000:	ef 92       	push	r14
    3002:	ff 92       	push	r15
    3004:	0f 93       	push	r16
    3006:	1f 93       	push	r17
    3008:	cf 93       	push	r28
    300a:	df 93       	push	r29
    300c:	5c 01       	movw	r10, r24
    300e:	eb 01       	movw	r28, r22
    3010:	82 2e       	mov	r8, r18
  uint8_t i;
  for(i=0;i<n;i++)
    3012:	22 23       	and	r18, r18
    3014:	09 f4       	brne	.+2      	; 0x3018 <findBestPrescaler+0x2c>
    3016:	5f c0       	rjmp	.+190    	; 0x30d6 <findBestPrescaler+0xea>
  {
    uint32_t result = F_CPU/ratio[i]/frequency;
    3018:	08 81       	ld	r16, Y
    301a:	19 81       	ldd	r17, Y+1	; 0x01
    301c:	6c 01       	movw	r12, r24
    301e:	e1 2c       	mov	r14, r1
    3020:	f1 2c       	mov	r15, r1
    3022:	98 01       	movw	r18, r16
    3024:	40 e0       	ldi	r20, 0x00	; 0
    3026:	50 e0       	ldi	r21, 0x00	; 0
    3028:	60 e0       	ldi	r22, 0x00	; 0
    302a:	7d e2       	ldi	r23, 0x2D	; 45
    302c:	81 e3       	ldi	r24, 0x31	; 49
    302e:	91 e0       	ldi	r25, 0x01	; 1
    3030:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <__udivmodsi4>
    3034:	ca 01       	movw	r24, r20
    3036:	b9 01       	movw	r22, r18
    3038:	a7 01       	movw	r20, r14
    303a:	96 01       	movw	r18, r12
    303c:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <__udivmodsi4>
    3040:	29 01       	movw	r4, r18
    3042:	3a 01       	movw	r6, r20
    if(result > 256UL)
    3044:	21 e0       	ldi	r18, 0x01	; 1
    3046:	42 16       	cp	r4, r18
    3048:	52 06       	cpc	r5, r18
    304a:	61 04       	cpc	r6, r1
    304c:	71 04       	cpc	r7, r1
    304e:	08 f0       	brcs	.+2      	; 0x3052 <findBestPrescaler+0x66>
    3050:	58 c0       	rjmp	.+176    	; 0x3102 <findBestPrescaler+0x116>
       return (i-1);
    if(result * ratio[i] * frequency == F_CPU)
    3052:	98 01       	movw	r18, r16
    3054:	d5 01       	movw	r26, r10
    3056:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <__umulhisi3>
    305a:	9b 01       	movw	r18, r22
    305c:	ac 01       	movw	r20, r24
    305e:	c3 01       	movw	r24, r6
    3060:	b2 01       	movw	r22, r4
    3062:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <__mulsi3>
    3066:	61 15       	cp	r22, r1
    3068:	7d 42       	sbci	r23, 0x2D	; 45
    306a:	81 43       	sbci	r24, 0x31	; 49
    306c:	91 40       	sbci	r25, 0x01	; 1
    306e:	09 f4       	brne	.+2      	; 0x3072 <findBestPrescaler+0x86>
    3070:	46 c0       	rjmp	.+140    	; 0x30fe <findBestPrescaler+0x112>
uint8_t clock_source_base[]={5,4,3,2,1};
uint16_t ratio_extended[]={1024,256,128,64,32,8,1};
uint8_t clock_source_extended[]={7,6,5,4,3,2,1};


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
    3072:	8e 01       	movw	r16, r28
    3074:	0e 5f       	subi	r16, 0xFE	; 254
    3076:	1f 4f       	sbci	r17, 0xFF	; 255
{
  uint8_t i;
  for(i=0;i<n;i++)
    3078:	91 2c       	mov	r9, r1
    307a:	2a c0       	rjmp	.+84     	; 0x30d0 <findBestPrescaler+0xe4>
  {
    uint32_t result = F_CPU/ratio[i]/frequency;
    307c:	f8 01       	movw	r30, r16
    307e:	c1 91       	ld	r28, Z+
    3080:	d1 91       	ld	r29, Z+
    3082:	8f 01       	movw	r16, r30
    3084:	9e 01       	movw	r18, r28
    3086:	40 e0       	ldi	r20, 0x00	; 0
    3088:	50 e0       	ldi	r21, 0x00	; 0
    308a:	60 e0       	ldi	r22, 0x00	; 0
    308c:	7d e2       	ldi	r23, 0x2D	; 45
    308e:	81 e3       	ldi	r24, 0x31	; 49
    3090:	91 e0       	ldi	r25, 0x01	; 1
    3092:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <__udivmodsi4>
    3096:	ca 01       	movw	r24, r20
    3098:	b9 01       	movw	r22, r18
    309a:	a7 01       	movw	r20, r14
    309c:	96 01       	movw	r18, r12
    309e:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <__udivmodsi4>
    30a2:	29 01       	movw	r4, r18
    30a4:	3a 01       	movw	r6, r20
    if(result > 256UL)
    30a6:	21 30       	cpi	r18, 0x01	; 1
    30a8:	f1 e0       	ldi	r31, 0x01	; 1
    30aa:	3f 07       	cpc	r19, r31
    30ac:	41 05       	cpc	r20, r1
    30ae:	51 05       	cpc	r21, r1
    30b0:	98 f4       	brcc	.+38     	; 0x30d8 <findBestPrescaler+0xec>
       return (i-1);
    if(result * ratio[i] * frequency == F_CPU)
    30b2:	9e 01       	movw	r18, r28
    30b4:	d5 01       	movw	r26, r10
    30b6:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <__umulhisi3>
    30ba:	9b 01       	movw	r18, r22
    30bc:	ac 01       	movw	r20, r24
    30be:	c3 01       	movw	r24, r6
    30c0:	b2 01       	movw	r22, r4
    30c2:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <__mulsi3>
    30c6:	61 15       	cp	r22, r1
    30c8:	7d 42       	sbci	r23, 0x2D	; 45
    30ca:	81 43       	sbci	r24, 0x31	; 49
    30cc:	91 40       	sbci	r25, 0x01	; 1
    30ce:	29 f0       	breq	.+10     	; 0x30da <findBestPrescaler+0xee>


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
{
  uint8_t i;
  for(i=0;i<n;i++)
    30d0:	93 94       	inc	r9
    30d2:	98 10       	cpse	r9, r8
    30d4:	d3 cf       	rjmp	.-90     	; 0x307c <findBestPrescaler+0x90>
    30d6:	02 c0       	rjmp	.+4      	; 0x30dc <findBestPrescaler+0xf0>
    30d8:	9a 94       	dec	r9
    30da:	89 2d       	mov	r24, r9
       return (i-1);
    if(result * ratio[i] * frequency == F_CPU)
      return i;
  };
  
    30dc:	df 91       	pop	r29
    30de:	cf 91       	pop	r28
    30e0:	1f 91       	pop	r17
    30e2:	0f 91       	pop	r16
    30e4:	ff 90       	pop	r15
    30e6:	ef 90       	pop	r14
    30e8:	df 90       	pop	r13
    30ea:	cf 90       	pop	r12
    30ec:	bf 90       	pop	r11
    30ee:	af 90       	pop	r10
    30f0:	9f 90       	pop	r9
    30f2:	8f 90       	pop	r8
    30f4:	7f 90       	pop	r7
    30f6:	6f 90       	pop	r6
    30f8:	5f 90       	pop	r5
    30fa:	4f 90       	pop	r4
    30fc:	08 95       	ret


uint8_t findBestPrescaler(uint16_t frequency, uint16_t *ratio ,uint8_t *clock_source,uint8_t n)
{
  uint8_t i;
  for(i=0;i<n;i++)
    30fe:	91 2c       	mov	r9, r1
    3100:	ec cf       	rjmp	.-40     	; 0x30da <findBestPrescaler+0xee>
  {
    uint32_t result = F_CPU/ratio[i]/frequency;
    if(result > 256UL)
    3102:	99 24       	eor	r9, r9
    3104:	9a 94       	dec	r9
       return (i-1);
    3106:	e9 cf       	rjmp	.-46     	; 0x30da <findBestPrescaler+0xee>

00003108 <boardInit>:
 * Board-specific initialization code.
 */



void boardInit(void) {
    3108:	08 95       	ret

0000310a <tmrcb>:
 */

#include "ch.h"
#include "evtimer.h"

static void tmrcb(void *p) {
    310a:	cf 93       	push	r28
    310c:	df 93       	push	r29
    310e:	ec 01       	movw	r28, r24
  EvTimer *etp = p;

  chSysLockFromIsr();
  chEvtBroadcastI(&etp->et_es);
    3110:	60 e0       	ldi	r22, 0x00	; 0
    3112:	0a 96       	adiw	r24, 0x0a	; 10
    3114:	0e 94 91 09 	call	0x1322	; 0x1322 <chEvtBroadcastFlagsI>
  chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    3118:	6c 85       	ldd	r22, Y+12	; 0x0c
    311a:	7d 85       	ldd	r23, Y+13	; 0x0d
    311c:	9e 01       	movw	r18, r28
    311e:	45 e8       	ldi	r20, 0x85	; 133
    3120:	58 e1       	ldi	r21, 0x18	; 24
    3122:	ce 01       	movw	r24, r28
  chSysUnlockFromIsr();
}
    3124:	df 91       	pop	r29
    3126:	cf 91       	pop	r28
static void tmrcb(void *p) {
  EvTimer *etp = p;

  chSysLockFromIsr();
  chEvtBroadcastI(&etp->et_es);
  chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    3128:	0c 94 69 01 	jmp	0x2d2	; 0x2d2 <chVTSetI>

0000312c <evtStart>:
 *
 * @param etp pointer to an initialized @p EvTimer structure.
 */
void evtStart(EvTimer *etp) {

  chSysLock();
    312c:	f8 94       	cli

  if (!chVTIsArmedI(&etp->et_vt))
    312e:	fc 01       	movw	r30, r24
    3130:	26 81       	ldd	r18, Z+6	; 0x06
    3132:	37 81       	ldd	r19, Z+7	; 0x07
    3134:	23 2b       	or	r18, r19
    3136:	11 f0       	breq	.+4      	; 0x313c <evtStart+0x10>
    chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);

  chSysUnlock();
    3138:	78 94       	sei
    313a:	08 95       	ret
void evtStart(EvTimer *etp) {

  chSysLock();

  if (!chVTIsArmedI(&etp->et_vt))
    chVTSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
    313c:	64 85       	ldd	r22, Z+12	; 0x0c
    313e:	75 85       	ldd	r23, Z+13	; 0x0d
    3140:	9c 01       	movw	r18, r24
    3142:	45 e8       	ldi	r20, 0x85	; 133
    3144:	58 e1       	ldi	r21, 0x18	; 24
    3146:	0e 94 69 01 	call	0x2d2	; 0x2d2 <chVTSetI>

  chSysUnlock();
    314a:	78 94       	sei
    314c:	08 95       	ret

0000314e <evtStop>:
 *
 * @param etp pointer to an initialized @p EvTimer structure.
 */
void evtStop(EvTimer *etp) {

  chVTReset(&etp->et_vt);
    314e:	f8 94       	cli
    3150:	fc 01       	movw	r30, r24
    3152:	26 81       	ldd	r18, Z+6	; 0x06
    3154:	37 81       	ldd	r19, Z+7	; 0x07
    3156:	23 2b       	or	r18, r19
    3158:	11 f0       	breq	.+4      	; 0x315e <evtStop+0x10>
    315a:	0e 94 a5 01 	call	0x34a	; 0x34a <chVTResetI>
    315e:	78 94       	sei
    3160:	08 95       	ret

00003162 <long_to_string_with_divisor.constprop.0>:
#include "chprintf.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 100000

static char *long_to_string_with_divisor(char *p,
    3162:	3f 92       	push	r3
    3164:	4f 92       	push	r4
    3166:	5f 92       	push	r5
    3168:	6f 92       	push	r6
    316a:	7f 92       	push	r7
    316c:	8f 92       	push	r8
    316e:	9f 92       	push	r9
    3170:	af 92       	push	r10
    3172:	bf 92       	push	r11
    3174:	cf 92       	push	r12
    3176:	df 92       	push	r13
    3178:	ef 92       	push	r14
    317a:	ff 92       	push	r15
    317c:	0f 93       	push	r16
    317e:	1f 93       	push	r17
    3180:	cf 93       	push	r28
    3182:	df 93       	push	r29
    3184:	00 d0       	rcall	.+0      	; 0x3186 <long_to_string_with_divisor.constprop.0+0x24>
    3186:	00 d0       	rcall	.+0      	; 0x3188 <long_to_string_with_divisor.constprop.0+0x26>
    3188:	cd b7       	in	r28, 0x3d	; 61
    318a:	de b7       	in	r29, 0x3e	; 62
    318c:	9c 83       	std	Y+4, r25	; 0x04
    318e:	8b 83       	std	Y+3, r24	; 0x03
    3190:	2a 01       	movw	r4, r20
    3192:	3b 01       	movw	r6, r22
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
    3194:	0b 96       	adiw	r24, 0x0b	; 11
    3196:	9a 83       	std	Y+2, r25	; 0x02
    3198:	89 83       	std	Y+1, r24	; 0x01
    319a:	49 01       	movw	r8, r18
    319c:	a1 2c       	mov	r10, r1
    319e:	b1 2c       	mov	r11, r1
    31a0:	6a 01       	movw	r12, r20
    31a2:	7b 01       	movw	r14, r22
    31a4:	8c 01       	movw	r16, r24
  do {
    i = (int)(l % radix);
    31a6:	b2 01       	movw	r22, r4
    31a8:	c3 01       	movw	r24, r6
    31aa:	a5 01       	movw	r20, r10
    31ac:	94 01       	movw	r18, r8
    31ae:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <__divmodsi4>
    i += '0';
    31b2:	cb 01       	movw	r24, r22
    31b4:	c0 96       	adiw	r24, 0x30	; 48
    if (i > '9')
    31b6:	8a 33       	cpi	r24, 0x3A	; 58
    31b8:	91 05       	cpc	r25, r1
    31ba:	14 f0       	brlt	.+4      	; 0x31c0 <long_to_string_with_divisor.constprop.0+0x5e>
      i += 'A' - '0' - 10;
    31bc:	cb 01       	movw	r24, r22
    31be:	c7 96       	adiw	r24, 0x37	; 55
    *--q = i;
    31c0:	38 2e       	mov	r3, r24
    31c2:	d8 01       	movw	r26, r16
    31c4:	8e 93       	st	-X, r24
    31c6:	8d 01       	movw	r16, r26
    l /= radix;
    31c8:	b2 01       	movw	r22, r4
    31ca:	c3 01       	movw	r24, r6
    31cc:	a5 01       	movw	r20, r10
    31ce:	94 01       	movw	r18, r8
    31d0:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <__divmodsi4>
    31d4:	29 01       	movw	r4, r18
    31d6:	3a 01       	movw	r6, r20
  } while ((ll /= radix) != 0);
    31d8:	c7 01       	movw	r24, r14
    31da:	b6 01       	movw	r22, r12
    31dc:	a5 01       	movw	r20, r10
    31de:	94 01       	movw	r18, r8
    31e0:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <__divmodsi4>
    31e4:	69 01       	movw	r12, r18
    31e6:	7a 01       	movw	r14, r20
    31e8:	21 15       	cp	r18, r1
    31ea:	31 05       	cpc	r19, r1
    31ec:	41 05       	cpc	r20, r1
    31ee:	51 05       	cpc	r21, r1
    31f0:	d1 f6       	brne	.-76     	; 0x31a6 <long_to_string_with_divisor.constprop.0+0x44>
#include "chprintf.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 100000

static char *long_to_string_with_divisor(char *p,
    31f2:	f8 01       	movw	r30, r16
    31f4:	31 96       	adiw	r30, 0x01	; 1
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
    31f6:	89 81       	ldd	r24, Y+1	; 0x01
    31f8:	9a 81       	ldd	r25, Y+2	; 0x02
    31fa:	80 1b       	sub	r24, r16
    31fc:	91 0b       	sbc	r25, r17
#include "chprintf.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 100000

static char *long_to_string_with_divisor(char *p,
    31fe:	2b 81       	ldd	r18, Y+3	; 0x03
    3200:	3c 81       	ldd	r19, Y+4	; 0x04
    3202:	82 0f       	add	r24, r18
    3204:	93 1f       	adc	r25, r19
    3206:	01 c0       	rjmp	.+2      	; 0x320a <long_to_string_with_divisor.constprop.0+0xa8>
    3208:	31 90       	ld	r3, Z+
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
    320a:	ab 81       	ldd	r26, Y+3	; 0x03
    320c:	bc 81       	ldd	r27, Y+4	; 0x04
    320e:	3d 92       	st	X+, r3
    3210:	bc 83       	std	Y+4, r27	; 0x04
    3212:	ab 83       	std	Y+3, r26	; 0x03
  while (--i);
    3214:	a8 17       	cp	r26, r24
    3216:	b9 07       	cpc	r27, r25
    3218:	b9 f7       	brne	.-18     	; 0x3208 <long_to_string_with_divisor.constprop.0+0xa6>

  return p;
}
    321a:	8b 81       	ldd	r24, Y+3	; 0x03
    321c:	9c 81       	ldd	r25, Y+4	; 0x04
    321e:	0f 90       	pop	r0
    3220:	0f 90       	pop	r0
    3222:	0f 90       	pop	r0
    3224:	0f 90       	pop	r0
    3226:	df 91       	pop	r29
    3228:	cf 91       	pop	r28
    322a:	1f 91       	pop	r17
    322c:	0f 91       	pop	r16
    322e:	ff 90       	pop	r15
    3230:	ef 90       	pop	r14
    3232:	df 90       	pop	r13
    3234:	cf 90       	pop	r12
    3236:	bf 90       	pop	r11
    3238:	af 90       	pop	r10
    323a:	9f 90       	pop	r9
    323c:	8f 90       	pop	r8
    323e:	7f 90       	pop	r7
    3240:	6f 90       	pop	r6
    3242:	5f 90       	pop	r5
    3244:	4f 90       	pop	r4
    3246:	3f 90       	pop	r3
    3248:	08 95       	ret

0000324a <chprintf>:
 *          .
 *
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 */
void chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
    324a:	2f 92       	push	r2
    324c:	3f 92       	push	r3
    324e:	4f 92       	push	r4
    3250:	5f 92       	push	r5
    3252:	6f 92       	push	r6
    3254:	7f 92       	push	r7
    3256:	8f 92       	push	r8
    3258:	9f 92       	push	r9
    325a:	af 92       	push	r10
    325c:	bf 92       	push	r11
    325e:	cf 92       	push	r12
    3260:	df 92       	push	r13
    3262:	ef 92       	push	r14
    3264:	ff 92       	push	r15
    3266:	0f 93       	push	r16
    3268:	1f 93       	push	r17
    326a:	cf 93       	push	r28
    326c:	df 93       	push	r29
    326e:	cd b7       	in	r28, 0x3d	; 61
    3270:	de b7       	in	r29, 0x3e	; 62
    3272:	60 97       	sbiw	r28, 0x10	; 16
    3274:	0f b6       	in	r0, 0x3f	; 63
    3276:	f8 94       	cli
    3278:	de bf       	out	0x3e, r29	; 62
    327a:	0f be       	out	0x3f, r0	; 63
    327c:	cd bf       	out	0x3d, r28	; 61
    327e:	cd a0       	ldd	r12, Y+37	; 0x25
    3280:	de a0       	ldd	r13, Y+38	; 0x26
    3282:	ef a0       	ldd	r14, Y+39	; 0x27
    3284:	f8 a4       	ldd	r15, Y+40	; 0x28
  char tmpbuf[2*MAX_FILLER + 1];
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  va_start(ap, fmt);
    3286:	5e 01       	movw	r10, r28
    3288:	29 e2       	ldi	r18, 0x29	; 41
    328a:	a2 0e       	add	r10, r18
    328c:	b1 1c       	adc	r11, r1
      else
        l = va_arg(ap, int);
      p = ltoa(p, l, c);
      break;
    default:
      *p++ = c;
    328e:	ce 01       	movw	r24, r28
    3290:	02 96       	adiw	r24, 0x02	; 2
    3292:	9e 87       	std	Y+14, r25	; 0x0e
    3294:	8d 87       	std	Y+13, r24	; 0x0d
    3296:	22 24       	eor	r2, r2
    3298:	23 94       	inc	r2
    329a:	31 2c       	mov	r3, r1
    329c:	2c 0e       	add	r2, r28
    329e:	3d 1e       	adc	r3, r29
    32a0:	82 19       	sub	r24, r2
    32a2:	93 09       	sbc	r25, r3
    32a4:	98 8b       	std	Y+16, r25	; 0x10
    32a6:	8f 87       	std	Y+15, r24	; 0x0f
  char tmpbuf[MAX_FILLER + 1];
#endif

  va_start(ap, fmt);
  while (TRUE) {
    c = *fmt++;
    32a8:	d7 01       	movw	r26, r14
    32aa:	6d 91       	ld	r22, X+
    32ac:	8d 01       	movw	r16, r26
    if (c == 0) {
    32ae:	66 23       	and	r22, r22
    32b0:	81 f0       	breq	.+32     	; 0x32d2 <chprintf+0x88>
      va_end(ap);
      return;
    }
    if (c != '%') {
    32b2:	65 32       	cpi	r22, 0x25	; 37
    32b4:	39 f1       	breq	.+78     	; 0x3304 <chprintf+0xba>
      chSequentialStreamPut(chp, (uint8_t)c);
    32b6:	d6 01       	movw	r26, r12
    32b8:	ed 91       	ld	r30, X+
    32ba:	fc 91       	ld	r31, X
    32bc:	04 80       	ldd	r0, Z+4	; 0x04
    32be:	f5 81       	ldd	r31, Z+5	; 0x05
    32c0:	e0 2d       	mov	r30, r0
    32c2:	c6 01       	movw	r24, r12
    32c4:	09 95       	icall
  char tmpbuf[MAX_FILLER + 1];
#endif

  va_start(ap, fmt);
  while (TRUE) {
    c = *fmt++;
    32c6:	78 01       	movw	r14, r16
    32c8:	d7 01       	movw	r26, r14
    32ca:	6d 91       	ld	r22, X+
    32cc:	8d 01       	movw	r16, r26
    if (c == 0) {
    32ce:	61 11       	cpse	r22, r1
    32d0:	f0 cf       	rjmp	.-32     	; 0x32b2 <chprintf+0x68>
    while (width) {
      chSequentialStreamPut(chp, (uint8_t)filler);
      width--;
    }
  }
}
    32d2:	60 96       	adiw	r28, 0x10	; 16
    32d4:	0f b6       	in	r0, 0x3f	; 63
    32d6:	f8 94       	cli
    32d8:	de bf       	out	0x3e, r29	; 62
    32da:	0f be       	out	0x3f, r0	; 63
    32dc:	cd bf       	out	0x3d, r28	; 61
    32de:	df 91       	pop	r29
    32e0:	cf 91       	pop	r28
    32e2:	1f 91       	pop	r17
    32e4:	0f 91       	pop	r16
    32e6:	ff 90       	pop	r15
    32e8:	ef 90       	pop	r14
    32ea:	df 90       	pop	r13
    32ec:	cf 90       	pop	r12
    32ee:	bf 90       	pop	r11
    32f0:	af 90       	pop	r10
    32f2:	9f 90       	pop	r9
    32f4:	8f 90       	pop	r8
    32f6:	7f 90       	pop	r7
    32f8:	6f 90       	pop	r6
    32fa:	5f 90       	pop	r5
    32fc:	4f 90       	pop	r4
    32fe:	3f 90       	pop	r3
    3300:	2f 90       	pop	r2
    3302:	08 95       	ret
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
    3304:	f7 01       	movw	r30, r14
    3306:	21 81       	ldd	r18, Z+1	; 0x01
    3308:	2d 32       	cpi	r18, 0x2D	; 45
    330a:	09 f4       	brne	.+2      	; 0x330e <chprintf+0xc4>
    330c:	f2 c0       	rjmp	.+484    	; 0x34f2 <chprintf+0x2a8>
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    330e:	41 2c       	mov	r4, r1
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '.') {
    3310:	2e 32       	cpi	r18, 0x2E	; 46
    3312:	09 f4       	brne	.+2      	; 0x3316 <chprintf+0xcc>
    3314:	e6 c0       	rjmp	.+460    	; 0x34e2 <chprintf+0x298>
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    3316:	b0 e2       	ldi	r27, 0x20	; 32
    3318:	5b 2e       	mov	r5, r27
 *          .
 *
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 */
void chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
    331a:	f8 01       	movw	r30, r16
    331c:	31 96       	adiw	r30, 0x01	; 1
    331e:	78 01       	movw	r14, r16
    filler = ' ';
    if (*fmt == '.') {
      fmt++;
      filler = '0';
    }
    width = 0;
    3320:	00 e0       	ldi	r16, 0x00	; 0
    3322:	10 e0       	ldi	r17, 0x00	; 0
    3324:	13 c0       	rjmp	.+38     	; 0x334c <chprintf+0x102>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
    3326:	d5 01       	movw	r26, r10
    3328:	3c 91       	ld	r19, X
    332a:	82 e0       	ldi	r24, 0x02	; 2
    332c:	a8 0e       	add	r10, r24
    332e:	b1 1c       	adc	r11, r1
      else
        break;
      width = width * 10 + c;
    3330:	c8 01       	movw	r24, r16
    3332:	88 0f       	add	r24, r24
    3334:	99 1f       	adc	r25, r25
    3336:	00 0f       	add	r16, r16
    3338:	11 1f       	adc	r17, r17
    333a:	00 0f       	add	r16, r16
    333c:	11 1f       	adc	r17, r17
    333e:	00 0f       	add	r16, r16
    3340:	11 1f       	adc	r17, r17
    3342:	08 0f       	add	r16, r24
    3344:	19 1f       	adc	r17, r25
    3346:	03 0f       	add	r16, r19
    3348:	11 1d       	adc	r17, r1
    334a:	21 91       	ld	r18, Z+
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
    334c:	bf ef       	ldi	r27, 0xFF	; 255
    334e:	eb 1a       	sub	r14, r27
    3350:	fb 0a       	sbc	r15, r27
      if (c >= '0' && c <= '9')
    3352:	32 2f       	mov	r19, r18
    3354:	30 53       	subi	r19, 0x30	; 48
    3356:	3a 30       	cpi	r19, 0x0A	; 10
    3358:	58 f3       	brcs	.-42     	; 0x3330 <chprintf+0xe6>
        c -= '0';
      else if (c == '*')
    335a:	2a 32       	cpi	r18, 0x2A	; 42
    335c:	21 f3       	breq	.-56     	; 0x3326 <chprintf+0xdc>
    335e:	f5 01       	movw	r30, r10
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
    3360:	2e 32       	cpi	r18, 0x2E	; 46
    3362:	09 f4       	brne	.+2      	; 0x3366 <chprintf+0x11c>
    3364:	9e c0       	rjmp	.+316    	; 0x34a2 <chprintf+0x258>
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    3366:	80 e0       	ldi	r24, 0x00	; 0
    3368:	90 e0       	ldi	r25, 0x00	; 0
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
    336a:	2c 36       	cpi	r18, 0x6C	; 108
    336c:	09 f4       	brne	.+2      	; 0x3370 <chprintf+0x126>
    336e:	81 c0       	rjmp	.+258    	; 0x3472 <chprintf+0x228>
    3370:	2c 34       	cpi	r18, 0x4C	; 76
    3372:	09 f4       	brne	.+2      	; 0x3376 <chprintf+0x12c>
    3374:	7e c0       	rjmp	.+252    	; 0x3472 <chprintf+0x228>
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
    3376:	32 2f       	mov	r19, r18
    3378:	31 54       	subi	r19, 0x41	; 65
    337a:	41 e0       	ldi	r20, 0x01	; 1
    337c:	3a 31       	cpi	r19, 0x1A	; 26
    337e:	08 f0       	brcs	.+2      	; 0x3382 <chprintf+0x138>
    3380:	40 e0       	ldi	r20, 0x00	; 0

    /* Command decoding.*/
    switch (c) {
    3382:	23 36       	cpi	r18, 0x63	; 99
    3384:	09 f4       	brne	.+2      	; 0x3388 <chprintf+0x13e>
    3386:	82 c0       	rjmp	.+260    	; 0x348c <chprintf+0x242>
    3388:	24 36       	cpi	r18, 0x64	; 100
    338a:	08 f0       	brcs	.+2      	; 0x338e <chprintf+0x144>
    338c:	4d c0       	rjmp	.+154    	; 0x3428 <chprintf+0x1de>
    338e:	2f 34       	cpi	r18, 0x4F	; 79
    3390:	09 f4       	brne	.+2      	; 0x3394 <chprintf+0x14a>
    3392:	e1 c0       	rjmp	.+450    	; 0x3556 <chprintf+0x30c>
    3394:	08 f0       	brcs	.+2      	; 0x3398 <chprintf+0x14e>
    3396:	04 c1       	rjmp	.+520    	; 0x35a0 <chprintf+0x356>
    3398:	24 34       	cpi	r18, 0x44	; 68
    339a:	09 f4       	brne	.+2      	; 0x339e <chprintf+0x154>
    339c:	4d c0       	rjmp	.+154    	; 0x3438 <chprintf+0x1ee>
      else
        l = va_arg(ap, int);
      p = ltoa(p, l, c);
      break;
    default:
      *p++ = c;
    339e:	29 83       	std	Y+1, r18	; 0x01
    33a0:	6f 84       	ldd	r6, Y+15	; 0x0f
    33a2:	78 88       	ldd	r7, Y+16	; 0x10
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    33a4:	41 01       	movw	r8, r2
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
    33a6:	06 19       	sub	r16, r6
    33a8:	17 09       	sbc	r17, r7
    33aa:	17 fd       	sbrc	r17, 7
    33ac:	5f c0       	rjmp	.+190    	; 0x346c <chprintf+0x222>
      width = 0;
    if (left_align == FALSE)
    33ae:	41 10       	cpse	r4, r1
    33b0:	15 c0       	rjmp	.+42     	; 0x33dc <chprintf+0x192>
      width = -width;
    33b2:	11 95       	neg	r17
    33b4:	01 95       	neg	r16
    33b6:	11 09       	sbc	r17, r1
    if (width < 0) {
    33b8:	89 f0       	breq	.+34     	; 0x33dc <chprintf+0x192>
      if (*s == '-' && filler == '0') {
    33ba:	d4 01       	movw	r26, r8
    33bc:	8c 91       	ld	r24, X
    33be:	8d 32       	cpi	r24, 0x2D	; 45
    33c0:	09 f4       	brne	.+2      	; 0x33c4 <chprintf+0x17a>
    33c2:	11 c1       	rjmp	.+546    	; 0x35e6 <chprintf+0x39c>
        chSequentialStreamPut(chp, (uint8_t)*s++);
        i--;
      }
      do
        chSequentialStreamPut(chp, (uint8_t)filler);
    33c4:	d6 01       	movw	r26, r12
    33c6:	ed 91       	ld	r30, X+
    33c8:	fc 91       	ld	r31, X
    33ca:	04 80       	ldd	r0, Z+4	; 0x04
    33cc:	f5 81       	ldd	r31, Z+5	; 0x05
    33ce:	e0 2d       	mov	r30, r0
    33d0:	65 2d       	mov	r22, r5
    33d2:	c6 01       	movw	r24, r12
    33d4:	09 95       	icall
      while (++width != 0);
    33d6:	0f 5f       	subi	r16, 0xFF	; 255
    33d8:	1f 4f       	sbci	r17, 0xFF	; 255
    33da:	a1 f7       	brne	.-24     	; 0x33c4 <chprintf+0x17a>
    }
    while (--i >= 0)
    33dc:	16 14       	cp	r1, r6
    33de:	17 04       	cpc	r1, r7
    33e0:	fc f4       	brge	.+62     	; 0x3420 <chprintf+0x1d6>
 *          .
 *
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 */
void chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
    33e2:	68 0c       	add	r6, r8
    33e4:	79 1c       	adc	r7, r9
      do
        chSequentialStreamPut(chp, (uint8_t)filler);
      while (++width != 0);
    }
    while (--i >= 0)
      chSequentialStreamPut(chp, (uint8_t)*s++);
    33e6:	f4 01       	movw	r30, r8
    33e8:	61 91       	ld	r22, Z+
    33ea:	4f 01       	movw	r8, r30
    33ec:	d6 01       	movw	r26, r12
    33ee:	ed 91       	ld	r30, X+
    33f0:	fc 91       	ld	r31, X
    33f2:	04 80       	ldd	r0, Z+4	; 0x04
    33f4:	f5 81       	ldd	r31, Z+5	; 0x05
    33f6:	e0 2d       	mov	r30, r0
    33f8:	c6 01       	movw	r24, r12
    33fa:	09 95       	icall
      }
      do
        chSequentialStreamPut(chp, (uint8_t)filler);
      while (++width != 0);
    }
    while (--i >= 0)
    33fc:	86 14       	cp	r8, r6
    33fe:	97 04       	cpc	r9, r7
    3400:	91 f7       	brne	.-28     	; 0x33e6 <chprintf+0x19c>
      chSequentialStreamPut(chp, (uint8_t)*s++);

    while (width) {
    3402:	01 15       	cp	r16, r1
    3404:	11 05       	cpc	r17, r1
    3406:	09 f4       	brne	.+2      	; 0x340a <chprintf+0x1c0>
    3408:	4f cf       	rjmp	.-354    	; 0x32a8 <chprintf+0x5e>
      chSequentialStreamPut(chp, (uint8_t)filler);
    340a:	d6 01       	movw	r26, r12
    340c:	ed 91       	ld	r30, X+
    340e:	fc 91       	ld	r31, X
    3410:	04 80       	ldd	r0, Z+4	; 0x04
    3412:	f5 81       	ldd	r31, Z+5	; 0x05
    3414:	e0 2d       	mov	r30, r0
    3416:	65 2d       	mov	r22, r5
    3418:	c6 01       	movw	r24, r12
    341a:	09 95       	icall
      width--;
    341c:	01 50       	subi	r16, 0x01	; 1
    341e:	11 09       	sbc	r17, r1
      while (++width != 0);
    }
    while (--i >= 0)
      chSequentialStreamPut(chp, (uint8_t)*s++);

    while (width) {
    3420:	01 15       	cp	r16, r1
    3422:	11 05       	cpc	r17, r1
    3424:	91 f7       	brne	.-28     	; 0x340a <chprintf+0x1c0>
    3426:	40 cf       	rjmp	.-384    	; 0x32a8 <chprintf+0x5e>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    3428:	23 37       	cpi	r18, 0x73	; 115
    342a:	09 f4       	brne	.+2      	; 0x342e <chprintf+0x1e4>
    342c:	6b c0       	rjmp	.+214    	; 0x3504 <chprintf+0x2ba>
    342e:	08 f0       	brcs	.+2      	; 0x3432 <chprintf+0x1e8>
    3430:	af c0       	rjmp	.+350    	; 0x3590 <chprintf+0x346>
    3432:	24 36       	cpi	r18, 0x64	; 100
    3434:	09 f0       	breq	.+2      	; 0x3438 <chprintf+0x1ee>
    3436:	8c c0       	rjmp	.+280    	; 0x3550 <chprintf+0x306>
      for (p = s; *p && (--precision >= 0); p++)
        ;
      break;
    case 'D':
    case 'd':
      if (is_long)
    3438:	41 11       	cpse	r20, r1
    343a:	bd c0       	rjmp	.+378    	; 0x35b6 <chprintf+0x36c>
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
    343c:	22 e0       	ldi	r18, 0x02	; 2
    343e:	a2 0e       	add	r10, r18
    3440:	b1 1c       	adc	r11, r1
    3442:	40 81       	ld	r20, Z
    3444:	51 81       	ldd	r21, Z+1	; 0x01
    3446:	66 27       	eor	r22, r22
    3448:	57 fd       	sbrc	r21, 7
    344a:	60 95       	com	r22
    344c:	76 2f       	mov	r23, r22
      if (l < 0) {
    344e:	77 fd       	sbrc	r23, 7
    3450:	bb c0       	rjmp	.+374    	; 0x35c8 <chprintf+0x37e>
    }
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    3452:	c1 01       	movw	r24, r2
  return p;
}

static char *ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
    3454:	2a e0       	ldi	r18, 0x0A	; 10
    3456:	30 e0       	ldi	r19, 0x00	; 0
    3458:	0e 94 b1 18 	call	0x3162	; 0x3162 <long_to_string_with_divisor.constprop.0>
    345c:	3c 01       	movw	r6, r24
    345e:	62 18       	sub	r6, r2
    3460:	73 08       	sbc	r7, r3
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    3462:	41 01       	movw	r8, r2
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
    3464:	06 19       	sub	r16, r6
    3466:	17 09       	sbc	r17, r7
    3468:	17 ff       	sbrs	r17, 7
    346a:	a1 cf       	rjmp	.-190    	; 0x33ae <chprintf+0x164>
    346c:	00 e0       	ldi	r16, 0x00	; 0
    346e:	10 e0       	ldi	r17, 0x00	; 0
    3470:	9e cf       	rjmp	.-196    	; 0x33ae <chprintf+0x164>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
    3472:	d7 01       	movw	r26, r14
    3474:	3c 91       	ld	r19, X
    3476:	33 23       	and	r19, r19
    3478:	09 f4       	brne	.+2      	; 0x347c <chprintf+0x232>
    347a:	42 c0       	rjmp	.+132    	; 0x3500 <chprintf+0x2b6>
        c = *fmt++;
    347c:	bf ef       	ldi	r27, 0xFF	; 255
    347e:	eb 1a       	sub	r14, r27
    3480:	fb 0a       	sbc	r15, r27
    3482:	23 2f       	mov	r18, r19
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
    3484:	41 e0       	ldi	r20, 0x01	; 1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    3486:	23 36       	cpi	r18, 0x63	; 99
    3488:	09 f0       	breq	.+2      	; 0x348c <chprintf+0x242>
    348a:	7e cf       	rjmp	.-260    	; 0x3388 <chprintf+0x13e>
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
    348c:	22 e0       	ldi	r18, 0x02	; 2
    348e:	a2 0e       	add	r10, r18
    3490:	b1 1c       	adc	r11, r1
    3492:	80 81       	ld	r24, Z
    3494:	89 83       	std	Y+1, r24	; 0x01
    3496:	6f 84       	ldd	r6, Y+15	; 0x0f
    3498:	78 88       	ldd	r7, Y+16	; 0x10
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
    349a:	30 e2       	ldi	r19, 0x20	; 32
    349c:	53 2e       	mov	r5, r19
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    349e:	41 01       	movw	r8, r2
    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    34a0:	82 cf       	rjmp	.-252    	; 0x33a6 <chprintf+0x15c>
    34a2:	f7 01       	movw	r30, r14
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
    34a4:	80 e0       	ldi	r24, 0x00	; 0
    34a6:	90 e0       	ldi	r25, 0x00	; 0
    34a8:	12 c0       	rjmp	.+36     	; 0x34ce <chprintf+0x284>
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
    34aa:	d5 01       	movw	r26, r10
    34ac:	4c 91       	ld	r20, X
    34ae:	22 e0       	ldi	r18, 0x02	; 2
    34b0:	a2 0e       	add	r10, r18
    34b2:	b1 1c       	adc	r11, r1
        else
          break;
        precision *= 10;
    34b4:	9c 01       	movw	r18, r24
    34b6:	22 0f       	add	r18, r18
    34b8:	33 1f       	adc	r19, r19
    34ba:	88 0f       	add	r24, r24
    34bc:	99 1f       	adc	r25, r25
    34be:	88 0f       	add	r24, r24
    34c0:	99 1f       	adc	r25, r25
    34c2:	88 0f       	add	r24, r24
    34c4:	99 1f       	adc	r25, r25
    34c6:	82 0f       	add	r24, r18
    34c8:	93 1f       	adc	r25, r19
        precision += c;
    34ca:	84 0f       	add	r24, r20
    34cc:	91 1d       	adc	r25, r1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
    34ce:	21 91       	ld	r18, Z+
    34d0:	7f 01       	movw	r14, r30
        if (c >= '0' && c <= '9')
    34d2:	42 2f       	mov	r20, r18
    34d4:	40 53       	subi	r20, 0x30	; 48
    34d6:	4a 30       	cpi	r20, 0x0A	; 10
    34d8:	68 f3       	brcs	.-38     	; 0x34b4 <chprintf+0x26a>
          c -= '0';
        else if (c == '*')
    34da:	2a 32       	cpi	r18, 0x2A	; 42
    34dc:	31 f3       	breq	.-52     	; 0x34aa <chprintf+0x260>
    34de:	f5 01       	movw	r30, r10
    34e0:	44 cf       	rjmp	.-376    	; 0x336a <chprintf+0x120>
    34e2:	d8 01       	movw	r26, r16
    34e4:	11 96       	adiw	r26, 0x01	; 1
    34e6:	2c 91       	ld	r18, X
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '.') {
      fmt++;
    34e8:	0f 5f       	subi	r16, 0xFF	; 255
    34ea:	1f 4f       	sbci	r17, 0xFF	; 255
      filler = '0';
    34ec:	80 e3       	ldi	r24, 0x30	; 48
    34ee:	58 2e       	mov	r5, r24
    34f0:	14 cf       	rjmp	.-472    	; 0x331a <chprintf+0xd0>
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
    34f2:	87 01       	movw	r16, r14
    34f4:	0e 5f       	subi	r16, 0xFE	; 254
    34f6:	1f 4f       	sbci	r17, 0xFF	; 255
    34f8:	22 81       	ldd	r18, Z+2	; 0x02
      left_align = TRUE;
    34fa:	44 24       	eor	r4, r4
    34fc:	43 94       	inc	r4
    34fe:	08 cf       	rjmp	.-496    	; 0x3310 <chprintf+0xc6>
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
    3500:	41 e0       	ldi	r20, 0x01	; 1
    3502:	3f cf       	rjmp	.-386    	; 0x3382 <chprintf+0x138>
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
    3504:	32 e0       	ldi	r19, 0x02	; 2
    3506:	a3 0e       	add	r10, r19
    3508:	b1 1c       	adc	r11, r1
    350a:	80 80       	ld	r8, Z
    350c:	91 80       	ldd	r9, Z+1	; 0x01
    350e:	81 14       	cp	r8, r1
    3510:	91 04       	cpc	r9, r1
    3512:	09 f4       	brne	.+2      	; 0x3516 <chprintf+0x2cc>
    3514:	7b c0       	rjmp	.+246    	; 0x360c <chprintf+0x3c2>
        s = "(null)";
      if (precision == 0)
    3516:	00 97       	sbiw	r24, 0x00	; 0
    3518:	09 f4       	brne	.+2      	; 0x351c <chprintf+0x2d2>
    351a:	62 c0       	rjmp	.+196    	; 0x35e0 <chprintf+0x396>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    351c:	d4 01       	movw	r26, r8
    351e:	2c 91       	ld	r18, X
    3520:	22 23       	and	r18, r18
    3522:	09 f4       	brne	.+2      	; 0x3526 <chprintf+0x2dc>
    3524:	78 c0       	rjmp	.+240    	; 0x3616 <chprintf+0x3cc>
 *          .
 *
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 */
void chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
    3526:	94 01       	movw	r18, r8
    3528:	2f 5f       	subi	r18, 0xFF	; 255
    352a:	3f 4f       	sbci	r19, 0xFF	; 255
    352c:	82 0f       	add	r24, r18
    352e:	93 1f       	adc	r25, r19
    3530:	03 c0       	rjmp	.+6      	; 0x3538 <chprintf+0x2ee>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    3532:	28 17       	cp	r18, r24
    3534:	39 07       	cpc	r19, r25
    3536:	31 f0       	breq	.+12     	; 0x3544 <chprintf+0x2fa>
    3538:	f9 01       	movw	r30, r18
    353a:	2f 5f       	subi	r18, 0xFF	; 255
    353c:	3f 4f       	sbci	r19, 0xFF	; 255
    353e:	40 81       	ld	r20, Z
    3540:	41 11       	cpse	r20, r1
    3542:	f7 cf       	rjmp	.-18     	; 0x3532 <chprintf+0x2e8>
    3544:	3f 01       	movw	r6, r30
    3546:	68 18       	sub	r6, r8
    3548:	79 08       	sbc	r7, r9
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
    354a:	90 e2       	ldi	r25, 0x20	; 32
    354c:	59 2e       	mov	r5, r25
    354e:	2b cf       	rjmp	.-426    	; 0x33a6 <chprintf+0x15c>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    3550:	2f 36       	cpi	r18, 0x6F	; 111
    3552:	09 f0       	breq	.+2      	; 0x3556 <chprintf+0x30c>
    3554:	24 cf       	rjmp	.-440    	; 0x339e <chprintf+0x154>
    3556:	28 e0       	ldi	r18, 0x08	; 8
    3558:	30 e0       	ldi	r19, 0x00	; 0
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
unsigned_common:
      if (is_long)
    355a:	44 23       	and	r20, r20
    355c:	79 f0       	breq	.+30     	; 0x357c <chprintf+0x332>
        l = va_arg(ap, long);
    355e:	84 e0       	ldi	r24, 0x04	; 4
    3560:	a8 0e       	add	r10, r24
    3562:	b1 1c       	adc	r11, r1
    3564:	40 81       	ld	r20, Z
    3566:	51 81       	ldd	r21, Z+1	; 0x01
    3568:	62 81       	ldd	r22, Z+2	; 0x02
    356a:	73 81       	ldd	r23, Z+3	; 0x03
  return p;
}

static char *ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
    356c:	c1 01       	movw	r24, r2
    356e:	0e 94 b1 18 	call	0x3162	; 0x3162 <long_to_string_with_divisor.constprop.0>
    3572:	3c 01       	movw	r6, r24
    3574:	62 18       	sub	r6, r2
    3576:	73 08       	sbc	r7, r3
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    3578:	41 01       	movw	r8, r2
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      p = ltoa(p, l, c);
      break;
    357a:	15 cf       	rjmp	.-470    	; 0x33a6 <chprintf+0x15c>
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
    357c:	92 e0       	ldi	r25, 0x02	; 2
    357e:	a9 0e       	add	r10, r25
    3580:	b1 1c       	adc	r11, r1
    3582:	40 81       	ld	r20, Z
    3584:	51 81       	ldd	r21, Z+1	; 0x01
    3586:	66 27       	eor	r22, r22
    3588:	57 fd       	sbrc	r21, 7
    358a:	60 95       	com	r22
    358c:	76 2f       	mov	r23, r22
    358e:	ee cf       	rjmp	.-36     	; 0x356c <chprintf+0x322>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    3590:	25 37       	cpi	r18, 0x75	; 117
    3592:	41 f0       	breq	.+16     	; 0x35a4 <chprintf+0x35a>
    3594:	28 37       	cpi	r18, 0x78	; 120
    3596:	09 f0       	breq	.+2      	; 0x359a <chprintf+0x350>
    3598:	02 cf       	rjmp	.-508    	; 0x339e <chprintf+0x154>
    359a:	20 e1       	ldi	r18, 0x10	; 16
    359c:	30 e0       	ldi	r19, 0x00	; 0
    359e:	dd cf       	rjmp	.-70     	; 0x355a <chprintf+0x310>
    35a0:	25 35       	cpi	r18, 0x55	; 85
    35a2:	19 f4       	brne	.+6      	; 0x35aa <chprintf+0x360>
    35a4:	2a e0       	ldi	r18, 0x0A	; 10
    35a6:	30 e0       	ldi	r19, 0x00	; 0
    35a8:	d8 cf       	rjmp	.-80     	; 0x355a <chprintf+0x310>
    35aa:	28 35       	cpi	r18, 0x58	; 88
    35ac:	09 f0       	breq	.+2      	; 0x35b0 <chprintf+0x366>
    35ae:	f7 ce       	rjmp	.-530    	; 0x339e <chprintf+0x154>
    35b0:	20 e1       	ldi	r18, 0x10	; 16
    35b2:	30 e0       	ldi	r19, 0x00	; 0
    35b4:	d2 cf       	rjmp	.-92     	; 0x355a <chprintf+0x310>
        ;
      break;
    case 'D':
    case 'd':
      if (is_long)
        l = va_arg(ap, long);
    35b6:	b4 e0       	ldi	r27, 0x04	; 4
    35b8:	ab 0e       	add	r10, r27
    35ba:	b1 1c       	adc	r11, r1
    35bc:	40 81       	ld	r20, Z
    35be:	51 81       	ldd	r21, Z+1	; 0x01
    35c0:	62 81       	ldd	r22, Z+2	; 0x02
    35c2:	73 81       	ldd	r23, Z+3	; 0x03
      else
        l = va_arg(ap, int);
      if (l < 0) {
    35c4:	77 ff       	sbrs	r23, 7
    35c6:	45 cf       	rjmp	.-374    	; 0x3452 <chprintf+0x208>
        *p++ = '-';
    35c8:	8d e2       	ldi	r24, 0x2D	; 45
    35ca:	89 83       	std	Y+1, r24	; 0x01
        l = -l;
    35cc:	70 95       	com	r23
    35ce:	60 95       	com	r22
    35d0:	50 95       	com	r21
    35d2:	41 95       	neg	r20
    35d4:	5f 4f       	sbci	r21, 0xFF	; 255
    35d6:	6f 4f       	sbci	r22, 0xFF	; 255
    35d8:	7f 4f       	sbci	r23, 0xFF	; 255
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
    35da:	8d 85       	ldd	r24, Y+13	; 0x0d
    35dc:	9e 85       	ldd	r25, Y+14	; 0x0e
    35de:	3a cf       	rjmp	.-396    	; 0x3454 <chprintf+0x20a>
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
    35e0:	8f ef       	ldi	r24, 0xFF	; 255
    35e2:	9f e7       	ldi	r25, 0x7F	; 127
    35e4:	9b cf       	rjmp	.-202    	; 0x351c <chprintf+0x2d2>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
    35e6:	b0 e3       	ldi	r27, 0x30	; 48
    35e8:	5b 12       	cpse	r5, r27
    35ea:	ec ce       	rjmp	.-552    	; 0x33c4 <chprintf+0x17a>
        chSequentialStreamPut(chp, (uint8_t)*s++);
    35ec:	ef ef       	ldi	r30, 0xFF	; 255
    35ee:	8e 1a       	sub	r8, r30
    35f0:	9e 0a       	sbc	r9, r30
    35f2:	d6 01       	movw	r26, r12
    35f4:	ed 91       	ld	r30, X+
    35f6:	fc 91       	ld	r31, X
    35f8:	04 80       	ldd	r0, Z+4	; 0x04
    35fa:	f5 81       	ldd	r31, Z+5	; 0x05
    35fc:	e0 2d       	mov	r30, r0
    35fe:	6d e2       	ldi	r22, 0x2D	; 45
    3600:	c6 01       	movw	r24, r12
    3602:	09 95       	icall
        i--;
    3604:	b1 e0       	ldi	r27, 0x01	; 1
    3606:	6b 1a       	sub	r6, r27
    3608:	71 08       	sbc	r7, r1
    360a:	dc ce       	rjmp	.-584    	; 0x33c4 <chprintf+0x17a>
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
    360c:	2a e8       	ldi	r18, 0x8A	; 138
    360e:	82 2e       	mov	r8, r18
    3610:	21 e0       	ldi	r18, 0x01	; 1
    3612:	92 2e       	mov	r9, r18
    3614:	80 cf       	rjmp	.-256    	; 0x3516 <chprintf+0x2cc>
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    3616:	61 2c       	mov	r6, r1
    3618:	71 2c       	mov	r7, r1
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
    361a:	80 e2       	ldi	r24, 0x20	; 32
    361c:	58 2e       	mov	r5, r24
    361e:	c3 ce       	rjmp	.-634    	; 0x33a6 <chprintf+0x15c>

00003620 <main>:
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */


  halInit();
    3620:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <halInit>
  chSysInit();
    3624:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <chSysInit>
  

  sdStart(&SD1, NULL);
    3628:	60 e0       	ldi	r22, 0x00	; 0
    362a:	70 e0       	ldi	r23, 0x00	; 0
    362c:	8e e3       	ldi	r24, 0x3E	; 62
    362e:	92 e0       	ldi	r25, 0x02	; 2
    3630:	0e 94 2b 10 	call	0x2056	; 0x2056 <sdStart>
  uint8_t a = 0;
    3634:	f1 2c       	mov	r15, r1
  while(1){
      a++;
      chprintf(&SD1,"a: %4.4x\n",a);
    3636:	01 e9       	ldi	r16, 0x91	; 145
    3638:	11 e0       	ldi	r17, 0x01	; 1
    363a:	ce e3       	ldi	r28, 0x3E	; 62
    363c:	d2 e0       	ldi	r29, 0x02	; 2
  

  sdStart(&SD1, NULL);
  uint8_t a = 0;
  while(1){
      a++;
    363e:	f3 94       	inc	r15
      chprintf(&SD1,"a: %4.4x\n",a);
    3640:	1f 92       	push	r1
    3642:	ff 92       	push	r15
    3644:	1f 93       	push	r17
    3646:	0f 93       	push	r16
    3648:	df 93       	push	r29
    364a:	cf 93       	push	r28
    364c:	0e 94 25 19 	call	0x324a	; 0x324a <chprintf>
      
      chThdSleepMilliseconds(20);
    3650:	8c e0       	ldi	r24, 0x0C	; 12
    3652:	90 e0       	ldi	r25, 0x00	; 0
    3654:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <chThdSleep>
    3658:	0f 90       	pop	r0
    365a:	0f 90       	pop	r0
    365c:	0f 90       	pop	r0
    365e:	0f 90       	pop	r0
    3660:	0f 90       	pop	r0
    3662:	0f 90       	pop	r0
    3664:	ec cf       	rjmp	.-40     	; 0x363e <main+0x1e>

00003666 <vfprintf>:
    3666:	ac e0       	ldi	r26, 0x0C	; 12
    3668:	b0 e0       	ldi	r27, 0x00	; 0
    366a:	e9 e3       	ldi	r30, 0x39	; 57
    366c:	fb e1       	ldi	r31, 0x1B	; 27
    366e:	0c 94 ae 1e 	jmp	0x3d5c	; 0x3d5c <__prologue_saves__+0x8>
    3672:	6c 01       	movw	r12, r24
    3674:	3b 01       	movw	r6, r22
    3676:	8a 01       	movw	r16, r20
    3678:	fc 01       	movw	r30, r24
    367a:	17 82       	std	Z+7, r1	; 0x07
    367c:	16 82       	std	Z+6, r1	; 0x06
    367e:	83 81       	ldd	r24, Z+3	; 0x03
    3680:	81 fd       	sbrc	r24, 1
    3682:	03 c0       	rjmp	.+6      	; 0x368a <vfprintf+0x24>
    3684:	1f c1       	rjmp	.+574    	; 0x38c4 <vfprintf+0x25e>
    3686:	85 01       	movw	r16, r10
    3688:	04 c0       	rjmp	.+8      	; 0x3692 <vfprintf+0x2c>
    368a:	4e 01       	movw	r8, r28
    368c:	08 94       	sec
    368e:	81 1c       	adc	r8, r1
    3690:	91 1c       	adc	r9, r1
    3692:	f6 01       	movw	r30, r12
    3694:	e3 80       	ldd	r14, Z+3	; 0x03
    3696:	f3 01       	movw	r30, r6
    3698:	e3 fc       	sbrc	r14, 3
    369a:	85 91       	lpm	r24, Z+
    369c:	e3 fe       	sbrs	r14, 3
    369e:	81 91       	ld	r24, Z+
    36a0:	3f 01       	movw	r6, r30
    36a2:	88 23       	and	r24, r24
    36a4:	09 f4       	brne	.+2      	; 0x36a8 <vfprintf+0x42>
    36a6:	0a c1       	rjmp	.+532    	; 0x38bc <vfprintf+0x256>
    36a8:	85 32       	cpi	r24, 0x25	; 37
    36aa:	39 f4       	brne	.+14     	; 0x36ba <vfprintf+0x54>
    36ac:	e3 fc       	sbrc	r14, 3
    36ae:	25 91       	lpm	r18, Z+
    36b0:	e3 fe       	sbrs	r14, 3
    36b2:	21 91       	ld	r18, Z+
    36b4:	3f 01       	movw	r6, r30
    36b6:	25 32       	cpi	r18, 0x25	; 37
    36b8:	19 f5       	brne	.+70     	; 0x3700 <vfprintf+0x9a>
    36ba:	90 e0       	ldi	r25, 0x00	; 0
    36bc:	b6 01       	movw	r22, r12
    36be:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <fputc>
    36c2:	58 01       	movw	r10, r16
    36c4:	e0 cf       	rjmp	.-64     	; 0x3686 <vfprintf+0x20>
    36c6:	22 23       	and	r18, r18
    36c8:	09 f4       	brne	.+2      	; 0x36cc <vfprintf+0x66>
    36ca:	f8 c0       	rjmp	.+496    	; 0x38bc <vfprintf+0x256>
    36cc:	8c e7       	ldi	r24, 0x7C	; 124
    36ce:	90 e0       	ldi	r25, 0x00	; 0
    36d0:	62 2f       	mov	r22, r18
    36d2:	70 e0       	ldi	r23, 0x00	; 0
    36d4:	2c 87       	std	Y+12, r18	; 0x0c
    36d6:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <strchr_P>
    36da:	2c 85       	ldd	r18, Y+12	; 0x0c
    36dc:	00 97       	sbiw	r24, 0x00	; 0
    36de:	49 f4       	brne	.+18     	; 0x36f2 <vfprintf+0x8c>
    36e0:	23 32       	cpi	r18, 0x23	; 35
    36e2:	19 f4       	brne	.+6      	; 0x36ea <vfprintf+0x84>
    36e4:	f0 e1       	ldi	r31, 0x10	; 16
    36e6:	ff 2a       	or	r15, r31
    36e8:	04 c0       	rjmp	.+8      	; 0x36f2 <vfprintf+0x8c>
    36ea:	2c 36       	cpi	r18, 0x6C	; 108
    36ec:	79 f4       	brne	.+30     	; 0x370c <vfprintf+0xa6>
    36ee:	20 e8       	ldi	r18, 0x80	; 128
    36f0:	f2 2a       	or	r15, r18
    36f2:	f3 01       	movw	r30, r6
    36f4:	e3 fc       	sbrc	r14, 3
    36f6:	25 91       	lpm	r18, Z+
    36f8:	e3 fe       	sbrs	r14, 3
    36fa:	21 91       	ld	r18, Z+
    36fc:	3f 01       	movw	r6, r30
    36fe:	01 c0       	rjmp	.+2      	; 0x3702 <vfprintf+0x9c>
    3700:	ff 24       	eor	r15, r15
    3702:	f7 fe       	sbrs	r15, 7
    3704:	e0 cf       	rjmp	.-64     	; 0x36c6 <vfprintf+0x60>
    3706:	22 23       	and	r18, r18
    3708:	09 f4       	brne	.+2      	; 0x370c <vfprintf+0xa6>
    370a:	d8 c0       	rjmp	.+432    	; 0x38bc <vfprintf+0x256>
    370c:	8c e8       	ldi	r24, 0x8C	; 140
    370e:	90 e0       	ldi	r25, 0x00	; 0
    3710:	62 2f       	mov	r22, r18
    3712:	70 e0       	ldi	r23, 0x00	; 0
    3714:	2c 87       	std	Y+12, r18	; 0x0c
    3716:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <strchr_P>
    371a:	2c 85       	ldd	r18, Y+12	; 0x0c
    371c:	00 97       	sbiw	r24, 0x00	; 0
    371e:	41 f0       	breq	.+16     	; 0x3730 <vfprintf+0xca>
    3720:	64 e0       	ldi	r22, 0x04	; 4
    3722:	a6 2e       	mov	r10, r22
    3724:	b1 2c       	mov	r11, r1
    3726:	a0 0e       	add	r10, r16
    3728:	b1 1e       	adc	r11, r17
    372a:	8f e3       	ldi	r24, 0x3F	; 63
    372c:	90 e0       	ldi	r25, 0x00	; 0
    372e:	0f c0       	rjmp	.+30     	; 0x374e <vfprintf+0xe8>
    3730:	23 36       	cpi	r18, 0x63	; 99
    3732:	29 f0       	breq	.+10     	; 0x373e <vfprintf+0xd8>
    3734:	23 37       	cpi	r18, 0x73	; 115
    3736:	89 f0       	breq	.+34     	; 0x375a <vfprintf+0xf4>
    3738:	23 35       	cpi	r18, 0x53	; 83
    373a:	29 f5       	brne	.+74     	; 0x3786 <vfprintf+0x120>
    373c:	0c c0       	rjmp	.+24     	; 0x3756 <vfprintf+0xf0>
    373e:	52 e0       	ldi	r21, 0x02	; 2
    3740:	a5 2e       	mov	r10, r21
    3742:	b1 2c       	mov	r11, r1
    3744:	a0 0e       	add	r10, r16
    3746:	b1 1e       	adc	r11, r17
    3748:	f8 01       	movw	r30, r16
    374a:	80 81       	ld	r24, Z
    374c:	91 81       	ldd	r25, Z+1	; 0x01
    374e:	b6 01       	movw	r22, r12
    3750:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <fputc>
    3754:	98 cf       	rjmp	.-208    	; 0x3686 <vfprintf+0x20>
    3756:	f1 e0       	ldi	r31, 0x01	; 1
    3758:	ff 2a       	or	r15, r31
    375a:	42 e0       	ldi	r20, 0x02	; 2
    375c:	a4 2e       	mov	r10, r20
    375e:	b1 2c       	mov	r11, r1
    3760:	a0 0e       	add	r10, r16
    3762:	b1 1e       	adc	r11, r17
    3764:	f8 01       	movw	r30, r16
    3766:	00 81       	ld	r16, Z
    3768:	11 81       	ldd	r17, Z+1	; 0x01
    376a:	04 c0       	rjmp	.+8      	; 0x3774 <vfprintf+0x10e>
    376c:	90 e0       	ldi	r25, 0x00	; 0
    376e:	b6 01       	movw	r22, r12
    3770:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <fputc>
    3774:	f8 01       	movw	r30, r16
    3776:	f0 fc       	sbrc	r15, 0
    3778:	85 91       	lpm	r24, Z+
    377a:	f0 fe       	sbrs	r15, 0
    377c:	81 91       	ld	r24, Z+
    377e:	8f 01       	movw	r16, r30
    3780:	88 23       	and	r24, r24
    3782:	a1 f7       	brne	.-24     	; 0x376c <vfprintf+0x106>
    3784:	80 cf       	rjmp	.-256    	; 0x3686 <vfprintf+0x20>
    3786:	24 36       	cpi	r18, 0x64	; 100
    3788:	11 f0       	breq	.+4      	; 0x378e <vfprintf+0x128>
    378a:	29 36       	cpi	r18, 0x69	; 105
    378c:	61 f5       	brne	.+88     	; 0x37e6 <vfprintf+0x180>
    378e:	f7 fe       	sbrs	r15, 7
    3790:	0b c0       	rjmp	.+22     	; 0x37a8 <vfprintf+0x142>
    3792:	34 e0       	ldi	r19, 0x04	; 4
    3794:	a3 2e       	mov	r10, r19
    3796:	b1 2c       	mov	r11, r1
    3798:	a0 0e       	add	r10, r16
    379a:	b1 1e       	adc	r11, r17
    379c:	f8 01       	movw	r30, r16
    379e:	80 81       	ld	r24, Z
    37a0:	91 81       	ldd	r25, Z+1	; 0x01
    37a2:	a2 81       	ldd	r26, Z+2	; 0x02
    37a4:	b3 81       	ldd	r27, Z+3	; 0x03
    37a6:	0c c0       	rjmp	.+24     	; 0x37c0 <vfprintf+0x15a>
    37a8:	22 e0       	ldi	r18, 0x02	; 2
    37aa:	a2 2e       	mov	r10, r18
    37ac:	b1 2c       	mov	r11, r1
    37ae:	a0 0e       	add	r10, r16
    37b0:	b1 1e       	adc	r11, r17
    37b2:	f8 01       	movw	r30, r16
    37b4:	80 81       	ld	r24, Z
    37b6:	91 81       	ldd	r25, Z+1	; 0x01
    37b8:	aa 27       	eor	r26, r26
    37ba:	97 fd       	sbrc	r25, 7
    37bc:	a0 95       	com	r26
    37be:	ba 2f       	mov	r27, r26
    37c0:	ff ee       	ldi	r31, 0xEF	; 239
    37c2:	ff 22       	and	r15, r31
    37c4:	b7 ff       	sbrs	r27, 7
    37c6:	09 c0       	rjmp	.+18     	; 0x37da <vfprintf+0x174>
    37c8:	b0 95       	com	r27
    37ca:	a0 95       	com	r26
    37cc:	90 95       	com	r25
    37ce:	81 95       	neg	r24
    37d0:	9f 4f       	sbci	r25, 0xFF	; 255
    37d2:	af 4f       	sbci	r26, 0xFF	; 255
    37d4:	bf 4f       	sbci	r27, 0xFF	; 255
    37d6:	20 e4       	ldi	r18, 0x40	; 64
    37d8:	f2 2a       	or	r15, r18
    37da:	bc 01       	movw	r22, r24
    37dc:	cd 01       	movw	r24, r26
    37de:	a4 01       	movw	r20, r8
    37e0:	2a e0       	ldi	r18, 0x0A	; 10
    37e2:	30 e0       	ldi	r19, 0x00	; 0
    37e4:	3b c0       	rjmp	.+118    	; 0x385c <vfprintf+0x1f6>
    37e6:	20 37       	cpi	r18, 0x70	; 112
    37e8:	99 f0       	breq	.+38     	; 0x3810 <vfprintf+0x1aa>
    37ea:	21 37       	cpi	r18, 0x71	; 113
    37ec:	30 f4       	brcc	.+12     	; 0x37fa <vfprintf+0x194>
    37ee:	28 35       	cpi	r18, 0x58	; 88
    37f0:	b1 f0       	breq	.+44     	; 0x381e <vfprintf+0x1b8>
    37f2:	2f 36       	cpi	r18, 0x6F	; 111
    37f4:	09 f0       	breq	.+2      	; 0x37f8 <vfprintf+0x192>
    37f6:	62 c0       	rjmp	.+196    	; 0x38bc <vfprintf+0x256>
    37f8:	17 c0       	rjmp	.+46     	; 0x3828 <vfprintf+0x1c2>
    37fa:	25 37       	cpi	r18, 0x75	; 117
    37fc:	21 f0       	breq	.+8      	; 0x3806 <vfprintf+0x1a0>
    37fe:	28 37       	cpi	r18, 0x78	; 120
    3800:	09 f0       	breq	.+2      	; 0x3804 <vfprintf+0x19e>
    3802:	5c c0       	rjmp	.+184    	; 0x38bc <vfprintf+0x256>
    3804:	07 c0       	rjmp	.+14     	; 0x3814 <vfprintf+0x1ae>
    3806:	8f ee       	ldi	r24, 0xEF	; 239
    3808:	f8 22       	and	r15, r24
    380a:	2a e0       	ldi	r18, 0x0A	; 10
    380c:	30 e0       	ldi	r19, 0x00	; 0
    380e:	0e c0       	rjmp	.+28     	; 0x382c <vfprintf+0x1c6>
    3810:	e0 e1       	ldi	r30, 0x10	; 16
    3812:	fe 2a       	or	r15, r30
    3814:	f4 e2       	ldi	r31, 0x24	; 36
    3816:	ff 2a       	or	r15, r31
    3818:	20 e1       	ldi	r18, 0x10	; 16
    381a:	30 e0       	ldi	r19, 0x00	; 0
    381c:	07 c0       	rjmp	.+14     	; 0x382c <vfprintf+0x1c6>
    381e:	24 e0       	ldi	r18, 0x04	; 4
    3820:	f2 2a       	or	r15, r18
    3822:	20 e1       	ldi	r18, 0x10	; 16
    3824:	32 e0       	ldi	r19, 0x02	; 2
    3826:	02 c0       	rjmp	.+4      	; 0x382c <vfprintf+0x1c6>
    3828:	28 e0       	ldi	r18, 0x08	; 8
    382a:	30 e0       	ldi	r19, 0x00	; 0
    382c:	f7 fe       	sbrs	r15, 7
    382e:	0b c0       	rjmp	.+22     	; 0x3846 <vfprintf+0x1e0>
    3830:	94 e0       	ldi	r25, 0x04	; 4
    3832:	a9 2e       	mov	r10, r25
    3834:	b1 2c       	mov	r11, r1
    3836:	a0 0e       	add	r10, r16
    3838:	b1 1e       	adc	r11, r17
    383a:	f8 01       	movw	r30, r16
    383c:	60 81       	ld	r22, Z
    383e:	71 81       	ldd	r23, Z+1	; 0x01
    3840:	82 81       	ldd	r24, Z+2	; 0x02
    3842:	93 81       	ldd	r25, Z+3	; 0x03
    3844:	0a c0       	rjmp	.+20     	; 0x385a <vfprintf+0x1f4>
    3846:	82 e0       	ldi	r24, 0x02	; 2
    3848:	a8 2e       	mov	r10, r24
    384a:	b1 2c       	mov	r11, r1
    384c:	a0 0e       	add	r10, r16
    384e:	b1 1e       	adc	r11, r17
    3850:	f8 01       	movw	r30, r16
    3852:	60 81       	ld	r22, Z
    3854:	71 81       	ldd	r23, Z+1	; 0x01
    3856:	80 e0       	ldi	r24, 0x00	; 0
    3858:	90 e0       	ldi	r25, 0x00	; 0
    385a:	a4 01       	movw	r20, r8
    385c:	0e 94 88 1f 	call	0x3f10	; 0x3f10 <__ultoa_invert>
    3860:	08 2f       	mov	r16, r24
    3862:	08 19       	sub	r16, r8
    3864:	ef 2c       	mov	r14, r15
    3866:	ff 24       	eor	r15, r15
    3868:	e6 fe       	sbrs	r14, 6
    386a:	05 c0       	rjmp	.+10     	; 0x3876 <vfprintf+0x210>
    386c:	8d e2       	ldi	r24, 0x2D	; 45
    386e:	90 e0       	ldi	r25, 0x00	; 0
    3870:	b6 01       	movw	r22, r12
    3872:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <fputc>
    3876:	e4 fe       	sbrs	r14, 4
    3878:	15 c0       	rjmp	.+42     	; 0x38a4 <vfprintf+0x23e>
    387a:	fe 01       	movw	r30, r28
    387c:	e0 0f       	add	r30, r16
    387e:	f1 1d       	adc	r31, r1
    3880:	80 81       	ld	r24, Z
    3882:	80 33       	cpi	r24, 0x30	; 48
    3884:	79 f0       	breq	.+30     	; 0x38a4 <vfprintf+0x23e>
    3886:	80 e3       	ldi	r24, 0x30	; 48
    3888:	90 e0       	ldi	r25, 0x00	; 0
    388a:	b6 01       	movw	r22, r12
    388c:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <fputc>
    3890:	e2 fe       	sbrs	r14, 2
    3892:	08 c0       	rjmp	.+16     	; 0x38a4 <vfprintf+0x23e>
    3894:	c7 01       	movw	r24, r14
    3896:	80 72       	andi	r24, 0x20	; 32
    3898:	90 70       	andi	r25, 0x00	; 0
    389a:	88 5a       	subi	r24, 0xA8	; 168
    389c:	9f 4f       	sbci	r25, 0xFF	; 255
    389e:	b6 01       	movw	r22, r12
    38a0:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <fputc>
    38a4:	01 50       	subi	r16, 0x01	; 1
    38a6:	f4 01       	movw	r30, r8
    38a8:	e0 0f       	add	r30, r16
    38aa:	f1 1d       	adc	r31, r1
    38ac:	80 81       	ld	r24, Z
    38ae:	90 e0       	ldi	r25, 0x00	; 0
    38b0:	b6 01       	movw	r22, r12
    38b2:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <fputc>
    38b6:	00 23       	and	r16, r16
    38b8:	a9 f7       	brne	.-22     	; 0x38a4 <vfprintf+0x23e>
    38ba:	e5 ce       	rjmp	.-566    	; 0x3686 <vfprintf+0x20>
    38bc:	f6 01       	movw	r30, r12
    38be:	86 81       	ldd	r24, Z+6	; 0x06
    38c0:	97 81       	ldd	r25, Z+7	; 0x07
    38c2:	02 c0       	rjmp	.+4      	; 0x38c8 <vfprintf+0x262>
    38c4:	8f ef       	ldi	r24, 0xFF	; 255
    38c6:	9f ef       	ldi	r25, 0xFF	; 255
    38c8:	2c 96       	adiw	r28, 0x0c	; 12
    38ca:	ee e0       	ldi	r30, 0x0E	; 14
    38cc:	0c 94 ca 1e 	jmp	0x3d94	; 0x3d94 <__epilogue_restores__+0x8>

000038d0 <putval>:
    38d0:	20 fd       	sbrc	r18, 0
    38d2:	09 c0       	rjmp	.+18     	; 0x38e6 <putval+0x16>
    38d4:	fc 01       	movw	r30, r24
    38d6:	23 fd       	sbrc	r18, 3
    38d8:	05 c0       	rjmp	.+10     	; 0x38e4 <putval+0x14>
    38da:	22 ff       	sbrs	r18, 2
    38dc:	02 c0       	rjmp	.+4      	; 0x38e2 <putval+0x12>
    38de:	73 83       	std	Z+3, r23	; 0x03
    38e0:	62 83       	std	Z+2, r22	; 0x02
    38e2:	51 83       	std	Z+1, r21	; 0x01
    38e4:	40 83       	st	Z, r20
    38e6:	08 95       	ret

000038e8 <mulacc>:
    38e8:	cf 92       	push	r12
    38ea:	df 92       	push	r13
    38ec:	ef 92       	push	r14
    38ee:	ff 92       	push	r15
    38f0:	6b 01       	movw	r12, r22
    38f2:	7c 01       	movw	r14, r24
    38f4:	44 fd       	sbrc	r20, 4
    38f6:	10 c0       	rjmp	.+32     	; 0x3918 <mulacc+0x30>
    38f8:	46 fd       	sbrc	r20, 6
    38fa:	10 c0       	rjmp	.+32     	; 0x391c <mulacc+0x34>
    38fc:	d6 01       	movw	r26, r12
    38fe:	f7 01       	movw	r30, r14
    3900:	aa 0f       	add	r26, r26
    3902:	bb 1f       	adc	r27, r27
    3904:	ee 1f       	adc	r30, r30
    3906:	ff 1f       	adc	r31, r31
    3908:	10 94       	com	r1
    390a:	d1 f7       	brne	.-12     	; 0x3900 <mulacc+0x18>
    390c:	ca 0e       	add	r12, r26
    390e:	db 1e       	adc	r13, r27
    3910:	ee 1e       	adc	r14, r30
    3912:	ff 1e       	adc	r15, r31
    3914:	81 e0       	ldi	r24, 0x01	; 1
    3916:	03 c0       	rjmp	.+6      	; 0x391e <mulacc+0x36>
    3918:	83 e0       	ldi	r24, 0x03	; 3
    391a:	01 c0       	rjmp	.+2      	; 0x391e <mulacc+0x36>
    391c:	84 e0       	ldi	r24, 0x04	; 4
    391e:	cc 0c       	add	r12, r12
    3920:	dd 1c       	adc	r13, r13
    3922:	ee 1c       	adc	r14, r14
    3924:	ff 1c       	adc	r15, r15
    3926:	81 50       	subi	r24, 0x01	; 1
    3928:	d1 f7       	brne	.-12     	; 0x391e <mulacc+0x36>
    392a:	c2 0e       	add	r12, r18
    392c:	d1 1c       	adc	r13, r1
    392e:	e1 1c       	adc	r14, r1
    3930:	f1 1c       	adc	r15, r1
    3932:	b6 01       	movw	r22, r12
    3934:	c7 01       	movw	r24, r14
    3936:	ff 90       	pop	r15
    3938:	ef 90       	pop	r14
    393a:	df 90       	pop	r13
    393c:	cf 90       	pop	r12
    393e:	08 95       	ret

00003940 <skip_spaces>:
    3940:	0f 93       	push	r16
    3942:	1f 93       	push	r17
    3944:	cf 93       	push	r28
    3946:	df 93       	push	r29
    3948:	8c 01       	movw	r16, r24
    394a:	c8 01       	movw	r24, r16
    394c:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <fgetc>
    3950:	ec 01       	movw	r28, r24
    3952:	97 fd       	sbrc	r25, 7
    3954:	08 c0       	rjmp	.+16     	; 0x3966 <skip_spaces+0x26>
    3956:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <isspace>
    395a:	00 97       	sbiw	r24, 0x00	; 0
    395c:	b1 f7       	brne	.-20     	; 0x394a <skip_spaces+0xa>
    395e:	ce 01       	movw	r24, r28
    3960:	b8 01       	movw	r22, r16
    3962:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <ungetc>
    3966:	ce 01       	movw	r24, r28
    3968:	df 91       	pop	r29
    396a:	cf 91       	pop	r28
    396c:	1f 91       	pop	r17
    396e:	0f 91       	pop	r16
    3970:	08 95       	ret

00003972 <conv_int>:
    3972:	a0 e0       	ldi	r26, 0x00	; 0
    3974:	b0 e0       	ldi	r27, 0x00	; 0
    3976:	ef eb       	ldi	r30, 0xBF	; 191
    3978:	fc e1       	ldi	r31, 0x1C	; 28
    397a:	0c 94 b2 1e 	jmp	0x3d64	; 0x3d64 <__prologue_saves__+0x10>
    397e:	8c 01       	movw	r16, r24
    3980:	d6 2f       	mov	r29, r22
    3982:	5a 01       	movw	r10, r20
    3984:	c2 2f       	mov	r28, r18
    3986:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <fgetc>
    398a:	8b 32       	cpi	r24, 0x2B	; 43
    398c:	19 f0       	breq	.+6      	; 0x3994 <conv_int+0x22>
    398e:	8d 32       	cpi	r24, 0x2D	; 45
    3990:	49 f4       	brne	.+18     	; 0x39a4 <conv_int+0x32>
    3992:	c0 68       	ori	r28, 0x80	; 128
    3994:	d1 50       	subi	r29, 0x01	; 1
    3996:	09 f4       	brne	.+2      	; 0x399a <conv_int+0x28>
    3998:	61 c0       	rjmp	.+194    	; 0x3a5c <conv_int+0xea>
    399a:	c8 01       	movw	r24, r16
    399c:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <fgetc>
    39a0:	97 fd       	sbrc	r25, 7
    39a2:	5c c0       	rjmp	.+184    	; 0x3a5c <conv_int+0xea>
    39a4:	cd 7f       	andi	r28, 0xFD	; 253
    39a6:	2c 2f       	mov	r18, r28
    39a8:	20 73       	andi	r18, 0x30	; 48
    39aa:	d1 f4       	brne	.+52     	; 0x39e0 <conv_int+0x6e>
    39ac:	80 33       	cpi	r24, 0x30	; 48
    39ae:	c1 f4       	brne	.+48     	; 0x39e0 <conv_int+0x6e>
    39b0:	d1 50       	subi	r29, 0x01	; 1
    39b2:	09 f4       	brne	.+2      	; 0x39b6 <conv_int+0x44>
    39b4:	3e c0       	rjmp	.+124    	; 0x3a32 <conv_int+0xc0>
    39b6:	c8 01       	movw	r24, r16
    39b8:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <fgetc>
    39bc:	97 fd       	sbrc	r25, 7
    39be:	39 c0       	rjmp	.+114    	; 0x3a32 <conv_int+0xc0>
    39c0:	c2 60       	ori	r28, 0x02	; 2
    39c2:	88 37       	cpi	r24, 0x78	; 120
    39c4:	11 f0       	breq	.+4      	; 0x39ca <conv_int+0x58>
    39c6:	88 35       	cpi	r24, 0x58	; 88
    39c8:	49 f4       	brne	.+18     	; 0x39dc <conv_int+0x6a>
    39ca:	c0 64       	ori	r28, 0x40	; 64
    39cc:	d1 50       	subi	r29, 0x01	; 1
    39ce:	89 f1       	breq	.+98     	; 0x3a32 <conv_int+0xc0>
    39d0:	c8 01       	movw	r24, r16
    39d2:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <fgetc>
    39d6:	97 ff       	sbrs	r25, 7
    39d8:	03 c0       	rjmp	.+6      	; 0x39e0 <conv_int+0x6e>
    39da:	2b c0       	rjmp	.+86     	; 0x3a32 <conv_int+0xc0>
    39dc:	c6 ff       	sbrs	r28, 6
    39de:	c0 61       	ori	r28, 0x10	; 16
    39e0:	cc 24       	eor	r12, r12
    39e2:	dd 24       	eor	r13, r13
    39e4:	76 01       	movw	r14, r12
    39e6:	28 2f       	mov	r18, r24
    39e8:	20 53       	subi	r18, 0x30	; 48
    39ea:	28 30       	cpi	r18, 0x08	; 8
    39ec:	80 f0       	brcs	.+32     	; 0x3a0e <conv_int+0x9c>
    39ee:	c4 fd       	sbrc	r28, 4
    39f0:	09 c0       	rjmp	.+18     	; 0x3a04 <conv_int+0x92>
    39f2:	2a 30       	cpi	r18, 0x0A	; 10
    39f4:	60 f0       	brcs	.+24     	; 0x3a0e <conv_int+0x9c>
    39f6:	c6 ff       	sbrs	r28, 6
    39f8:	05 c0       	rjmp	.+10     	; 0x3a04 <conv_int+0x92>
    39fa:	2f 7d       	andi	r18, 0xDF	; 223
    39fc:	32 2f       	mov	r19, r18
    39fe:	31 51       	subi	r19, 0x11	; 17
    3a00:	36 30       	cpi	r19, 0x06	; 6
    3a02:	20 f0       	brcs	.+8      	; 0x3a0c <conv_int+0x9a>
    3a04:	b8 01       	movw	r22, r16
    3a06:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <ungetc>
    3a0a:	10 c0       	rjmp	.+32     	; 0x3a2c <conv_int+0xba>
    3a0c:	27 50       	subi	r18, 0x07	; 7
    3a0e:	c7 01       	movw	r24, r14
    3a10:	b6 01       	movw	r22, r12
    3a12:	4c 2f       	mov	r20, r28
    3a14:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <mulacc>
    3a18:	6b 01       	movw	r12, r22
    3a1a:	7c 01       	movw	r14, r24
    3a1c:	c2 60       	ori	r28, 0x02	; 2
    3a1e:	d1 50       	subi	r29, 0x01	; 1
    3a20:	59 f0       	breq	.+22     	; 0x3a38 <conv_int+0xc6>
    3a22:	c8 01       	movw	r24, r16
    3a24:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <fgetc>
    3a28:	97 ff       	sbrs	r25, 7
    3a2a:	dd cf       	rjmp	.-70     	; 0x39e6 <conv_int+0x74>
    3a2c:	c1 fd       	sbrc	r28, 1
    3a2e:	04 c0       	rjmp	.+8      	; 0x3a38 <conv_int+0xc6>
    3a30:	15 c0       	rjmp	.+42     	; 0x3a5c <conv_int+0xea>
    3a32:	cc 24       	eor	r12, r12
    3a34:	dd 24       	eor	r13, r13
    3a36:	76 01       	movw	r14, r12
    3a38:	c7 ff       	sbrs	r28, 7
    3a3a:	08 c0       	rjmp	.+16     	; 0x3a4c <conv_int+0xda>
    3a3c:	f0 94       	com	r15
    3a3e:	e0 94       	com	r14
    3a40:	d0 94       	com	r13
    3a42:	c0 94       	com	r12
    3a44:	c1 1c       	adc	r12, r1
    3a46:	d1 1c       	adc	r13, r1
    3a48:	e1 1c       	adc	r14, r1
    3a4a:	f1 1c       	adc	r15, r1
    3a4c:	c5 01       	movw	r24, r10
    3a4e:	b7 01       	movw	r22, r14
    3a50:	a6 01       	movw	r20, r12
    3a52:	2c 2f       	mov	r18, r28
    3a54:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <putval>
    3a58:	81 e0       	ldi	r24, 0x01	; 1
    3a5a:	01 c0       	rjmp	.+2      	; 0x3a5e <conv_int+0xec>
    3a5c:	80 e0       	ldi	r24, 0x00	; 0
    3a5e:	cd b7       	in	r28, 0x3d	; 61
    3a60:	de b7       	in	r29, 0x3e	; 62
    3a62:	ea e0       	ldi	r30, 0x0A	; 10
    3a64:	0c 94 ce 1e 	jmp	0x3d9c	; 0x3d9c <__epilogue_restores__+0x10>

00003a68 <vfscanf>:
    3a68:	a1 e0       	ldi	r26, 0x01	; 1
    3a6a:	b0 e0       	ldi	r27, 0x00	; 0
    3a6c:	ea e3       	ldi	r30, 0x3A	; 58
    3a6e:	fd e1       	ldi	r31, 0x1D	; 29
    3a70:	0c 94 ad 1e 	jmp	0x3d5a	; 0x3d5a <__prologue_saves__+0x6>
    3a74:	7c 01       	movw	r14, r24
    3a76:	4b 01       	movw	r8, r22
    3a78:	3a 01       	movw	r6, r20
    3a7a:	fc 01       	movw	r30, r24
    3a7c:	17 82       	std	Z+7, r1	; 0x07
    3a7e:	16 82       	std	Z+6, r1	; 0x06
    3a80:	bb 24       	eor	r11, r11
    3a82:	e3 c0       	rjmp	.+454    	; 0x3c4a <vfscanf+0x1e2>
    3a84:	81 2f       	mov	r24, r17
    3a86:	90 e0       	ldi	r25, 0x00	; 0
    3a88:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <isspace>
    3a8c:	00 97       	sbiw	r24, 0x00	; 0
    3a8e:	21 f0       	breq	.+8      	; 0x3a98 <vfscanf+0x30>
    3a90:	c7 01       	movw	r24, r14
    3a92:	0e 94 a0 1c 	call	0x3940	; 0x3940 <skip_spaces>
    3a96:	d9 c0       	rjmp	.+434    	; 0x3c4a <vfscanf+0x1e2>
    3a98:	15 32       	cpi	r17, 0x25	; 37
    3a9a:	41 f4       	brne	.+16     	; 0x3aac <vfscanf+0x44>
    3a9c:	f4 01       	movw	r30, r8
    3a9e:	03 fd       	sbrc	r16, 3
    3aa0:	35 91       	lpm	r19, Z+
    3aa2:	03 ff       	sbrs	r16, 3
    3aa4:	31 91       	ld	r19, Z+
    3aa6:	4f 01       	movw	r8, r30
    3aa8:	35 32       	cpi	r19, 0x25	; 37
    3aaa:	61 f4       	brne	.+24     	; 0x3ac4 <vfscanf+0x5c>
    3aac:	c7 01       	movw	r24, r14
    3aae:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <fgetc>
    3ab2:	97 fd       	sbrc	r25, 7
    3ab4:	d6 c0       	rjmp	.+428    	; 0x3c62 <vfscanf+0x1fa>
    3ab6:	18 17       	cp	r17, r24
    3ab8:	09 f4       	brne	.+2      	; 0x3abc <vfscanf+0x54>
    3aba:	c7 c0       	rjmp	.+398    	; 0x3c4a <vfscanf+0x1e2>
    3abc:	b7 01       	movw	r22, r14
    3abe:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <ungetc>
    3ac2:	d1 c0       	rjmp	.+418    	; 0x3c66 <vfscanf+0x1fe>
    3ac4:	3a 32       	cpi	r19, 0x2A	; 42
    3ac6:	41 f4       	brne	.+16     	; 0x3ad8 <vfscanf+0x70>
    3ac8:	03 fd       	sbrc	r16, 3
    3aca:	35 91       	lpm	r19, Z+
    3acc:	03 ff       	sbrs	r16, 3
    3ace:	31 91       	ld	r19, Z+
    3ad0:	4f 01       	movw	r8, r30
    3ad2:	aa 24       	eor	r10, r10
    3ad4:	a3 94       	inc	r10
    3ad6:	01 c0       	rjmp	.+2      	; 0x3ada <vfscanf+0x72>
    3ad8:	aa 24       	eor	r10, r10
    3ada:	55 24       	eor	r5, r5
    3adc:	10 c0       	rjmp	.+32     	; 0x3afe <vfscanf+0x96>
    3ade:	f2 e0       	ldi	r31, 0x02	; 2
    3ae0:	af 2a       	or	r10, r31
    3ae2:	65 2d       	mov	r22, r5
    3ae4:	70 e0       	ldi	r23, 0x00	; 0
    3ae6:	80 e0       	ldi	r24, 0x00	; 0
    3ae8:	90 e0       	ldi	r25, 0x00	; 0
    3aea:	40 e2       	ldi	r20, 0x20	; 32
    3aec:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <mulacc>
    3af0:	56 2e       	mov	r5, r22
    3af2:	f4 01       	movw	r30, r8
    3af4:	03 fd       	sbrc	r16, 3
    3af6:	35 91       	lpm	r19, Z+
    3af8:	03 ff       	sbrs	r16, 3
    3afa:	31 91       	ld	r19, Z+
    3afc:	4f 01       	movw	r8, r30
    3afe:	23 2f       	mov	r18, r19
    3b00:	20 53       	subi	r18, 0x30	; 48
    3b02:	2a 30       	cpi	r18, 0x0A	; 10
    3b04:	60 f3       	brcs	.-40     	; 0x3ade <vfscanf+0x76>
    3b06:	a1 fe       	sbrs	r10, 1
    3b08:	03 c0       	rjmp	.+6      	; 0x3b10 <vfscanf+0xa8>
    3b0a:	55 20       	and	r5, r5
    3b0c:	19 f4       	brne	.+6      	; 0x3b14 <vfscanf+0xac>
    3b0e:	ab c0       	rjmp	.+342    	; 0x3c66 <vfscanf+0x1fe>
    3b10:	55 24       	eor	r5, r5
    3b12:	5a 94       	dec	r5
    3b14:	38 36       	cpi	r19, 0x68	; 104
    3b16:	19 f0       	breq	.+6      	; 0x3b1e <vfscanf+0xb6>
    3b18:	3c 36       	cpi	r19, 0x6C	; 108
    3b1a:	99 f4       	brne	.+38     	; 0x3b42 <vfscanf+0xda>
    3b1c:	0a c0       	rjmp	.+20     	; 0x3b32 <vfscanf+0xca>
    3b1e:	f4 01       	movw	r30, r8
    3b20:	03 fd       	sbrc	r16, 3
    3b22:	35 91       	lpm	r19, Z+
    3b24:	03 ff       	sbrs	r16, 3
    3b26:	31 91       	ld	r19, Z+
    3b28:	4f 01       	movw	r8, r30
    3b2a:	38 36       	cpi	r19, 0x68	; 104
    3b2c:	51 f4       	brne	.+20     	; 0x3b42 <vfscanf+0xda>
    3b2e:	f8 e0       	ldi	r31, 0x08	; 8
    3b30:	af 2a       	or	r10, r31
    3b32:	44 e0       	ldi	r20, 0x04	; 4
    3b34:	a4 2a       	or	r10, r20
    3b36:	f4 01       	movw	r30, r8
    3b38:	03 fd       	sbrc	r16, 3
    3b3a:	35 91       	lpm	r19, Z+
    3b3c:	03 ff       	sbrs	r16, 3
    3b3e:	31 91       	ld	r19, Z+
    3b40:	4f 01       	movw	r8, r30
    3b42:	33 23       	and	r19, r19
    3b44:	09 f4       	brne	.+2      	; 0x3b48 <vfscanf+0xe0>
    3b46:	8f c0       	rjmp	.+286    	; 0x3c66 <vfscanf+0x1fe>
    3b48:	83 e9       	ldi	r24, 0x93	; 147
    3b4a:	90 e0       	ldi	r25, 0x00	; 0
    3b4c:	63 2f       	mov	r22, r19
    3b4e:	70 e0       	ldi	r23, 0x00	; 0
    3b50:	39 83       	std	Y+1, r19	; 0x01
    3b52:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <strchr_P>
    3b56:	39 81       	ldd	r19, Y+1	; 0x01
    3b58:	00 97       	sbiw	r24, 0x00	; 0
    3b5a:	09 f4       	brne	.+2      	; 0x3b5e <vfscanf+0xf6>
    3b5c:	84 c0       	rjmp	.+264    	; 0x3c66 <vfscanf+0x1fe>
    3b5e:	8a 2d       	mov	r24, r10
    3b60:	a0 fc       	sbrc	r10, 0
    3b62:	08 c0       	rjmp	.+16     	; 0x3b74 <vfscanf+0x10c>
    3b64:	f3 01       	movw	r30, r6
    3b66:	00 81       	ld	r16, Z
    3b68:	11 81       	ldd	r17, Z+1	; 0x01
    3b6a:	42 e0       	ldi	r20, 0x02	; 2
    3b6c:	50 e0       	ldi	r21, 0x00	; 0
    3b6e:	64 0e       	add	r6, r20
    3b70:	75 1e       	adc	r7, r21
    3b72:	02 c0       	rjmp	.+4      	; 0x3b78 <vfscanf+0x110>
    3b74:	00 e0       	ldi	r16, 0x00	; 0
    3b76:	10 e0       	ldi	r17, 0x00	; 0
    3b78:	3e 36       	cpi	r19, 0x6E	; 110
    3b7a:	51 f4       	brne	.+20     	; 0x3b90 <vfscanf+0x128>
    3b7c:	f7 01       	movw	r30, r14
    3b7e:	46 81       	ldd	r20, Z+6	; 0x06
    3b80:	57 81       	ldd	r21, Z+7	; 0x07
    3b82:	60 e0       	ldi	r22, 0x00	; 0
    3b84:	70 e0       	ldi	r23, 0x00	; 0
    3b86:	c8 01       	movw	r24, r16
    3b88:	2a 2d       	mov	r18, r10
    3b8a:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <putval>
    3b8e:	5d c0       	rjmp	.+186    	; 0x3c4a <vfscanf+0x1e2>
    3b90:	33 36       	cpi	r19, 0x63	; 99
    3b92:	91 f4       	brne	.+36     	; 0x3bb8 <vfscanf+0x150>
    3b94:	81 fd       	sbrc	r24, 1
    3b96:	02 c0       	rjmp	.+4      	; 0x3b9c <vfscanf+0x134>
    3b98:	55 24       	eor	r5, r5
    3b9a:	53 94       	inc	r5
    3b9c:	c7 01       	movw	r24, r14
    3b9e:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <fgetc>
    3ba2:	97 fd       	sbrc	r25, 7
    3ba4:	5e c0       	rjmp	.+188    	; 0x3c62 <vfscanf+0x1fa>
    3ba6:	01 15       	cp	r16, r1
    3ba8:	11 05       	cpc	r17, r1
    3baa:	19 f0       	breq	.+6      	; 0x3bb2 <vfscanf+0x14a>
    3bac:	f8 01       	movw	r30, r16
    3bae:	81 93       	st	Z+, r24
    3bb0:	8f 01       	movw	r16, r30
    3bb2:	5a 94       	dec	r5
    3bb4:	99 f7       	brne	.-26     	; 0x3b9c <vfscanf+0x134>
    3bb6:	47 c0       	rjmp	.+142    	; 0x3c46 <vfscanf+0x1de>
    3bb8:	c7 01       	movw	r24, r14
    3bba:	39 83       	std	Y+1, r19	; 0x01
    3bbc:	0e 94 a0 1c 	call	0x3940	; 0x3940 <skip_spaces>
    3bc0:	39 81       	ldd	r19, Y+1	; 0x01
    3bc2:	97 fd       	sbrc	r25, 7
    3bc4:	4e c0       	rjmp	.+156    	; 0x3c62 <vfscanf+0x1fa>
    3bc6:	3f 36       	cpi	r19, 0x6F	; 111
    3bc8:	61 f1       	breq	.+88     	; 0x3c22 <vfscanf+0x1ba>
    3bca:	30 37       	cpi	r19, 0x70	; 112
    3bcc:	28 f4       	brcc	.+10     	; 0x3bd8 <vfscanf+0x170>
    3bce:	34 36       	cpi	r19, 0x64	; 100
    3bd0:	29 f1       	breq	.+74     	; 0x3c1c <vfscanf+0x1b4>
    3bd2:	39 36       	cpi	r19, 0x69	; 105
    3bd4:	49 f5       	brne	.+82     	; 0x3c28 <vfscanf+0x1c0>
    3bd6:	2a c0       	rjmp	.+84     	; 0x3c2c <vfscanf+0x1c4>
    3bd8:	33 37       	cpi	r19, 0x73	; 115
    3bda:	19 f0       	breq	.+6      	; 0x3be2 <vfscanf+0x17a>
    3bdc:	35 37       	cpi	r19, 0x75	; 117
    3bde:	21 f5       	brne	.+72     	; 0x3c28 <vfscanf+0x1c0>
    3be0:	1d c0       	rjmp	.+58     	; 0x3c1c <vfscanf+0x1b4>
    3be2:	c7 01       	movw	r24, r14
    3be4:	0e 94 ff 1e 	call	0x3dfe	; 0x3dfe <fgetc>
    3be8:	6c 01       	movw	r12, r24
    3bea:	97 fd       	sbrc	r25, 7
    3bec:	11 c0       	rjmp	.+34     	; 0x3c10 <vfscanf+0x1a8>
    3bee:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <isspace>
    3bf2:	00 97       	sbiw	r24, 0x00	; 0
    3bf4:	29 f0       	breq	.+10     	; 0x3c00 <vfscanf+0x198>
    3bf6:	c6 01       	movw	r24, r12
    3bf8:	b7 01       	movw	r22, r14
    3bfa:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <ungetc>
    3bfe:	08 c0       	rjmp	.+16     	; 0x3c10 <vfscanf+0x1a8>
    3c00:	01 15       	cp	r16, r1
    3c02:	11 05       	cpc	r17, r1
    3c04:	19 f0       	breq	.+6      	; 0x3c0c <vfscanf+0x1a4>
    3c06:	f8 01       	movw	r30, r16
    3c08:	c1 92       	st	Z+, r12
    3c0a:	8f 01       	movw	r16, r30
    3c0c:	5a 94       	dec	r5
    3c0e:	49 f7       	brne	.-46     	; 0x3be2 <vfscanf+0x17a>
    3c10:	01 15       	cp	r16, r1
    3c12:	11 05       	cpc	r17, r1
    3c14:	c1 f0       	breq	.+48     	; 0x3c46 <vfscanf+0x1de>
    3c16:	f8 01       	movw	r30, r16
    3c18:	10 82       	st	Z, r1
    3c1a:	15 c0       	rjmp	.+42     	; 0x3c46 <vfscanf+0x1de>
    3c1c:	f0 e2       	ldi	r31, 0x20	; 32
    3c1e:	af 2a       	or	r10, r31
    3c20:	05 c0       	rjmp	.+10     	; 0x3c2c <vfscanf+0x1c4>
    3c22:	40 e1       	ldi	r20, 0x10	; 16
    3c24:	a4 2a       	or	r10, r20
    3c26:	02 c0       	rjmp	.+4      	; 0x3c2c <vfscanf+0x1c4>
    3c28:	50 e4       	ldi	r21, 0x40	; 64
    3c2a:	a5 2a       	or	r10, r21
    3c2c:	c7 01       	movw	r24, r14
    3c2e:	65 2d       	mov	r22, r5
    3c30:	a8 01       	movw	r20, r16
    3c32:	2a 2d       	mov	r18, r10
    3c34:	0e 94 b9 1c 	call	0x3972	; 0x3972 <conv_int>
    3c38:	88 23       	and	r24, r24
    3c3a:	29 f4       	brne	.+10     	; 0x3c46 <vfscanf+0x1de>
    3c3c:	f7 01       	movw	r30, r14
    3c3e:	83 81       	ldd	r24, Z+3	; 0x03
    3c40:	80 73       	andi	r24, 0x30	; 48
    3c42:	79 f4       	brne	.+30     	; 0x3c62 <vfscanf+0x1fa>
    3c44:	10 c0       	rjmp	.+32     	; 0x3c66 <vfscanf+0x1fe>
    3c46:	a0 fe       	sbrs	r10, 0
    3c48:	b3 94       	inc	r11
    3c4a:	f7 01       	movw	r30, r14
    3c4c:	03 81       	ldd	r16, Z+3	; 0x03
    3c4e:	f4 01       	movw	r30, r8
    3c50:	03 fd       	sbrc	r16, 3
    3c52:	15 91       	lpm	r17, Z+
    3c54:	03 ff       	sbrs	r16, 3
    3c56:	11 91       	ld	r17, Z+
    3c58:	4f 01       	movw	r8, r30
    3c5a:	11 23       	and	r17, r17
    3c5c:	09 f0       	breq	.+2      	; 0x3c60 <vfscanf+0x1f8>
    3c5e:	12 cf       	rjmp	.-476    	; 0x3a84 <vfscanf+0x1c>
    3c60:	02 c0       	rjmp	.+4      	; 0x3c66 <vfscanf+0x1fe>
    3c62:	bb 20       	and	r11, r11
    3c64:	19 f0       	breq	.+6      	; 0x3c6c <vfscanf+0x204>
    3c66:	8b 2d       	mov	r24, r11
    3c68:	90 e0       	ldi	r25, 0x00	; 0
    3c6a:	02 c0       	rjmp	.+4      	; 0x3c70 <vfscanf+0x208>
    3c6c:	8f ef       	ldi	r24, 0xFF	; 255
    3c6e:	9f ef       	ldi	r25, 0xFF	; 255
    3c70:	21 96       	adiw	r28, 0x01	; 1
    3c72:	ef e0       	ldi	r30, 0x0F	; 15
    3c74:	0c 94 c9 1e 	jmp	0x3d92	; 0x3d92 <__epilogue_restores__+0x6>

00003c78 <__umulhisi3>:
    3c78:	a2 9f       	mul	r26, r18
    3c7a:	b0 01       	movw	r22, r0
    3c7c:	b3 9f       	mul	r27, r19
    3c7e:	c0 01       	movw	r24, r0
    3c80:	a3 9f       	mul	r26, r19
    3c82:	01 d0       	rcall	.+2      	; 0x3c86 <__umulhisi3+0xe>
    3c84:	b2 9f       	mul	r27, r18
    3c86:	70 0d       	add	r23, r0
    3c88:	81 1d       	adc	r24, r1
    3c8a:	11 24       	eor	r1, r1
    3c8c:	91 1d       	adc	r25, r1
    3c8e:	08 95       	ret

00003c90 <__mulsi3>:
    3c90:	db 01       	movw	r26, r22
    3c92:	8f 93       	push	r24
    3c94:	9f 93       	push	r25
    3c96:	0e 94 e1 1e 	call	0x3dc2	; 0x3dc2 <__muluhisi3>
    3c9a:	bf 91       	pop	r27
    3c9c:	af 91       	pop	r26
    3c9e:	a2 9f       	mul	r26, r18
    3ca0:	80 0d       	add	r24, r0
    3ca2:	91 1d       	adc	r25, r1
    3ca4:	a3 9f       	mul	r26, r19
    3ca6:	90 0d       	add	r25, r0
    3ca8:	b2 9f       	mul	r27, r18
    3caa:	90 0d       	add	r25, r0
    3cac:	11 24       	eor	r1, r1
    3cae:	08 95       	ret

00003cb0 <__udivmodhi4>:
    3cb0:	aa 1b       	sub	r26, r26
    3cb2:	bb 1b       	sub	r27, r27
    3cb4:	51 e1       	ldi	r21, 0x11	; 17
    3cb6:	07 c0       	rjmp	.+14     	; 0x3cc6 <__udivmodhi4_ep>

00003cb8 <__udivmodhi4_loop>:
    3cb8:	aa 1f       	adc	r26, r26
    3cba:	bb 1f       	adc	r27, r27
    3cbc:	a6 17       	cp	r26, r22
    3cbe:	b7 07       	cpc	r27, r23
    3cc0:	10 f0       	brcs	.+4      	; 0x3cc6 <__udivmodhi4_ep>
    3cc2:	a6 1b       	sub	r26, r22
    3cc4:	b7 0b       	sbc	r27, r23

00003cc6 <__udivmodhi4_ep>:
    3cc6:	88 1f       	adc	r24, r24
    3cc8:	99 1f       	adc	r25, r25
    3cca:	5a 95       	dec	r21
    3ccc:	a9 f7       	brne	.-22     	; 0x3cb8 <__udivmodhi4_loop>
    3cce:	80 95       	com	r24
    3cd0:	90 95       	com	r25
    3cd2:	bc 01       	movw	r22, r24
    3cd4:	cd 01       	movw	r24, r26
    3cd6:	08 95       	ret

00003cd8 <__udivmodsi4>:
    3cd8:	a1 e2       	ldi	r26, 0x21	; 33
    3cda:	1a 2e       	mov	r1, r26
    3cdc:	aa 1b       	sub	r26, r26
    3cde:	bb 1b       	sub	r27, r27
    3ce0:	fd 01       	movw	r30, r26
    3ce2:	0d c0       	rjmp	.+26     	; 0x3cfe <__udivmodsi4_ep>

00003ce4 <__udivmodsi4_loop>:
    3ce4:	aa 1f       	adc	r26, r26
    3ce6:	bb 1f       	adc	r27, r27
    3ce8:	ee 1f       	adc	r30, r30
    3cea:	ff 1f       	adc	r31, r31
    3cec:	a2 17       	cp	r26, r18
    3cee:	b3 07       	cpc	r27, r19
    3cf0:	e4 07       	cpc	r30, r20
    3cf2:	f5 07       	cpc	r31, r21
    3cf4:	20 f0       	brcs	.+8      	; 0x3cfe <__udivmodsi4_ep>
    3cf6:	a2 1b       	sub	r26, r18
    3cf8:	b3 0b       	sbc	r27, r19
    3cfa:	e4 0b       	sbc	r30, r20
    3cfc:	f5 0b       	sbc	r31, r21

00003cfe <__udivmodsi4_ep>:
    3cfe:	66 1f       	adc	r22, r22
    3d00:	77 1f       	adc	r23, r23
    3d02:	88 1f       	adc	r24, r24
    3d04:	99 1f       	adc	r25, r25
    3d06:	1a 94       	dec	r1
    3d08:	69 f7       	brne	.-38     	; 0x3ce4 <__udivmodsi4_loop>
    3d0a:	60 95       	com	r22
    3d0c:	70 95       	com	r23
    3d0e:	80 95       	com	r24
    3d10:	90 95       	com	r25
    3d12:	9b 01       	movw	r18, r22
    3d14:	ac 01       	movw	r20, r24
    3d16:	bd 01       	movw	r22, r26
    3d18:	cf 01       	movw	r24, r30
    3d1a:	08 95       	ret

00003d1c <__divmodsi4>:
    3d1c:	05 2e       	mov	r0, r21
    3d1e:	97 fb       	bst	r25, 7
    3d20:	16 f4       	brtc	.+4      	; 0x3d26 <__divmodsi4+0xa>
    3d22:	00 94       	com	r0
    3d24:	07 d0       	rcall	.+14     	; 0x3d34 <__divmodsi4_neg1>
    3d26:	57 fd       	sbrc	r21, 7
    3d28:	0d d0       	rcall	.+26     	; 0x3d44 <__divmodsi4_neg2>
    3d2a:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <__udivmodsi4>
    3d2e:	07 fc       	sbrc	r0, 7
    3d30:	09 d0       	rcall	.+18     	; 0x3d44 <__divmodsi4_neg2>
    3d32:	7e f4       	brtc	.+30     	; 0x3d52 <__divmodsi4_exit>

00003d34 <__divmodsi4_neg1>:
    3d34:	90 95       	com	r25
    3d36:	80 95       	com	r24
    3d38:	70 95       	com	r23
    3d3a:	61 95       	neg	r22
    3d3c:	7f 4f       	sbci	r23, 0xFF	; 255
    3d3e:	8f 4f       	sbci	r24, 0xFF	; 255
    3d40:	9f 4f       	sbci	r25, 0xFF	; 255
    3d42:	08 95       	ret

00003d44 <__divmodsi4_neg2>:
    3d44:	50 95       	com	r21
    3d46:	40 95       	com	r20
    3d48:	30 95       	com	r19
    3d4a:	21 95       	neg	r18
    3d4c:	3f 4f       	sbci	r19, 0xFF	; 255
    3d4e:	4f 4f       	sbci	r20, 0xFF	; 255
    3d50:	5f 4f       	sbci	r21, 0xFF	; 255

00003d52 <__divmodsi4_exit>:
    3d52:	08 95       	ret

00003d54 <__prologue_saves__>:
    3d54:	2f 92       	push	r2
    3d56:	3f 92       	push	r3
    3d58:	4f 92       	push	r4
    3d5a:	5f 92       	push	r5
    3d5c:	6f 92       	push	r6
    3d5e:	7f 92       	push	r7
    3d60:	8f 92       	push	r8
    3d62:	9f 92       	push	r9
    3d64:	af 92       	push	r10
    3d66:	bf 92       	push	r11
    3d68:	cf 92       	push	r12
    3d6a:	df 92       	push	r13
    3d6c:	ef 92       	push	r14
    3d6e:	ff 92       	push	r15
    3d70:	0f 93       	push	r16
    3d72:	1f 93       	push	r17
    3d74:	cf 93       	push	r28
    3d76:	df 93       	push	r29
    3d78:	cd b7       	in	r28, 0x3d	; 61
    3d7a:	de b7       	in	r29, 0x3e	; 62
    3d7c:	ca 1b       	sub	r28, r26
    3d7e:	db 0b       	sbc	r29, r27
    3d80:	0f b6       	in	r0, 0x3f	; 63
    3d82:	f8 94       	cli
    3d84:	de bf       	out	0x3e, r29	; 62
    3d86:	0f be       	out	0x3f, r0	; 63
    3d88:	cd bf       	out	0x3d, r28	; 61
    3d8a:	09 94       	ijmp

00003d8c <__epilogue_restores__>:
    3d8c:	2a 88       	ldd	r2, Y+18	; 0x12
    3d8e:	39 88       	ldd	r3, Y+17	; 0x11
    3d90:	48 88       	ldd	r4, Y+16	; 0x10
    3d92:	5f 84       	ldd	r5, Y+15	; 0x0f
    3d94:	6e 84       	ldd	r6, Y+14	; 0x0e
    3d96:	7d 84       	ldd	r7, Y+13	; 0x0d
    3d98:	8c 84       	ldd	r8, Y+12	; 0x0c
    3d9a:	9b 84       	ldd	r9, Y+11	; 0x0b
    3d9c:	aa 84       	ldd	r10, Y+10	; 0x0a
    3d9e:	b9 84       	ldd	r11, Y+9	; 0x09
    3da0:	c8 84       	ldd	r12, Y+8	; 0x08
    3da2:	df 80       	ldd	r13, Y+7	; 0x07
    3da4:	ee 80       	ldd	r14, Y+6	; 0x06
    3da6:	fd 80       	ldd	r15, Y+5	; 0x05
    3da8:	0c 81       	ldd	r16, Y+4	; 0x04
    3daa:	1b 81       	ldd	r17, Y+3	; 0x03
    3dac:	aa 81       	ldd	r26, Y+2	; 0x02
    3dae:	b9 81       	ldd	r27, Y+1	; 0x01
    3db0:	ce 0f       	add	r28, r30
    3db2:	d1 1d       	adc	r29, r1
    3db4:	0f b6       	in	r0, 0x3f	; 63
    3db6:	f8 94       	cli
    3db8:	de bf       	out	0x3e, r29	; 62
    3dba:	0f be       	out	0x3f, r0	; 63
    3dbc:	cd bf       	out	0x3d, r28	; 61
    3dbe:	ed 01       	movw	r28, r26
    3dc0:	08 95       	ret

00003dc2 <__muluhisi3>:
    3dc2:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <__umulhisi3>
    3dc6:	a5 9f       	mul	r26, r21
    3dc8:	90 0d       	add	r25, r0
    3dca:	b4 9f       	mul	r27, r20
    3dcc:	90 0d       	add	r25, r0
    3dce:	a4 9f       	mul	r26, r20
    3dd0:	80 0d       	add	r24, r0
    3dd2:	91 1d       	adc	r25, r1
    3dd4:	11 24       	eor	r1, r1
    3dd6:	08 95       	ret

00003dd8 <isspace>:
    3dd8:	91 11       	cpse	r25, r1
    3dda:	f8 c0       	rjmp	.+496    	; 0x3fcc <__ctype_isfalse>
    3ddc:	80 32       	cpi	r24, 0x20	; 32
    3dde:	19 f0       	breq	.+6      	; 0x3de6 <isspace+0xe>
    3de0:	89 50       	subi	r24, 0x09	; 9
    3de2:	85 50       	subi	r24, 0x05	; 5
    3de4:	d0 f7       	brcc	.-12     	; 0x3dda <isspace+0x2>
    3de6:	08 95       	ret

00003de8 <strchr_P>:
    3de8:	fc 01       	movw	r30, r24
    3dea:	05 90       	lpm	r0, Z+
    3dec:	06 16       	cp	r0, r22
    3dee:	21 f0       	breq	.+8      	; 0x3df8 <strchr_P+0x10>
    3df0:	00 20       	and	r0, r0
    3df2:	d9 f7       	brne	.-10     	; 0x3dea <strchr_P+0x2>
    3df4:	c0 01       	movw	r24, r0
    3df6:	08 95       	ret
    3df8:	31 97       	sbiw	r30, 0x01	; 1
    3dfa:	cf 01       	movw	r24, r30
    3dfc:	08 95       	ret

00003dfe <fgetc>:
    3dfe:	cf 93       	push	r28
    3e00:	df 93       	push	r29
    3e02:	ec 01       	movw	r28, r24
    3e04:	2b 81       	ldd	r18, Y+3	; 0x03
    3e06:	20 ff       	sbrs	r18, 0
    3e08:	35 c0       	rjmp	.+106    	; 0x3e74 <fgetc+0x76>
    3e0a:	26 ff       	sbrs	r18, 6
    3e0c:	09 c0       	rjmp	.+18     	; 0x3e20 <fgetc+0x22>
    3e0e:	2f 7b       	andi	r18, 0xBF	; 191
    3e10:	2b 83       	std	Y+3, r18	; 0x03
    3e12:	8e 81       	ldd	r24, Y+6	; 0x06
    3e14:	9f 81       	ldd	r25, Y+7	; 0x07
    3e16:	01 96       	adiw	r24, 0x01	; 1
    3e18:	9f 83       	std	Y+7, r25	; 0x07
    3e1a:	8e 83       	std	Y+6, r24	; 0x06
    3e1c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e1e:	28 c0       	rjmp	.+80     	; 0x3e70 <fgetc+0x72>
    3e20:	22 ff       	sbrs	r18, 2
    3e22:	0f c0       	rjmp	.+30     	; 0x3e42 <fgetc+0x44>
    3e24:	e8 81       	ld	r30, Y
    3e26:	f9 81       	ldd	r31, Y+1	; 0x01
    3e28:	80 81       	ld	r24, Z
    3e2a:	99 27       	eor	r25, r25
    3e2c:	87 fd       	sbrc	r24, 7
    3e2e:	90 95       	com	r25
    3e30:	00 97       	sbiw	r24, 0x00	; 0
    3e32:	19 f4       	brne	.+6      	; 0x3e3a <fgetc+0x3c>
    3e34:	20 62       	ori	r18, 0x20	; 32
    3e36:	2b 83       	std	Y+3, r18	; 0x03
    3e38:	1d c0       	rjmp	.+58     	; 0x3e74 <fgetc+0x76>
    3e3a:	31 96       	adiw	r30, 0x01	; 1
    3e3c:	f9 83       	std	Y+1, r31	; 0x01
    3e3e:	e8 83       	st	Y, r30
    3e40:	11 c0       	rjmp	.+34     	; 0x3e64 <fgetc+0x66>
    3e42:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e44:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e46:	ce 01       	movw	r24, r28
    3e48:	09 95       	icall
    3e4a:	97 ff       	sbrs	r25, 7
    3e4c:	0b c0       	rjmp	.+22     	; 0x3e64 <fgetc+0x66>
    3e4e:	2b 81       	ldd	r18, Y+3	; 0x03
    3e50:	3f ef       	ldi	r19, 0xFF	; 255
    3e52:	8f 3f       	cpi	r24, 0xFF	; 255
    3e54:	93 07       	cpc	r25, r19
    3e56:	11 f4       	brne	.+4      	; 0x3e5c <fgetc+0x5e>
    3e58:	80 e1       	ldi	r24, 0x10	; 16
    3e5a:	01 c0       	rjmp	.+2      	; 0x3e5e <fgetc+0x60>
    3e5c:	80 e2       	ldi	r24, 0x20	; 32
    3e5e:	82 2b       	or	r24, r18
    3e60:	8b 83       	std	Y+3, r24	; 0x03
    3e62:	08 c0       	rjmp	.+16     	; 0x3e74 <fgetc+0x76>
    3e64:	2e 81       	ldd	r18, Y+6	; 0x06
    3e66:	3f 81       	ldd	r19, Y+7	; 0x07
    3e68:	2f 5f       	subi	r18, 0xFF	; 255
    3e6a:	3f 4f       	sbci	r19, 0xFF	; 255
    3e6c:	3f 83       	std	Y+7, r19	; 0x07
    3e6e:	2e 83       	std	Y+6, r18	; 0x06
    3e70:	90 e0       	ldi	r25, 0x00	; 0
    3e72:	02 c0       	rjmp	.+4      	; 0x3e78 <fgetc+0x7a>
    3e74:	8f ef       	ldi	r24, 0xFF	; 255
    3e76:	9f ef       	ldi	r25, 0xFF	; 255
    3e78:	df 91       	pop	r29
    3e7a:	cf 91       	pop	r28
    3e7c:	08 95       	ret

00003e7e <fputc>:
    3e7e:	0f 93       	push	r16
    3e80:	1f 93       	push	r17
    3e82:	cf 93       	push	r28
    3e84:	df 93       	push	r29
    3e86:	8c 01       	movw	r16, r24
    3e88:	eb 01       	movw	r28, r22
    3e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e8c:	81 ff       	sbrs	r24, 1
    3e8e:	1b c0       	rjmp	.+54     	; 0x3ec6 <fputc+0x48>
    3e90:	82 ff       	sbrs	r24, 2
    3e92:	0d c0       	rjmp	.+26     	; 0x3eae <fputc+0x30>
    3e94:	2e 81       	ldd	r18, Y+6	; 0x06
    3e96:	3f 81       	ldd	r19, Y+7	; 0x07
    3e98:	8c 81       	ldd	r24, Y+4	; 0x04
    3e9a:	9d 81       	ldd	r25, Y+5	; 0x05
    3e9c:	28 17       	cp	r18, r24
    3e9e:	39 07       	cpc	r19, r25
    3ea0:	64 f4       	brge	.+24     	; 0x3eba <fputc+0x3c>
    3ea2:	e8 81       	ld	r30, Y
    3ea4:	f9 81       	ldd	r31, Y+1	; 0x01
    3ea6:	01 93       	st	Z+, r16
    3ea8:	f9 83       	std	Y+1, r31	; 0x01
    3eaa:	e8 83       	st	Y, r30
    3eac:	06 c0       	rjmp	.+12     	; 0x3eba <fputc+0x3c>
    3eae:	e8 85       	ldd	r30, Y+8	; 0x08
    3eb0:	f9 85       	ldd	r31, Y+9	; 0x09
    3eb2:	80 2f       	mov	r24, r16
    3eb4:	09 95       	icall
    3eb6:	00 97       	sbiw	r24, 0x00	; 0
    3eb8:	31 f4       	brne	.+12     	; 0x3ec6 <fputc+0x48>
    3eba:	8e 81       	ldd	r24, Y+6	; 0x06
    3ebc:	9f 81       	ldd	r25, Y+7	; 0x07
    3ebe:	01 96       	adiw	r24, 0x01	; 1
    3ec0:	9f 83       	std	Y+7, r25	; 0x07
    3ec2:	8e 83       	std	Y+6, r24	; 0x06
    3ec4:	02 c0       	rjmp	.+4      	; 0x3eca <fputc+0x4c>
    3ec6:	0f ef       	ldi	r16, 0xFF	; 255
    3ec8:	1f ef       	ldi	r17, 0xFF	; 255
    3eca:	c8 01       	movw	r24, r16
    3ecc:	df 91       	pop	r29
    3ece:	cf 91       	pop	r28
    3ed0:	1f 91       	pop	r17
    3ed2:	0f 91       	pop	r16
    3ed4:	08 95       	ret

00003ed6 <ungetc>:
    3ed6:	fb 01       	movw	r30, r22
    3ed8:	23 81       	ldd	r18, Z+3	; 0x03
    3eda:	20 ff       	sbrs	r18, 0
    3edc:	13 c0       	rjmp	.+38     	; 0x3f04 <ungetc+0x2e>
    3ede:	26 fd       	sbrc	r18, 6
    3ee0:	11 c0       	rjmp	.+34     	; 0x3f04 <ungetc+0x2e>
    3ee2:	3f ef       	ldi	r19, 0xFF	; 255
    3ee4:	8f 3f       	cpi	r24, 0xFF	; 255
    3ee6:	93 07       	cpc	r25, r19
    3ee8:	81 f0       	breq	.+32     	; 0x3f0a <ungetc+0x34>
    3eea:	82 83       	std	Z+2, r24	; 0x02
    3eec:	92 2f       	mov	r25, r18
    3eee:	90 64       	ori	r25, 0x40	; 64
    3ef0:	9f 7d       	andi	r25, 0xDF	; 223
    3ef2:	93 83       	std	Z+3, r25	; 0x03
    3ef4:	26 81       	ldd	r18, Z+6	; 0x06
    3ef6:	37 81       	ldd	r19, Z+7	; 0x07
    3ef8:	21 50       	subi	r18, 0x01	; 1
    3efa:	30 40       	sbci	r19, 0x00	; 0
    3efc:	37 83       	std	Z+7, r19	; 0x07
    3efe:	26 83       	std	Z+6, r18	; 0x06
    3f00:	90 e0       	ldi	r25, 0x00	; 0
    3f02:	08 95       	ret
    3f04:	8f ef       	ldi	r24, 0xFF	; 255
    3f06:	9f ef       	ldi	r25, 0xFF	; 255
    3f08:	08 95       	ret
    3f0a:	8f ef       	ldi	r24, 0xFF	; 255
    3f0c:	9f ef       	ldi	r25, 0xFF	; 255
    3f0e:	08 95       	ret

00003f10 <__ultoa_invert>:
    3f10:	fa 01       	movw	r30, r20
    3f12:	aa 27       	eor	r26, r26
    3f14:	28 30       	cpi	r18, 0x08	; 8
    3f16:	51 f1       	breq	.+84     	; 0x3f6c <__ultoa_invert+0x5c>
    3f18:	20 31       	cpi	r18, 0x10	; 16
    3f1a:	81 f1       	breq	.+96     	; 0x3f7c <__ultoa_invert+0x6c>
    3f1c:	e8 94       	clt
    3f1e:	6f 93       	push	r22
    3f20:	6e 7f       	andi	r22, 0xFE	; 254
    3f22:	6e 5f       	subi	r22, 0xFE	; 254
    3f24:	7f 4f       	sbci	r23, 0xFF	; 255
    3f26:	8f 4f       	sbci	r24, 0xFF	; 255
    3f28:	9f 4f       	sbci	r25, 0xFF	; 255
    3f2a:	af 4f       	sbci	r26, 0xFF	; 255
    3f2c:	b1 e0       	ldi	r27, 0x01	; 1
    3f2e:	3e d0       	rcall	.+124    	; 0x3fac <__ultoa_invert+0x9c>
    3f30:	b4 e0       	ldi	r27, 0x04	; 4
    3f32:	3c d0       	rcall	.+120    	; 0x3fac <__ultoa_invert+0x9c>
    3f34:	67 0f       	add	r22, r23
    3f36:	78 1f       	adc	r23, r24
    3f38:	89 1f       	adc	r24, r25
    3f3a:	9a 1f       	adc	r25, r26
    3f3c:	a1 1d       	adc	r26, r1
    3f3e:	68 0f       	add	r22, r24
    3f40:	79 1f       	adc	r23, r25
    3f42:	8a 1f       	adc	r24, r26
    3f44:	91 1d       	adc	r25, r1
    3f46:	a1 1d       	adc	r26, r1
    3f48:	6a 0f       	add	r22, r26
    3f4a:	71 1d       	adc	r23, r1
    3f4c:	81 1d       	adc	r24, r1
    3f4e:	91 1d       	adc	r25, r1
    3f50:	a1 1d       	adc	r26, r1
    3f52:	20 d0       	rcall	.+64     	; 0x3f94 <__ultoa_invert+0x84>
    3f54:	09 f4       	brne	.+2      	; 0x3f58 <__ultoa_invert+0x48>
    3f56:	68 94       	set
    3f58:	3f 91       	pop	r19
    3f5a:	2a e0       	ldi	r18, 0x0A	; 10
    3f5c:	26 9f       	mul	r18, r22
    3f5e:	11 24       	eor	r1, r1
    3f60:	30 19       	sub	r19, r0
    3f62:	30 5d       	subi	r19, 0xD0	; 208
    3f64:	31 93       	st	Z+, r19
    3f66:	de f6       	brtc	.-74     	; 0x3f1e <__ultoa_invert+0xe>
    3f68:	cf 01       	movw	r24, r30
    3f6a:	08 95       	ret
    3f6c:	46 2f       	mov	r20, r22
    3f6e:	47 70       	andi	r20, 0x07	; 7
    3f70:	40 5d       	subi	r20, 0xD0	; 208
    3f72:	41 93       	st	Z+, r20
    3f74:	b3 e0       	ldi	r27, 0x03	; 3
    3f76:	0f d0       	rcall	.+30     	; 0x3f96 <__ultoa_invert+0x86>
    3f78:	c9 f7       	brne	.-14     	; 0x3f6c <__ultoa_invert+0x5c>
    3f7a:	f6 cf       	rjmp	.-20     	; 0x3f68 <__ultoa_invert+0x58>
    3f7c:	46 2f       	mov	r20, r22
    3f7e:	4f 70       	andi	r20, 0x0F	; 15
    3f80:	40 5d       	subi	r20, 0xD0	; 208
    3f82:	4a 33       	cpi	r20, 0x3A	; 58
    3f84:	18 f0       	brcs	.+6      	; 0x3f8c <__ultoa_invert+0x7c>
    3f86:	49 5d       	subi	r20, 0xD9	; 217
    3f88:	31 fd       	sbrc	r19, 1
    3f8a:	40 52       	subi	r20, 0x20	; 32
    3f8c:	41 93       	st	Z+, r20
    3f8e:	02 d0       	rcall	.+4      	; 0x3f94 <__ultoa_invert+0x84>
    3f90:	a9 f7       	brne	.-22     	; 0x3f7c <__ultoa_invert+0x6c>
    3f92:	ea cf       	rjmp	.-44     	; 0x3f68 <__ultoa_invert+0x58>
    3f94:	b4 e0       	ldi	r27, 0x04	; 4
    3f96:	a6 95       	lsr	r26
    3f98:	97 95       	ror	r25
    3f9a:	87 95       	ror	r24
    3f9c:	77 95       	ror	r23
    3f9e:	67 95       	ror	r22
    3fa0:	ba 95       	dec	r27
    3fa2:	c9 f7       	brne	.-14     	; 0x3f96 <__ultoa_invert+0x86>
    3fa4:	00 97       	sbiw	r24, 0x00	; 0
    3fa6:	61 05       	cpc	r22, r1
    3fa8:	71 05       	cpc	r23, r1
    3faa:	08 95       	ret
    3fac:	9b 01       	movw	r18, r22
    3fae:	ac 01       	movw	r20, r24
    3fb0:	0a 2e       	mov	r0, r26
    3fb2:	06 94       	lsr	r0
    3fb4:	57 95       	ror	r21
    3fb6:	47 95       	ror	r20
    3fb8:	37 95       	ror	r19
    3fba:	27 95       	ror	r18
    3fbc:	ba 95       	dec	r27
    3fbe:	c9 f7       	brne	.-14     	; 0x3fb2 <__ultoa_invert+0xa2>
    3fc0:	62 0f       	add	r22, r18
    3fc2:	73 1f       	adc	r23, r19
    3fc4:	84 1f       	adc	r24, r20
    3fc6:	95 1f       	adc	r25, r21
    3fc8:	a0 1d       	adc	r26, r0
    3fca:	08 95       	ret

00003fcc <__ctype_isfalse>:
    3fcc:	99 27       	eor	r25, r25
    3fce:	88 27       	eor	r24, r24

00003fd0 <__ctype_istrue>:
    3fd0:	08 95       	ret

00003fd2 <_exit>:
    3fd2:	f8 94       	cli

00003fd4 <__stop_program>:
    3fd4:	ff cf       	rjmp	.-2      	; 0x3fd4 <__stop_program>
