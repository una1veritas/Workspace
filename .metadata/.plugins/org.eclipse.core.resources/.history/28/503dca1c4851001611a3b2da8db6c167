/*
 * Permutation.h
 *
 *  Created on: 2016/07/24
 *      Author: sin
 */

#ifndef PERMUTATION_H_
#define PERMUTATION_H_


class Permutator {
	const unsigned int size;
	std::vector<unsigned int> perm;

public:
	Permutation(const unsigned int n) : size(n), perm(size) {
		init();
	}

	void init(void) {
		for(unsigned int i = 0; i < size; i++)
			perm[i] = i;
	}

	const bool next(void) {
		unsigned int boundary = size - 1;
		for ( ; boundary > 0 && perm[boundary-1] > perm[boundary]; --boundary) {}
		// std::cout << "boundary = " << boundary << ", " << *this << std::endl;
		//sort
		std::sort(perm.begin()+boundary, perm.end(), [](int a, int b) { return a < b; } );
		// std::cout << "sorted: " << *this << std::endl;
		// find the next for perm[top-1]
		unsigned int larger;
		for(larger = boundary; larger < size; ++larger) {
			if ( perm[boundary-1] < perm[larger] )
				break;
		}
		if ( !(larger < size) ) {
			//std::cerr << "next error!" << std::endl;
			return false;
		}
		unsigned int t = perm[boundary-1];
		perm[boundary-1] = perm[larger];
		perm[larger] = t;
		//std::cout << *this << std::endl;
		return true;
	}

	std::string & map(std::string & str) const {
		std::string tmp(str);
		str.clear();
		for(int i = 0; i < size; i++) {
			if ( perm[i] < tmp.length() ) {
				str.push_back(tmp[perm[i]]);
			}
		}
		return str;
	}

	std::ostream & printOn(std::ostream & out) const {
		out << "(";
		for(unsigned int i = 0; i < size; i++) {
			out << perm[i];
			if ( i+1 < size )
				out << ", ";
		}
		out << ") ";
		return out;
	}

	friend std::ostream & operator<<(std::ostream & out, const Permutation & p) {
		return p.printOn(out);
	}
};



#endif /* PERMUTATION_H_ */
