
Arduino_FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000004c6  00800100  000164d4  00016568  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000164d4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000003ec  008005c6  008005c6  00016a2e  2**0
                  ALLOC
  3 .stab         0002f6f4  00000000  00000000  00016a30  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0001ca0f  00000000  00000000  00046124  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00062b33  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 77 01 	jmp	0x2ee	; 0x2ee <__ctors_end>
       4:	0c 94 94 6b 	jmp	0xd728	; 0xd728 <__vector_1>
       8:	0c 94 ca 6b 	jmp	0xd794	; 0xd794 <__vector_2>
       c:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      10:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      14:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      18:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      1c:	0c 94 8d 6a 	jmp	0xd51a	; 0xd51a <__vector_7>
      20:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      24:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      28:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      2c:	0c 94 8f 22 	jmp	0x451e	; 0x451e <__vector_11>
      30:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      34:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      38:	0c 94 f1 8b 	jmp	0x117e2	; 0x117e2 <__vector_14>
      3c:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      40:	0c 94 4c 7d 	jmp	0xfa98	; 0xfa98 <__vector_16>
      44:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      48:	0c 94 8a 53 	jmp	0xa714	; 0xa714 <__vector_18>
      4c:	0c 94 e8 53 	jmp	0xa7d0	; 0xa7d0 <__vector_19>
      50:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      54:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      58:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      5c:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      60:	0c 94 8e 03 	jmp	0x71c	; 0x71c <__vector_24>
      64:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__bad_interrupt>
      68:	cd 04       	cpc	r12, r13
      6a:	d2 04       	cpc	r13, r2
      6c:	d2 04       	cpc	r13, r2
      6e:	d2 04       	cpc	r13, r2
      70:	d2 04       	cpc	r13, r2
      72:	d2 04       	cpc	r13, r2
      74:	d2 04       	cpc	r13, r2
      76:	d2 04       	cpc	r13, r2
      78:	bf 03       	fmulsu	r19, r23
      7a:	d2 04       	cpc	r13, r2
      7c:	d2 04       	cpc	r13, r2
      7e:	d2 04       	cpc	r13, r2
      80:	d2 04       	cpc	r13, r2
      82:	d2 04       	cpc	r13, r2
      84:	d2 04       	cpc	r13, r2
      86:	d2 04       	cpc	r13, r2
      88:	bf 03       	fmulsu	r19, r23
      8a:	d2 04       	cpc	r13, r2
      8c:	d2 04       	cpc	r13, r2
      8e:	d2 04       	cpc	r13, r2
      90:	d2 04       	cpc	r13, r2
      92:	d2 04       	cpc	r13, r2
      94:	d2 04       	cpc	r13, r2
      96:	d2 04       	cpc	r13, r2
      98:	c9 03       	fmulsu	r20, r17
      9a:	d2 04       	cpc	r13, r2
      9c:	d2 04       	cpc	r13, r2
      9e:	d2 04       	cpc	r13, r2
      a0:	d2 04       	cpc	r13, r2
      a2:	d2 04       	cpc	r13, r2
      a4:	d2 04       	cpc	r13, r2
      a6:	d2 04       	cpc	r13, r2
      a8:	f5 03       	fmuls	r23, r21
      aa:	d2 04       	cpc	r13, r2
      ac:	d2 04       	cpc	r13, r2
      ae:	d2 04       	cpc	r13, r2
      b0:	d2 04       	cpc	r13, r2
      b2:	d2 04       	cpc	r13, r2
      b4:	d2 04       	cpc	r13, r2
      b6:	d2 04       	cpc	r13, r2
      b8:	c9 03       	fmulsu	r20, r17
      ba:	d2 04       	cpc	r13, r2
      bc:	d2 04       	cpc	r13, r2
      be:	d2 04       	cpc	r13, r2
      c0:	d2 04       	cpc	r13, r2
      c2:	d2 04       	cpc	r13, r2
      c4:	d2 04       	cpc	r13, r2
      c6:	d2 04       	cpc	r13, r2
      c8:	fb 03       	fmulsu	r23, r19
      ca:	d2 04       	cpc	r13, r2
      cc:	d2 04       	cpc	r13, r2
      ce:	d2 04       	cpc	r13, r2
      d0:	d2 04       	cpc	r13, r2
      d2:	d2 04       	cpc	r13, r2
      d4:	d2 04       	cpc	r13, r2
      d6:	d2 04       	cpc	r13, r2
      d8:	01 04       	cpc	r0, r1
      da:	d2 04       	cpc	r13, r2
      dc:	d2 04       	cpc	r13, r2
      de:	d2 04       	cpc	r13, r2
      e0:	d2 04       	cpc	r13, r2
      e2:	d2 04       	cpc	r13, r2
      e4:	d2 04       	cpc	r13, r2
      e6:	d2 04       	cpc	r13, r2
      e8:	17 04       	cpc	r1, r7
      ea:	d2 04       	cpc	r13, r2
      ec:	d2 04       	cpc	r13, r2
      ee:	d2 04       	cpc	r13, r2
      f0:	d2 04       	cpc	r13, r2
      f2:	d2 04       	cpc	r13, r2
      f4:	d2 04       	cpc	r13, r2
      f6:	d2 04       	cpc	r13, r2
      f8:	47 04       	cpc	r4, r7
      fa:	d2 04       	cpc	r13, r2
      fc:	d2 04       	cpc	r13, r2
      fe:	d2 04       	cpc	r13, r2
     100:	d2 04       	cpc	r13, r2
     102:	d2 04       	cpc	r13, r2
     104:	d2 04       	cpc	r13, r2
     106:	d2 04       	cpc	r13, r2
     108:	07 04       	cpc	r0, r7
     10a:	d2 04       	cpc	r13, r2
     10c:	d2 04       	cpc	r13, r2
     10e:	d2 04       	cpc	r13, r2
     110:	d2 04       	cpc	r13, r2
     112:	d2 04       	cpc	r13, r2
     114:	d2 04       	cpc	r13, r2
     116:	d2 04       	cpc	r13, r2
     118:	25 04       	cpc	r2, r5
     11a:	d2 04       	cpc	r13, r2
     11c:	d2 04       	cpc	r13, r2
     11e:	d2 04       	cpc	r13, r2
     120:	d2 04       	cpc	r13, r2
     122:	d2 04       	cpc	r13, r2
     124:	d2 04       	cpc	r13, r2
     126:	d2 04       	cpc	r13, r2
     128:	4a 04       	cpc	r4, r10
     12a:	d2 04       	cpc	r13, r2
     12c:	d2 04       	cpc	r13, r2
     12e:	d2 04       	cpc	r13, r2
     130:	d2 04       	cpc	r13, r2
     132:	d2 04       	cpc	r13, r2
     134:	d2 04       	cpc	r13, r2
     136:	d2 04       	cpc	r13, r2
     138:	4a 04       	cpc	r4, r10
     13a:	d2 04       	cpc	r13, r2
     13c:	d2 04       	cpc	r13, r2
     13e:	d2 04       	cpc	r13, r2
     140:	d2 04       	cpc	r13, r2
     142:	d2 04       	cpc	r13, r2
     144:	d2 04       	cpc	r13, r2
     146:	d2 04       	cpc	r13, r2
     148:	4a 04       	cpc	r4, r10
     14a:	d2 04       	cpc	r13, r2
     14c:	d2 04       	cpc	r13, r2
     14e:	d2 04       	cpc	r13, r2
     150:	d2 04       	cpc	r13, r2
     152:	d2 04       	cpc	r13, r2
     154:	d2 04       	cpc	r13, r2
     156:	d2 04       	cpc	r13, r2
     158:	4a 04       	cpc	r4, r10
     15a:	d2 04       	cpc	r13, r2
     15c:	d2 04       	cpc	r13, r2
     15e:	d2 04       	cpc	r13, r2
     160:	d2 04       	cpc	r13, r2
     162:	d2 04       	cpc	r13, r2
     164:	d2 04       	cpc	r13, r2
     166:	d2 04       	cpc	r13, r2
     168:	53 04       	cpc	r5, r3
     16a:	d2 04       	cpc	r13, r2
     16c:	d2 04       	cpc	r13, r2
     16e:	d2 04       	cpc	r13, r2
     170:	d2 04       	cpc	r13, r2
     172:	d2 04       	cpc	r13, r2
     174:	d2 04       	cpc	r13, r2
     176:	d2 04       	cpc	r13, r2
     178:	8f 04       	cpc	r8, r15
     17a:	d2 04       	cpc	r13, r2
     17c:	d2 04       	cpc	r13, r2
     17e:	d2 04       	cpc	r13, r2
     180:	d2 04       	cpc	r13, r2
     182:	d2 04       	cpc	r13, r2
     184:	d2 04       	cpc	r13, r2
     186:	d2 04       	cpc	r13, r2
     188:	53 04       	cpc	r5, r3
     18a:	d2 04       	cpc	r13, r2
     18c:	d2 04       	cpc	r13, r2
     18e:	d2 04       	cpc	r13, r2
     190:	d2 04       	cpc	r13, r2
     192:	d2 04       	cpc	r13, r2
     194:	d2 04       	cpc	r13, r2
     196:	d2 04       	cpc	r13, r2
     198:	8f 04       	cpc	r8, r15
     19a:	d2 04       	cpc	r13, r2
     19c:	d2 04       	cpc	r13, r2
     19e:	d2 04       	cpc	r13, r2
     1a0:	d2 04       	cpc	r13, r2
     1a2:	d2 04       	cpc	r13, r2
     1a4:	d2 04       	cpc	r13, r2
     1a6:	d2 04       	cpc	r13, r2
     1a8:	6f 04       	cpc	r6, r15
     1aa:	d2 04       	cpc	r13, r2
     1ac:	d2 04       	cpc	r13, r2
     1ae:	d2 04       	cpc	r13, r2
     1b0:	d2 04       	cpc	r13, r2
     1b2:	d2 04       	cpc	r13, r2
     1b4:	d2 04       	cpc	r13, r2
     1b6:	d2 04       	cpc	r13, r2
     1b8:	93 04       	cpc	r9, r3
     1ba:	d2 04       	cpc	r13, r2
     1bc:	d2 04       	cpc	r13, r2
     1be:	d2 04       	cpc	r13, r2
     1c0:	d2 04       	cpc	r13, r2
     1c2:	d2 04       	cpc	r13, r2
     1c4:	d2 04       	cpc	r13, r2
     1c6:	d2 04       	cpc	r13, r2
     1c8:	93 04       	cpc	r9, r3
     1ca:	d2 04       	cpc	r13, r2
     1cc:	d2 04       	cpc	r13, r2
     1ce:	d2 04       	cpc	r13, r2
     1d0:	d2 04       	cpc	r13, r2
     1d2:	d2 04       	cpc	r13, r2
     1d4:	d2 04       	cpc	r13, r2
     1d6:	d2 04       	cpc	r13, r2
     1d8:	a9 04       	cpc	r10, r9
     1da:	d2 04       	cpc	r13, r2
     1dc:	d2 04       	cpc	r13, r2
     1de:	d2 04       	cpc	r13, r2
     1e0:	d2 04       	cpc	r13, r2
     1e2:	d2 04       	cpc	r13, r2
     1e4:	d2 04       	cpc	r13, r2
     1e6:	d2 04       	cpc	r13, r2
     1e8:	c7 04       	cpc	r12, r7
     1ea:	d2 04       	cpc	r13, r2
     1ec:	d2 04       	cpc	r13, r2
     1ee:	d2 04       	cpc	r13, r2
     1f0:	d2 04       	cpc	r13, r2
     1f2:	d2 04       	cpc	r13, r2
     1f4:	d2 04       	cpc	r13, r2
     1f6:	d2 04       	cpc	r13, r2
     1f8:	c7 04       	cpc	r12, r7
     1fa:	d2 04       	cpc	r13, r2
     1fc:	d2 04       	cpc	r13, r2
     1fe:	d2 04       	cpc	r13, r2
     200:	d2 04       	cpc	r13, r2
     202:	d2 04       	cpc	r13, r2
     204:	d2 04       	cpc	r13, r2
     206:	d2 04       	cpc	r13, r2
     208:	d2 04       	cpc	r13, r2
     20a:	d2 04       	cpc	r13, r2
     20c:	d2 04       	cpc	r13, r2
     20e:	d2 04       	cpc	r13, r2
     210:	d2 04       	cpc	r13, r2
     212:	d2 04       	cpc	r13, r2
     214:	d2 04       	cpc	r13, r2
     216:	d2 04       	cpc	r13, r2
     218:	d2 04       	cpc	r13, r2
     21a:	d2 04       	cpc	r13, r2
     21c:	d2 04       	cpc	r13, r2
     21e:	d2 04       	cpc	r13, r2
     220:	d2 04       	cpc	r13, r2
     222:	d2 04       	cpc	r13, r2
     224:	d2 04       	cpc	r13, r2
     226:	d2 04       	cpc	r13, r2
     228:	d2 04       	cpc	r13, r2
     22a:	d2 04       	cpc	r13, r2
     22c:	d2 04       	cpc	r13, r2
     22e:	d2 04       	cpc	r13, r2
     230:	d2 04       	cpc	r13, r2
     232:	d2 04       	cpc	r13, r2
     234:	d2 04       	cpc	r13, r2
     236:	d2 04       	cpc	r13, r2
     238:	d2 04       	cpc	r13, r2
     23a:	d2 04       	cpc	r13, r2
     23c:	d2 04       	cpc	r13, r2
     23e:	d2 04       	cpc	r13, r2
     240:	d2 04       	cpc	r13, r2
     242:	d2 04       	cpc	r13, r2
     244:	d2 04       	cpc	r13, r2
     246:	d2 04       	cpc	r13, r2
     248:	d2 04       	cpc	r13, r2
     24a:	d2 04       	cpc	r13, r2
     24c:	d2 04       	cpc	r13, r2
     24e:	d2 04       	cpc	r13, r2
     250:	d2 04       	cpc	r13, r2
     252:	d2 04       	cpc	r13, r2
     254:	d2 04       	cpc	r13, r2
     256:	d2 04       	cpc	r13, r2
     258:	d2 04       	cpc	r13, r2

0000025a <_ZL21tone_pin_to_timer_PGM>:
     25a:	02                                                  .

0000025b <port_to_mode_PGM>:
     25b:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

00000265 <port_to_output_PGM>:
     265:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

0000026f <port_to_input_PGM>:
     26f:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

00000279 <digital_pin_to_port_PGM>:
     279:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
     289:	03 03 03 03                                         ....

0000028d <digital_pin_to_bit_mask_PGM>:
     28d:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
     29d:	04 08 10 20                                         ... 

000002a1 <digital_pin_to_timer_PGM>:
     2a1:	00 00 00 07 00 02 01 00 00 03 04 06 00 00 00 00     ................
     2b1:	00 00 00 00                                         ....

000002b5 <_ZZ5setupE3__c>:
     2b5:	44 69 65 00                                         Die.

000002b9 <_ZZL10vPrintTaskPvE3__c>:
     2b9:	43 6f 75 6e 74 3a 20 00                             Count: .

000002c1 <_ZZL10vPrintTaskPvE3__c_0>:
     2c1:	2c 20 55 6e 75 73 65 64 20 53 74 61 63 6b 3a 20     , Unused Stack: 
	...

000002d2 <__ctors_start>:
     2d2:	e6 07       	cpc	r30, r22
     2d4:	89 15       	cp	r24, r9
     2d6:	71 18       	sub	r7, r1
     2d8:	43 1c       	adc	r4, r3
     2da:	f1 1d       	adc	r31, r1
     2dc:	f6 2e       	mov	r15, r22
     2de:	02 42       	sbci	r16, 0x22	; 34
     2e0:	ce 46       	sbci	r28, 0x6E	; 110
     2e2:	10 4a       	sbci	r17, 0xA0	; 160
     2e4:	b4 4d       	sbci	r27, 0xD4	; 212
     2e6:	c8 4f       	sbci	r28, 0xF8	; 248
     2e8:	48 53       	subi	r20, 0x38	; 56
     2ea:	7c 59       	subi	r23, 0x9C	; 156
     2ec:	1e 5b       	subi	r17, 0xBE	; 190

000002ee <__ctors_end>:
     2ee:	11 24       	eor	r1, r1
     2f0:	1f be       	out	0x3f, r1	; 63
     2f2:	cf ef       	ldi	r28, 0xFF	; 255
     2f4:	d8 e0       	ldi	r29, 0x08	; 8
     2f6:	de bf       	out	0x3e, r29	; 62
     2f8:	cd bf       	out	0x3d, r28	; 61

000002fa <__do_copy_data>:
     2fa:	15 e0       	ldi	r17, 0x05	; 5
     2fc:	a0 e0       	ldi	r26, 0x00	; 0
     2fe:	b1 e0       	ldi	r27, 0x01	; 1
     300:	e4 ed       	ldi	r30, 0xD4	; 212
     302:	f4 e6       	ldi	r31, 0x64	; 100
     304:	02 c0       	rjmp	.+4      	; 0x30a <__do_copy_data+0x10>
     306:	05 90       	lpm	r0, Z+
     308:	0d 92       	st	X+, r0
     30a:	a6 3c       	cpi	r26, 0xC6	; 198
     30c:	b1 07       	cpc	r27, r17
     30e:	d9 f7       	brne	.-10     	; 0x306 <__do_copy_data+0xc>

00000310 <__do_clear_bss>:
     310:	19 e0       	ldi	r17, 0x09	; 9
     312:	a6 ec       	ldi	r26, 0xC6	; 198
     314:	b5 e0       	ldi	r27, 0x05	; 5
     316:	01 c0       	rjmp	.+2      	; 0x31a <.do_clear_bss_start>

00000318 <.do_clear_bss_loop>:
     318:	1d 92       	st	X+, r1

0000031a <.do_clear_bss_start>:
     31a:	a2 3b       	cpi	r26, 0xB2	; 178
     31c:	b1 07       	cpc	r27, r17
     31e:	e1 f7       	brne	.-8      	; 0x318 <.do_clear_bss_loop>

00000320 <__do_global_ctors>:
     320:	12 e0       	ldi	r17, 0x02	; 2
     322:	ce ee       	ldi	r28, 0xEE	; 238
     324:	d2 e0       	ldi	r29, 0x02	; 2
     326:	04 c0       	rjmp	.+8      	; 0x330 <__do_global_ctors+0x10>
     328:	22 97       	sbiw	r28, 0x02	; 2
     32a:	fe 01       	movw	r30, r28
     32c:	0e 94 ed ad 	call	0x15bda	; 0x15bda <__tablejump__>
     330:	c2 3d       	cpi	r28, 0xD2	; 210
     332:	d1 07       	cpc	r29, r17
     334:	c9 f7       	brne	.-14     	; 0x328 <__do_global_ctors+0x8>
     336:	0e 94 bf 7c 	call	0xf97e	; 0xf97e <main>
     33a:	0c 94 68 b2 	jmp	0x164d0	; 0x164d0 <_exit>

0000033e <__bad_interrupt>:
     33e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000342 <twi_init>:
 * Desc     readys twi pins and sets twi bitrate
 * Input    none
 * Output   none
 */
void twi_init(void)
{
     342:	cf 93       	push	r28
     344:	df 93       	push	r29
     346:	cd b7       	in	r28, 0x3d	; 61
     348:	de b7       	in	r29, 0x3e	; 62
  // initialize state
  twi_state = TWI_READY;
     34a:	10 92 c6 05 	sts	0x05C6, r1
  twi_sendStop = true;		// default value
     34e:	81 e0       	ldi	r24, 0x01	; 1
     350:	80 93 c8 05 	sts	0x05C8, r24
  twi_inRepStart = false;
     354:	10 92 c9 05 	sts	0x05C9, r1
  
  // activate internal pullups for twi.
  digitalWrite(SDA, 1);
     358:	80 91 56 02 	lds	r24, 0x0256
     35c:	61 e0       	ldi	r22, 0x01	; 1
     35e:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
  digitalWrite(SCL, 1);
     362:	80 91 57 02 	lds	r24, 0x0257
     366:	61 e0       	ldi	r22, 0x01	; 1
     368:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>

  // initialize twi prescaler and bit rate
  cbi(TWSR, TWPS0);
     36c:	89 eb       	ldi	r24, 0xB9	; 185
     36e:	90 e0       	ldi	r25, 0x00	; 0
     370:	29 eb       	ldi	r18, 0xB9	; 185
     372:	30 e0       	ldi	r19, 0x00	; 0
     374:	f9 01       	movw	r30, r18
     376:	20 81       	ld	r18, Z
     378:	2e 7f       	andi	r18, 0xFE	; 254
     37a:	fc 01       	movw	r30, r24
     37c:	20 83       	st	Z, r18
  cbi(TWSR, TWPS1);
     37e:	89 eb       	ldi	r24, 0xB9	; 185
     380:	90 e0       	ldi	r25, 0x00	; 0
     382:	29 eb       	ldi	r18, 0xB9	; 185
     384:	30 e0       	ldi	r19, 0x00	; 0
     386:	f9 01       	movw	r30, r18
     388:	20 81       	ld	r18, Z
     38a:	2d 7f       	andi	r18, 0xFD	; 253
     38c:	fc 01       	movw	r30, r24
     38e:	20 83       	st	Z, r18
  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;
     390:	88 eb       	ldi	r24, 0xB8	; 184
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	28 e4       	ldi	r18, 0x48	; 72
     396:	fc 01       	movw	r30, r24
     398:	20 83       	st	Z, r18
  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
  note: TWBR should be 10 or higher for master mode
  It is 72 for a 16mhz Wiring board with 100kHz TWI */

  // enable twi module, acks, and twi interrupt
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);
     39a:	8c eb       	ldi	r24, 0xBC	; 188
     39c:	90 e0       	ldi	r25, 0x00	; 0
     39e:	25 e4       	ldi	r18, 0x45	; 69
     3a0:	fc 01       	movw	r30, r24
     3a2:	20 83       	st	Z, r18
}
     3a4:	df 91       	pop	r29
     3a6:	cf 91       	pop	r28
     3a8:	08 95       	ret

000003aa <twi_setAddress>:
 * Desc     sets slave address and enables interrupt
 * Input    none
 * Output   none
 */
void twi_setAddress(uint8_t address)
{
     3aa:	cf 93       	push	r28
     3ac:	df 93       	push	r29
     3ae:	1f 92       	push	r1
     3b0:	cd b7       	in	r28, 0x3d	; 61
     3b2:	de b7       	in	r29, 0x3e	; 62
     3b4:	89 83       	std	Y+1, r24	; 0x01
  // set twi slave address (skip over TWGCE bit)
  TWAR = address << 1;
     3b6:	8a eb       	ldi	r24, 0xBA	; 186
     3b8:	90 e0       	ldi	r25, 0x00	; 0
     3ba:	29 81       	ldd	r18, Y+1	; 0x01
     3bc:	22 0f       	add	r18, r18
     3be:	fc 01       	movw	r30, r24
     3c0:	20 83       	st	Z, r18
}
     3c2:	0f 90       	pop	r0
     3c4:	df 91       	pop	r29
     3c6:	cf 91       	pop	r28
     3c8:	08 95       	ret

000003ca <twi_readFrom>:
 *          length: number of bytes to read into array
 *          sendStop: Boolean indicating whether to send a stop at the end
 * Output   number of bytes read
 */
uint8_t twi_readFrom(uint8_t address, uint8_t* data, uint8_t length, uint8_t sendStop)
{
     3ca:	cf 93       	push	r28
     3cc:	df 93       	push	r29
     3ce:	00 d0       	rcall	.+0      	; 0x3d0 <twi_readFrom+0x6>
     3d0:	00 d0       	rcall	.+0      	; 0x3d2 <twi_readFrom+0x8>
     3d2:	00 d0       	rcall	.+0      	; 0x3d4 <twi_readFrom+0xa>
     3d4:	cd b7       	in	r28, 0x3d	; 61
     3d6:	de b7       	in	r29, 0x3e	; 62
     3d8:	8a 83       	std	Y+2, r24	; 0x02
     3da:	7c 83       	std	Y+4, r23	; 0x04
     3dc:	6b 83       	std	Y+3, r22	; 0x03
     3de:	4d 83       	std	Y+5, r20	; 0x05
     3e0:	2e 83       	std	Y+6, r18	; 0x06
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < length){
     3e2:	8d 81       	ldd	r24, Y+5	; 0x05
     3e4:	81 32       	cpi	r24, 0x21	; 33
     3e6:	10 f0       	brcs	.+4      	; 0x3ec <twi_readFrom+0x22>
    return 0;
     3e8:	80 e0       	ldi	r24, 0x00	; 0
     3ea:	64 c0       	rjmp	.+200    	; 0x4b4 <twi_readFrom+0xea>
  }

  // wait until twi is ready, become master receiver
  while(TWI_READY != twi_state){
     3ec:	00 00       	nop
     3ee:	01 c0       	rjmp	.+2      	; 0x3f2 <twi_readFrom+0x28>
    continue;
     3f0:	00 00       	nop
  if(TWI_BUFFER_LENGTH < length){
    return 0;
  }

  // wait until twi is ready, become master receiver
  while(TWI_READY != twi_state){
     3f2:	80 91 c6 05 	lds	r24, 0x05C6
     3f6:	88 23       	and	r24, r24
     3f8:	d9 f7       	brne	.-10     	; 0x3f0 <twi_readFrom+0x26>
    continue;
  }
  twi_state = TWI_MRX;
     3fa:	81 e0       	ldi	r24, 0x01	; 1
     3fc:	80 93 c6 05 	sts	0x05C6, r24
  twi_sendStop = sendStop;
     400:	8e 81       	ldd	r24, Y+6	; 0x06
     402:	80 93 c8 05 	sts	0x05C8, r24
  // reset error state (0xFF.. no error occured)
  twi_error = 0xFF;
     406:	8f ef       	ldi	r24, 0xFF	; 255
     408:	80 93 33 06 	sts	0x0633, r24

  // initialize buffer iteration vars
  twi_masterBufferIndex = 0;
     40c:	10 92 ee 05 	sts	0x05EE, r1
  twi_masterBufferLength = length-1;  // This is not intuitive, read on...
     410:	8d 81       	ldd	r24, Y+5	; 0x05
     412:	81 50       	subi	r24, 0x01	; 1
     414:	80 93 ef 05 	sts	0x05EF, r24
  // Therefor we must actually set NACK when the _next_ to last byte is
  // received, causing that NACK to be sent in response to receiving the last
  // expected byte of data.

  // build sla+w, slave device address + w bit
  twi_slarw = TW_READ;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	80 93 c7 05 	sts	0x05C7, r24
  twi_slarw |= address << 1;
     41e:	8a 81       	ldd	r24, Y+2	; 0x02
     420:	88 2f       	mov	r24, r24
     422:	90 e0       	ldi	r25, 0x00	; 0
     424:	88 0f       	add	r24, r24
     426:	99 1f       	adc	r25, r25
     428:	98 2f       	mov	r25, r24
     42a:	80 91 c7 05 	lds	r24, 0x05C7
     42e:	89 2b       	or	r24, r25
     430:	80 93 c7 05 	sts	0x05C7, r24

  if (true == twi_inRepStart) {
     434:	80 91 c9 05 	lds	r24, 0x05C9
     438:	81 30       	cpi	r24, 0x01	; 1
     43a:	71 f4       	brne	.+28     	; 0x458 <twi_readFrom+0x8e>
    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
    // We need to remove ourselves from the repeated start state before we enable interrupts,
    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
    // up. Also, don't enable the START interrupt. There may be one pending from the 
    // repeated start that we sent outselves, and that would really confuse things.
    twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
     43c:	10 92 c9 05 	sts	0x05C9, r1
    TWDR = twi_slarw;
     440:	8b eb       	ldi	r24, 0xBB	; 187
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	20 91 c7 05 	lds	r18, 0x05C7
     448:	fc 01       	movw	r30, r24
     44a:	20 83       	st	Z, r18
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
     44c:	8c eb       	ldi	r24, 0xBC	; 188
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	25 ec       	ldi	r18, 0xC5	; 197
     452:	fc 01       	movw	r30, r24
     454:	20 83       	st	Z, r18
  else
    // send start condition
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);

  // wait for read operation to complete
  while(TWI_MRX == twi_state){
     456:	05 c0       	rjmp	.+10     	; 0x462 <twi_readFrom+0x98>
    TWDR = twi_slarw;
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
  }
  else
    // send start condition
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);
     458:	8c eb       	ldi	r24, 0xBC	; 188
     45a:	90 e0       	ldi	r25, 0x00	; 0
     45c:	25 ee       	ldi	r18, 0xE5	; 229
     45e:	fc 01       	movw	r30, r24
     460:	20 83       	st	Z, r18

  // wait for read operation to complete
  while(TWI_MRX == twi_state){
     462:	00 00       	nop
     464:	01 c0       	rjmp	.+2      	; 0x468 <twi_readFrom+0x9e>
    continue;
     466:	00 00       	nop
  else
    // send start condition
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);

  // wait for read operation to complete
  while(TWI_MRX == twi_state){
     468:	80 91 c6 05 	lds	r24, 0x05C6
     46c:	81 30       	cpi	r24, 0x01	; 1
     46e:	d9 f3       	breq	.-10     	; 0x466 <twi_readFrom+0x9c>
    continue;
  }

  if (twi_masterBufferIndex < length)
     470:	90 91 ee 05 	lds	r25, 0x05EE
     474:	8d 81       	ldd	r24, Y+5	; 0x05
     476:	98 17       	cp	r25, r24
     478:	18 f4       	brcc	.+6      	; 0x480 <twi_readFrom+0xb6>
    length = twi_masterBufferIndex;
     47a:	80 91 ee 05 	lds	r24, 0x05EE
     47e:	8d 83       	std	Y+5, r24	; 0x05

  // copy twi buffer to data
  for(i = 0; i < length; ++i){
     480:	19 82       	std	Y+1, r1	; 0x01
     482:	13 c0       	rjmp	.+38     	; 0x4aa <twi_readFrom+0xe0>
    data[i] = twi_masterBuffer[i];
     484:	89 81       	ldd	r24, Y+1	; 0x01
     486:	88 2f       	mov	r24, r24
     488:	90 e0       	ldi	r25, 0x00	; 0
     48a:	2b 81       	ldd	r18, Y+3	; 0x03
     48c:	3c 81       	ldd	r19, Y+4	; 0x04
     48e:	82 0f       	add	r24, r18
     490:	93 1f       	adc	r25, r19
     492:	29 81       	ldd	r18, Y+1	; 0x01
     494:	22 2f       	mov	r18, r18
     496:	30 e0       	ldi	r19, 0x00	; 0
     498:	22 53       	subi	r18, 0x32	; 50
     49a:	3a 4f       	sbci	r19, 0xFA	; 250
     49c:	f9 01       	movw	r30, r18
     49e:	20 81       	ld	r18, Z
     4a0:	fc 01       	movw	r30, r24
     4a2:	20 83       	st	Z, r18

  if (twi_masterBufferIndex < length)
    length = twi_masterBufferIndex;

  // copy twi buffer to data
  for(i = 0; i < length; ++i){
     4a4:	89 81       	ldd	r24, Y+1	; 0x01
     4a6:	8f 5f       	subi	r24, 0xFF	; 255
     4a8:	89 83       	std	Y+1, r24	; 0x01
     4aa:	99 81       	ldd	r25, Y+1	; 0x01
     4ac:	8d 81       	ldd	r24, Y+5	; 0x05
     4ae:	98 17       	cp	r25, r24
     4b0:	48 f3       	brcs	.-46     	; 0x484 <twi_readFrom+0xba>
    data[i] = twi_masterBuffer[i];
  }
	
  return length;
     4b2:	8d 81       	ldd	r24, Y+5	; 0x05
}
     4b4:	26 96       	adiw	r28, 0x06	; 6
     4b6:	0f b6       	in	r0, 0x3f	; 63
     4b8:	f8 94       	cli
     4ba:	de bf       	out	0x3e, r29	; 62
     4bc:	0f be       	out	0x3f, r0	; 63
     4be:	cd bf       	out	0x3d, r28	; 61
     4c0:	df 91       	pop	r29
     4c2:	cf 91       	pop	r28
     4c4:	08 95       	ret

000004c6 <twi_writeTo>:
 *          2 .. address send, NACK received
 *          3 .. data send, NACK received
 *          4 .. other twi error (lost bus arbitration, bus error, ..)
 */
uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
{
     4c6:	0f 93       	push	r16
     4c8:	cf 93       	push	r28
     4ca:	df 93       	push	r29
     4cc:	cd b7       	in	r28, 0x3d	; 61
     4ce:	de b7       	in	r29, 0x3e	; 62
     4d0:	27 97       	sbiw	r28, 0x07	; 7
     4d2:	0f b6       	in	r0, 0x3f	; 63
     4d4:	f8 94       	cli
     4d6:	de bf       	out	0x3e, r29	; 62
     4d8:	0f be       	out	0x3f, r0	; 63
     4da:	cd bf       	out	0x3d, r28	; 61
     4dc:	8a 83       	std	Y+2, r24	; 0x02
     4de:	7c 83       	std	Y+4, r23	; 0x04
     4e0:	6b 83       	std	Y+3, r22	; 0x03
     4e2:	4d 83       	std	Y+5, r20	; 0x05
     4e4:	2e 83       	std	Y+6, r18	; 0x06
     4e6:	0f 83       	std	Y+7, r16	; 0x07
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < length){
     4e8:	8d 81       	ldd	r24, Y+5	; 0x05
     4ea:	81 32       	cpi	r24, 0x21	; 33
     4ec:	10 f0       	brcs	.+4      	; 0x4f2 <twi_writeTo+0x2c>
    return 1;
     4ee:	81 e0       	ldi	r24, 0x01	; 1
     4f0:	6e c0       	rjmp	.+220    	; 0x5ce <twi_writeTo+0x108>
  }

  // wait until twi is ready, become master transmitter
  while(TWI_READY != twi_state){
     4f2:	00 00       	nop
     4f4:	01 c0       	rjmp	.+2      	; 0x4f8 <twi_writeTo+0x32>
    continue;
     4f6:	00 00       	nop
  if(TWI_BUFFER_LENGTH < length){
    return 1;
  }

  // wait until twi is ready, become master transmitter
  while(TWI_READY != twi_state){
     4f8:	80 91 c6 05 	lds	r24, 0x05C6
     4fc:	88 23       	and	r24, r24
     4fe:	d9 f7       	brne	.-10     	; 0x4f6 <twi_writeTo+0x30>
    continue;
  }
  twi_state = TWI_MTX;
     500:	82 e0       	ldi	r24, 0x02	; 2
     502:	80 93 c6 05 	sts	0x05C6, r24
  twi_sendStop = sendStop;
     506:	8f 81       	ldd	r24, Y+7	; 0x07
     508:	80 93 c8 05 	sts	0x05C8, r24
  // reset error state (0xFF.. no error occured)
  twi_error = 0xFF;
     50c:	8f ef       	ldi	r24, 0xFF	; 255
     50e:	80 93 33 06 	sts	0x0633, r24

  // initialize buffer iteration vars
  twi_masterBufferIndex = 0;
     512:	10 92 ee 05 	sts	0x05EE, r1
  twi_masterBufferLength = length;
     516:	8d 81       	ldd	r24, Y+5	; 0x05
     518:	80 93 ef 05 	sts	0x05EF, r24
  
  // copy data to twi buffer
  for(i = 0; i < length; ++i){
     51c:	19 82       	std	Y+1, r1	; 0x01
     51e:	13 c0       	rjmp	.+38     	; 0x546 <twi_writeTo+0x80>
    twi_masterBuffer[i] = data[i];
     520:	89 81       	ldd	r24, Y+1	; 0x01
     522:	88 2f       	mov	r24, r24
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	29 81       	ldd	r18, Y+1	; 0x01
     528:	22 2f       	mov	r18, r18
     52a:	30 e0       	ldi	r19, 0x00	; 0
     52c:	4b 81       	ldd	r20, Y+3	; 0x03
     52e:	5c 81       	ldd	r21, Y+4	; 0x04
     530:	24 0f       	add	r18, r20
     532:	35 1f       	adc	r19, r21
     534:	f9 01       	movw	r30, r18
     536:	20 81       	ld	r18, Z
     538:	82 53       	subi	r24, 0x32	; 50
     53a:	9a 4f       	sbci	r25, 0xFA	; 250
     53c:	fc 01       	movw	r30, r24
     53e:	20 83       	st	Z, r18
  // initialize buffer iteration vars
  twi_masterBufferIndex = 0;
  twi_masterBufferLength = length;
  
  // copy data to twi buffer
  for(i = 0; i < length; ++i){
     540:	89 81       	ldd	r24, Y+1	; 0x01
     542:	8f 5f       	subi	r24, 0xFF	; 255
     544:	89 83       	std	Y+1, r24	; 0x01
     546:	99 81       	ldd	r25, Y+1	; 0x01
     548:	8d 81       	ldd	r24, Y+5	; 0x05
     54a:	98 17       	cp	r25, r24
     54c:	48 f3       	brcs	.-46     	; 0x520 <twi_writeTo+0x5a>
    twi_masterBuffer[i] = data[i];
  }
  
  // build sla+w, slave device address + w bit
  twi_slarw = TW_WRITE;
     54e:	10 92 c7 05 	sts	0x05C7, r1
  twi_slarw |= address << 1;
     552:	8a 81       	ldd	r24, Y+2	; 0x02
     554:	88 2f       	mov	r24, r24
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	88 0f       	add	r24, r24
     55a:	99 1f       	adc	r25, r25
     55c:	98 2f       	mov	r25, r24
     55e:	80 91 c7 05 	lds	r24, 0x05C7
     562:	89 2b       	or	r24, r25
     564:	80 93 c7 05 	sts	0x05C7, r24
  
  // if we're in a repeated start, then we've already sent the START
  // in the ISR. Don't do it again.
  //
  if (true == twi_inRepStart) {
     568:	80 91 c9 05 	lds	r24, 0x05C9
     56c:	81 30       	cpi	r24, 0x01	; 1
     56e:	71 f4       	brne	.+28     	; 0x58c <twi_writeTo+0xc6>
    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
    // We need to remove ourselves from the repeated start state before we enable interrupts,
    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
    // up. Also, don't enable the START interrupt. There may be one pending from the 
    // repeated start that we sent outselves, and that would really confuse things.
    twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
     570:	10 92 c9 05 	sts	0x05C9, r1
    TWDR = twi_slarw;				
     574:	8b eb       	ldi	r24, 0xBB	; 187
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	20 91 c7 05 	lds	r18, 0x05C7
     57c:	fc 01       	movw	r30, r24
     57e:	20 83       	st	Z, r18
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
     580:	8c eb       	ldi	r24, 0xBC	; 188
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	25 ec       	ldi	r18, 0xC5	; 197
     586:	fc 01       	movw	r30, r24
     588:	20 83       	st	Z, r18
  else
    // send start condition
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);	// enable INTs

  // wait for write operation to complete
  while(wait && (TWI_MTX == twi_state)){
     58a:	07 c0       	rjmp	.+14     	; 0x59a <twi_writeTo+0xd4>
    TWDR = twi_slarw;				
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
  }
  else
    // send start condition
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);	// enable INTs
     58c:	8c eb       	ldi	r24, 0xBC	; 188
     58e:	90 e0       	ldi	r25, 0x00	; 0
     590:	25 ee       	ldi	r18, 0xE5	; 229
     592:	fc 01       	movw	r30, r24
     594:	20 83       	st	Z, r18

  // wait for write operation to complete
  while(wait && (TWI_MTX == twi_state)){
     596:	01 c0       	rjmp	.+2      	; 0x59a <twi_writeTo+0xd4>
    continue;
     598:	00 00       	nop
  else
    // send start condition
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);	// enable INTs

  // wait for write operation to complete
  while(wait && (TWI_MTX == twi_state)){
     59a:	8e 81       	ldd	r24, Y+6	; 0x06
     59c:	88 23       	and	r24, r24
     59e:	21 f0       	breq	.+8      	; 0x5a8 <twi_writeTo+0xe2>
     5a0:	80 91 c6 05 	lds	r24, 0x05C6
     5a4:	82 30       	cpi	r24, 0x02	; 2
     5a6:	c1 f3       	breq	.-16     	; 0x598 <twi_writeTo+0xd2>
    continue;
  }
  
  if (twi_error == 0xFF)
     5a8:	80 91 33 06 	lds	r24, 0x0633
     5ac:	8f 3f       	cpi	r24, 0xFF	; 255
     5ae:	11 f4       	brne	.+4      	; 0x5b4 <twi_writeTo+0xee>
    return 0;	// success
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	0d c0       	rjmp	.+26     	; 0x5ce <twi_writeTo+0x108>
  else if (twi_error == TW_MT_SLA_NACK)
     5b4:	80 91 33 06 	lds	r24, 0x0633
     5b8:	80 32       	cpi	r24, 0x20	; 32
     5ba:	11 f4       	brne	.+4      	; 0x5c0 <twi_writeTo+0xfa>
    return 2;	// error: address send, nack received
     5bc:	82 e0       	ldi	r24, 0x02	; 2
     5be:	07 c0       	rjmp	.+14     	; 0x5ce <twi_writeTo+0x108>
  else if (twi_error == TW_MT_DATA_NACK)
     5c0:	80 91 33 06 	lds	r24, 0x0633
     5c4:	80 33       	cpi	r24, 0x30	; 48
     5c6:	11 f4       	brne	.+4      	; 0x5cc <twi_writeTo+0x106>
    return 3;	// error: data send, nack received
     5c8:	83 e0       	ldi	r24, 0x03	; 3
     5ca:	01 c0       	rjmp	.+2      	; 0x5ce <twi_writeTo+0x108>
  else
    return 4;	// other twi error
     5cc:	84 e0       	ldi	r24, 0x04	; 4
}
     5ce:	27 96       	adiw	r28, 0x07	; 7
     5d0:	0f b6       	in	r0, 0x3f	; 63
     5d2:	f8 94       	cli
     5d4:	de bf       	out	0x3e, r29	; 62
     5d6:	0f be       	out	0x3f, r0	; 63
     5d8:	cd bf       	out	0x3d, r28	; 61
     5da:	df 91       	pop	r29
     5dc:	cf 91       	pop	r28
     5de:	0f 91       	pop	r16
     5e0:	08 95       	ret

000005e2 <twi_transmit>:
 * Output   1 length too long for buffer
 *          2 not slave transmitter
 *          0 ok
 */
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
     5e2:	cf 93       	push	r28
     5e4:	df 93       	push	r29
     5e6:	00 d0       	rcall	.+0      	; 0x5e8 <twi_transmit+0x6>
     5e8:	00 d0       	rcall	.+0      	; 0x5ea <twi_transmit+0x8>
     5ea:	cd b7       	in	r28, 0x3d	; 61
     5ec:	de b7       	in	r29, 0x3e	; 62
     5ee:	9b 83       	std	Y+3, r25	; 0x03
     5f0:	8a 83       	std	Y+2, r24	; 0x02
     5f2:	6c 83       	std	Y+4, r22	; 0x04
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < length){
     5f4:	8c 81       	ldd	r24, Y+4	; 0x04
     5f6:	81 32       	cpi	r24, 0x21	; 33
     5f8:	10 f0       	brcs	.+4      	; 0x5fe <twi_transmit+0x1c>
    return 1;
     5fa:	81 e0       	ldi	r24, 0x01	; 1
     5fc:	23 c0       	rjmp	.+70     	; 0x644 <twi_transmit+0x62>
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
     5fe:	80 91 c6 05 	lds	r24, 0x05C6
     602:	84 30       	cpi	r24, 0x04	; 4
     604:	11 f0       	breq	.+4      	; 0x60a <twi_transmit+0x28>
    return 2;
     606:	82 e0       	ldi	r24, 0x02	; 2
     608:	1d c0       	rjmp	.+58     	; 0x644 <twi_transmit+0x62>
  }
  
  // set length and copy data into tx buffer
  twi_txBufferLength = length;
     60a:	8c 81       	ldd	r24, Y+4	; 0x04
     60c:	80 93 11 06 	sts	0x0611, r24
  for(i = 0; i < length; ++i){
     610:	19 82       	std	Y+1, r1	; 0x01
     612:	13 c0       	rjmp	.+38     	; 0x63a <twi_transmit+0x58>
    twi_txBuffer[i] = data[i];
     614:	89 81       	ldd	r24, Y+1	; 0x01
     616:	88 2f       	mov	r24, r24
     618:	90 e0       	ldi	r25, 0x00	; 0
     61a:	29 81       	ldd	r18, Y+1	; 0x01
     61c:	22 2f       	mov	r18, r18
     61e:	30 e0       	ldi	r19, 0x00	; 0
     620:	4a 81       	ldd	r20, Y+2	; 0x02
     622:	5b 81       	ldd	r21, Y+3	; 0x03
     624:	24 0f       	add	r18, r20
     626:	35 1f       	adc	r19, r21
     628:	f9 01       	movw	r30, r18
     62a:	20 81       	ld	r18, Z
     62c:	80 51       	subi	r24, 0x10	; 16
     62e:	9a 4f       	sbci	r25, 0xFA	; 250
     630:	fc 01       	movw	r30, r24
     632:	20 83       	st	Z, r18
    return 2;
  }
  
  // set length and copy data into tx buffer
  twi_txBufferLength = length;
  for(i = 0; i < length; ++i){
     634:	89 81       	ldd	r24, Y+1	; 0x01
     636:	8f 5f       	subi	r24, 0xFF	; 255
     638:	89 83       	std	Y+1, r24	; 0x01
     63a:	99 81       	ldd	r25, Y+1	; 0x01
     63c:	8c 81       	ldd	r24, Y+4	; 0x04
     63e:	98 17       	cp	r25, r24
     640:	48 f3       	brcs	.-46     	; 0x614 <twi_transmit+0x32>
    twi_txBuffer[i] = data[i];
  }
  
  return 0;
     642:	80 e0       	ldi	r24, 0x00	; 0
}
     644:	0f 90       	pop	r0
     646:	0f 90       	pop	r0
     648:	0f 90       	pop	r0
     64a:	0f 90       	pop	r0
     64c:	df 91       	pop	r29
     64e:	cf 91       	pop	r28
     650:	08 95       	ret

00000652 <twi_attachSlaveRxEvent>:
 * Desc     sets function called before a slave read operation
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveRxEvent( void (*function)(uint8_t*, int) )
{
     652:	cf 93       	push	r28
     654:	df 93       	push	r29
     656:	00 d0       	rcall	.+0      	; 0x658 <twi_attachSlaveRxEvent+0x6>
     658:	cd b7       	in	r28, 0x3d	; 61
     65a:	de b7       	in	r29, 0x3e	; 62
     65c:	9a 83       	std	Y+2, r25	; 0x02
     65e:	89 83       	std	Y+1, r24	; 0x01
  twi_onSlaveReceive = function;
     660:	89 81       	ldd	r24, Y+1	; 0x01
     662:	9a 81       	ldd	r25, Y+2	; 0x02
     664:	90 93 cd 05 	sts	0x05CD, r25
     668:	80 93 cc 05 	sts	0x05CC, r24
}
     66c:	0f 90       	pop	r0
     66e:	0f 90       	pop	r0
     670:	df 91       	pop	r29
     672:	cf 91       	pop	r28
     674:	08 95       	ret

00000676 <twi_attachSlaveTxEvent>:
 * Desc     sets function called before a slave write operation
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveTxEvent( void (*function)(void) )
{
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
     67a:	00 d0       	rcall	.+0      	; 0x67c <twi_attachSlaveTxEvent+0x6>
     67c:	cd b7       	in	r28, 0x3d	; 61
     67e:	de b7       	in	r29, 0x3e	; 62
     680:	9a 83       	std	Y+2, r25	; 0x02
     682:	89 83       	std	Y+1, r24	; 0x01
  twi_onSlaveTransmit = function;
     684:	89 81       	ldd	r24, Y+1	; 0x01
     686:	9a 81       	ldd	r25, Y+2	; 0x02
     688:	90 93 cb 05 	sts	0x05CB, r25
     68c:	80 93 ca 05 	sts	0x05CA, r24
}
     690:	0f 90       	pop	r0
     692:	0f 90       	pop	r0
     694:	df 91       	pop	r29
     696:	cf 91       	pop	r28
     698:	08 95       	ret

0000069a <twi_reply>:
 * Desc     sends byte or readys receive line
 * Input    ack: byte indicating to ack or to nack
 * Output   none
 */
void twi_reply(uint8_t ack)
{
     69a:	cf 93       	push	r28
     69c:	df 93       	push	r29
     69e:	1f 92       	push	r1
     6a0:	cd b7       	in	r28, 0x3d	; 61
     6a2:	de b7       	in	r29, 0x3e	; 62
     6a4:	89 83       	std	Y+1, r24	; 0x01
  // transmit master read ready signal, with or without ack
  if(ack){
     6a6:	89 81       	ldd	r24, Y+1	; 0x01
     6a8:	88 23       	and	r24, r24
     6aa:	31 f0       	breq	.+12     	; 0x6b8 <twi_reply+0x1e>
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
     6ac:	8c eb       	ldi	r24, 0xBC	; 188
     6ae:	90 e0       	ldi	r25, 0x00	; 0
     6b0:	25 ec       	ldi	r18, 0xC5	; 197
     6b2:	fc 01       	movw	r30, r24
     6b4:	20 83       	st	Z, r18
     6b6:	05 c0       	rjmp	.+10     	; 0x6c2 <twi_reply+0x28>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
     6b8:	8c eb       	ldi	r24, 0xBC	; 188
     6ba:	90 e0       	ldi	r25, 0x00	; 0
     6bc:	25 e8       	ldi	r18, 0x85	; 133
     6be:	fc 01       	movw	r30, r24
     6c0:	20 83       	st	Z, r18
  }
}
     6c2:	0f 90       	pop	r0
     6c4:	df 91       	pop	r29
     6c6:	cf 91       	pop	r28
     6c8:	08 95       	ret

000006ca <twi_stop>:
 * Desc     relinquishes bus master status
 * Input    none
 * Output   none
 */
void twi_stop(void)
{
     6ca:	cf 93       	push	r28
     6cc:	df 93       	push	r29
     6ce:	cd b7       	in	r28, 0x3d	; 61
     6d0:	de b7       	in	r29, 0x3e	; 62
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
     6d2:	8c eb       	ldi	r24, 0xBC	; 188
     6d4:	90 e0       	ldi	r25, 0x00	; 0
     6d6:	25 ed       	ldi	r18, 0xD5	; 213
     6d8:	fc 01       	movw	r30, r24
     6da:	20 83       	st	Z, r18

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
     6dc:	00 00       	nop
     6de:	01 c0       	rjmp	.+2      	; 0x6e2 <twi_stop+0x18>
    continue;
     6e0:	00 00       	nop
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
     6e2:	8c eb       	ldi	r24, 0xBC	; 188
     6e4:	90 e0       	ldi	r25, 0x00	; 0
     6e6:	fc 01       	movw	r30, r24
     6e8:	80 81       	ld	r24, Z
     6ea:	88 2f       	mov	r24, r24
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	80 71       	andi	r24, 0x10	; 16
     6f0:	99 27       	eor	r25, r25
     6f2:	00 97       	sbiw	r24, 0x00	; 0
     6f4:	a9 f7       	brne	.-22     	; 0x6e0 <twi_stop+0x16>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
     6f6:	10 92 c6 05 	sts	0x05C6, r1
}
     6fa:	df 91       	pop	r29
     6fc:	cf 91       	pop	r28
     6fe:	08 95       	ret

00000700 <twi_releaseBus>:
 * Desc     releases bus control
 * Input    none
 * Output   none
 */
void twi_releaseBus(void)
{
     700:	cf 93       	push	r28
     702:	df 93       	push	r29
     704:	cd b7       	in	r28, 0x3d	; 61
     706:	de b7       	in	r29, 0x3e	; 62
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
     708:	8c eb       	ldi	r24, 0xBC	; 188
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	25 ec       	ldi	r18, 0xC5	; 197
     70e:	fc 01       	movw	r30, r24
     710:	20 83       	st	Z, r18

  // update twi state
  twi_state = TWI_READY;
     712:	10 92 c6 05 	sts	0x05C6, r1
}
     716:	df 91       	pop	r29
     718:	cf 91       	pop	r28
     71a:	08 95       	ret

0000071c <__vector_24>:

SIGNAL(TWI_vect)
{
     71c:	1f 92       	push	r1
     71e:	0f 92       	push	r0
     720:	00 90 5f 00 	lds	r0, 0x005F
     724:	0f 92       	push	r0
     726:	11 24       	eor	r1, r1
     728:	2f 93       	push	r18
     72a:	3f 93       	push	r19
     72c:	4f 93       	push	r20
     72e:	5f 93       	push	r21
     730:	6f 93       	push	r22
     732:	7f 93       	push	r23
     734:	8f 93       	push	r24
     736:	9f 93       	push	r25
     738:	af 93       	push	r26
     73a:	bf 93       	push	r27
     73c:	ef 93       	push	r30
     73e:	ff 93       	push	r31
     740:	cf 93       	push	r28
     742:	df 93       	push	r29
     744:	cd b7       	in	r28, 0x3d	; 61
     746:	de b7       	in	r29, 0x3e	; 62
  switch(TW_STATUS){
     748:	89 eb       	ldi	r24, 0xB9	; 185
     74a:	90 e0       	ldi	r25, 0x00	; 0
     74c:	fc 01       	movw	r30, r24
     74e:	80 81       	ld	r24, Z
     750:	88 2f       	mov	r24, r24
     752:	90 e0       	ldi	r25, 0x00	; 0
     754:	88 7f       	andi	r24, 0xF8	; 248
     756:	99 27       	eor	r25, r25
     758:	aa 27       	eor	r26, r26
     75a:	97 fd       	sbrc	r25, 7
     75c:	a0 95       	com	r26
     75e:	ba 2f       	mov	r27, r26
     760:	40 e0       	ldi	r20, 0x00	; 0
     762:	50 e0       	ldi	r21, 0x00	; 0
     764:	28 ef       	ldi	r18, 0xF8	; 248
     766:	30 e0       	ldi	r19, 0x00	; 0
     768:	84 1b       	sub	r24, r20
     76a:	95 0b       	sbc	r25, r21
     76c:	28 17       	cp	r18, r24
     76e:	39 07       	cpc	r19, r25
     770:	08 f4       	brcc	.+2      	; 0x774 <__vector_24+0x58>
     772:	18 c1       	rjmp	.+560    	; 0x9a4 <__stack+0xa5>
     774:	8c 5c       	subi	r24, 0xCC	; 204
     776:	9f 4f       	sbci	r25, 0xFF	; 255
     778:	fc 01       	movw	r30, r24
     77a:	0c 94 eb ad 	jmp	0x15bd6	; 0x15bd6 <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
     77e:	8b eb       	ldi	r24, 0xBB	; 187
     780:	90 e0       	ldi	r25, 0x00	; 0
     782:	20 91 c7 05 	lds	r18, 0x05C7
     786:	fc 01       	movw	r30, r24
     788:	20 83       	st	Z, r18
      twi_reply(1);
     78a:	81 e0       	ldi	r24, 0x01	; 1
     78c:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
      break;
     790:	09 c1       	rjmp	.+530    	; 0x9a4 <__stack+0xa5>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
     792:	90 91 ee 05 	lds	r25, 0x05EE
     796:	80 91 ef 05 	lds	r24, 0x05EF
     79a:	98 17       	cp	r25, r24
     79c:	a0 f4       	brcc	.+40     	; 0x7c6 <__vector_24+0xaa>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
     79e:	8b eb       	ldi	r24, 0xBB	; 187
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	40 91 ee 05 	lds	r20, 0x05EE
     7a6:	24 2f       	mov	r18, r20
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	22 53       	subi	r18, 0x32	; 50
     7ac:	3a 4f       	sbci	r19, 0xFA	; 250
     7ae:	f9 01       	movw	r30, r18
     7b0:	20 81       	ld	r18, Z
     7b2:	fc 01       	movw	r30, r24
     7b4:	20 83       	st	Z, r18
     7b6:	84 2f       	mov	r24, r20
     7b8:	8f 5f       	subi	r24, 0xFF	; 255
     7ba:	80 93 ee 05 	sts	0x05EE, r24
        twi_reply(1);
     7be:	81 e0       	ldi	r24, 0x01	; 1
     7c0:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
	  twi_state = TWI_READY;
	}
      }
      break;
     7c4:	ef c0       	rjmp	.+478    	; 0x9a4 <__stack+0xa5>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
     7c6:	80 91 c8 05 	lds	r24, 0x05C8
     7ca:	88 23       	and	r24, r24
     7cc:	19 f0       	breq	.+6      	; 0x7d4 <__vector_24+0xb8>
          twi_stop();
     7ce:	0e 94 65 03 	call	0x6ca	; 0x6ca <twi_stop>
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
	  twi_state = TWI_READY;
	}
      }
      break;
     7d2:	e8 c0       	rjmp	.+464    	; 0x9a4 <__stack+0xa5>
        twi_reply(1);
      }else{
	if (twi_sendStop)
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
     7d4:	81 e0       	ldi	r24, 0x01	; 1
     7d6:	80 93 c9 05 	sts	0x05C9, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
     7da:	8c eb       	ldi	r24, 0xBC	; 188
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	24 ea       	ldi	r18, 0xA4	; 164
     7e0:	fc 01       	movw	r30, r24
     7e2:	20 83       	st	Z, r18
	  twi_state = TWI_READY;
     7e4:	10 92 c6 05 	sts	0x05C6, r1
	}
      }
      break;
     7e8:	dd c0       	rjmp	.+442    	; 0x9a4 <__stack+0xa5>
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
     7ea:	80 e2       	ldi	r24, 0x20	; 32
     7ec:	80 93 33 06 	sts	0x0633, r24
      twi_stop();
     7f0:	0e 94 65 03 	call	0x6ca	; 0x6ca <twi_stop>
      break;
     7f4:	d7 c0       	rjmp	.+430    	; 0x9a4 <__stack+0xa5>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
     7f6:	80 e3       	ldi	r24, 0x30	; 48
     7f8:	80 93 33 06 	sts	0x0633, r24
      twi_stop();
     7fc:	0e 94 65 03 	call	0x6ca	; 0x6ca <twi_stop>
      break;
     800:	d1 c0       	rjmp	.+418    	; 0x9a4 <__stack+0xa5>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
     802:	88 e3       	ldi	r24, 0x38	; 56
     804:	80 93 33 06 	sts	0x0633, r24
      twi_releaseBus();
     808:	0e 94 80 03 	call	0x700	; 0x700 <twi_releaseBus>
      break;
     80c:	cb c0       	rjmp	.+406    	; 0x9a4 <__stack+0xa5>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
     80e:	40 91 ee 05 	lds	r20, 0x05EE
     812:	84 2f       	mov	r24, r20
     814:	90 e0       	ldi	r25, 0x00	; 0
     816:	2b eb       	ldi	r18, 0xBB	; 187
     818:	30 e0       	ldi	r19, 0x00	; 0
     81a:	f9 01       	movw	r30, r18
     81c:	20 81       	ld	r18, Z
     81e:	82 53       	subi	r24, 0x32	; 50
     820:	9a 4f       	sbci	r25, 0xFA	; 250
     822:	fc 01       	movw	r30, r24
     824:	20 83       	st	Z, r18
     826:	84 2f       	mov	r24, r20
     828:	8f 5f       	subi	r24, 0xFF	; 255
     82a:	80 93 ee 05 	sts	0x05EE, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
     82e:	90 91 ee 05 	lds	r25, 0x05EE
     832:	80 91 ef 05 	lds	r24, 0x05EF
     836:	98 17       	cp	r25, r24
     838:	20 f4       	brcc	.+8      	; 0x842 <__vector_24+0x126>
        twi_reply(1);
     83a:	81 e0       	ldi	r24, 0x01	; 1
     83c:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
      }else{
        twi_reply(0);
      }
      break;
     840:	b1 c0       	rjmp	.+354    	; 0x9a4 <__stack+0xa5>
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
        twi_reply(1);
      }else{
        twi_reply(0);
     842:	80 e0       	ldi	r24, 0x00	; 0
     844:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
      }
      break;
     848:	ad c0       	rjmp	.+346    	; 0x9a4 <__stack+0xa5>
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
     84a:	40 91 ee 05 	lds	r20, 0x05EE
     84e:	84 2f       	mov	r24, r20
     850:	90 e0       	ldi	r25, 0x00	; 0
     852:	2b eb       	ldi	r18, 0xBB	; 187
     854:	30 e0       	ldi	r19, 0x00	; 0
     856:	f9 01       	movw	r30, r18
     858:	20 81       	ld	r18, Z
     85a:	82 53       	subi	r24, 0x32	; 50
     85c:	9a 4f       	sbci	r25, 0xFA	; 250
     85e:	fc 01       	movw	r30, r24
     860:	20 83       	st	Z, r18
     862:	84 2f       	mov	r24, r20
     864:	8f 5f       	subi	r24, 0xFF	; 255
     866:	80 93 ee 05 	sts	0x05EE, r24
	if (twi_sendStop)
     86a:	80 91 c8 05 	lds	r24, 0x05C8
     86e:	88 23       	and	r24, r24
     870:	19 f0       	breq	.+6      	; 0x878 <__vector_24+0x15c>
          twi_stop();
     872:	0e 94 65 03 	call	0x6ca	; 0x6ca <twi_stop>
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
	  twi_state = TWI_READY;
	}    
	break;
     876:	96 c0       	rjmp	.+300    	; 0x9a4 <__stack+0xa5>
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
	if (twi_sendStop)
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	80 93 c9 05 	sts	0x05C9, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
     87e:	8c eb       	ldi	r24, 0xBC	; 188
     880:	90 e0       	ldi	r25, 0x00	; 0
     882:	24 ea       	ldi	r18, 0xA4	; 164
     884:	fc 01       	movw	r30, r24
     886:	20 83       	st	Z, r18
	  twi_state = TWI_READY;
     888:	10 92 c6 05 	sts	0x05C6, r1
	}    
	break;
     88c:	8b c0       	rjmp	.+278    	; 0x9a4 <__stack+0xa5>
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
     88e:	0e 94 65 03 	call	0x6ca	; 0x6ca <twi_stop>
      break;
     892:	88 c0       	rjmp	.+272    	; 0x9a4 <__stack+0xa5>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
     894:	83 e0       	ldi	r24, 0x03	; 3
     896:	80 93 c6 05 	sts	0x05C6, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
     89a:	10 92 32 06 	sts	0x0632, r1
      twi_reply(1);
     89e:	81 e0       	ldi	r24, 0x01	; 1
     8a0:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
      break;
     8a4:	7f c0       	rjmp	.+254    	; 0x9a4 <__stack+0xa5>
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
     8a6:	80 91 32 06 	lds	r24, 0x0632
     8aa:	80 32       	cpi	r24, 0x20	; 32
     8ac:	a0 f4       	brcc	.+40     	; 0x8d6 <__vector_24+0x1ba>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
     8ae:	40 91 32 06 	lds	r20, 0x0632
     8b2:	84 2f       	mov	r24, r20
     8b4:	90 e0       	ldi	r25, 0x00	; 0
     8b6:	2b eb       	ldi	r18, 0xBB	; 187
     8b8:	30 e0       	ldi	r19, 0x00	; 0
     8ba:	f9 01       	movw	r30, r18
     8bc:	20 81       	ld	r18, Z
     8be:	8e 5e       	subi	r24, 0xEE	; 238
     8c0:	99 4f       	sbci	r25, 0xF9	; 249
     8c2:	fc 01       	movw	r30, r24
     8c4:	20 83       	st	Z, r18
     8c6:	84 2f       	mov	r24, r20
     8c8:	8f 5f       	subi	r24, 0xFF	; 255
     8ca:	80 93 32 06 	sts	0x0632, r24
        twi_reply(1);
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
      }else{
        // otherwise nack
        twi_reply(0);
      }
      break;
     8d4:	67 c0       	rjmp	.+206    	; 0x9a4 <__stack+0xa5>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
        twi_reply(1);
      }else{
        // otherwise nack
        twi_reply(0);
     8d6:	80 e0       	ldi	r24, 0x00	; 0
     8d8:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
      }
      break;
     8dc:	63 c0       	rjmp	.+198    	; 0x9a4 <__stack+0xa5>
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
     8de:	80 91 32 06 	lds	r24, 0x0632
     8e2:	80 32       	cpi	r24, 0x20	; 32
     8e4:	40 f4       	brcc	.+16     	; 0x8f6 <__vector_24+0x1da>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
     8e6:	80 91 32 06 	lds	r24, 0x0632
     8ea:	88 2f       	mov	r24, r24
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	8e 5e       	subi	r24, 0xEE	; 238
     8f0:	99 4f       	sbci	r25, 0xF9	; 249
     8f2:	fc 01       	movw	r30, r24
     8f4:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
     8f6:	0e 94 65 03 	call	0x6ca	; 0x6ca <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
     8fa:	20 91 cc 05 	lds	r18, 0x05CC
     8fe:	30 91 cd 05 	lds	r19, 0x05CD
     902:	80 91 32 06 	lds	r24, 0x0632
     906:	88 2f       	mov	r24, r24
     908:	90 e0       	ldi	r25, 0x00	; 0
     90a:	bc 01       	movw	r22, r24
     90c:	82 e1       	ldi	r24, 0x12	; 18
     90e:	96 e0       	ldi	r25, 0x06	; 6
     910:	f9 01       	movw	r30, r18
     912:	09 95       	icall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
     914:	10 92 32 06 	sts	0x0632, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
     918:	0e 94 80 03 	call	0x700	; 0x700 <twi_releaseBus>
      break;
     91c:	43 c0       	rjmp	.+134    	; 0x9a4 <__stack+0xa5>
    case TW_SR_DATA_NACK:       // data received, returned nack
    case TW_SR_GCALL_DATA_NACK: // data received generally, returned nack
      // nack back at master
      twi_reply(0);
     91e:	80 e0       	ldi	r24, 0x00	; 0
     920:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
      break;
     924:	3f c0       	rjmp	.+126    	; 0x9a4 <__stack+0xa5>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
     926:	84 e0       	ldi	r24, 0x04	; 4
     928:	80 93 c6 05 	sts	0x05C6, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
     92c:	10 92 10 06 	sts	0x0610, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
     930:	10 92 11 06 	sts	0x0611, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
     934:	80 91 ca 05 	lds	r24, 0x05CA
     938:	90 91 cb 05 	lds	r25, 0x05CB
     93c:	fc 01       	movw	r30, r24
     93e:	09 95       	icall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
     940:	80 91 11 06 	lds	r24, 0x0611
     944:	88 23       	and	r24, r24
     946:	29 f4       	brne	.+10     	; 0x952 <__stack+0x53>
        twi_txBufferLength = 1;
     948:	81 e0       	ldi	r24, 0x01	; 1
     94a:	80 93 11 06 	sts	0x0611, r24
        twi_txBuffer[0] = 0x00;
     94e:	10 92 f0 05 	sts	0x05F0, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
     952:	8b eb       	ldi	r24, 0xBB	; 187
     954:	90 e0       	ldi	r25, 0x00	; 0
     956:	40 91 10 06 	lds	r20, 0x0610
     95a:	24 2f       	mov	r18, r20
     95c:	30 e0       	ldi	r19, 0x00	; 0
     95e:	20 51       	subi	r18, 0x10	; 16
     960:	3a 4f       	sbci	r19, 0xFA	; 250
     962:	f9 01       	movw	r30, r18
     964:	20 81       	ld	r18, Z
     966:	fc 01       	movw	r30, r24
     968:	20 83       	st	Z, r18
     96a:	84 2f       	mov	r24, r20
     96c:	8f 5f       	subi	r24, 0xFF	; 255
     96e:	80 93 10 06 	sts	0x0610, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
     972:	90 91 10 06 	lds	r25, 0x0610
     976:	80 91 11 06 	lds	r24, 0x0611
     97a:	98 17       	cp	r25, r24
     97c:	20 f4       	brcc	.+8      	; 0x986 <__stack+0x87>
        twi_reply(1);
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
      }else{
        twi_reply(0);
      }
      break;
     984:	0f c0       	rjmp	.+30     	; 0x9a4 <__stack+0xa5>
      TWDR = twi_txBuffer[twi_txBufferIndex++];
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
        twi_reply(1);
      }else{
        twi_reply(0);
     986:	80 e0       	ldi	r24, 0x00	; 0
     988:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
      }
      break;
     98c:	0b c0       	rjmp	.+22     	; 0x9a4 <__stack+0xa5>
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
     98e:	81 e0       	ldi	r24, 0x01	; 1
     990:	0e 94 4d 03 	call	0x69a	; 0x69a <twi_reply>
      // leave slave receiver state
      twi_state = TWI_READY;
     994:	10 92 c6 05 	sts	0x05C6, r1
      break;
     998:	05 c0       	rjmp	.+10     	; 0x9a4 <__stack+0xa5>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
     99a:	10 92 33 06 	sts	0x0633, r1
      twi_stop();
     99e:	0e 94 65 03 	call	0x6ca	; 0x6ca <twi_stop>
      break;
     9a2:	00 00       	nop
  }
}
     9a4:	df 91       	pop	r29
     9a6:	cf 91       	pop	r28
     9a8:	ff 91       	pop	r31
     9aa:	ef 91       	pop	r30
     9ac:	bf 91       	pop	r27
     9ae:	af 91       	pop	r26
     9b0:	9f 91       	pop	r25
     9b2:	8f 91       	pop	r24
     9b4:	7f 91       	pop	r23
     9b6:	6f 91       	pop	r22
     9b8:	5f 91       	pop	r21
     9ba:	4f 91       	pop	r20
     9bc:	3f 91       	pop	r19
     9be:	2f 91       	pop	r18
     9c0:	0f 90       	pop	r0
     9c2:	00 92 5f 00 	sts	0x005F, r0
     9c6:	0f 90       	pop	r0
     9c8:	1f 90       	pop	r1
     9ca:	18 95       	reti

000009cc <_ZN7TwoWireC1Ev>:
void (*TwoWire::user_onRequest)(void);
void (*TwoWire::user_onReceive)(int);

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire()
     9cc:	cf 93       	push	r28
     9ce:	df 93       	push	r29
     9d0:	00 d0       	rcall	.+0      	; 0x9d2 <_ZN7TwoWireC1Ev+0x6>
     9d2:	cd b7       	in	r28, 0x3d	; 61
     9d4:	de b7       	in	r29, 0x3e	; 62
     9d6:	9a 83       	std	Y+2, r25	; 0x02
     9d8:	89 83       	std	Y+1, r24	; 0x01
     9da:	89 81       	ldd	r24, Y+1	; 0x01
     9dc:	9a 81       	ldd	r25, Y+2	; 0x02
     9de:	0e 94 99 a5 	call	0x14b32	; 0x14b32 <_ZN6StreamC1Ev>
     9e2:	89 81       	ldd	r24, Y+1	; 0x01
     9e4:	9a 81       	ldd	r25, Y+2	; 0x02
     9e6:	2b ec       	ldi	r18, 0xCB	; 203
     9e8:	34 e0       	ldi	r19, 0x04	; 4
     9ea:	fc 01       	movw	r30, r24
     9ec:	31 83       	std	Z+1, r19	; 0x01
     9ee:	20 83       	st	Z, r18
{
}
     9f0:	0f 90       	pop	r0
     9f2:	0f 90       	pop	r0
     9f4:	df 91       	pop	r29
     9f6:	cf 91       	pop	r28
     9f8:	08 95       	ret

000009fa <_ZN7TwoWire5beginEv>:

// Public Methods //////////////////////////////////////////////////////////////

void TwoWire::begin(void)
{
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
     9fe:	00 d0       	rcall	.+0      	; 0xa00 <_ZN7TwoWire5beginEv+0x6>
     a00:	cd b7       	in	r28, 0x3d	; 61
     a02:	de b7       	in	r29, 0x3e	; 62
     a04:	9a 83       	std	Y+2, r25	; 0x02
     a06:	89 83       	std	Y+1, r24	; 0x01
  rxBufferIndex = 0;
     a08:	10 92 54 06 	sts	0x0654, r1
  rxBufferLength = 0;
     a0c:	10 92 55 06 	sts	0x0655, r1

  txBufferIndex = 0;
     a10:	10 92 77 06 	sts	0x0677, r1
  txBufferLength = 0;
     a14:	10 92 78 06 	sts	0x0678, r1

  twi_init();
     a18:	0e 94 a1 01 	call	0x342	; 0x342 <twi_init>
}
     a1c:	0f 90       	pop	r0
     a1e:	0f 90       	pop	r0
     a20:	df 91       	pop	r29
     a22:	cf 91       	pop	r28
     a24:	08 95       	ret

00000a26 <_ZN7TwoWire5beginEh>:

void TwoWire::begin(uint8_t address)
{
     a26:	cf 93       	push	r28
     a28:	df 93       	push	r29
     a2a:	00 d0       	rcall	.+0      	; 0xa2c <_ZN7TwoWire5beginEh+0x6>
     a2c:	1f 92       	push	r1
     a2e:	cd b7       	in	r28, 0x3d	; 61
     a30:	de b7       	in	r29, 0x3e	; 62
     a32:	9a 83       	std	Y+2, r25	; 0x02
     a34:	89 83       	std	Y+1, r24	; 0x01
     a36:	6b 83       	std	Y+3, r22	; 0x03
  twi_setAddress(address);
     a38:	8b 81       	ldd	r24, Y+3	; 0x03
     a3a:	0e 94 d5 01 	call	0x3aa	; 0x3aa <twi_setAddress>
  twi_attachSlaveTxEvent(onRequestService);
     a3e:	8f e7       	ldi	r24, 0x7F	; 127
     a40:	97 e0       	ldi	r25, 0x07	; 7
     a42:	0e 94 3b 03 	call	0x676	; 0x676 <twi_attachSlaveTxEvent>
  twi_attachSlaveRxEvent(onReceiveService);
     a46:	8e e2       	ldi	r24, 0x2E	; 46
     a48:	97 e0       	ldi	r25, 0x07	; 7
     a4a:	0e 94 29 03 	call	0x652	; 0x652 <twi_attachSlaveRxEvent>
  begin();
     a4e:	89 81       	ldd	r24, Y+1	; 0x01
     a50:	9a 81       	ldd	r25, Y+2	; 0x02
     a52:	0e 94 fd 04 	call	0x9fa	; 0x9fa <_ZN7TwoWire5beginEv>
}
     a56:	0f 90       	pop	r0
     a58:	0f 90       	pop	r0
     a5a:	0f 90       	pop	r0
     a5c:	df 91       	pop	r29
     a5e:	cf 91       	pop	r28
     a60:	08 95       	ret

00000a62 <_ZN7TwoWire5beginEi>:

void TwoWire::begin(int address)
{
     a62:	cf 93       	push	r28
     a64:	df 93       	push	r29
     a66:	00 d0       	rcall	.+0      	; 0xa68 <_ZN7TwoWire5beginEi+0x6>
     a68:	00 d0       	rcall	.+0      	; 0xa6a <_ZN7TwoWire5beginEi+0x8>
     a6a:	cd b7       	in	r28, 0x3d	; 61
     a6c:	de b7       	in	r29, 0x3e	; 62
     a6e:	9a 83       	std	Y+2, r25	; 0x02
     a70:	89 83       	std	Y+1, r24	; 0x01
     a72:	7c 83       	std	Y+4, r23	; 0x04
     a74:	6b 83       	std	Y+3, r22	; 0x03
  begin((uint8_t)address);
     a76:	2b 81       	ldd	r18, Y+3	; 0x03
     a78:	89 81       	ldd	r24, Y+1	; 0x01
     a7a:	9a 81       	ldd	r25, Y+2	; 0x02
     a7c:	62 2f       	mov	r22, r18
     a7e:	0e 94 13 05 	call	0xa26	; 0xa26 <_ZN7TwoWire5beginEh>
}
     a82:	0f 90       	pop	r0
     a84:	0f 90       	pop	r0
     a86:	0f 90       	pop	r0
     a88:	0f 90       	pop	r0
     a8a:	df 91       	pop	r29
     a8c:	cf 91       	pop	r28
     a8e:	08 95       	ret

00000a90 <_ZN7TwoWire11requestFromEhhh>:

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop)
{
     a90:	cf 93       	push	r28
     a92:	df 93       	push	r29
     a94:	00 d0       	rcall	.+0      	; 0xa96 <_ZN7TwoWire11requestFromEhhh+0x6>
     a96:	00 d0       	rcall	.+0      	; 0xa98 <_ZN7TwoWire11requestFromEhhh+0x8>
     a98:	00 d0       	rcall	.+0      	; 0xa9a <_ZN7TwoWire11requestFromEhhh+0xa>
     a9a:	cd b7       	in	r28, 0x3d	; 61
     a9c:	de b7       	in	r29, 0x3e	; 62
     a9e:	9b 83       	std	Y+3, r25	; 0x03
     aa0:	8a 83       	std	Y+2, r24	; 0x02
     aa2:	6c 83       	std	Y+4, r22	; 0x04
     aa4:	4d 83       	std	Y+5, r20	; 0x05
     aa6:	2e 83       	std	Y+6, r18	; 0x06
  // clamp to buffer length
  if(quantity > BUFFER_LENGTH){
     aa8:	8d 81       	ldd	r24, Y+5	; 0x05
     aaa:	81 32       	cpi	r24, 0x21	; 33
     aac:	10 f0       	brcs	.+4      	; 0xab2 <_ZN7TwoWire11requestFromEhhh+0x22>
    quantity = BUFFER_LENGTH;
     aae:	80 e2       	ldi	r24, 0x20	; 32
     ab0:	8d 83       	std	Y+5, r24	; 0x05
  }
  // perform blocking read into buffer
  uint8_t read = twi_readFrom(address, rxBuffer, quantity, sendStop);
     ab2:	2e 81       	ldd	r18, Y+6	; 0x06
     ab4:	4d 81       	ldd	r20, Y+5	; 0x05
     ab6:	64 e3       	ldi	r22, 0x34	; 52
     ab8:	76 e0       	ldi	r23, 0x06	; 6
     aba:	8c 81       	ldd	r24, Y+4	; 0x04
     abc:	0e 94 e5 01 	call	0x3ca	; 0x3ca <twi_readFrom>
     ac0:	89 83       	std	Y+1, r24	; 0x01
  // set rx buffer iterator vars
  rxBufferIndex = 0;
     ac2:	10 92 54 06 	sts	0x0654, r1
  rxBufferLength = read;
     ac6:	89 81       	ldd	r24, Y+1	; 0x01
     ac8:	80 93 55 06 	sts	0x0655, r24

  return read;
     acc:	89 81       	ldd	r24, Y+1	; 0x01
}
     ace:	26 96       	adiw	r28, 0x06	; 6
     ad0:	0f b6       	in	r0, 0x3f	; 63
     ad2:	f8 94       	cli
     ad4:	de bf       	out	0x3e, r29	; 62
     ad6:	0f be       	out	0x3f, r0	; 63
     ad8:	cd bf       	out	0x3d, r28	; 61
     ada:	df 91       	pop	r29
     adc:	cf 91       	pop	r28
     ade:	08 95       	ret

00000ae0 <_ZN7TwoWire11requestFromEhh>:

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)
{
     ae0:	cf 93       	push	r28
     ae2:	df 93       	push	r29
     ae4:	00 d0       	rcall	.+0      	; 0xae6 <_ZN7TwoWire11requestFromEhh+0x6>
     ae6:	00 d0       	rcall	.+0      	; 0xae8 <_ZN7TwoWire11requestFromEhh+0x8>
     ae8:	cd b7       	in	r28, 0x3d	; 61
     aea:	de b7       	in	r29, 0x3e	; 62
     aec:	9a 83       	std	Y+2, r25	; 0x02
     aee:	89 83       	std	Y+1, r24	; 0x01
     af0:	6b 83       	std	Y+3, r22	; 0x03
     af2:	4c 83       	std	Y+4, r20	; 0x04
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
     af4:	89 81       	ldd	r24, Y+1	; 0x01
     af6:	9a 81       	ldd	r25, Y+2	; 0x02
     af8:	21 e0       	ldi	r18, 0x01	; 1
     afa:	4c 81       	ldd	r20, Y+4	; 0x04
     afc:	6b 81       	ldd	r22, Y+3	; 0x03
     afe:	0e 94 48 05 	call	0xa90	; 0xa90 <_ZN7TwoWire11requestFromEhhh>
}
     b02:	0f 90       	pop	r0
     b04:	0f 90       	pop	r0
     b06:	0f 90       	pop	r0
     b08:	0f 90       	pop	r0
     b0a:	df 91       	pop	r29
     b0c:	cf 91       	pop	r28
     b0e:	08 95       	ret

00000b10 <_ZN7TwoWire11requestFromEii>:

uint8_t TwoWire::requestFrom(int address, int quantity)
{
     b10:	cf 93       	push	r28
     b12:	df 93       	push	r29
     b14:	00 d0       	rcall	.+0      	; 0xb16 <_ZN7TwoWire11requestFromEii+0x6>
     b16:	00 d0       	rcall	.+0      	; 0xb18 <_ZN7TwoWire11requestFromEii+0x8>
     b18:	00 d0       	rcall	.+0      	; 0xb1a <_ZN7TwoWire11requestFromEii+0xa>
     b1a:	cd b7       	in	r28, 0x3d	; 61
     b1c:	de b7       	in	r29, 0x3e	; 62
     b1e:	9a 83       	std	Y+2, r25	; 0x02
     b20:	89 83       	std	Y+1, r24	; 0x01
     b22:	7c 83       	std	Y+4, r23	; 0x04
     b24:	6b 83       	std	Y+3, r22	; 0x03
     b26:	5e 83       	std	Y+6, r21	; 0x06
     b28:	4d 83       	std	Y+5, r20	; 0x05
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
     b2a:	4d 81       	ldd	r20, Y+5	; 0x05
     b2c:	3b 81       	ldd	r19, Y+3	; 0x03
     b2e:	89 81       	ldd	r24, Y+1	; 0x01
     b30:	9a 81       	ldd	r25, Y+2	; 0x02
     b32:	21 e0       	ldi	r18, 0x01	; 1
     b34:	63 2f       	mov	r22, r19
     b36:	0e 94 48 05 	call	0xa90	; 0xa90 <_ZN7TwoWire11requestFromEhhh>
}
     b3a:	26 96       	adiw	r28, 0x06	; 6
     b3c:	0f b6       	in	r0, 0x3f	; 63
     b3e:	f8 94       	cli
     b40:	de bf       	out	0x3e, r29	; 62
     b42:	0f be       	out	0x3f, r0	; 63
     b44:	cd bf       	out	0x3d, r28	; 61
     b46:	df 91       	pop	r29
     b48:	cf 91       	pop	r28
     b4a:	08 95       	ret

00000b4c <_ZN7TwoWire11requestFromEiii>:

uint8_t TwoWire::requestFrom(int address, int quantity, int sendStop)
{
     b4c:	cf 93       	push	r28
     b4e:	df 93       	push	r29
     b50:	cd b7       	in	r28, 0x3d	; 61
     b52:	de b7       	in	r29, 0x3e	; 62
     b54:	28 97       	sbiw	r28, 0x08	; 8
     b56:	0f b6       	in	r0, 0x3f	; 63
     b58:	f8 94       	cli
     b5a:	de bf       	out	0x3e, r29	; 62
     b5c:	0f be       	out	0x3f, r0	; 63
     b5e:	cd bf       	out	0x3d, r28	; 61
     b60:	9a 83       	std	Y+2, r25	; 0x02
     b62:	89 83       	std	Y+1, r24	; 0x01
     b64:	7c 83       	std	Y+4, r23	; 0x04
     b66:	6b 83       	std	Y+3, r22	; 0x03
     b68:	5e 83       	std	Y+6, r21	; 0x06
     b6a:	4d 83       	std	Y+5, r20	; 0x05
     b6c:	38 87       	std	Y+8, r19	; 0x08
     b6e:	2f 83       	std	Y+7, r18	; 0x07
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
     b70:	2f 81       	ldd	r18, Y+7	; 0x07
     b72:	4d 81       	ldd	r20, Y+5	; 0x05
     b74:	3b 81       	ldd	r19, Y+3	; 0x03
     b76:	89 81       	ldd	r24, Y+1	; 0x01
     b78:	9a 81       	ldd	r25, Y+2	; 0x02
     b7a:	63 2f       	mov	r22, r19
     b7c:	0e 94 48 05 	call	0xa90	; 0xa90 <_ZN7TwoWire11requestFromEhhh>
}
     b80:	28 96       	adiw	r28, 0x08	; 8
     b82:	0f b6       	in	r0, 0x3f	; 63
     b84:	f8 94       	cli
     b86:	de bf       	out	0x3e, r29	; 62
     b88:	0f be       	out	0x3f, r0	; 63
     b8a:	cd bf       	out	0x3d, r28	; 61
     b8c:	df 91       	pop	r29
     b8e:	cf 91       	pop	r28
     b90:	08 95       	ret

00000b92 <_ZN7TwoWire17beginTransmissionEh>:

void TwoWire::beginTransmission(uint8_t address)
{
     b92:	cf 93       	push	r28
     b94:	df 93       	push	r29
     b96:	00 d0       	rcall	.+0      	; 0xb98 <_ZN7TwoWire17beginTransmissionEh+0x6>
     b98:	1f 92       	push	r1
     b9a:	cd b7       	in	r28, 0x3d	; 61
     b9c:	de b7       	in	r29, 0x3e	; 62
     b9e:	9a 83       	std	Y+2, r25	; 0x02
     ba0:	89 83       	std	Y+1, r24	; 0x01
     ba2:	6b 83       	std	Y+3, r22	; 0x03
  // indicate that we are transmitting
  transmitting = 1;
     ba4:	81 e0       	ldi	r24, 0x01	; 1
     ba6:	80 93 79 06 	sts	0x0679, r24
  // set address of targeted slave
  txAddress = address;
     baa:	8b 81       	ldd	r24, Y+3	; 0x03
     bac:	80 93 56 06 	sts	0x0656, r24
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     bb0:	10 92 77 06 	sts	0x0677, r1
  txBufferLength = 0;
     bb4:	10 92 78 06 	sts	0x0678, r1
}
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	0f 90       	pop	r0
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	08 95       	ret

00000bc4 <_ZN7TwoWire17beginTransmissionEi>:

void TwoWire::beginTransmission(int address)
{
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	00 d0       	rcall	.+0      	; 0xbca <_ZN7TwoWire17beginTransmissionEi+0x6>
     bca:	00 d0       	rcall	.+0      	; 0xbcc <_ZN7TwoWire17beginTransmissionEi+0x8>
     bcc:	cd b7       	in	r28, 0x3d	; 61
     bce:	de b7       	in	r29, 0x3e	; 62
     bd0:	9a 83       	std	Y+2, r25	; 0x02
     bd2:	89 83       	std	Y+1, r24	; 0x01
     bd4:	7c 83       	std	Y+4, r23	; 0x04
     bd6:	6b 83       	std	Y+3, r22	; 0x03
  beginTransmission((uint8_t)address);
     bd8:	2b 81       	ldd	r18, Y+3	; 0x03
     bda:	89 81       	ldd	r24, Y+1	; 0x01
     bdc:	9a 81       	ldd	r25, Y+2	; 0x02
     bde:	62 2f       	mov	r22, r18
     be0:	0e 94 c9 05 	call	0xb92	; 0xb92 <_ZN7TwoWire17beginTransmissionEh>
}
     be4:	0f 90       	pop	r0
     be6:	0f 90       	pop	r0
     be8:	0f 90       	pop	r0
     bea:	0f 90       	pop	r0
     bec:	df 91       	pop	r29
     bee:	cf 91       	pop	r28
     bf0:	08 95       	ret

00000bf2 <_ZN7TwoWire15endTransmissionEh>:
//	is very possible to leave the bus in a hung state if
//	no call to endTransmission(true) is made. Some I2C
//	devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
     bf2:	0f 93       	push	r16
     bf4:	cf 93       	push	r28
     bf6:	df 93       	push	r29
     bf8:	00 d0       	rcall	.+0      	; 0xbfa <_ZN7TwoWire15endTransmissionEh+0x8>
     bfa:	00 d0       	rcall	.+0      	; 0xbfc <_ZN7TwoWire15endTransmissionEh+0xa>
     bfc:	cd b7       	in	r28, 0x3d	; 61
     bfe:	de b7       	in	r29, 0x3e	; 62
     c00:	9b 83       	std	Y+3, r25	; 0x03
     c02:	8a 83       	std	Y+2, r24	; 0x02
     c04:	6c 83       	std	Y+4, r22	; 0x04
  // transmit buffer (blocking)
  int8_t ret = twi_writeTo(txAddress, txBuffer, txBufferLength, 1, sendStop);
     c06:	90 91 78 06 	lds	r25, 0x0678
     c0a:	80 91 56 06 	lds	r24, 0x0656
     c0e:	0c 81       	ldd	r16, Y+4	; 0x04
     c10:	21 e0       	ldi	r18, 0x01	; 1
     c12:	49 2f       	mov	r20, r25
     c14:	67 e5       	ldi	r22, 0x57	; 87
     c16:	76 e0       	ldi	r23, 0x06	; 6
     c18:	0e 94 63 02 	call	0x4c6	; 0x4c6 <twi_writeTo>
     c1c:	89 83       	std	Y+1, r24	; 0x01
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     c1e:	10 92 77 06 	sts	0x0677, r1
  txBufferLength = 0;
     c22:	10 92 78 06 	sts	0x0678, r1
  // indicate that we are done transmitting
  transmitting = 0;
     c26:	10 92 79 06 	sts	0x0679, r1
  return ret;
     c2a:	89 81       	ldd	r24, Y+1	; 0x01
}
     c2c:	0f 90       	pop	r0
     c2e:	0f 90       	pop	r0
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	df 91       	pop	r29
     c36:	cf 91       	pop	r28
     c38:	0f 91       	pop	r16
     c3a:	08 95       	ret

00000c3c <_ZN7TwoWire15endTransmissionEv>:

//	This provides backwards compatibility with the original
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
     c3c:	cf 93       	push	r28
     c3e:	df 93       	push	r29
     c40:	00 d0       	rcall	.+0      	; 0xc42 <_ZN7TwoWire15endTransmissionEv+0x6>
     c42:	cd b7       	in	r28, 0x3d	; 61
     c44:	de b7       	in	r29, 0x3e	; 62
     c46:	9a 83       	std	Y+2, r25	; 0x02
     c48:	89 83       	std	Y+1, r24	; 0x01
  return endTransmission(true);
     c4a:	89 81       	ldd	r24, Y+1	; 0x01
     c4c:	9a 81       	ldd	r25, Y+2	; 0x02
     c4e:	61 e0       	ldi	r22, 0x01	; 1
     c50:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <_ZN7TwoWire15endTransmissionEh>
}
     c54:	0f 90       	pop	r0
     c56:	0f 90       	pop	r0
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
     c5c:	08 95       	ret

00000c5e <_ZN7TwoWire5writeEh>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
     c5e:	cf 93       	push	r28
     c60:	df 93       	push	r29
     c62:	00 d0       	rcall	.+0      	; 0xc64 <_ZN7TwoWire5writeEh+0x6>
     c64:	1f 92       	push	r1
     c66:	cd b7       	in	r28, 0x3d	; 61
     c68:	de b7       	in	r29, 0x3e	; 62
     c6a:	9a 83       	std	Y+2, r25	; 0x02
     c6c:	89 83       	std	Y+1, r24	; 0x01
     c6e:	6b 83       	std	Y+3, r22	; 0x03
  if(transmitting){
     c70:	80 91 79 06 	lds	r24, 0x0679
     c74:	88 23       	and	r24, r24
     c76:	01 f1       	breq	.+64     	; 0xcb8 <_ZN7TwoWire5writeEh+0x5a>
  // in master transmitter mode
    // don't bother if buffer is full
    if(txBufferLength >= BUFFER_LENGTH){
     c78:	80 91 78 06 	lds	r24, 0x0678
     c7c:	80 32       	cpi	r24, 0x20	; 32
     c7e:	48 f0       	brcs	.+18     	; 0xc92 <_ZN7TwoWire5writeEh+0x34>
      setWriteError();
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	9a 81       	ldd	r25, Y+2	; 0x02
     c84:	61 e0       	ldi	r22, 0x01	; 1
     c86:	70 e0       	ldi	r23, 0x00	; 0
     c88:	0e 94 69 a5 	call	0x14ad2	; 0x14ad2 <_ZN5Print13setWriteErrorEi>
      return 0;
     c8c:	80 e0       	ldi	r24, 0x00	; 0
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	1a c0       	rjmp	.+52     	; 0xcc6 <_ZN7TwoWire5writeEh+0x68>
    }
    // put byte in tx buffer
    txBuffer[txBufferIndex] = data;
     c92:	80 91 77 06 	lds	r24, 0x0677
     c96:	88 2f       	mov	r24, r24
     c98:	90 e0       	ldi	r25, 0x00	; 0
     c9a:	2b 81       	ldd	r18, Y+3	; 0x03
     c9c:	89 5a       	subi	r24, 0xA9	; 169
     c9e:	99 4f       	sbci	r25, 0xF9	; 249
     ca0:	fc 01       	movw	r30, r24
     ca2:	20 83       	st	Z, r18
    ++txBufferIndex;
     ca4:	80 91 77 06 	lds	r24, 0x0677
     ca8:	8f 5f       	subi	r24, 0xFF	; 255
     caa:	80 93 77 06 	sts	0x0677, r24
    // update amount in buffer   
    txBufferLength = txBufferIndex;
     cae:	80 91 77 06 	lds	r24, 0x0677
     cb2:	80 93 78 06 	sts	0x0678, r24
     cb6:	05 c0       	rjmp	.+10     	; 0xcc2 <_ZN7TwoWire5writeEh+0x64>
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
     cb8:	ce 01       	movw	r24, r28
     cba:	03 96       	adiw	r24, 0x03	; 3
     cbc:	61 e0       	ldi	r22, 0x01	; 1
     cbe:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <twi_transmit>
  }
  return 1;
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	90 e0       	ldi	r25, 0x00	; 0
}
     cc6:	0f 90       	pop	r0
     cc8:	0f 90       	pop	r0
     cca:	0f 90       	pop	r0
     ccc:	df 91       	pop	r29
     cce:	cf 91       	pop	r28
     cd0:	08 95       	ret

00000cd2 <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
     cd2:	cf 93       	push	r28
     cd4:	df 93       	push	r29
     cd6:	cd b7       	in	r28, 0x3d	; 61
     cd8:	de b7       	in	r29, 0x3e	; 62
     cda:	28 97       	sbiw	r28, 0x08	; 8
     cdc:	0f b6       	in	r0, 0x3f	; 63
     cde:	f8 94       	cli
     ce0:	de bf       	out	0x3e, r29	; 62
     ce2:	0f be       	out	0x3f, r0	; 63
     ce4:	cd bf       	out	0x3d, r28	; 61
     ce6:	9c 83       	std	Y+4, r25	; 0x04
     ce8:	8b 83       	std	Y+3, r24	; 0x03
     cea:	7e 83       	std	Y+6, r23	; 0x06
     cec:	6d 83       	std	Y+5, r22	; 0x05
     cee:	58 87       	std	Y+8, r21	; 0x08
     cf0:	4f 83       	std	Y+7, r20	; 0x07
  if(transmitting){
     cf2:	80 91 79 06 	lds	r24, 0x0679
     cf6:	88 23       	and	r24, r24
     cf8:	49 f1       	breq	.+82     	; 0xd4c <_ZN7TwoWire5writeEPKhj+0x7a>
  // in master transmitter mode
    for(size_t i = 0; i < quantity; ++i){
     cfa:	1a 82       	std	Y+2, r1	; 0x02
     cfc:	19 82       	std	Y+1, r1	; 0x01
     cfe:	1a c0       	rjmp	.+52     	; 0xd34 <_ZN7TwoWire5writeEPKhj+0x62>
      write(data[i]);
     d00:	8b 81       	ldd	r24, Y+3	; 0x03
     d02:	9c 81       	ldd	r25, Y+4	; 0x04
     d04:	fc 01       	movw	r30, r24
     d06:	80 81       	ld	r24, Z
     d08:	91 81       	ldd	r25, Z+1	; 0x01
     d0a:	fc 01       	movw	r30, r24
     d0c:	20 81       	ld	r18, Z
     d0e:	31 81       	ldd	r19, Z+1	; 0x01
     d10:	4d 81       	ldd	r20, Y+5	; 0x05
     d12:	5e 81       	ldd	r21, Y+6	; 0x06
     d14:	89 81       	ldd	r24, Y+1	; 0x01
     d16:	9a 81       	ldd	r25, Y+2	; 0x02
     d18:	84 0f       	add	r24, r20
     d1a:	95 1f       	adc	r25, r21
     d1c:	fc 01       	movw	r30, r24
     d1e:	40 81       	ld	r20, Z
     d20:	8b 81       	ldd	r24, Y+3	; 0x03
     d22:	9c 81       	ldd	r25, Y+4	; 0x04
     d24:	64 2f       	mov	r22, r20
     d26:	f9 01       	movw	r30, r18
     d28:	09 95       	icall
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  if(transmitting){
  // in master transmitter mode
    for(size_t i = 0; i < quantity; ++i){
     d2a:	89 81       	ldd	r24, Y+1	; 0x01
     d2c:	9a 81       	ldd	r25, Y+2	; 0x02
     d2e:	01 96       	adiw	r24, 0x01	; 1
     d30:	9a 83       	std	Y+2, r25	; 0x02
     d32:	89 83       	std	Y+1, r24	; 0x01
     d34:	41 e0       	ldi	r20, 0x01	; 1
     d36:	29 81       	ldd	r18, Y+1	; 0x01
     d38:	3a 81       	ldd	r19, Y+2	; 0x02
     d3a:	8f 81       	ldd	r24, Y+7	; 0x07
     d3c:	98 85       	ldd	r25, Y+8	; 0x08
     d3e:	28 17       	cp	r18, r24
     d40:	39 07       	cpc	r19, r25
     d42:	08 f0       	brcs	.+2      	; 0xd46 <_ZN7TwoWire5writeEPKhj+0x74>
     d44:	40 e0       	ldi	r20, 0x00	; 0
     d46:	44 23       	and	r20, r20
     d48:	d9 f6       	brne	.-74     	; 0xd00 <_ZN7TwoWire5writeEPKhj+0x2e>
     d4a:	06 c0       	rjmp	.+12     	; 0xd58 <_ZN7TwoWire5writeEPKhj+0x86>
      write(data[i]);
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
     d4c:	2f 81       	ldd	r18, Y+7	; 0x07
     d4e:	8d 81       	ldd	r24, Y+5	; 0x05
     d50:	9e 81       	ldd	r25, Y+6	; 0x06
     d52:	62 2f       	mov	r22, r18
     d54:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <twi_transmit>
  }
  return quantity;
     d58:	8f 81       	ldd	r24, Y+7	; 0x07
     d5a:	98 85       	ldd	r25, Y+8	; 0x08
}
     d5c:	28 96       	adiw	r28, 0x08	; 8
     d5e:	0f b6       	in	r0, 0x3f	; 63
     d60:	f8 94       	cli
     d62:	de bf       	out	0x3e, r29	; 62
     d64:	0f be       	out	0x3f, r0	; 63
     d66:	cd bf       	out	0x3d, r28	; 61
     d68:	df 91       	pop	r29
     d6a:	cf 91       	pop	r28
     d6c:	08 95       	ret

00000d6e <_ZN7TwoWire9availableEv>:

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
     d6e:	cf 93       	push	r28
     d70:	df 93       	push	r29
     d72:	00 d0       	rcall	.+0      	; 0xd74 <_ZN7TwoWire9availableEv+0x6>
     d74:	cd b7       	in	r28, 0x3d	; 61
     d76:	de b7       	in	r29, 0x3e	; 62
     d78:	9a 83       	std	Y+2, r25	; 0x02
     d7a:	89 83       	std	Y+1, r24	; 0x01
  return rxBufferLength - rxBufferIndex;
     d7c:	80 91 55 06 	lds	r24, 0x0655
     d80:	28 2f       	mov	r18, r24
     d82:	30 e0       	ldi	r19, 0x00	; 0
     d84:	80 91 54 06 	lds	r24, 0x0654
     d88:	88 2f       	mov	r24, r24
     d8a:	90 e0       	ldi	r25, 0x00	; 0
     d8c:	a9 01       	movw	r20, r18
     d8e:	48 1b       	sub	r20, r24
     d90:	59 0b       	sbc	r21, r25
     d92:	ca 01       	movw	r24, r20
}
     d94:	0f 90       	pop	r0
     d96:	0f 90       	pop	r0
     d98:	df 91       	pop	r29
     d9a:	cf 91       	pop	r28
     d9c:	08 95       	ret

00000d9e <_ZN7TwoWire4readEv>:

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
     da2:	00 d0       	rcall	.+0      	; 0xda4 <_ZN7TwoWire4readEv+0x6>
     da4:	00 d0       	rcall	.+0      	; 0xda6 <_ZN7TwoWire4readEv+0x8>
     da6:	cd b7       	in	r28, 0x3d	; 61
     da8:	de b7       	in	r29, 0x3e	; 62
     daa:	9c 83       	std	Y+4, r25	; 0x04
     dac:	8b 83       	std	Y+3, r24	; 0x03
  int value = -1;
     dae:	8f ef       	ldi	r24, 0xFF	; 255
     db0:	9f ef       	ldi	r25, 0xFF	; 255
     db2:	9a 83       	std	Y+2, r25	; 0x02
     db4:	89 83       	std	Y+1, r24	; 0x01
  
  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     db6:	90 91 54 06 	lds	r25, 0x0654
     dba:	80 91 55 06 	lds	r24, 0x0655
     dbe:	98 17       	cp	r25, r24
     dc0:	88 f4       	brcc	.+34     	; 0xde4 <_ZN7TwoWire4readEv+0x46>
    value = rxBuffer[rxBufferIndex];
     dc2:	80 91 54 06 	lds	r24, 0x0654
     dc6:	88 2f       	mov	r24, r24
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	8c 5c       	subi	r24, 0xCC	; 204
     dcc:	99 4f       	sbci	r25, 0xF9	; 249
     dce:	fc 01       	movw	r30, r24
     dd0:	80 81       	ld	r24, Z
     dd2:	88 2f       	mov	r24, r24
     dd4:	90 e0       	ldi	r25, 0x00	; 0
     dd6:	9a 83       	std	Y+2, r25	; 0x02
     dd8:	89 83       	std	Y+1, r24	; 0x01
    ++rxBufferIndex;
     dda:	80 91 54 06 	lds	r24, 0x0654
     dde:	8f 5f       	subi	r24, 0xFF	; 255
     de0:	80 93 54 06 	sts	0x0654, r24
  }

  return value;
     de4:	89 81       	ldd	r24, Y+1	; 0x01
     de6:	9a 81       	ldd	r25, Y+2	; 0x02
}
     de8:	0f 90       	pop	r0
     dea:	0f 90       	pop	r0
     dec:	0f 90       	pop	r0
     dee:	0f 90       	pop	r0
     df0:	df 91       	pop	r29
     df2:	cf 91       	pop	r28
     df4:	08 95       	ret

00000df6 <_ZN7TwoWire4peekEv>:

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
     df6:	cf 93       	push	r28
     df8:	df 93       	push	r29
     dfa:	00 d0       	rcall	.+0      	; 0xdfc <_ZN7TwoWire4peekEv+0x6>
     dfc:	00 d0       	rcall	.+0      	; 0xdfe <_ZN7TwoWire4peekEv+0x8>
     dfe:	cd b7       	in	r28, 0x3d	; 61
     e00:	de b7       	in	r29, 0x3e	; 62
     e02:	9c 83       	std	Y+4, r25	; 0x04
     e04:	8b 83       	std	Y+3, r24	; 0x03
  int value = -1;
     e06:	8f ef       	ldi	r24, 0xFF	; 255
     e08:	9f ef       	ldi	r25, 0xFF	; 255
     e0a:	9a 83       	std	Y+2, r25	; 0x02
     e0c:	89 83       	std	Y+1, r24	; 0x01
  
  if(rxBufferIndex < rxBufferLength){
     e0e:	90 91 54 06 	lds	r25, 0x0654
     e12:	80 91 55 06 	lds	r24, 0x0655
     e16:	98 17       	cp	r25, r24
     e18:	60 f4       	brcc	.+24     	; 0xe32 <_ZN7TwoWire4peekEv+0x3c>
    value = rxBuffer[rxBufferIndex];
     e1a:	80 91 54 06 	lds	r24, 0x0654
     e1e:	88 2f       	mov	r24, r24
     e20:	90 e0       	ldi	r25, 0x00	; 0
     e22:	8c 5c       	subi	r24, 0xCC	; 204
     e24:	99 4f       	sbci	r25, 0xF9	; 249
     e26:	fc 01       	movw	r30, r24
     e28:	80 81       	ld	r24, Z
     e2a:	88 2f       	mov	r24, r24
     e2c:	90 e0       	ldi	r25, 0x00	; 0
     e2e:	9a 83       	std	Y+2, r25	; 0x02
     e30:	89 83       	std	Y+1, r24	; 0x01
  }

  return value;
     e32:	89 81       	ldd	r24, Y+1	; 0x01
     e34:	9a 81       	ldd	r25, Y+2	; 0x02
}
     e36:	0f 90       	pop	r0
     e38:	0f 90       	pop	r0
     e3a:	0f 90       	pop	r0
     e3c:	0f 90       	pop	r0
     e3e:	df 91       	pop	r29
     e40:	cf 91       	pop	r28
     e42:	08 95       	ret

00000e44 <_ZN7TwoWire5flushEv>:

void TwoWire::flush(void)
{
     e44:	cf 93       	push	r28
     e46:	df 93       	push	r29
     e48:	00 d0       	rcall	.+0      	; 0xe4a <_ZN7TwoWire5flushEv+0x6>
     e4a:	cd b7       	in	r28, 0x3d	; 61
     e4c:	de b7       	in	r29, 0x3e	; 62
     e4e:	9a 83       	std	Y+2, r25	; 0x02
     e50:	89 83       	std	Y+1, r24	; 0x01
  // XXX: to be implemented.
}
     e52:	0f 90       	pop	r0
     e54:	0f 90       	pop	r0
     e56:	df 91       	pop	r29
     e58:	cf 91       	pop	r28
     e5a:	08 95       	ret

00000e5c <_ZN7TwoWire16onReceiveServiceEPhi>:

// behind the scenes function that is called when data is received
void TwoWire::onReceiveService(uint8_t* inBytes, int numBytes)
{
     e5c:	cf 93       	push	r28
     e5e:	df 93       	push	r29
     e60:	00 d0       	rcall	.+0      	; 0xe62 <_ZN7TwoWire16onReceiveServiceEPhi+0x6>
     e62:	00 d0       	rcall	.+0      	; 0xe64 <_ZN7TwoWire16onReceiveServiceEPhi+0x8>
     e64:	1f 92       	push	r1
     e66:	cd b7       	in	r28, 0x3d	; 61
     e68:	de b7       	in	r29, 0x3e	; 62
     e6a:	9b 83       	std	Y+3, r25	; 0x03
     e6c:	8a 83       	std	Y+2, r24	; 0x02
     e6e:	7d 83       	std	Y+5, r23	; 0x05
     e70:	6c 83       	std	Y+4, r22	; 0x04
  // don't bother if user hasn't registered a callback
  if(!user_onReceive){
     e72:	80 91 7c 06 	lds	r24, 0x067C
     e76:	90 91 7d 06 	lds	r25, 0x067D
     e7a:	00 97       	sbiw	r24, 0x00	; 0
     e7c:	a9 f1       	breq	.+106    	; 0xee8 <_ZN7TwoWire16onReceiveServiceEPhi+0x8c>
    return;
  }
  // don't bother if rx buffer is in use by a master requestFrom() op
  // i know this drops data, but it allows for slight stupidity
  // meaning, they may not have read all the master requestFrom() data yet
  if(rxBufferIndex < rxBufferLength){
     e7e:	90 91 54 06 	lds	r25, 0x0654
     e82:	80 91 55 06 	lds	r24, 0x0655
     e86:	98 17       	cp	r25, r24
     e88:	88 f1       	brcs	.+98     	; 0xeec <_ZN7TwoWire16onReceiveServiceEPhi+0x90>
    return;
  }
  // copy twi rx buffer into local read buffer
  // this enables new reads to happen in parallel
  for(uint8_t i = 0; i < numBytes; ++i){
     e8a:	19 82       	std	Y+1, r1	; 0x01
     e8c:	13 c0       	rjmp	.+38     	; 0xeb4 <_ZN7TwoWire16onReceiveServiceEPhi+0x58>
    rxBuffer[i] = inBytes[i];    
     e8e:	89 81       	ldd	r24, Y+1	; 0x01
     e90:	88 2f       	mov	r24, r24
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	29 81       	ldd	r18, Y+1	; 0x01
     e96:	22 2f       	mov	r18, r18
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	4a 81       	ldd	r20, Y+2	; 0x02
     e9c:	5b 81       	ldd	r21, Y+3	; 0x03
     e9e:	24 0f       	add	r18, r20
     ea0:	35 1f       	adc	r19, r21
     ea2:	f9 01       	movw	r30, r18
     ea4:	20 81       	ld	r18, Z
     ea6:	8c 5c       	subi	r24, 0xCC	; 204
     ea8:	99 4f       	sbci	r25, 0xF9	; 249
     eaa:	fc 01       	movw	r30, r24
     eac:	20 83       	st	Z, r18
  if(rxBufferIndex < rxBufferLength){
    return;
  }
  // copy twi rx buffer into local read buffer
  // this enables new reads to happen in parallel
  for(uint8_t i = 0; i < numBytes; ++i){
     eae:	89 81       	ldd	r24, Y+1	; 0x01
     eb0:	8f 5f       	subi	r24, 0xFF	; 255
     eb2:	89 83       	std	Y+1, r24	; 0x01
     eb4:	89 81       	ldd	r24, Y+1	; 0x01
     eb6:	28 2f       	mov	r18, r24
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	41 e0       	ldi	r20, 0x01	; 1
     ebc:	8c 81       	ldd	r24, Y+4	; 0x04
     ebe:	9d 81       	ldd	r25, Y+5	; 0x05
     ec0:	28 17       	cp	r18, r24
     ec2:	39 07       	cpc	r19, r25
     ec4:	0c f0       	brlt	.+2      	; 0xec8 <_ZN7TwoWire16onReceiveServiceEPhi+0x6c>
     ec6:	40 e0       	ldi	r20, 0x00	; 0
     ec8:	44 23       	and	r20, r20
     eca:	09 f7       	brne	.-62     	; 0xe8e <_ZN7TwoWire16onReceiveServiceEPhi+0x32>
    rxBuffer[i] = inBytes[i];    
  }
  // set rx iterator vars
  rxBufferIndex = 0;
     ecc:	10 92 54 06 	sts	0x0654, r1
  rxBufferLength = numBytes;
     ed0:	8c 81       	ldd	r24, Y+4	; 0x04
     ed2:	80 93 55 06 	sts	0x0655, r24
  // alert user program
  user_onReceive(numBytes);
     ed6:	20 91 7c 06 	lds	r18, 0x067C
     eda:	30 91 7d 06 	lds	r19, 0x067D
     ede:	8c 81       	ldd	r24, Y+4	; 0x04
     ee0:	9d 81       	ldd	r25, Y+5	; 0x05
     ee2:	f9 01       	movw	r30, r18
     ee4:	09 95       	icall
     ee6:	03 c0       	rjmp	.+6      	; 0xeee <_ZN7TwoWire16onReceiveServiceEPhi+0x92>
// behind the scenes function that is called when data is received
void TwoWire::onReceiveService(uint8_t* inBytes, int numBytes)
{
  // don't bother if user hasn't registered a callback
  if(!user_onReceive){
    return;
     ee8:	00 00       	nop
     eea:	01 c0       	rjmp	.+2      	; 0xeee <_ZN7TwoWire16onReceiveServiceEPhi+0x92>
  }
  // don't bother if rx buffer is in use by a master requestFrom() op
  // i know this drops data, but it allows for slight stupidity
  // meaning, they may not have read all the master requestFrom() data yet
  if(rxBufferIndex < rxBufferLength){
    return;
     eec:	00 00       	nop
  // set rx iterator vars
  rxBufferIndex = 0;
  rxBufferLength = numBytes;
  // alert user program
  user_onReceive(numBytes);
}
     eee:	0f 90       	pop	r0
     ef0:	0f 90       	pop	r0
     ef2:	0f 90       	pop	r0
     ef4:	0f 90       	pop	r0
     ef6:	0f 90       	pop	r0
     ef8:	df 91       	pop	r29
     efa:	cf 91       	pop	r28
     efc:	08 95       	ret

00000efe <_ZN7TwoWire16onRequestServiceEv>:

// behind the scenes function that is called when data is requested
void TwoWire::onRequestService(void)
{
     efe:	cf 93       	push	r28
     f00:	df 93       	push	r29
     f02:	cd b7       	in	r28, 0x3d	; 61
     f04:	de b7       	in	r29, 0x3e	; 62
  // don't bother if user hasn't registered a callback
  if(!user_onRequest){
     f06:	80 91 7a 06 	lds	r24, 0x067A
     f0a:	90 91 7b 06 	lds	r25, 0x067B
     f0e:	00 97       	sbiw	r24, 0x00	; 0
     f10:	59 f0       	breq	.+22     	; 0xf28 <_ZN7TwoWire16onRequestServiceEv+0x2a>
    return;
  }
  // reset tx buffer iterator vars
  // !!! this will kill any pending pre-master sendTo() activity
  txBufferIndex = 0;
     f12:	10 92 77 06 	sts	0x0677, r1
  txBufferLength = 0;
     f16:	10 92 78 06 	sts	0x0678, r1
  // alert user program
  user_onRequest();
     f1a:	80 91 7a 06 	lds	r24, 0x067A
     f1e:	90 91 7b 06 	lds	r25, 0x067B
     f22:	fc 01       	movw	r30, r24
     f24:	09 95       	icall
     f26:	01 c0       	rjmp	.+2      	; 0xf2a <_ZN7TwoWire16onRequestServiceEv+0x2c>
// behind the scenes function that is called when data is requested
void TwoWire::onRequestService(void)
{
  // don't bother if user hasn't registered a callback
  if(!user_onRequest){
    return;
     f28:	00 00       	nop
  // !!! this will kill any pending pre-master sendTo() activity
  txBufferIndex = 0;
  txBufferLength = 0;
  // alert user program
  user_onRequest();
}
     f2a:	df 91       	pop	r29
     f2c:	cf 91       	pop	r28
     f2e:	08 95       	ret

00000f30 <_ZN7TwoWire9onReceiveEPFviE>:

// sets function called on slave write
void TwoWire::onReceive( void (*function)(int) )
{
     f30:	cf 93       	push	r28
     f32:	df 93       	push	r29
     f34:	00 d0       	rcall	.+0      	; 0xf36 <_ZN7TwoWire9onReceiveEPFviE+0x6>
     f36:	00 d0       	rcall	.+0      	; 0xf38 <_ZN7TwoWire9onReceiveEPFviE+0x8>
     f38:	cd b7       	in	r28, 0x3d	; 61
     f3a:	de b7       	in	r29, 0x3e	; 62
     f3c:	9a 83       	std	Y+2, r25	; 0x02
     f3e:	89 83       	std	Y+1, r24	; 0x01
     f40:	7c 83       	std	Y+4, r23	; 0x04
     f42:	6b 83       	std	Y+3, r22	; 0x03
  user_onReceive = function;
     f44:	8b 81       	ldd	r24, Y+3	; 0x03
     f46:	9c 81       	ldd	r25, Y+4	; 0x04
     f48:	90 93 7d 06 	sts	0x067D, r25
     f4c:	80 93 7c 06 	sts	0x067C, r24
}
     f50:	0f 90       	pop	r0
     f52:	0f 90       	pop	r0
     f54:	0f 90       	pop	r0
     f56:	0f 90       	pop	r0
     f58:	df 91       	pop	r29
     f5a:	cf 91       	pop	r28
     f5c:	08 95       	ret

00000f5e <_ZN7TwoWire9onRequestEPFvvE>:

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
     f5e:	cf 93       	push	r28
     f60:	df 93       	push	r29
     f62:	00 d0       	rcall	.+0      	; 0xf64 <_ZN7TwoWire9onRequestEPFvvE+0x6>
     f64:	00 d0       	rcall	.+0      	; 0xf66 <_ZN7TwoWire9onRequestEPFvvE+0x8>
     f66:	cd b7       	in	r28, 0x3d	; 61
     f68:	de b7       	in	r29, 0x3e	; 62
     f6a:	9a 83       	std	Y+2, r25	; 0x02
     f6c:	89 83       	std	Y+1, r24	; 0x01
     f6e:	7c 83       	std	Y+4, r23	; 0x04
     f70:	6b 83       	std	Y+3, r22	; 0x03
  user_onRequest = function;
     f72:	8b 81       	ldd	r24, Y+3	; 0x03
     f74:	9c 81       	ldd	r25, Y+4	; 0x04
     f76:	90 93 7b 06 	sts	0x067B, r25
     f7a:	80 93 7a 06 	sts	0x067A, r24
}
     f7e:	0f 90       	pop	r0
     f80:	0f 90       	pop	r0
     f82:	0f 90       	pop	r0
     f84:	0f 90       	pop	r0
     f86:	df 91       	pop	r29
     f88:	cf 91       	pop	r28
     f8a:	08 95       	ret

00000f8c <_Z41__static_initialization_and_destruction_0ii>:

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
     f8c:	cf 93       	push	r28
     f8e:	df 93       	push	r29
     f90:	00 d0       	rcall	.+0      	; 0xf92 <_Z41__static_initialization_and_destruction_0ii+0x6>
     f92:	00 d0       	rcall	.+0      	; 0xf94 <_Z41__static_initialization_and_destruction_0ii+0x8>
     f94:	cd b7       	in	r28, 0x3d	; 61
     f96:	de b7       	in	r29, 0x3e	; 62
     f98:	9a 83       	std	Y+2, r25	; 0x02
     f9a:	89 83       	std	Y+1, r24	; 0x01
     f9c:	7c 83       	std	Y+4, r23	; 0x04
     f9e:	6b 83       	std	Y+3, r22	; 0x03
     fa0:	89 81       	ldd	r24, Y+1	; 0x01
     fa2:	9a 81       	ldd	r25, Y+2	; 0x02
     fa4:	81 30       	cpi	r24, 0x01	; 1
     fa6:	91 05       	cpc	r25, r1
     fa8:	51 f4       	brne	.+20     	; 0xfbe <_Z41__static_initialization_and_destruction_0ii+0x32>
     faa:	8b 81       	ldd	r24, Y+3	; 0x03
     fac:	9c 81       	ldd	r25, Y+4	; 0x04
     fae:	8f 3f       	cpi	r24, 0xFF	; 255
     fb0:	2f ef       	ldi	r18, 0xFF	; 255
     fb2:	92 07       	cpc	r25, r18
     fb4:	21 f4       	brne	.+8      	; 0xfbe <_Z41__static_initialization_and_destruction_0ii+0x32>
     fb6:	8e e7       	ldi	r24, 0x7E	; 126
     fb8:	96 e0       	ldi	r25, 0x06	; 6
     fba:	0e 94 e6 04 	call	0x9cc	; 0x9cc <_ZN7TwoWireC1Ev>
     fbe:	0f 90       	pop	r0
     fc0:	0f 90       	pop	r0
     fc2:	0f 90       	pop	r0
     fc4:	0f 90       	pop	r0
     fc6:	df 91       	pop	r29
     fc8:	cf 91       	pop	r28
     fca:	08 95       	ret

00000fcc <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
     fcc:	cf 93       	push	r28
     fce:	df 93       	push	r29
     fd0:	cd b7       	in	r28, 0x3d	; 61
     fd2:	de b7       	in	r29, 0x3e	; 62
     fd4:	6f ef       	ldi	r22, 0xFF	; 255
     fd6:	7f ef       	ldi	r23, 0xFF	; 255
     fd8:	81 e0       	ldi	r24, 0x01	; 1
     fda:	90 e0       	ldi	r25, 0x00	; 0
     fdc:	0e 94 c6 07 	call	0xf8c	; 0xf8c <_Z41__static_initialization_and_destruction_0ii>
     fe0:	df 91       	pop	r29
     fe2:	cf 91       	pop	r28
     fe4:	08 95       	ret

00000fe6 <_ZN9ServerDrv11startServerEjh>:
}


// Start server TCP on port specified
void ServerDrv::startServer(uint16_t port, uint8_t sock)
{
     fe6:	cf 93       	push	r28
     fe8:	df 93       	push	r29
     fea:	00 d0       	rcall	.+0      	; 0xfec <_ZN9ServerDrv11startServerEjh+0x6>
     fec:	00 d0       	rcall	.+0      	; 0xfee <_ZN9ServerDrv11startServerEjh+0x8>
     fee:	1f 92       	push	r1
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
     ff4:	9c 83       	std	Y+4, r25	; 0x04
     ff6:	8b 83       	std	Y+3, r24	; 0x03
     ff8:	6d 83       	std	Y+5, r22	; 0x05
	WAIT_FOR_SLAVE_SELECT();
     ffa:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
     ffe:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(START_SERVER_TCP_CMD, PARAM_NUMS_2);
    1002:	62 e0       	ldi	r22, 0x02	; 2
    1004:	88 e2       	ldi	r24, 0x28	; 40
    1006:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam(port);
    100a:	8b 81       	ldd	r24, Y+3	; 0x03
    100c:	9c 81       	ldd	r25, Y+4	; 0x04
    100e:	60 e0       	ldi	r22, 0x00	; 0
    1010:	0e 94 a0 10 	call	0x2140	; 0x2140 <_ZN6SpiDrv9sendParamEjh>
    SpiDrv::sendParam(&sock, 1, LAST_PARAM);
    1014:	ce 01       	movw	r24, r28
    1016:	05 96       	adiw	r24, 0x05	; 5
    1018:	41 e0       	ldi	r20, 0x01	; 1
    101a:	61 e0       	ldi	r22, 0x01	; 1
    101c:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    1020:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    1024:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    1026:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseCmd(START_SERVER_TCP_CMD, PARAM_NUMS_1, &_data, &_dataLen))
    1028:	ce 01       	movw	r24, r28
    102a:	02 96       	adiw	r24, 0x02	; 2
    102c:	9c 01       	movw	r18, r24
    102e:	ce 01       	movw	r24, r28
    1030:	01 96       	adiw	r24, 0x01	; 1
    1032:	ac 01       	movw	r20, r24
    1034:	61 e0       	ldi	r22, 0x01	; 1
    1036:	88 e2       	ldi	r24, 0x28	; 40
    1038:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    {
        WARN("error waitResponse");
    }
    SpiDrv::spiSlaveDeselect();
    103c:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
}
    1040:	0f 90       	pop	r0
    1042:	0f 90       	pop	r0
    1044:	0f 90       	pop	r0
    1046:	0f 90       	pop	r0
    1048:	0f 90       	pop	r0
    104a:	df 91       	pop	r29
    104c:	cf 91       	pop	r28
    104e:	08 95       	ret

00001050 <_ZN9ServerDrv11startClientEmjh>:

// Start server TCP on port specified
void ServerDrv::startClient(uint32_t ipAddress, uint16_t port, uint8_t sock)
{
    1050:	cf 93       	push	r28
    1052:	df 93       	push	r29
    1054:	cd b7       	in	r28, 0x3d	; 61
    1056:	de b7       	in	r29, 0x3e	; 62
    1058:	29 97       	sbiw	r28, 0x09	; 9
    105a:	0f b6       	in	r0, 0x3f	; 63
    105c:	f8 94       	cli
    105e:	de bf       	out	0x3e, r29	; 62
    1060:	0f be       	out	0x3f, r0	; 63
    1062:	cd bf       	out	0x3d, r28	; 61
    1064:	6b 83       	std	Y+3, r22	; 0x03
    1066:	7c 83       	std	Y+4, r23	; 0x04
    1068:	8d 83       	std	Y+5, r24	; 0x05
    106a:	9e 83       	std	Y+6, r25	; 0x06
    106c:	58 87       	std	Y+8, r21	; 0x08
    106e:	4f 83       	std	Y+7, r20	; 0x07
    1070:	29 87       	std	Y+9, r18	; 0x09
	WAIT_FOR_SLAVE_SELECT();
    1072:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    1076:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(START_CLIENT_TCP_CMD, PARAM_NUMS_3);
    107a:	63 e0       	ldi	r22, 0x03	; 3
    107c:	8d e2       	ldi	r24, 0x2D	; 45
    107e:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam((uint8_t*)&ipAddress, sizeof(ipAddress));
    1082:	ce 01       	movw	r24, r28
    1084:	03 96       	adiw	r24, 0x03	; 3
    1086:	40 e0       	ldi	r20, 0x00	; 0
    1088:	64 e0       	ldi	r22, 0x04	; 4
    108a:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>
    SpiDrv::sendParam(port);
    108e:	8f 81       	ldd	r24, Y+7	; 0x07
    1090:	98 85       	ldd	r25, Y+8	; 0x08
    1092:	60 e0       	ldi	r22, 0x00	; 0
    1094:	0e 94 a0 10 	call	0x2140	; 0x2140 <_ZN6SpiDrv9sendParamEjh>
    SpiDrv::sendParam(&sock, 1, LAST_PARAM);
    1098:	ce 01       	movw	r24, r28
    109a:	09 96       	adiw	r24, 0x09	; 9
    109c:	41 e0       	ldi	r20, 0x01	; 1
    109e:	61 e0       	ldi	r22, 0x01	; 1
    10a0:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    10a4:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    10a8:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    10aa:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseCmd(START_CLIENT_TCP_CMD, PARAM_NUMS_1, &_data, &_dataLen))
    10ac:	ce 01       	movw	r24, r28
    10ae:	02 96       	adiw	r24, 0x02	; 2
    10b0:	9c 01       	movw	r18, r24
    10b2:	ce 01       	movw	r24, r28
    10b4:	01 96       	adiw	r24, 0x01	; 1
    10b6:	ac 01       	movw	r20, r24
    10b8:	61 e0       	ldi	r22, 0x01	; 1
    10ba:	8d e2       	ldi	r24, 0x2D	; 45
    10bc:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    {
        WARN("error waitResponse");
    }
    SpiDrv::spiSlaveDeselect();
    10c0:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
}
    10c4:	29 96       	adiw	r28, 0x09	; 9
    10c6:	0f b6       	in	r0, 0x3f	; 63
    10c8:	f8 94       	cli
    10ca:	de bf       	out	0x3e, r29	; 62
    10cc:	0f be       	out	0x3f, r0	; 63
    10ce:	cd bf       	out	0x3d, r28	; 61
    10d0:	df 91       	pop	r29
    10d2:	cf 91       	pop	r28
    10d4:	08 95       	ret

000010d6 <_ZN9ServerDrv10stopClientEh>:

// Start server TCP on port specified
void ServerDrv::stopClient(uint8_t sock)
{
    10d6:	cf 93       	push	r28
    10d8:	df 93       	push	r29
    10da:	00 d0       	rcall	.+0      	; 0x10dc <_ZN9ServerDrv10stopClientEh+0x6>
    10dc:	1f 92       	push	r1
    10de:	cd b7       	in	r28, 0x3d	; 61
    10e0:	de b7       	in	r29, 0x3e	; 62
    10e2:	8b 83       	std	Y+3, r24	; 0x03
	WAIT_FOR_SLAVE_SELECT();
    10e4:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    10e8:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(STOP_CLIENT_TCP_CMD, PARAM_NUMS_1);
    10ec:	61 e0       	ldi	r22, 0x01	; 1
    10ee:	8e e2       	ldi	r24, 0x2E	; 46
    10f0:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam(&sock, 1, LAST_PARAM);
    10f4:	ce 01       	movw	r24, r28
    10f6:	03 96       	adiw	r24, 0x03	; 3
    10f8:	41 e0       	ldi	r20, 0x01	; 1
    10fa:	61 e0       	ldi	r22, 0x01	; 1
    10fc:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    1100:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    1104:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    1106:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseCmd(STOP_CLIENT_TCP_CMD, PARAM_NUMS_1, &_data, &_dataLen))
    1108:	ce 01       	movw	r24, r28
    110a:	02 96       	adiw	r24, 0x02	; 2
    110c:	9c 01       	movw	r18, r24
    110e:	ce 01       	movw	r24, r28
    1110:	01 96       	adiw	r24, 0x01	; 1
    1112:	ac 01       	movw	r20, r24
    1114:	61 e0       	ldi	r22, 0x01	; 1
    1116:	8e e2       	ldi	r24, 0x2E	; 46
    1118:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    {
        WARN("error waitResponse");
    }
    SpiDrv::spiSlaveDeselect();
    111c:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
}
    1120:	0f 90       	pop	r0
    1122:	0f 90       	pop	r0
    1124:	0f 90       	pop	r0
    1126:	df 91       	pop	r29
    1128:	cf 91       	pop	r28
    112a:	08 95       	ret

0000112c <_ZN9ServerDrv14getServerStateEh>:


uint8_t ServerDrv::getServerState(uint8_t sock)
{
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	00 d0       	rcall	.+0      	; 0x1132 <_ZN9ServerDrv14getServerStateEh+0x6>
    1132:	1f 92       	push	r1
    1134:	cd b7       	in	r28, 0x3d	; 61
    1136:	de b7       	in	r29, 0x3e	; 62
    1138:	8b 83       	std	Y+3, r24	; 0x03
	WAIT_FOR_SLAVE_SELECT();
    113a:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    113e:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(GET_STATE_TCP_CMD, PARAM_NUMS_1);
    1142:	61 e0       	ldi	r22, 0x01	; 1
    1144:	89 e2       	ldi	r24, 0x29	; 41
    1146:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam(&sock, sizeof(sock), LAST_PARAM);
    114a:	ce 01       	movw	r24, r28
    114c:	03 96       	adiw	r24, 0x03	; 3
    114e:	41 e0       	ldi	r20, 0x01	; 1
    1150:	61 e0       	ldi	r22, 0x01	; 1
    1152:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    1156:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    115a:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    115c:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseCmd(GET_STATE_TCP_CMD, PARAM_NUMS_1, &_data, &_dataLen))
    115e:	ce 01       	movw	r24, r28
    1160:	02 96       	adiw	r24, 0x02	; 2
    1162:	9c 01       	movw	r18, r24
    1164:	ce 01       	movw	r24, r28
    1166:	01 96       	adiw	r24, 0x01	; 1
    1168:	ac 01       	movw	r20, r24
    116a:	61 e0       	ldi	r22, 0x01	; 1
    116c:	89 e2       	ldi	r24, 0x29	; 41
    116e:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    {
        WARN("error waitResponse");
    }
    SpiDrv::spiSlaveDeselect();
    1172:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
   return _data;
    1176:	89 81       	ldd	r24, Y+1	; 0x01
}
    1178:	0f 90       	pop	r0
    117a:	0f 90       	pop	r0
    117c:	0f 90       	pop	r0
    117e:	df 91       	pop	r29
    1180:	cf 91       	pop	r28
    1182:	08 95       	ret

00001184 <_ZN9ServerDrv14getClientStateEh>:

uint8_t ServerDrv::getClientState(uint8_t sock)
{
    1184:	cf 93       	push	r28
    1186:	df 93       	push	r29
    1188:	00 d0       	rcall	.+0      	; 0x118a <_ZN9ServerDrv14getClientStateEh+0x6>
    118a:	1f 92       	push	r1
    118c:	cd b7       	in	r28, 0x3d	; 61
    118e:	de b7       	in	r29, 0x3e	; 62
    1190:	8b 83       	std	Y+3, r24	; 0x03
	WAIT_FOR_SLAVE_SELECT();
    1192:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    1196:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(GET_CLIENT_STATE_TCP_CMD, PARAM_NUMS_1);
    119a:	61 e0       	ldi	r22, 0x01	; 1
    119c:	8f e2       	ldi	r24, 0x2F	; 47
    119e:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam(&sock, sizeof(sock), LAST_PARAM);
    11a2:	ce 01       	movw	r24, r28
    11a4:	03 96       	adiw	r24, 0x03	; 3
    11a6:	41 e0       	ldi	r20, 0x01	; 1
    11a8:	61 e0       	ldi	r22, 0x01	; 1
    11aa:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    11ae:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    11b2:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    11b4:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseCmd(GET_CLIENT_STATE_TCP_CMD, PARAM_NUMS_1, &_data, &_dataLen))
    11b6:	ce 01       	movw	r24, r28
    11b8:	02 96       	adiw	r24, 0x02	; 2
    11ba:	9c 01       	movw	r18, r24
    11bc:	ce 01       	movw	r24, r28
    11be:	01 96       	adiw	r24, 0x01	; 1
    11c0:	ac 01       	movw	r20, r24
    11c2:	61 e0       	ldi	r22, 0x01	; 1
    11c4:	8f e2       	ldi	r24, 0x2F	; 47
    11c6:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    {
        WARN("error waitResponse");
    }
    SpiDrv::spiSlaveDeselect();
    11ca:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
   return _data;
    11ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    11d0:	0f 90       	pop	r0
    11d2:	0f 90       	pop	r0
    11d4:	0f 90       	pop	r0
    11d6:	df 91       	pop	r29
    11d8:	cf 91       	pop	r28
    11da:	08 95       	ret

000011dc <_ZN9ServerDrv9availDataEh>:

uint8_t ServerDrv::availData(uint8_t sock)
{
    11dc:	cf 93       	push	r28
    11de:	df 93       	push	r29
    11e0:	00 d0       	rcall	.+0      	; 0x11e2 <_ZN9ServerDrv9availDataEh+0x6>
    11e2:	1f 92       	push	r1
    11e4:	cd b7       	in	r28, 0x3d	; 61
    11e6:	de b7       	in	r29, 0x3e	; 62
    11e8:	8b 83       	std	Y+3, r24	; 0x03
	WAIT_FOR_SLAVE_SELECT();
    11ea:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    11ee:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(AVAIL_DATA_TCP_CMD, PARAM_NUMS_1);
    11f2:	61 e0       	ldi	r22, 0x01	; 1
    11f4:	8b e2       	ldi	r24, 0x2B	; 43
    11f6:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam(&sock, sizeof(sock), LAST_PARAM);
    11fa:	ce 01       	movw	r24, r28
    11fc:	03 96       	adiw	r24, 0x03	; 3
    11fe:	41 e0       	ldi	r20, 0x01	; 1
    1200:	61 e0       	ldi	r22, 0x01	; 1
    1202:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    1206:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    120a:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    120c:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseCmd(AVAIL_DATA_TCP_CMD, PARAM_NUMS_1, &_data, &_dataLen))
    120e:	ce 01       	movw	r24, r28
    1210:	02 96       	adiw	r24, 0x02	; 2
    1212:	9c 01       	movw	r18, r24
    1214:	ce 01       	movw	r24, r28
    1216:	01 96       	adiw	r24, 0x01	; 1
    1218:	ac 01       	movw	r20, r24
    121a:	61 e0       	ldi	r22, 0x01	; 1
    121c:	8b e2       	ldi	r24, 0x2B	; 43
    121e:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    {
        WARN("error waitResponse");
    }
    SpiDrv::spiSlaveDeselect();
    1222:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    if (_dataLen!=0)
    1226:	8a 81       	ldd	r24, Y+2	; 0x02
    1228:	88 23       	and	r24, r24
    122a:	31 f0       	breq	.+12     	; 0x1238 <_ZN9ServerDrv9availDataEh+0x5c>
    {
        return (_data == 1);
    122c:	99 81       	ldd	r25, Y+1	; 0x01
    122e:	81 e0       	ldi	r24, 0x01	; 1
    1230:	91 30       	cpi	r25, 0x01	; 1
    1232:	09 f0       	breq	.+2      	; 0x1236 <_ZN9ServerDrv9availDataEh+0x5a>
    1234:	80 e0       	ldi	r24, 0x00	; 0
    1236:	01 c0       	rjmp	.+2      	; 0x123a <_ZN9ServerDrv9availDataEh+0x5e>
    }
    return false;
    1238:	80 e0       	ldi	r24, 0x00	; 0
}
    123a:	0f 90       	pop	r0
    123c:	0f 90       	pop	r0
    123e:	0f 90       	pop	r0
    1240:	df 91       	pop	r29
    1242:	cf 91       	pop	r28
    1244:	08 95       	ret

00001246 <_ZN9ServerDrv7getDataEhPhh>:

bool ServerDrv::getData(uint8_t sock, uint8_t *data, uint8_t peek)
{
    1246:	cf 93       	push	r28
    1248:	df 93       	push	r29
    124a:	00 d0       	rcall	.+0      	; 0x124c <_ZN9ServerDrv7getDataEhPhh+0x6>
    124c:	00 d0       	rcall	.+0      	; 0x124e <_ZN9ServerDrv7getDataEhPhh+0x8>
    124e:	00 d0       	rcall	.+0      	; 0x1250 <_ZN9ServerDrv7getDataEhPhh+0xa>
    1250:	cd b7       	in	r28, 0x3d	; 61
    1252:	de b7       	in	r29, 0x3e	; 62
    1254:	8b 83       	std	Y+3, r24	; 0x03
    1256:	7d 83       	std	Y+5, r23	; 0x05
    1258:	6c 83       	std	Y+4, r22	; 0x04
    125a:	4e 83       	std	Y+6, r20	; 0x06
	WAIT_FOR_SLAVE_SELECT();
    125c:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    1260:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(GET_DATA_TCP_CMD, PARAM_NUMS_2);
    1264:	62 e0       	ldi	r22, 0x02	; 2
    1266:	8c e2       	ldi	r24, 0x2C	; 44
    1268:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam(&sock, sizeof(sock));
    126c:	ce 01       	movw	r24, r28
    126e:	03 96       	adiw	r24, 0x03	; 3
    1270:	40 e0       	ldi	r20, 0x00	; 0
    1272:	61 e0       	ldi	r22, 0x01	; 1
    1274:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>
    SpiDrv::sendParam(peek, LAST_PARAM);
    1278:	8e 81       	ldd	r24, Y+6	; 0x06
    127a:	88 2f       	mov	r24, r24
    127c:	90 e0       	ldi	r25, 0x00	; 0
    127e:	61 e0       	ldi	r22, 0x01	; 1
    1280:	0e 94 a0 10 	call	0x2140	; 0x2140 <_ZN6SpiDrv9sendParamEjh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    1284:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    1288:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    128a:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseData8(GET_DATA_TCP_CMD, &_data, &_dataLen))
    128c:	ce 01       	movw	r24, r28
    128e:	02 96       	adiw	r24, 0x02	; 2
    1290:	ac 01       	movw	r20, r24
    1292:	ce 01       	movw	r24, r28
    1294:	01 96       	adiw	r24, 0x01	; 1
    1296:	bc 01       	movw	r22, r24
    1298:	8c e2       	ldi	r24, 0x2C	; 44
    129a:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <_ZN6SpiDrv17waitResponseData8EhPhS0_>
    {
        WARN("error waitResponse");
    }
    SpiDrv::spiSlaveDeselect();
    129e:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
    if (_dataLen!=0)
    12a2:	8a 81       	ldd	r24, Y+2	; 0x02
    12a4:	88 23       	and	r24, r24
    12a6:	39 f0       	breq	.+14     	; 0x12b6 <_ZN9ServerDrv7getDataEhPhh+0x70>
    {
        *data = _data;
    12a8:	29 81       	ldd	r18, Y+1	; 0x01
    12aa:	8c 81       	ldd	r24, Y+4	; 0x04
    12ac:	9d 81       	ldd	r25, Y+5	; 0x05
    12ae:	fc 01       	movw	r30, r24
    12b0:	20 83       	st	Z, r18
        return true;
    12b2:	81 e0       	ldi	r24, 0x01	; 1
    12b4:	01 c0       	rjmp	.+2      	; 0x12b8 <_ZN9ServerDrv7getDataEhPhh+0x72>
    }
    return false;
    12b6:	80 e0       	ldi	r24, 0x00	; 0
}
    12b8:	26 96       	adiw	r28, 0x06	; 6
    12ba:	0f b6       	in	r0, 0x3f	; 63
    12bc:	f8 94       	cli
    12be:	de bf       	out	0x3e, r29	; 62
    12c0:	0f be       	out	0x3f, r0	; 63
    12c2:	cd bf       	out	0x3d, r28	; 61
    12c4:	df 91       	pop	r29
    12c6:	cf 91       	pop	r28
    12c8:	08 95       	ret

000012ca <_ZN9ServerDrv10getDataBufEhPhPj>:

bool ServerDrv::getDataBuf(uint8_t sock, uint8_t *_data, uint16_t *_dataLen)
{
    12ca:	cf 93       	push	r28
    12cc:	df 93       	push	r29
    12ce:	00 d0       	rcall	.+0      	; 0x12d0 <_ZN9ServerDrv10getDataBufEhPhPj+0x6>
    12d0:	00 d0       	rcall	.+0      	; 0x12d2 <_ZN9ServerDrv10getDataBufEhPhPj+0x8>
    12d2:	1f 92       	push	r1
    12d4:	cd b7       	in	r28, 0x3d	; 61
    12d6:	de b7       	in	r29, 0x3e	; 62
    12d8:	89 83       	std	Y+1, r24	; 0x01
    12da:	7b 83       	std	Y+3, r23	; 0x03
    12dc:	6a 83       	std	Y+2, r22	; 0x02
    12de:	5d 83       	std	Y+5, r21	; 0x05
    12e0:	4c 83       	std	Y+4, r20	; 0x04
	WAIT_FOR_SLAVE_SELECT();
    12e2:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    12e6:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(GET_DATABUF_TCP_CMD, PARAM_NUMS_1);
    12ea:	61 e0       	ldi	r22, 0x01	; 1
    12ec:	85 e4       	ldi	r24, 0x45	; 69
    12ee:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendBuffer(&sock, sizeof(sock), LAST_PARAM);
    12f2:	41 e0       	ldi	r20, 0x01	; 1
    12f4:	61 e0       	ldi	r22, 0x01	; 1
    12f6:	70 e0       	ldi	r23, 0x00	; 0
    12f8:	ce 01       	movw	r24, r28
    12fa:	01 96       	adiw	r24, 0x01	; 1
    12fc:	0e 94 5f 10 	call	0x20be	; 0x20be <_ZN6SpiDrv10sendBufferEPhjh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    1300:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    if (!SpiDrv::waitResponseData16(GET_DATABUF_TCP_CMD, _data, _dataLen))
    1304:	2c 81       	ldd	r18, Y+4	; 0x04
    1306:	3d 81       	ldd	r19, Y+5	; 0x05
    1308:	8a 81       	ldd	r24, Y+2	; 0x02
    130a:	9b 81       	ldd	r25, Y+3	; 0x03
    130c:	a9 01       	movw	r20, r18
    130e:	bc 01       	movw	r22, r24
    1310:	85 e4       	ldi	r24, 0x45	; 69
    1312:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <_ZN6SpiDrv18waitResponseData16EhPhPj>
    {
        WARN("error waitResponse");
    }
    SpiDrv::spiSlaveDeselect();
    1316:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
    if (*_dataLen!=0)
    131a:	8c 81       	ldd	r24, Y+4	; 0x04
    131c:	9d 81       	ldd	r25, Y+5	; 0x05
    131e:	fc 01       	movw	r30, r24
    1320:	80 81       	ld	r24, Z
    1322:	91 81       	ldd	r25, Z+1	; 0x01
    1324:	00 97       	sbiw	r24, 0x00	; 0
    1326:	11 f0       	breq	.+4      	; 0x132c <_ZN9ServerDrv10getDataBufEhPhPj+0x62>
    {
        return true;
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	01 c0       	rjmp	.+2      	; 0x132e <_ZN9ServerDrv10getDataBufEhPhPj+0x64>
    }
    return false;
    132c:	80 e0       	ldi	r24, 0x00	; 0
}
    132e:	0f 90       	pop	r0
    1330:	0f 90       	pop	r0
    1332:	0f 90       	pop	r0
    1334:	0f 90       	pop	r0
    1336:	0f 90       	pop	r0
    1338:	df 91       	pop	r29
    133a:	cf 91       	pop	r28
    133c:	08 95       	ret

0000133e <_ZN9ServerDrv8sendDataEhPKhj>:


bool ServerDrv::sendData(uint8_t sock, const uint8_t *data, uint16_t len)
{
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	cd b7       	in	r28, 0x3d	; 61
    1344:	de b7       	in	r29, 0x3e	; 62
    1346:	27 97       	sbiw	r28, 0x07	; 7
    1348:	0f b6       	in	r0, 0x3f	; 63
    134a:	f8 94       	cli
    134c:	de bf       	out	0x3e, r29	; 62
    134e:	0f be       	out	0x3f, r0	; 63
    1350:	cd bf       	out	0x3d, r28	; 61
    1352:	8b 83       	std	Y+3, r24	; 0x03
    1354:	7d 83       	std	Y+5, r23	; 0x05
    1356:	6c 83       	std	Y+4, r22	; 0x04
    1358:	5f 83       	std	Y+7, r21	; 0x07
    135a:	4e 83       	std	Y+6, r20	; 0x06
	WAIT_FOR_SLAVE_SELECT();
    135c:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    1360:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(SEND_DATA_TCP_CMD, PARAM_NUMS_2);
    1364:	62 e0       	ldi	r22, 0x02	; 2
    1366:	84 e4       	ldi	r24, 0x44	; 68
    1368:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendBuffer(&sock, sizeof(sock));
    136c:	ce 01       	movw	r24, r28
    136e:	03 96       	adiw	r24, 0x03	; 3
    1370:	40 e0       	ldi	r20, 0x00	; 0
    1372:	61 e0       	ldi	r22, 0x01	; 1
    1374:	70 e0       	ldi	r23, 0x00	; 0
    1376:	0e 94 5f 10 	call	0x20be	; 0x20be <_ZN6SpiDrv10sendBufferEPhjh>
    SpiDrv::sendBuffer((uint8_t *)data, len, LAST_PARAM);
    137a:	2e 81       	ldd	r18, Y+6	; 0x06
    137c:	3f 81       	ldd	r19, Y+7	; 0x07
    137e:	8c 81       	ldd	r24, Y+4	; 0x04
    1380:	9d 81       	ldd	r25, Y+5	; 0x05
    1382:	41 e0       	ldi	r20, 0x01	; 1
    1384:	b9 01       	movw	r22, r18
    1386:	0e 94 5f 10 	call	0x20be	; 0x20be <_ZN6SpiDrv10sendBufferEPhjh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    138a:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    138e:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    1390:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseData8(SEND_DATA_TCP_CMD, &_data, &_dataLen))
    1392:	ce 01       	movw	r24, r28
    1394:	02 96       	adiw	r24, 0x02	; 2
    1396:	ac 01       	movw	r20, r24
    1398:	ce 01       	movw	r24, r28
    139a:	01 96       	adiw	r24, 0x01	; 1
    139c:	bc 01       	movw	r22, r24
    139e:	84 e4       	ldi	r24, 0x44	; 68
    13a0:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <_ZN6SpiDrv17waitResponseData8EhPhS0_>
    {
        WARN("error waitResponse");
    }
    SpiDrv::spiSlaveDeselect();
    13a4:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
    if (_dataLen!=0)
    13a8:	8a 81       	ldd	r24, Y+2	; 0x02
    13aa:	88 23       	and	r24, r24
    13ac:	31 f0       	breq	.+12     	; 0x13ba <_ZN9ServerDrv8sendDataEhPKhj+0x7c>
    {
        return (_data == 1);
    13ae:	99 81       	ldd	r25, Y+1	; 0x01
    13b0:	81 e0       	ldi	r24, 0x01	; 1
    13b2:	91 30       	cpi	r25, 0x01	; 1
    13b4:	19 f0       	breq	.+6      	; 0x13bc <_ZN9ServerDrv8sendDataEhPKhj+0x7e>
    13b6:	80 e0       	ldi	r24, 0x00	; 0
    13b8:	01 c0       	rjmp	.+2      	; 0x13bc <_ZN9ServerDrv8sendDataEhPKhj+0x7e>
    }
    return false;
    13ba:	80 e0       	ldi	r24, 0x00	; 0
}
    13bc:	27 96       	adiw	r28, 0x07	; 7
    13be:	0f b6       	in	r0, 0x3f	; 63
    13c0:	f8 94       	cli
    13c2:	de bf       	out	0x3e, r29	; 62
    13c4:	0f be       	out	0x3f, r0	; 63
    13c6:	cd bf       	out	0x3d, r28	; 61
    13c8:	df 91       	pop	r29
    13ca:	cf 91       	pop	r28
    13cc:	08 95       	ret

000013ce <_ZN9ServerDrv13checkDataSentEh>:


uint8_t ServerDrv::checkDataSent(uint8_t sock)
{
    13ce:	cf 93       	push	r28
    13d0:	df 93       	push	r29
    13d2:	cd b7       	in	r28, 0x3d	; 61
    13d4:	de b7       	in	r29, 0x3e	; 62
    13d6:	27 97       	sbiw	r28, 0x07	; 7
    13d8:	0f b6       	in	r0, 0x3f	; 63
    13da:	f8 94       	cli
    13dc:	de bf       	out	0x3e, r29	; 62
    13de:	0f be       	out	0x3f, r0	; 63
    13e0:	cd bf       	out	0x3d, r28	; 61
    13e2:	8f 83       	std	Y+7, r24	; 0x07
	const uint16_t TIMEOUT_DATA_SENT = 25;
    13e4:	89 e1       	ldi	r24, 0x19	; 25
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	9c 83       	std	Y+4, r25	; 0x04
    13ea:	8b 83       	std	Y+3, r24	; 0x03
    uint16_t timeout = 0;
    13ec:	1a 82       	std	Y+2, r1	; 0x02
    13ee:	19 82       	std	Y+1, r1	; 0x01
	uint8_t _data = 0;
    13f0:	1d 82       	std	Y+5, r1	; 0x05
	uint8_t _dataLen = 0;
    13f2:	1e 82       	std	Y+6, r1	; 0x06

	do {
		WAIT_FOR_SLAVE_SELECT();
    13f4:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    13f8:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
		// Send Command
		SpiDrv::sendCmd(DATA_SENT_TCP_CMD, PARAM_NUMS_1);
    13fc:	61 e0       	ldi	r22, 0x01	; 1
    13fe:	8a e2       	ldi	r24, 0x2A	; 42
    1400:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
		SpiDrv::sendParam(&sock, sizeof(sock), LAST_PARAM);
    1404:	ce 01       	movw	r24, r28
    1406:	07 96       	adiw	r24, 0x07	; 7
    1408:	41 e0       	ldi	r20, 0x01	; 1
    140a:	61 e0       	ldi	r22, 0x01	; 1
    140c:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

		//Wait the reply elaboration
		SpiDrv::waitForSlaveReady();
    1410:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

		// Wait for reply
		if (!SpiDrv::waitResponseCmd(DATA_SENT_TCP_CMD, PARAM_NUMS_1, &_data, &_dataLen))
    1414:	9e 01       	movw	r18, r28
    1416:	2a 5f       	subi	r18, 0xFA	; 250
    1418:	3f 4f       	sbci	r19, 0xFF	; 255
    141a:	ce 01       	movw	r24, r28
    141c:	05 96       	adiw	r24, 0x05	; 5
    141e:	ac 01       	movw	r20, r24
    1420:	61 e0       	ldi	r22, 0x01	; 1
    1422:	8a e2       	ldi	r24, 0x2A	; 42
    1424:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
		{
			WARN("error waitResponse isDataSent");
		}
		SpiDrv::spiSlaveDeselect();
    1428:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

		if (_data) timeout = 0;
    142c:	8d 81       	ldd	r24, Y+5	; 0x05
    142e:	88 23       	and	r24, r24
    1430:	19 f0       	breq	.+6      	; 0x1438 <_ZN9ServerDrv13checkDataSentEh+0x6a>
    1432:	1a 82       	std	Y+2, r1	; 0x02
    1434:	19 82       	std	Y+1, r1	; 0x01
    1436:	0b c0       	rjmp	.+22     	; 0x144e <_ZN9ServerDrv13checkDataSentEh+0x80>
		else{
			++timeout;
    1438:	89 81       	ldd	r24, Y+1	; 0x01
    143a:	9a 81       	ldd	r25, Y+2	; 0x02
    143c:	01 96       	adiw	r24, 0x01	; 1
    143e:	9a 83       	std	Y+2, r25	; 0x02
    1440:	89 83       	std	Y+1, r24	; 0x01
			delay(100);
    1442:	64 e6       	ldi	r22, 0x64	; 100
    1444:	70 e0       	ldi	r23, 0x00	; 0
    1446:	80 e0       	ldi	r24, 0x00	; 0
    1448:	90 e0       	ldi	r25, 0x00	; 0
    144a:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
	const uint16_t TIMEOUT_DATA_SENT = 25;
    uint16_t timeout = 0;
	uint8_t _data = 0;
	uint8_t _dataLen = 0;

	do {
    144e:	8d 81       	ldd	r24, Y+5	; 0x05
    1450:	88 23       	and	r24, r24
    1452:	39 f4       	brne	.+14     	; 0x1462 <_ZN9ServerDrv13checkDataSentEh+0x94>
    1454:	89 81       	ldd	r24, Y+1	; 0x01
    1456:	9a 81       	ldd	r25, Y+2	; 0x02
    1458:	89 31       	cpi	r24, 0x19	; 25
    145a:	91 05       	cpc	r25, r1
    145c:	10 f4       	brcc	.+4      	; 0x1462 <_ZN9ServerDrv13checkDataSentEh+0x94>
    145e:	81 e0       	ldi	r24, 0x01	; 1
    1460:	01 c0       	rjmp	.+2      	; 0x1464 <_ZN9ServerDrv13checkDataSentEh+0x96>
    1462:	80 e0       	ldi	r24, 0x00	; 0
    1464:	88 23       	and	r24, r24
    1466:	31 f6       	brne	.-116    	; 0x13f4 <_ZN9ServerDrv13checkDataSentEh+0x26>
			++timeout;
			delay(100);
		}

	}while((_data==0)&&(timeout<TIMEOUT_DATA_SENT));
    return (timeout==TIMEOUT_DATA_SENT)?0:1;
    1468:	21 e0       	ldi	r18, 0x01	; 1
    146a:	89 81       	ldd	r24, Y+1	; 0x01
    146c:	9a 81       	ldd	r25, Y+2	; 0x02
    146e:	89 31       	cpi	r24, 0x19	; 25
    1470:	91 05       	cpc	r25, r1
    1472:	09 f4       	brne	.+2      	; 0x1476 <_ZN9ServerDrv13checkDataSentEh+0xa8>
    1474:	20 e0       	ldi	r18, 0x00	; 0
    1476:	82 2f       	mov	r24, r18
}
    1478:	27 96       	adiw	r28, 0x07	; 7
    147a:	0f b6       	in	r0, 0x3f	; 63
    147c:	f8 94       	cli
    147e:	de bf       	out	0x3e, r29	; 62
    1480:	0f be       	out	0x3f, r0	; 63
    1482:	cd bf       	out	0x3d, r28	; 61
    1484:	df 91       	pop	r29
    1486:	cf 91       	pop	r28
    1488:	08 95       	ret

0000148a <socket>:
*
*/
#include <inttypes.h>
#include "socket.h"

SOCKET socket(uint8 protocol) {return 0;} // Opens a socket(TCP or UDP or IP_RAW mode)
    148a:	cf 93       	push	r28
    148c:	df 93       	push	r29
    148e:	1f 92       	push	r1
    1490:	cd b7       	in	r28, 0x3d	; 61
    1492:	de b7       	in	r29, 0x3e	; 62
    1494:	89 83       	std	Y+1, r24	; 0x01
    1496:	80 e0       	ldi	r24, 0x00	; 0
    1498:	90 e0       	ldi	r25, 0x00	; 0
    149a:	0f 90       	pop	r0
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	08 95       	ret

000014a2 <close>:
void close(SOCKET s) {} // Close socket
    14a2:	cf 93       	push	r28
    14a4:	df 93       	push	r29
    14a6:	00 d0       	rcall	.+0      	; 0x14a8 <close+0x6>
    14a8:	cd b7       	in	r28, 0x3d	; 61
    14aa:	de b7       	in	r29, 0x3e	; 62
    14ac:	9a 83       	std	Y+2, r25	; 0x02
    14ae:	89 83       	std	Y+1, r24	; 0x01
    14b0:	0f 90       	pop	r0
    14b2:	0f 90       	pop	r0
    14b4:	df 91       	pop	r29
    14b6:	cf 91       	pop	r28
    14b8:	08 95       	ret

000014ba <connect>:
uint8 connect(SOCKET s, uint8 * addr, uint16 port) {return 0;} // Establish TCP connection (Active connection)
    14ba:	cf 93       	push	r28
    14bc:	df 93       	push	r29
    14be:	00 d0       	rcall	.+0      	; 0x14c0 <connect+0x6>
    14c0:	00 d0       	rcall	.+0      	; 0x14c2 <connect+0x8>
    14c2:	00 d0       	rcall	.+0      	; 0x14c4 <connect+0xa>
    14c4:	cd b7       	in	r28, 0x3d	; 61
    14c6:	de b7       	in	r29, 0x3e	; 62
    14c8:	9a 83       	std	Y+2, r25	; 0x02
    14ca:	89 83       	std	Y+1, r24	; 0x01
    14cc:	7c 83       	std	Y+4, r23	; 0x04
    14ce:	6b 83       	std	Y+3, r22	; 0x03
    14d0:	5e 83       	std	Y+6, r21	; 0x06
    14d2:	4d 83       	std	Y+5, r20	; 0x05
    14d4:	80 e0       	ldi	r24, 0x00	; 0
    14d6:	26 96       	adiw	r28, 0x06	; 6
    14d8:	0f b6       	in	r0, 0x3f	; 63
    14da:	f8 94       	cli
    14dc:	de bf       	out	0x3e, r29	; 62
    14de:	0f be       	out	0x3f, r0	; 63
    14e0:	cd bf       	out	0x3d, r28	; 61
    14e2:	df 91       	pop	r29
    14e4:	cf 91       	pop	r28
    14e6:	08 95       	ret

000014e8 <disconnect>:
void disconnect(SOCKET s) {} // disconnect the connection
    14e8:	cf 93       	push	r28
    14ea:	df 93       	push	r29
    14ec:	00 d0       	rcall	.+0      	; 0x14ee <disconnect+0x6>
    14ee:	cd b7       	in	r28, 0x3d	; 61
    14f0:	de b7       	in	r29, 0x3e	; 62
    14f2:	9a 83       	std	Y+2, r25	; 0x02
    14f4:	89 83       	std	Y+1, r24	; 0x01
    14f6:	0f 90       	pop	r0
    14f8:	0f 90       	pop	r0
    14fa:	df 91       	pop	r29
    14fc:	cf 91       	pop	r28
    14fe:	08 95       	ret

00001500 <listen>:
uint8 listen(SOCKET s) { return 0;}	// Establish TCP connection (Passive connection)
    1500:	cf 93       	push	r28
    1502:	df 93       	push	r29
    1504:	00 d0       	rcall	.+0      	; 0x1506 <listen+0x6>
    1506:	cd b7       	in	r28, 0x3d	; 61
    1508:	de b7       	in	r29, 0x3e	; 62
    150a:	9a 83       	std	Y+2, r25	; 0x02
    150c:	89 83       	std	Y+1, r24	; 0x01
    150e:	80 e0       	ldi	r24, 0x00	; 0
    1510:	0f 90       	pop	r0
    1512:	0f 90       	pop	r0
    1514:	df 91       	pop	r29
    1516:	cf 91       	pop	r28
    1518:	08 95       	ret

0000151a <send>:
uint16 send(SOCKET s, const uint8 * buf, uint16 len) { return 0;} // Send data (TCP)
    151a:	cf 93       	push	r28
    151c:	df 93       	push	r29
    151e:	00 d0       	rcall	.+0      	; 0x1520 <send+0x6>
    1520:	00 d0       	rcall	.+0      	; 0x1522 <send+0x8>
    1522:	00 d0       	rcall	.+0      	; 0x1524 <send+0xa>
    1524:	cd b7       	in	r28, 0x3d	; 61
    1526:	de b7       	in	r29, 0x3e	; 62
    1528:	9a 83       	std	Y+2, r25	; 0x02
    152a:	89 83       	std	Y+1, r24	; 0x01
    152c:	7c 83       	std	Y+4, r23	; 0x04
    152e:	6b 83       	std	Y+3, r22	; 0x03
    1530:	5e 83       	std	Y+6, r21	; 0x06
    1532:	4d 83       	std	Y+5, r20	; 0x05
    1534:	80 e0       	ldi	r24, 0x00	; 0
    1536:	90 e0       	ldi	r25, 0x00	; 0
    1538:	26 96       	adiw	r28, 0x06	; 6
    153a:	0f b6       	in	r0, 0x3f	; 63
    153c:	f8 94       	cli
    153e:	de bf       	out	0x3e, r29	; 62
    1540:	0f be       	out	0x3f, r0	; 63
    1542:	cd bf       	out	0x3d, r28	; 61
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	08 95       	ret

0000154a <recv>:
uint16 recv(SOCKET s, uint8 * buf, uint16 len) {return 0;}	// Receive data (TCP)
    154a:	cf 93       	push	r28
    154c:	df 93       	push	r29
    154e:	00 d0       	rcall	.+0      	; 0x1550 <recv+0x6>
    1550:	00 d0       	rcall	.+0      	; 0x1552 <recv+0x8>
    1552:	00 d0       	rcall	.+0      	; 0x1554 <recv+0xa>
    1554:	cd b7       	in	r28, 0x3d	; 61
    1556:	de b7       	in	r29, 0x3e	; 62
    1558:	9a 83       	std	Y+2, r25	; 0x02
    155a:	89 83       	std	Y+1, r24	; 0x01
    155c:	7c 83       	std	Y+4, r23	; 0x04
    155e:	6b 83       	std	Y+3, r22	; 0x03
    1560:	5e 83       	std	Y+6, r21	; 0x06
    1562:	4d 83       	std	Y+5, r20	; 0x05
    1564:	80 e0       	ldi	r24, 0x00	; 0
    1566:	90 e0       	ldi	r25, 0x00	; 0
    1568:	26 96       	adiw	r28, 0x06	; 6
    156a:	0f b6       	in	r0, 0x3f	; 63
    156c:	f8 94       	cli
    156e:	de bf       	out	0x3e, r29	; 62
    1570:	0f be       	out	0x3f, r0	; 63
    1572:	cd bf       	out	0x3d, r28	; 61
    1574:	df 91       	pop	r29
    1576:	cf 91       	pop	r28
    1578:	08 95       	ret

0000157a <sendto>:
uint16 sendto(SOCKET s, const uint8 * buf, uint16 len, uint8 * addr, uint16 port) {return 0;} // Send data (UDP/IP RAW)
    157a:	0f 93       	push	r16
    157c:	1f 93       	push	r17
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	cd b7       	in	r28, 0x3d	; 61
    1584:	de b7       	in	r29, 0x3e	; 62
    1586:	2a 97       	sbiw	r28, 0x0a	; 10
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	f8 94       	cli
    158c:	de bf       	out	0x3e, r29	; 62
    158e:	0f be       	out	0x3f, r0	; 63
    1590:	cd bf       	out	0x3d, r28	; 61
    1592:	9a 83       	std	Y+2, r25	; 0x02
    1594:	89 83       	std	Y+1, r24	; 0x01
    1596:	7c 83       	std	Y+4, r23	; 0x04
    1598:	6b 83       	std	Y+3, r22	; 0x03
    159a:	5e 83       	std	Y+6, r21	; 0x06
    159c:	4d 83       	std	Y+5, r20	; 0x05
    159e:	38 87       	std	Y+8, r19	; 0x08
    15a0:	2f 83       	std	Y+7, r18	; 0x07
    15a2:	1a 87       	std	Y+10, r17	; 0x0a
    15a4:	09 87       	std	Y+9, r16	; 0x09
    15a6:	80 e0       	ldi	r24, 0x00	; 0
    15a8:	90 e0       	ldi	r25, 0x00	; 0
    15aa:	2a 96       	adiw	r28, 0x0a	; 10
    15ac:	0f b6       	in	r0, 0x3f	; 63
    15ae:	f8 94       	cli
    15b0:	de bf       	out	0x3e, r29	; 62
    15b2:	0f be       	out	0x3f, r0	; 63
    15b4:	cd bf       	out	0x3d, r28	; 61
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	08 95       	ret

000015c0 <recvfrom>:
uint16 recvfrom(SOCKET s, uint8 * buf, uint16 len, uint8 * addr, uint16  *port) {return 0;} // Receive data (UDP/IP RAW)
    15c0:	0f 93       	push	r16
    15c2:	1f 93       	push	r17
    15c4:	cf 93       	push	r28
    15c6:	df 93       	push	r29
    15c8:	cd b7       	in	r28, 0x3d	; 61
    15ca:	de b7       	in	r29, 0x3e	; 62
    15cc:	2a 97       	sbiw	r28, 0x0a	; 10
    15ce:	0f b6       	in	r0, 0x3f	; 63
    15d0:	f8 94       	cli
    15d2:	de bf       	out	0x3e, r29	; 62
    15d4:	0f be       	out	0x3f, r0	; 63
    15d6:	cd bf       	out	0x3d, r28	; 61
    15d8:	9a 83       	std	Y+2, r25	; 0x02
    15da:	89 83       	std	Y+1, r24	; 0x01
    15dc:	7c 83       	std	Y+4, r23	; 0x04
    15de:	6b 83       	std	Y+3, r22	; 0x03
    15e0:	5e 83       	std	Y+6, r21	; 0x06
    15e2:	4d 83       	std	Y+5, r20	; 0x05
    15e4:	38 87       	std	Y+8, r19	; 0x08
    15e6:	2f 83       	std	Y+7, r18	; 0x07
    15e8:	1a 87       	std	Y+10, r17	; 0x0a
    15ea:	09 87       	std	Y+9, r16	; 0x09
    15ec:	80 e0       	ldi	r24, 0x00	; 0
    15ee:	90 e0       	ldi	r25, 0x00	; 0
    15f0:	2a 96       	adiw	r28, 0x0a	; 10
    15f2:	0f b6       	in	r0, 0x3f	; 63
    15f4:	f8 94       	cli
    15f6:	de bf       	out	0x3e, r29	; 62
    15f8:	0f be       	out	0x3f, r0	; 63
    15fa:	cd bf       	out	0x3d, r28	; 61
    15fc:	df 91       	pop	r29
    15fe:	cf 91       	pop	r28
    1600:	1f 91       	pop	r17
    1602:	0f 91       	pop	r16
    1604:	08 95       	ret

00001606 <igmpsend>:

uint16 igmpsend(SOCKET s, const uint8 * buf, uint16 len) {return 0;}
    1606:	cf 93       	push	r28
    1608:	df 93       	push	r29
    160a:	00 d0       	rcall	.+0      	; 0x160c <igmpsend+0x6>
    160c:	00 d0       	rcall	.+0      	; 0x160e <igmpsend+0x8>
    160e:	00 d0       	rcall	.+0      	; 0x1610 <igmpsend+0xa>
    1610:	cd b7       	in	r28, 0x3d	; 61
    1612:	de b7       	in	r29, 0x3e	; 62
    1614:	9a 83       	std	Y+2, r25	; 0x02
    1616:	89 83       	std	Y+1, r24	; 0x01
    1618:	7c 83       	std	Y+4, r23	; 0x04
    161a:	6b 83       	std	Y+3, r22	; 0x03
    161c:	5e 83       	std	Y+6, r21	; 0x06
    161e:	4d 83       	std	Y+5, r20	; 0x05
    1620:	80 e0       	ldi	r24, 0x00	; 0
    1622:	90 e0       	ldi	r25, 0x00	; 0
    1624:	26 96       	adiw	r28, 0x06	; 6
    1626:	0f b6       	in	r0, 0x3f	; 63
    1628:	f8 94       	cli
    162a:	de bf       	out	0x3e, r29	; 62
    162c:	0f be       	out	0x3f, r0	; 63
    162e:	cd bf       	out	0x3d, r28	; 61
    1630:	df 91       	pop	r29
    1632:	cf 91       	pop	r28
    1634:	08 95       	ret

00001636 <_ZN6SpiDrv5beginEv>:
#define DELAY_100NS do { asm volatile("nop"); }while(0);
#define DELAY_SPI(X) { int ii=0; do {  asm volatile("nop"); }while(++ii<X);}
#define DELAY_TRANSFER() DELAY_SPI(10)

void SpiDrv::begin()
{
    1636:	cf 93       	push	r28
    1638:	df 93       	push	r29
    163a:	cd b7       	in	r28, 0x3d	; 61
    163c:	de b7       	in	r29, 0x3e	; 62
	  // MISO pin automatically overrides to INPUT.
	  // When the SS pin is set as OUTPUT, it can be used as
	  // a general purpose output port (it doesn't influence
	  // SPI operations).

	  pinMode(SCK, OUTPUT);
    163e:	61 e0       	ldi	r22, 0x01	; 1
    1640:	8d e0       	ldi	r24, 0x0D	; 13
    1642:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
	  pinMode(MOSI, OUTPUT);
    1646:	61 e0       	ldi	r22, 0x01	; 1
    1648:	8b e0       	ldi	r24, 0x0B	; 11
    164a:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
	  pinMode(SS, OUTPUT);
    164e:	61 e0       	ldi	r22, 0x01	; 1
    1650:	8a e0       	ldi	r24, 0x0A	; 10
    1652:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
	  pinMode(SLAVESELECT, OUTPUT);
    1656:	61 e0       	ldi	r22, 0x01	; 1
    1658:	8a e0       	ldi	r24, 0x0A	; 10
    165a:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
	  pinMode(SLAVEREADY, INPUT);
    165e:	60 e0       	ldi	r22, 0x00	; 0
    1660:	87 e0       	ldi	r24, 0x07	; 7
    1662:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
	  pinMode(WIFILED, OUTPUT);
    1666:	61 e0       	ldi	r22, 0x01	; 1
    1668:	89 e0       	ldi	r24, 0x09	; 9
    166a:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>

	  digitalWrite(SCK, LOW);
    166e:	60 e0       	ldi	r22, 0x00	; 0
    1670:	8d e0       	ldi	r24, 0x0D	; 13
    1672:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
	  digitalWrite(MOSI, LOW);
    1676:	60 e0       	ldi	r22, 0x00	; 0
    1678:	8b e0       	ldi	r24, 0x0B	; 11
    167a:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
	  digitalWrite(SS, HIGH);
    167e:	61 e0       	ldi	r22, 0x01	; 1
    1680:	8a e0       	ldi	r24, 0x0A	; 10
    1682:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
	  digitalWrite(SLAVESELECT, HIGH);
    1686:	61 e0       	ldi	r22, 0x01	; 1
    1688:	8a e0       	ldi	r24, 0x0A	; 10
    168a:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
	  digitalWrite(WIFILED, LOW);
    168e:	60 e0       	ldi	r22, 0x00	; 0
    1690:	89 e0       	ldi	r24, 0x09	; 9
    1692:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
#endif

	  // Warning: if the SS pin ever becomes a LOW INPUT then SPI
	  // automatically switches to Slave, so the data direction of
	  // the SS pin MUST be kept as OUTPUT.
	  SPCR |= _BV(MSTR);
    1696:	8c e4       	ldi	r24, 0x4C	; 76
    1698:	90 e0       	ldi	r25, 0x00	; 0
    169a:	2c e4       	ldi	r18, 0x4C	; 76
    169c:	30 e0       	ldi	r19, 0x00	; 0
    169e:	f9 01       	movw	r30, r18
    16a0:	20 81       	ld	r18, Z
    16a2:	20 61       	ori	r18, 0x10	; 16
    16a4:	fc 01       	movw	r30, r24
    16a6:	20 83       	st	Z, r18
	  SPCR |= _BV(SPE);
    16a8:	8c e4       	ldi	r24, 0x4C	; 76
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	2c e4       	ldi	r18, 0x4C	; 76
    16ae:	30 e0       	ldi	r19, 0x00	; 0
    16b0:	f9 01       	movw	r30, r18
    16b2:	20 81       	ld	r18, Z
    16b4:	20 64       	ori	r18, 0x40	; 64
    16b6:	fc 01       	movw	r30, r24
    16b8:	20 83       	st	Z, r18
	  //SPSR |= _BV(SPI2X);
}
    16ba:	df 91       	pop	r29
    16bc:	cf 91       	pop	r28
    16be:	08 95       	ret

000016c0 <_ZN6SpiDrv3endEv>:

void SpiDrv::end() {
    16c0:	cf 93       	push	r28
    16c2:	df 93       	push	r29
    16c4:	cd b7       	in	r28, 0x3d	; 61
    16c6:	de b7       	in	r29, 0x3e	; 62
  SPCR &= ~_BV(SPE);
    16c8:	8c e4       	ldi	r24, 0x4C	; 76
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	2c e4       	ldi	r18, 0x4C	; 76
    16ce:	30 e0       	ldi	r19, 0x00	; 0
    16d0:	f9 01       	movw	r30, r18
    16d2:	20 81       	ld	r18, Z
    16d4:	2f 7b       	andi	r18, 0xBF	; 191
    16d6:	fc 01       	movw	r30, r24
    16d8:	20 83       	st	Z, r18
}
    16da:	df 91       	pop	r29
    16dc:	cf 91       	pop	r28
    16de:	08 95       	ret

000016e0 <_ZN6SpiDrv14spiSlaveSelectEv>:

void SpiDrv::spiSlaveSelect()
{
    16e0:	cf 93       	push	r28
    16e2:	df 93       	push	r29
    16e4:	cd b7       	in	r28, 0x3d	; 61
    16e6:	de b7       	in	r29, 0x3e	; 62
    digitalWrite(SLAVESELECT,LOW);
    16e8:	60 e0       	ldi	r22, 0x00	; 0
    16ea:	8a e0       	ldi	r24, 0x0A	; 10
    16ec:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
}
    16f0:	df 91       	pop	r29
    16f2:	cf 91       	pop	r28
    16f4:	08 95       	ret

000016f6 <_ZN6SpiDrv16spiSlaveDeselectEv>:


void SpiDrv::spiSlaveDeselect()
{
    16f6:	cf 93       	push	r28
    16f8:	df 93       	push	r29
    16fa:	cd b7       	in	r28, 0x3d	; 61
    16fc:	de b7       	in	r29, 0x3e	; 62
    digitalWrite(SLAVESELECT,HIGH);
    16fe:	61 e0       	ldi	r22, 0x01	; 1
    1700:	8a e0       	ldi	r24, 0x0A	; 10
    1702:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
}
    1706:	df 91       	pop	r29
    1708:	cf 91       	pop	r28
    170a:	08 95       	ret

0000170c <_Z8delaySpiv>:

void delaySpi()
{
    170c:	cf 93       	push	r28
    170e:	df 93       	push	r29
    1710:	00 d0       	rcall	.+0      	; 0x1712 <_Z8delaySpiv+0x6>
    1712:	00 d0       	rcall	.+0      	; 0x1714 <_Z8delaySpiv+0x8>
    1714:	00 d0       	rcall	.+0      	; 0x1716 <_Z8delaySpiv+0xa>
    1716:	cd b7       	in	r28, 0x3d	; 61
    1718:	de b7       	in	r29, 0x3e	; 62
	int i = 0;
    171a:	1a 82       	std	Y+2, r1	; 0x02
    171c:	19 82       	std	Y+1, r1	; 0x01
	const int DELAY = 1000;
    171e:	88 ee       	ldi	r24, 0xE8	; 232
    1720:	93 e0       	ldi	r25, 0x03	; 3
    1722:	9e 83       	std	Y+6, r25	; 0x06
    1724:	8d 83       	std	Y+5, r24	; 0x05
	for (;i<DELAY;++i)
    1726:	0a c0       	rjmp	.+20     	; 0x173c <_Z8delaySpiv+0x30>
	{
		int a =a+1;
    1728:	8b 81       	ldd	r24, Y+3	; 0x03
    172a:	9c 81       	ldd	r25, Y+4	; 0x04
    172c:	01 96       	adiw	r24, 0x01	; 1
    172e:	9c 83       	std	Y+4, r25	; 0x04
    1730:	8b 83       	std	Y+3, r24	; 0x03

void delaySpi()
{
	int i = 0;
	const int DELAY = 1000;
	for (;i<DELAY;++i)
    1732:	89 81       	ldd	r24, Y+1	; 0x01
    1734:	9a 81       	ldd	r25, Y+2	; 0x02
    1736:	01 96       	adiw	r24, 0x01	; 1
    1738:	9a 83       	std	Y+2, r25	; 0x02
    173a:	89 83       	std	Y+1, r24	; 0x01
    173c:	21 e0       	ldi	r18, 0x01	; 1
    173e:	89 81       	ldd	r24, Y+1	; 0x01
    1740:	9a 81       	ldd	r25, Y+2	; 0x02
    1742:	88 3e       	cpi	r24, 0xE8	; 232
    1744:	33 e0       	ldi	r19, 0x03	; 3
    1746:	93 07       	cpc	r25, r19
    1748:	0c f0       	brlt	.+2      	; 0x174c <_Z8delaySpiv+0x40>
    174a:	20 e0       	ldi	r18, 0x00	; 0
    174c:	22 23       	and	r18, r18
    174e:	61 f7       	brne	.-40     	; 0x1728 <_Z8delaySpiv+0x1c>
	{
		int a =a+1;
	}
}
    1750:	26 96       	adiw	r28, 0x06	; 6
    1752:	0f b6       	in	r0, 0x3f	; 63
    1754:	f8 94       	cli
    1756:	de bf       	out	0x3e, r29	; 62
    1758:	0f be       	out	0x3f, r0	; 63
    175a:	cd bf       	out	0x3d, r28	; 61
    175c:	df 91       	pop	r29
    175e:	cf 91       	pop	r28
    1760:	08 95       	ret

00001762 <_ZN6SpiDrv11spiTransferEc>:

char SpiDrv::spiTransfer(volatile char data)
{
    1762:	cf 93       	push	r28
    1764:	df 93       	push	r29
    1766:	00 d0       	rcall	.+0      	; 0x1768 <_ZN6SpiDrv11spiTransferEc+0x6>
    1768:	00 d0       	rcall	.+0      	; 0x176a <_ZN6SpiDrv11spiTransferEc+0x8>
    176a:	cd b7       	in	r28, 0x3d	; 61
    176c:	de b7       	in	r29, 0x3e	; 62
    176e:	8c 83       	std	Y+4, r24	; 0x04
    SPDR = data;                    // Start the transmission
    1770:	8e e4       	ldi	r24, 0x4E	; 78
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	2c 81       	ldd	r18, Y+4	; 0x04
    1776:	fc 01       	movw	r30, r24
    1778:	20 83       	st	Z, r18
    while (!(SPSR & (1<<SPIF)))     // Wait the end of the transmission
    177a:	00 00       	nop
    177c:	8d e4       	ldi	r24, 0x4D	; 77
    177e:	90 e0       	ldi	r25, 0x00	; 0
    1780:	fc 01       	movw	r30, r24
    1782:	80 81       	ld	r24, Z
    1784:	80 95       	com	r24
    1786:	88 1f       	adc	r24, r24
    1788:	88 27       	eor	r24, r24
    178a:	88 1f       	adc	r24, r24
    178c:	88 23       	and	r24, r24
    178e:	b1 f7       	brne	.-20     	; 0x177c <_ZN6SpiDrv11spiTransferEc+0x1a>
    {
    };
    char result = SPDR;
    1790:	8e e4       	ldi	r24, 0x4E	; 78
    1792:	90 e0       	ldi	r25, 0x00	; 0
    1794:	fc 01       	movw	r30, r24
    1796:	80 81       	ld	r24, Z
    1798:	8b 83       	std	Y+3, r24	; 0x03
    DELAY_TRANSFER();
    179a:	1a 82       	std	Y+2, r1	; 0x02
    179c:	19 82       	std	Y+1, r1	; 0x01
    179e:	00 00       	nop
    17a0:	89 81       	ldd	r24, Y+1	; 0x01
    17a2:	9a 81       	ldd	r25, Y+2	; 0x02
    17a4:	01 96       	adiw	r24, 0x01	; 1
    17a6:	9a 83       	std	Y+2, r25	; 0x02
    17a8:	89 83       	std	Y+1, r24	; 0x01
    17aa:	21 e0       	ldi	r18, 0x01	; 1
    17ac:	89 81       	ldd	r24, Y+1	; 0x01
    17ae:	9a 81       	ldd	r25, Y+2	; 0x02
    17b0:	8a 30       	cpi	r24, 0x0A	; 10
    17b2:	91 05       	cpc	r25, r1
    17b4:	0c f0       	brlt	.+2      	; 0x17b8 <_ZN6SpiDrv11spiTransferEc+0x56>
    17b6:	20 e0       	ldi	r18, 0x00	; 0
    17b8:	22 23       	and	r18, r18
    17ba:	89 f7       	brne	.-30     	; 0x179e <_ZN6SpiDrv11spiTransferEc+0x3c>

    return result;                    // return the received byte
    17bc:	8b 81       	ldd	r24, Y+3	; 0x03
}
    17be:	0f 90       	pop	r0
    17c0:	0f 90       	pop	r0
    17c2:	0f 90       	pop	r0
    17c4:	0f 90       	pop	r0
    17c6:	df 91       	pop	r29
    17c8:	cf 91       	pop	r28
    17ca:	08 95       	ret

000017cc <_ZN6SpiDrv11waitSpiCharEh>:

int SpiDrv::waitSpiChar(unsigned char waitChar)
{
    17cc:	cf 93       	push	r28
    17ce:	df 93       	push	r29
    17d0:	00 d0       	rcall	.+0      	; 0x17d2 <_ZN6SpiDrv11waitSpiCharEh+0x6>
    17d2:	00 d0       	rcall	.+0      	; 0x17d4 <_ZN6SpiDrv11waitSpiCharEh+0x8>
    17d4:	cd b7       	in	r28, 0x3d	; 61
    17d6:	de b7       	in	r29, 0x3e	; 62
    17d8:	8c 83       	std	Y+4, r24	; 0x04
    int timeout = TIMEOUT_CHAR;
    17da:	88 ee       	ldi	r24, 0xE8	; 232
    17dc:	93 e0       	ldi	r25, 0x03	; 3
    17de:	9a 83       	std	Y+2, r25	; 0x02
    17e0:	89 83       	std	Y+1, r24	; 0x01
    unsigned char _readChar = 0;
    17e2:	1b 82       	std	Y+3, r1	; 0x03
    do{
        _readChar = readChar(); //get data byte
    17e4:	0e 94 3f 0c 	call	0x187e	; 0x187e <_ZN6SpiDrv8readCharEv>
    17e8:	8b 83       	std	Y+3, r24	; 0x03
        if (_readChar == ERR_CMD)
    17ea:	8b 81       	ldd	r24, Y+3	; 0x03
    17ec:	8f 3e       	cpi	r24, 0xEF	; 239
    17ee:	19 f4       	brne	.+6      	; 0x17f6 <_ZN6SpiDrv11waitSpiCharEh+0x2a>
        {
        	WARN("Err cmd received\n");
        	return -1;
    17f0:	8f ef       	ldi	r24, 0xFF	; 255
    17f2:	9f ef       	ldi	r25, 0xFF	; 255
    17f4:	1f c0       	rjmp	.+62     	; 0x1834 <_ZN6SpiDrv11waitSpiCharEh+0x68>

int SpiDrv::waitSpiChar(unsigned char waitChar)
{
    int timeout = TIMEOUT_CHAR;
    unsigned char _readChar = 0;
    do{
    17f6:	21 e0       	ldi	r18, 0x01	; 1
    17f8:	89 81       	ldd	r24, Y+1	; 0x01
    17fa:	9a 81       	ldd	r25, Y+2	; 0x02
    17fc:	18 16       	cp	r1, r24
    17fe:	19 06       	cpc	r1, r25
    1800:	0c f0       	brlt	.+2      	; 0x1804 <_ZN6SpiDrv11waitSpiCharEh+0x38>
    1802:	20 e0       	ldi	r18, 0x00	; 0
    1804:	89 81       	ldd	r24, Y+1	; 0x01
    1806:	9a 81       	ldd	r25, Y+2	; 0x02
    1808:	01 97       	sbiw	r24, 0x01	; 1
    180a:	9a 83       	std	Y+2, r25	; 0x02
    180c:	89 83       	std	Y+1, r24	; 0x01
    180e:	22 23       	and	r18, r18
    1810:	31 f0       	breq	.+12     	; 0x181e <_ZN6SpiDrv11waitSpiCharEh+0x52>
    1812:	9b 81       	ldd	r25, Y+3	; 0x03
    1814:	8c 81       	ldd	r24, Y+4	; 0x04
    1816:	98 17       	cp	r25, r24
    1818:	11 f0       	breq	.+4      	; 0x181e <_ZN6SpiDrv11waitSpiCharEh+0x52>
    181a:	81 e0       	ldi	r24, 0x01	; 1
    181c:	01 c0       	rjmp	.+2      	; 0x1820 <_ZN6SpiDrv11waitSpiCharEh+0x54>
    181e:	80 e0       	ldi	r24, 0x00	; 0
    1820:	88 23       	and	r24, r24
    1822:	01 f7       	brne	.-64     	; 0x17e4 <_ZN6SpiDrv11waitSpiCharEh+0x18>
        {
        	WARN("Err cmd received\n");
        	return -1;
        }
    }while((timeout-- > 0) && (_readChar != waitChar));
    return  (_readChar == waitChar);
    1824:	81 e0       	ldi	r24, 0x01	; 1
    1826:	2b 81       	ldd	r18, Y+3	; 0x03
    1828:	9c 81       	ldd	r25, Y+4	; 0x04
    182a:	29 17       	cp	r18, r25
    182c:	09 f0       	breq	.+2      	; 0x1830 <_ZN6SpiDrv11waitSpiCharEh+0x64>
    182e:	80 e0       	ldi	r24, 0x00	; 0
    1830:	88 2f       	mov	r24, r24
    1832:	90 e0       	ldi	r25, 0x00	; 0
}
    1834:	0f 90       	pop	r0
    1836:	0f 90       	pop	r0
    1838:	0f 90       	pop	r0
    183a:	0f 90       	pop	r0
    183c:	df 91       	pop	r29
    183e:	cf 91       	pop	r28
    1840:	08 95       	ret

00001842 <_ZN6SpiDrv16readAndCheckCharEcPc>:

int SpiDrv::readAndCheckChar(char checkChar, char* readChar)
{
    1842:	cf 93       	push	r28
    1844:	df 93       	push	r29
    1846:	00 d0       	rcall	.+0      	; 0x1848 <_ZN6SpiDrv16readAndCheckCharEcPc+0x6>
    1848:	1f 92       	push	r1
    184a:	cd b7       	in	r28, 0x3d	; 61
    184c:	de b7       	in	r29, 0x3e	; 62
    184e:	89 83       	std	Y+1, r24	; 0x01
    1850:	7b 83       	std	Y+3, r23	; 0x03
    1852:	6a 83       	std	Y+2, r22	; 0x02
    getParam((uint8_t*)readChar);
    1854:	8a 81       	ldd	r24, Y+2	; 0x02
    1856:	9b 81       	ldd	r25, Y+3	; 0x03
    1858:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <_ZN6SpiDrv8getParamEPh>

    return  (*readChar == checkChar);
    185c:	8a 81       	ldd	r24, Y+2	; 0x02
    185e:	9b 81       	ldd	r25, Y+3	; 0x03
    1860:	fc 01       	movw	r30, r24
    1862:	20 81       	ld	r18, Z
    1864:	81 e0       	ldi	r24, 0x01	; 1
    1866:	99 81       	ldd	r25, Y+1	; 0x01
    1868:	29 17       	cp	r18, r25
    186a:	09 f0       	breq	.+2      	; 0x186e <_ZN6SpiDrv16readAndCheckCharEcPc+0x2c>
    186c:	80 e0       	ldi	r24, 0x00	; 0
    186e:	88 2f       	mov	r24, r24
    1870:	90 e0       	ldi	r25, 0x00	; 0
}
    1872:	0f 90       	pop	r0
    1874:	0f 90       	pop	r0
    1876:	0f 90       	pop	r0
    1878:	df 91       	pop	r29
    187a:	cf 91       	pop	r28
    187c:	08 95       	ret

0000187e <_ZN6SpiDrv8readCharEv>:

char SpiDrv::readChar()
{
    187e:	cf 93       	push	r28
    1880:	df 93       	push	r29
    1882:	1f 92       	push	r1
    1884:	cd b7       	in	r28, 0x3d	; 61
    1886:	de b7       	in	r29, 0x3e	; 62
	uint8_t readChar = 0;
    1888:	19 82       	std	Y+1, r1	; 0x01
	getParam(&readChar);
    188a:	ce 01       	movw	r24, r28
    188c:	01 96       	adiw	r24, 0x01	; 1
    188e:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <_ZN6SpiDrv8getParamEPh>
	return readChar;
    1892:	89 81       	ldd	r24, Y+1	; 0x01
}
    1894:	0f 90       	pop	r0
    1896:	df 91       	pop	r29
    1898:	cf 91       	pop	r28
    189a:	08 95       	ret

0000189c <_ZN6SpiDrv16waitForSlaveSignEv>:
#define waitSlaveSign() (digitalRead(SLAVEREADY) == HIGH)
#define waitSlaveSignalH() while(digitalRead(SLAVEREADY) != HIGH){}
#define waitSlaveSignalL() while(digitalRead(SLAVEREADY) != LOW){}

void SpiDrv::waitForSlaveSign()
{
    189c:	cf 93       	push	r28
    189e:	df 93       	push	r29
    18a0:	cd b7       	in	r28, 0x3d	; 61
    18a2:	de b7       	in	r29, 0x3e	; 62
	while (!waitSlaveSign());
    18a4:	00 00       	nop
    18a6:	87 e0       	ldi	r24, 0x07	; 7
    18a8:	0e 94 2a 82 	call	0x10454	; 0x10454 <digitalRead>
    18ac:	21 e0       	ldi	r18, 0x01	; 1
    18ae:	81 30       	cpi	r24, 0x01	; 1
    18b0:	91 05       	cpc	r25, r1
    18b2:	09 f4       	brne	.+2      	; 0x18b6 <_ZN6SpiDrv16waitForSlaveSignEv+0x1a>
    18b4:	20 e0       	ldi	r18, 0x00	; 0
    18b6:	22 23       	and	r18, r18
    18b8:	b1 f7       	brne	.-20     	; 0x18a6 <_ZN6SpiDrv16waitForSlaveSignEv+0xa>
}
    18ba:	df 91       	pop	r29
    18bc:	cf 91       	pop	r28
    18be:	08 95       	ret

000018c0 <_ZN6SpiDrv17waitForSlaveReadyEv>:

void SpiDrv::waitForSlaveReady()
{
    18c0:	cf 93       	push	r28
    18c2:	df 93       	push	r29
    18c4:	cd b7       	in	r28, 0x3d	; 61
    18c6:	de b7       	in	r29, 0x3e	; 62
	while (!waitSlaveReady());
    18c8:	00 00       	nop
    18ca:	87 e0       	ldi	r24, 0x07	; 7
    18cc:	0e 94 2a 82 	call	0x10454	; 0x10454 <digitalRead>
    18d0:	21 e0       	ldi	r18, 0x01	; 1
    18d2:	00 97       	sbiw	r24, 0x00	; 0
    18d4:	09 f4       	brne	.+2      	; 0x18d8 <_ZN6SpiDrv17waitForSlaveReadyEv+0x18>
    18d6:	20 e0       	ldi	r18, 0x00	; 0
    18d8:	22 23       	and	r18, r18
    18da:	b9 f7       	brne	.-18     	; 0x18ca <_ZN6SpiDrv17waitForSlaveReadyEv+0xa>
}
    18dc:	df 91       	pop	r29
    18de:	cf 91       	pop	r28
    18e0:	08 95       	ret

000018e2 <_ZN6SpiDrv8getParamEPh>:

void SpiDrv::getParam(uint8_t* param)
{
    18e2:	cf 93       	push	r28
    18e4:	df 93       	push	r29
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <_ZN6SpiDrv8getParamEPh+0x6>
    18e8:	00 d0       	rcall	.+0      	; 0x18ea <_ZN6SpiDrv8getParamEPh+0x8>
    18ea:	cd b7       	in	r28, 0x3d	; 61
    18ec:	de b7       	in	r29, 0x3e	; 62
    18ee:	9c 83       	std	Y+4, r25	; 0x04
    18f0:	8b 83       	std	Y+3, r24	; 0x03
    // Get Params data
    *param = spiTransfer(DUMMY_DATA);
    18f2:	8f ef       	ldi	r24, 0xFF	; 255
    18f4:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    18f8:	28 2f       	mov	r18, r24
    18fa:	8b 81       	ldd	r24, Y+3	; 0x03
    18fc:	9c 81       	ldd	r25, Y+4	; 0x04
    18fe:	fc 01       	movw	r30, r24
    1900:	20 83       	st	Z, r18
    DELAY_TRANSFER();
    1902:	1a 82       	std	Y+2, r1	; 0x02
    1904:	19 82       	std	Y+1, r1	; 0x01
    1906:	00 00       	nop
    1908:	89 81       	ldd	r24, Y+1	; 0x01
    190a:	9a 81       	ldd	r25, Y+2	; 0x02
    190c:	01 96       	adiw	r24, 0x01	; 1
    190e:	9a 83       	std	Y+2, r25	; 0x02
    1910:	89 83       	std	Y+1, r24	; 0x01
    1912:	21 e0       	ldi	r18, 0x01	; 1
    1914:	89 81       	ldd	r24, Y+1	; 0x01
    1916:	9a 81       	ldd	r25, Y+2	; 0x02
    1918:	8a 30       	cpi	r24, 0x0A	; 10
    191a:	91 05       	cpc	r25, r1
    191c:	0c f0       	brlt	.+2      	; 0x1920 <_ZN6SpiDrv8getParamEPh+0x3e>
    191e:	20 e0       	ldi	r18, 0x00	; 0
    1920:	22 23       	and	r18, r18
    1922:	89 f7       	brne	.-30     	; 0x1906 <_ZN6SpiDrv8getParamEPh+0x24>
}
    1924:	0f 90       	pop	r0
    1926:	0f 90       	pop	r0
    1928:	0f 90       	pop	r0
    192a:	0f 90       	pop	r0
    192c:	df 91       	pop	r29
    192e:	cf 91       	pop	r28
    1930:	08 95       	ret

00001932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>:

int SpiDrv::waitResponseCmd(uint8_t cmd, uint8_t numParam, uint8_t* param, uint8_t* param_len)
{
    1932:	cf 93       	push	r28
    1934:	df 93       	push	r29
    1936:	cd b7       	in	r28, 0x3d	; 61
    1938:	de b7       	in	r29, 0x3e	; 62
    193a:	29 97       	sbiw	r28, 0x09	; 9
    193c:	0f b6       	in	r0, 0x3f	; 63
    193e:	f8 94       	cli
    1940:	de bf       	out	0x3e, r29	; 62
    1942:	0f be       	out	0x3f, r0	; 63
    1944:	cd bf       	out	0x3d, r28	; 61
    1946:	8c 83       	std	Y+4, r24	; 0x04
    1948:	6d 83       	std	Y+5, r22	; 0x05
    194a:	5f 83       	std	Y+7, r21	; 0x07
    194c:	4e 83       	std	Y+6, r20	; 0x06
    194e:	39 87       	std	Y+9, r19	; 0x09
    1950:	28 87       	std	Y+8, r18	; 0x08
    char _data = 0;
    1952:	1b 82       	std	Y+3, r1	; 0x03
    int ii = 0;
    1954:	1a 82       	std	Y+2, r1	; 0x02
    1956:	19 82       	std	Y+1, r1	; 0x01

    IF_CHECK_START_CMD(_data)
    1958:	80 ee       	ldi	r24, 0xE0	; 224
    195a:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <_ZN6SpiDrv11waitSpiCharEh>
    195e:	21 e0       	ldi	r18, 0x01	; 1
    1960:	00 97       	sbiw	r24, 0x00	; 0
    1962:	09 f0       	breq	.+2      	; 0x1966 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0x34>
    1964:	20 e0       	ldi	r18, 0x00	; 0
    1966:	22 23       	and	r18, r18
    1968:	19 f0       	breq	.+6      	; 0x1970 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0x3e>
    196a:	80 e0       	ldi	r24, 0x00	; 0
    196c:	90 e0       	ldi	r25, 0x00	; 0
    196e:	4c c0       	rjmp	.+152    	; 0x1a08 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0xd6>
    {
        CHECK_DATA(cmd | REPLY_FLAG, _data){};
    1970:	8c 81       	ldd	r24, Y+4	; 0x04
    1972:	28 2f       	mov	r18, r24
    1974:	20 68       	ori	r18, 0x80	; 128
    1976:	ce 01       	movw	r24, r28
    1978:	03 96       	adiw	r24, 0x03	; 3
    197a:	bc 01       	movw	r22, r24
    197c:	82 2f       	mov	r24, r18
    197e:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    1982:	21 e0       	ldi	r18, 0x01	; 1
    1984:	00 97       	sbiw	r24, 0x00	; 0
    1986:	09 f0       	breq	.+2      	; 0x198a <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0x58>
    1988:	20 e0       	ldi	r18, 0x00	; 0
    198a:	22 23       	and	r18, r18
    198c:	19 f0       	breq	.+6      	; 0x1994 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0x62>
    198e:	80 e0       	ldi	r24, 0x00	; 0
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	3a c0       	rjmp	.+116    	; 0x1a08 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0xd6>

        CHECK_DATA(numParam, _data);
    1994:	ce 01       	movw	r24, r28
    1996:	03 96       	adiw	r24, 0x03	; 3
    1998:	bc 01       	movw	r22, r24
    199a:	8d 81       	ldd	r24, Y+5	; 0x05
    199c:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    19a0:	21 e0       	ldi	r18, 0x01	; 1
    19a2:	00 97       	sbiw	r24, 0x00	; 0
    19a4:	09 f0       	breq	.+2      	; 0x19a8 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0x76>
    19a6:	20 e0       	ldi	r18, 0x00	; 0
    19a8:	22 23       	and	r18, r18
    19aa:	19 f0       	breq	.+6      	; 0x19b2 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0x80>
    19ac:	80 e0       	ldi	r24, 0x00	; 0
    19ae:	90 e0       	ldi	r25, 0x00	; 0
    19b0:	2b c0       	rjmp	.+86     	; 0x1a08 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0xd6>
        {
            readParamLen8(param_len);
    19b2:	88 85       	ldd	r24, Y+8	; 0x08
    19b4:	99 85       	ldd	r25, Y+9	; 0x09
    19b6:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN6SpiDrv13readParamLen8EPh>
            for (ii=0; ii<(*param_len); ++ii)
    19ba:	1a 82       	std	Y+2, r1	; 0x02
    19bc:	19 82       	std	Y+1, r1	; 0x01
    19be:	0d c0       	rjmp	.+26     	; 0x19da <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0xa8>
            {
                // Get Params data
                //param[ii] = spiTransfer(DUMMY_DATA);
                getParam(&param[ii]);
    19c0:	89 81       	ldd	r24, Y+1	; 0x01
    19c2:	9a 81       	ldd	r25, Y+2	; 0x02
    19c4:	2e 81       	ldd	r18, Y+6	; 0x06
    19c6:	3f 81       	ldd	r19, Y+7	; 0x07
    19c8:	82 0f       	add	r24, r18
    19ca:	93 1f       	adc	r25, r19
    19cc:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <_ZN6SpiDrv8getParamEPh>
        CHECK_DATA(cmd | REPLY_FLAG, _data){};

        CHECK_DATA(numParam, _data);
        {
            readParamLen8(param_len);
            for (ii=0; ii<(*param_len); ++ii)
    19d0:	89 81       	ldd	r24, Y+1	; 0x01
    19d2:	9a 81       	ldd	r25, Y+2	; 0x02
    19d4:	01 96       	adiw	r24, 0x01	; 1
    19d6:	9a 83       	std	Y+2, r25	; 0x02
    19d8:	89 83       	std	Y+1, r24	; 0x01
    19da:	88 85       	ldd	r24, Y+8	; 0x08
    19dc:	99 85       	ldd	r25, Y+9	; 0x09
    19de:	fc 01       	movw	r30, r24
    19e0:	80 81       	ld	r24, Z
    19e2:	28 2f       	mov	r18, r24
    19e4:	30 e0       	ldi	r19, 0x00	; 0
    19e6:	41 e0       	ldi	r20, 0x01	; 1
    19e8:	89 81       	ldd	r24, Y+1	; 0x01
    19ea:	9a 81       	ldd	r25, Y+2	; 0x02
    19ec:	82 17       	cp	r24, r18
    19ee:	93 07       	cpc	r25, r19
    19f0:	0c f0       	brlt	.+2      	; 0x19f4 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0xc2>
    19f2:	40 e0       	ldi	r20, 0x00	; 0
    19f4:	44 23       	and	r20, r20
    19f6:	21 f7       	brne	.-56     	; 0x19c0 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_+0x8e>
                //param[ii] = spiTransfer(DUMMY_DATA);
                getParam(&param[ii]);
            } 
        }         

        readAndCheckChar(END_CMD, &_data);
    19f8:	ce 01       	movw	r24, r28
    19fa:	03 96       	adiw	r24, 0x03	; 3
    19fc:	bc 01       	movw	r22, r24
    19fe:	8e ee       	ldi	r24, 0xEE	; 238
    1a00:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    }     
    
    return 1;
    1a04:	81 e0       	ldi	r24, 0x01	; 1
    1a06:	90 e0       	ldi	r25, 0x00	; 0
}
    1a08:	29 96       	adiw	r28, 0x09	; 9
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	f8 94       	cli
    1a0e:	de bf       	out	0x3e, r29	; 62
    1a10:	0f be       	out	0x3f, r0	; 63
    1a12:	cd bf       	out	0x3d, r28	; 61
    1a14:	df 91       	pop	r29
    1a16:	cf 91       	pop	r28
    1a18:	08 95       	ret

00001a1a <_ZN6SpiDrv18waitResponseData16EhPhPj>:
    return 1;
}
*/

int SpiDrv::waitResponseData16(uint8_t cmd, uint8_t* param, uint16_t* param_len)
{
    1a1a:	0f 93       	push	r16
    1a1c:	1f 93       	push	r17
    1a1e:	cf 93       	push	r28
    1a20:	df 93       	push	r29
    1a22:	cd b7       	in	r28, 0x3d	; 61
    1a24:	de b7       	in	r29, 0x3e	; 62
    1a26:	29 97       	sbiw	r28, 0x09	; 9
    1a28:	0f b6       	in	r0, 0x3f	; 63
    1a2a:	f8 94       	cli
    1a2c:	de bf       	out	0x3e, r29	; 62
    1a2e:	0f be       	out	0x3f, r0	; 63
    1a30:	cd bf       	out	0x3d, r28	; 61
    1a32:	8d 83       	std	Y+5, r24	; 0x05
    1a34:	7f 83       	std	Y+7, r23	; 0x07
    1a36:	6e 83       	std	Y+6, r22	; 0x06
    1a38:	59 87       	std	Y+9, r21	; 0x09
    1a3a:	48 87       	std	Y+8, r20	; 0x08
    char _data = 0;
    1a3c:	1c 82       	std	Y+4, r1	; 0x04
    uint16_t ii = 0;
    1a3e:	1a 82       	std	Y+2, r1	; 0x02
    1a40:	19 82       	std	Y+1, r1	; 0x01

    IF_CHECK_START_CMD(_data)
    1a42:	80 ee       	ldi	r24, 0xE0	; 224
    1a44:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <_ZN6SpiDrv11waitSpiCharEh>
    1a48:	21 e0       	ldi	r18, 0x01	; 1
    1a4a:	00 97       	sbiw	r24, 0x00	; 0
    1a4c:	09 f0       	breq	.+2      	; 0x1a50 <_ZN6SpiDrv18waitResponseData16EhPhPj+0x36>
    1a4e:	20 e0       	ldi	r18, 0x00	; 0
    1a50:	22 23       	and	r18, r18
    1a52:	19 f0       	breq	.+6      	; 0x1a5a <_ZN6SpiDrv18waitResponseData16EhPhPj+0x40>
    1a54:	80 e0       	ldi	r24, 0x00	; 0
    1a56:	90 e0       	ldi	r25, 0x00	; 0
    1a58:	46 c0       	rjmp	.+140    	; 0x1ae6 <_ZN6SpiDrv18waitResponseData16EhPhPj+0xcc>
    {
        CHECK_DATA(cmd | REPLY_FLAG, _data){};
    1a5a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a5c:	28 2f       	mov	r18, r24
    1a5e:	20 68       	ori	r18, 0x80	; 128
    1a60:	ce 01       	movw	r24, r28
    1a62:	04 96       	adiw	r24, 0x04	; 4
    1a64:	bc 01       	movw	r22, r24
    1a66:	82 2f       	mov	r24, r18
    1a68:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    1a6c:	21 e0       	ldi	r18, 0x01	; 1
    1a6e:	00 97       	sbiw	r24, 0x00	; 0
    1a70:	09 f0       	breq	.+2      	; 0x1a74 <_ZN6SpiDrv18waitResponseData16EhPhPj+0x5a>
    1a72:	20 e0       	ldi	r18, 0x00	; 0
    1a74:	22 23       	and	r18, r18
    1a76:	19 f0       	breq	.+6      	; 0x1a7e <_ZN6SpiDrv18waitResponseData16EhPhPj+0x64>
    1a78:	80 e0       	ldi	r24, 0x00	; 0
    1a7a:	90 e0       	ldi	r25, 0x00	; 0
    1a7c:	34 c0       	rjmp	.+104    	; 0x1ae6 <_ZN6SpiDrv18waitResponseData16EhPhPj+0xcc>

        uint8_t numParam = readChar();
    1a7e:	0e 94 3f 0c 	call	0x187e	; 0x187e <_ZN6SpiDrv8readCharEv>
    1a82:	8b 83       	std	Y+3, r24	; 0x03
        if (numParam != 0)
    1a84:	8b 81       	ldd	r24, Y+3	; 0x03
    1a86:	88 23       	and	r24, r24
    1a88:	31 f1       	breq	.+76     	; 0x1ad6 <_ZN6SpiDrv18waitResponseData16EhPhPj+0xbc>
        {        
            readParamLen16(param_len);
    1a8a:	88 85       	ldd	r24, Y+8	; 0x08
    1a8c:	99 85       	ldd	r25, Y+9	; 0x09
    1a8e:	0e 94 2f 10 	call	0x205e	; 0x205e <_ZN6SpiDrv14readParamLen16EPj>
            for (ii=0; ii<(*param_len); ++ii)
    1a92:	1a 82       	std	Y+2, r1	; 0x02
    1a94:	19 82       	std	Y+1, r1	; 0x01
    1a96:	11 c0       	rjmp	.+34     	; 0x1aba <_ZN6SpiDrv18waitResponseData16EhPhPj+0xa0>
            {
                // Get Params data
                param[ii] = spiTransfer(DUMMY_DATA);
    1a98:	2e 81       	ldd	r18, Y+6	; 0x06
    1a9a:	3f 81       	ldd	r19, Y+7	; 0x07
    1a9c:	89 81       	ldd	r24, Y+1	; 0x01
    1a9e:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa0:	89 01       	movw	r16, r18
    1aa2:	08 0f       	add	r16, r24
    1aa4:	19 1f       	adc	r17, r25
    1aa6:	8f ef       	ldi	r24, 0xFF	; 255
    1aa8:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    1aac:	f8 01       	movw	r30, r16
    1aae:	80 83       	st	Z, r24

        uint8_t numParam = readChar();
        if (numParam != 0)
        {        
            readParamLen16(param_len);
            for (ii=0; ii<(*param_len); ++ii)
    1ab0:	89 81       	ldd	r24, Y+1	; 0x01
    1ab2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ab4:	01 96       	adiw	r24, 0x01	; 1
    1ab6:	9a 83       	std	Y+2, r25	; 0x02
    1ab8:	89 83       	std	Y+1, r24	; 0x01
    1aba:	88 85       	ldd	r24, Y+8	; 0x08
    1abc:	99 85       	ldd	r25, Y+9	; 0x09
    1abe:	fc 01       	movw	r30, r24
    1ac0:	20 81       	ld	r18, Z
    1ac2:	31 81       	ldd	r19, Z+1	; 0x01
    1ac4:	41 e0       	ldi	r20, 0x01	; 1
    1ac6:	89 81       	ldd	r24, Y+1	; 0x01
    1ac8:	9a 81       	ldd	r25, Y+2	; 0x02
    1aca:	82 17       	cp	r24, r18
    1acc:	93 07       	cpc	r25, r19
    1ace:	08 f0       	brcs	.+2      	; 0x1ad2 <_ZN6SpiDrv18waitResponseData16EhPhPj+0xb8>
    1ad0:	40 e0       	ldi	r20, 0x00	; 0
    1ad2:	44 23       	and	r20, r20
    1ad4:	09 f7       	brne	.-62     	; 0x1a98 <_ZN6SpiDrv18waitResponseData16EhPhPj+0x7e>
                // Get Params data
                param[ii] = spiTransfer(DUMMY_DATA);
            } 
        }         

        readAndCheckChar(END_CMD, &_data);
    1ad6:	ce 01       	movw	r24, r28
    1ad8:	04 96       	adiw	r24, 0x04	; 4
    1ada:	bc 01       	movw	r22, r24
    1adc:	8e ee       	ldi	r24, 0xEE	; 238
    1ade:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    }     
    
    return 1;
    1ae2:	81 e0       	ldi	r24, 0x01	; 1
    1ae4:	90 e0       	ldi	r25, 0x00	; 0
}
    1ae6:	29 96       	adiw	r28, 0x09	; 9
    1ae8:	0f b6       	in	r0, 0x3f	; 63
    1aea:	f8 94       	cli
    1aec:	de bf       	out	0x3e, r29	; 62
    1aee:	0f be       	out	0x3f, r0	; 63
    1af0:	cd bf       	out	0x3d, r28	; 61
    1af2:	df 91       	pop	r29
    1af4:	cf 91       	pop	r28
    1af6:	1f 91       	pop	r17
    1af8:	0f 91       	pop	r16
    1afa:	08 95       	ret

00001afc <_ZN6SpiDrv17waitResponseData8EhPhS0_>:

int SpiDrv::waitResponseData8(uint8_t cmd, uint8_t* param, uint8_t* param_len)
{
    1afc:	0f 93       	push	r16
    1afe:	1f 93       	push	r17
    1b00:	cf 93       	push	r28
    1b02:	df 93       	push	r29
    1b04:	cd b7       	in	r28, 0x3d	; 61
    1b06:	de b7       	in	r29, 0x3e	; 62
    1b08:	29 97       	sbiw	r28, 0x09	; 9
    1b0a:	0f b6       	in	r0, 0x3f	; 63
    1b0c:	f8 94       	cli
    1b0e:	de bf       	out	0x3e, r29	; 62
    1b10:	0f be       	out	0x3f, r0	; 63
    1b12:	cd bf       	out	0x3d, r28	; 61
    1b14:	8d 83       	std	Y+5, r24	; 0x05
    1b16:	7f 83       	std	Y+7, r23	; 0x07
    1b18:	6e 83       	std	Y+6, r22	; 0x06
    1b1a:	59 87       	std	Y+9, r21	; 0x09
    1b1c:	48 87       	std	Y+8, r20	; 0x08
    char _data = 0;
    1b1e:	1c 82       	std	Y+4, r1	; 0x04
    int ii = 0;
    1b20:	1a 82       	std	Y+2, r1	; 0x02
    1b22:	19 82       	std	Y+1, r1	; 0x01

    IF_CHECK_START_CMD(_data)
    1b24:	80 ee       	ldi	r24, 0xE0	; 224
    1b26:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <_ZN6SpiDrv11waitSpiCharEh>
    1b2a:	21 e0       	ldi	r18, 0x01	; 1
    1b2c:	00 97       	sbiw	r24, 0x00	; 0
    1b2e:	09 f0       	breq	.+2      	; 0x1b32 <_ZN6SpiDrv17waitResponseData8EhPhS0_+0x36>
    1b30:	20 e0       	ldi	r18, 0x00	; 0
    1b32:	22 23       	and	r18, r18
    1b34:	19 f0       	breq	.+6      	; 0x1b3c <_ZN6SpiDrv17waitResponseData8EhPhS0_+0x40>
    1b36:	80 e0       	ldi	r24, 0x00	; 0
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	47 c0       	rjmp	.+142    	; 0x1bca <_ZN6SpiDrv17waitResponseData8EhPhS0_+0xce>
    {
        CHECK_DATA(cmd | REPLY_FLAG, _data){};
    1b3c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b3e:	28 2f       	mov	r18, r24
    1b40:	20 68       	ori	r18, 0x80	; 128
    1b42:	ce 01       	movw	r24, r28
    1b44:	04 96       	adiw	r24, 0x04	; 4
    1b46:	bc 01       	movw	r22, r24
    1b48:	82 2f       	mov	r24, r18
    1b4a:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    1b4e:	21 e0       	ldi	r18, 0x01	; 1
    1b50:	00 97       	sbiw	r24, 0x00	; 0
    1b52:	09 f0       	breq	.+2      	; 0x1b56 <_ZN6SpiDrv17waitResponseData8EhPhS0_+0x5a>
    1b54:	20 e0       	ldi	r18, 0x00	; 0
    1b56:	22 23       	and	r18, r18
    1b58:	19 f0       	breq	.+6      	; 0x1b60 <_ZN6SpiDrv17waitResponseData8EhPhS0_+0x64>
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	35 c0       	rjmp	.+106    	; 0x1bca <_ZN6SpiDrv17waitResponseData8EhPhS0_+0xce>

        uint8_t numParam = readChar();
    1b60:	0e 94 3f 0c 	call	0x187e	; 0x187e <_ZN6SpiDrv8readCharEv>
    1b64:	8b 83       	std	Y+3, r24	; 0x03
        if (numParam != 0)
    1b66:	8b 81       	ldd	r24, Y+3	; 0x03
    1b68:	88 23       	and	r24, r24
    1b6a:	39 f1       	breq	.+78     	; 0x1bba <_ZN6SpiDrv17waitResponseData8EhPhS0_+0xbe>
        {        
            readParamLen8(param_len);
    1b6c:	88 85       	ldd	r24, Y+8	; 0x08
    1b6e:	99 85       	ldd	r25, Y+9	; 0x09
    1b70:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN6SpiDrv13readParamLen8EPh>
            for (ii=0; ii<(*param_len); ++ii)
    1b74:	1a 82       	std	Y+2, r1	; 0x02
    1b76:	19 82       	std	Y+1, r1	; 0x01
    1b78:	11 c0       	rjmp	.+34     	; 0x1b9c <_ZN6SpiDrv17waitResponseData8EhPhS0_+0xa0>
            {
                // Get Params data
                param[ii] = spiTransfer(DUMMY_DATA);
    1b7a:	89 81       	ldd	r24, Y+1	; 0x01
    1b7c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b7e:	2e 81       	ldd	r18, Y+6	; 0x06
    1b80:	3f 81       	ldd	r19, Y+7	; 0x07
    1b82:	89 01       	movw	r16, r18
    1b84:	08 0f       	add	r16, r24
    1b86:	19 1f       	adc	r17, r25
    1b88:	8f ef       	ldi	r24, 0xFF	; 255
    1b8a:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    1b8e:	f8 01       	movw	r30, r16
    1b90:	80 83       	st	Z, r24

        uint8_t numParam = readChar();
        if (numParam != 0)
        {        
            readParamLen8(param_len);
            for (ii=0; ii<(*param_len); ++ii)
    1b92:	89 81       	ldd	r24, Y+1	; 0x01
    1b94:	9a 81       	ldd	r25, Y+2	; 0x02
    1b96:	01 96       	adiw	r24, 0x01	; 1
    1b98:	9a 83       	std	Y+2, r25	; 0x02
    1b9a:	89 83       	std	Y+1, r24	; 0x01
    1b9c:	88 85       	ldd	r24, Y+8	; 0x08
    1b9e:	99 85       	ldd	r25, Y+9	; 0x09
    1ba0:	fc 01       	movw	r30, r24
    1ba2:	80 81       	ld	r24, Z
    1ba4:	28 2f       	mov	r18, r24
    1ba6:	30 e0       	ldi	r19, 0x00	; 0
    1ba8:	41 e0       	ldi	r20, 0x01	; 1
    1baa:	89 81       	ldd	r24, Y+1	; 0x01
    1bac:	9a 81       	ldd	r25, Y+2	; 0x02
    1bae:	82 17       	cp	r24, r18
    1bb0:	93 07       	cpc	r25, r19
    1bb2:	0c f0       	brlt	.+2      	; 0x1bb6 <_ZN6SpiDrv17waitResponseData8EhPhS0_+0xba>
    1bb4:	40 e0       	ldi	r20, 0x00	; 0
    1bb6:	44 23       	and	r20, r20
    1bb8:	01 f7       	brne	.-64     	; 0x1b7a <_ZN6SpiDrv17waitResponseData8EhPhS0_+0x7e>
                // Get Params data
                param[ii] = spiTransfer(DUMMY_DATA);
            } 
        }         

        readAndCheckChar(END_CMD, &_data);
    1bba:	ce 01       	movw	r24, r28
    1bbc:	04 96       	adiw	r24, 0x04	; 4
    1bbe:	bc 01       	movw	r22, r24
    1bc0:	8e ee       	ldi	r24, 0xEE	; 238
    1bc2:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    }     
    
    return 1;
    1bc6:	81 e0       	ldi	r24, 0x01	; 1
    1bc8:	90 e0       	ldi	r25, 0x00	; 0
}
    1bca:	29 96       	adiw	r28, 0x09	; 9
    1bcc:	0f b6       	in	r0, 0x3f	; 63
    1bce:	f8 94       	cli
    1bd0:	de bf       	out	0x3e, r29	; 62
    1bd2:	0f be       	out	0x3f, r0	; 63
    1bd4:	cd bf       	out	0x3d, r28	; 61
    1bd6:	df 91       	pop	r29
    1bd8:	cf 91       	pop	r28
    1bda:	1f 91       	pop	r17
    1bdc:	0f 91       	pop	r16
    1bde:	08 95       	ret

00001be0 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam>:

int SpiDrv::waitResponseParams(uint8_t cmd, uint8_t numParam, tParam* params)
{
    1be0:	0f 93       	push	r16
    1be2:	1f 93       	push	r17
    1be4:	cf 93       	push	r28
    1be6:	df 93       	push	r29
    1be8:	cd b7       	in	r28, 0x3d	; 61
    1bea:	de b7       	in	r29, 0x3e	; 62
    1bec:	2a 97       	sbiw	r28, 0x0a	; 10
    1bee:	0f b6       	in	r0, 0x3f	; 63
    1bf0:	f8 94       	cli
    1bf2:	de bf       	out	0x3e, r29	; 62
    1bf4:	0f be       	out	0x3f, r0	; 63
    1bf6:	cd bf       	out	0x3d, r28	; 61
    1bf8:	8f 83       	std	Y+7, r24	; 0x07
    1bfa:	68 87       	std	Y+8, r22	; 0x08
    1bfc:	5a 87       	std	Y+10, r21	; 0x0a
    1bfe:	49 87       	std	Y+9, r20	; 0x09
    char _data = 0;
    1c00:	1e 82       	std	Y+6, r1	; 0x06
    int i =0, ii = 0;
    1c02:	1a 82       	std	Y+2, r1	; 0x02
    1c04:	19 82       	std	Y+1, r1	; 0x01
    1c06:	1c 82       	std	Y+4, r1	; 0x04
    1c08:	1b 82       	std	Y+3, r1	; 0x03


    IF_CHECK_START_CMD(_data)
    1c0a:	80 ee       	ldi	r24, 0xE0	; 224
    1c0c:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <_ZN6SpiDrv11waitSpiCharEh>
    1c10:	21 e0       	ldi	r18, 0x01	; 1
    1c12:	00 97       	sbiw	r24, 0x00	; 0
    1c14:	09 f0       	breq	.+2      	; 0x1c18 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x38>
    1c16:	20 e0       	ldi	r18, 0x00	; 0
    1c18:	22 23       	and	r18, r18
    1c1a:	19 f0       	breq	.+6      	; 0x1c22 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x42>
    1c1c:	80 e0       	ldi	r24, 0x00	; 0
    1c1e:	90 e0       	ldi	r25, 0x00	; 0
    1c20:	8b c0       	rjmp	.+278    	; 0x1d38 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x158>
    {
        CHECK_DATA(cmd | REPLY_FLAG, _data){};
    1c22:	8f 81       	ldd	r24, Y+7	; 0x07
    1c24:	28 2f       	mov	r18, r24
    1c26:	20 68       	ori	r18, 0x80	; 128
    1c28:	ce 01       	movw	r24, r28
    1c2a:	06 96       	adiw	r24, 0x06	; 6
    1c2c:	bc 01       	movw	r22, r24
    1c2e:	82 2f       	mov	r24, r18
    1c30:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    1c34:	21 e0       	ldi	r18, 0x01	; 1
    1c36:	00 97       	sbiw	r24, 0x00	; 0
    1c38:	09 f0       	breq	.+2      	; 0x1c3c <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x5c>
    1c3a:	20 e0       	ldi	r18, 0x00	; 0
    1c3c:	22 23       	and	r18, r18
    1c3e:	19 f0       	breq	.+6      	; 0x1c46 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x66>
    1c40:	80 e0       	ldi	r24, 0x00	; 0
    1c42:	90 e0       	ldi	r25, 0x00	; 0
    1c44:	79 c0       	rjmp	.+242    	; 0x1d38 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x158>

        uint8_t _numParam = readChar();
    1c46:	0e 94 3f 0c 	call	0x187e	; 0x187e <_ZN6SpiDrv8readCharEv>
    1c4a:	8d 83       	std	Y+5, r24	; 0x05
        if (_numParam != 0)
    1c4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c4e:	88 23       	and	r24, r24
    1c50:	09 f4       	brne	.+2      	; 0x1c54 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x74>
    1c52:	60 c0       	rjmp	.+192    	; 0x1d14 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x134>
        {        
            for (i=0; i<_numParam; ++i)
    1c54:	1a 82       	std	Y+2, r1	; 0x02
    1c56:	19 82       	std	Y+1, r1	; 0x01
    1c58:	4f c0       	rjmp	.+158    	; 0x1cf8 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x118>
            {
                params[i].paramLen = readParamLen8();
    1c5a:	29 81       	ldd	r18, Y+1	; 0x01
    1c5c:	3a 81       	ldd	r19, Y+2	; 0x02
    1c5e:	c9 01       	movw	r24, r18
    1c60:	88 0f       	add	r24, r24
    1c62:	99 1f       	adc	r25, r25
    1c64:	82 0f       	add	r24, r18
    1c66:	93 1f       	adc	r25, r19
    1c68:	29 85       	ldd	r18, Y+9	; 0x09
    1c6a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1c6c:	89 01       	movw	r16, r18
    1c6e:	08 0f       	add	r16, r24
    1c70:	19 1f       	adc	r17, r25
    1c72:	80 e0       	ldi	r24, 0x00	; 0
    1c74:	90 e0       	ldi	r25, 0x00	; 0
    1c76:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN6SpiDrv13readParamLen8EPh>
    1c7a:	f8 01       	movw	r30, r16
    1c7c:	80 83       	st	Z, r24
                for (ii=0; ii<params[i].paramLen; ++ii)
    1c7e:	1c 82       	std	Y+4, r1	; 0x04
    1c80:	1b 82       	std	Y+3, r1	; 0x03
    1c82:	1d c0       	rjmp	.+58     	; 0x1cbe <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0xde>
                {
                    // Get Params data
                    params[i].param[ii] = spiTransfer(DUMMY_DATA);
    1c84:	29 81       	ldd	r18, Y+1	; 0x01
    1c86:	3a 81       	ldd	r19, Y+2	; 0x02
    1c88:	c9 01       	movw	r24, r18
    1c8a:	88 0f       	add	r24, r24
    1c8c:	99 1f       	adc	r25, r25
    1c8e:	82 0f       	add	r24, r18
    1c90:	93 1f       	adc	r25, r19
    1c92:	29 85       	ldd	r18, Y+9	; 0x09
    1c94:	3a 85       	ldd	r19, Y+10	; 0x0a
    1c96:	82 0f       	add	r24, r18
    1c98:	93 1f       	adc	r25, r19
    1c9a:	fc 01       	movw	r30, r24
    1c9c:	21 81       	ldd	r18, Z+1	; 0x01
    1c9e:	32 81       	ldd	r19, Z+2	; 0x02
    1ca0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ca4:	89 01       	movw	r16, r18
    1ca6:	08 0f       	add	r16, r24
    1ca8:	19 1f       	adc	r17, r25
    1caa:	8f ef       	ldi	r24, 0xFF	; 255
    1cac:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    1cb0:	f8 01       	movw	r30, r16
    1cb2:	80 83       	st	Z, r24
        if (_numParam != 0)
        {        
            for (i=0; i<_numParam; ++i)
            {
                params[i].paramLen = readParamLen8();
                for (ii=0; ii<params[i].paramLen; ++ii)
    1cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb8:	01 96       	adiw	r24, 0x01	; 1
    1cba:	9c 83       	std	Y+4, r25	; 0x04
    1cbc:	8b 83       	std	Y+3, r24	; 0x03
    1cbe:	29 81       	ldd	r18, Y+1	; 0x01
    1cc0:	3a 81       	ldd	r19, Y+2	; 0x02
    1cc2:	c9 01       	movw	r24, r18
    1cc4:	88 0f       	add	r24, r24
    1cc6:	99 1f       	adc	r25, r25
    1cc8:	82 0f       	add	r24, r18
    1cca:	93 1f       	adc	r25, r19
    1ccc:	29 85       	ldd	r18, Y+9	; 0x09
    1cce:	3a 85       	ldd	r19, Y+10	; 0x0a
    1cd0:	82 0f       	add	r24, r18
    1cd2:	93 1f       	adc	r25, r19
    1cd4:	fc 01       	movw	r30, r24
    1cd6:	80 81       	ld	r24, Z
    1cd8:	28 2f       	mov	r18, r24
    1cda:	30 e0       	ldi	r19, 0x00	; 0
    1cdc:	41 e0       	ldi	r20, 0x01	; 1
    1cde:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ce2:	82 17       	cp	r24, r18
    1ce4:	93 07       	cpc	r25, r19
    1ce6:	0c f0       	brlt	.+2      	; 0x1cea <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x10a>
    1ce8:	40 e0       	ldi	r20, 0x00	; 0
    1cea:	44 23       	and	r20, r20
    1cec:	59 f6       	brne	.-106    	; 0x1c84 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0xa4>
        CHECK_DATA(cmd | REPLY_FLAG, _data){};

        uint8_t _numParam = readChar();
        if (_numParam != 0)
        {        
            for (i=0; i<_numParam; ++i)
    1cee:	89 81       	ldd	r24, Y+1	; 0x01
    1cf0:	9a 81       	ldd	r25, Y+2	; 0x02
    1cf2:	01 96       	adiw	r24, 0x01	; 1
    1cf4:	9a 83       	std	Y+2, r25	; 0x02
    1cf6:	89 83       	std	Y+1, r24	; 0x01
    1cf8:	8d 81       	ldd	r24, Y+5	; 0x05
    1cfa:	28 2f       	mov	r18, r24
    1cfc:	30 e0       	ldi	r19, 0x00	; 0
    1cfe:	41 e0       	ldi	r20, 0x01	; 1
    1d00:	89 81       	ldd	r24, Y+1	; 0x01
    1d02:	9a 81       	ldd	r25, Y+2	; 0x02
    1d04:	82 17       	cp	r24, r18
    1d06:	93 07       	cpc	r25, r19
    1d08:	0c f0       	brlt	.+2      	; 0x1d0c <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x12c>
    1d0a:	40 e0       	ldi	r20, 0x00	; 0
    1d0c:	44 23       	and	r20, r20
    1d0e:	09 f0       	breq	.+2      	; 0x1d12 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x132>
    1d10:	a4 cf       	rjmp	.-184    	; 0x1c5a <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x7a>
    1d12:	03 c0       	rjmp	.+6      	; 0x1d1a <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x13a>
                } 
            }
        } else
        {
            WARN("Error numParam == 0");
            return 0;
    1d14:	80 e0       	ldi	r24, 0x00	; 0
    1d16:	90 e0       	ldi	r25, 0x00	; 0
    1d18:	0f c0       	rjmp	.+30     	; 0x1d38 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x158>
        }

        if (numParam != _numParam)
    1d1a:	98 85       	ldd	r25, Y+8	; 0x08
    1d1c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d1e:	98 17       	cp	r25, r24
    1d20:	19 f0       	breq	.+6      	; 0x1d28 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x148>
        {
            WARN("Mismatch numParam");
            return 0;
    1d22:	80 e0       	ldi	r24, 0x00	; 0
    1d24:	90 e0       	ldi	r25, 0x00	; 0
    1d26:	08 c0       	rjmp	.+16     	; 0x1d38 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam+0x158>
        }

        readAndCheckChar(END_CMD, &_data);
    1d28:	ce 01       	movw	r24, r28
    1d2a:	06 96       	adiw	r24, 0x06	; 6
    1d2c:	bc 01       	movw	r22, r24
    1d2e:	8e ee       	ldi	r24, 0xEE	; 238
    1d30:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    }         
    return 1;
    1d34:	81 e0       	ldi	r24, 0x01	; 1
    1d36:	90 e0       	ldi	r25, 0x00	; 0
}
    1d38:	2a 96       	adiw	r28, 0x0a	; 10
    1d3a:	0f b6       	in	r0, 0x3f	; 63
    1d3c:	f8 94       	cli
    1d3e:	de bf       	out	0x3e, r29	; 62
    1d40:	0f be       	out	0x3f, r0	; 63
    1d42:	cd bf       	out	0x3d, r28	; 61
    1d44:	df 91       	pop	r29
    1d46:	cf 91       	pop	r28
    1d48:	1f 91       	pop	r17
    1d4a:	0f 91       	pop	r16
    1d4c:	08 95       	ret

00001d4e <_ZN6SpiDrv12waitResponseEhPhPS0_h>:
    return 1;
}
*/

int SpiDrv::waitResponse(uint8_t cmd, uint8_t* numParamRead, uint8_t** params, uint8_t maxNumParams)
{
    1d4e:	0f 93       	push	r16
    1d50:	1f 93       	push	r17
    1d52:	cf 93       	push	r28
    1d54:	df 93       	push	r29
    1d56:	cd b7       	in	r28, 0x3d	; 61
    1d58:	de b7       	in	r29, 0x3e	; 62
    1d5a:	cd 54       	subi	r28, 0x4D	; 77
    1d5c:	d1 09       	sbc	r29, r1
    1d5e:	0f b6       	in	r0, 0x3f	; 63
    1d60:	f8 94       	cli
    1d62:	de bf       	out	0x3e, r29	; 62
    1d64:	0f be       	out	0x3f, r0	; 63
    1d66:	cd bf       	out	0x3d, r28	; 61
    1d68:	fe 01       	movw	r30, r28
    1d6a:	e8 5b       	subi	r30, 0xB8	; 184
    1d6c:	ff 4f       	sbci	r31, 0xFF	; 255
    1d6e:	80 83       	st	Z, r24
    1d70:	ce 01       	movw	r24, r28
    1d72:	87 5b       	subi	r24, 0xB7	; 183
    1d74:	9f 4f       	sbci	r25, 0xFF	; 255
    1d76:	fc 01       	movw	r30, r24
    1d78:	71 83       	std	Z+1, r23	; 0x01
    1d7a:	60 83       	st	Z, r22
    1d7c:	ce 01       	movw	r24, r28
    1d7e:	85 5b       	subi	r24, 0xB5	; 181
    1d80:	9f 4f       	sbci	r25, 0xFF	; 255
    1d82:	fc 01       	movw	r30, r24
    1d84:	51 83       	std	Z+1, r21	; 0x01
    1d86:	40 83       	st	Z, r20
    1d88:	ce 01       	movw	r24, r28
    1d8a:	83 5b       	subi	r24, 0xB3	; 179
    1d8c:	9f 4f       	sbci	r25, 0xFF	; 255
    1d8e:	fc 01       	movw	r30, r24
    1d90:	20 83       	st	Z, r18
    char _data = 0;
    1d92:	1f 82       	std	Y+7, r1	; 0x07
    int i =0, ii = 0;
    1d94:	1a 82       	std	Y+2, r1	; 0x02
    1d96:	19 82       	std	Y+1, r1	; 0x01
    1d98:	1c 82       	std	Y+4, r1	; 0x04
    1d9a:	1b 82       	std	Y+3, r1	; 0x03

    char    *index[WL_SSID_MAX_LENGTH];

    for (i = 0 ; i < WL_NETWORKS_LIST_MAXNUM ; i++)
    1d9c:	1a 82       	std	Y+2, r1	; 0x02
    1d9e:	19 82       	std	Y+1, r1	; 0x01
    1da0:	24 c0       	rjmp	.+72     	; 0x1dea <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x9c>
            index[i] = (char *)params + WL_SSID_MAX_LENGTH*i;
    1da2:	89 81       	ldd	r24, Y+1	; 0x01
    1da4:	9a 81       	ldd	r25, Y+2	; 0x02
    1da6:	88 0f       	add	r24, r24
    1da8:	99 1f       	adc	r25, r25
    1daa:	82 95       	swap	r24
    1dac:	92 95       	swap	r25
    1dae:	90 7f       	andi	r25, 0xF0	; 240
    1db0:	98 27       	eor	r25, r24
    1db2:	80 7f       	andi	r24, 0xF0	; 240
    1db4:	98 27       	eor	r25, r24
    1db6:	9e 01       	movw	r18, r28
    1db8:	25 5b       	subi	r18, 0xB5	; 181
    1dba:	3f 4f       	sbci	r19, 0xFF	; 255
    1dbc:	f9 01       	movw	r30, r18
    1dbe:	20 81       	ld	r18, Z
    1dc0:	31 81       	ldd	r19, Z+1	; 0x01
    1dc2:	28 0f       	add	r18, r24
    1dc4:	39 1f       	adc	r19, r25
    1dc6:	89 81       	ldd	r24, Y+1	; 0x01
    1dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    1dca:	88 0f       	add	r24, r24
    1dcc:	99 1f       	adc	r25, r25
    1dce:	ae 01       	movw	r20, r28
    1dd0:	4f 5f       	subi	r20, 0xFF	; 255
    1dd2:	5f 4f       	sbci	r21, 0xFF	; 255
    1dd4:	84 0f       	add	r24, r20
    1dd6:	95 1f       	adc	r25, r21
    1dd8:	07 96       	adiw	r24, 0x07	; 7
    1dda:	fc 01       	movw	r30, r24
    1ddc:	31 83       	std	Z+1, r19	; 0x01
    1dde:	20 83       	st	Z, r18
    char _data = 0;
    int i =0, ii = 0;

    char    *index[WL_SSID_MAX_LENGTH];

    for (i = 0 ; i < WL_NETWORKS_LIST_MAXNUM ; i++)
    1de0:	89 81       	ldd	r24, Y+1	; 0x01
    1de2:	9a 81       	ldd	r25, Y+2	; 0x02
    1de4:	01 96       	adiw	r24, 0x01	; 1
    1de6:	9a 83       	std	Y+2, r25	; 0x02
    1de8:	89 83       	std	Y+1, r24	; 0x01
    1dea:	21 e0       	ldi	r18, 0x01	; 1
    1dec:	89 81       	ldd	r24, Y+1	; 0x01
    1dee:	9a 81       	ldd	r25, Y+2	; 0x02
    1df0:	8a 30       	cpi	r24, 0x0A	; 10
    1df2:	91 05       	cpc	r25, r1
    1df4:	0c f0       	brlt	.+2      	; 0x1df8 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0xaa>
    1df6:	20 e0       	ldi	r18, 0x00	; 0
    1df8:	22 23       	and	r18, r18
    1dfa:	99 f6       	brne	.-90     	; 0x1da2 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x54>
            index[i] = (char *)params + WL_SSID_MAX_LENGTH*i;

    IF_CHECK_START_CMD(_data)
    1dfc:	80 ee       	ldi	r24, 0xE0	; 224
    1dfe:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <_ZN6SpiDrv11waitSpiCharEh>
    1e02:	21 e0       	ldi	r18, 0x01	; 1
    1e04:	00 97       	sbiw	r24, 0x00	; 0
    1e06:	09 f0       	breq	.+2      	; 0x1e0a <_ZN6SpiDrv12waitResponseEhPhPS0_h+0xbc>
    1e08:	20 e0       	ldi	r18, 0x00	; 0
    1e0a:	22 23       	and	r18, r18
    1e0c:	19 f0       	breq	.+6      	; 0x1e14 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0xc6>
    1e0e:	80 e0       	ldi	r24, 0x00	; 0
    1e10:	90 e0       	ldi	r25, 0x00	; 0
    1e12:	9e c0       	rjmp	.+316    	; 0x1f50 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x202>
    {
        CHECK_DATA(cmd | REPLY_FLAG, _data){};
    1e14:	ce 01       	movw	r24, r28
    1e16:	88 5b       	subi	r24, 0xB8	; 184
    1e18:	9f 4f       	sbci	r25, 0xFF	; 255
    1e1a:	fc 01       	movw	r30, r24
    1e1c:	80 81       	ld	r24, Z
    1e1e:	28 2f       	mov	r18, r24
    1e20:	20 68       	ori	r18, 0x80	; 128
    1e22:	ce 01       	movw	r24, r28
    1e24:	07 96       	adiw	r24, 0x07	; 7
    1e26:	bc 01       	movw	r22, r24
    1e28:	82 2f       	mov	r24, r18
    1e2a:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    1e2e:	21 e0       	ldi	r18, 0x01	; 1
    1e30:	00 97       	sbiw	r24, 0x00	; 0
    1e32:	09 f0       	breq	.+2      	; 0x1e36 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0xe8>
    1e34:	20 e0       	ldi	r18, 0x00	; 0
    1e36:	22 23       	and	r18, r18
    1e38:	19 f0       	breq	.+6      	; 0x1e40 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0xf2>
    1e3a:	80 e0       	ldi	r24, 0x00	; 0
    1e3c:	90 e0       	ldi	r25, 0x00	; 0
    1e3e:	88 c0       	rjmp	.+272    	; 0x1f50 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x202>

        uint8_t numParam = readChar();
    1e40:	0e 94 3f 0c 	call	0x187e	; 0x187e <_ZN6SpiDrv8readCharEv>
    1e44:	8d 83       	std	Y+5, r24	; 0x05

        if (numParam > maxNumParams)
    1e46:	ce 01       	movw	r24, r28
    1e48:	83 5b       	subi	r24, 0xB3	; 179
    1e4a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e4c:	2d 81       	ldd	r18, Y+5	; 0x05
    1e4e:	fc 01       	movw	r30, r24
    1e50:	80 81       	ld	r24, Z
    1e52:	82 17       	cp	r24, r18
    1e54:	30 f4       	brcc	.+12     	; 0x1e62 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x114>
        {
            numParam = maxNumParams;
    1e56:	ce 01       	movw	r24, r28
    1e58:	83 5b       	subi	r24, 0xB3	; 179
    1e5a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e5c:	fc 01       	movw	r30, r24
    1e5e:	80 81       	ld	r24, Z
    1e60:	8d 83       	std	Y+5, r24	; 0x05
        }
        *numParamRead = numParam;
    1e62:	ce 01       	movw	r24, r28
    1e64:	87 5b       	subi	r24, 0xB7	; 183
    1e66:	9f 4f       	sbci	r25, 0xFF	; 255
    1e68:	fc 01       	movw	r30, r24
    1e6a:	80 81       	ld	r24, Z
    1e6c:	91 81       	ldd	r25, Z+1	; 0x01
    1e6e:	2d 81       	ldd	r18, Y+5	; 0x05
    1e70:	fc 01       	movw	r30, r24
    1e72:	20 83       	st	Z, r18
        if (numParam != 0)
    1e74:	8d 81       	ldd	r24, Y+5	; 0x05
    1e76:	88 23       	and	r24, r24
    1e78:	09 f4       	brne	.+2      	; 0x1e7c <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x12e>
    1e7a:	59 c0       	rjmp	.+178    	; 0x1f2e <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x1e0>
        {
            for (i=0; i<numParam; ++i)
    1e7c:	1a 82       	std	Y+2, r1	; 0x02
    1e7e:	19 82       	std	Y+1, r1	; 0x01
    1e80:	48 c0       	rjmp	.+144    	; 0x1f12 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x1c4>
            {
            	uint8_t paramLen = readParamLen8();
    1e82:	80 e0       	ldi	r24, 0x00	; 0
    1e84:	90 e0       	ldi	r25, 0x00	; 0
    1e86:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN6SpiDrv13readParamLen8EPh>
    1e8a:	8e 83       	std	Y+6, r24	; 0x06
                for (ii=0; ii<paramLen; ++ii)
    1e8c:	1c 82       	std	Y+4, r1	; 0x04
    1e8e:	1b 82       	std	Y+3, r1	; 0x03
    1e90:	1c c0       	rjmp	.+56     	; 0x1eca <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x17c>
                {
                	//ssid[ii] = spiTransfer(DUMMY_DATA);
                    // Get Params data
                    index[i][ii] = (uint8_t)spiTransfer(DUMMY_DATA);
    1e92:	89 81       	ldd	r24, Y+1	; 0x01
    1e94:	9a 81       	ldd	r25, Y+2	; 0x02
    1e96:	88 0f       	add	r24, r24
    1e98:	99 1f       	adc	r25, r25
    1e9a:	9e 01       	movw	r18, r28
    1e9c:	2f 5f       	subi	r18, 0xFF	; 255
    1e9e:	3f 4f       	sbci	r19, 0xFF	; 255
    1ea0:	82 0f       	add	r24, r18
    1ea2:	93 1f       	adc	r25, r19
    1ea4:	07 96       	adiw	r24, 0x07	; 7
    1ea6:	fc 01       	movw	r30, r24
    1ea8:	20 81       	ld	r18, Z
    1eaa:	31 81       	ldd	r19, Z+1	; 0x01
    1eac:	8b 81       	ldd	r24, Y+3	; 0x03
    1eae:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb0:	89 01       	movw	r16, r18
    1eb2:	08 0f       	add	r16, r24
    1eb4:	19 1f       	adc	r17, r25
    1eb6:	8f ef       	ldi	r24, 0xFF	; 255
    1eb8:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    1ebc:	f8 01       	movw	r30, r16
    1ebe:	80 83       	st	Z, r24
        if (numParam != 0)
        {
            for (i=0; i<numParam; ++i)
            {
            	uint8_t paramLen = readParamLen8();
                for (ii=0; ii<paramLen; ++ii)
    1ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec4:	01 96       	adiw	r24, 0x01	; 1
    1ec6:	9c 83       	std	Y+4, r25	; 0x04
    1ec8:	8b 83       	std	Y+3, r24	; 0x03
    1eca:	8e 81       	ldd	r24, Y+6	; 0x06
    1ecc:	28 2f       	mov	r18, r24
    1ece:	30 e0       	ldi	r19, 0x00	; 0
    1ed0:	41 e0       	ldi	r20, 0x01	; 1
    1ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ed6:	82 17       	cp	r24, r18
    1ed8:	93 07       	cpc	r25, r19
    1eda:	0c f0       	brlt	.+2      	; 0x1ede <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x190>
    1edc:	40 e0       	ldi	r20, 0x00	; 0
    1ede:	44 23       	and	r20, r20
    1ee0:	c1 f6       	brne	.-80     	; 0x1e92 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x144>
                	//ssid[ii] = spiTransfer(DUMMY_DATA);
                    // Get Params data
                    index[i][ii] = (uint8_t)spiTransfer(DUMMY_DATA);

                }
                index[i][ii]=0;
    1ee2:	89 81       	ldd	r24, Y+1	; 0x01
    1ee4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee6:	88 0f       	add	r24, r24
    1ee8:	99 1f       	adc	r25, r25
    1eea:	9e 01       	movw	r18, r28
    1eec:	2f 5f       	subi	r18, 0xFF	; 255
    1eee:	3f 4f       	sbci	r19, 0xFF	; 255
    1ef0:	82 0f       	add	r24, r18
    1ef2:	93 1f       	adc	r25, r19
    1ef4:	07 96       	adiw	r24, 0x07	; 7
    1ef6:	fc 01       	movw	r30, r24
    1ef8:	20 81       	ld	r18, Z
    1efa:	31 81       	ldd	r19, Z+1	; 0x01
    1efc:	8b 81       	ldd	r24, Y+3	; 0x03
    1efe:	9c 81       	ldd	r25, Y+4	; 0x04
    1f00:	82 0f       	add	r24, r18
    1f02:	93 1f       	adc	r25, r19
    1f04:	fc 01       	movw	r30, r24
    1f06:	10 82       	st	Z, r1
            numParam = maxNumParams;
        }
        *numParamRead = numParam;
        if (numParam != 0)
        {
            for (i=0; i<numParam; ++i)
    1f08:	89 81       	ldd	r24, Y+1	; 0x01
    1f0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f0c:	01 96       	adiw	r24, 0x01	; 1
    1f0e:	9a 83       	std	Y+2, r25	; 0x02
    1f10:	89 83       	std	Y+1, r24	; 0x01
    1f12:	8d 81       	ldd	r24, Y+5	; 0x05
    1f14:	28 2f       	mov	r18, r24
    1f16:	30 e0       	ldi	r19, 0x00	; 0
    1f18:	41 e0       	ldi	r20, 0x01	; 1
    1f1a:	89 81       	ldd	r24, Y+1	; 0x01
    1f1c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f1e:	82 17       	cp	r24, r18
    1f20:	93 07       	cpc	r25, r19
    1f22:	0c f0       	brlt	.+2      	; 0x1f26 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x1d8>
    1f24:	40 e0       	ldi	r20, 0x00	; 0
    1f26:	44 23       	and	r20, r20
    1f28:	09 f0       	breq	.+2      	; 0x1f2c <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x1de>
    1f2a:	ab cf       	rjmp	.-170    	; 0x1e82 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x134>
    1f2c:	09 c0       	rjmp	.+18     	; 0x1f40 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x1f2>
                index[i][ii]=0;
            }
        } else
        {
            WARN("Error numParams == 0");
            readAndCheckChar(END_CMD, &_data);
    1f2e:	ce 01       	movw	r24, r28
    1f30:	07 96       	adiw	r24, 0x07	; 7
    1f32:	bc 01       	movw	r22, r24
    1f34:	8e ee       	ldi	r24, 0xEE	; 238
    1f36:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
            return 0;
    1f3a:	80 e0       	ldi	r24, 0x00	; 0
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	08 c0       	rjmp	.+16     	; 0x1f50 <_ZN6SpiDrv12waitResponseEhPhPS0_h+0x202>
        }
        readAndCheckChar(END_CMD, &_data);
    1f40:	ce 01       	movw	r24, r28
    1f42:	07 96       	adiw	r24, 0x07	; 7
    1f44:	bc 01       	movw	r22, r24
    1f46:	8e ee       	ldi	r24, 0xEE	; 238
    1f48:	0e 94 21 0c 	call	0x1842	; 0x1842 <_ZN6SpiDrv16readAndCheckCharEcPc>
    }
    return 1;
    1f4c:	81 e0       	ldi	r24, 0x01	; 1
    1f4e:	90 e0       	ldi	r25, 0x00	; 0
}
    1f50:	c3 5b       	subi	r28, 0xB3	; 179
    1f52:	df 4f       	sbci	r29, 0xFF	; 255
    1f54:	0f b6       	in	r0, 0x3f	; 63
    1f56:	f8 94       	cli
    1f58:	de bf       	out	0x3e, r29	; 62
    1f5a:	0f be       	out	0x3f, r0	; 63
    1f5c:	cd bf       	out	0x3d, r28	; 61
    1f5e:	df 91       	pop	r29
    1f60:	cf 91       	pop	r28
    1f62:	1f 91       	pop	r17
    1f64:	0f 91       	pop	r16
    1f66:	08 95       	ret

00001f68 <_ZN6SpiDrv9sendParamEPhhh>:


void SpiDrv::sendParam(uint8_t* param, uint8_t param_len, uint8_t lastParam)
{
    1f68:	cf 93       	push	r28
    1f6a:	df 93       	push	r29
    1f6c:	00 d0       	rcall	.+0      	; 0x1f6e <_ZN6SpiDrv9sendParamEPhhh+0x6>
    1f6e:	00 d0       	rcall	.+0      	; 0x1f70 <_ZN6SpiDrv9sendParamEPhhh+0x8>
    1f70:	00 d0       	rcall	.+0      	; 0x1f72 <_ZN6SpiDrv9sendParamEPhhh+0xa>
    1f72:	cd b7       	in	r28, 0x3d	; 61
    1f74:	de b7       	in	r29, 0x3e	; 62
    1f76:	9c 83       	std	Y+4, r25	; 0x04
    1f78:	8b 83       	std	Y+3, r24	; 0x03
    1f7a:	6d 83       	std	Y+5, r22	; 0x05
    1f7c:	4e 83       	std	Y+6, r20	; 0x06
    int i = 0;
    1f7e:	1a 82       	std	Y+2, r1	; 0x02
    1f80:	19 82       	std	Y+1, r1	; 0x01
    // Send Spi paramLen
    sendParamLen8(param_len);
    1f82:	8d 81       	ldd	r24, Y+5	; 0x05
    1f84:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <_ZN6SpiDrv13sendParamLen8Eh>

    // Send Spi param data
    for (i=0; i<param_len; ++i)
    1f88:	1a 82       	std	Y+2, r1	; 0x02
    1f8a:	19 82       	std	Y+1, r1	; 0x01
    1f8c:	0f c0       	rjmp	.+30     	; 0x1fac <_ZN6SpiDrv9sendParamEPhhh+0x44>
    {
        spiTransfer(param[i]);
    1f8e:	89 81       	ldd	r24, Y+1	; 0x01
    1f90:	9a 81       	ldd	r25, Y+2	; 0x02
    1f92:	2b 81       	ldd	r18, Y+3	; 0x03
    1f94:	3c 81       	ldd	r19, Y+4	; 0x04
    1f96:	82 0f       	add	r24, r18
    1f98:	93 1f       	adc	r25, r19
    1f9a:	fc 01       	movw	r30, r24
    1f9c:	80 81       	ld	r24, Z
    1f9e:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    int i = 0;
    // Send Spi paramLen
    sendParamLen8(param_len);

    // Send Spi param data
    for (i=0; i<param_len; ++i)
    1fa2:	89 81       	ldd	r24, Y+1	; 0x01
    1fa4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fa6:	01 96       	adiw	r24, 0x01	; 1
    1fa8:	9a 83       	std	Y+2, r25	; 0x02
    1faa:	89 83       	std	Y+1, r24	; 0x01
    1fac:	8d 81       	ldd	r24, Y+5	; 0x05
    1fae:	28 2f       	mov	r18, r24
    1fb0:	30 e0       	ldi	r19, 0x00	; 0
    1fb2:	41 e0       	ldi	r20, 0x01	; 1
    1fb4:	89 81       	ldd	r24, Y+1	; 0x01
    1fb6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fb8:	82 17       	cp	r24, r18
    1fba:	93 07       	cpc	r25, r19
    1fbc:	0c f0       	brlt	.+2      	; 0x1fc0 <_ZN6SpiDrv9sendParamEPhhh+0x58>
    1fbe:	40 e0       	ldi	r20, 0x00	; 0
    1fc0:	44 23       	and	r20, r20
    1fc2:	29 f7       	brne	.-54     	; 0x1f8e <_ZN6SpiDrv9sendParamEPhhh+0x26>
    {
        spiTransfer(param[i]);
    }

    // if lastParam==1 Send Spi END CMD
    if (lastParam == 1)
    1fc4:	8e 81       	ldd	r24, Y+6	; 0x06
    1fc6:	81 30       	cpi	r24, 0x01	; 1
    1fc8:	19 f4       	brne	.+6      	; 0x1fd0 <_ZN6SpiDrv9sendParamEPhhh+0x68>
        spiTransfer(END_CMD);
    1fca:	8e ee       	ldi	r24, 0xEE	; 238
    1fcc:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
}
    1fd0:	26 96       	adiw	r28, 0x06	; 6
    1fd2:	0f b6       	in	r0, 0x3f	; 63
    1fd4:	f8 94       	cli
    1fd6:	de bf       	out	0x3e, r29	; 62
    1fd8:	0f be       	out	0x3f, r0	; 63
    1fda:	cd bf       	out	0x3d, r28	; 61
    1fdc:	df 91       	pop	r29
    1fde:	cf 91       	pop	r28
    1fe0:	08 95       	ret

00001fe2 <_ZN6SpiDrv13sendParamLen8Eh>:

void SpiDrv::sendParamLen8(uint8_t param_len)
{
    1fe2:	cf 93       	push	r28
    1fe4:	df 93       	push	r29
    1fe6:	1f 92       	push	r1
    1fe8:	cd b7       	in	r28, 0x3d	; 61
    1fea:	de b7       	in	r29, 0x3e	; 62
    1fec:	89 83       	std	Y+1, r24	; 0x01
    // Send Spi paramLen
    spiTransfer(param_len);
    1fee:	89 81       	ldd	r24, Y+1	; 0x01
    1ff0:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
}
    1ff4:	0f 90       	pop	r0
    1ff6:	df 91       	pop	r29
    1ff8:	cf 91       	pop	r28
    1ffa:	08 95       	ret

00001ffc <_ZN6SpiDrv14sendParamLen16Ej>:

void SpiDrv::sendParamLen16(uint16_t param_len)
{
    1ffc:	cf 93       	push	r28
    1ffe:	df 93       	push	r29
    2000:	00 d0       	rcall	.+0      	; 0x2002 <_ZN6SpiDrv14sendParamLen16Ej+0x6>
    2002:	cd b7       	in	r28, 0x3d	; 61
    2004:	de b7       	in	r29, 0x3e	; 62
    2006:	9a 83       	std	Y+2, r25	; 0x02
    2008:	89 83       	std	Y+1, r24	; 0x01
    // Send Spi paramLen
    spiTransfer((uint8_t)((param_len & 0xff00)>>8));
    200a:	89 81       	ldd	r24, Y+1	; 0x01
    200c:	9a 81       	ldd	r25, Y+2	; 0x02
    200e:	89 2f       	mov	r24, r25
    2010:	99 27       	eor	r25, r25
    2012:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    spiTransfer((uint8_t)(param_len & 0xff));
    2016:	89 81       	ldd	r24, Y+1	; 0x01
    2018:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
}
    201c:	0f 90       	pop	r0
    201e:	0f 90       	pop	r0
    2020:	df 91       	pop	r29
    2022:	cf 91       	pop	r28
    2024:	08 95       	ret

00002026 <_ZN6SpiDrv13readParamLen8EPh>:

uint8_t SpiDrv::readParamLen8(uint8_t* param_len)
{
    2026:	cf 93       	push	r28
    2028:	df 93       	push	r29
    202a:	00 d0       	rcall	.+0      	; 0x202c <_ZN6SpiDrv13readParamLen8EPh+0x6>
    202c:	1f 92       	push	r1
    202e:	cd b7       	in	r28, 0x3d	; 61
    2030:	de b7       	in	r29, 0x3e	; 62
    2032:	9b 83       	std	Y+3, r25	; 0x03
    2034:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t _param_len = spiTransfer(DUMMY_DATA);
    2036:	8f ef       	ldi	r24, 0xFF	; 255
    2038:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    203c:	89 83       	std	Y+1, r24	; 0x01
    if (param_len != NULL)
    203e:	8a 81       	ldd	r24, Y+2	; 0x02
    2040:	9b 81       	ldd	r25, Y+3	; 0x03
    2042:	00 97       	sbiw	r24, 0x00	; 0
    2044:	29 f0       	breq	.+10     	; 0x2050 <_ZN6SpiDrv13readParamLen8EPh+0x2a>
    {
        *param_len = _param_len;
    2046:	8a 81       	ldd	r24, Y+2	; 0x02
    2048:	9b 81       	ldd	r25, Y+3	; 0x03
    204a:	29 81       	ldd	r18, Y+1	; 0x01
    204c:	fc 01       	movw	r30, r24
    204e:	20 83       	st	Z, r18
    }
    return _param_len;
    2050:	89 81       	ldd	r24, Y+1	; 0x01
}
    2052:	0f 90       	pop	r0
    2054:	0f 90       	pop	r0
    2056:	0f 90       	pop	r0
    2058:	df 91       	pop	r29
    205a:	cf 91       	pop	r28
    205c:	08 95       	ret

0000205e <_ZN6SpiDrv14readParamLen16EPj>:

uint16_t SpiDrv::readParamLen16(uint16_t* param_len)
{
    205e:	0f 93       	push	r16
    2060:	1f 93       	push	r17
    2062:	cf 93       	push	r28
    2064:	df 93       	push	r29
    2066:	00 d0       	rcall	.+0      	; 0x2068 <_ZN6SpiDrv14readParamLen16EPj+0xa>
    2068:	00 d0       	rcall	.+0      	; 0x206a <_ZN6SpiDrv14readParamLen16EPj+0xc>
    206a:	cd b7       	in	r28, 0x3d	; 61
    206c:	de b7       	in	r29, 0x3e	; 62
    206e:	9c 83       	std	Y+4, r25	; 0x04
    2070:	8b 83       	std	Y+3, r24	; 0x03
    uint16_t _param_len = spiTransfer(DUMMY_DATA)<<8 | (spiTransfer(DUMMY_DATA)& 0xff);
    2072:	8f ef       	ldi	r24, 0xFF	; 255
    2074:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    2078:	88 2f       	mov	r24, r24
    207a:	90 e0       	ldi	r25, 0x00	; 0
    207c:	18 2f       	mov	r17, r24
    207e:	00 27       	eor	r16, r16
    2080:	8f ef       	ldi	r24, 0xFF	; 255
    2082:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    2086:	88 2f       	mov	r24, r24
    2088:	90 e0       	ldi	r25, 0x00	; 0
    208a:	80 2b       	or	r24, r16
    208c:	91 2b       	or	r25, r17
    208e:	9a 83       	std	Y+2, r25	; 0x02
    2090:	89 83       	std	Y+1, r24	; 0x01
    if (param_len != NULL)
    2092:	8b 81       	ldd	r24, Y+3	; 0x03
    2094:	9c 81       	ldd	r25, Y+4	; 0x04
    2096:	00 97       	sbiw	r24, 0x00	; 0
    2098:	39 f0       	breq	.+14     	; 0x20a8 <_ZN6SpiDrv14readParamLen16EPj+0x4a>
    {
        *param_len = _param_len;
    209a:	8b 81       	ldd	r24, Y+3	; 0x03
    209c:	9c 81       	ldd	r25, Y+4	; 0x04
    209e:	29 81       	ldd	r18, Y+1	; 0x01
    20a0:	3a 81       	ldd	r19, Y+2	; 0x02
    20a2:	fc 01       	movw	r30, r24
    20a4:	31 83       	std	Z+1, r19	; 0x01
    20a6:	20 83       	st	Z, r18
    }
    return _param_len;
    20a8:	89 81       	ldd	r24, Y+1	; 0x01
    20aa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    20ac:	0f 90       	pop	r0
    20ae:	0f 90       	pop	r0
    20b0:	0f 90       	pop	r0
    20b2:	0f 90       	pop	r0
    20b4:	df 91       	pop	r29
    20b6:	cf 91       	pop	r28
    20b8:	1f 91       	pop	r17
    20ba:	0f 91       	pop	r16
    20bc:	08 95       	ret

000020be <_ZN6SpiDrv10sendBufferEPhjh>:


void SpiDrv::sendBuffer(uint8_t* param, uint16_t param_len, uint8_t lastParam)
{
    20be:	cf 93       	push	r28
    20c0:	df 93       	push	r29
    20c2:	cd b7       	in	r28, 0x3d	; 61
    20c4:	de b7       	in	r29, 0x3e	; 62
    20c6:	27 97       	sbiw	r28, 0x07	; 7
    20c8:	0f b6       	in	r0, 0x3f	; 63
    20ca:	f8 94       	cli
    20cc:	de bf       	out	0x3e, r29	; 62
    20ce:	0f be       	out	0x3f, r0	; 63
    20d0:	cd bf       	out	0x3d, r28	; 61
    20d2:	9c 83       	std	Y+4, r25	; 0x04
    20d4:	8b 83       	std	Y+3, r24	; 0x03
    20d6:	7e 83       	std	Y+6, r23	; 0x06
    20d8:	6d 83       	std	Y+5, r22	; 0x05
    20da:	4f 83       	std	Y+7, r20	; 0x07
    uint16_t i = 0;
    20dc:	1a 82       	std	Y+2, r1	; 0x02
    20de:	19 82       	std	Y+1, r1	; 0x01

    // Send Spi paramLen
    sendParamLen16(param_len);
    20e0:	8d 81       	ldd	r24, Y+5	; 0x05
    20e2:	9e 81       	ldd	r25, Y+6	; 0x06
    20e4:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <_ZN6SpiDrv14sendParamLen16Ej>

    // Send Spi param data
    for (i=0; i<param_len; ++i)
    20e8:	1a 82       	std	Y+2, r1	; 0x02
    20ea:	19 82       	std	Y+1, r1	; 0x01
    20ec:	0f c0       	rjmp	.+30     	; 0x210c <_ZN6SpiDrv10sendBufferEPhjh+0x4e>
    {
        spiTransfer(param[i]);
    20ee:	2b 81       	ldd	r18, Y+3	; 0x03
    20f0:	3c 81       	ldd	r19, Y+4	; 0x04
    20f2:	89 81       	ldd	r24, Y+1	; 0x01
    20f4:	9a 81       	ldd	r25, Y+2	; 0x02
    20f6:	82 0f       	add	r24, r18
    20f8:	93 1f       	adc	r25, r19
    20fa:	fc 01       	movw	r30, r24
    20fc:	80 81       	ld	r24, Z
    20fe:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>

    // Send Spi paramLen
    sendParamLen16(param_len);

    // Send Spi param data
    for (i=0; i<param_len; ++i)
    2102:	89 81       	ldd	r24, Y+1	; 0x01
    2104:	9a 81       	ldd	r25, Y+2	; 0x02
    2106:	01 96       	adiw	r24, 0x01	; 1
    2108:	9a 83       	std	Y+2, r25	; 0x02
    210a:	89 83       	std	Y+1, r24	; 0x01
    210c:	41 e0       	ldi	r20, 0x01	; 1
    210e:	29 81       	ldd	r18, Y+1	; 0x01
    2110:	3a 81       	ldd	r19, Y+2	; 0x02
    2112:	8d 81       	ldd	r24, Y+5	; 0x05
    2114:	9e 81       	ldd	r25, Y+6	; 0x06
    2116:	28 17       	cp	r18, r24
    2118:	39 07       	cpc	r19, r25
    211a:	08 f0       	brcs	.+2      	; 0x211e <_ZN6SpiDrv10sendBufferEPhjh+0x60>
    211c:	40 e0       	ldi	r20, 0x00	; 0
    211e:	44 23       	and	r20, r20
    2120:	31 f7       	brne	.-52     	; 0x20ee <_ZN6SpiDrv10sendBufferEPhjh+0x30>
    {
        spiTransfer(param[i]);
    }

    // if lastParam==1 Send Spi END CMD
    if (lastParam == 1)
    2122:	8f 81       	ldd	r24, Y+7	; 0x07
    2124:	81 30       	cpi	r24, 0x01	; 1
    2126:	19 f4       	brne	.+6      	; 0x212e <_ZN6SpiDrv10sendBufferEPhjh+0x70>
        spiTransfer(END_CMD);
    2128:	8e ee       	ldi	r24, 0xEE	; 238
    212a:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
}
    212e:	27 96       	adiw	r28, 0x07	; 7
    2130:	0f b6       	in	r0, 0x3f	; 63
    2132:	f8 94       	cli
    2134:	de bf       	out	0x3e, r29	; 62
    2136:	0f be       	out	0x3f, r0	; 63
    2138:	cd bf       	out	0x3d, r28	; 61
    213a:	df 91       	pop	r29
    213c:	cf 91       	pop	r28
    213e:	08 95       	ret

00002140 <_ZN6SpiDrv9sendParamEjh>:


void SpiDrv::sendParam(uint16_t param, uint8_t lastParam)
{
    2140:	cf 93       	push	r28
    2142:	df 93       	push	r29
    2144:	00 d0       	rcall	.+0      	; 0x2146 <_ZN6SpiDrv9sendParamEjh+0x6>
    2146:	1f 92       	push	r1
    2148:	cd b7       	in	r28, 0x3d	; 61
    214a:	de b7       	in	r29, 0x3e	; 62
    214c:	9a 83       	std	Y+2, r25	; 0x02
    214e:	89 83       	std	Y+1, r24	; 0x01
    2150:	6b 83       	std	Y+3, r22	; 0x03
    // Send Spi paramLen
    sendParamLen8(2);
    2152:	82 e0       	ldi	r24, 0x02	; 2
    2154:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <_ZN6SpiDrv13sendParamLen8Eh>

    spiTransfer((uint8_t)((param & 0xff00)>>8));
    2158:	89 81       	ldd	r24, Y+1	; 0x01
    215a:	9a 81       	ldd	r25, Y+2	; 0x02
    215c:	89 2f       	mov	r24, r25
    215e:	99 27       	eor	r25, r25
    2160:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
    spiTransfer((uint8_t)(param & 0xff));
    2164:	89 81       	ldd	r24, Y+1	; 0x01
    2166:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>

    // if lastParam==1 Send Spi END CMD
    if (lastParam == 1)
    216a:	8b 81       	ldd	r24, Y+3	; 0x03
    216c:	81 30       	cpi	r24, 0x01	; 1
    216e:	19 f4       	brne	.+6      	; 0x2176 <_ZN6SpiDrv9sendParamEjh+0x36>
        spiTransfer(END_CMD);
    2170:	8e ee       	ldi	r24, 0xEE	; 238
    2172:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>
}
    2176:	0f 90       	pop	r0
    2178:	0f 90       	pop	r0
    217a:	0f 90       	pop	r0
    217c:	df 91       	pop	r29
    217e:	cf 91       	pop	r28
    2180:	08 95       	ret

00002182 <_ZN6SpiDrv7sendCmdEhh>:
/*|___________|______|______|_________|_________|___________|________|____|_________| */
/*|   8 bit   | 1bit | 7bit |  8bit   |  8bit   |   8bit    | nbytes | .. |   8bit  | */
/*|___________|______|______|_________|_________|___________|________|____|_________| */

void SpiDrv::sendCmd(uint8_t cmd, uint8_t numParam)
{
    2182:	cf 93       	push	r28
    2184:	df 93       	push	r29
    2186:	00 d0       	rcall	.+0      	; 0x2188 <_ZN6SpiDrv7sendCmdEhh+0x6>
    2188:	cd b7       	in	r28, 0x3d	; 61
    218a:	de b7       	in	r29, 0x3e	; 62
    218c:	89 83       	std	Y+1, r24	; 0x01
    218e:	6a 83       	std	Y+2, r22	; 0x02
    // Send Spi START CMD
    spiTransfer(START_CMD);
    2190:	80 ee       	ldi	r24, 0xE0	; 224
    2192:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>

    //waitForSlaveSign();
    //wait the interrupt trigger on slave
    delayMicroseconds(SPI_START_CMD_DELAY);
    2196:	8c e0       	ldi	r24, 0x0C	; 12
    2198:	90 e0       	ldi	r25, 0x00	; 0
    219a:	0e 94 8e 7e 	call	0xfd1c	; 0xfd1c <delayMicroseconds>

    // Send Spi C + cmd
    spiTransfer(cmd & ~(REPLY_FLAG));
    219e:	89 81       	ldd	r24, Y+1	; 0x01
    21a0:	8f 77       	andi	r24, 0x7F	; 127
    21a2:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>

    // Send Spi totLen
    //spiTransfer(totLen);

    // Send Spi numParam
    spiTransfer(numParam);
    21a6:	8a 81       	ldd	r24, Y+2	; 0x02
    21a8:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>

    // If numParam == 0 send END CMD
    if (numParam == 0)
    21ac:	8a 81       	ldd	r24, Y+2	; 0x02
    21ae:	88 23       	and	r24, r24
    21b0:	19 f4       	brne	.+6      	; 0x21b8 <_ZN6SpiDrv7sendCmdEhh+0x36>
        spiTransfer(END_CMD);
    21b2:	8e ee       	ldi	r24, 0xEE	; 238
    21b4:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN6SpiDrv11spiTransferEc>

}
    21b8:	0f 90       	pop	r0
    21ba:	0f 90       	pop	r0
    21bc:	df 91       	pop	r29
    21be:	cf 91       	pop	r28
    21c0:	08 95       	ret

000021c2 <_ZN7WiFiDrv14getNetworkDataEPhS0_S0_>:


// Private Methods

void WiFiDrv::getNetworkData(uint8_t *ip, uint8_t *mask, uint8_t *gwip)
{
    21c2:	cf 93       	push	r28
    21c4:	df 93       	push	r29
    21c6:	cd b7       	in	r28, 0x3d	; 61
    21c8:	de b7       	in	r29, 0x3e	; 62
    21ca:	60 97       	sbiw	r28, 0x10	; 16
    21cc:	0f b6       	in	r0, 0x3f	; 63
    21ce:	f8 94       	cli
    21d0:	de bf       	out	0x3e, r29	; 62
    21d2:	0f be       	out	0x3f, r0	; 63
    21d4:	cd bf       	out	0x3d, r28	; 61
    21d6:	9c 87       	std	Y+12, r25	; 0x0c
    21d8:	8b 87       	std	Y+11, r24	; 0x0b
    21da:	7e 87       	std	Y+14, r23	; 0x0e
    21dc:	6d 87       	std	Y+13, r22	; 0x0d
    21de:	58 8b       	std	Y+16, r21	; 0x10
    21e0:	4f 87       	std	Y+15, r20	; 0x0f
    tParam params[PARAM_NUMS_3] = { {0, (char*)ip}, {0, (char*)mask}, {0, (char*)gwip}};
    21e2:	29 e0       	ldi	r18, 0x09	; 9
    21e4:	ce 01       	movw	r24, r28
    21e6:	01 96       	adiw	r24, 0x01	; 1
    21e8:	fc 01       	movw	r30, r24
    21ea:	32 2f       	mov	r19, r18
    21ec:	11 92       	st	Z+, r1
    21ee:	3a 95       	dec	r19
    21f0:	e9 f7       	brne	.-6      	; 0x21ec <_ZN7WiFiDrv14getNetworkDataEPhS0_S0_+0x2a>
    21f2:	8b 85       	ldd	r24, Y+11	; 0x0b
    21f4:	9c 85       	ldd	r25, Y+12	; 0x0c
    21f6:	9b 83       	std	Y+3, r25	; 0x03
    21f8:	8a 83       	std	Y+2, r24	; 0x02
    21fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    21fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    21fe:	9e 83       	std	Y+6, r25	; 0x06
    2200:	8d 83       	std	Y+5, r24	; 0x05
    2202:	8f 85       	ldd	r24, Y+15	; 0x0f
    2204:	98 89       	ldd	r25, Y+16	; 0x10
    2206:	99 87       	std	Y+9, r25	; 0x09
    2208:	88 87       	std	Y+8, r24	; 0x08

    WAIT_FOR_SLAVE_SELECT();
    220a:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    220e:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(GET_IPADDR_CMD, PARAM_NUMS_1);
    2212:	61 e0       	ldi	r22, 0x01	; 1
    2214:	81 e2       	ldi	r24, 0x21	; 33
    2216:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    uint8_t _dummy = DUMMY_DATA;
    221a:	8f ef       	ldi	r24, 0xFF	; 255
    221c:	8a 87       	std	Y+10, r24	; 0x0a
    SpiDrv::sendParam(&_dummy, sizeof(_dummy), LAST_PARAM);
    221e:	ce 01       	movw	r24, r28
    2220:	0a 96       	adiw	r24, 0x0a	; 10
    2222:	41 e0       	ldi	r20, 0x01	; 1
    2224:	61 e0       	ldi	r22, 0x01	; 1
    2226:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    222a:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    SpiDrv::waitResponseParams(GET_IPADDR_CMD, PARAM_NUMS_3, params);
    222e:	ce 01       	movw	r24, r28
    2230:	01 96       	adiw	r24, 0x01	; 1
    2232:	ac 01       	movw	r20, r24
    2234:	63 e0       	ldi	r22, 0x03	; 3
    2236:	81 e2       	ldi	r24, 0x21	; 33
    2238:	0e 94 f0 0d 	call	0x1be0	; 0x1be0 <_ZN6SpiDrv18waitResponseParamsEhhP6tParam>

    SpiDrv::spiSlaveDeselect();
    223c:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
}
    2240:	60 96       	adiw	r28, 0x10	; 16
    2242:	0f b6       	in	r0, 0x3f	; 63
    2244:	f8 94       	cli
    2246:	de bf       	out	0x3e, r29	; 62
    2248:	0f be       	out	0x3f, r0	; 63
    224a:	cd bf       	out	0x3d, r28	; 61
    224c:	df 91       	pop	r29
    224e:	cf 91       	pop	r28
    2250:	08 95       	ret

00002252 <_ZN7WiFiDrv14wifiDriverInitEv>:

// Public Methods


void WiFiDrv::wifiDriverInit()
{
    2252:	cf 93       	push	r28
    2254:	df 93       	push	r29
    2256:	cd b7       	in	r28, 0x3d	; 61
    2258:	de b7       	in	r29, 0x3e	; 62
    SpiDrv::begin();
    225a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_ZN6SpiDrv5beginEv>
}
    225e:	df 91       	pop	r29
    2260:	cf 91       	pop	r28
    2262:	08 95       	ret

00002264 <_ZN7WiFiDrv14wifiSetNetworkEPch>:

int8_t WiFiDrv::wifiSetNetwork(char* ssid, uint8_t ssid_len)
{
    2264:	cf 93       	push	r28
    2266:	df 93       	push	r29
    2268:	00 d0       	rcall	.+0      	; 0x226a <_ZN7WiFiDrv14wifiSetNetworkEPch+0x6>
    226a:	00 d0       	rcall	.+0      	; 0x226c <_ZN7WiFiDrv14wifiSetNetworkEPch+0x8>
    226c:	1f 92       	push	r1
    226e:	cd b7       	in	r28, 0x3d	; 61
    2270:	de b7       	in	r29, 0x3e	; 62
    2272:	9c 83       	std	Y+4, r25	; 0x04
    2274:	8b 83       	std	Y+3, r24	; 0x03
    2276:	6d 83       	std	Y+5, r22	; 0x05
	WAIT_FOR_SLAVE_SELECT();
    2278:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    227c:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(SET_NET_CMD, PARAM_NUMS_1);
    2280:	61 e0       	ldi	r22, 0x01	; 1
    2282:	80 e1       	ldi	r24, 0x10	; 16
    2284:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam((uint8_t*)ssid, ssid_len, LAST_PARAM);
    2288:	8b 81       	ldd	r24, Y+3	; 0x03
    228a:	9c 81       	ldd	r25, Y+4	; 0x04
    228c:	41 e0       	ldi	r20, 0x01	; 1
    228e:	6d 81       	ldd	r22, Y+5	; 0x05
    2290:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    2294:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    2298:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    229a:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseCmd(SET_NET_CMD, PARAM_NUMS_1, &_data, &_dataLen))
    229c:	ce 01       	movw	r24, r28
    229e:	02 96       	adiw	r24, 0x02	; 2
    22a0:	9c 01       	movw	r18, r24
    22a2:	ce 01       	movw	r24, r28
    22a4:	01 96       	adiw	r24, 0x01	; 1
    22a6:	ac 01       	movw	r20, r24
    22a8:	61 e0       	ldi	r22, 0x01	; 1
    22aa:	80 e1       	ldi	r24, 0x10	; 16
    22ac:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    22b0:	21 e0       	ldi	r18, 0x01	; 1
    22b2:	00 97       	sbiw	r24, 0x00	; 0
    22b4:	09 f0       	breq	.+2      	; 0x22b8 <_ZN7WiFiDrv14wifiSetNetworkEPch+0x54>
    22b6:	20 e0       	ldi	r18, 0x00	; 0
    22b8:	22 23       	and	r18, r18
    22ba:	11 f0       	breq	.+4      	; 0x22c0 <_ZN7WiFiDrv14wifiSetNetworkEPch+0x5c>
    {
        WARN("error waitResponse");
        _data = WL_FAILURE;
    22bc:	8f ef       	ldi	r24, 0xFF	; 255
    22be:	89 83       	std	Y+1, r24	; 0x01
    }
    SpiDrv::spiSlaveDeselect();
    22c0:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return(_data == WIFI_SPI_ACK) ? WL_SUCCESS : WL_FAILURE;
    22c4:	89 81       	ldd	r24, Y+1	; 0x01
    22c6:	81 30       	cpi	r24, 0x01	; 1
    22c8:	11 f4       	brne	.+4      	; 0x22ce <_ZN7WiFiDrv14wifiSetNetworkEPch+0x6a>
    22ca:	81 e0       	ldi	r24, 0x01	; 1
    22cc:	01 c0       	rjmp	.+2      	; 0x22d0 <_ZN7WiFiDrv14wifiSetNetworkEPch+0x6c>
    22ce:	8f ef       	ldi	r24, 0xFF	; 255
}
    22d0:	0f 90       	pop	r0
    22d2:	0f 90       	pop	r0
    22d4:	0f 90       	pop	r0
    22d6:	0f 90       	pop	r0
    22d8:	0f 90       	pop	r0
    22da:	df 91       	pop	r29
    22dc:	cf 91       	pop	r28
    22de:	08 95       	ret

000022e0 <_ZN7WiFiDrv17wifiSetPassphraseEPchPKch>:

int8_t WiFiDrv::wifiSetPassphrase(char* ssid, uint8_t ssid_len, const char *passphrase, const uint8_t len)
{
    22e0:	cf 93       	push	r28
    22e2:	df 93       	push	r29
    22e4:	cd b7       	in	r28, 0x3d	; 61
    22e6:	de b7       	in	r29, 0x3e	; 62
    22e8:	28 97       	sbiw	r28, 0x08	; 8
    22ea:	0f b6       	in	r0, 0x3f	; 63
    22ec:	f8 94       	cli
    22ee:	de bf       	out	0x3e, r29	; 62
    22f0:	0f be       	out	0x3f, r0	; 63
    22f2:	cd bf       	out	0x3d, r28	; 61
    22f4:	9c 83       	std	Y+4, r25	; 0x04
    22f6:	8b 83       	std	Y+3, r24	; 0x03
    22f8:	6d 83       	std	Y+5, r22	; 0x05
    22fa:	5f 83       	std	Y+7, r21	; 0x07
    22fc:	4e 83       	std	Y+6, r20	; 0x06
    22fe:	28 87       	std	Y+8, r18	; 0x08
	WAIT_FOR_SLAVE_SELECT();
    2300:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    2304:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(SET_PASSPHRASE_CMD, PARAM_NUMS_2);
    2308:	62 e0       	ldi	r22, 0x02	; 2
    230a:	81 e1       	ldi	r24, 0x11	; 17
    230c:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam((uint8_t*)ssid, ssid_len, NO_LAST_PARAM);
    2310:	8b 81       	ldd	r24, Y+3	; 0x03
    2312:	9c 81       	ldd	r25, Y+4	; 0x04
    2314:	40 e0       	ldi	r20, 0x00	; 0
    2316:	6d 81       	ldd	r22, Y+5	; 0x05
    2318:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>
    SpiDrv::sendParam((uint8_t*)passphrase, len, LAST_PARAM);
    231c:	8e 81       	ldd	r24, Y+6	; 0x06
    231e:	9f 81       	ldd	r25, Y+7	; 0x07
    2320:	41 e0       	ldi	r20, 0x01	; 1
    2322:	68 85       	ldd	r22, Y+8	; 0x08
    2324:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    2328:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    232c:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    232e:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseCmd(SET_PASSPHRASE_CMD, PARAM_NUMS_1, &_data, &_dataLen))
    2330:	ce 01       	movw	r24, r28
    2332:	02 96       	adiw	r24, 0x02	; 2
    2334:	9c 01       	movw	r18, r24
    2336:	ce 01       	movw	r24, r28
    2338:	01 96       	adiw	r24, 0x01	; 1
    233a:	ac 01       	movw	r20, r24
    233c:	61 e0       	ldi	r22, 0x01	; 1
    233e:	81 e1       	ldi	r24, 0x11	; 17
    2340:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    2344:	21 e0       	ldi	r18, 0x01	; 1
    2346:	00 97       	sbiw	r24, 0x00	; 0
    2348:	09 f0       	breq	.+2      	; 0x234c <_ZN7WiFiDrv17wifiSetPassphraseEPchPKch+0x6c>
    234a:	20 e0       	ldi	r18, 0x00	; 0
    234c:	22 23       	and	r18, r18
    234e:	11 f0       	breq	.+4      	; 0x2354 <_ZN7WiFiDrv17wifiSetPassphraseEPchPKch+0x74>
    {
        WARN("error waitResponse");
        _data = WL_FAILURE;
    2350:	8f ef       	ldi	r24, 0xFF	; 255
    2352:	89 83       	std	Y+1, r24	; 0x01
    }
    SpiDrv::spiSlaveDeselect();
    2354:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
    return _data;
    2358:	89 81       	ldd	r24, Y+1	; 0x01
}
    235a:	28 96       	adiw	r28, 0x08	; 8
    235c:	0f b6       	in	r0, 0x3f	; 63
    235e:	f8 94       	cli
    2360:	de bf       	out	0x3e, r29	; 62
    2362:	0f be       	out	0x3f, r0	; 63
    2364:	cd bf       	out	0x3d, r28	; 61
    2366:	df 91       	pop	r29
    2368:	cf 91       	pop	r28
    236a:	08 95       	ret

0000236c <_ZN7WiFiDrv10wifiSetKeyEPchhPKvh>:


int8_t WiFiDrv::wifiSetKey(char* ssid, uint8_t ssid_len, uint8_t key_idx, const void *key, const uint8_t len)
{
    236c:	0f 93       	push	r16
    236e:	cf 93       	push	r28
    2370:	df 93       	push	r29
    2372:	cd b7       	in	r28, 0x3d	; 61
    2374:	de b7       	in	r29, 0x3e	; 62
    2376:	29 97       	sbiw	r28, 0x09	; 9
    2378:	0f b6       	in	r0, 0x3f	; 63
    237a:	f8 94       	cli
    237c:	de bf       	out	0x3e, r29	; 62
    237e:	0f be       	out	0x3f, r0	; 63
    2380:	cd bf       	out	0x3d, r28	; 61
    2382:	9c 83       	std	Y+4, r25	; 0x04
    2384:	8b 83       	std	Y+3, r24	; 0x03
    2386:	6d 83       	std	Y+5, r22	; 0x05
    2388:	4e 83       	std	Y+6, r20	; 0x06
    238a:	38 87       	std	Y+8, r19	; 0x08
    238c:	2f 83       	std	Y+7, r18	; 0x07
    238e:	09 87       	std	Y+9, r16	; 0x09
	WAIT_FOR_SLAVE_SELECT();
    2390:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    2394:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(SET_KEY_CMD, PARAM_NUMS_3);
    2398:	63 e0       	ldi	r22, 0x03	; 3
    239a:	82 e1       	ldi	r24, 0x12	; 18
    239c:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam((uint8_t*)ssid, ssid_len, NO_LAST_PARAM);
    23a0:	8b 81       	ldd	r24, Y+3	; 0x03
    23a2:	9c 81       	ldd	r25, Y+4	; 0x04
    23a4:	40 e0       	ldi	r20, 0x00	; 0
    23a6:	6d 81       	ldd	r22, Y+5	; 0x05
    23a8:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>
    SpiDrv::sendParam(&key_idx, KEY_IDX_LEN, NO_LAST_PARAM);
    23ac:	ce 01       	movw	r24, r28
    23ae:	06 96       	adiw	r24, 0x06	; 6
    23b0:	40 e0       	ldi	r20, 0x00	; 0
    23b2:	61 e0       	ldi	r22, 0x01	; 1
    23b4:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>
    SpiDrv::sendParam((uint8_t*)key, len, LAST_PARAM);
    23b8:	8f 81       	ldd	r24, Y+7	; 0x07
    23ba:	98 85       	ldd	r25, Y+8	; 0x08
    23bc:	41 e0       	ldi	r20, 0x01	; 1
    23be:	69 85       	ldd	r22, Y+9	; 0x09
    23c0:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>
    
    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    23c4:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    23c8:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    23ca:	1a 82       	std	Y+2, r1	; 0x02
    if (!SpiDrv::waitResponseCmd(SET_KEY_CMD, PARAM_NUMS_1, &_data, &_dataLen))
    23cc:	ce 01       	movw	r24, r28
    23ce:	02 96       	adiw	r24, 0x02	; 2
    23d0:	9c 01       	movw	r18, r24
    23d2:	ce 01       	movw	r24, r28
    23d4:	01 96       	adiw	r24, 0x01	; 1
    23d6:	ac 01       	movw	r20, r24
    23d8:	61 e0       	ldi	r22, 0x01	; 1
    23da:	82 e1       	ldi	r24, 0x12	; 18
    23dc:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    23e0:	21 e0       	ldi	r18, 0x01	; 1
    23e2:	00 97       	sbiw	r24, 0x00	; 0
    23e4:	09 f0       	breq	.+2      	; 0x23e8 <_ZN7WiFiDrv10wifiSetKeyEPchhPKvh+0x7c>
    23e6:	20 e0       	ldi	r18, 0x00	; 0
    23e8:	22 23       	and	r18, r18
    23ea:	11 f0       	breq	.+4      	; 0x23f0 <_ZN7WiFiDrv10wifiSetKeyEPchhPKvh+0x84>
    {
        WARN("error waitResponse");
        _data = WL_FAILURE;
    23ec:	8f ef       	ldi	r24, 0xFF	; 255
    23ee:	89 83       	std	Y+1, r24	; 0x01
    }
    SpiDrv::spiSlaveDeselect();
    23f0:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
    return _data;
    23f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    23f6:	29 96       	adiw	r28, 0x09	; 9
    23f8:	0f b6       	in	r0, 0x3f	; 63
    23fa:	f8 94       	cli
    23fc:	de bf       	out	0x3e, r29	; 62
    23fe:	0f be       	out	0x3f, r0	; 63
    2400:	cd bf       	out	0x3d, r28	; 61
    2402:	df 91       	pop	r29
    2404:	cf 91       	pop	r28
    2406:	0f 91       	pop	r16
    2408:	08 95       	ret

0000240a <_ZN7WiFiDrv10disconnectEv>:
                        
int8_t WiFiDrv::disconnect()
{
    240a:	cf 93       	push	r28
    240c:	df 93       	push	r29
    240e:	00 d0       	rcall	.+0      	; 0x2410 <_ZN7WiFiDrv10disconnectEv+0x6>
    2410:	00 d0       	rcall	.+0      	; 0x2412 <_ZN7WiFiDrv10disconnectEv+0x8>
    2412:	cd b7       	in	r28, 0x3d	; 61
    2414:	de b7       	in	r29, 0x3e	; 62
	WAIT_FOR_SLAVE_SELECT();
    2416:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    241a:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(DISCONNECT_CMD, PARAM_NUMS_1);
    241e:	61 e0       	ldi	r22, 0x01	; 1
    2420:	80 e3       	ldi	r24, 0x30	; 48
    2422:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    uint8_t _dummy = DUMMY_DATA;
    2426:	8f ef       	ldi	r24, 0xFF	; 255
    2428:	8a 83       	std	Y+2, r24	; 0x02
    SpiDrv::sendParam(&_dummy, 1, LAST_PARAM);
    242a:	ce 01       	movw	r24, r28
    242c:	02 96       	adiw	r24, 0x02	; 2
    242e:	41 e0       	ldi	r20, 0x01	; 1
    2430:	61 e0       	ldi	r22, 0x01	; 1
    2432:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    2436:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    243a:	1b 82       	std	Y+3, r1	; 0x03
    uint8_t _dataLen = 0;
    243c:	1c 82       	std	Y+4, r1	; 0x04
    int8_t result = SpiDrv::waitResponseCmd(DISCONNECT_CMD, PARAM_NUMS_1, &_data, &_dataLen);
    243e:	9e 01       	movw	r18, r28
    2440:	2c 5f       	subi	r18, 0xFC	; 252
    2442:	3f 4f       	sbci	r19, 0xFF	; 255
    2444:	ce 01       	movw	r24, r28
    2446:	03 96       	adiw	r24, 0x03	; 3
    2448:	ac 01       	movw	r20, r24
    244a:	61 e0       	ldi	r22, 0x01	; 1
    244c:	80 e3       	ldi	r24, 0x30	; 48
    244e:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    2452:	89 83       	std	Y+1, r24	; 0x01

    SpiDrv::spiSlaveDeselect();
    2454:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return result;
    2458:	89 81       	ldd	r24, Y+1	; 0x01
}
    245a:	0f 90       	pop	r0
    245c:	0f 90       	pop	r0
    245e:	0f 90       	pop	r0
    2460:	0f 90       	pop	r0
    2462:	df 91       	pop	r29
    2464:	cf 91       	pop	r28
    2466:	08 95       	ret

00002468 <_ZN7WiFiDrv19getConnectionStatusEv>:

uint8_t WiFiDrv::getConnectionStatus()
{
    2468:	cf 93       	push	r28
    246a:	df 93       	push	r29
    246c:	00 d0       	rcall	.+0      	; 0x246e <_ZN7WiFiDrv19getConnectionStatusEv+0x6>
    246e:	cd b7       	in	r28, 0x3d	; 61
    2470:	de b7       	in	r29, 0x3e	; 62
	WAIT_FOR_SLAVE_SELECT();
    2472:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    2476:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(GET_CONN_STATUS_CMD, PARAM_NUMS_0);
    247a:	60 e0       	ldi	r22, 0x00	; 0
    247c:	80 e2       	ldi	r24, 0x20	; 32
    247e:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    2482:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = -1;
    2486:	8f ef       	ldi	r24, 0xFF	; 255
    2488:	89 83       	std	Y+1, r24	; 0x01
    uint8_t _dataLen = 0;
    248a:	1a 82       	std	Y+2, r1	; 0x02
    SpiDrv::waitResponseCmd(GET_CONN_STATUS_CMD, PARAM_NUMS_1, &_data, &_dataLen);
    248c:	ce 01       	movw	r24, r28
    248e:	02 96       	adiw	r24, 0x02	; 2
    2490:	9c 01       	movw	r18, r24
    2492:	ce 01       	movw	r24, r28
    2494:	01 96       	adiw	r24, 0x01	; 1
    2496:	ac 01       	movw	r20, r24
    2498:	61 e0       	ldi	r22, 0x01	; 1
    249a:	80 e2       	ldi	r24, 0x20	; 32
    249c:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>

    SpiDrv::spiSlaveDeselect();
    24a0:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return _data;
    24a4:	89 81       	ldd	r24, Y+1	; 0x01
}
    24a6:	0f 90       	pop	r0
    24a8:	0f 90       	pop	r0
    24aa:	df 91       	pop	r29
    24ac:	cf 91       	pop	r28
    24ae:	08 95       	ret

000024b0 <_ZN7WiFiDrv13getMacAddressEv>:

uint8_t* WiFiDrv::getMacAddress()
{
    24b0:	cf 93       	push	r28
    24b2:	df 93       	push	r29
    24b4:	00 d0       	rcall	.+0      	; 0x24b6 <_ZN7WiFiDrv13getMacAddressEv+0x6>
    24b6:	cd b7       	in	r28, 0x3d	; 61
    24b8:	de b7       	in	r29, 0x3e	; 62
	WAIT_FOR_SLAVE_SELECT();
    24ba:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    24be:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(GET_MACADDR_CMD, PARAM_NUMS_1);
    24c2:	61 e0       	ldi	r22, 0x01	; 1
    24c4:	82 e2       	ldi	r24, 0x22	; 34
    24c6:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    uint8_t _dummy = DUMMY_DATA;
    24ca:	8f ef       	ldi	r24, 0xFF	; 255
    24cc:	89 83       	std	Y+1, r24	; 0x01
    SpiDrv::sendParam(&_dummy, 1, LAST_PARAM);
    24ce:	41 e0       	ldi	r20, 0x01	; 1
    24d0:	61 e0       	ldi	r22, 0x01	; 1
    24d2:	ce 01       	movw	r24, r28
    24d4:	01 96       	adiw	r24, 0x01	; 1
    24d6:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    24da:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _dataLen = 0;
    24de:	1a 82       	std	Y+2, r1	; 0x02
    SpiDrv::waitResponseCmd(GET_MACADDR_CMD, PARAM_NUMS_1, _mac, &_dataLen);
    24e0:	ce 01       	movw	r24, r28
    24e2:	02 96       	adiw	r24, 0x02	; 2
    24e4:	9c 01       	movw	r18, r24
    24e6:	44 ee       	ldi	r20, 0xE4	; 228
    24e8:	56 e0       	ldi	r21, 0x06	; 6
    24ea:	61 e0       	ldi	r22, 0x01	; 1
    24ec:	82 e2       	ldi	r24, 0x22	; 34
    24ee:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>

    SpiDrv::spiSlaveDeselect();
    24f2:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return _mac;
    24f6:	84 ee       	ldi	r24, 0xE4	; 228
    24f8:	96 e0       	ldi	r25, 0x06	; 6
}
    24fa:	0f 90       	pop	r0
    24fc:	0f 90       	pop	r0
    24fe:	df 91       	pop	r29
    2500:	cf 91       	pop	r28
    2502:	08 95       	ret

00002504 <_ZN7WiFiDrv12getIpAddressER9IPAddress>:

void WiFiDrv::getIpAddress(IPAddress& ip)
{
    2504:	cf 93       	push	r28
    2506:	df 93       	push	r29
    2508:	00 d0       	rcall	.+0      	; 0x250a <_ZN7WiFiDrv12getIpAddressER9IPAddress+0x6>
    250a:	cd b7       	in	r28, 0x3d	; 61
    250c:	de b7       	in	r29, 0x3e	; 62
    250e:	9a 83       	std	Y+2, r25	; 0x02
    2510:	89 83       	std	Y+1, r24	; 0x01
	getNetworkData(_localIp, _subnetMask, _gatewayIp);
    2512:	42 ef       	ldi	r20, 0xF2	; 242
    2514:	56 e0       	ldi	r21, 0x06	; 6
    2516:	6e ee       	ldi	r22, 0xEE	; 238
    2518:	76 e0       	ldi	r23, 0x06	; 6
    251a:	8a ee       	ldi	r24, 0xEA	; 234
    251c:	96 e0       	ldi	r25, 0x06	; 6
    251e:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN7WiFiDrv14getNetworkDataEPhS0_S0_>
	ip = _localIp;
    2522:	89 81       	ldd	r24, Y+1	; 0x01
    2524:	9a 81       	ldd	r25, Y+2	; 0x02
    2526:	6a ee       	ldi	r22, 0xEA	; 234
    2528:	76 e0       	ldi	r23, 0x06	; 6
    252a:	0e 94 35 5a 	call	0xb46a	; 0xb46a <_ZN9IPAddressaSEPKh>
}
    252e:	0f 90       	pop	r0
    2530:	0f 90       	pop	r0
    2532:	df 91       	pop	r29
    2534:	cf 91       	pop	r28
    2536:	08 95       	ret

00002538 <_ZN7WiFiDrv13getSubnetMaskER9IPAddress>:

 void WiFiDrv::getSubnetMask(IPAddress& mask)
 {
    2538:	cf 93       	push	r28
    253a:	df 93       	push	r29
    253c:	00 d0       	rcall	.+0      	; 0x253e <_ZN7WiFiDrv13getSubnetMaskER9IPAddress+0x6>
    253e:	cd b7       	in	r28, 0x3d	; 61
    2540:	de b7       	in	r29, 0x3e	; 62
    2542:	9a 83       	std	Y+2, r25	; 0x02
    2544:	89 83       	std	Y+1, r24	; 0x01
	getNetworkData(_localIp, _subnetMask, _gatewayIp);
    2546:	42 ef       	ldi	r20, 0xF2	; 242
    2548:	56 e0       	ldi	r21, 0x06	; 6
    254a:	6e ee       	ldi	r22, 0xEE	; 238
    254c:	76 e0       	ldi	r23, 0x06	; 6
    254e:	8a ee       	ldi	r24, 0xEA	; 234
    2550:	96 e0       	ldi	r25, 0x06	; 6
    2552:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN7WiFiDrv14getNetworkDataEPhS0_S0_>
	mask = _subnetMask;
    2556:	89 81       	ldd	r24, Y+1	; 0x01
    2558:	9a 81       	ldd	r25, Y+2	; 0x02
    255a:	6e ee       	ldi	r22, 0xEE	; 238
    255c:	76 e0       	ldi	r23, 0x06	; 6
    255e:	0e 94 35 5a 	call	0xb46a	; 0xb46a <_ZN9IPAddressaSEPKh>
 }
    2562:	0f 90       	pop	r0
    2564:	0f 90       	pop	r0
    2566:	df 91       	pop	r29
    2568:	cf 91       	pop	r28
    256a:	08 95       	ret

0000256c <_ZN7WiFiDrv12getGatewayIPER9IPAddress>:

 void WiFiDrv::getGatewayIP(IPAddress& ip)
 {
    256c:	cf 93       	push	r28
    256e:	df 93       	push	r29
    2570:	00 d0       	rcall	.+0      	; 0x2572 <_ZN7WiFiDrv12getGatewayIPER9IPAddress+0x6>
    2572:	cd b7       	in	r28, 0x3d	; 61
    2574:	de b7       	in	r29, 0x3e	; 62
    2576:	9a 83       	std	Y+2, r25	; 0x02
    2578:	89 83       	std	Y+1, r24	; 0x01
	getNetworkData(_localIp, _subnetMask, _gatewayIp);
    257a:	42 ef       	ldi	r20, 0xF2	; 242
    257c:	56 e0       	ldi	r21, 0x06	; 6
    257e:	6e ee       	ldi	r22, 0xEE	; 238
    2580:	76 e0       	ldi	r23, 0x06	; 6
    2582:	8a ee       	ldi	r24, 0xEA	; 234
    2584:	96 e0       	ldi	r25, 0x06	; 6
    2586:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN7WiFiDrv14getNetworkDataEPhS0_S0_>
	ip = _gatewayIp;
    258a:	89 81       	ldd	r24, Y+1	; 0x01
    258c:	9a 81       	ldd	r25, Y+2	; 0x02
    258e:	62 ef       	ldi	r22, 0xF2	; 242
    2590:	76 e0       	ldi	r23, 0x06	; 6
    2592:	0e 94 35 5a 	call	0xb46a	; 0xb46a <_ZN9IPAddressaSEPKh>
 }
    2596:	0f 90       	pop	r0
    2598:	0f 90       	pop	r0
    259a:	df 91       	pop	r29
    259c:	cf 91       	pop	r28
    259e:	08 95       	ret

000025a0 <_ZN7WiFiDrv14getCurrentSSIDEv>:

char* WiFiDrv::getCurrentSSID()
{
    25a0:	cf 93       	push	r28
    25a2:	df 93       	push	r29
    25a4:	00 d0       	rcall	.+0      	; 0x25a6 <_ZN7WiFiDrv14getCurrentSSIDEv+0x6>
    25a6:	cd b7       	in	r28, 0x3d	; 61
    25a8:	de b7       	in	r29, 0x3e	; 62
	WAIT_FOR_SLAVE_SELECT();
    25aa:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    25ae:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(GET_CURR_SSID_CMD, PARAM_NUMS_1);
    25b2:	61 e0       	ldi	r22, 0x01	; 1
    25b4:	83 e2       	ldi	r24, 0x23	; 35
    25b6:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    uint8_t _dummy = DUMMY_DATA;
    25ba:	8f ef       	ldi	r24, 0xFF	; 255
    25bc:	89 83       	std	Y+1, r24	; 0x01
    SpiDrv::sendParam(&_dummy, 1, LAST_PARAM);
    25be:	41 e0       	ldi	r20, 0x01	; 1
    25c0:	61 e0       	ldi	r22, 0x01	; 1
    25c2:	ce 01       	movw	r24, r28
    25c4:	01 96       	adiw	r24, 0x01	; 1
    25c6:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    25ca:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _dataLen = 0;
    25ce:	1a 82       	std	Y+2, r1	; 0x02
    SpiDrv::waitResponseCmd(GET_CURR_SSID_CMD, PARAM_NUMS_1, (uint8_t*)_ssid, &_dataLen);
    25d0:	ce 01       	movw	r24, r28
    25d2:	02 96       	adiw	r24, 0x02	; 2
    25d4:	9c 01       	movw	r18, r24
    25d6:	4e eb       	ldi	r20, 0xBE	; 190
    25d8:	56 e0       	ldi	r21, 0x06	; 6
    25da:	61 e0       	ldi	r22, 0x01	; 1
    25dc:	83 e2       	ldi	r24, 0x23	; 35
    25de:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>

    SpiDrv::spiSlaveDeselect();
    25e2:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return _ssid;
    25e6:	8e eb       	ldi	r24, 0xBE	; 190
    25e8:	96 e0       	ldi	r25, 0x06	; 6
}
    25ea:	0f 90       	pop	r0
    25ec:	0f 90       	pop	r0
    25ee:	df 91       	pop	r29
    25f0:	cf 91       	pop	r28
    25f2:	08 95       	ret

000025f4 <_ZN7WiFiDrv15getCurrentBSSIDEv>:

uint8_t* WiFiDrv::getCurrentBSSID()
{
    25f4:	cf 93       	push	r28
    25f6:	df 93       	push	r29
    25f8:	00 d0       	rcall	.+0      	; 0x25fa <_ZN7WiFiDrv15getCurrentBSSIDEv+0x6>
    25fa:	cd b7       	in	r28, 0x3d	; 61
    25fc:	de b7       	in	r29, 0x3e	; 62
	WAIT_FOR_SLAVE_SELECT();
    25fe:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    2602:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(GET_CURR_BSSID_CMD, PARAM_NUMS_1);
    2606:	61 e0       	ldi	r22, 0x01	; 1
    2608:	84 e2       	ldi	r24, 0x24	; 36
    260a:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    uint8_t _dummy = DUMMY_DATA;
    260e:	8f ef       	ldi	r24, 0xFF	; 255
    2610:	89 83       	std	Y+1, r24	; 0x01
    SpiDrv::sendParam(&_dummy, 1, LAST_PARAM);
    2612:	41 e0       	ldi	r20, 0x01	; 1
    2614:	61 e0       	ldi	r22, 0x01	; 1
    2616:	ce 01       	movw	r24, r28
    2618:	01 96       	adiw	r24, 0x01	; 1
    261a:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    261e:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _dataLen = 0;
    2622:	1a 82       	std	Y+2, r1	; 0x02
    SpiDrv::waitResponseCmd(GET_CURR_BSSID_CMD, PARAM_NUMS_1, _bssid, &_dataLen);
    2624:	ce 01       	movw	r24, r28
    2626:	02 96       	adiw	r24, 0x02	; 2
    2628:	9c 01       	movw	r18, r24
    262a:	4e ed       	ldi	r20, 0xDE	; 222
    262c:	56 e0       	ldi	r21, 0x06	; 6
    262e:	61 e0       	ldi	r22, 0x01	; 1
    2630:	84 e2       	ldi	r24, 0x24	; 36
    2632:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>

    SpiDrv::spiSlaveDeselect();
    2636:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return _bssid;
    263a:	8e ed       	ldi	r24, 0xDE	; 222
    263c:	96 e0       	ldi	r25, 0x06	; 6
}
    263e:	0f 90       	pop	r0
    2640:	0f 90       	pop	r0
    2642:	df 91       	pop	r29
    2644:	cf 91       	pop	r28
    2646:	08 95       	ret

00002648 <_ZN7WiFiDrv14getCurrentRSSIEv>:

int32_t WiFiDrv::getCurrentRSSI()
{
    2648:	cf 93       	push	r28
    264a:	df 93       	push	r29
    264c:	00 d0       	rcall	.+0      	; 0x264e <_ZN7WiFiDrv14getCurrentRSSIEv+0x6>
    264e:	00 d0       	rcall	.+0      	; 0x2650 <_ZN7WiFiDrv14getCurrentRSSIEv+0x8>
    2650:	00 d0       	rcall	.+0      	; 0x2652 <_ZN7WiFiDrv14getCurrentRSSIEv+0xa>
    2652:	cd b7       	in	r28, 0x3d	; 61
    2654:	de b7       	in	r29, 0x3e	; 62
	WAIT_FOR_SLAVE_SELECT();
    2656:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    265a:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(GET_CURR_RSSI_CMD, PARAM_NUMS_1);
    265e:	61 e0       	ldi	r22, 0x01	; 1
    2660:	85 e2       	ldi	r24, 0x25	; 37
    2662:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    uint8_t _dummy = DUMMY_DATA;
    2666:	8f ef       	ldi	r24, 0xFF	; 255
    2668:	89 83       	std	Y+1, r24	; 0x01
    SpiDrv::sendParam(&_dummy, 1, LAST_PARAM);
    266a:	41 e0       	ldi	r20, 0x01	; 1
    266c:	61 e0       	ldi	r22, 0x01	; 1
    266e:	ce 01       	movw	r24, r28
    2670:	01 96       	adiw	r24, 0x01	; 1
    2672:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    2676:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _dataLen = 0;
    267a:	1a 82       	std	Y+2, r1	; 0x02
    int32_t rssi = 0;
    267c:	1b 82       	std	Y+3, r1	; 0x03
    267e:	1c 82       	std	Y+4, r1	; 0x04
    2680:	1d 82       	std	Y+5, r1	; 0x05
    2682:	1e 82       	std	Y+6, r1	; 0x06
    SpiDrv::waitResponseCmd(GET_CURR_RSSI_CMD, PARAM_NUMS_1, (uint8_t*)&rssi, &_dataLen);
    2684:	9e 01       	movw	r18, r28
    2686:	2e 5f       	subi	r18, 0xFE	; 254
    2688:	3f 4f       	sbci	r19, 0xFF	; 255
    268a:	ce 01       	movw	r24, r28
    268c:	03 96       	adiw	r24, 0x03	; 3
    268e:	ac 01       	movw	r20, r24
    2690:	61 e0       	ldi	r22, 0x01	; 1
    2692:	85 e2       	ldi	r24, 0x25	; 37
    2694:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>

    SpiDrv::spiSlaveDeselect();
    2698:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return rssi;
    269c:	8b 81       	ldd	r24, Y+3	; 0x03
    269e:	9c 81       	ldd	r25, Y+4	; 0x04
    26a0:	ad 81       	ldd	r26, Y+5	; 0x05
    26a2:	be 81       	ldd	r27, Y+6	; 0x06
}
    26a4:	bc 01       	movw	r22, r24
    26a6:	cd 01       	movw	r24, r26
    26a8:	26 96       	adiw	r28, 0x06	; 6
    26aa:	0f b6       	in	r0, 0x3f	; 63
    26ac:	f8 94       	cli
    26ae:	de bf       	out	0x3e, r29	; 62
    26b0:	0f be       	out	0x3f, r0	; 63
    26b2:	cd bf       	out	0x3d, r28	; 61
    26b4:	df 91       	pop	r29
    26b6:	cf 91       	pop	r28
    26b8:	08 95       	ret

000026ba <_ZN7WiFiDrv24getCurrentEncryptionTypeEv>:

uint8_t WiFiDrv::getCurrentEncryptionType()
{
    26ba:	cf 93       	push	r28
    26bc:	df 93       	push	r29
    26be:	00 d0       	rcall	.+0      	; 0x26c0 <_ZN7WiFiDrv24getCurrentEncryptionTypeEv+0x6>
    26c0:	1f 92       	push	r1
    26c2:	cd b7       	in	r28, 0x3d	; 61
    26c4:	de b7       	in	r29, 0x3e	; 62
	WAIT_FOR_SLAVE_SELECT();
    26c6:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    26ca:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(GET_CURR_ENCT_CMD, PARAM_NUMS_1);
    26ce:	61 e0       	ldi	r22, 0x01	; 1
    26d0:	86 e2       	ldi	r24, 0x26	; 38
    26d2:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    uint8_t _dummy = DUMMY_DATA;
    26d6:	8f ef       	ldi	r24, 0xFF	; 255
    26d8:	89 83       	std	Y+1, r24	; 0x01
    SpiDrv::sendParam(&_dummy, 1, LAST_PARAM);
    26da:	41 e0       	ldi	r20, 0x01	; 1
    26dc:	61 e0       	ldi	r22, 0x01	; 1
    26de:	ce 01       	movw	r24, r28
    26e0:	01 96       	adiw	r24, 0x01	; 1
    26e2:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    26e6:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t dataLen = 0;
    26ea:	1a 82       	std	Y+2, r1	; 0x02
    uint8_t encType = 0;
    26ec:	1b 82       	std	Y+3, r1	; 0x03
    SpiDrv::waitResponseCmd(GET_CURR_ENCT_CMD, PARAM_NUMS_1, (uint8_t*)&encType, &dataLen);
    26ee:	9e 01       	movw	r18, r28
    26f0:	2e 5f       	subi	r18, 0xFE	; 254
    26f2:	3f 4f       	sbci	r19, 0xFF	; 255
    26f4:	ce 01       	movw	r24, r28
    26f6:	03 96       	adiw	r24, 0x03	; 3
    26f8:	ac 01       	movw	r20, r24
    26fa:	61 e0       	ldi	r22, 0x01	; 1
    26fc:	86 e2       	ldi	r24, 0x26	; 38
    26fe:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>

    SpiDrv::spiSlaveDeselect();
    2702:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return encType;
    2706:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2708:	0f 90       	pop	r0
    270a:	0f 90       	pop	r0
    270c:	0f 90       	pop	r0
    270e:	df 91       	pop	r29
    2710:	cf 91       	pop	r28
    2712:	08 95       	ret

00002714 <_ZN7WiFiDrv17startScanNetworksEv>:

int8_t WiFiDrv::startScanNetworks()
{
    2714:	cf 93       	push	r28
    2716:	df 93       	push	r29
    2718:	00 d0       	rcall	.+0      	; 0x271a <_ZN7WiFiDrv17startScanNetworksEv+0x6>
    271a:	cd b7       	in	r28, 0x3d	; 61
    271c:	de b7       	in	r29, 0x3e	; 62
	WAIT_FOR_SLAVE_SELECT();
    271e:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    2722:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(START_SCAN_NETWORKS, PARAM_NUMS_0);
    2726:	60 e0       	ldi	r22, 0x00	; 0
    2728:	86 e3       	ldi	r24, 0x36	; 54
    272a:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    272e:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    2732:	19 82       	std	Y+1, r1	; 0x01
    uint8_t _dataLen = 0;
    2734:	1a 82       	std	Y+2, r1	; 0x02

    if (!SpiDrv::waitResponseCmd(START_SCAN_NETWORKS, PARAM_NUMS_1, &_data, &_dataLen))
    2736:	ce 01       	movw	r24, r28
    2738:	02 96       	adiw	r24, 0x02	; 2
    273a:	9c 01       	movw	r18, r24
    273c:	ce 01       	movw	r24, r28
    273e:	01 96       	adiw	r24, 0x01	; 1
    2740:	ac 01       	movw	r20, r24
    2742:	61 e0       	ldi	r22, 0x01	; 1
    2744:	86 e3       	ldi	r24, 0x36	; 54
    2746:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    274a:	21 e0       	ldi	r18, 0x01	; 1
    274c:	00 97       	sbiw	r24, 0x00	; 0
    274e:	09 f0       	breq	.+2      	; 0x2752 <_ZN7WiFiDrv17startScanNetworksEv+0x3e>
    2750:	20 e0       	ldi	r18, 0x00	; 0
    2752:	22 23       	and	r18, r18
    2754:	11 f0       	breq	.+4      	; 0x275a <_ZN7WiFiDrv17startScanNetworksEv+0x46>
     {
         WARN("error waitResponse");
         _data = WL_FAILURE;
    2756:	8f ef       	ldi	r24, 0xFF	; 255
    2758:	89 83       	std	Y+1, r24	; 0x01
     }

    SpiDrv::spiSlaveDeselect();
    275a:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return (_data == WL_FAILURE)? _data : WL_SUCCESS;
    275e:	81 e0       	ldi	r24, 0x01	; 1
}
    2760:	0f 90       	pop	r0
    2762:	0f 90       	pop	r0
    2764:	df 91       	pop	r29
    2766:	cf 91       	pop	r28
    2768:	08 95       	ret

0000276a <_ZN7WiFiDrv15getScanNetworksEv>:


uint8_t WiFiDrv::getScanNetworks()
{
    276a:	cf 93       	push	r28
    276c:	df 93       	push	r29
    276e:	1f 92       	push	r1
    2770:	cd b7       	in	r28, 0x3d	; 61
    2772:	de b7       	in	r29, 0x3e	; 62
	WAIT_FOR_SLAVE_SELECT();
    2774:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    2778:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(SCAN_NETWORKS, PARAM_NUMS_0);
    277c:	60 e0       	ldi	r22, 0x00	; 0
    277e:	87 e2       	ldi	r24, 0x27	; 39
    2780:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    2784:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t ssidListNum = 0;
    2788:	19 82       	std	Y+1, r1	; 0x01
    SpiDrv::waitResponse(SCAN_NETWORKS, &ssidListNum, (uint8_t**)_networkSsid, WL_NETWORKS_LIST_MAXNUM);
    278a:	2a e0       	ldi	r18, 0x0A	; 10
    278c:	40 e0       	ldi	r20, 0x00	; 0
    278e:	51 e0       	ldi	r21, 0x01	; 1
    2790:	ce 01       	movw	r24, r28
    2792:	01 96       	adiw	r24, 0x01	; 1
    2794:	bc 01       	movw	r22, r24
    2796:	87 e2       	ldi	r24, 0x27	; 39
    2798:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <_ZN6SpiDrv12waitResponseEhPhPS0_h>

    SpiDrv::spiSlaveDeselect();
    279c:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return ssidListNum;
    27a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    27a2:	0f 90       	pop	r0
    27a4:	df 91       	pop	r29
    27a6:	cf 91       	pop	r28
    27a8:	08 95       	ret

000027aa <_ZN7WiFiDrv16getSSIDNetoworksEh>:

char* WiFiDrv::getSSIDNetoworks(uint8_t networkItem)
{
    27aa:	cf 93       	push	r28
    27ac:	df 93       	push	r29
    27ae:	1f 92       	push	r1
    27b0:	cd b7       	in	r28, 0x3d	; 61
    27b2:	de b7       	in	r29, 0x3e	; 62
    27b4:	89 83       	std	Y+1, r24	; 0x01
	if (networkItem >= WL_NETWORKS_LIST_MAXNUM)
    27b6:	89 81       	ldd	r24, Y+1	; 0x01
    27b8:	8a 30       	cpi	r24, 0x0A	; 10
    27ba:	18 f0       	brcs	.+6      	; 0x27c2 <_ZN7WiFiDrv16getSSIDNetoworksEh+0x18>
		return NULL;
    27bc:	80 e0       	ldi	r24, 0x00	; 0
    27be:	90 e0       	ldi	r25, 0x00	; 0
    27c0:	0d c0       	rjmp	.+26     	; 0x27dc <_ZN7WiFiDrv16getSSIDNetoworksEh+0x32>

	return _networkSsid[networkItem];
    27c2:	89 81       	ldd	r24, Y+1	; 0x01
    27c4:	88 2f       	mov	r24, r24
    27c6:	90 e0       	ldi	r25, 0x00	; 0
    27c8:	88 0f       	add	r24, r24
    27ca:	99 1f       	adc	r25, r25
    27cc:	82 95       	swap	r24
    27ce:	92 95       	swap	r25
    27d0:	90 7f       	andi	r25, 0xF0	; 240
    27d2:	98 27       	eor	r25, r24
    27d4:	80 7f       	andi	r24, 0xF0	; 240
    27d6:	98 27       	eor	r25, r24
    27d8:	80 50       	subi	r24, 0x00	; 0
    27da:	9f 4f       	sbci	r25, 0xFF	; 255
}
    27dc:	0f 90       	pop	r0
    27de:	df 91       	pop	r29
    27e0:	cf 91       	pop	r28
    27e2:	08 95       	ret

000027e4 <_ZN7WiFiDrv18getEncTypeNetowrksEh>:

uint8_t WiFiDrv::getEncTypeNetowrks(uint8_t networkItem)
{
    27e4:	cf 93       	push	r28
    27e6:	df 93       	push	r29
    27e8:	00 d0       	rcall	.+0      	; 0x27ea <_ZN7WiFiDrv18getEncTypeNetowrksEh+0x6>
    27ea:	1f 92       	push	r1
    27ec:	cd b7       	in	r28, 0x3d	; 61
    27ee:	de b7       	in	r29, 0x3e	; 62
    27f0:	8b 83       	std	Y+3, r24	; 0x03
	if (networkItem >= WL_NETWORKS_LIST_MAXNUM)
    27f2:	8b 81       	ldd	r24, Y+3	; 0x03
    27f4:	8a 30       	cpi	r24, 0x0A	; 10
    27f6:	10 f0       	brcs	.+4      	; 0x27fc <_ZN7WiFiDrv18getEncTypeNetowrksEh+0x18>
		return (uint8_t) NULL;
    27f8:	80 e0       	ldi	r24, 0x00	; 0
    27fa:	1f c0       	rjmp	.+62     	; 0x283a <_ZN7WiFiDrv18getEncTypeNetowrksEh+0x56>

	WAIT_FOR_SLAVE_SELECT();
    27fc:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    2800:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(GET_IDX_ENCT_CMD, PARAM_NUMS_1);
    2804:	61 e0       	ldi	r22, 0x01	; 1
    2806:	83 e3       	ldi	r24, 0x33	; 51
    2808:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    SpiDrv::sendParam(&networkItem, 1, LAST_PARAM);
    280c:	ce 01       	movw	r24, r28
    280e:	03 96       	adiw	r24, 0x03	; 3
    2810:	41 e0       	ldi	r20, 0x01	; 1
    2812:	61 e0       	ldi	r22, 0x01	; 1
    2814:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    2818:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t dataLen = 0;
    281c:	19 82       	std	Y+1, r1	; 0x01
    uint8_t encType = 0;
    281e:	1a 82       	std	Y+2, r1	; 0x02
    SpiDrv::waitResponseCmd(GET_IDX_ENCT_CMD, PARAM_NUMS_1, (uint8_t*)&encType, &dataLen);
    2820:	ce 01       	movw	r24, r28
    2822:	02 96       	adiw	r24, 0x02	; 2
    2824:	9e 01       	movw	r18, r28
    2826:	2f 5f       	subi	r18, 0xFF	; 255
    2828:	3f 4f       	sbci	r19, 0xFF	; 255
    282a:	ac 01       	movw	r20, r24
    282c:	61 e0       	ldi	r22, 0x01	; 1
    282e:	83 e3       	ldi	r24, 0x33	; 51
    2830:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>

    SpiDrv::spiSlaveDeselect();
    2834:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return encType;
    2838:	8a 81       	ldd	r24, Y+2	; 0x02
}
    283a:	0f 90       	pop	r0
    283c:	0f 90       	pop	r0
    283e:	0f 90       	pop	r0
    2840:	df 91       	pop	r29
    2842:	cf 91       	pop	r28
    2844:	08 95       	ret

00002846 <_ZN7WiFiDrv16getRSSINetoworksEh>:

int32_t WiFiDrv::getRSSINetoworks(uint8_t networkItem)
{
    2846:	cf 93       	push	r28
    2848:	df 93       	push	r29
    284a:	00 d0       	rcall	.+0      	; 0x284c <_ZN7WiFiDrv16getRSSINetoworksEh+0x6>
    284c:	00 d0       	rcall	.+0      	; 0x284e <_ZN7WiFiDrv16getRSSINetoworksEh+0x8>
    284e:	00 d0       	rcall	.+0      	; 0x2850 <_ZN7WiFiDrv16getRSSINetoworksEh+0xa>
    2850:	cd b7       	in	r28, 0x3d	; 61
    2852:	de b7       	in	r29, 0x3e	; 62
    2854:	8e 83       	std	Y+6, r24	; 0x06
	if (networkItem >= WL_NETWORKS_LIST_MAXNUM)
    2856:	8e 81       	ldd	r24, Y+6	; 0x06
    2858:	8a 30       	cpi	r24, 0x0A	; 10
    285a:	20 f0       	brcs	.+8      	; 0x2864 <_ZN7WiFiDrv16getRSSINetoworksEh+0x1e>
		return (int32_t) NULL;
    285c:	80 e0       	ldi	r24, 0x00	; 0
    285e:	90 e0       	ldi	r25, 0x00	; 0
    2860:	dc 01       	movw	r26, r24
    2862:	25 c0       	rjmp	.+74     	; 0x28ae <_ZN7WiFiDrv16getRSSINetoworksEh+0x68>
	int32_t	networkRssi = 0;
    2864:	19 82       	std	Y+1, r1	; 0x01
    2866:	1a 82       	std	Y+2, r1	; 0x02
    2868:	1b 82       	std	Y+3, r1	; 0x03
    286a:	1c 82       	std	Y+4, r1	; 0x04

	WAIT_FOR_SLAVE_SELECT();
    286c:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    2870:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(GET_IDX_RSSI_CMD, PARAM_NUMS_1);
    2874:	61 e0       	ldi	r22, 0x01	; 1
    2876:	82 e3       	ldi	r24, 0x32	; 50
    2878:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    SpiDrv::sendParam(&networkItem, 1, LAST_PARAM);
    287c:	ce 01       	movw	r24, r28
    287e:	06 96       	adiw	r24, 0x06	; 6
    2880:	41 e0       	ldi	r20, 0x01	; 1
    2882:	61 e0       	ldi	r22, 0x01	; 1
    2884:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    2888:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t dataLen = 0;
    288c:	1d 82       	std	Y+5, r1	; 0x05
    SpiDrv::waitResponseCmd(GET_IDX_RSSI_CMD, PARAM_NUMS_1, (uint8_t*)&networkRssi, &dataLen);
    288e:	ce 01       	movw	r24, r28
    2890:	05 96       	adiw	r24, 0x05	; 5
    2892:	9c 01       	movw	r18, r24
    2894:	ce 01       	movw	r24, r28
    2896:	01 96       	adiw	r24, 0x01	; 1
    2898:	ac 01       	movw	r20, r24
    289a:	61 e0       	ldi	r22, 0x01	; 1
    289c:	82 e3       	ldi	r24, 0x32	; 50
    289e:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>

    SpiDrv::spiSlaveDeselect();
    28a2:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

	return networkRssi;
    28a6:	89 81       	ldd	r24, Y+1	; 0x01
    28a8:	9a 81       	ldd	r25, Y+2	; 0x02
    28aa:	ab 81       	ldd	r26, Y+3	; 0x03
    28ac:	bc 81       	ldd	r27, Y+4	; 0x04
}
    28ae:	bc 01       	movw	r22, r24
    28b0:	cd 01       	movw	r24, r26
    28b2:	26 96       	adiw	r28, 0x06	; 6
    28b4:	0f b6       	in	r0, 0x3f	; 63
    28b6:	f8 94       	cli
    28b8:	de bf       	out	0x3e, r29	; 62
    28ba:	0f be       	out	0x3f, r0	; 63
    28bc:	cd bf       	out	0x3d, r28	; 61
    28be:	df 91       	pop	r29
    28c0:	cf 91       	pop	r28
    28c2:	08 95       	ret

000028c4 <_ZN7WiFiDrv13reqHostByNameEPKc>:

uint8_t WiFiDrv::reqHostByName(const char* aHostname)
{
    28c4:	cf 93       	push	r28
    28c6:	df 93       	push	r29
    28c8:	00 d0       	rcall	.+0      	; 0x28ca <_ZN7WiFiDrv13reqHostByNameEPKc+0x6>
    28ca:	00 d0       	rcall	.+0      	; 0x28cc <_ZN7WiFiDrv13reqHostByNameEPKc+0x8>
    28cc:	1f 92       	push	r1
    28ce:	cd b7       	in	r28, 0x3d	; 61
    28d0:	de b7       	in	r29, 0x3e	; 62
    28d2:	9d 83       	std	Y+5, r25	; 0x05
    28d4:	8c 83       	std	Y+4, r24	; 0x04
	WAIT_FOR_SLAVE_SELECT();
    28d6:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    28da:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>

    // Send Command
    SpiDrv::sendCmd(REQ_HOST_BY_NAME_CMD, PARAM_NUMS_1);
    28de:	61 e0       	ldi	r22, 0x01	; 1
    28e0:	84 e3       	ldi	r24, 0x34	; 52
    28e2:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>
    SpiDrv::sendParam((uint8_t*)aHostname, strlen(aHostname), LAST_PARAM);
    28e6:	8c 81       	ldd	r24, Y+4	; 0x04
    28e8:	9d 81       	ldd	r25, Y+5	; 0x05
    28ea:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    28ee:	28 2f       	mov	r18, r24
    28f0:	8c 81       	ldd	r24, Y+4	; 0x04
    28f2:	9d 81       	ldd	r25, Y+5	; 0x05
    28f4:	41 e0       	ldi	r20, 0x01	; 1
    28f6:	62 2f       	mov	r22, r18
    28f8:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <_ZN6SpiDrv9sendParamEPhhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    28fc:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _data = 0;
    2900:	1a 82       	std	Y+2, r1	; 0x02
    uint8_t _dataLen = 0;
    2902:	1b 82       	std	Y+3, r1	; 0x03
    uint8_t result = SpiDrv::waitResponseCmd(REQ_HOST_BY_NAME_CMD, PARAM_NUMS_1, &_data, &_dataLen);
    2904:	9e 01       	movw	r18, r28
    2906:	2d 5f       	subi	r18, 0xFD	; 253
    2908:	3f 4f       	sbci	r19, 0xFF	; 255
    290a:	ce 01       	movw	r24, r28
    290c:	02 96       	adiw	r24, 0x02	; 2
    290e:	ac 01       	movw	r20, r24
    2910:	61 e0       	ldi	r22, 0x01	; 1
    2912:	84 e3       	ldi	r24, 0x34	; 52
    2914:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    2918:	89 83       	std	Y+1, r24	; 0x01

    SpiDrv::spiSlaveDeselect();
    291a:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>

    return result;
    291e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2920:	0f 90       	pop	r0
    2922:	0f 90       	pop	r0
    2924:	0f 90       	pop	r0
    2926:	0f 90       	pop	r0
    2928:	0f 90       	pop	r0
    292a:	df 91       	pop	r29
    292c:	cf 91       	pop	r28
    292e:	08 95       	ret

00002930 <_ZN7WiFiDrv13getHostByNameER9IPAddress>:

int WiFiDrv::getHostByName(IPAddress& aResult)
{
    2930:	cf 92       	push	r12
    2932:	df 92       	push	r13
    2934:	ef 92       	push	r14
    2936:	ff 92       	push	r15
    2938:	0f 93       	push	r16
    293a:	cf 93       	push	r28
    293c:	df 93       	push	r29
    293e:	cd b7       	in	r28, 0x3d	; 61
    2940:	de b7       	in	r29, 0x3e	; 62
    2942:	2f 97       	sbiw	r28, 0x0f	; 15
    2944:	0f b6       	in	r0, 0x3f	; 63
    2946:	f8 94       	cli
    2948:	de bf       	out	0x3e, r29	; 62
    294a:	0f be       	out	0x3f, r0	; 63
    294c:	cd bf       	out	0x3d, r28	; 61
    294e:	9f 87       	std	Y+15, r25	; 0x0f
    2950:	8e 87       	std	Y+14, r24	; 0x0e
	uint8_t  _ipAddr[WL_IPV4_LENGTH];
	IPAddress dummy(0xFF,0xFF,0xFF,0xFF);
    2952:	ce 01       	movw	r24, r28
    2954:	07 96       	adiw	r24, 0x07	; 7
    2956:	0f ef       	ldi	r16, 0xFF	; 255
    2958:	2f ef       	ldi	r18, 0xFF	; 255
    295a:	4f ef       	ldi	r20, 0xFF	; 255
    295c:	6f ef       	ldi	r22, 0xFF	; 255
    295e:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
	int result = 0;
    2962:	1a 82       	std	Y+2, r1	; 0x02
    2964:	19 82       	std	Y+1, r1	; 0x01

	WAIT_FOR_SLAVE_SELECT();
    2966:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    296a:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(GET_HOST_BY_NAME_CMD, PARAM_NUMS_0);
    296e:	60 e0       	ldi	r22, 0x00	; 0
    2970:	85 e3       	ldi	r24, 0x35	; 53
    2972:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    2976:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _dataLen = 0;
    297a:	1d 86       	std	Y+13, r1	; 0x0d
    if (!SpiDrv::waitResponseCmd(GET_HOST_BY_NAME_CMD, PARAM_NUMS_1, _ipAddr, &_dataLen))
    297c:	9e 01       	movw	r18, r28
    297e:	23 5f       	subi	r18, 0xF3	; 243
    2980:	3f 4f       	sbci	r19, 0xFF	; 255
    2982:	ce 01       	movw	r24, r28
    2984:	03 96       	adiw	r24, 0x03	; 3
    2986:	ac 01       	movw	r20, r24
    2988:	61 e0       	ldi	r22, 0x01	; 1
    298a:	85 e3       	ldi	r24, 0x35	; 53
    298c:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    2990:	21 e0       	ldi	r18, 0x01	; 1
    2992:	00 97       	sbiw	r24, 0x00	; 0
    2994:	09 f0       	breq	.+2      	; 0x2998 <_ZN7WiFiDrv13getHostByNameER9IPAddress+0x68>
    2996:	20 e0       	ldi	r18, 0x00	; 0
    2998:	22 23       	and	r18, r18
    299a:	f9 f4       	brne	.+62     	; 0x29da <_ZN7WiFiDrv13getHostByNameER9IPAddress+0xaa>
    {
        WARN("error waitResponse");
    }else{
    	aResult = _ipAddr;
    299c:	9e 01       	movw	r18, r28
    299e:	2d 5f       	subi	r18, 0xFD	; 253
    29a0:	3f 4f       	sbci	r19, 0xFF	; 255
    29a2:	8e 85       	ldd	r24, Y+14	; 0x0e
    29a4:	9f 85       	ldd	r25, Y+15	; 0x0f
    29a6:	b9 01       	movw	r22, r18
    29a8:	0e 94 35 5a 	call	0xb46a	; 0xb46a <_ZN9IPAddressaSEPKh>
    	result = (aResult != dummy);
    29ac:	8e 85       	ldd	r24, Y+14	; 0x0e
    29ae:	9f 85       	ldd	r25, Y+15	; 0x0f
    29b0:	0e 94 bb a5 	call	0x14b76	; 0x14b76 <_ZN9IPAddresscvmEv>
    29b4:	6b 01       	movw	r12, r22
    29b6:	7c 01       	movw	r14, r24
    29b8:	ce 01       	movw	r24, r28
    29ba:	07 96       	adiw	r24, 0x07	; 7
    29bc:	0e 94 bb a5 	call	0x14b76	; 0x14b76 <_ZN9IPAddresscvmEv>
    29c0:	dc 01       	movw	r26, r24
    29c2:	cb 01       	movw	r24, r22
    29c4:	21 e0       	ldi	r18, 0x01	; 1
    29c6:	c8 16       	cp	r12, r24
    29c8:	d9 06       	cpc	r13, r25
    29ca:	ea 06       	cpc	r14, r26
    29cc:	fb 06       	cpc	r15, r27
    29ce:	09 f4       	brne	.+2      	; 0x29d2 <_ZN7WiFiDrv13getHostByNameER9IPAddress+0xa2>
    29d0:	20 e0       	ldi	r18, 0x00	; 0
    29d2:	82 2f       	mov	r24, r18
    29d4:	90 e0       	ldi	r25, 0x00	; 0
    29d6:	9a 83       	std	Y+2, r25	; 0x02
    29d8:	89 83       	std	Y+1, r24	; 0x01
    }
    SpiDrv::spiSlaveDeselect();
    29da:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
    return result;
    29de:	89 81       	ldd	r24, Y+1	; 0x01
    29e0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    29e2:	2f 96       	adiw	r28, 0x0f	; 15
    29e4:	0f b6       	in	r0, 0x3f	; 63
    29e6:	f8 94       	cli
    29e8:	de bf       	out	0x3e, r29	; 62
    29ea:	0f be       	out	0x3f, r0	; 63
    29ec:	cd bf       	out	0x3d, r28	; 61
    29ee:	df 91       	pop	r29
    29f0:	cf 91       	pop	r28
    29f2:	0f 91       	pop	r16
    29f4:	ff 90       	pop	r15
    29f6:	ef 90       	pop	r14
    29f8:	df 90       	pop	r13
    29fa:	cf 90       	pop	r12
    29fc:	08 95       	ret

000029fe <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress>:

int WiFiDrv::getHostByName(const char* aHostname, IPAddress& aResult)
{
    29fe:	cf 93       	push	r28
    2a00:	df 93       	push	r29
    2a02:	00 d0       	rcall	.+0      	; 0x2a04 <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x6>
    2a04:	00 d0       	rcall	.+0      	; 0x2a06 <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x8>
    2a06:	1f 92       	push	r1
    2a08:	cd b7       	in	r28, 0x3d	; 61
    2a0a:	de b7       	in	r29, 0x3e	; 62
    2a0c:	9b 83       	std	Y+3, r25	; 0x03
    2a0e:	8a 83       	std	Y+2, r24	; 0x02
    2a10:	7d 83       	std	Y+5, r23	; 0x05
    2a12:	6c 83       	std	Y+4, r22	; 0x04
	uint8_t retry = 10;
    2a14:	8a e0       	ldi	r24, 0x0A	; 10
    2a16:	89 83       	std	Y+1, r24	; 0x01
	if (reqHostByName(aHostname))
    2a18:	8a 81       	ldd	r24, Y+2	; 0x02
    2a1a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a1c:	0e 94 62 14 	call	0x28c4	; 0x28c4 <_ZN7WiFiDrv13reqHostByNameEPKc>
    2a20:	98 2f       	mov	r25, r24
    2a22:	81 e0       	ldi	r24, 0x01	; 1
    2a24:	99 23       	and	r25, r25
    2a26:	09 f4       	brne	.+2      	; 0x2a2a <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x2c>
    2a28:	80 e0       	ldi	r24, 0x00	; 0
    2a2a:	88 23       	and	r24, r24
    2a2c:	c9 f0       	breq	.+50     	; 0x2a60 <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x62>
	{
		while(!getHostByName(aResult) && --retry > 0)
    2a2e:	06 c0       	rjmp	.+12     	; 0x2a3c <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x3e>
		{
			delay(1000);
    2a30:	68 ee       	ldi	r22, 0xE8	; 232
    2a32:	73 e0       	ldi	r23, 0x03	; 3
    2a34:	80 e0       	ldi	r24, 0x00	; 0
    2a36:	90 e0       	ldi	r25, 0x00	; 0
    2a38:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
int WiFiDrv::getHostByName(const char* aHostname, IPAddress& aResult)
{
	uint8_t retry = 10;
	if (reqHostByName(aHostname))
	{
		while(!getHostByName(aResult) && --retry > 0)
    2a3c:	8c 81       	ldd	r24, Y+4	; 0x04
    2a3e:	9d 81       	ldd	r25, Y+5	; 0x05
    2a40:	0e 94 98 14 	call	0x2930	; 0x2930 <_ZN7WiFiDrv13getHostByNameER9IPAddress>
    2a44:	00 97       	sbiw	r24, 0x00	; 0
    2a46:	41 f4       	brne	.+16     	; 0x2a58 <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x5a>
    2a48:	89 81       	ldd	r24, Y+1	; 0x01
    2a4a:	81 50       	subi	r24, 0x01	; 1
    2a4c:	89 83       	std	Y+1, r24	; 0x01
    2a4e:	89 81       	ldd	r24, Y+1	; 0x01
    2a50:	88 23       	and	r24, r24
    2a52:	11 f0       	breq	.+4      	; 0x2a58 <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x5a>
    2a54:	81 e0       	ldi	r24, 0x01	; 1
    2a56:	01 c0       	rjmp	.+2      	; 0x2a5a <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x5c>
    2a58:	80 e0       	ldi	r24, 0x00	; 0
    2a5a:	88 23       	and	r24, r24
    2a5c:	49 f7       	brne	.-46     	; 0x2a30 <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x32>
    2a5e:	03 c0       	rjmp	.+6      	; 0x2a66 <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x68>
		{
			delay(1000);
		}
	}else{
		return 0;
    2a60:	80 e0       	ldi	r24, 0x00	; 0
    2a62:	90 e0       	ldi	r25, 0x00	; 0
    2a64:	07 c0       	rjmp	.+14     	; 0x2a74 <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x76>
	}
	return (retry>0);
    2a66:	81 e0       	ldi	r24, 0x01	; 1
    2a68:	99 81       	ldd	r25, Y+1	; 0x01
    2a6a:	99 23       	and	r25, r25
    2a6c:	09 f4       	brne	.+2      	; 0x2a70 <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress+0x72>
    2a6e:	80 e0       	ldi	r24, 0x00	; 0
    2a70:	88 2f       	mov	r24, r24
    2a72:	90 e0       	ldi	r25, 0x00	; 0
}
    2a74:	0f 90       	pop	r0
    2a76:	0f 90       	pop	r0
    2a78:	0f 90       	pop	r0
    2a7a:	0f 90       	pop	r0
    2a7c:	0f 90       	pop	r0
    2a7e:	df 91       	pop	r29
    2a80:	cf 91       	pop	r28
    2a82:	08 95       	ret

00002a84 <_ZN7WiFiDrv12getFwVersionEv>:

char*  WiFiDrv::getFwVersion()
{
    2a84:	cf 93       	push	r28
    2a86:	df 93       	push	r29
    2a88:	1f 92       	push	r1
    2a8a:	cd b7       	in	r28, 0x3d	; 61
    2a8c:	de b7       	in	r29, 0x3e	; 62
	WAIT_FOR_SLAVE_SELECT();
    2a8e:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>
    2a92:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <_ZN6SpiDrv14spiSlaveSelectEv>
    // Send Command
    SpiDrv::sendCmd(GET_FW_VERSION_CMD, PARAM_NUMS_0);
    2a96:	60 e0       	ldi	r22, 0x00	; 0
    2a98:	87 e3       	ldi	r24, 0x37	; 55
    2a9a:	0e 94 c1 10 	call	0x2182	; 0x2182 <_ZN6SpiDrv7sendCmdEhh>

    //Wait the reply elaboration
    SpiDrv::waitForSlaveReady();
    2a9e:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <_ZN6SpiDrv17waitForSlaveReadyEv>

    // Wait for reply
    uint8_t _dataLen = 0;
    2aa2:	19 82       	std	Y+1, r1	; 0x01
    if (!SpiDrv::waitResponseCmd(GET_FW_VERSION_CMD, PARAM_NUMS_1, (uint8_t*)fwVersion, &_dataLen))
    2aa4:	ce 01       	movw	r24, r28
    2aa6:	01 96       	adiw	r24, 0x01	; 1
    2aa8:	9c 01       	movw	r18, r24
    2aaa:	46 ef       	ldi	r20, 0xF6	; 246
    2aac:	56 e0       	ldi	r21, 0x06	; 6
    2aae:	61 e0       	ldi	r22, 0x01	; 1
    2ab0:	87 e3       	ldi	r24, 0x37	; 55
    2ab2:	0e 94 99 0c 	call	0x1932	; 0x1932 <_ZN6SpiDrv15waitResponseCmdEhhPhS0_>
    {
        WARN("error waitResponse");
    }
    SpiDrv::spiSlaveDeselect();
    2ab6:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <_ZN6SpiDrv16spiSlaveDeselectEv>
    return fwVersion;
    2aba:	86 ef       	ldi	r24, 0xF6	; 246
    2abc:	96 e0       	ldi	r25, 0x06	; 6
}
    2abe:	0f 90       	pop	r0
    2ac0:	df 91       	pop	r29
    2ac2:	cf 91       	pop	r28
    2ac4:	08 95       	ret

00002ac6 <_Z41__static_initialization_and_destruction_0ii>:

WiFiDrv wiFiDrv;
    2ac6:	0f 93       	push	r16
    2ac8:	cf 93       	push	r28
    2aca:	df 93       	push	r29
    2acc:	00 d0       	rcall	.+0      	; 0x2ace <_Z41__static_initialization_and_destruction_0ii+0x8>
    2ace:	00 d0       	rcall	.+0      	; 0x2ad0 <_Z41__static_initialization_and_destruction_0ii+0xa>
    2ad0:	cd b7       	in	r28, 0x3d	; 61
    2ad2:	de b7       	in	r29, 0x3e	; 62
    2ad4:	9a 83       	std	Y+2, r25	; 0x02
    2ad6:	89 83       	std	Y+1, r24	; 0x01
    2ad8:	7c 83       	std	Y+4, r23	; 0x04
    2ada:	6b 83       	std	Y+3, r22	; 0x03
    2adc:	89 81       	ldd	r24, Y+1	; 0x01
    2ade:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae0:	81 30       	cpi	r24, 0x01	; 1
    2ae2:	91 05       	cpc	r25, r1
    2ae4:	71 f4       	brne	.+28     	; 0x2b02 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    2ae6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aea:	8f 3f       	cpi	r24, 0xFF	; 255
    2aec:	2f ef       	ldi	r18, 0xFF	; 255
    2aee:	92 07       	cpc	r25, r18
    2af0:	41 f4       	brne	.+16     	; 0x2b02 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    friend class Server;
    friend class DhcpClass;
    friend class DNSClient;
};

const IPAddress INADDR_NONE(0,0,0,0);
    2af2:	00 e0       	ldi	r16, 0x00	; 0
    2af4:	20 e0       	ldi	r18, 0x00	; 0
    2af6:	40 e0       	ldi	r20, 0x00	; 0
    2af8:	60 e0       	ldi	r22, 0x00	; 0
    2afa:	8d ef       	ldi	r24, 0xFD	; 253
    2afc:	96 e0       	ldi	r25, 0x06	; 6
    2afe:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    2b02:	0f 90       	pop	r0
    2b04:	0f 90       	pop	r0
    2b06:	0f 90       	pop	r0
    2b08:	0f 90       	pop	r0
    2b0a:	df 91       	pop	r29
    2b0c:	cf 91       	pop	r28
    2b0e:	0f 91       	pop	r16
    2b10:	08 95       	ret

00002b12 <_GLOBAL__sub_I__ZN7WiFiDrv12_networkSsidE>:
    2b12:	cf 93       	push	r28
    2b14:	df 93       	push	r29
    2b16:	cd b7       	in	r28, 0x3d	; 61
    2b18:	de b7       	in	r29, 0x3e	; 62
    2b1a:	6f ef       	ldi	r22, 0xFF	; 255
    2b1c:	7f ef       	ldi	r23, 0xFF	; 255
    2b1e:	81 e0       	ldi	r24, 0x01	; 1
    2b20:	90 e0       	ldi	r25, 0x00	; 0
    2b22:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <_Z41__static_initialization_and_destruction_0ii>
    2b26:	df 91       	pop	r29
    2b28:	cf 91       	pop	r28
    2b2a:	08 95       	ret

00002b2c <_ZN9WiFiClassC1Ev>:

// XXX: don't make assumptions about the value of MAX_SOCK_NUM.
int16_t 	WiFiClass::_state[MAX_SOCK_NUM] = { 0, 0, 0, 0 };
uint16_t 	WiFiClass::_server_port[MAX_SOCK_NUM] = { 0, 0, 0, 0 };

WiFiClass::WiFiClass()
    2b2c:	cf 93       	push	r28
    2b2e:	df 93       	push	r29
    2b30:	00 d0       	rcall	.+0      	; 0x2b32 <_ZN9WiFiClassC1Ev+0x6>
    2b32:	cd b7       	in	r28, 0x3d	; 61
    2b34:	de b7       	in	r29, 0x3e	; 62
    2b36:	9a 83       	std	Y+2, r25	; 0x02
    2b38:	89 83       	std	Y+1, r24	; 0x01
{
	// Driver initialization
	init();
    2b3a:	0e 94 a4 15 	call	0x2b48	; 0x2b48 <_ZN9WiFiClass4initEv>
}
    2b3e:	0f 90       	pop	r0
    2b40:	0f 90       	pop	r0
    2b42:	df 91       	pop	r29
    2b44:	cf 91       	pop	r28
    2b46:	08 95       	ret

00002b48 <_ZN9WiFiClass4initEv>:

void WiFiClass::init()
{
    2b48:	cf 93       	push	r28
    2b4a:	df 93       	push	r29
    2b4c:	cd b7       	in	r28, 0x3d	; 61
    2b4e:	de b7       	in	r29, 0x3e	; 62
    WiFiDrv::wifiDriverInit();
    2b50:	0e 94 29 11 	call	0x2252	; 0x2252 <_ZN7WiFiDrv14wifiDriverInitEv>
}
    2b54:	df 91       	pop	r29
    2b56:	cf 91       	pop	r28
    2b58:	08 95       	ret

00002b5a <_ZN9WiFiClass9getSocketEv>:

uint8_t WiFiClass::getSocket()
{
    2b5a:	cf 93       	push	r28
    2b5c:	df 93       	push	r29
    2b5e:	1f 92       	push	r1
    2b60:	cd b7       	in	r28, 0x3d	; 61
    2b62:	de b7       	in	r29, 0x3e	; 62
    for (uint8_t i = 0; i < MAX_SOCK_NUM; ++i)
    2b64:	19 82       	std	Y+1, r1	; 0x01
    2b66:	11 c0       	rjmp	.+34     	; 0x2b8a <_ZN9WiFiClass9getSocketEv+0x30>
    {
        if (WiFiClass::_server_port[i] == 0)
    2b68:	89 81       	ldd	r24, Y+1	; 0x01
    2b6a:	88 2f       	mov	r24, r24
    2b6c:	90 e0       	ldi	r25, 0x00	; 0
    2b6e:	88 0f       	add	r24, r24
    2b70:	99 1f       	adc	r25, r25
    2b72:	85 5f       	subi	r24, 0xF5	; 245
    2b74:	98 4f       	sbci	r25, 0xF8	; 248
    2b76:	fc 01       	movw	r30, r24
    2b78:	80 81       	ld	r24, Z
    2b7a:	91 81       	ldd	r25, Z+1	; 0x01
    2b7c:	00 97       	sbiw	r24, 0x00	; 0
    2b7e:	11 f4       	brne	.+4      	; 0x2b84 <_ZN9WiFiClass9getSocketEv+0x2a>
        {
             return i;
    2b80:	89 81       	ldd	r24, Y+1	; 0x01
    2b82:	0b c0       	rjmp	.+22     	; 0x2b9a <_ZN9WiFiClass9getSocketEv+0x40>
    WiFiDrv::wifiDriverInit();
}

uint8_t WiFiClass::getSocket()
{
    for (uint8_t i = 0; i < MAX_SOCK_NUM; ++i)
    2b84:	89 81       	ldd	r24, Y+1	; 0x01
    2b86:	8f 5f       	subi	r24, 0xFF	; 255
    2b88:	89 83       	std	Y+1, r24	; 0x01
    2b8a:	81 e0       	ldi	r24, 0x01	; 1
    2b8c:	99 81       	ldd	r25, Y+1	; 0x01
    2b8e:	94 30       	cpi	r25, 0x04	; 4
    2b90:	08 f0       	brcs	.+2      	; 0x2b94 <_ZN9WiFiClass9getSocketEv+0x3a>
    2b92:	80 e0       	ldi	r24, 0x00	; 0
    2b94:	88 23       	and	r24, r24
    2b96:	41 f7       	brne	.-48     	; 0x2b68 <_ZN9WiFiClass9getSocketEv+0xe>
        if (WiFiClass::_server_port[i] == 0)
        {
             return i;
        }
    }
    return NO_SOCKET_AVAIL;
    2b98:	8f ef       	ldi	r24, 0xFF	; 255
}
    2b9a:	0f 90       	pop	r0
    2b9c:	df 91       	pop	r29
    2b9e:	cf 91       	pop	r28
    2ba0:	08 95       	ret

00002ba2 <_ZN9WiFiClass15firmwareVersionEv>:

char* WiFiClass::firmwareVersion()
{
    2ba2:	cf 93       	push	r28
    2ba4:	df 93       	push	r29
    2ba6:	cd b7       	in	r28, 0x3d	; 61
    2ba8:	de b7       	in	r29, 0x3e	; 62
	return WiFiDrv::getFwVersion();
    2baa:	0e 94 42 15 	call	0x2a84	; 0x2a84 <_ZN7WiFiDrv12getFwVersionEv>
}
    2bae:	df 91       	pop	r29
    2bb0:	cf 91       	pop	r28
    2bb2:	08 95       	ret

00002bb4 <_ZN9WiFiClass5beginEPc>:

int WiFiClass::begin(char* ssid)
{
    2bb4:	cf 93       	push	r28
    2bb6:	df 93       	push	r29
    2bb8:	00 d0       	rcall	.+0      	; 0x2bba <_ZN9WiFiClass5beginEPc+0x6>
    2bba:	00 d0       	rcall	.+0      	; 0x2bbc <_ZN9WiFiClass5beginEPc+0x8>
    2bbc:	00 d0       	rcall	.+0      	; 0x2bbe <_ZN9WiFiClass5beginEPc+0xa>
    2bbe:	cd b7       	in	r28, 0x3d	; 61
    2bc0:	de b7       	in	r29, 0x3e	; 62
    2bc2:	9c 83       	std	Y+4, r25	; 0x04
    2bc4:	8b 83       	std	Y+3, r24	; 0x03
    2bc6:	7e 83       	std	Y+6, r23	; 0x06
    2bc8:	6d 83       	std	Y+5, r22	; 0x05
	uint8_t status = WL_IDLE_STATUS;
    2bca:	19 82       	std	Y+1, r1	; 0x01
	uint8_t attempts = WL_MAX_ATTEMPT_CONNECTION;
    2bcc:	8a e0       	ldi	r24, 0x0A	; 10
    2bce:	8a 83       	std	Y+2, r24	; 0x02

   if (WiFiDrv::wifiSetNetwork(ssid, strlen(ssid)) != WL_FAILURE)
    2bd0:	8d 81       	ldd	r24, Y+5	; 0x05
    2bd2:	9e 81       	ldd	r25, Y+6	; 0x06
    2bd4:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    2bd8:	28 2f       	mov	r18, r24
    2bda:	8d 81       	ldd	r24, Y+5	; 0x05
    2bdc:	9e 81       	ldd	r25, Y+6	; 0x06
    2bde:	62 2f       	mov	r22, r18
    2be0:	0e 94 32 11 	call	0x2264	; 0x2264 <_ZN7WiFiDrv14wifiSetNetworkEPch>
    2be4:	98 2f       	mov	r25, r24
    2be6:	81 e0       	ldi	r24, 0x01	; 1
    2be8:	9f 3f       	cpi	r25, 0xFF	; 255
    2bea:	09 f4       	brne	.+2      	; 0x2bee <_ZN9WiFiClass5beginEPc+0x3a>
    2bec:	80 e0       	ldi	r24, 0x00	; 0
    2bee:	88 23       	and	r24, r24
    2bf0:	d9 f0       	breq	.+54     	; 0x2c28 <_ZN9WiFiClass5beginEPc+0x74>
   {
	   do
	   {
		   delay(WL_DELAY_START_CONNECTION);
    2bf2:	68 e8       	ldi	r22, 0x88	; 136
    2bf4:	73 e1       	ldi	r23, 0x13	; 19
    2bf6:	80 e0       	ldi	r24, 0x00	; 0
    2bf8:	90 e0       	ldi	r25, 0x00	; 0
    2bfa:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
		   status = WiFiDrv::getConnectionStatus();
    2bfe:	0e 94 34 12 	call	0x2468	; 0x2468 <_ZN7WiFiDrv19getConnectionStatusEv>
    2c02:	89 83       	std	Y+1, r24	; 0x01
	uint8_t status = WL_IDLE_STATUS;
	uint8_t attempts = WL_MAX_ATTEMPT_CONNECTION;

   if (WiFiDrv::wifiSetNetwork(ssid, strlen(ssid)) != WL_FAILURE)
   {
	   do
    2c04:	89 81       	ldd	r24, Y+1	; 0x01
    2c06:	88 23       	and	r24, r24
    2c08:	19 f0       	breq	.+6      	; 0x2c10 <_ZN9WiFiClass5beginEPc+0x5c>
    2c0a:	89 81       	ldd	r24, Y+1	; 0x01
    2c0c:	82 30       	cpi	r24, 0x02	; 2
    2c0e:	41 f4       	brne	.+16     	; 0x2c20 <_ZN9WiFiClass5beginEPc+0x6c>
    2c10:	8a 81       	ldd	r24, Y+2	; 0x02
    2c12:	81 50       	subi	r24, 0x01	; 1
    2c14:	8a 83       	std	Y+2, r24	; 0x02
    2c16:	8a 81       	ldd	r24, Y+2	; 0x02
    2c18:	88 23       	and	r24, r24
    2c1a:	11 f0       	breq	.+4      	; 0x2c20 <_ZN9WiFiClass5beginEPc+0x6c>
    2c1c:	81 e0       	ldi	r24, 0x01	; 1
    2c1e:	01 c0       	rjmp	.+2      	; 0x2c22 <_ZN9WiFiClass5beginEPc+0x6e>
    2c20:	80 e0       	ldi	r24, 0x00	; 0
    2c22:	88 23       	and	r24, r24
    2c24:	31 f7       	brne	.-52     	; 0x2bf2 <_ZN9WiFiClass5beginEPc+0x3e>
    2c26:	02 c0       	rjmp	.+4      	; 0x2c2c <_ZN9WiFiClass5beginEPc+0x78>
		   status = WiFiDrv::getConnectionStatus();
	   }
	   while ((( status == WL_IDLE_STATUS)||(status == WL_SCAN_COMPLETED))&&(--attempts>0));
   }else
   {
	   status = WL_CONNECT_FAILED;
    2c28:	84 e0       	ldi	r24, 0x04	; 4
    2c2a:	89 83       	std	Y+1, r24	; 0x01
   }
   return status;
    2c2c:	89 81       	ldd	r24, Y+1	; 0x01
    2c2e:	88 2f       	mov	r24, r24
    2c30:	90 e0       	ldi	r25, 0x00	; 0
}
    2c32:	26 96       	adiw	r28, 0x06	; 6
    2c34:	0f b6       	in	r0, 0x3f	; 63
    2c36:	f8 94       	cli
    2c38:	de bf       	out	0x3e, r29	; 62
    2c3a:	0f be       	out	0x3f, r0	; 63
    2c3c:	cd bf       	out	0x3d, r28	; 61
    2c3e:	df 91       	pop	r29
    2c40:	cf 91       	pop	r28
    2c42:	08 95       	ret

00002c44 <_ZN9WiFiClass5beginEPchPKc>:

int WiFiClass::begin(char* ssid, uint8_t key_idx, const char *key)
{
    2c44:	0f 93       	push	r16
    2c46:	1f 93       	push	r17
    2c48:	cf 93       	push	r28
    2c4a:	df 93       	push	r29
    2c4c:	cd b7       	in	r28, 0x3d	; 61
    2c4e:	de b7       	in	r29, 0x3e	; 62
    2c50:	29 97       	sbiw	r28, 0x09	; 9
    2c52:	0f b6       	in	r0, 0x3f	; 63
    2c54:	f8 94       	cli
    2c56:	de bf       	out	0x3e, r29	; 62
    2c58:	0f be       	out	0x3f, r0	; 63
    2c5a:	cd bf       	out	0x3d, r28	; 61
    2c5c:	9c 83       	std	Y+4, r25	; 0x04
    2c5e:	8b 83       	std	Y+3, r24	; 0x03
    2c60:	7e 83       	std	Y+6, r23	; 0x06
    2c62:	6d 83       	std	Y+5, r22	; 0x05
    2c64:	4f 83       	std	Y+7, r20	; 0x07
    2c66:	39 87       	std	Y+9, r19	; 0x09
    2c68:	28 87       	std	Y+8, r18	; 0x08
	uint8_t status = WL_IDLE_STATUS;
    2c6a:	19 82       	std	Y+1, r1	; 0x01
	uint8_t attempts = WL_MAX_ATTEMPT_CONNECTION;
    2c6c:	8a e0       	ldi	r24, 0x0A	; 10
    2c6e:	8a 83       	std	Y+2, r24	; 0x02

	// set encryption key
   if (WiFiDrv::wifiSetKey(ssid, strlen(ssid), key_idx, key, strlen(key)) != WL_FAILURE)
    2c70:	88 85       	ldd	r24, Y+8	; 0x08
    2c72:	99 85       	ldd	r25, Y+9	; 0x09
    2c74:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    2c78:	18 2f       	mov	r17, r24
    2c7a:	8d 81       	ldd	r24, Y+5	; 0x05
    2c7c:	9e 81       	ldd	r25, Y+6	; 0x06
    2c7e:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    2c82:	58 2f       	mov	r21, r24
    2c84:	28 85       	ldd	r18, Y+8	; 0x08
    2c86:	39 85       	ldd	r19, Y+9	; 0x09
    2c88:	8d 81       	ldd	r24, Y+5	; 0x05
    2c8a:	9e 81       	ldd	r25, Y+6	; 0x06
    2c8c:	01 2f       	mov	r16, r17
    2c8e:	4f 81       	ldd	r20, Y+7	; 0x07
    2c90:	65 2f       	mov	r22, r21
    2c92:	0e 94 b6 11 	call	0x236c	; 0x236c <_ZN7WiFiDrv10wifiSetKeyEPchhPKvh>
    2c96:	98 2f       	mov	r25, r24
    2c98:	81 e0       	ldi	r24, 0x01	; 1
    2c9a:	9f 3f       	cpi	r25, 0xFF	; 255
    2c9c:	09 f4       	brne	.+2      	; 0x2ca0 <_ZN9WiFiClass5beginEPchPKc+0x5c>
    2c9e:	80 e0       	ldi	r24, 0x00	; 0
    2ca0:	88 23       	and	r24, r24
    2ca2:	d9 f0       	breq	.+54     	; 0x2cda <_ZN9WiFiClass5beginEPchPKc+0x96>
   {
	   do
	   {
		   delay(WL_DELAY_START_CONNECTION);
    2ca4:	68 e8       	ldi	r22, 0x88	; 136
    2ca6:	73 e1       	ldi	r23, 0x13	; 19
    2ca8:	80 e0       	ldi	r24, 0x00	; 0
    2caa:	90 e0       	ldi	r25, 0x00	; 0
    2cac:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
		   status = WiFiDrv::getConnectionStatus();
    2cb0:	0e 94 34 12 	call	0x2468	; 0x2468 <_ZN7WiFiDrv19getConnectionStatusEv>
    2cb4:	89 83       	std	Y+1, r24	; 0x01
	uint8_t attempts = WL_MAX_ATTEMPT_CONNECTION;

	// set encryption key
   if (WiFiDrv::wifiSetKey(ssid, strlen(ssid), key_idx, key, strlen(key)) != WL_FAILURE)
   {
	   do
    2cb6:	89 81       	ldd	r24, Y+1	; 0x01
    2cb8:	88 23       	and	r24, r24
    2cba:	19 f0       	breq	.+6      	; 0x2cc2 <_ZN9WiFiClass5beginEPchPKc+0x7e>
    2cbc:	89 81       	ldd	r24, Y+1	; 0x01
    2cbe:	82 30       	cpi	r24, 0x02	; 2
    2cc0:	41 f4       	brne	.+16     	; 0x2cd2 <_ZN9WiFiClass5beginEPchPKc+0x8e>
    2cc2:	8a 81       	ldd	r24, Y+2	; 0x02
    2cc4:	81 50       	subi	r24, 0x01	; 1
    2cc6:	8a 83       	std	Y+2, r24	; 0x02
    2cc8:	8a 81       	ldd	r24, Y+2	; 0x02
    2cca:	88 23       	and	r24, r24
    2ccc:	11 f0       	breq	.+4      	; 0x2cd2 <_ZN9WiFiClass5beginEPchPKc+0x8e>
    2cce:	81 e0       	ldi	r24, 0x01	; 1
    2cd0:	01 c0       	rjmp	.+2      	; 0x2cd4 <_ZN9WiFiClass5beginEPchPKc+0x90>
    2cd2:	80 e0       	ldi	r24, 0x00	; 0
    2cd4:	88 23       	and	r24, r24
    2cd6:	31 f7       	brne	.-52     	; 0x2ca4 <_ZN9WiFiClass5beginEPchPKc+0x60>
    2cd8:	02 c0       	rjmp	.+4      	; 0x2cde <_ZN9WiFiClass5beginEPchPKc+0x9a>
		   delay(WL_DELAY_START_CONNECTION);
		   status = WiFiDrv::getConnectionStatus();
	   }
	   while ((( status == WL_IDLE_STATUS)||(status == WL_SCAN_COMPLETED))&&(--attempts>0));
   }else{
	   status = WL_CONNECT_FAILED;
    2cda:	84 e0       	ldi	r24, 0x04	; 4
    2cdc:	89 83       	std	Y+1, r24	; 0x01
   }
   return status;
    2cde:	89 81       	ldd	r24, Y+1	; 0x01
    2ce0:	88 2f       	mov	r24, r24
    2ce2:	90 e0       	ldi	r25, 0x00	; 0
}
    2ce4:	29 96       	adiw	r28, 0x09	; 9
    2ce6:	0f b6       	in	r0, 0x3f	; 63
    2ce8:	f8 94       	cli
    2cea:	de bf       	out	0x3e, r29	; 62
    2cec:	0f be       	out	0x3f, r0	; 63
    2cee:	cd bf       	out	0x3d, r28	; 61
    2cf0:	df 91       	pop	r29
    2cf2:	cf 91       	pop	r28
    2cf4:	1f 91       	pop	r17
    2cf6:	0f 91       	pop	r16
    2cf8:	08 95       	ret

00002cfa <_ZN9WiFiClass5beginEPcPKc>:

int WiFiClass::begin(char* ssid, const char *passphrase)
{
    2cfa:	1f 93       	push	r17
    2cfc:	cf 93       	push	r28
    2cfe:	df 93       	push	r29
    2d00:	cd b7       	in	r28, 0x3d	; 61
    2d02:	de b7       	in	r29, 0x3e	; 62
    2d04:	28 97       	sbiw	r28, 0x08	; 8
    2d06:	0f b6       	in	r0, 0x3f	; 63
    2d08:	f8 94       	cli
    2d0a:	de bf       	out	0x3e, r29	; 62
    2d0c:	0f be       	out	0x3f, r0	; 63
    2d0e:	cd bf       	out	0x3d, r28	; 61
    2d10:	9c 83       	std	Y+4, r25	; 0x04
    2d12:	8b 83       	std	Y+3, r24	; 0x03
    2d14:	7e 83       	std	Y+6, r23	; 0x06
    2d16:	6d 83       	std	Y+5, r22	; 0x05
    2d18:	58 87       	std	Y+8, r21	; 0x08
    2d1a:	4f 83       	std	Y+7, r20	; 0x07
	uint8_t status = WL_IDLE_STATUS;
    2d1c:	19 82       	std	Y+1, r1	; 0x01
	uint8_t attempts = WL_MAX_ATTEMPT_CONNECTION;
    2d1e:	8a e0       	ldi	r24, 0x0A	; 10
    2d20:	8a 83       	std	Y+2, r24	; 0x02

    // set passphrase
    if (WiFiDrv::wifiSetPassphrase(ssid, strlen(ssid), passphrase, strlen(passphrase))!= WL_FAILURE)
    2d22:	8f 81       	ldd	r24, Y+7	; 0x07
    2d24:	98 85       	ldd	r25, Y+8	; 0x08
    2d26:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    2d2a:	18 2f       	mov	r17, r24
    2d2c:	8d 81       	ldd	r24, Y+5	; 0x05
    2d2e:	9e 81       	ldd	r25, Y+6	; 0x06
    2d30:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    2d34:	38 2f       	mov	r19, r24
    2d36:	4f 81       	ldd	r20, Y+7	; 0x07
    2d38:	58 85       	ldd	r21, Y+8	; 0x08
    2d3a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d3c:	9e 81       	ldd	r25, Y+6	; 0x06
    2d3e:	21 2f       	mov	r18, r17
    2d40:	63 2f       	mov	r22, r19
    2d42:	0e 94 70 11 	call	0x22e0	; 0x22e0 <_ZN7WiFiDrv17wifiSetPassphraseEPchPKch>
    2d46:	98 2f       	mov	r25, r24
    2d48:	81 e0       	ldi	r24, 0x01	; 1
    2d4a:	9f 3f       	cpi	r25, 0xFF	; 255
    2d4c:	09 f4       	brne	.+2      	; 0x2d50 <_ZN9WiFiClass5beginEPcPKc+0x56>
    2d4e:	80 e0       	ldi	r24, 0x00	; 0
    2d50:	88 23       	and	r24, r24
    2d52:	d9 f0       	breq	.+54     	; 0x2d8a <_ZN9WiFiClass5beginEPcPKc+0x90>
    {
 	   do
 	   {
 		   delay(WL_DELAY_START_CONNECTION);
    2d54:	68 e8       	ldi	r22, 0x88	; 136
    2d56:	73 e1       	ldi	r23, 0x13	; 19
    2d58:	80 e0       	ldi	r24, 0x00	; 0
    2d5a:	90 e0       	ldi	r25, 0x00	; 0
    2d5c:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
 		   status = WiFiDrv::getConnectionStatus();
    2d60:	0e 94 34 12 	call	0x2468	; 0x2468 <_ZN7WiFiDrv19getConnectionStatusEv>
    2d64:	89 83       	std	Y+1, r24	; 0x01
	uint8_t attempts = WL_MAX_ATTEMPT_CONNECTION;

    // set passphrase
    if (WiFiDrv::wifiSetPassphrase(ssid, strlen(ssid), passphrase, strlen(passphrase))!= WL_FAILURE)
    {
 	   do
    2d66:	89 81       	ldd	r24, Y+1	; 0x01
    2d68:	88 23       	and	r24, r24
    2d6a:	19 f0       	breq	.+6      	; 0x2d72 <_ZN9WiFiClass5beginEPcPKc+0x78>
    2d6c:	89 81       	ldd	r24, Y+1	; 0x01
    2d6e:	82 30       	cpi	r24, 0x02	; 2
    2d70:	41 f4       	brne	.+16     	; 0x2d82 <_ZN9WiFiClass5beginEPcPKc+0x88>
    2d72:	8a 81       	ldd	r24, Y+2	; 0x02
    2d74:	81 50       	subi	r24, 0x01	; 1
    2d76:	8a 83       	std	Y+2, r24	; 0x02
    2d78:	8a 81       	ldd	r24, Y+2	; 0x02
    2d7a:	88 23       	and	r24, r24
    2d7c:	11 f0       	breq	.+4      	; 0x2d82 <_ZN9WiFiClass5beginEPcPKc+0x88>
    2d7e:	81 e0       	ldi	r24, 0x01	; 1
    2d80:	01 c0       	rjmp	.+2      	; 0x2d84 <_ZN9WiFiClass5beginEPcPKc+0x8a>
    2d82:	80 e0       	ldi	r24, 0x00	; 0
    2d84:	88 23       	and	r24, r24
    2d86:	31 f7       	brne	.-52     	; 0x2d54 <_ZN9WiFiClass5beginEPcPKc+0x5a>
    2d88:	02 c0       	rjmp	.+4      	; 0x2d8e <_ZN9WiFiClass5beginEPcPKc+0x94>
 		   delay(WL_DELAY_START_CONNECTION);
 		   status = WiFiDrv::getConnectionStatus();
 	   }
	   while ((( status == WL_IDLE_STATUS)||(status == WL_SCAN_COMPLETED))&&(--attempts>0));
    }else{
    	status = WL_CONNECT_FAILED;
    2d8a:	84 e0       	ldi	r24, 0x04	; 4
    2d8c:	89 83       	std	Y+1, r24	; 0x01
    }
    return status;
    2d8e:	89 81       	ldd	r24, Y+1	; 0x01
    2d90:	88 2f       	mov	r24, r24
    2d92:	90 e0       	ldi	r25, 0x00	; 0
}
    2d94:	28 96       	adiw	r28, 0x08	; 8
    2d96:	0f b6       	in	r0, 0x3f	; 63
    2d98:	f8 94       	cli
    2d9a:	de bf       	out	0x3e, r29	; 62
    2d9c:	0f be       	out	0x3f, r0	; 63
    2d9e:	cd bf       	out	0x3d, r28	; 61
    2da0:	df 91       	pop	r29
    2da2:	cf 91       	pop	r28
    2da4:	1f 91       	pop	r17
    2da6:	08 95       	ret

00002da8 <_ZN9WiFiClass10disconnectEv>:

int WiFiClass::disconnect()
{
    2da8:	cf 93       	push	r28
    2daa:	df 93       	push	r29
    2dac:	00 d0       	rcall	.+0      	; 0x2dae <_ZN9WiFiClass10disconnectEv+0x6>
    2dae:	cd b7       	in	r28, 0x3d	; 61
    2db0:	de b7       	in	r29, 0x3e	; 62
    2db2:	9a 83       	std	Y+2, r25	; 0x02
    2db4:	89 83       	std	Y+1, r24	; 0x01
    return WiFiDrv::disconnect();
    2db6:	0e 94 05 12 	call	0x240a	; 0x240a <_ZN7WiFiDrv10disconnectEv>
    2dba:	99 27       	eor	r25, r25
    2dbc:	87 fd       	sbrc	r24, 7
    2dbe:	90 95       	com	r25
}
    2dc0:	0f 90       	pop	r0
    2dc2:	0f 90       	pop	r0
    2dc4:	df 91       	pop	r29
    2dc6:	cf 91       	pop	r28
    2dc8:	08 95       	ret

00002dca <_ZN9WiFiClass10macAddressEPh>:

uint8_t* WiFiClass::macAddress(uint8_t* mac)
{
    2dca:	cf 93       	push	r28
    2dcc:	df 93       	push	r29
    2dce:	00 d0       	rcall	.+0      	; 0x2dd0 <_ZN9WiFiClass10macAddressEPh+0x6>
    2dd0:	00 d0       	rcall	.+0      	; 0x2dd2 <_ZN9WiFiClass10macAddressEPh+0x8>
    2dd2:	00 d0       	rcall	.+0      	; 0x2dd4 <_ZN9WiFiClass10macAddressEPh+0xa>
    2dd4:	cd b7       	in	r28, 0x3d	; 61
    2dd6:	de b7       	in	r29, 0x3e	; 62
    2dd8:	9c 83       	std	Y+4, r25	; 0x04
    2dda:	8b 83       	std	Y+3, r24	; 0x03
    2ddc:	7e 83       	std	Y+6, r23	; 0x06
    2dde:	6d 83       	std	Y+5, r22	; 0x05
	uint8_t* _mac = WiFiDrv::getMacAddress();
    2de0:	0e 94 58 12 	call	0x24b0	; 0x24b0 <_ZN7WiFiDrv13getMacAddressEv>
    2de4:	9a 83       	std	Y+2, r25	; 0x02
    2de6:	89 83       	std	Y+1, r24	; 0x01
	memcpy(mac, _mac, WL_MAC_ADDR_LENGTH);
    2de8:	29 81       	ldd	r18, Y+1	; 0x01
    2dea:	3a 81       	ldd	r19, Y+2	; 0x02
    2dec:	8d 81       	ldd	r24, Y+5	; 0x05
    2dee:	9e 81       	ldd	r25, Y+6	; 0x06
    2df0:	46 e0       	ldi	r20, 0x06	; 6
    2df2:	50 e0       	ldi	r21, 0x00	; 0
    2df4:	b9 01       	movw	r22, r18
    2df6:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
    return mac;
    2dfa:	8d 81       	ldd	r24, Y+5	; 0x05
    2dfc:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2dfe:	26 96       	adiw	r28, 0x06	; 6
    2e00:	0f b6       	in	r0, 0x3f	; 63
    2e02:	f8 94       	cli
    2e04:	de bf       	out	0x3e, r29	; 62
    2e06:	0f be       	out	0x3f, r0	; 63
    2e08:	cd bf       	out	0x3d, r28	; 61
    2e0a:	df 91       	pop	r29
    2e0c:	cf 91       	pop	r28
    2e0e:	08 95       	ret

00002e10 <_ZN9WiFiClass7localIPEv>:
   
IPAddress WiFiClass::localIP()
{
    2e10:	cf 93       	push	r28
    2e12:	df 93       	push	r29
    2e14:	00 d0       	rcall	.+0      	; 0x2e16 <_ZN9WiFiClass7localIPEv+0x6>
    2e16:	00 d0       	rcall	.+0      	; 0x2e18 <_ZN9WiFiClass7localIPEv+0x8>
    2e18:	cd b7       	in	r28, 0x3d	; 61
    2e1a:	de b7       	in	r29, 0x3e	; 62
    2e1c:	9a 83       	std	Y+2, r25	; 0x02
    2e1e:	89 83       	std	Y+1, r24	; 0x01
    2e20:	7c 83       	std	Y+4, r23	; 0x04
    2e22:	6b 83       	std	Y+3, r22	; 0x03
	IPAddress ret;
    2e24:	89 81       	ldd	r24, Y+1	; 0x01
    2e26:	9a 81       	ldd	r25, Y+2	; 0x02
    2e28:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>
	WiFiDrv::getIpAddress(ret);
    2e2c:	89 81       	ldd	r24, Y+1	; 0x01
    2e2e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e30:	0e 94 82 12 	call	0x2504	; 0x2504 <_ZN7WiFiDrv12getIpAddressER9IPAddress>
	return ret;
    2e34:	00 00       	nop
}
    2e36:	89 81       	ldd	r24, Y+1	; 0x01
    2e38:	9a 81       	ldd	r25, Y+2	; 0x02
    2e3a:	0f 90       	pop	r0
    2e3c:	0f 90       	pop	r0
    2e3e:	0f 90       	pop	r0
    2e40:	0f 90       	pop	r0
    2e42:	df 91       	pop	r29
    2e44:	cf 91       	pop	r28
    2e46:	08 95       	ret

00002e48 <_ZN9WiFiClass10subnetMaskEv>:

IPAddress WiFiClass::subnetMask()
{
    2e48:	cf 93       	push	r28
    2e4a:	df 93       	push	r29
    2e4c:	00 d0       	rcall	.+0      	; 0x2e4e <_ZN9WiFiClass10subnetMaskEv+0x6>
    2e4e:	00 d0       	rcall	.+0      	; 0x2e50 <_ZN9WiFiClass10subnetMaskEv+0x8>
    2e50:	cd b7       	in	r28, 0x3d	; 61
    2e52:	de b7       	in	r29, 0x3e	; 62
    2e54:	9a 83       	std	Y+2, r25	; 0x02
    2e56:	89 83       	std	Y+1, r24	; 0x01
    2e58:	7c 83       	std	Y+4, r23	; 0x04
    2e5a:	6b 83       	std	Y+3, r22	; 0x03
	IPAddress ret;
    2e5c:	89 81       	ldd	r24, Y+1	; 0x01
    2e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e60:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>
	WiFiDrv::getSubnetMask(ret);
    2e64:	89 81       	ldd	r24, Y+1	; 0x01
    2e66:	9a 81       	ldd	r25, Y+2	; 0x02
    2e68:	0e 94 9c 12 	call	0x2538	; 0x2538 <_ZN7WiFiDrv13getSubnetMaskER9IPAddress>
	return ret;
    2e6c:	00 00       	nop
}
    2e6e:	89 81       	ldd	r24, Y+1	; 0x01
    2e70:	9a 81       	ldd	r25, Y+2	; 0x02
    2e72:	0f 90       	pop	r0
    2e74:	0f 90       	pop	r0
    2e76:	0f 90       	pop	r0
    2e78:	0f 90       	pop	r0
    2e7a:	df 91       	pop	r29
    2e7c:	cf 91       	pop	r28
    2e7e:	08 95       	ret

00002e80 <_ZN9WiFiClass9gatewayIPEv>:

IPAddress WiFiClass::gatewayIP()
{
    2e80:	cf 93       	push	r28
    2e82:	df 93       	push	r29
    2e84:	00 d0       	rcall	.+0      	; 0x2e86 <_ZN9WiFiClass9gatewayIPEv+0x6>
    2e86:	00 d0       	rcall	.+0      	; 0x2e88 <_ZN9WiFiClass9gatewayIPEv+0x8>
    2e88:	cd b7       	in	r28, 0x3d	; 61
    2e8a:	de b7       	in	r29, 0x3e	; 62
    2e8c:	9a 83       	std	Y+2, r25	; 0x02
    2e8e:	89 83       	std	Y+1, r24	; 0x01
    2e90:	7c 83       	std	Y+4, r23	; 0x04
    2e92:	6b 83       	std	Y+3, r22	; 0x03
	IPAddress ret;
    2e94:	89 81       	ldd	r24, Y+1	; 0x01
    2e96:	9a 81       	ldd	r25, Y+2	; 0x02
    2e98:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>
	WiFiDrv::getGatewayIP(ret);
    2e9c:	89 81       	ldd	r24, Y+1	; 0x01
    2e9e:	9a 81       	ldd	r25, Y+2	; 0x02
    2ea0:	0e 94 b6 12 	call	0x256c	; 0x256c <_ZN7WiFiDrv12getGatewayIPER9IPAddress>
	return ret;
    2ea4:	00 00       	nop
}
    2ea6:	89 81       	ldd	r24, Y+1	; 0x01
    2ea8:	9a 81       	ldd	r25, Y+2	; 0x02
    2eaa:	0f 90       	pop	r0
    2eac:	0f 90       	pop	r0
    2eae:	0f 90       	pop	r0
    2eb0:	0f 90       	pop	r0
    2eb2:	df 91       	pop	r29
    2eb4:	cf 91       	pop	r28
    2eb6:	08 95       	ret

00002eb8 <_ZN9WiFiClass4SSIDEv>:

char* WiFiClass::SSID()
{
    2eb8:	cf 93       	push	r28
    2eba:	df 93       	push	r29
    2ebc:	00 d0       	rcall	.+0      	; 0x2ebe <_ZN9WiFiClass4SSIDEv+0x6>
    2ebe:	cd b7       	in	r28, 0x3d	; 61
    2ec0:	de b7       	in	r29, 0x3e	; 62
    2ec2:	9a 83       	std	Y+2, r25	; 0x02
    2ec4:	89 83       	std	Y+1, r24	; 0x01
    return WiFiDrv::getCurrentSSID();
    2ec6:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <_ZN7WiFiDrv14getCurrentSSIDEv>
}
    2eca:	0f 90       	pop	r0
    2ecc:	0f 90       	pop	r0
    2ece:	df 91       	pop	r29
    2ed0:	cf 91       	pop	r28
    2ed2:	08 95       	ret

00002ed4 <_ZN9WiFiClass5BSSIDEPh>:

uint8_t* WiFiClass::BSSID(uint8_t* bssid)
{
    2ed4:	cf 93       	push	r28
    2ed6:	df 93       	push	r29
    2ed8:	00 d0       	rcall	.+0      	; 0x2eda <_ZN9WiFiClass5BSSIDEPh+0x6>
    2eda:	00 d0       	rcall	.+0      	; 0x2edc <_ZN9WiFiClass5BSSIDEPh+0x8>
    2edc:	00 d0       	rcall	.+0      	; 0x2ede <_ZN9WiFiClass5BSSIDEPh+0xa>
    2ede:	cd b7       	in	r28, 0x3d	; 61
    2ee0:	de b7       	in	r29, 0x3e	; 62
    2ee2:	9c 83       	std	Y+4, r25	; 0x04
    2ee4:	8b 83       	std	Y+3, r24	; 0x03
    2ee6:	7e 83       	std	Y+6, r23	; 0x06
    2ee8:	6d 83       	std	Y+5, r22	; 0x05
	uint8_t* _bssid = WiFiDrv::getCurrentBSSID();
    2eea:	0e 94 fa 12 	call	0x25f4	; 0x25f4 <_ZN7WiFiDrv15getCurrentBSSIDEv>
    2eee:	9a 83       	std	Y+2, r25	; 0x02
    2ef0:	89 83       	std	Y+1, r24	; 0x01
	memcpy(bssid, _bssid, WL_MAC_ADDR_LENGTH);
    2ef2:	29 81       	ldd	r18, Y+1	; 0x01
    2ef4:	3a 81       	ldd	r19, Y+2	; 0x02
    2ef6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ef8:	9e 81       	ldd	r25, Y+6	; 0x06
    2efa:	46 e0       	ldi	r20, 0x06	; 6
    2efc:	50 e0       	ldi	r21, 0x00	; 0
    2efe:	b9 01       	movw	r22, r18
    2f00:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
    return bssid;
    2f04:	8d 81       	ldd	r24, Y+5	; 0x05
    2f06:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2f08:	26 96       	adiw	r28, 0x06	; 6
    2f0a:	0f b6       	in	r0, 0x3f	; 63
    2f0c:	f8 94       	cli
    2f0e:	de bf       	out	0x3e, r29	; 62
    2f10:	0f be       	out	0x3f, r0	; 63
    2f12:	cd bf       	out	0x3d, r28	; 61
    2f14:	df 91       	pop	r29
    2f16:	cf 91       	pop	r28
    2f18:	08 95       	ret

00002f1a <_ZN9WiFiClass4RSSIEv>:

int32_t WiFiClass::RSSI()
{
    2f1a:	cf 93       	push	r28
    2f1c:	df 93       	push	r29
    2f1e:	00 d0       	rcall	.+0      	; 0x2f20 <_ZN9WiFiClass4RSSIEv+0x6>
    2f20:	cd b7       	in	r28, 0x3d	; 61
    2f22:	de b7       	in	r29, 0x3e	; 62
    2f24:	9a 83       	std	Y+2, r25	; 0x02
    2f26:	89 83       	std	Y+1, r24	; 0x01
    return WiFiDrv::getCurrentRSSI();
    2f28:	0e 94 24 13 	call	0x2648	; 0x2648 <_ZN7WiFiDrv14getCurrentRSSIEv>
    2f2c:	dc 01       	movw	r26, r24
    2f2e:	cb 01       	movw	r24, r22
}
    2f30:	bc 01       	movw	r22, r24
    2f32:	cd 01       	movw	r24, r26
    2f34:	0f 90       	pop	r0
    2f36:	0f 90       	pop	r0
    2f38:	df 91       	pop	r29
    2f3a:	cf 91       	pop	r28
    2f3c:	08 95       	ret

00002f3e <_ZN9WiFiClass14encryptionTypeEv>:

uint8_t WiFiClass::encryptionType()
{
    2f3e:	cf 93       	push	r28
    2f40:	df 93       	push	r29
    2f42:	00 d0       	rcall	.+0      	; 0x2f44 <_ZN9WiFiClass14encryptionTypeEv+0x6>
    2f44:	cd b7       	in	r28, 0x3d	; 61
    2f46:	de b7       	in	r29, 0x3e	; 62
    2f48:	9a 83       	std	Y+2, r25	; 0x02
    2f4a:	89 83       	std	Y+1, r24	; 0x01
    return WiFiDrv::getCurrentEncryptionType();
    2f4c:	0e 94 5d 13 	call	0x26ba	; 0x26ba <_ZN7WiFiDrv24getCurrentEncryptionTypeEv>
}
    2f50:	0f 90       	pop	r0
    2f52:	0f 90       	pop	r0
    2f54:	df 91       	pop	r29
    2f56:	cf 91       	pop	r28
    2f58:	08 95       	ret

00002f5a <_ZN9WiFiClass12scanNetworksEv>:


int8_t WiFiClass::scanNetworks()
{
    2f5a:	cf 93       	push	r28
    2f5c:	df 93       	push	r29
    2f5e:	00 d0       	rcall	.+0      	; 0x2f60 <_ZN9WiFiClass12scanNetworksEv+0x6>
    2f60:	00 d0       	rcall	.+0      	; 0x2f62 <_ZN9WiFiClass12scanNetworksEv+0x8>
    2f62:	cd b7       	in	r28, 0x3d	; 61
    2f64:	de b7       	in	r29, 0x3e	; 62
    2f66:	9c 83       	std	Y+4, r25	; 0x04
    2f68:	8b 83       	std	Y+3, r24	; 0x03
	uint8_t attempts = 10;
    2f6a:	8a e0       	ldi	r24, 0x0A	; 10
    2f6c:	89 83       	std	Y+1, r24	; 0x01
	uint8_t numOfNetworks = 0;
    2f6e:	1a 82       	std	Y+2, r1	; 0x02

	if (WiFiDrv::startScanNetworks() == WL_FAILURE)
    2f70:	0e 94 8a 13 	call	0x2714	; 0x2714 <_ZN7WiFiDrv17startScanNetworksEv>
    2f74:	98 2f       	mov	r25, r24
    2f76:	81 e0       	ldi	r24, 0x01	; 1
    2f78:	9f 3f       	cpi	r25, 0xFF	; 255
    2f7a:	09 f0       	breq	.+2      	; 0x2f7e <_ZN9WiFiClass12scanNetworksEv+0x24>
    2f7c:	80 e0       	ldi	r24, 0x00	; 0
    2f7e:	88 23       	and	r24, r24
    2f80:	11 f0       	breq	.+4      	; 0x2f86 <_ZN9WiFiClass12scanNetworksEv+0x2c>
		return WL_FAILURE;
    2f82:	8f ef       	ldi	r24, 0xFF	; 255
    2f84:	18 c0       	rjmp	.+48     	; 0x2fb6 <_ZN9WiFiClass12scanNetworksEv+0x5c>
 	do
 	{
 		delay(2000);
    2f86:	60 ed       	ldi	r22, 0xD0	; 208
    2f88:	77 e0       	ldi	r23, 0x07	; 7
    2f8a:	80 e0       	ldi	r24, 0x00	; 0
    2f8c:	90 e0       	ldi	r25, 0x00	; 0
    2f8e:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
 		numOfNetworks = WiFiDrv::getScanNetworks();
    2f92:	0e 94 b5 13 	call	0x276a	; 0x276a <_ZN7WiFiDrv15getScanNetworksEv>
    2f96:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t attempts = 10;
	uint8_t numOfNetworks = 0;

	if (WiFiDrv::startScanNetworks() == WL_FAILURE)
		return WL_FAILURE;
 	do
    2f98:	8a 81       	ldd	r24, Y+2	; 0x02
    2f9a:	88 23       	and	r24, r24
    2f9c:	41 f4       	brne	.+16     	; 0x2fae <_ZN9WiFiClass12scanNetworksEv+0x54>
    2f9e:	89 81       	ldd	r24, Y+1	; 0x01
    2fa0:	81 50       	subi	r24, 0x01	; 1
    2fa2:	89 83       	std	Y+1, r24	; 0x01
    2fa4:	89 81       	ldd	r24, Y+1	; 0x01
    2fa6:	88 23       	and	r24, r24
    2fa8:	11 f0       	breq	.+4      	; 0x2fae <_ZN9WiFiClass12scanNetworksEv+0x54>
    2faa:	81 e0       	ldi	r24, 0x01	; 1
    2fac:	01 c0       	rjmp	.+2      	; 0x2fb0 <_ZN9WiFiClass12scanNetworksEv+0x56>
    2fae:	80 e0       	ldi	r24, 0x00	; 0
    2fb0:	88 23       	and	r24, r24
    2fb2:	49 f7       	brne	.-46     	; 0x2f86 <_ZN9WiFiClass12scanNetworksEv+0x2c>
 	{
 		delay(2000);
 		numOfNetworks = WiFiDrv::getScanNetworks();
 	}
	while (( numOfNetworks == 0)&&(--attempts>0));
	return numOfNetworks;
    2fb4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2fb6:	0f 90       	pop	r0
    2fb8:	0f 90       	pop	r0
    2fba:	0f 90       	pop	r0
    2fbc:	0f 90       	pop	r0
    2fbe:	df 91       	pop	r29
    2fc0:	cf 91       	pop	r28
    2fc2:	08 95       	ret

00002fc4 <_ZN9WiFiClass4SSIDEh>:

char* WiFiClass::SSID(uint8_t networkItem)
{
    2fc4:	cf 93       	push	r28
    2fc6:	df 93       	push	r29
    2fc8:	00 d0       	rcall	.+0      	; 0x2fca <_ZN9WiFiClass4SSIDEh+0x6>
    2fca:	1f 92       	push	r1
    2fcc:	cd b7       	in	r28, 0x3d	; 61
    2fce:	de b7       	in	r29, 0x3e	; 62
    2fd0:	9a 83       	std	Y+2, r25	; 0x02
    2fd2:	89 83       	std	Y+1, r24	; 0x01
    2fd4:	6b 83       	std	Y+3, r22	; 0x03
	return WiFiDrv::getSSIDNetoworks(networkItem);
    2fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd8:	0e 94 d5 13 	call	0x27aa	; 0x27aa <_ZN7WiFiDrv16getSSIDNetoworksEh>
}
    2fdc:	0f 90       	pop	r0
    2fde:	0f 90       	pop	r0
    2fe0:	0f 90       	pop	r0
    2fe2:	df 91       	pop	r29
    2fe4:	cf 91       	pop	r28
    2fe6:	08 95       	ret

00002fe8 <_ZN9WiFiClass4RSSIEh>:

int32_t WiFiClass::RSSI(uint8_t networkItem)
{
    2fe8:	cf 93       	push	r28
    2fea:	df 93       	push	r29
    2fec:	00 d0       	rcall	.+0      	; 0x2fee <_ZN9WiFiClass4RSSIEh+0x6>
    2fee:	1f 92       	push	r1
    2ff0:	cd b7       	in	r28, 0x3d	; 61
    2ff2:	de b7       	in	r29, 0x3e	; 62
    2ff4:	9a 83       	std	Y+2, r25	; 0x02
    2ff6:	89 83       	std	Y+1, r24	; 0x01
    2ff8:	6b 83       	std	Y+3, r22	; 0x03
	return WiFiDrv::getRSSINetoworks(networkItem);
    2ffa:	8b 81       	ldd	r24, Y+3	; 0x03
    2ffc:	0e 94 23 14 	call	0x2846	; 0x2846 <_ZN7WiFiDrv16getRSSINetoworksEh>
    3000:	dc 01       	movw	r26, r24
    3002:	cb 01       	movw	r24, r22
}
    3004:	bc 01       	movw	r22, r24
    3006:	cd 01       	movw	r24, r26
    3008:	0f 90       	pop	r0
    300a:	0f 90       	pop	r0
    300c:	0f 90       	pop	r0
    300e:	df 91       	pop	r29
    3010:	cf 91       	pop	r28
    3012:	08 95       	ret

00003014 <_ZN9WiFiClass14encryptionTypeEh>:

uint8_t WiFiClass::encryptionType(uint8_t networkItem)
{
    3014:	cf 93       	push	r28
    3016:	df 93       	push	r29
    3018:	00 d0       	rcall	.+0      	; 0x301a <_ZN9WiFiClass14encryptionTypeEh+0x6>
    301a:	1f 92       	push	r1
    301c:	cd b7       	in	r28, 0x3d	; 61
    301e:	de b7       	in	r29, 0x3e	; 62
    3020:	9a 83       	std	Y+2, r25	; 0x02
    3022:	89 83       	std	Y+1, r24	; 0x01
    3024:	6b 83       	std	Y+3, r22	; 0x03
    return WiFiDrv::getEncTypeNetowrks(networkItem);
    3026:	8b 81       	ldd	r24, Y+3	; 0x03
    3028:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <_ZN7WiFiDrv18getEncTypeNetowrksEh>
}
    302c:	0f 90       	pop	r0
    302e:	0f 90       	pop	r0
    3030:	0f 90       	pop	r0
    3032:	df 91       	pop	r29
    3034:	cf 91       	pop	r28
    3036:	08 95       	ret

00003038 <_ZN9WiFiClass6statusEv>:

uint8_t WiFiClass::status()
{
    3038:	cf 93       	push	r28
    303a:	df 93       	push	r29
    303c:	00 d0       	rcall	.+0      	; 0x303e <_ZN9WiFiClass6statusEv+0x6>
    303e:	cd b7       	in	r28, 0x3d	; 61
    3040:	de b7       	in	r29, 0x3e	; 62
    3042:	9a 83       	std	Y+2, r25	; 0x02
    3044:	89 83       	std	Y+1, r24	; 0x01
    return WiFiDrv::getConnectionStatus();
    3046:	0e 94 34 12 	call	0x2468	; 0x2468 <_ZN7WiFiDrv19getConnectionStatusEv>
}
    304a:	0f 90       	pop	r0
    304c:	0f 90       	pop	r0
    304e:	df 91       	pop	r29
    3050:	cf 91       	pop	r28
    3052:	08 95       	ret

00003054 <_ZN9WiFiClass10hostByNameEPKcR9IPAddress>:

int WiFiClass::hostByName(const char* aHostname, IPAddress& aResult)
{
    3054:	cf 93       	push	r28
    3056:	df 93       	push	r29
    3058:	00 d0       	rcall	.+0      	; 0x305a <_ZN9WiFiClass10hostByNameEPKcR9IPAddress+0x6>
    305a:	00 d0       	rcall	.+0      	; 0x305c <_ZN9WiFiClass10hostByNameEPKcR9IPAddress+0x8>
    305c:	00 d0       	rcall	.+0      	; 0x305e <_ZN9WiFiClass10hostByNameEPKcR9IPAddress+0xa>
    305e:	cd b7       	in	r28, 0x3d	; 61
    3060:	de b7       	in	r29, 0x3e	; 62
    3062:	9a 83       	std	Y+2, r25	; 0x02
    3064:	89 83       	std	Y+1, r24	; 0x01
    3066:	7c 83       	std	Y+4, r23	; 0x04
    3068:	6b 83       	std	Y+3, r22	; 0x03
    306a:	5e 83       	std	Y+6, r21	; 0x06
    306c:	4d 83       	std	Y+5, r20	; 0x05
	return WiFiDrv::getHostByName(aHostname, aResult);
    306e:	2d 81       	ldd	r18, Y+5	; 0x05
    3070:	3e 81       	ldd	r19, Y+6	; 0x06
    3072:	8b 81       	ldd	r24, Y+3	; 0x03
    3074:	9c 81       	ldd	r25, Y+4	; 0x04
    3076:	b9 01       	movw	r22, r18
    3078:	0e 94 ff 14 	call	0x29fe	; 0x29fe <_ZN7WiFiDrv13getHostByNameEPKcR9IPAddress>
}
    307c:	26 96       	adiw	r28, 0x06	; 6
    307e:	0f b6       	in	r0, 0x3f	; 63
    3080:	f8 94       	cli
    3082:	de bf       	out	0x3e, r29	; 62
    3084:	0f be       	out	0x3f, r0	; 63
    3086:	cd bf       	out	0x3d, r28	; 61
    3088:	df 91       	pop	r29
    308a:	cf 91       	pop	r28
    308c:	08 95       	ret

0000308e <_Z41__static_initialization_and_destruction_0ii>:

WiFiClass WiFi;
    308e:	0f 93       	push	r16
    3090:	cf 93       	push	r28
    3092:	df 93       	push	r29
    3094:	00 d0       	rcall	.+0      	; 0x3096 <_Z41__static_initialization_and_destruction_0ii+0x8>
    3096:	00 d0       	rcall	.+0      	; 0x3098 <_Z41__static_initialization_and_destruction_0ii+0xa>
    3098:	cd b7       	in	r28, 0x3d	; 61
    309a:	de b7       	in	r29, 0x3e	; 62
    309c:	9a 83       	std	Y+2, r25	; 0x02
    309e:	89 83       	std	Y+1, r24	; 0x01
    30a0:	7c 83       	std	Y+4, r23	; 0x04
    30a2:	6b 83       	std	Y+3, r22	; 0x03
    30a4:	89 81       	ldd	r24, Y+1	; 0x01
    30a6:	9a 81       	ldd	r25, Y+2	; 0x02
    30a8:	81 30       	cpi	r24, 0x01	; 1
    30aa:	91 05       	cpc	r25, r1
    30ac:	91 f4       	brne	.+36     	; 0x30d2 <_Z41__static_initialization_and_destruction_0ii+0x44>
    30ae:	8b 81       	ldd	r24, Y+3	; 0x03
    30b0:	9c 81       	ldd	r25, Y+4	; 0x04
    30b2:	8f 3f       	cpi	r24, 0xFF	; 255
    30b4:	2f ef       	ldi	r18, 0xFF	; 255
    30b6:	92 07       	cpc	r25, r18
    30b8:	61 f4       	brne	.+24     	; 0x30d2 <_Z41__static_initialization_and_destruction_0ii+0x44>
    30ba:	00 e0       	ldi	r16, 0x00	; 0
    30bc:	20 e0       	ldi	r18, 0x00	; 0
    30be:	40 e0       	ldi	r20, 0x00	; 0
    30c0:	60 e0       	ldi	r22, 0x00	; 0
    30c2:	84 e1       	ldi	r24, 0x14	; 20
    30c4:	97 e0       	ldi	r25, 0x07	; 7
    30c6:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    30ca:	83 e1       	ldi	r24, 0x13	; 19
    30cc:	97 e0       	ldi	r25, 0x07	; 7
    30ce:	0e 94 96 15 	call	0x2b2c	; 0x2b2c <_ZN9WiFiClassC1Ev>
    30d2:	0f 90       	pop	r0
    30d4:	0f 90       	pop	r0
    30d6:	0f 90       	pop	r0
    30d8:	0f 90       	pop	r0
    30da:	df 91       	pop	r29
    30dc:	cf 91       	pop	r28
    30de:	0f 91       	pop	r16
    30e0:	08 95       	ret

000030e2 <_GLOBAL__sub_I__ZN9WiFiClass6_stateE>:
    30e2:	cf 93       	push	r28
    30e4:	df 93       	push	r29
    30e6:	cd b7       	in	r28, 0x3d	; 61
    30e8:	de b7       	in	r29, 0x3e	; 62
    30ea:	6f ef       	ldi	r22, 0xFF	; 255
    30ec:	7f ef       	ldi	r23, 0xFF	; 255
    30ee:	81 e0       	ldi	r24, 0x01	; 1
    30f0:	90 e0       	ldi	r25, 0x00	; 0
    30f2:	0e 94 47 18 	call	0x308e	; 0x308e <_Z41__static_initialization_and_destruction_0ii>
    30f6:	df 91       	pop	r29
    30f8:	cf 91       	pop	r28
    30fa:	08 95       	ret

000030fc <_ZN10WiFiClientC1Ev>:
#endif


uint16_t WiFiClient::_srcport = 1024;

WiFiClient::WiFiClient() : _sock(MAX_SOCK_NUM) {
    30fc:	cf 93       	push	r28
    30fe:	df 93       	push	r29
    3100:	00 d0       	rcall	.+0      	; 0x3102 <_ZN10WiFiClientC1Ev+0x6>
    3102:	cd b7       	in	r28, 0x3d	; 61
    3104:	de b7       	in	r29, 0x3e	; 62
    3106:	9a 83       	std	Y+2, r25	; 0x02
    3108:	89 83       	std	Y+1, r24	; 0x01
    310a:	89 81       	ldd	r24, Y+1	; 0x01
    310c:	9a 81       	ldd	r25, Y+2	; 0x02
    310e:	0e 94 d1 a5 	call	0x14ba2	; 0x14ba2 <_ZN6ClientC1Ev>
    3112:	89 81       	ldd	r24, Y+1	; 0x01
    3114:	9a 81       	ldd	r25, Y+2	; 0x02
    3116:	2b ee       	ldi	r18, 0xEB	; 235
    3118:	34 e0       	ldi	r19, 0x04	; 4
    311a:	fc 01       	movw	r30, r24
    311c:	31 83       	std	Z+1, r19	; 0x01
    311e:	20 83       	st	Z, r18
    3120:	89 81       	ldd	r24, Y+1	; 0x01
    3122:	9a 81       	ldd	r25, Y+2	; 0x02
    3124:	24 e0       	ldi	r18, 0x04	; 4
    3126:	fc 01       	movw	r30, r24
    3128:	24 87       	std	Z+12, r18	; 0x0c
}
    312a:	0f 90       	pop	r0
    312c:	0f 90       	pop	r0
    312e:	df 91       	pop	r29
    3130:	cf 91       	pop	r28
    3132:	08 95       	ret

00003134 <_ZN10WiFiClientC1Eh>:

WiFiClient::WiFiClient(uint8_t sock) : _sock(sock) {
    3134:	cf 93       	push	r28
    3136:	df 93       	push	r29
    3138:	00 d0       	rcall	.+0      	; 0x313a <_ZN10WiFiClientC1Eh+0x6>
    313a:	1f 92       	push	r1
    313c:	cd b7       	in	r28, 0x3d	; 61
    313e:	de b7       	in	r29, 0x3e	; 62
    3140:	9a 83       	std	Y+2, r25	; 0x02
    3142:	89 83       	std	Y+1, r24	; 0x01
    3144:	6b 83       	std	Y+3, r22	; 0x03
    3146:	89 81       	ldd	r24, Y+1	; 0x01
    3148:	9a 81       	ldd	r25, Y+2	; 0x02
    314a:	0e 94 d1 a5 	call	0x14ba2	; 0x14ba2 <_ZN6ClientC1Ev>
    314e:	89 81       	ldd	r24, Y+1	; 0x01
    3150:	9a 81       	ldd	r25, Y+2	; 0x02
    3152:	2b ee       	ldi	r18, 0xEB	; 235
    3154:	34 e0       	ldi	r19, 0x04	; 4
    3156:	fc 01       	movw	r30, r24
    3158:	31 83       	std	Z+1, r19	; 0x01
    315a:	20 83       	st	Z, r18
    315c:	89 81       	ldd	r24, Y+1	; 0x01
    315e:	9a 81       	ldd	r25, Y+2	; 0x02
    3160:	2b 81       	ldd	r18, Y+3	; 0x03
    3162:	fc 01       	movw	r30, r24
    3164:	24 87       	std	Z+12, r18	; 0x0c
}
    3166:	0f 90       	pop	r0
    3168:	0f 90       	pop	r0
    316a:	0f 90       	pop	r0
    316c:	df 91       	pop	r29
    316e:	cf 91       	pop	r28
    3170:	08 95       	ret

00003172 <_ZN10WiFiClient7connectEPKcj>:

int WiFiClient::connect(const char* host, uint16_t port) {
    3172:	0f 93       	push	r16
    3174:	1f 93       	push	r17
    3176:	cf 93       	push	r28
    3178:	df 93       	push	r29
    317a:	cd b7       	in	r28, 0x3d	; 61
    317c:	de b7       	in	r29, 0x3e	; 62
    317e:	62 97       	sbiw	r28, 0x12	; 18
    3180:	0f b6       	in	r0, 0x3f	; 63
    3182:	f8 94       	cli
    3184:	de bf       	out	0x3e, r29	; 62
    3186:	0f be       	out	0x3f, r0	; 63
    3188:	cd bf       	out	0x3d, r28	; 61
    318a:	9e 87       	std	Y+14, r25	; 0x0e
    318c:	8d 87       	std	Y+13, r24	; 0x0d
    318e:	78 8b       	std	Y+16, r23	; 0x10
    3190:	6f 87       	std	Y+15, r22	; 0x0f
    3192:	5a 8b       	std	Y+18, r21	; 0x12
    3194:	49 8b       	std	Y+17, r20	; 0x11
	IPAddress remote_addr;
    3196:	ce 01       	movw	r24, r28
    3198:	07 96       	adiw	r24, 0x07	; 7
    319a:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>
	if (WiFi.hostByName(host, remote_addr))
    319e:	9e 01       	movw	r18, r28
    31a0:	29 5f       	subi	r18, 0xF9	; 249
    31a2:	3f 4f       	sbci	r19, 0xFF	; 255
    31a4:	8f 85       	ldd	r24, Y+15	; 0x0f
    31a6:	98 89       	ldd	r25, Y+16	; 0x10
    31a8:	a9 01       	movw	r20, r18
    31aa:	bc 01       	movw	r22, r24
    31ac:	83 e1       	ldi	r24, 0x13	; 19
    31ae:	97 e0       	ldi	r25, 0x07	; 7
    31b0:	0e 94 2a 18 	call	0x3054	; 0x3054 <_ZN9WiFiClass10hostByNameEPKcR9IPAddress>
    31b4:	21 e0       	ldi	r18, 0x01	; 1
    31b6:	00 97       	sbiw	r24, 0x00	; 0
    31b8:	09 f4       	brne	.+2      	; 0x31bc <_ZN10WiFiClient7connectEPKcj+0x4a>
    31ba:	20 e0       	ldi	r18, 0x00	; 0
    31bc:	22 23       	and	r18, r18
    31be:	e1 f0       	breq	.+56     	; 0x31f8 <_ZN10WiFiClient7connectEPKcj+0x86>
	{
		return connect(remote_addr, port);
    31c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    31c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    31c4:	fc 01       	movw	r30, r24
    31c6:	80 81       	ld	r24, Z
    31c8:	91 81       	ldd	r25, Z+1	; 0x01
    31ca:	0c 96       	adiw	r24, 0x0c	; 12
    31cc:	fc 01       	movw	r30, r24
    31ce:	00 81       	ld	r16, Z
    31d0:	11 81       	ldd	r17, Z+1	; 0x01
    31d2:	ce 01       	movw	r24, r28
    31d4:	07 96       	adiw	r24, 0x07	; 7
    31d6:	bc 01       	movw	r22, r24
    31d8:	ce 01       	movw	r24, r28
    31da:	01 96       	adiw	r24, 0x01	; 1
    31dc:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    31e0:	29 89       	ldd	r18, Y+17	; 0x11
    31e2:	3a 89       	ldd	r19, Y+18	; 0x12
    31e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    31e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    31e8:	a9 01       	movw	r20, r18
    31ea:	9e 01       	movw	r18, r28
    31ec:	2f 5f       	subi	r18, 0xFF	; 255
    31ee:	3f 4f       	sbci	r19, 0xFF	; 255
    31f0:	b9 01       	movw	r22, r18
    31f2:	f8 01       	movw	r30, r16
    31f4:	09 95       	icall
    31f6:	02 c0       	rjmp	.+4      	; 0x31fc <_ZN10WiFiClient7connectEPKcj+0x8a>
	}
	return 0;
    31f8:	80 e0       	ldi	r24, 0x00	; 0
    31fa:	90 e0       	ldi	r25, 0x00	; 0
}
    31fc:	62 96       	adiw	r28, 0x12	; 18
    31fe:	0f b6       	in	r0, 0x3f	; 63
    3200:	f8 94       	cli
    3202:	de bf       	out	0x3e, r29	; 62
    3204:	0f be       	out	0x3f, r0	; 63
    3206:	cd bf       	out	0x3d, r28	; 61
    3208:	df 91       	pop	r29
    320a:	cf 91       	pop	r28
    320c:	1f 91       	pop	r17
    320e:	0f 91       	pop	r16
    3210:	08 95       	ret

00003212 <_ZN10WiFiClient7connectE9IPAddressj>:

int WiFiClient::connect(IPAddress ip, uint16_t port) {
    3212:	ef 92       	push	r14
    3214:	ff 92       	push	r15
    3216:	0f 93       	push	r16
    3218:	1f 93       	push	r17
    321a:	cf 93       	push	r28
    321c:	df 93       	push	r29
    321e:	cd b7       	in	r28, 0x3d	; 61
    3220:	de b7       	in	r29, 0x3e	; 62
    3222:	2a 97       	sbiw	r28, 0x0a	; 10
    3224:	0f b6       	in	r0, 0x3f	; 63
    3226:	f8 94       	cli
    3228:	de bf       	out	0x3e, r29	; 62
    322a:	0f be       	out	0x3f, r0	; 63
    322c:	cd bf       	out	0x3d, r28	; 61
    322e:	9e 83       	std	Y+6, r25	; 0x06
    3230:	8d 83       	std	Y+5, r24	; 0x05
    3232:	78 87       	std	Y+8, r23	; 0x08
    3234:	6f 83       	std	Y+7, r22	; 0x07
    3236:	5a 87       	std	Y+10, r21	; 0x0a
    3238:	49 87       	std	Y+9, r20	; 0x09
    _sock = getFirstSocket();
    323a:	8d 81       	ldd	r24, Y+5	; 0x05
    323c:	9e 81       	ldd	r25, Y+6	; 0x06
    323e:	0e 94 ef 1b 	call	0x37de	; 0x37de <_ZN10WiFiClient14getFirstSocketEv>
    3242:	28 2f       	mov	r18, r24
    3244:	8d 81       	ldd	r24, Y+5	; 0x05
    3246:	9e 81       	ldd	r25, Y+6	; 0x06
    3248:	fc 01       	movw	r30, r24
    324a:	24 87       	std	Z+12, r18	; 0x0c
    if (_sock != NO_SOCKET_AVAIL)
    324c:	8d 81       	ldd	r24, Y+5	; 0x05
    324e:	9e 81       	ldd	r25, Y+6	; 0x06
    3250:	fc 01       	movw	r30, r24
    3252:	84 85       	ldd	r24, Z+12	; 0x0c
    3254:	8f 3f       	cpi	r24, 0xFF	; 255
    3256:	09 f4       	brne	.+2      	; 0x325a <_ZN10WiFiClient7connectE9IPAddressj+0x48>
    3258:	74 c0       	rjmp	.+232    	; 0x3342 <_ZN10WiFiClient7connectE9IPAddressj+0x130>
    {
    	ServerDrv::startClient(uint32_t(ip), port, _sock);
    325a:	8d 81       	ldd	r24, Y+5	; 0x05
    325c:	9e 81       	ldd	r25, Y+6	; 0x06
    325e:	fc 01       	movw	r30, r24
    3260:	14 85       	ldd	r17, Z+12	; 0x0c
    3262:	8f 81       	ldd	r24, Y+7	; 0x07
    3264:	98 85       	ldd	r25, Y+8	; 0x08
    3266:	0e 94 bb a5 	call	0x14b76	; 0x14b76 <_ZN9IPAddresscvmEv>
    326a:	dc 01       	movw	r26, r24
    326c:	cb 01       	movw	r24, r22
    326e:	49 85       	ldd	r20, Y+9	; 0x09
    3270:	5a 85       	ldd	r21, Y+10	; 0x0a
    3272:	21 2f       	mov	r18, r17
    3274:	bc 01       	movw	r22, r24
    3276:	cd 01       	movw	r24, r26
    3278:	0e 94 28 08 	call	0x1050	; 0x1050 <_ZN9ServerDrv11startClientEmjh>
    	WiFiClass::_state[_sock] = _sock;
    327c:	8d 81       	ldd	r24, Y+5	; 0x05
    327e:	9e 81       	ldd	r25, Y+6	; 0x06
    3280:	fc 01       	movw	r30, r24
    3282:	84 85       	ldd	r24, Z+12	; 0x0c
    3284:	88 2f       	mov	r24, r24
    3286:	90 e0       	ldi	r25, 0x00	; 0
    3288:	2d 81       	ldd	r18, Y+5	; 0x05
    328a:	3e 81       	ldd	r19, Y+6	; 0x06
    328c:	f9 01       	movw	r30, r18
    328e:	24 85       	ldd	r18, Z+12	; 0x0c
    3290:	22 2f       	mov	r18, r18
    3292:	30 e0       	ldi	r19, 0x00	; 0
    3294:	88 0f       	add	r24, r24
    3296:	99 1f       	adc	r25, r25
    3298:	8d 5f       	subi	r24, 0xFD	; 253
    329a:	98 4f       	sbci	r25, 0xF8	; 248
    329c:	fc 01       	movw	r30, r24
    329e:	31 83       	std	Z+1, r19	; 0x01
    32a0:	20 83       	st	Z, r18

    	unsigned long start = millis();
    32a2:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    32a6:	dc 01       	movw	r26, r24
    32a8:	cb 01       	movw	r24, r22
    32aa:	89 83       	std	Y+1, r24	; 0x01
    32ac:	9a 83       	std	Y+2, r25	; 0x02
    32ae:	ab 83       	std	Y+3, r26	; 0x03
    32b0:	bc 83       	std	Y+4, r27	; 0x04

    	// wait 4 second for the connection to close
    	while (!connected() && millis() - start < 10000)
    32b2:	06 c0       	rjmp	.+12     	; 0x32c0 <_ZN10WiFiClient7connectE9IPAddressj+0xae>
    		delay(1);
    32b4:	61 e0       	ldi	r22, 0x01	; 1
    32b6:	70 e0       	ldi	r23, 0x00	; 0
    32b8:	80 e0       	ldi	r24, 0x00	; 0
    32ba:	90 e0       	ldi	r25, 0x00	; 0
    32bc:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
    	WiFiClass::_state[_sock] = _sock;

    	unsigned long start = millis();

    	// wait 4 second for the connection to close
    	while (!connected() && millis() - start < 10000)
    32c0:	8d 81       	ldd	r24, Y+5	; 0x05
    32c2:	9e 81       	ldd	r25, Y+6	; 0x06
    32c4:	fc 01       	movw	r30, r24
    32c6:	80 81       	ld	r24, Z
    32c8:	91 81       	ldd	r25, Z+1	; 0x01
    32ca:	44 96       	adiw	r24, 0x14	; 20
    32cc:	fc 01       	movw	r30, r24
    32ce:	20 81       	ld	r18, Z
    32d0:	31 81       	ldd	r19, Z+1	; 0x01
    32d2:	8d 81       	ldd	r24, Y+5	; 0x05
    32d4:	9e 81       	ldd	r25, Y+6	; 0x06
    32d6:	f9 01       	movw	r30, r18
    32d8:	09 95       	icall
    32da:	88 23       	and	r24, r24
    32dc:	c1 f4       	brne	.+48     	; 0x330e <_ZN10WiFiClient7connectE9IPAddressj+0xfc>
    32de:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    32e2:	9b 01       	movw	r18, r22
    32e4:	ac 01       	movw	r20, r24
    32e6:	89 81       	ldd	r24, Y+1	; 0x01
    32e8:	9a 81       	ldd	r25, Y+2	; 0x02
    32ea:	ab 81       	ldd	r26, Y+3	; 0x03
    32ec:	bc 81       	ldd	r27, Y+4	; 0x04
    32ee:	79 01       	movw	r14, r18
    32f0:	8a 01       	movw	r16, r20
    32f2:	e8 1a       	sub	r14, r24
    32f4:	f9 0a       	sbc	r15, r25
    32f6:	0a 0b       	sbc	r16, r26
    32f8:	1b 0b       	sbc	r17, r27
    32fa:	d8 01       	movw	r26, r16
    32fc:	c7 01       	movw	r24, r14
    32fe:	80 31       	cpi	r24, 0x10	; 16
    3300:	07 e2       	ldi	r16, 0x27	; 39
    3302:	90 07       	cpc	r25, r16
    3304:	a1 05       	cpc	r26, r1
    3306:	b1 05       	cpc	r27, r1
    3308:	10 f4       	brcc	.+4      	; 0x330e <_ZN10WiFiClient7connectE9IPAddressj+0xfc>
    330a:	81 e0       	ldi	r24, 0x01	; 1
    330c:	01 c0       	rjmp	.+2      	; 0x3310 <_ZN10WiFiClient7connectE9IPAddressj+0xfe>
    330e:	80 e0       	ldi	r24, 0x00	; 0
    3310:	88 23       	and	r24, r24
    3312:	81 f6       	brne	.-96     	; 0x32b4 <_ZN10WiFiClient7connectE9IPAddressj+0xa2>
    		delay(1);

    	if (!connected())
    3314:	8d 81       	ldd	r24, Y+5	; 0x05
    3316:	9e 81       	ldd	r25, Y+6	; 0x06
    3318:	fc 01       	movw	r30, r24
    331a:	80 81       	ld	r24, Z
    331c:	91 81       	ldd	r25, Z+1	; 0x01
    331e:	44 96       	adiw	r24, 0x14	; 20
    3320:	fc 01       	movw	r30, r24
    3322:	20 81       	ld	r18, Z
    3324:	31 81       	ldd	r19, Z+1	; 0x01
    3326:	8d 81       	ldd	r24, Y+5	; 0x05
    3328:	9e 81       	ldd	r25, Y+6	; 0x06
    332a:	f9 01       	movw	r30, r18
    332c:	09 95       	icall
    332e:	98 2f       	mov	r25, r24
    3330:	81 e0       	ldi	r24, 0x01	; 1
    3332:	99 23       	and	r25, r25
    3334:	09 f0       	breq	.+2      	; 0x3338 <_ZN10WiFiClient7connectE9IPAddressj+0x126>
    3336:	80 e0       	ldi	r24, 0x00	; 0
    3338:	88 23       	and	r24, r24
    333a:	61 f0       	breq	.+24     	; 0x3354 <_ZN10WiFiClient7connectE9IPAddressj+0x142>
       	{
    		return 0;
    333c:	80 e0       	ldi	r24, 0x00	; 0
    333e:	90 e0       	ldi	r25, 0x00	; 0
    3340:	0b c0       	rjmp	.+22     	; 0x3358 <_ZN10WiFiClient7connectE9IPAddressj+0x146>
    	}
    }else{
    	Serial.println("No Socket available");
    3342:	6d e9       	ldi	r22, 0x9D	; 157
    3344:	72 e0       	ldi	r23, 0x02	; 2
    3346:	87 ec       	ldi	r24, 0xC7	; 199
    3348:	98 e0       	ldi	r25, 0x08	; 8
    334a:	0e 94 1a 5e 	call	0xbc34	; 0xbc34 <_ZN5Print7printlnEPKc>
    	return 0;
    334e:	80 e0       	ldi	r24, 0x00	; 0
    3350:	90 e0       	ldi	r25, 0x00	; 0
    3352:	02 c0       	rjmp	.+4      	; 0x3358 <_ZN10WiFiClient7connectE9IPAddressj+0x146>
    }
    return 1;
    3354:	81 e0       	ldi	r24, 0x01	; 1
    3356:	90 e0       	ldi	r25, 0x00	; 0
}
    3358:	2a 96       	adiw	r28, 0x0a	; 10
    335a:	0f b6       	in	r0, 0x3f	; 63
    335c:	f8 94       	cli
    335e:	de bf       	out	0x3e, r29	; 62
    3360:	0f be       	out	0x3f, r0	; 63
    3362:	cd bf       	out	0x3d, r28	; 61
    3364:	df 91       	pop	r29
    3366:	cf 91       	pop	r28
    3368:	1f 91       	pop	r17
    336a:	0f 91       	pop	r16
    336c:	ff 90       	pop	r15
    336e:	ef 90       	pop	r14
    3370:	08 95       	ret

00003372 <_ZN10WiFiClient5writeEh>:

size_t WiFiClient::write(uint8_t b) {
    3372:	cf 93       	push	r28
    3374:	df 93       	push	r29
    3376:	00 d0       	rcall	.+0      	; 0x3378 <_ZN10WiFiClient5writeEh+0x6>
    3378:	1f 92       	push	r1
    337a:	cd b7       	in	r28, 0x3d	; 61
    337c:	de b7       	in	r29, 0x3e	; 62
    337e:	9a 83       	std	Y+2, r25	; 0x02
    3380:	89 83       	std	Y+1, r24	; 0x01
    3382:	6b 83       	std	Y+3, r22	; 0x03
	  return write(&b, 1);
    3384:	89 81       	ldd	r24, Y+1	; 0x01
    3386:	9a 81       	ldd	r25, Y+2	; 0x02
    3388:	fc 01       	movw	r30, r24
    338a:	80 81       	ld	r24, Z
    338c:	91 81       	ldd	r25, Z+1	; 0x01
    338e:	02 96       	adiw	r24, 0x02	; 2
    3390:	fc 01       	movw	r30, r24
    3392:	20 81       	ld	r18, Z
    3394:	31 81       	ldd	r19, Z+1	; 0x01
    3396:	be 01       	movw	r22, r28
    3398:	6d 5f       	subi	r22, 0xFD	; 253
    339a:	7f 4f       	sbci	r23, 0xFF	; 255
    339c:	89 81       	ldd	r24, Y+1	; 0x01
    339e:	9a 81       	ldd	r25, Y+2	; 0x02
    33a0:	41 e0       	ldi	r20, 0x01	; 1
    33a2:	50 e0       	ldi	r21, 0x00	; 0
    33a4:	f9 01       	movw	r30, r18
    33a6:	09 95       	icall
}
    33a8:	0f 90       	pop	r0
    33aa:	0f 90       	pop	r0
    33ac:	0f 90       	pop	r0
    33ae:	df 91       	pop	r29
    33b0:	cf 91       	pop	r28
    33b2:	08 95       	ret

000033b4 <_ZN10WiFiClient5writeEPKhj>:

size_t WiFiClient::write(const uint8_t *buf, size_t size) {
    33b4:	cf 93       	push	r28
    33b6:	df 93       	push	r29
    33b8:	00 d0       	rcall	.+0      	; 0x33ba <_ZN10WiFiClient5writeEPKhj+0x6>
    33ba:	00 d0       	rcall	.+0      	; 0x33bc <_ZN10WiFiClient5writeEPKhj+0x8>
    33bc:	00 d0       	rcall	.+0      	; 0x33be <_ZN10WiFiClient5writeEPKhj+0xa>
    33be:	cd b7       	in	r28, 0x3d	; 61
    33c0:	de b7       	in	r29, 0x3e	; 62
    33c2:	9a 83       	std	Y+2, r25	; 0x02
    33c4:	89 83       	std	Y+1, r24	; 0x01
    33c6:	7c 83       	std	Y+4, r23	; 0x04
    33c8:	6b 83       	std	Y+3, r22	; 0x03
    33ca:	5e 83       	std	Y+6, r21	; 0x06
    33cc:	4d 83       	std	Y+5, r20	; 0x05
  if (_sock >= MAX_SOCK_NUM)
    33ce:	89 81       	ldd	r24, Y+1	; 0x01
    33d0:	9a 81       	ldd	r25, Y+2	; 0x02
    33d2:	dc 01       	movw	r26, r24
    33d4:	1c 96       	adiw	r26, 0x0c	; 12
    33d6:	8c 91       	ld	r24, X
    33d8:	1c 97       	sbiw	r26, 0x0c	; 12
    33da:	84 30       	cpi	r24, 0x04	; 4
    33dc:	48 f0       	brcs	.+18     	; 0x33f0 <_ZN10WiFiClient5writeEPKhj+0x3c>
  {
	  setWriteError();
    33de:	89 81       	ldd	r24, Y+1	; 0x01
    33e0:	9a 81       	ldd	r25, Y+2	; 0x02
    33e2:	61 e0       	ldi	r22, 0x01	; 1
    33e4:	70 e0       	ldi	r23, 0x00	; 0
    33e6:	0e 94 69 a5 	call	0x14ad2	; 0x14ad2 <_ZN5Print13setWriteErrorEi>
	  return 0;
    33ea:	80 e0       	ldi	r24, 0x00	; 0
    33ec:	90 e0       	ldi	r25, 0x00	; 0
    33ee:	41 c0       	rjmp	.+130    	; 0x3472 <_ZN10WiFiClient5writeEPKhj+0xbe>
  }
  if (size==0)
    33f0:	8d 81       	ldd	r24, Y+5	; 0x05
    33f2:	9e 81       	ldd	r25, Y+6	; 0x06
    33f4:	00 97       	sbiw	r24, 0x00	; 0
    33f6:	49 f4       	brne	.+18     	; 0x340a <_ZN10WiFiClient5writeEPKhj+0x56>
  {
	  setWriteError();
    33f8:	89 81       	ldd	r24, Y+1	; 0x01
    33fa:	9a 81       	ldd	r25, Y+2	; 0x02
    33fc:	61 e0       	ldi	r22, 0x01	; 1
    33fe:	70 e0       	ldi	r23, 0x00	; 0
    3400:	0e 94 69 a5 	call	0x14ad2	; 0x14ad2 <_ZN5Print13setWriteErrorEi>
      return 0;
    3404:	80 e0       	ldi	r24, 0x00	; 0
    3406:	90 e0       	ldi	r25, 0x00	; 0
    3408:	34 c0       	rjmp	.+104    	; 0x3472 <_ZN10WiFiClient5writeEPKhj+0xbe>
  }


  if (!ServerDrv::sendData(_sock, buf, size))
    340a:	89 81       	ldd	r24, Y+1	; 0x01
    340c:	9a 81       	ldd	r25, Y+2	; 0x02
    340e:	dc 01       	movw	r26, r24
    3410:	1c 96       	adiw	r26, 0x0c	; 12
    3412:	ec 91       	ld	r30, X
    3414:	2d 81       	ldd	r18, Y+5	; 0x05
    3416:	3e 81       	ldd	r19, Y+6	; 0x06
    3418:	8b 81       	ldd	r24, Y+3	; 0x03
    341a:	9c 81       	ldd	r25, Y+4	; 0x04
    341c:	a9 01       	movw	r20, r18
    341e:	bc 01       	movw	r22, r24
    3420:	8e 2f       	mov	r24, r30
    3422:	0e 94 9f 09 	call	0x133e	; 0x133e <_ZN9ServerDrv8sendDataEhPKhj>
    3426:	98 2f       	mov	r25, r24
    3428:	81 e0       	ldi	r24, 0x01	; 1
    342a:	89 27       	eor	r24, r25
    342c:	88 23       	and	r24, r24
    342e:	49 f0       	breq	.+18     	; 0x3442 <_ZN10WiFiClient5writeEPKhj+0x8e>
  {
	  setWriteError();
    3430:	89 81       	ldd	r24, Y+1	; 0x01
    3432:	9a 81       	ldd	r25, Y+2	; 0x02
    3434:	61 e0       	ldi	r22, 0x01	; 1
    3436:	70 e0       	ldi	r23, 0x00	; 0
    3438:	0e 94 69 a5 	call	0x14ad2	; 0x14ad2 <_ZN5Print13setWriteErrorEi>
      return 0;
    343c:	80 e0       	ldi	r24, 0x00	; 0
    343e:	90 e0       	ldi	r25, 0x00	; 0
    3440:	18 c0       	rjmp	.+48     	; 0x3472 <_ZN10WiFiClient5writeEPKhj+0xbe>
  }
  if (!ServerDrv::checkDataSent(_sock))
    3442:	89 81       	ldd	r24, Y+1	; 0x01
    3444:	9a 81       	ldd	r25, Y+2	; 0x02
    3446:	fc 01       	movw	r30, r24
    3448:	84 85       	ldd	r24, Z+12	; 0x0c
    344a:	0e 94 e7 09 	call	0x13ce	; 0x13ce <_ZN9ServerDrv13checkDataSentEh>
    344e:	98 2f       	mov	r25, r24
    3450:	81 e0       	ldi	r24, 0x01	; 1
    3452:	99 23       	and	r25, r25
    3454:	09 f0       	breq	.+2      	; 0x3458 <_ZN10WiFiClient5writeEPKhj+0xa4>
    3456:	80 e0       	ldi	r24, 0x00	; 0
    3458:	88 23       	and	r24, r24
    345a:	49 f0       	breq	.+18     	; 0x346e <_ZN10WiFiClient5writeEPKhj+0xba>
  {
	  setWriteError();
    345c:	89 81       	ldd	r24, Y+1	; 0x01
    345e:	9a 81       	ldd	r25, Y+2	; 0x02
    3460:	61 e0       	ldi	r22, 0x01	; 1
    3462:	70 e0       	ldi	r23, 0x00	; 0
    3464:	0e 94 69 a5 	call	0x14ad2	; 0x14ad2 <_ZN5Print13setWriteErrorEi>
      return 0;
    3468:	80 e0       	ldi	r24, 0x00	; 0
    346a:	90 e0       	ldi	r25, 0x00	; 0
    346c:	02 c0       	rjmp	.+4      	; 0x3472 <_ZN10WiFiClient5writeEPKhj+0xbe>
  }

  return size;
    346e:	8d 81       	ldd	r24, Y+5	; 0x05
    3470:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3472:	26 96       	adiw	r28, 0x06	; 6
    3474:	0f b6       	in	r0, 0x3f	; 63
    3476:	f8 94       	cli
    3478:	de bf       	out	0x3e, r29	; 62
    347a:	0f be       	out	0x3f, r0	; 63
    347c:	cd bf       	out	0x3d, r28	; 61
    347e:	df 91       	pop	r29
    3480:	cf 91       	pop	r28
    3482:	08 95       	ret

00003484 <_ZN10WiFiClient9availableEv>:

int WiFiClient::available() {
    3484:	cf 93       	push	r28
    3486:	df 93       	push	r29
    3488:	00 d0       	rcall	.+0      	; 0x348a <_ZN10WiFiClient9availableEv+0x6>
    348a:	cd b7       	in	r28, 0x3d	; 61
    348c:	de b7       	in	r29, 0x3e	; 62
    348e:	9a 83       	std	Y+2, r25	; 0x02
    3490:	89 83       	std	Y+1, r24	; 0x01
  if (_sock != 255)
    3492:	89 81       	ldd	r24, Y+1	; 0x01
    3494:	9a 81       	ldd	r25, Y+2	; 0x02
    3496:	fc 01       	movw	r30, r24
    3498:	84 85       	ldd	r24, Z+12	; 0x0c
    349a:	8f 3f       	cpi	r24, 0xFF	; 255
    349c:	49 f0       	breq	.+18     	; 0x34b0 <_ZN10WiFiClient9availableEv+0x2c>
  {
      return ServerDrv::availData(_sock);
    349e:	89 81       	ldd	r24, Y+1	; 0x01
    34a0:	9a 81       	ldd	r25, Y+2	; 0x02
    34a2:	fc 01       	movw	r30, r24
    34a4:	84 85       	ldd	r24, Z+12	; 0x0c
    34a6:	0e 94 ee 08 	call	0x11dc	; 0x11dc <_ZN9ServerDrv9availDataEh>
    34aa:	88 2f       	mov	r24, r24
    34ac:	90 e0       	ldi	r25, 0x00	; 0
    34ae:	02 c0       	rjmp	.+4      	; 0x34b4 <_ZN10WiFiClient9availableEv+0x30>
  }
   
  return 0;
    34b0:	80 e0       	ldi	r24, 0x00	; 0
    34b2:	90 e0       	ldi	r25, 0x00	; 0
}
    34b4:	0f 90       	pop	r0
    34b6:	0f 90       	pop	r0
    34b8:	df 91       	pop	r29
    34ba:	cf 91       	pop	r28
    34bc:	08 95       	ret

000034be <_ZN10WiFiClient4readEv>:

int WiFiClient::read() {
    34be:	cf 93       	push	r28
    34c0:	df 93       	push	r29
    34c2:	00 d0       	rcall	.+0      	; 0x34c4 <_ZN10WiFiClient4readEv+0x6>
    34c4:	1f 92       	push	r1
    34c6:	cd b7       	in	r28, 0x3d	; 61
    34c8:	de b7       	in	r29, 0x3e	; 62
    34ca:	9b 83       	std	Y+3, r25	; 0x03
    34cc:	8a 83       	std	Y+2, r24	; 0x02
  uint8_t b;
  if (!available())
    34ce:	8a 81       	ldd	r24, Y+2	; 0x02
    34d0:	9b 81       	ldd	r25, Y+3	; 0x03
    34d2:	fc 01       	movw	r30, r24
    34d4:	80 81       	ld	r24, Z
    34d6:	91 81       	ldd	r25, Z+1	; 0x01
    34d8:	04 96       	adiw	r24, 0x04	; 4
    34da:	fc 01       	movw	r30, r24
    34dc:	20 81       	ld	r18, Z
    34de:	31 81       	ldd	r19, Z+1	; 0x01
    34e0:	8a 81       	ldd	r24, Y+2	; 0x02
    34e2:	9b 81       	ldd	r25, Y+3	; 0x03
    34e4:	f9 01       	movw	r30, r18
    34e6:	09 95       	icall
    34e8:	21 e0       	ldi	r18, 0x01	; 1
    34ea:	00 97       	sbiw	r24, 0x00	; 0
    34ec:	09 f0       	breq	.+2      	; 0x34f0 <_ZN10WiFiClient4readEv+0x32>
    34ee:	20 e0       	ldi	r18, 0x00	; 0
    34f0:	22 23       	and	r18, r18
    34f2:	19 f0       	breq	.+6      	; 0x34fa <_ZN10WiFiClient4readEv+0x3c>
    return -1;
    34f4:	8f ef       	ldi	r24, 0xFF	; 255
    34f6:	9f ef       	ldi	r25, 0xFF	; 255
    34f8:	0e c0       	rjmp	.+28     	; 0x3516 <_ZN10WiFiClient4readEv+0x58>

  ServerDrv::getData(_sock, &b);
    34fa:	8a 81       	ldd	r24, Y+2	; 0x02
    34fc:	9b 81       	ldd	r25, Y+3	; 0x03
    34fe:	fc 01       	movw	r30, r24
    3500:	24 85       	ldd	r18, Z+12	; 0x0c
    3502:	40 e0       	ldi	r20, 0x00	; 0
    3504:	ce 01       	movw	r24, r28
    3506:	01 96       	adiw	r24, 0x01	; 1
    3508:	bc 01       	movw	r22, r24
    350a:	82 2f       	mov	r24, r18
    350c:	0e 94 23 09 	call	0x1246	; 0x1246 <_ZN9ServerDrv7getDataEhPhh>
  return b;
    3510:	89 81       	ldd	r24, Y+1	; 0x01
    3512:	88 2f       	mov	r24, r24
    3514:	90 e0       	ldi	r25, 0x00	; 0
}
    3516:	0f 90       	pop	r0
    3518:	0f 90       	pop	r0
    351a:	0f 90       	pop	r0
    351c:	df 91       	pop	r29
    351e:	cf 91       	pop	r28
    3520:	08 95       	ret

00003522 <_ZN10WiFiClient4readEPhj>:


int WiFiClient::read(uint8_t* buf, size_t size) {
    3522:	cf 93       	push	r28
    3524:	df 93       	push	r29
    3526:	00 d0       	rcall	.+0      	; 0x3528 <_ZN10WiFiClient4readEPhj+0x6>
    3528:	00 d0       	rcall	.+0      	; 0x352a <_ZN10WiFiClient4readEPhj+0x8>
    352a:	00 d0       	rcall	.+0      	; 0x352c <_ZN10WiFiClient4readEPhj+0xa>
    352c:	cd b7       	in	r28, 0x3d	; 61
    352e:	de b7       	in	r29, 0x3e	; 62
    3530:	9a 83       	std	Y+2, r25	; 0x02
    3532:	89 83       	std	Y+1, r24	; 0x01
    3534:	7c 83       	std	Y+4, r23	; 0x04
    3536:	6b 83       	std	Y+3, r22	; 0x03
    3538:	5e 83       	std	Y+6, r21	; 0x06
    353a:	4d 83       	std	Y+5, r20	; 0x05
  if (!ServerDrv::getDataBuf(_sock, buf, &size))
    353c:	89 81       	ldd	r24, Y+1	; 0x01
    353e:	9a 81       	ldd	r25, Y+2	; 0x02
    3540:	dc 01       	movw	r26, r24
    3542:	1c 96       	adiw	r26, 0x0c	; 12
    3544:	ec 91       	ld	r30, X
    3546:	9e 01       	movw	r18, r28
    3548:	2b 5f       	subi	r18, 0xFB	; 251
    354a:	3f 4f       	sbci	r19, 0xFF	; 255
    354c:	8b 81       	ldd	r24, Y+3	; 0x03
    354e:	9c 81       	ldd	r25, Y+4	; 0x04
    3550:	a9 01       	movw	r20, r18
    3552:	bc 01       	movw	r22, r24
    3554:	8e 2f       	mov	r24, r30
    3556:	0e 94 65 09 	call	0x12ca	; 0x12ca <_ZN9ServerDrv10getDataBufEhPhPj>
    355a:	98 2f       	mov	r25, r24
    355c:	81 e0       	ldi	r24, 0x01	; 1
    355e:	89 27       	eor	r24, r25
    3560:	88 23       	and	r24, r24
    3562:	19 f0       	breq	.+6      	; 0x356a <_ZN10WiFiClient4readEPhj+0x48>
      return -1;
    3564:	8f ef       	ldi	r24, 0xFF	; 255
    3566:	9f ef       	ldi	r25, 0xFF	; 255
    3568:	02 c0       	rjmp	.+4      	; 0x356e <_ZN10WiFiClient4readEPhj+0x4c>
  return 0;
    356a:	80 e0       	ldi	r24, 0x00	; 0
    356c:	90 e0       	ldi	r25, 0x00	; 0
}
    356e:	26 96       	adiw	r28, 0x06	; 6
    3570:	0f b6       	in	r0, 0x3f	; 63
    3572:	f8 94       	cli
    3574:	de bf       	out	0x3e, r29	; 62
    3576:	0f be       	out	0x3f, r0	; 63
    3578:	cd bf       	out	0x3d, r28	; 61
    357a:	df 91       	pop	r29
    357c:	cf 91       	pop	r28
    357e:	08 95       	ret

00003580 <_ZN10WiFiClient4peekEv>:

int WiFiClient::peek() {
    3580:	cf 93       	push	r28
    3582:	df 93       	push	r29
    3584:	00 d0       	rcall	.+0      	; 0x3586 <_ZN10WiFiClient4peekEv+0x6>
    3586:	1f 92       	push	r1
    3588:	cd b7       	in	r28, 0x3d	; 61
    358a:	de b7       	in	r29, 0x3e	; 62
    358c:	9b 83       	std	Y+3, r25	; 0x03
    358e:	8a 83       	std	Y+2, r24	; 0x02
	  uint8_t b;
	  if (!available())
    3590:	8a 81       	ldd	r24, Y+2	; 0x02
    3592:	9b 81       	ldd	r25, Y+3	; 0x03
    3594:	fc 01       	movw	r30, r24
    3596:	80 81       	ld	r24, Z
    3598:	91 81       	ldd	r25, Z+1	; 0x01
    359a:	04 96       	adiw	r24, 0x04	; 4
    359c:	fc 01       	movw	r30, r24
    359e:	20 81       	ld	r18, Z
    35a0:	31 81       	ldd	r19, Z+1	; 0x01
    35a2:	8a 81       	ldd	r24, Y+2	; 0x02
    35a4:	9b 81       	ldd	r25, Y+3	; 0x03
    35a6:	f9 01       	movw	r30, r18
    35a8:	09 95       	icall
    35aa:	21 e0       	ldi	r18, 0x01	; 1
    35ac:	00 97       	sbiw	r24, 0x00	; 0
    35ae:	09 f0       	breq	.+2      	; 0x35b2 <_ZN10WiFiClient4peekEv+0x32>
    35b0:	20 e0       	ldi	r18, 0x00	; 0
    35b2:	22 23       	and	r18, r18
    35b4:	19 f0       	breq	.+6      	; 0x35bc <_ZN10WiFiClient4peekEv+0x3c>
	    return -1;
    35b6:	8f ef       	ldi	r24, 0xFF	; 255
    35b8:	9f ef       	ldi	r25, 0xFF	; 255
    35ba:	0e c0       	rjmp	.+28     	; 0x35d8 <_ZN10WiFiClient4peekEv+0x58>

	  ServerDrv::getData(_sock, &b, 1);
    35bc:	8a 81       	ldd	r24, Y+2	; 0x02
    35be:	9b 81       	ldd	r25, Y+3	; 0x03
    35c0:	fc 01       	movw	r30, r24
    35c2:	24 85       	ldd	r18, Z+12	; 0x0c
    35c4:	41 e0       	ldi	r20, 0x01	; 1
    35c6:	ce 01       	movw	r24, r28
    35c8:	01 96       	adiw	r24, 0x01	; 1
    35ca:	bc 01       	movw	r22, r24
    35cc:	82 2f       	mov	r24, r18
    35ce:	0e 94 23 09 	call	0x1246	; 0x1246 <_ZN9ServerDrv7getDataEhPhh>
	  return b;
    35d2:	89 81       	ldd	r24, Y+1	; 0x01
    35d4:	88 2f       	mov	r24, r24
    35d6:	90 e0       	ldi	r25, 0x00	; 0
}
    35d8:	0f 90       	pop	r0
    35da:	0f 90       	pop	r0
    35dc:	0f 90       	pop	r0
    35de:	df 91       	pop	r29
    35e0:	cf 91       	pop	r28
    35e2:	08 95       	ret

000035e4 <_ZN10WiFiClient5flushEv>:

void WiFiClient::flush() {
    35e4:	cf 93       	push	r28
    35e6:	df 93       	push	r29
    35e8:	00 d0       	rcall	.+0      	; 0x35ea <_ZN10WiFiClient5flushEv+0x6>
    35ea:	cd b7       	in	r28, 0x3d	; 61
    35ec:	de b7       	in	r29, 0x3e	; 62
    35ee:	9a 83       	std	Y+2, r25	; 0x02
    35f0:	89 83       	std	Y+1, r24	; 0x01
  while (available())
    35f2:	0d c0       	rjmp	.+26     	; 0x360e <_ZN10WiFiClient5flushEv+0x2a>
    read();
    35f4:	89 81       	ldd	r24, Y+1	; 0x01
    35f6:	9a 81       	ldd	r25, Y+2	; 0x02
    35f8:	fc 01       	movw	r30, r24
    35fa:	80 81       	ld	r24, Z
    35fc:	91 81       	ldd	r25, Z+1	; 0x01
    35fe:	06 96       	adiw	r24, 0x06	; 6
    3600:	fc 01       	movw	r30, r24
    3602:	20 81       	ld	r18, Z
    3604:	31 81       	ldd	r19, Z+1	; 0x01
    3606:	89 81       	ldd	r24, Y+1	; 0x01
    3608:	9a 81       	ldd	r25, Y+2	; 0x02
    360a:	f9 01       	movw	r30, r18
    360c:	09 95       	icall
	  ServerDrv::getData(_sock, &b, 1);
	  return b;
}

void WiFiClient::flush() {
  while (available())
    360e:	89 81       	ldd	r24, Y+1	; 0x01
    3610:	9a 81       	ldd	r25, Y+2	; 0x02
    3612:	fc 01       	movw	r30, r24
    3614:	80 81       	ld	r24, Z
    3616:	91 81       	ldd	r25, Z+1	; 0x01
    3618:	04 96       	adiw	r24, 0x04	; 4
    361a:	fc 01       	movw	r30, r24
    361c:	20 81       	ld	r18, Z
    361e:	31 81       	ldd	r19, Z+1	; 0x01
    3620:	89 81       	ldd	r24, Y+1	; 0x01
    3622:	9a 81       	ldd	r25, Y+2	; 0x02
    3624:	f9 01       	movw	r30, r18
    3626:	09 95       	icall
    3628:	21 e0       	ldi	r18, 0x01	; 1
    362a:	00 97       	sbiw	r24, 0x00	; 0
    362c:	09 f4       	brne	.+2      	; 0x3630 <_ZN10WiFiClient5flushEv+0x4c>
    362e:	20 e0       	ldi	r18, 0x00	; 0
    3630:	22 23       	and	r18, r18
    3632:	01 f7       	brne	.-64     	; 0x35f4 <_ZN10WiFiClient5flushEv+0x10>
    read();
}
    3634:	0f 90       	pop	r0
    3636:	0f 90       	pop	r0
    3638:	df 91       	pop	r29
    363a:	cf 91       	pop	r28
    363c:	08 95       	ret

0000363e <_ZN10WiFiClient4stopEv>:

void WiFiClient::stop() {
    363e:	ef 92       	push	r14
    3640:	ff 92       	push	r15
    3642:	0f 93       	push	r16
    3644:	1f 93       	push	r17
    3646:	cf 93       	push	r28
    3648:	df 93       	push	r29
    364a:	00 d0       	rcall	.+0      	; 0x364c <_ZN10WiFiClient4stopEv+0xe>
    364c:	00 d0       	rcall	.+0      	; 0x364e <_ZN10WiFiClient4stopEv+0x10>
    364e:	00 d0       	rcall	.+0      	; 0x3650 <_ZN10WiFiClient4stopEv+0x12>
    3650:	cd b7       	in	r28, 0x3d	; 61
    3652:	de b7       	in	r29, 0x3e	; 62
    3654:	9e 83       	std	Y+6, r25	; 0x06
    3656:	8d 83       	std	Y+5, r24	; 0x05

  if (_sock == 255)
    3658:	8d 81       	ldd	r24, Y+5	; 0x05
    365a:	9e 81       	ldd	r25, Y+6	; 0x06
    365c:	fc 01       	movw	r30, r24
    365e:	84 85       	ldd	r24, Z+12	; 0x0c
    3660:	8f 3f       	cpi	r24, 0xFF	; 255
    3662:	e1 f1       	breq	.+120    	; 0x36dc <_ZN10WiFiClient4stopEv+0x9e>
    return;

  ServerDrv::stopClient(_sock);
    3664:	8d 81       	ldd	r24, Y+5	; 0x05
    3666:	9e 81       	ldd	r25, Y+6	; 0x06
    3668:	fc 01       	movw	r30, r24
    366a:	84 85       	ldd	r24, Z+12	; 0x0c
    366c:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <_ZN9ServerDrv10stopClientEh>

  unsigned long start = millis();
    3670:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    3674:	dc 01       	movw	r26, r24
    3676:	cb 01       	movw	r24, r22
    3678:	89 83       	std	Y+1, r24	; 0x01
    367a:	9a 83       	std	Y+2, r25	; 0x02
    367c:	ab 83       	std	Y+3, r26	; 0x03
    367e:	bc 83       	std	Y+4, r27	; 0x04
  

  // wait a second for the connection to close
  while (status() != CLOSED && millis() - start < 1000)
    3680:	06 c0       	rjmp	.+12     	; 0x368e <_ZN10WiFiClient4stopEv+0x50>
    delay(1);
    3682:	61 e0       	ldi	r22, 0x01	; 1
    3684:	70 e0       	ldi	r23, 0x00	; 0
    3686:	80 e0       	ldi	r24, 0x00	; 0
    3688:	90 e0       	ldi	r25, 0x00	; 0
    368a:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>

  unsigned long start = millis();
  

  // wait a second for the connection to close
  while (status() != CLOSED && millis() - start < 1000)
    368e:	8d 81       	ldd	r24, Y+5	; 0x05
    3690:	9e 81       	ldd	r25, Y+6	; 0x06
    3692:	0e 94 c1 1b 	call	0x3782	; 0x3782 <_ZN10WiFiClient6statusEv>
    3696:	88 23       	and	r24, r24
    3698:	c1 f0       	breq	.+48     	; 0x36ca <_ZN10WiFiClient4stopEv+0x8c>
    369a:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    369e:	9b 01       	movw	r18, r22
    36a0:	ac 01       	movw	r20, r24
    36a2:	89 81       	ldd	r24, Y+1	; 0x01
    36a4:	9a 81       	ldd	r25, Y+2	; 0x02
    36a6:	ab 81       	ldd	r26, Y+3	; 0x03
    36a8:	bc 81       	ldd	r27, Y+4	; 0x04
    36aa:	79 01       	movw	r14, r18
    36ac:	8a 01       	movw	r16, r20
    36ae:	e8 1a       	sub	r14, r24
    36b0:	f9 0a       	sbc	r15, r25
    36b2:	0a 0b       	sbc	r16, r26
    36b4:	1b 0b       	sbc	r17, r27
    36b6:	d8 01       	movw	r26, r16
    36b8:	c7 01       	movw	r24, r14
    36ba:	88 3e       	cpi	r24, 0xE8	; 232
    36bc:	03 e0       	ldi	r16, 0x03	; 3
    36be:	90 07       	cpc	r25, r16
    36c0:	a1 05       	cpc	r26, r1
    36c2:	b1 05       	cpc	r27, r1
    36c4:	10 f4       	brcc	.+4      	; 0x36ca <_ZN10WiFiClient4stopEv+0x8c>
    36c6:	81 e0       	ldi	r24, 0x01	; 1
    36c8:	01 c0       	rjmp	.+2      	; 0x36cc <_ZN10WiFiClient4stopEv+0x8e>
    36ca:	80 e0       	ldi	r24, 0x00	; 0
    36cc:	88 23       	and	r24, r24
    36ce:	c9 f6       	brne	.-78     	; 0x3682 <_ZN10WiFiClient4stopEv+0x44>
    delay(1);
  _sock = 255;
    36d0:	8d 81       	ldd	r24, Y+5	; 0x05
    36d2:	9e 81       	ldd	r25, Y+6	; 0x06
    36d4:	2f ef       	ldi	r18, 0xFF	; 255
    36d6:	fc 01       	movw	r30, r24
    36d8:	24 87       	std	Z+12, r18	; 0x0c
    36da:	01 c0       	rjmp	.+2      	; 0x36de <_ZN10WiFiClient4stopEv+0xa0>
}

void WiFiClient::stop() {

  if (_sock == 255)
    return;
    36dc:	00 00       	nop

  // wait a second for the connection to close
  while (status() != CLOSED && millis() - start < 1000)
    delay(1);
  _sock = 255;
}
    36de:	26 96       	adiw	r28, 0x06	; 6
    36e0:	0f b6       	in	r0, 0x3f	; 63
    36e2:	f8 94       	cli
    36e4:	de bf       	out	0x3e, r29	; 62
    36e6:	0f be       	out	0x3f, r0	; 63
    36e8:	cd bf       	out	0x3d, r28	; 61
    36ea:	df 91       	pop	r29
    36ec:	cf 91       	pop	r28
    36ee:	1f 91       	pop	r17
    36f0:	0f 91       	pop	r16
    36f2:	ff 90       	pop	r15
    36f4:	ef 90       	pop	r14
    36f6:	08 95       	ret

000036f8 <_ZN10WiFiClient9connectedEv>:

uint8_t WiFiClient::connected() {
    36f8:	cf 93       	push	r28
    36fa:	df 93       	push	r29
    36fc:	00 d0       	rcall	.+0      	; 0x36fe <_ZN10WiFiClient9connectedEv+0x6>
    36fe:	1f 92       	push	r1
    3700:	cd b7       	in	r28, 0x3d	; 61
    3702:	de b7       	in	r29, 0x3e	; 62
    3704:	9b 83       	std	Y+3, r25	; 0x03
    3706:	8a 83       	std	Y+2, r24	; 0x02

  if (_sock == 255) {
    3708:	8a 81       	ldd	r24, Y+2	; 0x02
    370a:	9b 81       	ldd	r25, Y+3	; 0x03
    370c:	fc 01       	movw	r30, r24
    370e:	84 85       	ldd	r24, Z+12	; 0x0c
    3710:	8f 3f       	cpi	r24, 0xFF	; 255
    3712:	11 f4       	brne	.+4      	; 0x3718 <_ZN10WiFiClient9connectedEv+0x20>
    return 0;
    3714:	80 e0       	ldi	r24, 0x00	; 0
    3716:	2f c0       	rjmp	.+94     	; 0x3776 <_ZN10WiFiClient9connectedEv+0x7e>
  } else {
    uint8_t s = status();
    3718:	8a 81       	ldd	r24, Y+2	; 0x02
    371a:	9b 81       	ldd	r25, Y+3	; 0x03
    371c:	0e 94 c1 1b 	call	0x3782	; 0x3782 <_ZN10WiFiClient6statusEv>
    3720:	89 83       	std	Y+1, r24	; 0x01

    return !(s == LISTEN || s == CLOSED || s == FIN_WAIT_1 ||
    		s == FIN_WAIT_2 || s == TIME_WAIT ||
    		s == SYN_SENT || s== SYN_RCVD ||
             (s == CLOSE_WAIT && !available()));
    3722:	89 81       	ldd	r24, Y+1	; 0x01
    3724:	81 30       	cpi	r24, 0x01	; 1
    3726:	31 f1       	breq	.+76     	; 0x3774 <_ZN10WiFiClient9connectedEv+0x7c>
    3728:	89 81       	ldd	r24, Y+1	; 0x01
    372a:	88 23       	and	r24, r24
    372c:	19 f1       	breq	.+70     	; 0x3774 <_ZN10WiFiClient9connectedEv+0x7c>
    372e:	89 81       	ldd	r24, Y+1	; 0x01
    3730:	85 30       	cpi	r24, 0x05	; 5
    3732:	01 f1       	breq	.+64     	; 0x3774 <_ZN10WiFiClient9connectedEv+0x7c>
    3734:	89 81       	ldd	r24, Y+1	; 0x01
    3736:	86 30       	cpi	r24, 0x06	; 6
    3738:	e9 f0       	breq	.+58     	; 0x3774 <_ZN10WiFiClient9connectedEv+0x7c>
    373a:	89 81       	ldd	r24, Y+1	; 0x01
    373c:	8a 30       	cpi	r24, 0x0A	; 10
    373e:	d1 f0       	breq	.+52     	; 0x3774 <_ZN10WiFiClient9connectedEv+0x7c>
    3740:	89 81       	ldd	r24, Y+1	; 0x01
    3742:	82 30       	cpi	r24, 0x02	; 2
    3744:	b9 f0       	breq	.+46     	; 0x3774 <_ZN10WiFiClient9connectedEv+0x7c>
    3746:	89 81       	ldd	r24, Y+1	; 0x01
    3748:	83 30       	cpi	r24, 0x03	; 3
    374a:	a1 f0       	breq	.+40     	; 0x3774 <_ZN10WiFiClient9connectedEv+0x7c>
    374c:	89 81       	ldd	r24, Y+1	; 0x01
    374e:	87 30       	cpi	r24, 0x07	; 7
    3750:	79 f4       	brne	.+30     	; 0x3770 <_ZN10WiFiClient9connectedEv+0x78>
    3752:	8a 81       	ldd	r24, Y+2	; 0x02
    3754:	9b 81       	ldd	r25, Y+3	; 0x03
    3756:	fc 01       	movw	r30, r24
    3758:	80 81       	ld	r24, Z
    375a:	91 81       	ldd	r25, Z+1	; 0x01
    375c:	04 96       	adiw	r24, 0x04	; 4
    375e:	fc 01       	movw	r30, r24
    3760:	20 81       	ld	r18, Z
    3762:	31 81       	ldd	r19, Z+1	; 0x01
    3764:	8a 81       	ldd	r24, Y+2	; 0x02
    3766:	9b 81       	ldd	r25, Y+3	; 0x03
    3768:	f9 01       	movw	r30, r18
    376a:	09 95       	icall
    376c:	00 97       	sbiw	r24, 0x00	; 0
    376e:	11 f0       	breq	.+4      	; 0x3774 <_ZN10WiFiClient9connectedEv+0x7c>
    3770:	81 e0       	ldi	r24, 0x01	; 1
    3772:	01 c0       	rjmp	.+2      	; 0x3776 <_ZN10WiFiClient9connectedEv+0x7e>
    3774:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    3776:	0f 90       	pop	r0
    3778:	0f 90       	pop	r0
    377a:	0f 90       	pop	r0
    377c:	df 91       	pop	r29
    377e:	cf 91       	pop	r28
    3780:	08 95       	ret

00003782 <_ZN10WiFiClient6statusEv>:

uint8_t WiFiClient::status() {
    3782:	cf 93       	push	r28
    3784:	df 93       	push	r29
    3786:	00 d0       	rcall	.+0      	; 0x3788 <_ZN10WiFiClient6statusEv+0x6>
    3788:	cd b7       	in	r28, 0x3d	; 61
    378a:	de b7       	in	r29, 0x3e	; 62
    378c:	9a 83       	std	Y+2, r25	; 0x02
    378e:	89 83       	std	Y+1, r24	; 0x01
    if (_sock == 255) {
    3790:	89 81       	ldd	r24, Y+1	; 0x01
    3792:	9a 81       	ldd	r25, Y+2	; 0x02
    3794:	fc 01       	movw	r30, r24
    3796:	84 85       	ldd	r24, Z+12	; 0x0c
    3798:	8f 3f       	cpi	r24, 0xFF	; 255
    379a:	11 f4       	brne	.+4      	; 0x37a0 <_ZN10WiFiClient6statusEv+0x1e>
    return CLOSED;
    379c:	80 e0       	ldi	r24, 0x00	; 0
    379e:	06 c0       	rjmp	.+12     	; 0x37ac <_ZN10WiFiClient6statusEv+0x2a>
  } else {
    return ServerDrv::getClientState(_sock);
    37a0:	89 81       	ldd	r24, Y+1	; 0x01
    37a2:	9a 81       	ldd	r25, Y+2	; 0x02
    37a4:	fc 01       	movw	r30, r24
    37a6:	84 85       	ldd	r24, Z+12	; 0x0c
    37a8:	0e 94 c2 08 	call	0x1184	; 0x1184 <_ZN9ServerDrv14getClientStateEh>
  }
}
    37ac:	0f 90       	pop	r0
    37ae:	0f 90       	pop	r0
    37b0:	df 91       	pop	r29
    37b2:	cf 91       	pop	r28
    37b4:	08 95       	ret

000037b6 <_ZN10WiFiClientcvbEv>:

WiFiClient::operator bool() {
    37b6:	cf 93       	push	r28
    37b8:	df 93       	push	r29
    37ba:	00 d0       	rcall	.+0      	; 0x37bc <_ZN10WiFiClientcvbEv+0x6>
    37bc:	cd b7       	in	r28, 0x3d	; 61
    37be:	de b7       	in	r29, 0x3e	; 62
    37c0:	9a 83       	std	Y+2, r25	; 0x02
    37c2:	89 83       	std	Y+1, r24	; 0x01
  return _sock != 255;
    37c4:	89 81       	ldd	r24, Y+1	; 0x01
    37c6:	9a 81       	ldd	r25, Y+2	; 0x02
    37c8:	fc 01       	movw	r30, r24
    37ca:	94 85       	ldd	r25, Z+12	; 0x0c
    37cc:	81 e0       	ldi	r24, 0x01	; 1
    37ce:	9f 3f       	cpi	r25, 0xFF	; 255
    37d0:	09 f4       	brne	.+2      	; 0x37d4 <_ZN10WiFiClientcvbEv+0x1e>
    37d2:	80 e0       	ldi	r24, 0x00	; 0
}
    37d4:	0f 90       	pop	r0
    37d6:	0f 90       	pop	r0
    37d8:	df 91       	pop	r29
    37da:	cf 91       	pop	r28
    37dc:	08 95       	ret

000037de <_ZN10WiFiClient14getFirstSocketEv>:

// Private Methods
uint8_t WiFiClient::getFirstSocket()
{
    37de:	cf 93       	push	r28
    37e0:	df 93       	push	r29
    37e2:	00 d0       	rcall	.+0      	; 0x37e4 <_ZN10WiFiClient14getFirstSocketEv+0x6>
    37e4:	00 d0       	rcall	.+0      	; 0x37e6 <_ZN10WiFiClient14getFirstSocketEv+0x8>
    37e6:	cd b7       	in	r28, 0x3d	; 61
    37e8:	de b7       	in	r29, 0x3e	; 62
    37ea:	9c 83       	std	Y+4, r25	; 0x04
    37ec:	8b 83       	std	Y+3, r24	; 0x03
    for (int i = 0; i < MAX_SOCK_NUM; i++) {
    37ee:	1a 82       	std	Y+2, r1	; 0x02
    37f0:	19 82       	std	Y+1, r1	; 0x01
    37f2:	12 c0       	rjmp	.+36     	; 0x3818 <_ZN10WiFiClient14getFirstSocketEv+0x3a>
      if (WiFiClass::_state[i] == 0)
    37f4:	89 81       	ldd	r24, Y+1	; 0x01
    37f6:	9a 81       	ldd	r25, Y+2	; 0x02
    37f8:	88 0f       	add	r24, r24
    37fa:	99 1f       	adc	r25, r25
    37fc:	8d 5f       	subi	r24, 0xFD	; 253
    37fe:	98 4f       	sbci	r25, 0xF8	; 248
    3800:	fc 01       	movw	r30, r24
    3802:	80 81       	ld	r24, Z
    3804:	91 81       	ldd	r25, Z+1	; 0x01
    3806:	00 97       	sbiw	r24, 0x00	; 0
    3808:	11 f4       	brne	.+4      	; 0x380e <_ZN10WiFiClient14getFirstSocketEv+0x30>
      {
          return i;
    380a:	89 81       	ldd	r24, Y+1	; 0x01
    380c:	0f c0       	rjmp	.+30     	; 0x382c <_ZN10WiFiClient14getFirstSocketEv+0x4e>
}

// Private Methods
uint8_t WiFiClient::getFirstSocket()
{
    for (int i = 0; i < MAX_SOCK_NUM; i++) {
    380e:	89 81       	ldd	r24, Y+1	; 0x01
    3810:	9a 81       	ldd	r25, Y+2	; 0x02
    3812:	01 96       	adiw	r24, 0x01	; 1
    3814:	9a 83       	std	Y+2, r25	; 0x02
    3816:	89 83       	std	Y+1, r24	; 0x01
    3818:	21 e0       	ldi	r18, 0x01	; 1
    381a:	89 81       	ldd	r24, Y+1	; 0x01
    381c:	9a 81       	ldd	r25, Y+2	; 0x02
    381e:	84 30       	cpi	r24, 0x04	; 4
    3820:	91 05       	cpc	r25, r1
    3822:	0c f0       	brlt	.+2      	; 0x3826 <_ZN10WiFiClient14getFirstSocketEv+0x48>
    3824:	20 e0       	ldi	r18, 0x00	; 0
    3826:	22 23       	and	r18, r18
    3828:	29 f7       	brne	.-54     	; 0x37f4 <_ZN10WiFiClient14getFirstSocketEv+0x16>
      if (WiFiClass::_state[i] == 0)
      {
          return i;
      }
    }
    return SOCK_NOT_AVAIL;
    382a:	8f ef       	ldi	r24, 0xFF	; 255
}
    382c:	0f 90       	pop	r0
    382e:	0f 90       	pop	r0
    3830:	0f 90       	pop	r0
    3832:	0f 90       	pop	r0
    3834:	df 91       	pop	r29
    3836:	cf 91       	pop	r28
    3838:	08 95       	ret

0000383a <_Z41__static_initialization_and_destruction_0ii>:
    383a:	0f 93       	push	r16
    383c:	cf 93       	push	r28
    383e:	df 93       	push	r29
    3840:	00 d0       	rcall	.+0      	; 0x3842 <_Z41__static_initialization_and_destruction_0ii+0x8>
    3842:	00 d0       	rcall	.+0      	; 0x3844 <_Z41__static_initialization_and_destruction_0ii+0xa>
    3844:	cd b7       	in	r28, 0x3d	; 61
    3846:	de b7       	in	r29, 0x3e	; 62
    3848:	9a 83       	std	Y+2, r25	; 0x02
    384a:	89 83       	std	Y+1, r24	; 0x01
    384c:	7c 83       	std	Y+4, r23	; 0x04
    384e:	6b 83       	std	Y+3, r22	; 0x03
    3850:	89 81       	ldd	r24, Y+1	; 0x01
    3852:	9a 81       	ldd	r25, Y+2	; 0x02
    3854:	81 30       	cpi	r24, 0x01	; 1
    3856:	91 05       	cpc	r25, r1
    3858:	71 f4       	brne	.+28     	; 0x3876 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    385a:	8b 81       	ldd	r24, Y+3	; 0x03
    385c:	9c 81       	ldd	r25, Y+4	; 0x04
    385e:	8f 3f       	cpi	r24, 0xFF	; 255
    3860:	2f ef       	ldi	r18, 0xFF	; 255
    3862:	92 07       	cpc	r25, r18
    3864:	41 f4       	brne	.+16     	; 0x3876 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    3866:	00 e0       	ldi	r16, 0x00	; 0
    3868:	20 e0       	ldi	r18, 0x00	; 0
    386a:	40 e0       	ldi	r20, 0x00	; 0
    386c:	60 e0       	ldi	r22, 0x00	; 0
    386e:	8a e1       	ldi	r24, 0x1A	; 26
    3870:	97 e0       	ldi	r25, 0x07	; 7
    3872:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    3876:	0f 90       	pop	r0
    3878:	0f 90       	pop	r0
    387a:	0f 90       	pop	r0
    387c:	0f 90       	pop	r0
    387e:	df 91       	pop	r29
    3880:	cf 91       	pop	r28
    3882:	0f 91       	pop	r16
    3884:	08 95       	ret

00003886 <_GLOBAL__sub_I__ZN10WiFiClient8_srcportE>:
    3886:	cf 93       	push	r28
    3888:	df 93       	push	r29
    388a:	cd b7       	in	r28, 0x3d	; 61
    388c:	de b7       	in	r29, 0x3e	; 62
    388e:	6f ef       	ldi	r22, 0xFF	; 255
    3890:	7f ef       	ldi	r23, 0xFF	; 255
    3892:	81 e0       	ldi	r24, 0x01	; 1
    3894:	90 e0       	ldi	r25, 0x00	; 0
    3896:	0e 94 1d 1c 	call	0x383a	; 0x383a <_Z41__static_initialization_and_destruction_0ii>
    389a:	df 91       	pop	r29
    389c:	cf 91       	pop	r28
    389e:	08 95       	ret

000038a0 <_ZN10WiFiServerC1Ej>:

#include "WiFi.h"
#include "WiFiClient.h"
#include "WiFiServer.h"

WiFiServer::WiFiServer(uint16_t port)
    38a0:	cf 93       	push	r28
    38a2:	df 93       	push	r29
    38a4:	00 d0       	rcall	.+0      	; 0x38a6 <_ZN10WiFiServerC1Ej+0x6>
    38a6:	00 d0       	rcall	.+0      	; 0x38a8 <_ZN10WiFiServerC1Ej+0x8>
    38a8:	cd b7       	in	r28, 0x3d	; 61
    38aa:	de b7       	in	r29, 0x3e	; 62
    38ac:	9a 83       	std	Y+2, r25	; 0x02
    38ae:	89 83       	std	Y+1, r24	; 0x01
    38b0:	7c 83       	std	Y+4, r23	; 0x04
    38b2:	6b 83       	std	Y+3, r22	; 0x03
    38b4:	89 81       	ldd	r24, Y+1	; 0x01
    38b6:	9a 81       	ldd	r25, Y+2	; 0x02
    38b8:	0e 94 2d a6 	call	0x14c5a	; 0x14c5a <_ZN6ServerC1Ev>
    38bc:	89 81       	ldd	r24, Y+1	; 0x01
    38be:	9a 81       	ldd	r25, Y+2	; 0x02
    38c0:	29 e2       	ldi	r18, 0x29	; 41
    38c2:	35 e0       	ldi	r19, 0x05	; 5
    38c4:	fc 01       	movw	r30, r24
    38c6:	31 83       	std	Z+1, r19	; 0x01
    38c8:	20 83       	st	Z, r18
{
    _port = port;
    38ca:	89 81       	ldd	r24, Y+1	; 0x01
    38cc:	9a 81       	ldd	r25, Y+2	; 0x02
    38ce:	2b 81       	ldd	r18, Y+3	; 0x03
    38d0:	3c 81       	ldd	r19, Y+4	; 0x04
    38d2:	fc 01       	movw	r30, r24
    38d4:	35 83       	std	Z+5, r19	; 0x05
    38d6:	24 83       	std	Z+4, r18	; 0x04
}
    38d8:	0f 90       	pop	r0
    38da:	0f 90       	pop	r0
    38dc:	0f 90       	pop	r0
    38de:	0f 90       	pop	r0
    38e0:	df 91       	pop	r29
    38e2:	cf 91       	pop	r28
    38e4:	08 95       	ret

000038e6 <_ZN10WiFiServer5beginEv>:

void WiFiServer::begin()
{
    38e6:	cf 93       	push	r28
    38e8:	df 93       	push	r29
    38ea:	00 d0       	rcall	.+0      	; 0x38ec <_ZN10WiFiServer5beginEv+0x6>
    38ec:	1f 92       	push	r1
    38ee:	cd b7       	in	r28, 0x3d	; 61
    38f0:	de b7       	in	r29, 0x3e	; 62
    38f2:	9b 83       	std	Y+3, r25	; 0x03
    38f4:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t _sock = WiFiClass::getSocket();
    38f6:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <_ZN9WiFiClass9getSocketEv>
    38fa:	89 83       	std	Y+1, r24	; 0x01
    if (_sock != NO_SOCKET_AVAIL)
    38fc:	89 81       	ldd	r24, Y+1	; 0x01
    38fe:	8f 3f       	cpi	r24, 0xFF	; 255
    3900:	b9 f0       	breq	.+46     	; 0x3930 <_ZN10WiFiServer5beginEv+0x4a>
    {
        ServerDrv::startServer(_port, _sock);
    3902:	8a 81       	ldd	r24, Y+2	; 0x02
    3904:	9b 81       	ldd	r25, Y+3	; 0x03
    3906:	fc 01       	movw	r30, r24
    3908:	84 81       	ldd	r24, Z+4	; 0x04
    390a:	95 81       	ldd	r25, Z+5	; 0x05
    390c:	69 81       	ldd	r22, Y+1	; 0x01
    390e:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <_ZN9ServerDrv11startServerEjh>
        WiFiClass::_server_port[_sock] = _port;
    3912:	89 81       	ldd	r24, Y+1	; 0x01
    3914:	88 2f       	mov	r24, r24
    3916:	90 e0       	ldi	r25, 0x00	; 0
    3918:	2a 81       	ldd	r18, Y+2	; 0x02
    391a:	3b 81       	ldd	r19, Y+3	; 0x03
    391c:	f9 01       	movw	r30, r18
    391e:	24 81       	ldd	r18, Z+4	; 0x04
    3920:	35 81       	ldd	r19, Z+5	; 0x05
    3922:	88 0f       	add	r24, r24
    3924:	99 1f       	adc	r25, r25
    3926:	85 5f       	subi	r24, 0xF5	; 245
    3928:	98 4f       	sbci	r25, 0xF8	; 248
    392a:	fc 01       	movw	r30, r24
    392c:	31 83       	std	Z+1, r19	; 0x01
    392e:	20 83       	st	Z, r18
    }
}
    3930:	0f 90       	pop	r0
    3932:	0f 90       	pop	r0
    3934:	0f 90       	pop	r0
    3936:	df 91       	pop	r29
    3938:	cf 91       	pop	r28
    393a:	08 95       	ret

0000393c <_ZN10WiFiServer9availableEPh>:

WiFiClient WiFiServer::available(byte* status)
{
    393c:	cf 93       	push	r28
    393e:	df 93       	push	r29
    3940:	cd b7       	in	r28, 0x3d	; 61
    3942:	de b7       	in	r29, 0x3e	; 62
    3944:	6b 97       	sbiw	r28, 0x1b	; 27
    3946:	0f b6       	in	r0, 0x3f	; 63
    3948:	f8 94       	cli
    394a:	de bf       	out	0x3e, r29	; 62
    394c:	0f be       	out	0x3f, r0	; 63
    394e:	cd bf       	out	0x3d, r28	; 61
    3950:	9f 8b       	std	Y+23, r25	; 0x17
    3952:	8e 8b       	std	Y+22, r24	; 0x16
    3954:	79 8f       	std	Y+25, r23	; 0x19
    3956:	68 8f       	std	Y+24, r22	; 0x18
    3958:	5b 8f       	std	Y+27, r21	; 0x1b
    395a:	4a 8f       	std	Y+26, r20	; 0x1a
	static int cycle_server_down = 0;
	const int TH_SERVER_DOWN = 50;
    395c:	82 e3       	ldi	r24, 0x32	; 50
    395e:	90 e0       	ldi	r25, 0x00	; 0
    3960:	9c 83       	std	Y+4, r25	; 0x04
    3962:	8b 83       	std	Y+3, r24	; 0x03

    for (int sock = 0; sock < MAX_SOCK_NUM; sock++)
    3964:	1a 82       	std	Y+2, r1	; 0x02
    3966:	19 82       	std	Y+1, r1	; 0x01
    3968:	61 c0       	rjmp	.+194    	; 0x3a2c <_ZN10WiFiServer9availableEPh+0xf0>
    {
        if (WiFiClass::_server_port[sock] == _port)
    396a:	89 81       	ldd	r24, Y+1	; 0x01
    396c:	9a 81       	ldd	r25, Y+2	; 0x02
    396e:	88 0f       	add	r24, r24
    3970:	99 1f       	adc	r25, r25
    3972:	85 5f       	subi	r24, 0xF5	; 245
    3974:	98 4f       	sbci	r25, 0xF8	; 248
    3976:	fc 01       	movw	r30, r24
    3978:	20 81       	ld	r18, Z
    397a:	31 81       	ldd	r19, Z+1	; 0x01
    397c:	88 8d       	ldd	r24, Y+24	; 0x18
    397e:	99 8d       	ldd	r25, Y+25	; 0x19
    3980:	fc 01       	movw	r30, r24
    3982:	84 81       	ldd	r24, Z+4	; 0x04
    3984:	95 81       	ldd	r25, Z+5	; 0x05
    3986:	28 17       	cp	r18, r24
    3988:	39 07       	cpc	r19, r25
    398a:	09 f0       	breq	.+2      	; 0x398e <_ZN10WiFiServer9availableEPh+0x52>
    398c:	4a c0       	rjmp	.+148    	; 0x3a22 <_ZN10WiFiServer9availableEPh+0xe6>
        {
        	WiFiClient client(sock);
    398e:	29 81       	ldd	r18, Y+1	; 0x01
    3990:	ce 01       	movw	r24, r28
    3992:	07 96       	adiw	r24, 0x07	; 7
    3994:	62 2f       	mov	r22, r18
    3996:	0e 94 9a 18 	call	0x3134	; 0x3134 <_ZN10WiFiClientC1Eh>
            uint8_t _status = client.status();
    399a:	ce 01       	movw	r24, r28
    399c:	07 96       	adiw	r24, 0x07	; 7
    399e:	0e 94 c1 1b 	call	0x3782	; 0x3782 <_ZN10WiFiClient6statusEv>
    39a2:	8d 83       	std	Y+5, r24	; 0x05
            uint8_t _ser_status = this->status();
    39a4:	88 8d       	ldd	r24, Y+24	; 0x18
    39a6:	99 8d       	ldd	r25, Y+25	; 0x19
    39a8:	0e 94 30 1d 	call	0x3a60	; 0x3a60 <_ZN10WiFiServer6statusEv>
    39ac:	8e 83       	std	Y+6, r24	; 0x06

            if (status != NULL)
    39ae:	8a 8d       	ldd	r24, Y+26	; 0x1a
    39b0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    39b2:	00 97       	sbiw	r24, 0x00	; 0
    39b4:	29 f0       	breq	.+10     	; 0x39c0 <_ZN10WiFiServer9availableEPh+0x84>
            	*status = _status;
    39b6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    39b8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    39ba:	2d 81       	ldd	r18, Y+5	; 0x05
    39bc:	fc 01       	movw	r30, r24
    39be:	20 83       	st	Z, r18

            //server not in listen state, restart it
            if ((_ser_status == 0)&&(cycle_server_down++ > TH_SERVER_DOWN))
    39c0:	8e 81       	ldd	r24, Y+6	; 0x06
    39c2:	88 23       	and	r24, r24
    39c4:	91 f4       	brne	.+36     	; 0x39ea <_ZN10WiFiServer9availableEPh+0xae>
    39c6:	80 91 26 07 	lds	r24, 0x0726
    39ca:	90 91 27 07 	lds	r25, 0x0727
    39ce:	21 e0       	ldi	r18, 0x01	; 1
    39d0:	83 33       	cpi	r24, 0x33	; 51
    39d2:	91 05       	cpc	r25, r1
    39d4:	0c f4       	brge	.+2      	; 0x39d8 <_ZN10WiFiServer9availableEPh+0x9c>
    39d6:	20 e0       	ldi	r18, 0x00	; 0
    39d8:	01 96       	adiw	r24, 0x01	; 1
    39da:	90 93 27 07 	sts	0x0727, r25
    39de:	80 93 26 07 	sts	0x0726, r24
    39e2:	22 23       	and	r18, r18
    39e4:	11 f0       	breq	.+4      	; 0x39ea <_ZN10WiFiServer9availableEPh+0xae>
    39e6:	81 e0       	ldi	r24, 0x01	; 1
    39e8:	01 c0       	rjmp	.+2      	; 0x39ec <_ZN10WiFiServer9availableEPh+0xb0>
    39ea:	80 e0       	ldi	r24, 0x00	; 0
    39ec:	88 23       	and	r24, r24
    39ee:	69 f0       	breq	.+26     	; 0x3a0a <_ZN10WiFiServer9availableEPh+0xce>
            {
            	ServerDrv::startServer(_port, sock);
    39f0:	29 81       	ldd	r18, Y+1	; 0x01
    39f2:	88 8d       	ldd	r24, Y+24	; 0x18
    39f4:	99 8d       	ldd	r25, Y+25	; 0x19
    39f6:	fc 01       	movw	r30, r24
    39f8:	84 81       	ldd	r24, Z+4	; 0x04
    39fa:	95 81       	ldd	r25, Z+5	; 0x05
    39fc:	62 2f       	mov	r22, r18
    39fe:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <_ZN9ServerDrv11startServerEjh>
            	cycle_server_down = 0;
    3a02:	10 92 27 07 	sts	0x0727, r1
    3a06:	10 92 26 07 	sts	0x0726, r1
            }

            if (_status == ESTABLISHED)
    3a0a:	8d 81       	ldd	r24, Y+5	; 0x05
    3a0c:	84 30       	cpi	r24, 0x04	; 4
    3a0e:	49 f4       	brne	.+18     	; 0x3a22 <_ZN10WiFiServer9availableEPh+0xe6>
            {                
                return client;  //TODO 
    3a10:	9e 01       	movw	r18, r28
    3a12:	29 5f       	subi	r18, 0xF9	; 249
    3a14:	3f 4f       	sbci	r19, 0xFF	; 255
    3a16:	8e 89       	ldd	r24, Y+22	; 0x16
    3a18:	9f 89       	ldd	r25, Y+23	; 0x17
    3a1a:	b9 01       	movw	r22, r18
    3a1c:	0e 94 c0 a6 	call	0x14d80	; 0x14d80 <_ZN10WiFiClientC1ERKS_>
    3a20:	14 c0       	rjmp	.+40     	; 0x3a4a <_ZN10WiFiServer9availableEPh+0x10e>
WiFiClient WiFiServer::available(byte* status)
{
	static int cycle_server_down = 0;
	const int TH_SERVER_DOWN = 50;

    for (int sock = 0; sock < MAX_SOCK_NUM; sock++)
    3a22:	89 81       	ldd	r24, Y+1	; 0x01
    3a24:	9a 81       	ldd	r25, Y+2	; 0x02
    3a26:	01 96       	adiw	r24, 0x01	; 1
    3a28:	9a 83       	std	Y+2, r25	; 0x02
    3a2a:	89 83       	std	Y+1, r24	; 0x01
    3a2c:	21 e0       	ldi	r18, 0x01	; 1
    3a2e:	89 81       	ldd	r24, Y+1	; 0x01
    3a30:	9a 81       	ldd	r25, Y+2	; 0x02
    3a32:	84 30       	cpi	r24, 0x04	; 4
    3a34:	91 05       	cpc	r25, r1
    3a36:	0c f0       	brlt	.+2      	; 0x3a3a <_ZN10WiFiServer9availableEPh+0xfe>
    3a38:	20 e0       	ldi	r18, 0x00	; 0
    3a3a:	22 23       	and	r18, r18
    3a3c:	09 f0       	breq	.+2      	; 0x3a40 <_ZN10WiFiServer9availableEPh+0x104>
    3a3e:	95 cf       	rjmp	.-214    	; 0x396a <_ZN10WiFiServer9availableEPh+0x2e>
                return client;  //TODO 
            }
        }
    }

    return WiFiClient(255);
    3a40:	8e 89       	ldd	r24, Y+22	; 0x16
    3a42:	9f 89       	ldd	r25, Y+23	; 0x17
    3a44:	6f ef       	ldi	r22, 0xFF	; 255
    3a46:	0e 94 9a 18 	call	0x3134	; 0x3134 <_ZN10WiFiClientC1Eh>
}
    3a4a:	8e 89       	ldd	r24, Y+22	; 0x16
    3a4c:	9f 89       	ldd	r25, Y+23	; 0x17
    3a4e:	6b 96       	adiw	r28, 0x1b	; 27
    3a50:	0f b6       	in	r0, 0x3f	; 63
    3a52:	f8 94       	cli
    3a54:	de bf       	out	0x3e, r29	; 62
    3a56:	0f be       	out	0x3f, r0	; 63
    3a58:	cd bf       	out	0x3d, r28	; 61
    3a5a:	df 91       	pop	r29
    3a5c:	cf 91       	pop	r28
    3a5e:	08 95       	ret

00003a60 <_ZN10WiFiServer6statusEv>:

uint8_t WiFiServer::status() {
    3a60:	cf 93       	push	r28
    3a62:	df 93       	push	r29
    3a64:	00 d0       	rcall	.+0      	; 0x3a66 <_ZN10WiFiServer6statusEv+0x6>
    3a66:	cd b7       	in	r28, 0x3d	; 61
    3a68:	de b7       	in	r29, 0x3e	; 62
    3a6a:	9a 83       	std	Y+2, r25	; 0x02
    3a6c:	89 83       	std	Y+1, r24	; 0x01
    return ServerDrv::getServerState(0);
    3a6e:	80 e0       	ldi	r24, 0x00	; 0
    3a70:	0e 94 96 08 	call	0x112c	; 0x112c <_ZN9ServerDrv14getServerStateEh>
}
    3a74:	0f 90       	pop	r0
    3a76:	0f 90       	pop	r0
    3a78:	df 91       	pop	r29
    3a7a:	cf 91       	pop	r28
    3a7c:	08 95       	ret

00003a7e <_ZN10WiFiServer5writeEh>:


size_t WiFiServer::write(uint8_t b)
{
    3a7e:	cf 93       	push	r28
    3a80:	df 93       	push	r29
    3a82:	00 d0       	rcall	.+0      	; 0x3a84 <_ZN10WiFiServer5writeEh+0x6>
    3a84:	1f 92       	push	r1
    3a86:	cd b7       	in	r28, 0x3d	; 61
    3a88:	de b7       	in	r29, 0x3e	; 62
    3a8a:	9a 83       	std	Y+2, r25	; 0x02
    3a8c:	89 83       	std	Y+1, r24	; 0x01
    3a8e:	6b 83       	std	Y+3, r22	; 0x03
    return write(&b, 1);
    3a90:	89 81       	ldd	r24, Y+1	; 0x01
    3a92:	9a 81       	ldd	r25, Y+2	; 0x02
    3a94:	fc 01       	movw	r30, r24
    3a96:	80 81       	ld	r24, Z
    3a98:	91 81       	ldd	r25, Z+1	; 0x01
    3a9a:	02 96       	adiw	r24, 0x02	; 2
    3a9c:	fc 01       	movw	r30, r24
    3a9e:	20 81       	ld	r18, Z
    3aa0:	31 81       	ldd	r19, Z+1	; 0x01
    3aa2:	be 01       	movw	r22, r28
    3aa4:	6d 5f       	subi	r22, 0xFD	; 253
    3aa6:	7f 4f       	sbci	r23, 0xFF	; 255
    3aa8:	89 81       	ldd	r24, Y+1	; 0x01
    3aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    3aac:	41 e0       	ldi	r20, 0x01	; 1
    3aae:	50 e0       	ldi	r21, 0x00	; 0
    3ab0:	f9 01       	movw	r30, r18
    3ab2:	09 95       	icall
}
    3ab4:	0f 90       	pop	r0
    3ab6:	0f 90       	pop	r0
    3ab8:	0f 90       	pop	r0
    3aba:	df 91       	pop	r29
    3abc:	cf 91       	pop	r28
    3abe:	08 95       	ret

00003ac0 <_ZN10WiFiServer5writeEPKhj>:

size_t WiFiServer::write(const uint8_t *buffer, size_t size)
{
    3ac0:	cf 93       	push	r28
    3ac2:	df 93       	push	r29
    3ac4:	cd b7       	in	r28, 0x3d	; 61
    3ac6:	de b7       	in	r29, 0x3e	; 62
    3ac8:	69 97       	sbiw	r28, 0x19	; 25
    3aca:	0f b6       	in	r0, 0x3f	; 63
    3acc:	f8 94       	cli
    3ace:	de bf       	out	0x3e, r29	; 62
    3ad0:	0f be       	out	0x3f, r0	; 63
    3ad2:	cd bf       	out	0x3d, r28	; 61
    3ad4:	9d 8b       	std	Y+21, r25	; 0x15
    3ad6:	8c 8b       	std	Y+20, r24	; 0x14
    3ad8:	7f 8b       	std	Y+23, r23	; 0x17
    3ada:	6e 8b       	std	Y+22, r22	; 0x16
    3adc:	59 8f       	std	Y+25, r21	; 0x19
    3ade:	48 8f       	std	Y+24, r20	; 0x18
	size_t n = 0;
    3ae0:	1a 82       	std	Y+2, r1	; 0x02
    3ae2:	19 82       	std	Y+1, r1	; 0x01

    for (int sock = 0; sock < MAX_SOCK_NUM; sock++)
    3ae4:	1c 82       	std	Y+4, r1	; 0x04
    3ae6:	1b 82       	std	Y+3, r1	; 0x03
    3ae8:	41 c0       	rjmp	.+130    	; 0x3b6c <_ZN10WiFiServer5writeEPKhj+0xac>
    {
        if (WiFiClass::_server_port[sock] != 0)
    3aea:	8b 81       	ldd	r24, Y+3	; 0x03
    3aec:	9c 81       	ldd	r25, Y+4	; 0x04
    3aee:	88 0f       	add	r24, r24
    3af0:	99 1f       	adc	r25, r25
    3af2:	85 5f       	subi	r24, 0xF5	; 245
    3af4:	98 4f       	sbci	r25, 0xF8	; 248
    3af6:	fc 01       	movw	r30, r24
    3af8:	80 81       	ld	r24, Z
    3afa:	91 81       	ldd	r25, Z+1	; 0x01
    3afc:	00 97       	sbiw	r24, 0x00	; 0
    3afe:	89 f1       	breq	.+98     	; 0x3b62 <_ZN10WiFiServer5writeEPKhj+0xa2>
        {
        	WiFiClient client(sock);
    3b00:	2b 81       	ldd	r18, Y+3	; 0x03
    3b02:	ce 01       	movw	r24, r28
    3b04:	05 96       	adiw	r24, 0x05	; 5
    3b06:	62 2f       	mov	r22, r18
    3b08:	0e 94 9a 18 	call	0x3134	; 0x3134 <_ZN10WiFiClientC1Eh>

            if (WiFiClass::_server_port[sock] == _port &&
    3b0c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b0e:	9c 81       	ldd	r25, Y+4	; 0x04
    3b10:	88 0f       	add	r24, r24
    3b12:	99 1f       	adc	r25, r25
    3b14:	85 5f       	subi	r24, 0xF5	; 245
    3b16:	98 4f       	sbci	r25, 0xF8	; 248
    3b18:	fc 01       	movw	r30, r24
    3b1a:	20 81       	ld	r18, Z
    3b1c:	31 81       	ldd	r19, Z+1	; 0x01
    3b1e:	8c 89       	ldd	r24, Y+20	; 0x14
    3b20:	9d 89       	ldd	r25, Y+21	; 0x15
    3b22:	fc 01       	movw	r30, r24
    3b24:	84 81       	ldd	r24, Z+4	; 0x04
    3b26:	95 81       	ldd	r25, Z+5	; 0x05
    3b28:	28 17       	cp	r18, r24
    3b2a:	39 07       	cpc	r19, r25
    3b2c:	41 f4       	brne	.+16     	; 0x3b3e <_ZN10WiFiServer5writeEPKhj+0x7e>
                client.status() == ESTABLISHED)
    3b2e:	ce 01       	movw	r24, r28
    3b30:	05 96       	adiw	r24, 0x05	; 5
    3b32:	0e 94 c1 1b 	call	0x3782	; 0x3782 <_ZN10WiFiClient6statusEv>
    {
        if (WiFiClass::_server_port[sock] != 0)
        {
        	WiFiClient client(sock);

            if (WiFiClass::_server_port[sock] == _port &&
    3b36:	84 30       	cpi	r24, 0x04	; 4
    3b38:	11 f4       	brne	.+4      	; 0x3b3e <_ZN10WiFiServer5writeEPKhj+0x7e>
    3b3a:	81 e0       	ldi	r24, 0x01	; 1
    3b3c:	01 c0       	rjmp	.+2      	; 0x3b40 <_ZN10WiFiServer5writeEPKhj+0x80>
    3b3e:	80 e0       	ldi	r24, 0x00	; 0
    3b40:	88 23       	and	r24, r24
    3b42:	79 f0       	breq	.+30     	; 0x3b62 <_ZN10WiFiServer5writeEPKhj+0xa2>
                client.status() == ESTABLISHED)
            {                
                n+=client.write(buffer, size);
    3b44:	48 8d       	ldd	r20, Y+24	; 0x18
    3b46:	59 8d       	ldd	r21, Y+25	; 0x19
    3b48:	2e 89       	ldd	r18, Y+22	; 0x16
    3b4a:	3f 89       	ldd	r19, Y+23	; 0x17
    3b4c:	ce 01       	movw	r24, r28
    3b4e:	05 96       	adiw	r24, 0x05	; 5
    3b50:	b9 01       	movw	r22, r18
    3b52:	0e 94 da 19 	call	0x33b4	; 0x33b4 <_ZN10WiFiClient5writeEPKhj>
    3b56:	29 81       	ldd	r18, Y+1	; 0x01
    3b58:	3a 81       	ldd	r19, Y+2	; 0x02
    3b5a:	82 0f       	add	r24, r18
    3b5c:	93 1f       	adc	r25, r19
    3b5e:	9a 83       	std	Y+2, r25	; 0x02
    3b60:	89 83       	std	Y+1, r24	; 0x01

size_t WiFiServer::write(const uint8_t *buffer, size_t size)
{
	size_t n = 0;

    for (int sock = 0; sock < MAX_SOCK_NUM; sock++)
    3b62:	8b 81       	ldd	r24, Y+3	; 0x03
    3b64:	9c 81       	ldd	r25, Y+4	; 0x04
    3b66:	01 96       	adiw	r24, 0x01	; 1
    3b68:	9c 83       	std	Y+4, r25	; 0x04
    3b6a:	8b 83       	std	Y+3, r24	; 0x03
    3b6c:	21 e0       	ldi	r18, 0x01	; 1
    3b6e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b70:	9c 81       	ldd	r25, Y+4	; 0x04
    3b72:	84 30       	cpi	r24, 0x04	; 4
    3b74:	91 05       	cpc	r25, r1
    3b76:	0c f0       	brlt	.+2      	; 0x3b7a <_ZN10WiFiServer5writeEPKhj+0xba>
    3b78:	20 e0       	ldi	r18, 0x00	; 0
    3b7a:	22 23       	and	r18, r18
    3b7c:	09 f0       	breq	.+2      	; 0x3b80 <_ZN10WiFiServer5writeEPKhj+0xc0>
    3b7e:	b5 cf       	rjmp	.-150    	; 0x3aea <_ZN10WiFiServer5writeEPKhj+0x2a>
            {                
                n+=client.write(buffer, size);
            }
        }
    }
    return n;
    3b80:	89 81       	ldd	r24, Y+1	; 0x01
    3b82:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3b84:	69 96       	adiw	r28, 0x19	; 25
    3b86:	0f b6       	in	r0, 0x3f	; 63
    3b88:	f8 94       	cli
    3b8a:	de bf       	out	0x3e, r29	; 62
    3b8c:	0f be       	out	0x3f, r0	; 63
    3b8e:	cd bf       	out	0x3d, r28	; 61
    3b90:	df 91       	pop	r29
    3b92:	cf 91       	pop	r28
    3b94:	08 95       	ret

00003b96 <_Z41__static_initialization_and_destruction_0ii>:
    3b96:	0f 93       	push	r16
    3b98:	cf 93       	push	r28
    3b9a:	df 93       	push	r29
    3b9c:	00 d0       	rcall	.+0      	; 0x3b9e <_Z41__static_initialization_and_destruction_0ii+0x8>
    3b9e:	00 d0       	rcall	.+0      	; 0x3ba0 <_Z41__static_initialization_and_destruction_0ii+0xa>
    3ba0:	cd b7       	in	r28, 0x3d	; 61
    3ba2:	de b7       	in	r29, 0x3e	; 62
    3ba4:	9a 83       	std	Y+2, r25	; 0x02
    3ba6:	89 83       	std	Y+1, r24	; 0x01
    3ba8:	7c 83       	std	Y+4, r23	; 0x04
    3baa:	6b 83       	std	Y+3, r22	; 0x03
    3bac:	89 81       	ldd	r24, Y+1	; 0x01
    3bae:	9a 81       	ldd	r25, Y+2	; 0x02
    3bb0:	81 30       	cpi	r24, 0x01	; 1
    3bb2:	91 05       	cpc	r25, r1
    3bb4:	71 f4       	brne	.+28     	; 0x3bd2 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    3bb6:	8b 81       	ldd	r24, Y+3	; 0x03
    3bb8:	9c 81       	ldd	r25, Y+4	; 0x04
    3bba:	8f 3f       	cpi	r24, 0xFF	; 255
    3bbc:	2f ef       	ldi	r18, 0xFF	; 255
    3bbe:	92 07       	cpc	r25, r18
    3bc0:	41 f4       	brne	.+16     	; 0x3bd2 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    3bc2:	00 e0       	ldi	r16, 0x00	; 0
    3bc4:	20 e0       	ldi	r18, 0x00	; 0
    3bc6:	40 e0       	ldi	r20, 0x00	; 0
    3bc8:	60 e0       	ldi	r22, 0x00	; 0
    3bca:	80 e2       	ldi	r24, 0x20	; 32
    3bcc:	97 e0       	ldi	r25, 0x07	; 7
    3bce:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    3bd2:	0f 90       	pop	r0
    3bd4:	0f 90       	pop	r0
    3bd6:	0f 90       	pop	r0
    3bd8:	0f 90       	pop	r0
    3bda:	df 91       	pop	r29
    3bdc:	cf 91       	pop	r28
    3bde:	0f 91       	pop	r16
    3be0:	08 95       	ret

00003be2 <_GLOBAL__sub_I__ZN10WiFiServerC2Ej>:
    3be2:	cf 93       	push	r28
    3be4:	df 93       	push	r29
    3be6:	cd b7       	in	r28, 0x3d	; 61
    3be8:	de b7       	in	r29, 0x3e	; 62
    3bea:	6f ef       	ldi	r22, 0xFF	; 255
    3bec:	7f ef       	ldi	r23, 0xFF	; 255
    3bee:	81 e0       	ldi	r24, 0x01	; 1
    3bf0:	90 e0       	ldi	r25, 0x00	; 0
    3bf2:	0e 94 cb 1d 	call	0x3b96	; 0x3b96 <_Z41__static_initialization_and_destruction_0ii>
    3bf6:	df 91       	pop	r29
    3bf8:	cf 91       	pop	r28
    3bfa:	08 95       	ret

00003bfc <_ZN7StepperC1Eiii>:

/*
 * two-wire constructor.
 * Sets which wires should control the motor.
 */
Stepper::Stepper(int number_of_steps, int motor_pin_1, int motor_pin_2)
    3bfc:	cf 93       	push	r28
    3bfe:	df 93       	push	r29
    3c00:	cd b7       	in	r28, 0x3d	; 61
    3c02:	de b7       	in	r29, 0x3e	; 62
    3c04:	28 97       	sbiw	r28, 0x08	; 8
    3c06:	0f b6       	in	r0, 0x3f	; 63
    3c08:	f8 94       	cli
    3c0a:	de bf       	out	0x3e, r29	; 62
    3c0c:	0f be       	out	0x3f, r0	; 63
    3c0e:	cd bf       	out	0x3d, r28	; 61
    3c10:	9a 83       	std	Y+2, r25	; 0x02
    3c12:	89 83       	std	Y+1, r24	; 0x01
    3c14:	7c 83       	std	Y+4, r23	; 0x04
    3c16:	6b 83       	std	Y+3, r22	; 0x03
    3c18:	5e 83       	std	Y+6, r21	; 0x06
    3c1a:	4d 83       	std	Y+5, r20	; 0x05
    3c1c:	38 87       	std	Y+8, r19	; 0x08
    3c1e:	2f 83       	std	Y+7, r18	; 0x07
{
  this->step_number = 0;      // which step the motor is on
    3c20:	89 81       	ldd	r24, Y+1	; 0x01
    3c22:	9a 81       	ldd	r25, Y+2	; 0x02
    3c24:	fc 01       	movw	r30, r24
    3c26:	15 86       	std	Z+13, r1	; 0x0d
    3c28:	14 86       	std	Z+12, r1	; 0x0c
  this->speed = 0;        // the motor speed, in revolutions per minute
    3c2a:	89 81       	ldd	r24, Y+1	; 0x01
    3c2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c2e:	fc 01       	movw	r30, r24
    3c30:	13 82       	std	Z+3, r1	; 0x03
    3c32:	12 82       	std	Z+2, r1	; 0x02
  this->direction = 0;      // motor direction
    3c34:	89 81       	ldd	r24, Y+1	; 0x01
    3c36:	9a 81       	ldd	r25, Y+2	; 0x02
    3c38:	fc 01       	movw	r30, r24
    3c3a:	11 82       	std	Z+1, r1	; 0x01
    3c3c:	10 82       	st	Z, r1
  this->last_step_time = 0;    // time stamp in ms of the last step taken
    3c3e:	89 81       	ldd	r24, Y+1	; 0x01
    3c40:	9a 81       	ldd	r25, Y+2	; 0x02
    3c42:	fc 01       	movw	r30, r24
    3c44:	16 8a       	std	Z+22, r1	; 0x16
    3c46:	17 8a       	std	Z+23, r1	; 0x17
    3c48:	10 8e       	std	Z+24, r1	; 0x18
    3c4a:	11 8e       	std	Z+25, r1	; 0x19
  this->number_of_steps = number_of_steps;    // total number of steps for this motor
    3c4c:	89 81       	ldd	r24, Y+1	; 0x01
    3c4e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c50:	2b 81       	ldd	r18, Y+3	; 0x03
    3c52:	3c 81       	ldd	r19, Y+4	; 0x04
    3c54:	fc 01       	movw	r30, r24
    3c56:	31 87       	std	Z+9, r19	; 0x09
    3c58:	20 87       	std	Z+8, r18	; 0x08
  
  // Arduino pins for the motor control connection:
  this->motor_pin_1 = motor_pin_1;
    3c5a:	89 81       	ldd	r24, Y+1	; 0x01
    3c5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c5e:	2d 81       	ldd	r18, Y+5	; 0x05
    3c60:	3e 81       	ldd	r19, Y+6	; 0x06
    3c62:	fc 01       	movw	r30, r24
    3c64:	37 87       	std	Z+15, r19	; 0x0f
    3c66:	26 87       	std	Z+14, r18	; 0x0e
  this->motor_pin_2 = motor_pin_2;
    3c68:	89 81       	ldd	r24, Y+1	; 0x01
    3c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c6c:	2f 81       	ldd	r18, Y+7	; 0x07
    3c6e:	38 85       	ldd	r19, Y+8	; 0x08
    3c70:	fc 01       	movw	r30, r24
    3c72:	31 8b       	std	Z+17, r19	; 0x11
    3c74:	20 8b       	std	Z+16, r18	; 0x10

  // setup the pins on the microcontroller:
  pinMode(this->motor_pin_1, OUTPUT);
    3c76:	89 81       	ldd	r24, Y+1	; 0x01
    3c78:	9a 81       	ldd	r25, Y+2	; 0x02
    3c7a:	fc 01       	movw	r30, r24
    3c7c:	86 85       	ldd	r24, Z+14	; 0x0e
    3c7e:	97 85       	ldd	r25, Z+15	; 0x0f
    3c80:	61 e0       	ldi	r22, 0x01	; 1
    3c82:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
  pinMode(this->motor_pin_2, OUTPUT);
    3c86:	89 81       	ldd	r24, Y+1	; 0x01
    3c88:	9a 81       	ldd	r25, Y+2	; 0x02
    3c8a:	fc 01       	movw	r30, r24
    3c8c:	80 89       	ldd	r24, Z+16	; 0x10
    3c8e:	91 89       	ldd	r25, Z+17	; 0x11
    3c90:	61 e0       	ldi	r22, 0x01	; 1
    3c92:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
  
  // When there are only 2 pins, set the other two to 0:
  this->motor_pin_3 = 0;
    3c96:	89 81       	ldd	r24, Y+1	; 0x01
    3c98:	9a 81       	ldd	r25, Y+2	; 0x02
    3c9a:	fc 01       	movw	r30, r24
    3c9c:	13 8a       	std	Z+19, r1	; 0x13
    3c9e:	12 8a       	std	Z+18, r1	; 0x12
  this->motor_pin_4 = 0;
    3ca0:	89 81       	ldd	r24, Y+1	; 0x01
    3ca2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ca4:	fc 01       	movw	r30, r24
    3ca6:	15 8a       	std	Z+21, r1	; 0x15
    3ca8:	14 8a       	std	Z+20, r1	; 0x14
  
  // pin_count is used by the stepMotor() method:
  this->pin_count = 2;
    3caa:	89 81       	ldd	r24, Y+1	; 0x01
    3cac:	9a 81       	ldd	r25, Y+2	; 0x02
    3cae:	22 e0       	ldi	r18, 0x02	; 2
    3cb0:	30 e0       	ldi	r19, 0x00	; 0
    3cb2:	fc 01       	movw	r30, r24
    3cb4:	33 87       	std	Z+11, r19	; 0x0b
    3cb6:	22 87       	std	Z+10, r18	; 0x0a
}
    3cb8:	28 96       	adiw	r28, 0x08	; 8
    3cba:	0f b6       	in	r0, 0x3f	; 63
    3cbc:	f8 94       	cli
    3cbe:	de bf       	out	0x3e, r29	; 62
    3cc0:	0f be       	out	0x3f, r0	; 63
    3cc2:	cd bf       	out	0x3d, r28	; 61
    3cc4:	df 91       	pop	r29
    3cc6:	cf 91       	pop	r28
    3cc8:	08 95       	ret

00003cca <_ZN7StepperC1Eiiiii>:
/*
 *   constructor for four-pin version
 *   Sets which wires should control the motor.
 */

Stepper::Stepper(int number_of_steps, int motor_pin_1, int motor_pin_2, int motor_pin_3, int motor_pin_4)
    3cca:	ef 92       	push	r14
    3ccc:	ff 92       	push	r15
    3cce:	0f 93       	push	r16
    3cd0:	1f 93       	push	r17
    3cd2:	cf 93       	push	r28
    3cd4:	df 93       	push	r29
    3cd6:	cd b7       	in	r28, 0x3d	; 61
    3cd8:	de b7       	in	r29, 0x3e	; 62
    3cda:	2c 97       	sbiw	r28, 0x0c	; 12
    3cdc:	0f b6       	in	r0, 0x3f	; 63
    3cde:	f8 94       	cli
    3ce0:	de bf       	out	0x3e, r29	; 62
    3ce2:	0f be       	out	0x3f, r0	; 63
    3ce4:	cd bf       	out	0x3d, r28	; 61
    3ce6:	9a 83       	std	Y+2, r25	; 0x02
    3ce8:	89 83       	std	Y+1, r24	; 0x01
    3cea:	7c 83       	std	Y+4, r23	; 0x04
    3cec:	6b 83       	std	Y+3, r22	; 0x03
    3cee:	5e 83       	std	Y+6, r21	; 0x06
    3cf0:	4d 83       	std	Y+5, r20	; 0x05
    3cf2:	38 87       	std	Y+8, r19	; 0x08
    3cf4:	2f 83       	std	Y+7, r18	; 0x07
    3cf6:	1a 87       	std	Y+10, r17	; 0x0a
    3cf8:	09 87       	std	Y+9, r16	; 0x09
    3cfa:	fc 86       	std	Y+12, r15	; 0x0c
    3cfc:	eb 86       	std	Y+11, r14	; 0x0b
{
  this->step_number = 0;      // which step the motor is on
    3cfe:	89 81       	ldd	r24, Y+1	; 0x01
    3d00:	9a 81       	ldd	r25, Y+2	; 0x02
    3d02:	fc 01       	movw	r30, r24
    3d04:	15 86       	std	Z+13, r1	; 0x0d
    3d06:	14 86       	std	Z+12, r1	; 0x0c
  this->speed = 0;        // the motor speed, in revolutions per minute
    3d08:	89 81       	ldd	r24, Y+1	; 0x01
    3d0a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d0c:	fc 01       	movw	r30, r24
    3d0e:	13 82       	std	Z+3, r1	; 0x03
    3d10:	12 82       	std	Z+2, r1	; 0x02
  this->direction = 0;      // motor direction
    3d12:	89 81       	ldd	r24, Y+1	; 0x01
    3d14:	9a 81       	ldd	r25, Y+2	; 0x02
    3d16:	fc 01       	movw	r30, r24
    3d18:	11 82       	std	Z+1, r1	; 0x01
    3d1a:	10 82       	st	Z, r1
  this->last_step_time = 0;    // time stamp in ms of the last step taken
    3d1c:	89 81       	ldd	r24, Y+1	; 0x01
    3d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d20:	fc 01       	movw	r30, r24
    3d22:	16 8a       	std	Z+22, r1	; 0x16
    3d24:	17 8a       	std	Z+23, r1	; 0x17
    3d26:	10 8e       	std	Z+24, r1	; 0x18
    3d28:	11 8e       	std	Z+25, r1	; 0x19
  this->number_of_steps = number_of_steps;    // total number of steps for this motor
    3d2a:	89 81       	ldd	r24, Y+1	; 0x01
    3d2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d2e:	2b 81       	ldd	r18, Y+3	; 0x03
    3d30:	3c 81       	ldd	r19, Y+4	; 0x04
    3d32:	fc 01       	movw	r30, r24
    3d34:	31 87       	std	Z+9, r19	; 0x09
    3d36:	20 87       	std	Z+8, r18	; 0x08
  
  // Arduino pins for the motor control connection:
  this->motor_pin_1 = motor_pin_1;
    3d38:	89 81       	ldd	r24, Y+1	; 0x01
    3d3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d3c:	2d 81       	ldd	r18, Y+5	; 0x05
    3d3e:	3e 81       	ldd	r19, Y+6	; 0x06
    3d40:	fc 01       	movw	r30, r24
    3d42:	37 87       	std	Z+15, r19	; 0x0f
    3d44:	26 87       	std	Z+14, r18	; 0x0e
  this->motor_pin_2 = motor_pin_2;
    3d46:	89 81       	ldd	r24, Y+1	; 0x01
    3d48:	9a 81       	ldd	r25, Y+2	; 0x02
    3d4a:	2f 81       	ldd	r18, Y+7	; 0x07
    3d4c:	38 85       	ldd	r19, Y+8	; 0x08
    3d4e:	fc 01       	movw	r30, r24
    3d50:	31 8b       	std	Z+17, r19	; 0x11
    3d52:	20 8b       	std	Z+16, r18	; 0x10
  this->motor_pin_3 = motor_pin_3;
    3d54:	89 81       	ldd	r24, Y+1	; 0x01
    3d56:	9a 81       	ldd	r25, Y+2	; 0x02
    3d58:	29 85       	ldd	r18, Y+9	; 0x09
    3d5a:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d5c:	fc 01       	movw	r30, r24
    3d5e:	33 8b       	std	Z+19, r19	; 0x13
    3d60:	22 8b       	std	Z+18, r18	; 0x12
  this->motor_pin_4 = motor_pin_4;
    3d62:	89 81       	ldd	r24, Y+1	; 0x01
    3d64:	9a 81       	ldd	r25, Y+2	; 0x02
    3d66:	2b 85       	ldd	r18, Y+11	; 0x0b
    3d68:	3c 85       	ldd	r19, Y+12	; 0x0c
    3d6a:	fc 01       	movw	r30, r24
    3d6c:	35 8b       	std	Z+21, r19	; 0x15
    3d6e:	24 8b       	std	Z+20, r18	; 0x14

  // setup the pins on the microcontroller:
  pinMode(this->motor_pin_1, OUTPUT);
    3d70:	89 81       	ldd	r24, Y+1	; 0x01
    3d72:	9a 81       	ldd	r25, Y+2	; 0x02
    3d74:	fc 01       	movw	r30, r24
    3d76:	86 85       	ldd	r24, Z+14	; 0x0e
    3d78:	97 85       	ldd	r25, Z+15	; 0x0f
    3d7a:	61 e0       	ldi	r22, 0x01	; 1
    3d7c:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
  pinMode(this->motor_pin_2, OUTPUT);
    3d80:	89 81       	ldd	r24, Y+1	; 0x01
    3d82:	9a 81       	ldd	r25, Y+2	; 0x02
    3d84:	fc 01       	movw	r30, r24
    3d86:	80 89       	ldd	r24, Z+16	; 0x10
    3d88:	91 89       	ldd	r25, Z+17	; 0x11
    3d8a:	61 e0       	ldi	r22, 0x01	; 1
    3d8c:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
  pinMode(this->motor_pin_3, OUTPUT);
    3d90:	89 81       	ldd	r24, Y+1	; 0x01
    3d92:	9a 81       	ldd	r25, Y+2	; 0x02
    3d94:	fc 01       	movw	r30, r24
    3d96:	82 89       	ldd	r24, Z+18	; 0x12
    3d98:	93 89       	ldd	r25, Z+19	; 0x13
    3d9a:	61 e0       	ldi	r22, 0x01	; 1
    3d9c:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
  pinMode(this->motor_pin_4, OUTPUT);
    3da0:	89 81       	ldd	r24, Y+1	; 0x01
    3da2:	9a 81       	ldd	r25, Y+2	; 0x02
    3da4:	fc 01       	movw	r30, r24
    3da6:	84 89       	ldd	r24, Z+20	; 0x14
    3da8:	95 89       	ldd	r25, Z+21	; 0x15
    3daa:	61 e0       	ldi	r22, 0x01	; 1
    3dac:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>

  // pin_count is used by the stepMotor() method:  
  this->pin_count = 4;  
    3db0:	89 81       	ldd	r24, Y+1	; 0x01
    3db2:	9a 81       	ldd	r25, Y+2	; 0x02
    3db4:	24 e0       	ldi	r18, 0x04	; 4
    3db6:	30 e0       	ldi	r19, 0x00	; 0
    3db8:	fc 01       	movw	r30, r24
    3dba:	33 87       	std	Z+11, r19	; 0x0b
    3dbc:	22 87       	std	Z+10, r18	; 0x0a
}
    3dbe:	2c 96       	adiw	r28, 0x0c	; 12
    3dc0:	0f b6       	in	r0, 0x3f	; 63
    3dc2:	f8 94       	cli
    3dc4:	de bf       	out	0x3e, r29	; 62
    3dc6:	0f be       	out	0x3f, r0	; 63
    3dc8:	cd bf       	out	0x3d, r28	; 61
    3dca:	df 91       	pop	r29
    3dcc:	cf 91       	pop	r28
    3dce:	1f 91       	pop	r17
    3dd0:	0f 91       	pop	r16
    3dd2:	ff 90       	pop	r15
    3dd4:	ef 90       	pop	r14
    3dd6:	08 95       	ret

00003dd8 <_ZN7Stepper8setSpeedEl>:
/*
  Sets the speed in revs per minute

*/
void Stepper::setSpeed(long whatSpeed)
{
    3dd8:	cf 93       	push	r28
    3dda:	df 93       	push	r29
    3ddc:	00 d0       	rcall	.+0      	; 0x3dde <_ZN7Stepper8setSpeedEl+0x6>
    3dde:	00 d0       	rcall	.+0      	; 0x3de0 <_ZN7Stepper8setSpeedEl+0x8>
    3de0:	00 d0       	rcall	.+0      	; 0x3de2 <_ZN7Stepper8setSpeedEl+0xa>
    3de2:	cd b7       	in	r28, 0x3d	; 61
    3de4:	de b7       	in	r29, 0x3e	; 62
    3de6:	9a 83       	std	Y+2, r25	; 0x02
    3de8:	89 83       	std	Y+1, r24	; 0x01
    3dea:	4b 83       	std	Y+3, r20	; 0x03
    3dec:	5c 83       	std	Y+4, r21	; 0x04
    3dee:	6d 83       	std	Y+5, r22	; 0x05
    3df0:	7e 83       	std	Y+6, r23	; 0x06
  this->step_delay = 60L * 1000L / this->number_of_steps / whatSpeed;
    3df2:	89 81       	ldd	r24, Y+1	; 0x01
    3df4:	9a 81       	ldd	r25, Y+2	; 0x02
    3df6:	fc 01       	movw	r30, r24
    3df8:	80 85       	ldd	r24, Z+8	; 0x08
    3dfa:	91 85       	ldd	r25, Z+9	; 0x09
    3dfc:	9c 01       	movw	r18, r24
    3dfe:	44 27       	eor	r20, r20
    3e00:	37 fd       	sbrc	r19, 7
    3e02:	40 95       	com	r20
    3e04:	54 2f       	mov	r21, r20
    3e06:	80 e6       	ldi	r24, 0x60	; 96
    3e08:	9a ee       	ldi	r25, 0xEA	; 234
    3e0a:	a0 e0       	ldi	r26, 0x00	; 0
    3e0c:	b0 e0       	ldi	r27, 0x00	; 0
    3e0e:	bc 01       	movw	r22, r24
    3e10:	cd 01       	movw	r24, r26
    3e12:	0e 94 cf ad 	call	0x15b9e	; 0x15b9e <__divmodsi4>
    3e16:	da 01       	movw	r26, r20
    3e18:	c9 01       	movw	r24, r18
    3e1a:	2b 81       	ldd	r18, Y+3	; 0x03
    3e1c:	3c 81       	ldd	r19, Y+4	; 0x04
    3e1e:	4d 81       	ldd	r20, Y+5	; 0x05
    3e20:	5e 81       	ldd	r21, Y+6	; 0x06
    3e22:	bc 01       	movw	r22, r24
    3e24:	cd 01       	movw	r24, r26
    3e26:	0e 94 cf ad 	call	0x15b9e	; 0x15b9e <__divmodsi4>
    3e2a:	da 01       	movw	r26, r20
    3e2c:	c9 01       	movw	r24, r18
    3e2e:	29 81       	ldd	r18, Y+1	; 0x01
    3e30:	3a 81       	ldd	r19, Y+2	; 0x02
    3e32:	f9 01       	movw	r30, r18
    3e34:	84 83       	std	Z+4, r24	; 0x04
    3e36:	95 83       	std	Z+5, r25	; 0x05
    3e38:	a6 83       	std	Z+6, r26	; 0x06
    3e3a:	b7 83       	std	Z+7, r27	; 0x07
}
    3e3c:	26 96       	adiw	r28, 0x06	; 6
    3e3e:	0f b6       	in	r0, 0x3f	; 63
    3e40:	f8 94       	cli
    3e42:	de bf       	out	0x3e, r29	; 62
    3e44:	0f be       	out	0x3f, r0	; 63
    3e46:	cd bf       	out	0x3d, r28	; 61
    3e48:	df 91       	pop	r29
    3e4a:	cf 91       	pop	r28
    3e4c:	08 95       	ret

00003e4e <_ZN7Stepper4stepEi>:
/*
  Moves the motor steps_to_move steps.  If the number is negative, 
   the motor moves in the reverse direction.
 */
void Stepper::step(int steps_to_move)
{  
    3e4e:	cf 93       	push	r28
    3e50:	df 93       	push	r29
    3e52:	00 d0       	rcall	.+0      	; 0x3e54 <_ZN7Stepper4stepEi+0x6>
    3e54:	00 d0       	rcall	.+0      	; 0x3e56 <_ZN7Stepper4stepEi+0x8>
    3e56:	00 d0       	rcall	.+0      	; 0x3e58 <_ZN7Stepper4stepEi+0xa>
    3e58:	cd b7       	in	r28, 0x3d	; 61
    3e5a:	de b7       	in	r29, 0x3e	; 62
    3e5c:	9c 83       	std	Y+4, r25	; 0x04
    3e5e:	8b 83       	std	Y+3, r24	; 0x03
    3e60:	7e 83       	std	Y+6, r23	; 0x06
    3e62:	6d 83       	std	Y+5, r22	; 0x05
  int steps_left = abs(steps_to_move);  // how many steps to take
    3e64:	8d 81       	ldd	r24, Y+5	; 0x05
    3e66:	9e 81       	ldd	r25, Y+6	; 0x06
    3e68:	99 23       	and	r25, r25
    3e6a:	1c f4       	brge	.+6      	; 0x3e72 <_ZN7Stepper4stepEi+0x24>
    3e6c:	91 95       	neg	r25
    3e6e:	81 95       	neg	r24
    3e70:	91 09       	sbc	r25, r1
    3e72:	9a 83       	std	Y+2, r25	; 0x02
    3e74:	89 83       	std	Y+1, r24	; 0x01
  
  // determine direction based on whether steps_to_mode is + or -:
  if (steps_to_move > 0) {this->direction = 1;}
    3e76:	8d 81       	ldd	r24, Y+5	; 0x05
    3e78:	9e 81       	ldd	r25, Y+6	; 0x06
    3e7a:	18 16       	cp	r1, r24
    3e7c:	19 06       	cpc	r1, r25
    3e7e:	3c f4       	brge	.+14     	; 0x3e8e <_ZN7Stepper4stepEi+0x40>
    3e80:	8b 81       	ldd	r24, Y+3	; 0x03
    3e82:	9c 81       	ldd	r25, Y+4	; 0x04
    3e84:	21 e0       	ldi	r18, 0x01	; 1
    3e86:	30 e0       	ldi	r19, 0x00	; 0
    3e88:	fc 01       	movw	r30, r24
    3e8a:	31 83       	std	Z+1, r19	; 0x01
    3e8c:	20 83       	st	Z, r18
  if (steps_to_move < 0) {this->direction = 0;}
    3e8e:	8d 81       	ldd	r24, Y+5	; 0x05
    3e90:	9e 81       	ldd	r25, Y+6	; 0x06
    3e92:	99 23       	and	r25, r25
    3e94:	0c f0       	brlt	.+2      	; 0x3e98 <_ZN7Stepper4stepEi+0x4a>
    3e96:	8f c0       	rjmp	.+286    	; 0x3fb6 <_ZN7Stepper4stepEi+0x168>
    3e98:	8b 81       	ldd	r24, Y+3	; 0x03
    3e9a:	9c 81       	ldd	r25, Y+4	; 0x04
    3e9c:	fc 01       	movw	r30, r24
    3e9e:	11 82       	std	Z+1, r1	; 0x01
    3ea0:	10 82       	st	Z, r1
    
    
  // decrement the number of steps, moving one step each time:
  while(steps_left > 0) {
    3ea2:	89 c0       	rjmp	.+274    	; 0x3fb6 <_ZN7Stepper4stepEi+0x168>
  // move only if the appropriate delay has passed:
  if (millis() - this->last_step_time >= this->step_delay) {
    3ea4:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    3ea8:	9b 01       	movw	r18, r22
    3eaa:	ac 01       	movw	r20, r24
    3eac:	8b 81       	ldd	r24, Y+3	; 0x03
    3eae:	9c 81       	ldd	r25, Y+4	; 0x04
    3eb0:	fc 01       	movw	r30, r24
    3eb2:	86 89       	ldd	r24, Z+22	; 0x16
    3eb4:	97 89       	ldd	r25, Z+23	; 0x17
    3eb6:	a0 8d       	ldd	r26, Z+24	; 0x18
    3eb8:	b1 8d       	ldd	r27, Z+25	; 0x19
    3eba:	28 1b       	sub	r18, r24
    3ebc:	39 0b       	sbc	r19, r25
    3ebe:	4a 0b       	sbc	r20, r26
    3ec0:	5b 0b       	sbc	r21, r27
    3ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ec4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ec6:	fc 01       	movw	r30, r24
    3ec8:	84 81       	ldd	r24, Z+4	; 0x04
    3eca:	95 81       	ldd	r25, Z+5	; 0x05
    3ecc:	a6 81       	ldd	r26, Z+6	; 0x06
    3ece:	b7 81       	ldd	r27, Z+7	; 0x07
    3ed0:	61 e0       	ldi	r22, 0x01	; 1
    3ed2:	28 17       	cp	r18, r24
    3ed4:	39 07       	cpc	r19, r25
    3ed6:	4a 07       	cpc	r20, r26
    3ed8:	5b 07       	cpc	r21, r27
    3eda:	08 f4       	brcc	.+2      	; 0x3ede <_ZN7Stepper4stepEi+0x90>
    3edc:	60 e0       	ldi	r22, 0x00	; 0
    3ede:	66 23       	and	r22, r22
    3ee0:	09 f4       	brne	.+2      	; 0x3ee4 <_ZN7Stepper4stepEi+0x96>
    3ee2:	69 c0       	rjmp	.+210    	; 0x3fb6 <_ZN7Stepper4stepEi+0x168>
      // get the timeStamp of when you stepped:
      this->last_step_time = millis();
    3ee4:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    3ee8:	dc 01       	movw	r26, r24
    3eea:	cb 01       	movw	r24, r22
    3eec:	2b 81       	ldd	r18, Y+3	; 0x03
    3eee:	3c 81       	ldd	r19, Y+4	; 0x04
    3ef0:	f9 01       	movw	r30, r18
    3ef2:	86 8b       	std	Z+22, r24	; 0x16
    3ef4:	97 8b       	std	Z+23, r25	; 0x17
    3ef6:	a0 8f       	std	Z+24, r26	; 0x18
    3ef8:	b1 8f       	std	Z+25, r27	; 0x19
      // increment or decrement the step number,
      // depending on direction:
      if (this->direction == 1) {
    3efa:	8b 81       	ldd	r24, Y+3	; 0x03
    3efc:	9c 81       	ldd	r25, Y+4	; 0x04
    3efe:	fc 01       	movw	r30, r24
    3f00:	80 81       	ld	r24, Z
    3f02:	91 81       	ldd	r25, Z+1	; 0x01
    3f04:	81 30       	cpi	r24, 0x01	; 1
    3f06:	91 05       	cpc	r25, r1
    3f08:	01 f5       	brne	.+64     	; 0x3f4a <_ZN7Stepper4stepEi+0xfc>
        this->step_number++;
    3f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f0e:	fc 01       	movw	r30, r24
    3f10:	84 85       	ldd	r24, Z+12	; 0x0c
    3f12:	95 85       	ldd	r25, Z+13	; 0x0d
    3f14:	9c 01       	movw	r18, r24
    3f16:	2f 5f       	subi	r18, 0xFF	; 255
    3f18:	3f 4f       	sbci	r19, 0xFF	; 255
    3f1a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f1c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f1e:	fc 01       	movw	r30, r24
    3f20:	35 87       	std	Z+13, r19	; 0x0d
    3f22:	24 87       	std	Z+12, r18	; 0x0c
        if (this->step_number == this->number_of_steps) {
    3f24:	8b 81       	ldd	r24, Y+3	; 0x03
    3f26:	9c 81       	ldd	r25, Y+4	; 0x04
    3f28:	fc 01       	movw	r30, r24
    3f2a:	24 85       	ldd	r18, Z+12	; 0x0c
    3f2c:	35 85       	ldd	r19, Z+13	; 0x0d
    3f2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f30:	9c 81       	ldd	r25, Y+4	; 0x04
    3f32:	fc 01       	movw	r30, r24
    3f34:	80 85       	ldd	r24, Z+8	; 0x08
    3f36:	91 85       	ldd	r25, Z+9	; 0x09
    3f38:	28 17       	cp	r18, r24
    3f3a:	39 07       	cpc	r19, r25
    3f3c:	21 f5       	brne	.+72     	; 0x3f86 <_ZN7Stepper4stepEi+0x138>
          this->step_number = 0;
    3f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f40:	9c 81       	ldd	r25, Y+4	; 0x04
    3f42:	fc 01       	movw	r30, r24
    3f44:	15 86       	std	Z+13, r1	; 0x0d
    3f46:	14 86       	std	Z+12, r1	; 0x0c
    3f48:	1e c0       	rjmp	.+60     	; 0x3f86 <_ZN7Stepper4stepEi+0x138>
        }
      } 
      else { 
        if (this->step_number == 0) {
    3f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f4c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f4e:	fc 01       	movw	r30, r24
    3f50:	84 85       	ldd	r24, Z+12	; 0x0c
    3f52:	95 85       	ldd	r25, Z+13	; 0x0d
    3f54:	00 97       	sbiw	r24, 0x00	; 0
    3f56:	51 f4       	brne	.+20     	; 0x3f6c <_ZN7Stepper4stepEi+0x11e>
          this->step_number = this->number_of_steps;
    3f58:	8b 81       	ldd	r24, Y+3	; 0x03
    3f5a:	9c 81       	ldd	r25, Y+4	; 0x04
    3f5c:	fc 01       	movw	r30, r24
    3f5e:	20 85       	ldd	r18, Z+8	; 0x08
    3f60:	31 85       	ldd	r19, Z+9	; 0x09
    3f62:	8b 81       	ldd	r24, Y+3	; 0x03
    3f64:	9c 81       	ldd	r25, Y+4	; 0x04
    3f66:	fc 01       	movw	r30, r24
    3f68:	35 87       	std	Z+13, r19	; 0x0d
    3f6a:	24 87       	std	Z+12, r18	; 0x0c
        }
        this->step_number--;
    3f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f70:	fc 01       	movw	r30, r24
    3f72:	84 85       	ldd	r24, Z+12	; 0x0c
    3f74:	95 85       	ldd	r25, Z+13	; 0x0d
    3f76:	9c 01       	movw	r18, r24
    3f78:	21 50       	subi	r18, 0x01	; 1
    3f7a:	31 09       	sbc	r19, r1
    3f7c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f7e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f80:	fc 01       	movw	r30, r24
    3f82:	35 87       	std	Z+13, r19	; 0x0d
    3f84:	24 87       	std	Z+12, r18	; 0x0c
      }
      // decrement the steps left:
      steps_left--;
    3f86:	89 81       	ldd	r24, Y+1	; 0x01
    3f88:	9a 81       	ldd	r25, Y+2	; 0x02
    3f8a:	01 97       	sbiw	r24, 0x01	; 1
    3f8c:	9a 83       	std	Y+2, r25	; 0x02
    3f8e:	89 83       	std	Y+1, r24	; 0x01
      // step the motor to step number 0, 1, 2, or 3:
      stepMotor(this->step_number % 4);
    3f90:	8b 81       	ldd	r24, Y+3	; 0x03
    3f92:	9c 81       	ldd	r25, Y+4	; 0x04
    3f94:	fc 01       	movw	r30, r24
    3f96:	84 85       	ldd	r24, Z+12	; 0x0c
    3f98:	95 85       	ldd	r25, Z+13	; 0x0d
    3f9a:	83 70       	andi	r24, 0x03	; 3
    3f9c:	90 78       	andi	r25, 0x80	; 128
    3f9e:	99 23       	and	r25, r25
    3fa0:	24 f4       	brge	.+8      	; 0x3faa <_ZN7Stepper4stepEi+0x15c>
    3fa2:	01 97       	sbiw	r24, 0x01	; 1
    3fa4:	8c 6f       	ori	r24, 0xFC	; 252
    3fa6:	9f 6f       	ori	r25, 0xFF	; 255
    3fa8:	01 96       	adiw	r24, 0x01	; 1
    3faa:	9c 01       	movw	r18, r24
    3fac:	8b 81       	ldd	r24, Y+3	; 0x03
    3fae:	9c 81       	ldd	r25, Y+4	; 0x04
    3fb0:	b9 01       	movw	r22, r18
    3fb2:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <_ZN7Stepper9stepMotorEi>
  if (steps_to_move > 0) {this->direction = 1;}
  if (steps_to_move < 0) {this->direction = 0;}
    
    
  // decrement the number of steps, moving one step each time:
  while(steps_left > 0) {
    3fb6:	21 e0       	ldi	r18, 0x01	; 1
    3fb8:	89 81       	ldd	r24, Y+1	; 0x01
    3fba:	9a 81       	ldd	r25, Y+2	; 0x02
    3fbc:	18 16       	cp	r1, r24
    3fbe:	19 06       	cpc	r1, r25
    3fc0:	0c f0       	brlt	.+2      	; 0x3fc4 <_ZN7Stepper4stepEi+0x176>
    3fc2:	20 e0       	ldi	r18, 0x00	; 0
    3fc4:	22 23       	and	r18, r18
    3fc6:	09 f0       	breq	.+2      	; 0x3fca <_ZN7Stepper4stepEi+0x17c>
    3fc8:	6d cf       	rjmp	.-294    	; 0x3ea4 <_ZN7Stepper4stepEi+0x56>
      steps_left--;
      // step the motor to step number 0, 1, 2, or 3:
      stepMotor(this->step_number % 4);
    }
  }
}
    3fca:	26 96       	adiw	r28, 0x06	; 6
    3fcc:	0f b6       	in	r0, 0x3f	; 63
    3fce:	f8 94       	cli
    3fd0:	de bf       	out	0x3e, r29	; 62
    3fd2:	0f be       	out	0x3f, r0	; 63
    3fd4:	cd bf       	out	0x3d, r28	; 61
    3fd6:	df 91       	pop	r29
    3fd8:	cf 91       	pop	r28
    3fda:	08 95       	ret

00003fdc <_ZN7Stepper9stepMotorEi>:

/*
 * Moves the motor forward or backwards.
 */
void Stepper::stepMotor(int thisStep)
{
    3fdc:	cf 93       	push	r28
    3fde:	df 93       	push	r29
    3fe0:	00 d0       	rcall	.+0      	; 0x3fe2 <_ZN7Stepper9stepMotorEi+0x6>
    3fe2:	00 d0       	rcall	.+0      	; 0x3fe4 <_ZN7Stepper9stepMotorEi+0x8>
    3fe4:	cd b7       	in	r28, 0x3d	; 61
    3fe6:	de b7       	in	r29, 0x3e	; 62
    3fe8:	9a 83       	std	Y+2, r25	; 0x02
    3fea:	89 83       	std	Y+1, r24	; 0x01
    3fec:	7c 83       	std	Y+4, r23	; 0x04
    3fee:	6b 83       	std	Y+3, r22	; 0x03
  if (this->pin_count == 2) {
    3ff0:	89 81       	ldd	r24, Y+1	; 0x01
    3ff2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ff4:	fc 01       	movw	r30, r24
    3ff6:	82 85       	ldd	r24, Z+10	; 0x0a
    3ff8:	93 85       	ldd	r25, Z+11	; 0x0b
    3ffa:	82 30       	cpi	r24, 0x02	; 2
    3ffc:	91 05       	cpc	r25, r1
    3ffe:	09 f0       	breq	.+2      	; 0x4002 <_ZN7Stepper9stepMotorEi+0x26>
    4000:	56 c0       	rjmp	.+172    	; 0x40ae <_ZN7Stepper9stepMotorEi+0xd2>
    switch (thisStep) {
    4002:	8b 81       	ldd	r24, Y+3	; 0x03
    4004:	9c 81       	ldd	r25, Y+4	; 0x04
    4006:	81 30       	cpi	r24, 0x01	; 1
    4008:	91 05       	cpc	r25, r1
    400a:	f1 f0       	breq	.+60     	; 0x4048 <_ZN7Stepper9stepMotorEi+0x6c>
    400c:	82 30       	cpi	r24, 0x02	; 2
    400e:	91 05       	cpc	r25, r1
    4010:	1c f4       	brge	.+6      	; 0x4018 <_ZN7Stepper9stepMotorEi+0x3c>
    4012:	00 97       	sbiw	r24, 0x00	; 0
    4014:	41 f0       	breq	.+16     	; 0x4026 <_ZN7Stepper9stepMotorEi+0x4a>
    4016:	4b c0       	rjmp	.+150    	; 0x40ae <_ZN7Stepper9stepMotorEi+0xd2>
    4018:	82 30       	cpi	r24, 0x02	; 2
    401a:	91 05       	cpc	r25, r1
    401c:	31 f1       	breq	.+76     	; 0x406a <_ZN7Stepper9stepMotorEi+0x8e>
    401e:	83 30       	cpi	r24, 0x03	; 3
    4020:	91 05       	cpc	r25, r1
    4022:	a1 f1       	breq	.+104    	; 0x408c <_ZN7Stepper9stepMotorEi+0xb0>
    4024:	44 c0       	rjmp	.+136    	; 0x40ae <_ZN7Stepper9stepMotorEi+0xd2>
      case 0: /* 01 */
      digitalWrite(motor_pin_1, LOW);
    4026:	89 81       	ldd	r24, Y+1	; 0x01
    4028:	9a 81       	ldd	r25, Y+2	; 0x02
    402a:	fc 01       	movw	r30, r24
    402c:	86 85       	ldd	r24, Z+14	; 0x0e
    402e:	97 85       	ldd	r25, Z+15	; 0x0f
    4030:	60 e0       	ldi	r22, 0x00	; 0
    4032:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_2, HIGH);
    4036:	89 81       	ldd	r24, Y+1	; 0x01
    4038:	9a 81       	ldd	r25, Y+2	; 0x02
    403a:	fc 01       	movw	r30, r24
    403c:	80 89       	ldd	r24, Z+16	; 0x10
    403e:	91 89       	ldd	r25, Z+17	; 0x11
    4040:	61 e0       	ldi	r22, 0x01	; 1
    4042:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      break;
    4046:	33 c0       	rjmp	.+102    	; 0x40ae <_ZN7Stepper9stepMotorEi+0xd2>
      case 1: /* 11 */
      digitalWrite(motor_pin_1, HIGH);
    4048:	89 81       	ldd	r24, Y+1	; 0x01
    404a:	9a 81       	ldd	r25, Y+2	; 0x02
    404c:	fc 01       	movw	r30, r24
    404e:	86 85       	ldd	r24, Z+14	; 0x0e
    4050:	97 85       	ldd	r25, Z+15	; 0x0f
    4052:	61 e0       	ldi	r22, 0x01	; 1
    4054:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_2, HIGH);
    4058:	89 81       	ldd	r24, Y+1	; 0x01
    405a:	9a 81       	ldd	r25, Y+2	; 0x02
    405c:	fc 01       	movw	r30, r24
    405e:	80 89       	ldd	r24, Z+16	; 0x10
    4060:	91 89       	ldd	r25, Z+17	; 0x11
    4062:	61 e0       	ldi	r22, 0x01	; 1
    4064:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      break;
    4068:	22 c0       	rjmp	.+68     	; 0x40ae <_ZN7Stepper9stepMotorEi+0xd2>
      case 2: /* 10 */
      digitalWrite(motor_pin_1, HIGH);
    406a:	89 81       	ldd	r24, Y+1	; 0x01
    406c:	9a 81       	ldd	r25, Y+2	; 0x02
    406e:	fc 01       	movw	r30, r24
    4070:	86 85       	ldd	r24, Z+14	; 0x0e
    4072:	97 85       	ldd	r25, Z+15	; 0x0f
    4074:	61 e0       	ldi	r22, 0x01	; 1
    4076:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_2, LOW);
    407a:	89 81       	ldd	r24, Y+1	; 0x01
    407c:	9a 81       	ldd	r25, Y+2	; 0x02
    407e:	fc 01       	movw	r30, r24
    4080:	80 89       	ldd	r24, Z+16	; 0x10
    4082:	91 89       	ldd	r25, Z+17	; 0x11
    4084:	60 e0       	ldi	r22, 0x00	; 0
    4086:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      break;
    408a:	11 c0       	rjmp	.+34     	; 0x40ae <_ZN7Stepper9stepMotorEi+0xd2>
      case 3: /* 00 */
      digitalWrite(motor_pin_1, LOW);
    408c:	89 81       	ldd	r24, Y+1	; 0x01
    408e:	9a 81       	ldd	r25, Y+2	; 0x02
    4090:	fc 01       	movw	r30, r24
    4092:	86 85       	ldd	r24, Z+14	; 0x0e
    4094:	97 85       	ldd	r25, Z+15	; 0x0f
    4096:	60 e0       	ldi	r22, 0x00	; 0
    4098:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_2, LOW);
    409c:	89 81       	ldd	r24, Y+1	; 0x01
    409e:	9a 81       	ldd	r25, Y+2	; 0x02
    40a0:	fc 01       	movw	r30, r24
    40a2:	80 89       	ldd	r24, Z+16	; 0x10
    40a4:	91 89       	ldd	r25, Z+17	; 0x11
    40a6:	60 e0       	ldi	r22, 0x00	; 0
    40a8:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      break;
    40ac:	00 00       	nop
    } 
  }
  if (this->pin_count == 4) {
    40ae:	89 81       	ldd	r24, Y+1	; 0x01
    40b0:	9a 81       	ldd	r25, Y+2	; 0x02
    40b2:	fc 01       	movw	r30, r24
    40b4:	82 85       	ldd	r24, Z+10	; 0x0a
    40b6:	93 85       	ldd	r25, Z+11	; 0x0b
    40b8:	84 30       	cpi	r24, 0x04	; 4
    40ba:	91 05       	cpc	r25, r1
    40bc:	09 f0       	breq	.+2      	; 0x40c0 <_ZN7Stepper9stepMotorEi+0xe4>
    40be:	98 c0       	rjmp	.+304    	; 0x41f0 <_ZN7Stepper9stepMotorEi+0x214>
    switch (thisStep) {
    40c0:	8b 81       	ldd	r24, Y+3	; 0x03
    40c2:	9c 81       	ldd	r25, Y+4	; 0x04
    40c4:	81 30       	cpi	r24, 0x01	; 1
    40c6:	91 05       	cpc	r25, r1
    40c8:	81 f1       	breq	.+96     	; 0x412a <_ZN7Stepper9stepMotorEi+0x14e>
    40ca:	82 30       	cpi	r24, 0x02	; 2
    40cc:	91 05       	cpc	r25, r1
    40ce:	1c f4       	brge	.+6      	; 0x40d6 <_ZN7Stepper9stepMotorEi+0xfa>
    40d0:	00 97       	sbiw	r24, 0x00	; 0
    40d2:	51 f0       	breq	.+20     	; 0x40e8 <_ZN7Stepper9stepMotorEi+0x10c>
    40d4:	8d c0       	rjmp	.+282    	; 0x41f0 <_ZN7Stepper9stepMotorEi+0x214>
    40d6:	82 30       	cpi	r24, 0x02	; 2
    40d8:	91 05       	cpc	r25, r1
    40da:	09 f4       	brne	.+2      	; 0x40de <_ZN7Stepper9stepMotorEi+0x102>
    40dc:	47 c0       	rjmp	.+142    	; 0x416c <_ZN7Stepper9stepMotorEi+0x190>
    40de:	83 30       	cpi	r24, 0x03	; 3
    40e0:	91 05       	cpc	r25, r1
    40e2:	09 f4       	brne	.+2      	; 0x40e6 <_ZN7Stepper9stepMotorEi+0x10a>
    40e4:	64 c0       	rjmp	.+200    	; 0x41ae <_ZN7Stepper9stepMotorEi+0x1d2>
    40e6:	84 c0       	rjmp	.+264    	; 0x41f0 <_ZN7Stepper9stepMotorEi+0x214>
      case 0:    // 1010
      digitalWrite(motor_pin_1, HIGH);
    40e8:	89 81       	ldd	r24, Y+1	; 0x01
    40ea:	9a 81       	ldd	r25, Y+2	; 0x02
    40ec:	fc 01       	movw	r30, r24
    40ee:	86 85       	ldd	r24, Z+14	; 0x0e
    40f0:	97 85       	ldd	r25, Z+15	; 0x0f
    40f2:	61 e0       	ldi	r22, 0x01	; 1
    40f4:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_2, LOW);
    40f8:	89 81       	ldd	r24, Y+1	; 0x01
    40fa:	9a 81       	ldd	r25, Y+2	; 0x02
    40fc:	fc 01       	movw	r30, r24
    40fe:	80 89       	ldd	r24, Z+16	; 0x10
    4100:	91 89       	ldd	r25, Z+17	; 0x11
    4102:	60 e0       	ldi	r22, 0x00	; 0
    4104:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_3, HIGH);
    4108:	89 81       	ldd	r24, Y+1	; 0x01
    410a:	9a 81       	ldd	r25, Y+2	; 0x02
    410c:	fc 01       	movw	r30, r24
    410e:	82 89       	ldd	r24, Z+18	; 0x12
    4110:	93 89       	ldd	r25, Z+19	; 0x13
    4112:	61 e0       	ldi	r22, 0x01	; 1
    4114:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_4, LOW);
    4118:	89 81       	ldd	r24, Y+1	; 0x01
    411a:	9a 81       	ldd	r25, Y+2	; 0x02
    411c:	fc 01       	movw	r30, r24
    411e:	84 89       	ldd	r24, Z+20	; 0x14
    4120:	95 89       	ldd	r25, Z+21	; 0x15
    4122:	60 e0       	ldi	r22, 0x00	; 0
    4124:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      break;
    4128:	63 c0       	rjmp	.+198    	; 0x41f0 <_ZN7Stepper9stepMotorEi+0x214>
      case 1:    // 0110
      digitalWrite(motor_pin_1, LOW);
    412a:	89 81       	ldd	r24, Y+1	; 0x01
    412c:	9a 81       	ldd	r25, Y+2	; 0x02
    412e:	fc 01       	movw	r30, r24
    4130:	86 85       	ldd	r24, Z+14	; 0x0e
    4132:	97 85       	ldd	r25, Z+15	; 0x0f
    4134:	60 e0       	ldi	r22, 0x00	; 0
    4136:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_2, HIGH);
    413a:	89 81       	ldd	r24, Y+1	; 0x01
    413c:	9a 81       	ldd	r25, Y+2	; 0x02
    413e:	fc 01       	movw	r30, r24
    4140:	80 89       	ldd	r24, Z+16	; 0x10
    4142:	91 89       	ldd	r25, Z+17	; 0x11
    4144:	61 e0       	ldi	r22, 0x01	; 1
    4146:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_3, HIGH);
    414a:	89 81       	ldd	r24, Y+1	; 0x01
    414c:	9a 81       	ldd	r25, Y+2	; 0x02
    414e:	fc 01       	movw	r30, r24
    4150:	82 89       	ldd	r24, Z+18	; 0x12
    4152:	93 89       	ldd	r25, Z+19	; 0x13
    4154:	61 e0       	ldi	r22, 0x01	; 1
    4156:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_4, LOW);
    415a:	89 81       	ldd	r24, Y+1	; 0x01
    415c:	9a 81       	ldd	r25, Y+2	; 0x02
    415e:	fc 01       	movw	r30, r24
    4160:	84 89       	ldd	r24, Z+20	; 0x14
    4162:	95 89       	ldd	r25, Z+21	; 0x15
    4164:	60 e0       	ldi	r22, 0x00	; 0
    4166:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      break;
    416a:	42 c0       	rjmp	.+132    	; 0x41f0 <_ZN7Stepper9stepMotorEi+0x214>
      case 2:    //0101
      digitalWrite(motor_pin_1, LOW);
    416c:	89 81       	ldd	r24, Y+1	; 0x01
    416e:	9a 81       	ldd	r25, Y+2	; 0x02
    4170:	fc 01       	movw	r30, r24
    4172:	86 85       	ldd	r24, Z+14	; 0x0e
    4174:	97 85       	ldd	r25, Z+15	; 0x0f
    4176:	60 e0       	ldi	r22, 0x00	; 0
    4178:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_2, HIGH);
    417c:	89 81       	ldd	r24, Y+1	; 0x01
    417e:	9a 81       	ldd	r25, Y+2	; 0x02
    4180:	fc 01       	movw	r30, r24
    4182:	80 89       	ldd	r24, Z+16	; 0x10
    4184:	91 89       	ldd	r25, Z+17	; 0x11
    4186:	61 e0       	ldi	r22, 0x01	; 1
    4188:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_3, LOW);
    418c:	89 81       	ldd	r24, Y+1	; 0x01
    418e:	9a 81       	ldd	r25, Y+2	; 0x02
    4190:	fc 01       	movw	r30, r24
    4192:	82 89       	ldd	r24, Z+18	; 0x12
    4194:	93 89       	ldd	r25, Z+19	; 0x13
    4196:	60 e0       	ldi	r22, 0x00	; 0
    4198:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_4, HIGH);
    419c:	89 81       	ldd	r24, Y+1	; 0x01
    419e:	9a 81       	ldd	r25, Y+2	; 0x02
    41a0:	fc 01       	movw	r30, r24
    41a2:	84 89       	ldd	r24, Z+20	; 0x14
    41a4:	95 89       	ldd	r25, Z+21	; 0x15
    41a6:	61 e0       	ldi	r22, 0x01	; 1
    41a8:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      break;
    41ac:	21 c0       	rjmp	.+66     	; 0x41f0 <_ZN7Stepper9stepMotorEi+0x214>
      case 3:    //1001
      digitalWrite(motor_pin_1, HIGH);
    41ae:	89 81       	ldd	r24, Y+1	; 0x01
    41b0:	9a 81       	ldd	r25, Y+2	; 0x02
    41b2:	fc 01       	movw	r30, r24
    41b4:	86 85       	ldd	r24, Z+14	; 0x0e
    41b6:	97 85       	ldd	r25, Z+15	; 0x0f
    41b8:	61 e0       	ldi	r22, 0x01	; 1
    41ba:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_2, LOW);
    41be:	89 81       	ldd	r24, Y+1	; 0x01
    41c0:	9a 81       	ldd	r25, Y+2	; 0x02
    41c2:	fc 01       	movw	r30, r24
    41c4:	80 89       	ldd	r24, Z+16	; 0x10
    41c6:	91 89       	ldd	r25, Z+17	; 0x11
    41c8:	60 e0       	ldi	r22, 0x00	; 0
    41ca:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_3, LOW);
    41ce:	89 81       	ldd	r24, Y+1	; 0x01
    41d0:	9a 81       	ldd	r25, Y+2	; 0x02
    41d2:	fc 01       	movw	r30, r24
    41d4:	82 89       	ldd	r24, Z+18	; 0x12
    41d6:	93 89       	ldd	r25, Z+19	; 0x13
    41d8:	60 e0       	ldi	r22, 0x00	; 0
    41da:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      digitalWrite(motor_pin_4, HIGH);
    41de:	89 81       	ldd	r24, Y+1	; 0x01
    41e0:	9a 81       	ldd	r25, Y+2	; 0x02
    41e2:	fc 01       	movw	r30, r24
    41e4:	84 89       	ldd	r24, Z+20	; 0x14
    41e6:	95 89       	ldd	r25, Z+21	; 0x15
    41e8:	61 e0       	ldi	r22, 0x01	; 1
    41ea:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
      break;
    41ee:	00 00       	nop
    } 
  }
}
    41f0:	0f 90       	pop	r0
    41f2:	0f 90       	pop	r0
    41f4:	0f 90       	pop	r0
    41f6:	0f 90       	pop	r0
    41f8:	df 91       	pop	r29
    41fa:	cf 91       	pop	r28
    41fc:	08 95       	ret

000041fe <_ZN7Stepper7versionEv>:

/*
  version() returns the version of the library:
*/
int Stepper::version(void)
{
    41fe:	cf 93       	push	r28
    4200:	df 93       	push	r29
    4202:	00 d0       	rcall	.+0      	; 0x4204 <_ZN7Stepper7versionEv+0x6>
    4204:	cd b7       	in	r28, 0x3d	; 61
    4206:	de b7       	in	r29, 0x3e	; 62
    4208:	9a 83       	std	Y+2, r25	; 0x02
    420a:	89 83       	std	Y+1, r24	; 0x01
  return 4;
    420c:	84 e0       	ldi	r24, 0x04	; 4
    420e:	90 e0       	ldi	r25, 0x00	; 0
}
    4210:	0f 90       	pop	r0
    4212:	0f 90       	pop	r0
    4214:	df 91       	pop	r29
    4216:	cf 91       	pop	r28
    4218:	08 95       	ret

0000421a <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_>:
#define SERVO_MAX() (MAX_PULSE_WIDTH - this->max * 4)  // maximum value in uS for this servo 

/************ static functions common to all instances ***********************/

static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA)
{
    421a:	cf 93       	push	r28
    421c:	df 93       	push	r29
    421e:	00 d0       	rcall	.+0      	; 0x4220 <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x6>
    4220:	00 d0       	rcall	.+0      	; 0x4222 <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x8>
    4222:	1f 92       	push	r1
    4224:	cd b7       	in	r28, 0x3d	; 61
    4226:	de b7       	in	r29, 0x3e	; 62
    4228:	89 83       	std	Y+1, r24	; 0x01
    422a:	7b 83       	std	Y+3, r23	; 0x03
    422c:	6a 83       	std	Y+2, r22	; 0x02
    422e:	5d 83       	std	Y+5, r21	; 0x05
    4230:	4c 83       	std	Y+4, r20	; 0x04
  if( Channel[timer] < 0 )
    4232:	89 81       	ldd	r24, Y+1	; 0x01
    4234:	88 2f       	mov	r24, r24
    4236:	90 e0       	ldi	r25, 0x00	; 0
    4238:	83 5b       	subi	r24, 0xB3	; 179
    423a:	98 4f       	sbci	r25, 0xF8	; 248
    423c:	fc 01       	movw	r30, r24
    423e:	80 81       	ld	r24, Z
    4240:	88 1f       	adc	r24, r24
    4242:	88 27       	eor	r24, r24
    4244:	88 1f       	adc	r24, r24
    4246:	88 23       	and	r24, r24
    4248:	31 f0       	breq	.+12     	; 0x4256 <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x3c>
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer 
    424a:	8a 81       	ldd	r24, Y+2	; 0x02
    424c:	9b 81       	ldd	r25, Y+3	; 0x03
    424e:	fc 01       	movw	r30, r24
    4250:	11 82       	std	Z+1, r1	; 0x01
    4252:	10 82       	st	Z, r1
    4254:	72 c0       	rjmp	.+228    	; 0x433a <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x120>
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )  
    4256:	89 81       	ldd	r24, Y+1	; 0x01
    4258:	28 2f       	mov	r18, r24
    425a:	30 e0       	ldi	r19, 0x00	; 0
    425c:	c9 01       	movw	r24, r18
    425e:	88 0f       	add	r24, r24
    4260:	99 1f       	adc	r25, r25
    4262:	82 0f       	add	r24, r18
    4264:	93 1f       	adc	r25, r19
    4266:	88 0f       	add	r24, r24
    4268:	99 1f       	adc	r25, r25
    426a:	88 0f       	add	r24, r24
    426c:	99 1f       	adc	r25, r25
    426e:	9c 01       	movw	r18, r24
    4270:	89 81       	ldd	r24, Y+1	; 0x01
    4272:	88 2f       	mov	r24, r24
    4274:	90 e0       	ldi	r25, 0x00	; 0
    4276:	83 5b       	subi	r24, 0xB3	; 179
    4278:	98 4f       	sbci	r25, 0xF8	; 248
    427a:	fc 01       	movw	r30, r24
    427c:	80 81       	ld	r24, Z
    427e:	99 27       	eor	r25, r25
    4280:	87 fd       	sbrc	r24, 7
    4282:	90 95       	com	r25
    4284:	28 0f       	add	r18, r24
    4286:	39 1f       	adc	r19, r25
    4288:	80 91 28 07 	lds	r24, 0x0728
    428c:	88 2f       	mov	r24, r24
    428e:	90 e0       	ldi	r25, 0x00	; 0
    4290:	28 17       	cp	r18, r24
    4292:	39 07       	cpc	r19, r25
    4294:	4c f5       	brge	.+82     	; 0x42e8 <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0xce>
    4296:	89 81       	ldd	r24, Y+1	; 0x01
    4298:	28 2f       	mov	r18, r24
    429a:	30 e0       	ldi	r19, 0x00	; 0
    429c:	c9 01       	movw	r24, r18
    429e:	88 0f       	add	r24, r24
    42a0:	99 1f       	adc	r25, r25
    42a2:	82 0f       	add	r24, r18
    42a4:	93 1f       	adc	r25, r19
    42a6:	88 0f       	add	r24, r24
    42a8:	99 1f       	adc	r25, r25
    42aa:	88 0f       	add	r24, r24
    42ac:	99 1f       	adc	r25, r25
    42ae:	9c 01       	movw	r18, r24
    42b0:	89 81       	ldd	r24, Y+1	; 0x01
    42b2:	88 2f       	mov	r24, r24
    42b4:	90 e0       	ldi	r25, 0x00	; 0
    42b6:	83 5b       	subi	r24, 0xB3	; 179
    42b8:	98 4f       	sbci	r25, 0xF8	; 248
    42ba:	fc 01       	movw	r30, r24
    42bc:	80 81       	ld	r24, Z
    42be:	99 27       	eor	r25, r25
    42c0:	87 fd       	sbrc	r24, 7
    42c2:	90 95       	com	r25
    42c4:	28 0f       	add	r18, r24
    42c6:	39 1f       	adc	r19, r25
    42c8:	c9 01       	movw	r24, r18
    42ca:	88 0f       	add	r24, r24
    42cc:	99 1f       	adc	r25, r25
    42ce:	82 0f       	add	r24, r18
    42d0:	93 1f       	adc	r25, r19
    42d2:	87 5d       	subi	r24, 0xD7	; 215
    42d4:	98 4f       	sbci	r25, 0xF8	; 248
    42d6:	fc 01       	movw	r30, r24
    42d8:	80 81       	ld	r24, Z
    42da:	86 fb       	bst	r24, 6
    42dc:	88 27       	eor	r24, r24
    42de:	80 f9       	bld	r24, 0
    42e0:	81 30       	cpi	r24, 0x01	; 1
    42e2:	11 f4       	brne	.+4      	; 0x42e8 <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0xce>
    42e4:	81 e0       	ldi	r24, 0x01	; 1
    42e6:	01 c0       	rjmp	.+2      	; 0x42ea <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0xd0>
    42e8:	80 e0       	ldi	r24, 0x00	; 0
    42ea:	88 23       	and	r24, r24
    42ec:	31 f1       	breq	.+76     	; 0x433a <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x120>
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
    42ee:	89 81       	ldd	r24, Y+1	; 0x01
    42f0:	28 2f       	mov	r18, r24
    42f2:	30 e0       	ldi	r19, 0x00	; 0
    42f4:	c9 01       	movw	r24, r18
    42f6:	88 0f       	add	r24, r24
    42f8:	99 1f       	adc	r25, r25
    42fa:	82 0f       	add	r24, r18
    42fc:	93 1f       	adc	r25, r19
    42fe:	88 0f       	add	r24, r24
    4300:	99 1f       	adc	r25, r25
    4302:	88 0f       	add	r24, r24
    4304:	99 1f       	adc	r25, r25
    4306:	9c 01       	movw	r18, r24
    4308:	89 81       	ldd	r24, Y+1	; 0x01
    430a:	88 2f       	mov	r24, r24
    430c:	90 e0       	ldi	r25, 0x00	; 0
    430e:	83 5b       	subi	r24, 0xB3	; 179
    4310:	98 4f       	sbci	r25, 0xF8	; 248
    4312:	fc 01       	movw	r30, r24
    4314:	80 81       	ld	r24, Z
    4316:	99 27       	eor	r25, r25
    4318:	87 fd       	sbrc	r24, 7
    431a:	90 95       	com	r25
    431c:	28 0f       	add	r18, r24
    431e:	39 1f       	adc	r19, r25
    4320:	c9 01       	movw	r24, r18
    4322:	88 0f       	add	r24, r24
    4324:	99 1f       	adc	r25, r25
    4326:	82 0f       	add	r24, r18
    4328:	93 1f       	adc	r25, r19
    432a:	87 5d       	subi	r24, 0xD7	; 215
    432c:	98 4f       	sbci	r25, 0xF8	; 248
    432e:	fc 01       	movw	r30, r24
    4330:	80 81       	ld	r24, Z
    4332:	8f 73       	andi	r24, 0x3F	; 63
    4334:	60 e0       	ldi	r22, 0x00	; 0
    4336:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
  }

  Channel[timer]++;    // increment to the next channel
    433a:	89 81       	ldd	r24, Y+1	; 0x01
    433c:	88 2f       	mov	r24, r24
    433e:	90 e0       	ldi	r25, 0x00	; 0
    4340:	9c 01       	movw	r18, r24
    4342:	23 5b       	subi	r18, 0xB3	; 179
    4344:	38 4f       	sbci	r19, 0xF8	; 248
    4346:	f9 01       	movw	r30, r18
    4348:	20 81       	ld	r18, Z
    434a:	2f 5f       	subi	r18, 0xFF	; 255
    434c:	83 5b       	subi	r24, 0xB3	; 179
    434e:	98 4f       	sbci	r25, 0xF8	; 248
    4350:	fc 01       	movw	r30, r24
    4352:	20 83       	st	Z, r18
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    4354:	89 81       	ldd	r24, Y+1	; 0x01
    4356:	28 2f       	mov	r18, r24
    4358:	30 e0       	ldi	r19, 0x00	; 0
    435a:	c9 01       	movw	r24, r18
    435c:	88 0f       	add	r24, r24
    435e:	99 1f       	adc	r25, r25
    4360:	82 0f       	add	r24, r18
    4362:	93 1f       	adc	r25, r19
    4364:	88 0f       	add	r24, r24
    4366:	99 1f       	adc	r25, r25
    4368:	88 0f       	add	r24, r24
    436a:	99 1f       	adc	r25, r25
    436c:	9c 01       	movw	r18, r24
    436e:	89 81       	ldd	r24, Y+1	; 0x01
    4370:	88 2f       	mov	r24, r24
    4372:	90 e0       	ldi	r25, 0x00	; 0
    4374:	83 5b       	subi	r24, 0xB3	; 179
    4376:	98 4f       	sbci	r25, 0xF8	; 248
    4378:	fc 01       	movw	r30, r24
    437a:	80 81       	ld	r24, Z
    437c:	99 27       	eor	r25, r25
    437e:	87 fd       	sbrc	r24, 7
    4380:	90 95       	com	r25
    4382:	28 0f       	add	r18, r24
    4384:	39 1f       	adc	r19, r25
    4386:	80 91 28 07 	lds	r24, 0x0728
    438a:	88 2f       	mov	r24, r24
    438c:	90 e0       	ldi	r25, 0x00	; 0
    438e:	28 17       	cp	r18, r24
    4390:	39 07       	cpc	r19, r25
    4392:	5c f4       	brge	.+22     	; 0x43aa <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x190>
    4394:	89 81       	ldd	r24, Y+1	; 0x01
    4396:	88 2f       	mov	r24, r24
    4398:	90 e0       	ldi	r25, 0x00	; 0
    439a:	83 5b       	subi	r24, 0xB3	; 179
    439c:	98 4f       	sbci	r25, 0xF8	; 248
    439e:	fc 01       	movw	r30, r24
    43a0:	80 81       	ld	r24, Z
    43a2:	8c 30       	cpi	r24, 0x0C	; 12
    43a4:	14 f4       	brge	.+4      	; 0x43aa <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x190>
    43a6:	81 e0       	ldi	r24, 0x01	; 1
    43a8:	01 c0       	rjmp	.+2      	; 0x43ac <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x192>
    43aa:	80 e0       	ldi	r24, 0x00	; 0
    43ac:	88 23       	and	r24, r24
    43ae:	09 f4       	brne	.+2      	; 0x43b2 <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x198>
    43b0:	83 c0       	rjmp	.+262    	; 0x44b8 <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x29e>
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
    43b2:	8a 81       	ldd	r24, Y+2	; 0x02
    43b4:	9b 81       	ldd	r25, Y+3	; 0x03
    43b6:	fc 01       	movw	r30, r24
    43b8:	40 81       	ld	r20, Z
    43ba:	51 81       	ldd	r21, Z+1	; 0x01
    43bc:	89 81       	ldd	r24, Y+1	; 0x01
    43be:	28 2f       	mov	r18, r24
    43c0:	30 e0       	ldi	r19, 0x00	; 0
    43c2:	c9 01       	movw	r24, r18
    43c4:	88 0f       	add	r24, r24
    43c6:	99 1f       	adc	r25, r25
    43c8:	82 0f       	add	r24, r18
    43ca:	93 1f       	adc	r25, r19
    43cc:	88 0f       	add	r24, r24
    43ce:	99 1f       	adc	r25, r25
    43d0:	88 0f       	add	r24, r24
    43d2:	99 1f       	adc	r25, r25
    43d4:	9c 01       	movw	r18, r24
    43d6:	89 81       	ldd	r24, Y+1	; 0x01
    43d8:	88 2f       	mov	r24, r24
    43da:	90 e0       	ldi	r25, 0x00	; 0
    43dc:	83 5b       	subi	r24, 0xB3	; 179
    43de:	98 4f       	sbci	r25, 0xF8	; 248
    43e0:	fc 01       	movw	r30, r24
    43e2:	80 81       	ld	r24, Z
    43e4:	99 27       	eor	r25, r25
    43e6:	87 fd       	sbrc	r24, 7
    43e8:	90 95       	com	r25
    43ea:	28 0f       	add	r18, r24
    43ec:	39 1f       	adc	r19, r25
    43ee:	c9 01       	movw	r24, r18
    43f0:	88 0f       	add	r24, r24
    43f2:	99 1f       	adc	r25, r25
    43f4:	82 0f       	add	r24, r18
    43f6:	93 1f       	adc	r25, r19
    43f8:	86 5d       	subi	r24, 0xD6	; 214
    43fa:	98 4f       	sbci	r25, 0xF8	; 248
    43fc:	fc 01       	movw	r30, r24
    43fe:	80 81       	ld	r24, Z
    4400:	91 81       	ldd	r25, Z+1	; 0x01
    4402:	9a 01       	movw	r18, r20
    4404:	28 0f       	add	r18, r24
    4406:	39 1f       	adc	r19, r25
    4408:	8c 81       	ldd	r24, Y+4	; 0x04
    440a:	9d 81       	ldd	r25, Y+5	; 0x05
    440c:	fc 01       	movw	r30, r24
    440e:	31 83       	std	Z+1, r19	; 0x01
    4410:	20 83       	st	Z, r18
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
    4412:	89 81       	ldd	r24, Y+1	; 0x01
    4414:	28 2f       	mov	r18, r24
    4416:	30 e0       	ldi	r19, 0x00	; 0
    4418:	c9 01       	movw	r24, r18
    441a:	88 0f       	add	r24, r24
    441c:	99 1f       	adc	r25, r25
    441e:	82 0f       	add	r24, r18
    4420:	93 1f       	adc	r25, r19
    4422:	88 0f       	add	r24, r24
    4424:	99 1f       	adc	r25, r25
    4426:	88 0f       	add	r24, r24
    4428:	99 1f       	adc	r25, r25
    442a:	9c 01       	movw	r18, r24
    442c:	89 81       	ldd	r24, Y+1	; 0x01
    442e:	88 2f       	mov	r24, r24
    4430:	90 e0       	ldi	r25, 0x00	; 0
    4432:	83 5b       	subi	r24, 0xB3	; 179
    4434:	98 4f       	sbci	r25, 0xF8	; 248
    4436:	fc 01       	movw	r30, r24
    4438:	80 81       	ld	r24, Z
    443a:	99 27       	eor	r25, r25
    443c:	87 fd       	sbrc	r24, 7
    443e:	90 95       	com	r25
    4440:	28 0f       	add	r18, r24
    4442:	39 1f       	adc	r19, r25
    4444:	c9 01       	movw	r24, r18
    4446:	88 0f       	add	r24, r24
    4448:	99 1f       	adc	r25, r25
    444a:	82 0f       	add	r24, r18
    444c:	93 1f       	adc	r25, r19
    444e:	87 5d       	subi	r24, 0xD7	; 215
    4450:	98 4f       	sbci	r25, 0xF8	; 248
    4452:	fc 01       	movw	r30, r24
    4454:	80 81       	ld	r24, Z
    4456:	86 fb       	bst	r24, 6
    4458:	99 27       	eor	r25, r25
    445a:	90 f9       	bld	r25, 0
    445c:	81 e0       	ldi	r24, 0x01	; 1
    445e:	91 30       	cpi	r25, 0x01	; 1
    4460:	09 f0       	breq	.+2      	; 0x4464 <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x24a>
    4462:	80 e0       	ldi	r24, 0x00	; 0
    4464:	88 23       	and	r24, r24
    4466:	09 f4       	brne	.+2      	; 0x446a <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x250>
    4468:	52 c0       	rjmp	.+164    	; 0x450e <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x2f4>
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high   
    446a:	89 81       	ldd	r24, Y+1	; 0x01
    446c:	28 2f       	mov	r18, r24
    446e:	30 e0       	ldi	r19, 0x00	; 0
    4470:	c9 01       	movw	r24, r18
    4472:	88 0f       	add	r24, r24
    4474:	99 1f       	adc	r25, r25
    4476:	82 0f       	add	r24, r18
    4478:	93 1f       	adc	r25, r19
    447a:	88 0f       	add	r24, r24
    447c:	99 1f       	adc	r25, r25
    447e:	88 0f       	add	r24, r24
    4480:	99 1f       	adc	r25, r25
    4482:	9c 01       	movw	r18, r24
    4484:	89 81       	ldd	r24, Y+1	; 0x01
    4486:	88 2f       	mov	r24, r24
    4488:	90 e0       	ldi	r25, 0x00	; 0
    448a:	83 5b       	subi	r24, 0xB3	; 179
    448c:	98 4f       	sbci	r25, 0xF8	; 248
    448e:	fc 01       	movw	r30, r24
    4490:	80 81       	ld	r24, Z
    4492:	99 27       	eor	r25, r25
    4494:	87 fd       	sbrc	r24, 7
    4496:	90 95       	com	r25
    4498:	28 0f       	add	r18, r24
    449a:	39 1f       	adc	r19, r25
    449c:	c9 01       	movw	r24, r18
    449e:	88 0f       	add	r24, r24
    44a0:	99 1f       	adc	r25, r25
    44a2:	82 0f       	add	r24, r18
    44a4:	93 1f       	adc	r25, r19
    44a6:	87 5d       	subi	r24, 0xD7	; 215
    44a8:	98 4f       	sbci	r25, 0xF8	; 248
    44aa:	fc 01       	movw	r30, r24
    44ac:	80 81       	ld	r24, Z
    44ae:	8f 73       	andi	r24, 0x3F	; 63
    44b0:	61 e0       	ldi	r22, 0x01	; 1
    44b2:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
    44b6:	2b c0       	rjmp	.+86     	; 0x450e <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x2f4>
  }  
  else { 
    // finished all channels so wait for the refresh period to expire before starting over 
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
    44b8:	8a 81       	ldd	r24, Y+2	; 0x02
    44ba:	9b 81       	ldd	r25, Y+3	; 0x03
    44bc:	fc 01       	movw	r30, r24
    44be:	80 81       	ld	r24, Z
    44c0:	91 81       	ldd	r25, Z+1	; 0x01
    44c2:	04 96       	adiw	r24, 0x04	; 4
    44c4:	21 e0       	ldi	r18, 0x01	; 1
    44c6:	80 34       	cpi	r24, 0x40	; 64
    44c8:	fc e9       	ldi	r31, 0x9C	; 156
    44ca:	9f 07       	cpc	r25, r31
    44cc:	08 f0       	brcs	.+2      	; 0x44d0 <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x2b6>
    44ce:	20 e0       	ldi	r18, 0x00	; 0
    44d0:	22 23       	and	r18, r18
    44d2:	41 f0       	breq	.+16     	; 0x44e4 <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x2ca>
      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);  
    44d4:	8c 81       	ldd	r24, Y+4	; 0x04
    44d6:	9d 81       	ldd	r25, Y+5	; 0x05
    44d8:	20 e4       	ldi	r18, 0x40	; 64
    44da:	3c e9       	ldi	r19, 0x9C	; 156
    44dc:	fc 01       	movw	r30, r24
    44de:	31 83       	std	Z+1, r19	; 0x01
    44e0:	20 83       	st	Z, r18
    44e2:	0d c0       	rjmp	.+26     	; 0x44fe <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_+0x2e4>
    else 
      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed
    44e4:	8a 81       	ldd	r24, Y+2	; 0x02
    44e6:	9b 81       	ldd	r25, Y+3	; 0x03
    44e8:	fc 01       	movw	r30, r24
    44ea:	80 81       	ld	r24, Z
    44ec:	91 81       	ldd	r25, Z+1	; 0x01
    44ee:	9c 01       	movw	r18, r24
    44f0:	2c 5f       	subi	r18, 0xFC	; 252
    44f2:	3f 4f       	sbci	r19, 0xFF	; 255
    44f4:	8c 81       	ldd	r24, Y+4	; 0x04
    44f6:	9d 81       	ldd	r25, Y+5	; 0x05
    44f8:	fc 01       	movw	r30, r24
    44fa:	31 83       	std	Z+1, r19	; 0x01
    44fc:	20 83       	st	Z, r18
    Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
    44fe:	89 81       	ldd	r24, Y+1	; 0x01
    4500:	88 2f       	mov	r24, r24
    4502:	90 e0       	ldi	r25, 0x00	; 0
    4504:	83 5b       	subi	r24, 0xB3	; 179
    4506:	98 4f       	sbci	r25, 0xF8	; 248
    4508:	2f ef       	ldi	r18, 0xFF	; 255
    450a:	fc 01       	movw	r30, r24
    450c:	20 83       	st	Z, r18
  }
}
    450e:	0f 90       	pop	r0
    4510:	0f 90       	pop	r0
    4512:	0f 90       	pop	r0
    4514:	0f 90       	pop	r0
    4516:	0f 90       	pop	r0
    4518:	df 91       	pop	r29
    451a:	cf 91       	pop	r28
    451c:	08 95       	ret

0000451e <__vector_11>:

#ifndef WIRING // Wiring pre-defines signal handlers so don't define any if compiling for the Wiring platform
// Interrupt handlers for Arduino 
#if defined(_useTimer1)
SIGNAL (TIMER1_COMPA_vect) 
{ 
    451e:	1f 92       	push	r1
    4520:	0f 92       	push	r0
    4522:	00 90 5f 00 	lds	r0, 0x005F
    4526:	0f 92       	push	r0
    4528:	11 24       	eor	r1, r1
    452a:	2f 93       	push	r18
    452c:	3f 93       	push	r19
    452e:	4f 93       	push	r20
    4530:	5f 93       	push	r21
    4532:	6f 93       	push	r22
    4534:	7f 93       	push	r23
    4536:	8f 93       	push	r24
    4538:	9f 93       	push	r25
    453a:	af 93       	push	r26
    453c:	bf 93       	push	r27
    453e:	ef 93       	push	r30
    4540:	ff 93       	push	r31
    4542:	cf 93       	push	r28
    4544:	df 93       	push	r29
    4546:	cd b7       	in	r28, 0x3d	; 61
    4548:	de b7       	in	r29, 0x3e	; 62
  handle_interrupts(_timer1, &TCNT1, &OCR1A); 
    454a:	48 e8       	ldi	r20, 0x88	; 136
    454c:	50 e0       	ldi	r21, 0x00	; 0
    454e:	64 e8       	ldi	r22, 0x84	; 132
    4550:	70 e0       	ldi	r23, 0x00	; 0
    4552:	80 e0       	ldi	r24, 0x00	; 0
    4554:	0e 94 0d 21 	call	0x421a	; 0x421a <_ZL17handle_interrupts18timer16_Sequence_tPVjS1_>
}
    4558:	df 91       	pop	r29
    455a:	cf 91       	pop	r28
    455c:	ff 91       	pop	r31
    455e:	ef 91       	pop	r30
    4560:	bf 91       	pop	r27
    4562:	af 91       	pop	r26
    4564:	9f 91       	pop	r25
    4566:	8f 91       	pop	r24
    4568:	7f 91       	pop	r23
    456a:	6f 91       	pop	r22
    456c:	5f 91       	pop	r21
    456e:	4f 91       	pop	r20
    4570:	3f 91       	pop	r19
    4572:	2f 91       	pop	r18
    4574:	0f 90       	pop	r0
    4576:	00 92 5f 00 	sts	0x005F, r0
    457a:	0f 90       	pop	r0
    457c:	1f 90       	pop	r1
    457e:	18 95       	reti

00004580 <_ZL7initISR18timer16_Sequence_t>:
#endif
#endif


static void initISR(timer16_Sequence_t timer)
{  
    4580:	cf 93       	push	r28
    4582:	df 93       	push	r29
    4584:	1f 92       	push	r1
    4586:	cd b7       	in	r28, 0x3d	; 61
    4588:	de b7       	in	r29, 0x3e	; 62
    458a:	89 83       	std	Y+1, r24	; 0x01
#if defined (_useTimer1)
  if(timer == _timer1) {
    458c:	89 81       	ldd	r24, Y+1	; 0x01
    458e:	88 23       	and	r24, r24
    4590:	01 f5       	brne	.+64     	; 0x45d2 <_ZL7initISR18timer16_Sequence_t+0x52>
    TCCR1A = 0;             // normal counting mode 
    4592:	80 e8       	ldi	r24, 0x80	; 128
    4594:	90 e0       	ldi	r25, 0x00	; 0
    4596:	fc 01       	movw	r30, r24
    4598:	10 82       	st	Z, r1
    TCCR1B = _BV(CS11);     // set prescaler of 8 
    459a:	81 e8       	ldi	r24, 0x81	; 129
    459c:	90 e0       	ldi	r25, 0x00	; 0
    459e:	22 e0       	ldi	r18, 0x02	; 2
    45a0:	fc 01       	movw	r30, r24
    45a2:	20 83       	st	Z, r18
    TCNT1 = 0;              // clear the timer count 
    45a4:	84 e8       	ldi	r24, 0x84	; 132
    45a6:	90 e0       	ldi	r25, 0x00	; 0
    45a8:	fc 01       	movw	r30, r24
    45aa:	11 82       	std	Z+1, r1	; 0x01
    45ac:	10 82       	st	Z, r1
#if defined(__AVR_ATmega8__)|| defined(__AVR_ATmega128__)
    TIFR |= _BV(OCF1A);      // clear any pending interrupts; 
    TIMSK |=  _BV(OCIE1A) ;  // enable the output compare interrupt  
#else
    // here if not ATmega8 or ATmega128
    TIFR1 |= _BV(OCF1A);     // clear any pending interrupts; 
    45ae:	86 e3       	ldi	r24, 0x36	; 54
    45b0:	90 e0       	ldi	r25, 0x00	; 0
    45b2:	26 e3       	ldi	r18, 0x36	; 54
    45b4:	30 e0       	ldi	r19, 0x00	; 0
    45b6:	f9 01       	movw	r30, r18
    45b8:	20 81       	ld	r18, Z
    45ba:	22 60       	ori	r18, 0x02	; 2
    45bc:	fc 01       	movw	r30, r24
    45be:	20 83       	st	Z, r18
    TIMSK1 |=  _BV(OCIE1A) ; // enable the output compare interrupt 
    45c0:	8f e6       	ldi	r24, 0x6F	; 111
    45c2:	90 e0       	ldi	r25, 0x00	; 0
    45c4:	2f e6       	ldi	r18, 0x6F	; 111
    45c6:	30 e0       	ldi	r19, 0x00	; 0
    45c8:	f9 01       	movw	r30, r18
    45ca:	20 81       	ld	r18, Z
    45cc:	22 60       	ori	r18, 0x02	; 2
    45ce:	fc 01       	movw	r30, r24
    45d0:	20 83       	st	Z, r18
    TCNT5 = 0;              // clear the timer count 
    TIFR5 = _BV(OCF5A);     // clear any pending interrupts; 
    TIMSK5 =  _BV(OCIE5A) ; // enable the output compare interrupt      
  }
#endif
} 
    45d2:	0f 90       	pop	r0
    45d4:	df 91       	pop	r29
    45d6:	cf 91       	pop	r28
    45d8:	08 95       	ret

000045da <_ZL6finISR18timer16_Sequence_t>:

static void finISR(timer16_Sequence_t timer)
{
    45da:	cf 93       	push	r28
    45dc:	df 93       	push	r29
    45de:	1f 92       	push	r1
    45e0:	cd b7       	in	r28, 0x3d	; 61
    45e2:	de b7       	in	r29, 0x3e	; 62
    45e4:	89 83       	std	Y+1, r24	; 0x01
    timerDetach(TIMER3OUTCOMPAREA_INT);
  }
#else
    //For arduino - in future: call here to a currently undefined function to reset the timer
#endif
}
    45e6:	0f 90       	pop	r0
    45e8:	df 91       	pop	r29
    45ea:	cf 91       	pop	r28
    45ec:	08 95       	ret

000045ee <_ZL13isTimerActive18timer16_Sequence_t>:

static boolean isTimerActive(timer16_Sequence_t timer)
{
    45ee:	cf 93       	push	r28
    45f0:	df 93       	push	r29
    45f2:	00 d0       	rcall	.+0      	; 0x45f4 <_ZL13isTimerActive18timer16_Sequence_t+0x6>
    45f4:	cd b7       	in	r28, 0x3d	; 61
    45f6:	de b7       	in	r29, 0x3e	; 62
    45f8:	8a 83       	std	Y+2, r24	; 0x02
  // returns true if any servo is active on this timer
  for(uint8_t channel=0; channel < SERVOS_PER_TIMER; channel++) {
    45fa:	19 82       	std	Y+1, r1	; 0x01
    45fc:	25 c0       	rjmp	.+74     	; 0x4648 <_ZL13isTimerActive18timer16_Sequence_t+0x5a>
    if(SERVO(timer,channel).Pin.isActive == true)
    45fe:	8a 81       	ldd	r24, Y+2	; 0x02
    4600:	28 2f       	mov	r18, r24
    4602:	30 e0       	ldi	r19, 0x00	; 0
    4604:	c9 01       	movw	r24, r18
    4606:	88 0f       	add	r24, r24
    4608:	99 1f       	adc	r25, r25
    460a:	82 0f       	add	r24, r18
    460c:	93 1f       	adc	r25, r19
    460e:	88 0f       	add	r24, r24
    4610:	99 1f       	adc	r25, r25
    4612:	88 0f       	add	r24, r24
    4614:	99 1f       	adc	r25, r25
    4616:	9c 01       	movw	r18, r24
    4618:	89 81       	ldd	r24, Y+1	; 0x01
    461a:	88 2f       	mov	r24, r24
    461c:	90 e0       	ldi	r25, 0x00	; 0
    461e:	28 0f       	add	r18, r24
    4620:	39 1f       	adc	r19, r25
    4622:	c9 01       	movw	r24, r18
    4624:	88 0f       	add	r24, r24
    4626:	99 1f       	adc	r25, r25
    4628:	82 0f       	add	r24, r18
    462a:	93 1f       	adc	r25, r19
    462c:	87 5d       	subi	r24, 0xD7	; 215
    462e:	98 4f       	sbci	r25, 0xF8	; 248
    4630:	fc 01       	movw	r30, r24
    4632:	80 81       	ld	r24, Z
    4634:	86 fb       	bst	r24, 6
    4636:	88 27       	eor	r24, r24
    4638:	80 f9       	bld	r24, 0
    463a:	81 30       	cpi	r24, 0x01	; 1
    463c:	11 f4       	brne	.+4      	; 0x4642 <_ZL13isTimerActive18timer16_Sequence_t+0x54>
      return true;
    463e:	81 e0       	ldi	r24, 0x01	; 1
    4640:	0b c0       	rjmp	.+22     	; 0x4658 <_ZL13isTimerActive18timer16_Sequence_t+0x6a>
}

static boolean isTimerActive(timer16_Sequence_t timer)
{
  // returns true if any servo is active on this timer
  for(uint8_t channel=0; channel < SERVOS_PER_TIMER; channel++) {
    4642:	89 81       	ldd	r24, Y+1	; 0x01
    4644:	8f 5f       	subi	r24, 0xFF	; 255
    4646:	89 83       	std	Y+1, r24	; 0x01
    4648:	81 e0       	ldi	r24, 0x01	; 1
    464a:	99 81       	ldd	r25, Y+1	; 0x01
    464c:	9c 30       	cpi	r25, 0x0C	; 12
    464e:	08 f0       	brcs	.+2      	; 0x4652 <_ZL13isTimerActive18timer16_Sequence_t+0x64>
    4650:	80 e0       	ldi	r24, 0x00	; 0
    4652:	88 23       	and	r24, r24
    4654:	a1 f6       	brne	.-88     	; 0x45fe <_ZL13isTimerActive18timer16_Sequence_t+0x10>
    if(SERVO(timer,channel).Pin.isActive == true)
      return true;
  }
  return false;
    4656:	80 e0       	ldi	r24, 0x00	; 0
}
    4658:	0f 90       	pop	r0
    465a:	0f 90       	pop	r0
    465c:	df 91       	pop	r29
    465e:	cf 91       	pop	r28
    4660:	08 95       	ret

00004662 <_ZN5ServoC1Ev>:


/****************** end of static functions ******************************/

Servo::Servo()
    4662:	cf 93       	push	r28
    4664:	df 93       	push	r29
    4666:	00 d0       	rcall	.+0      	; 0x4668 <_ZN5ServoC1Ev+0x6>
    4668:	cd b7       	in	r28, 0x3d	; 61
    466a:	de b7       	in	r29, 0x3e	; 62
    466c:	9a 83       	std	Y+2, r25	; 0x02
    466e:	89 83       	std	Y+1, r24	; 0x01
{
  if( ServoCount < MAX_SERVOS) {
    4670:	80 91 28 07 	lds	r24, 0x0728
    4674:	8c 30       	cpi	r24, 0x0C	; 12
    4676:	e8 f4       	brcc	.+58     	; 0x46b2 <_ZN5ServoC1Ev+0x50>
    this->servoIndex = ServoCount++;                    // assign a servo index to this instance
    4678:	20 91 28 07 	lds	r18, 0x0728
    467c:	89 81       	ldd	r24, Y+1	; 0x01
    467e:	9a 81       	ldd	r25, Y+2	; 0x02
    4680:	fc 01       	movw	r30, r24
    4682:	20 83       	st	Z, r18
    4684:	82 2f       	mov	r24, r18
    4686:	8f 5f       	subi	r24, 0xFF	; 255
    4688:	80 93 28 07 	sts	0x0728, r24
	servos[this->servoIndex].ticks = usToTicks(DEFAULT_PULSE_WIDTH);   // store default values  - 12 Aug 2009
    468c:	89 81       	ldd	r24, Y+1	; 0x01
    468e:	9a 81       	ldd	r25, Y+2	; 0x02
    4690:	fc 01       	movw	r30, r24
    4692:	80 81       	ld	r24, Z
    4694:	28 2f       	mov	r18, r24
    4696:	30 e0       	ldi	r19, 0x00	; 0
    4698:	c9 01       	movw	r24, r18
    469a:	88 0f       	add	r24, r24
    469c:	99 1f       	adc	r25, r25
    469e:	82 0f       	add	r24, r18
    46a0:	93 1f       	adc	r25, r19
    46a2:	86 5d       	subi	r24, 0xD6	; 214
    46a4:	98 4f       	sbci	r25, 0xF8	; 248
    46a6:	28 eb       	ldi	r18, 0xB8	; 184
    46a8:	3b e0       	ldi	r19, 0x0B	; 11
    46aa:	fc 01       	movw	r30, r24
    46ac:	31 83       	std	Z+1, r19	; 0x01
    46ae:	20 83       	st	Z, r18
    46b0:	05 c0       	rjmp	.+10     	; 0x46bc <_ZN5ServoC1Ev+0x5a>
  }
  else
    this->servoIndex = INVALID_SERVO ;  // too many servos 
    46b2:	89 81       	ldd	r24, Y+1	; 0x01
    46b4:	9a 81       	ldd	r25, Y+2	; 0x02
    46b6:	2f ef       	ldi	r18, 0xFF	; 255
    46b8:	fc 01       	movw	r30, r24
    46ba:	20 83       	st	Z, r18
}
    46bc:	0f 90       	pop	r0
    46be:	0f 90       	pop	r0
    46c0:	df 91       	pop	r29
    46c2:	cf 91       	pop	r28
    46c4:	08 95       	ret

000046c6 <_ZN5Servo6attachEi>:

uint8_t Servo::attach(int pin)
{
    46c6:	cf 93       	push	r28
    46c8:	df 93       	push	r29
    46ca:	00 d0       	rcall	.+0      	; 0x46cc <_ZN5Servo6attachEi+0x6>
    46cc:	00 d0       	rcall	.+0      	; 0x46ce <_ZN5Servo6attachEi+0x8>
    46ce:	cd b7       	in	r28, 0x3d	; 61
    46d0:	de b7       	in	r29, 0x3e	; 62
    46d2:	9a 83       	std	Y+2, r25	; 0x02
    46d4:	89 83       	std	Y+1, r24	; 0x01
    46d6:	7c 83       	std	Y+4, r23	; 0x04
    46d8:	6b 83       	std	Y+3, r22	; 0x03
  return this->attach(pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);
    46da:	6b 81       	ldd	r22, Y+3	; 0x03
    46dc:	7c 81       	ldd	r23, Y+4	; 0x04
    46de:	89 81       	ldd	r24, Y+1	; 0x01
    46e0:	9a 81       	ldd	r25, Y+2	; 0x02
    46e2:	20 e6       	ldi	r18, 0x60	; 96
    46e4:	39 e0       	ldi	r19, 0x09	; 9
    46e6:	40 e2       	ldi	r20, 0x20	; 32
    46e8:	52 e0       	ldi	r21, 0x02	; 2
    46ea:	0e 94 7e 23 	call	0x46fc	; 0x46fc <_ZN5Servo6attachEiii>
}
    46ee:	0f 90       	pop	r0
    46f0:	0f 90       	pop	r0
    46f2:	0f 90       	pop	r0
    46f4:	0f 90       	pop	r0
    46f6:	df 91       	pop	r29
    46f8:	cf 91       	pop	r28
    46fa:	08 95       	ret

000046fc <_ZN5Servo6attachEiii>:

uint8_t Servo::attach(int pin, int min, int max)
{
    46fc:	cf 93       	push	r28
    46fe:	df 93       	push	r29
    4700:	cd b7       	in	r28, 0x3d	; 61
    4702:	de b7       	in	r29, 0x3e	; 62
    4704:	29 97       	sbiw	r28, 0x09	; 9
    4706:	0f b6       	in	r0, 0x3f	; 63
    4708:	f8 94       	cli
    470a:	de bf       	out	0x3e, r29	; 62
    470c:	0f be       	out	0x3f, r0	; 63
    470e:	cd bf       	out	0x3d, r28	; 61
    4710:	9b 83       	std	Y+3, r25	; 0x03
    4712:	8a 83       	std	Y+2, r24	; 0x02
    4714:	7d 83       	std	Y+5, r23	; 0x05
    4716:	6c 83       	std	Y+4, r22	; 0x04
    4718:	5f 83       	std	Y+7, r21	; 0x07
    471a:	4e 83       	std	Y+6, r20	; 0x06
    471c:	39 87       	std	Y+9, r19	; 0x09
    471e:	28 87       	std	Y+8, r18	; 0x08
  if(this->servoIndex < MAX_SERVOS ) {
    4720:	8a 81       	ldd	r24, Y+2	; 0x02
    4722:	9b 81       	ldd	r25, Y+3	; 0x03
    4724:	fc 01       	movw	r30, r24
    4726:	80 81       	ld	r24, Z
    4728:	8c 30       	cpi	r24, 0x0C	; 12
    472a:	08 f0       	brcs	.+2      	; 0x472e <_ZN5Servo6attachEiii+0x32>
    472c:	6f c0       	rjmp	.+222    	; 0x480c <_ZN5Servo6attachEiii+0x110>
    pinMode( pin, OUTPUT) ;                                   // set servo pin to output
    472e:	8c 81       	ldd	r24, Y+4	; 0x04
    4730:	61 e0       	ldi	r22, 0x01	; 1
    4732:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
    servos[this->servoIndex].Pin.nbr = pin;  
    4736:	8a 81       	ldd	r24, Y+2	; 0x02
    4738:	9b 81       	ldd	r25, Y+3	; 0x03
    473a:	fc 01       	movw	r30, r24
    473c:	80 81       	ld	r24, Z
    473e:	28 2f       	mov	r18, r24
    4740:	30 e0       	ldi	r19, 0x00	; 0
    4742:	8c 81       	ldd	r24, Y+4	; 0x04
    4744:	48 2f       	mov	r20, r24
    4746:	4f 73       	andi	r20, 0x3F	; 63
    4748:	c9 01       	movw	r24, r18
    474a:	88 0f       	add	r24, r24
    474c:	99 1f       	adc	r25, r25
    474e:	82 0f       	add	r24, r18
    4750:	93 1f       	adc	r25, r19
    4752:	87 5d       	subi	r24, 0xD7	; 215
    4754:	98 4f       	sbci	r25, 0xF8	; 248
    4756:	24 2f       	mov	r18, r20
    4758:	2f 73       	andi	r18, 0x3F	; 63
    475a:	fc 01       	movw	r30, r24
    475c:	30 81       	ld	r19, Z
    475e:	30 7c       	andi	r19, 0xC0	; 192
    4760:	23 2b       	or	r18, r19
    4762:	fc 01       	movw	r30, r24
    4764:	20 83       	st	Z, r18
    // todo min/max check: abs(min - MIN_PULSE_WIDTH) /4 < 128 
    this->min  = (MIN_PULSE_WIDTH - min)/4; //resolution of min/max is 4 uS
    4766:	20 e2       	ldi	r18, 0x20	; 32
    4768:	32 e0       	ldi	r19, 0x02	; 2
    476a:	8e 81       	ldd	r24, Y+6	; 0x06
    476c:	9f 81       	ldd	r25, Y+7	; 0x07
    476e:	a9 01       	movw	r20, r18
    4770:	48 1b       	sub	r20, r24
    4772:	59 0b       	sbc	r21, r25
    4774:	ca 01       	movw	r24, r20
    4776:	99 23       	and	r25, r25
    4778:	0c f4       	brge	.+2      	; 0x477c <_ZN5Servo6attachEiii+0x80>
    477a:	03 96       	adiw	r24, 0x03	; 3
    477c:	95 95       	asr	r25
    477e:	87 95       	ror	r24
    4780:	95 95       	asr	r25
    4782:	87 95       	ror	r24
    4784:	28 2f       	mov	r18, r24
    4786:	8a 81       	ldd	r24, Y+2	; 0x02
    4788:	9b 81       	ldd	r25, Y+3	; 0x03
    478a:	fc 01       	movw	r30, r24
    478c:	21 83       	std	Z+1, r18	; 0x01
    this->max  = (MAX_PULSE_WIDTH - max)/4; 
    478e:	20 e6       	ldi	r18, 0x60	; 96
    4790:	39 e0       	ldi	r19, 0x09	; 9
    4792:	88 85       	ldd	r24, Y+8	; 0x08
    4794:	99 85       	ldd	r25, Y+9	; 0x09
    4796:	a9 01       	movw	r20, r18
    4798:	48 1b       	sub	r20, r24
    479a:	59 0b       	sbc	r21, r25
    479c:	ca 01       	movw	r24, r20
    479e:	99 23       	and	r25, r25
    47a0:	0c f4       	brge	.+2      	; 0x47a4 <_ZN5Servo6attachEiii+0xa8>
    47a2:	03 96       	adiw	r24, 0x03	; 3
    47a4:	95 95       	asr	r25
    47a6:	87 95       	ror	r24
    47a8:	95 95       	asr	r25
    47aa:	87 95       	ror	r24
    47ac:	28 2f       	mov	r18, r24
    47ae:	8a 81       	ldd	r24, Y+2	; 0x02
    47b0:	9b 81       	ldd	r25, Y+3	; 0x03
    47b2:	fc 01       	movw	r30, r24
    47b4:	22 83       	std	Z+2, r18	; 0x02
    // initialize the timer if it has not already been initialized 
    timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);
    47b6:	8a 81       	ldd	r24, Y+2	; 0x02
    47b8:	9b 81       	ldd	r25, Y+3	; 0x03
    47ba:	fc 01       	movw	r30, r24
    47bc:	90 81       	ld	r25, Z
    47be:	8b ea       	ldi	r24, 0xAB	; 171
    47c0:	98 9f       	mul	r25, r24
    47c2:	81 2d       	mov	r24, r1
    47c4:	11 24       	eor	r1, r1
    47c6:	86 95       	lsr	r24
    47c8:	86 95       	lsr	r24
    47ca:	86 95       	lsr	r24
    47cc:	89 83       	std	Y+1, r24	; 0x01
    if(isTimerActive(timer) == false)
    47ce:	89 81       	ldd	r24, Y+1	; 0x01
    47d0:	0e 94 f7 22 	call	0x45ee	; 0x45ee <_ZL13isTimerActive18timer16_Sequence_t>
    47d4:	98 2f       	mov	r25, r24
    47d6:	81 e0       	ldi	r24, 0x01	; 1
    47d8:	99 23       	and	r25, r25
    47da:	09 f0       	breq	.+2      	; 0x47de <_ZN5Servo6attachEiii+0xe2>
    47dc:	80 e0       	ldi	r24, 0x00	; 0
    47de:	88 23       	and	r24, r24
    47e0:	19 f0       	breq	.+6      	; 0x47e8 <_ZN5Servo6attachEiii+0xec>
      initISR(timer);    
    47e2:	89 81       	ldd	r24, Y+1	; 0x01
    47e4:	0e 94 c0 22 	call	0x4580	; 0x4580 <_ZL7initISR18timer16_Sequence_t>
    servos[this->servoIndex].Pin.isActive = true;  // this must be set after the check for isTimerActive
    47e8:	8a 81       	ldd	r24, Y+2	; 0x02
    47ea:	9b 81       	ldd	r25, Y+3	; 0x03
    47ec:	fc 01       	movw	r30, r24
    47ee:	80 81       	ld	r24, Z
    47f0:	28 2f       	mov	r18, r24
    47f2:	30 e0       	ldi	r19, 0x00	; 0
    47f4:	c9 01       	movw	r24, r18
    47f6:	88 0f       	add	r24, r24
    47f8:	99 1f       	adc	r25, r25
    47fa:	82 0f       	add	r24, r18
    47fc:	93 1f       	adc	r25, r19
    47fe:	87 5d       	subi	r24, 0xD7	; 215
    4800:	98 4f       	sbci	r25, 0xF8	; 248
    4802:	fc 01       	movw	r30, r24
    4804:	20 81       	ld	r18, Z
    4806:	20 64       	ori	r18, 0x40	; 64
    4808:	fc 01       	movw	r30, r24
    480a:	20 83       	st	Z, r18
  } 
  return this->servoIndex ;
    480c:	8a 81       	ldd	r24, Y+2	; 0x02
    480e:	9b 81       	ldd	r25, Y+3	; 0x03
    4810:	fc 01       	movw	r30, r24
    4812:	80 81       	ld	r24, Z
}
    4814:	29 96       	adiw	r28, 0x09	; 9
    4816:	0f b6       	in	r0, 0x3f	; 63
    4818:	f8 94       	cli
    481a:	de bf       	out	0x3e, r29	; 62
    481c:	0f be       	out	0x3f, r0	; 63
    481e:	cd bf       	out	0x3d, r28	; 61
    4820:	df 91       	pop	r29
    4822:	cf 91       	pop	r28
    4824:	08 95       	ret

00004826 <_ZN5Servo6detachEv>:

void Servo::detach()  
{
    4826:	cf 93       	push	r28
    4828:	df 93       	push	r29
    482a:	00 d0       	rcall	.+0      	; 0x482c <_ZN5Servo6detachEv+0x6>
    482c:	1f 92       	push	r1
    482e:	cd b7       	in	r28, 0x3d	; 61
    4830:	de b7       	in	r29, 0x3e	; 62
    4832:	9b 83       	std	Y+3, r25	; 0x03
    4834:	8a 83       	std	Y+2, r24	; 0x02
  servos[this->servoIndex].Pin.isActive = false;  
    4836:	8a 81       	ldd	r24, Y+2	; 0x02
    4838:	9b 81       	ldd	r25, Y+3	; 0x03
    483a:	fc 01       	movw	r30, r24
    483c:	80 81       	ld	r24, Z
    483e:	28 2f       	mov	r18, r24
    4840:	30 e0       	ldi	r19, 0x00	; 0
    4842:	c9 01       	movw	r24, r18
    4844:	88 0f       	add	r24, r24
    4846:	99 1f       	adc	r25, r25
    4848:	82 0f       	add	r24, r18
    484a:	93 1f       	adc	r25, r19
    484c:	87 5d       	subi	r24, 0xD7	; 215
    484e:	98 4f       	sbci	r25, 0xF8	; 248
    4850:	fc 01       	movw	r30, r24
    4852:	20 81       	ld	r18, Z
    4854:	2f 7b       	andi	r18, 0xBF	; 191
    4856:	fc 01       	movw	r30, r24
    4858:	20 83       	st	Z, r18
  timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);
    485a:	8a 81       	ldd	r24, Y+2	; 0x02
    485c:	9b 81       	ldd	r25, Y+3	; 0x03
    485e:	fc 01       	movw	r30, r24
    4860:	90 81       	ld	r25, Z
    4862:	8b ea       	ldi	r24, 0xAB	; 171
    4864:	98 9f       	mul	r25, r24
    4866:	81 2d       	mov	r24, r1
    4868:	11 24       	eor	r1, r1
    486a:	86 95       	lsr	r24
    486c:	86 95       	lsr	r24
    486e:	86 95       	lsr	r24
    4870:	89 83       	std	Y+1, r24	; 0x01
  if(isTimerActive(timer) == false) {
    4872:	89 81       	ldd	r24, Y+1	; 0x01
    4874:	0e 94 f7 22 	call	0x45ee	; 0x45ee <_ZL13isTimerActive18timer16_Sequence_t>
    4878:	98 2f       	mov	r25, r24
    487a:	81 e0       	ldi	r24, 0x01	; 1
    487c:	99 23       	and	r25, r25
    487e:	09 f0       	breq	.+2      	; 0x4882 <_ZN5Servo6detachEv+0x5c>
    4880:	80 e0       	ldi	r24, 0x00	; 0
    4882:	88 23       	and	r24, r24
    4884:	19 f0       	breq	.+6      	; 0x488c <_ZN5Servo6detachEv+0x66>
    finISR(timer);
    4886:	89 81       	ldd	r24, Y+1	; 0x01
    4888:	0e 94 ed 22 	call	0x45da	; 0x45da <_ZL6finISR18timer16_Sequence_t>
  }
}
    488c:	0f 90       	pop	r0
    488e:	0f 90       	pop	r0
    4890:	0f 90       	pop	r0
    4892:	df 91       	pop	r29
    4894:	cf 91       	pop	r28
    4896:	08 95       	ret

00004898 <_ZN5Servo5writeEi>:

void Servo::write(int value)
{  
    4898:	6f 92       	push	r6
    489a:	7f 92       	push	r7
    489c:	8f 92       	push	r8
    489e:	9f 92       	push	r9
    48a0:	af 92       	push	r10
    48a2:	bf 92       	push	r11
    48a4:	cf 92       	push	r12
    48a6:	df 92       	push	r13
    48a8:	ef 92       	push	r14
    48aa:	ff 92       	push	r15
    48ac:	0f 93       	push	r16
    48ae:	1f 93       	push	r17
    48b0:	cf 93       	push	r28
    48b2:	df 93       	push	r29
    48b4:	00 d0       	rcall	.+0      	; 0x48b6 <_ZN5Servo5writeEi+0x1e>
    48b6:	00 d0       	rcall	.+0      	; 0x48b8 <_ZN5Servo5writeEi+0x20>
    48b8:	cd b7       	in	r28, 0x3d	; 61
    48ba:	de b7       	in	r29, 0x3e	; 62
    48bc:	9a 83       	std	Y+2, r25	; 0x02
    48be:	89 83       	std	Y+1, r24	; 0x01
    48c0:	7c 83       	std	Y+4, r23	; 0x04
    48c2:	6b 83       	std	Y+3, r22	; 0x03
  if(value < MIN_PULSE_WIDTH)
    48c4:	8b 81       	ldd	r24, Y+3	; 0x03
    48c6:	9c 81       	ldd	r25, Y+4	; 0x04
    48c8:	80 32       	cpi	r24, 0x20	; 32
    48ca:	22 e0       	ldi	r18, 0x02	; 2
    48cc:	92 07       	cpc	r25, r18
    48ce:	0c f0       	brlt	.+2      	; 0x48d2 <_ZN5Servo5writeEi+0x3a>
    48d0:	5d c0       	rjmp	.+186    	; 0x498c <_ZN5Servo5writeEi+0xf4>
  {  // treat values less than 544 as angles in degrees (valid values in microseconds are handled as microseconds)
    if(value < 0) value = 0;
    48d2:	8b 81       	ldd	r24, Y+3	; 0x03
    48d4:	9c 81       	ldd	r25, Y+4	; 0x04
    48d6:	99 23       	and	r25, r25
    48d8:	14 f4       	brge	.+4      	; 0x48de <_ZN5Servo5writeEi+0x46>
    48da:	1c 82       	std	Y+4, r1	; 0x04
    48dc:	1b 82       	std	Y+3, r1	; 0x03
    if(value > 180) value = 180;
    48de:	8b 81       	ldd	r24, Y+3	; 0x03
    48e0:	9c 81       	ldd	r25, Y+4	; 0x04
    48e2:	85 3b       	cpi	r24, 0xB5	; 181
    48e4:	91 05       	cpc	r25, r1
    48e6:	24 f0       	brlt	.+8      	; 0x48f0 <_ZN5Servo5writeEi+0x58>
    48e8:	84 eb       	ldi	r24, 0xB4	; 180
    48ea:	90 e0       	ldi	r25, 0x00	; 0
    48ec:	9c 83       	std	Y+4, r25	; 0x04
    48ee:	8b 83       	std	Y+3, r24	; 0x03
    value = map(value, 0, 180, SERVO_MIN(),  SERVO_MAX());      
    48f0:	89 81       	ldd	r24, Y+1	; 0x01
    48f2:	9a 81       	ldd	r25, Y+2	; 0x02
    48f4:	fc 01       	movw	r30, r24
    48f6:	82 81       	ldd	r24, Z+2	; 0x02
    48f8:	99 27       	eor	r25, r25
    48fa:	87 fd       	sbrc	r24, 7
    48fc:	90 95       	com	r25
    48fe:	28 e5       	ldi	r18, 0x58	; 88
    4900:	32 e0       	ldi	r19, 0x02	; 2
    4902:	a9 01       	movw	r20, r18
    4904:	48 1b       	sub	r20, r24
    4906:	59 0b       	sbc	r21, r25
    4908:	ca 01       	movw	r24, r20
    490a:	88 0f       	add	r24, r24
    490c:	99 1f       	adc	r25, r25
    490e:	88 0f       	add	r24, r24
    4910:	99 1f       	adc	r25, r25
    4912:	aa 27       	eor	r26, r26
    4914:	97 fd       	sbrc	r25, 7
    4916:	a0 95       	com	r26
    4918:	ba 2f       	mov	r27, r26
    491a:	29 81       	ldd	r18, Y+1	; 0x01
    491c:	3a 81       	ldd	r19, Y+2	; 0x02
    491e:	f9 01       	movw	r30, r18
    4920:	21 81       	ldd	r18, Z+1	; 0x01
    4922:	33 27       	eor	r19, r19
    4924:	27 fd       	sbrc	r18, 7
    4926:	30 95       	com	r19
    4928:	48 e8       	ldi	r20, 0x88	; 136
    492a:	50 e0       	ldi	r21, 0x00	; 0
    492c:	ba 01       	movw	r22, r20
    492e:	62 1b       	sub	r22, r18
    4930:	73 0b       	sbc	r23, r19
    4932:	9b 01       	movw	r18, r22
    4934:	22 0f       	add	r18, r18
    4936:	33 1f       	adc	r19, r19
    4938:	22 0f       	add	r18, r18
    493a:	33 1f       	adc	r19, r19
    493c:	44 27       	eor	r20, r20
    493e:	37 fd       	sbrc	r19, 7
    4940:	40 95       	com	r20
    4942:	54 2f       	mov	r21, r20
    4944:	6b 81       	ldd	r22, Y+3	; 0x03
    4946:	7c 81       	ldd	r23, Y+4	; 0x04
    4948:	3b 01       	movw	r6, r22
    494a:	88 24       	eor	r8, r8
    494c:	77 fc       	sbrc	r7, 7
    494e:	80 94       	com	r8
    4950:	98 2c       	mov	r9, r8
    4952:	6b 2f       	mov	r22, r27
    4954:	6f 93       	push	r22
    4956:	6a 2f       	mov	r22, r26
    4958:	6f 93       	push	r22
    495a:	69 2f       	mov	r22, r25
    495c:	6f 93       	push	r22
    495e:	8f 93       	push	r24
    4960:	59 01       	movw	r10, r18
    4962:	6a 01       	movw	r12, r20
    4964:	14 eb       	ldi	r17, 0xB4	; 180
    4966:	e1 2e       	mov	r14, r17
    4968:	f1 2c       	mov	r15, r1
    496a:	00 e0       	ldi	r16, 0x00	; 0
    496c:	10 e0       	ldi	r17, 0x00	; 0
    496e:	20 e0       	ldi	r18, 0x00	; 0
    4970:	30 e0       	ldi	r19, 0x00	; 0
    4972:	a9 01       	movw	r20, r18
    4974:	c4 01       	movw	r24, r8
    4976:	b3 01       	movw	r22, r6
    4978:	0e 94 a3 6c 	call	0xd946	; 0xd946 <_Z3maplllll>
    497c:	0f 90       	pop	r0
    497e:	0f 90       	pop	r0
    4980:	0f 90       	pop	r0
    4982:	0f 90       	pop	r0
    4984:	dc 01       	movw	r26, r24
    4986:	cb 01       	movw	r24, r22
    4988:	9c 83       	std	Y+4, r25	; 0x04
    498a:	8b 83       	std	Y+3, r24	; 0x03
  }
  this->writeMicroseconds(value);
    498c:	2b 81       	ldd	r18, Y+3	; 0x03
    498e:	3c 81       	ldd	r19, Y+4	; 0x04
    4990:	89 81       	ldd	r24, Y+1	; 0x01
    4992:	9a 81       	ldd	r25, Y+2	; 0x02
    4994:	b9 01       	movw	r22, r18
    4996:	0e 94 e0 24 	call	0x49c0	; 0x49c0 <_ZN5Servo17writeMicrosecondsEi>
}
    499a:	0f 90       	pop	r0
    499c:	0f 90       	pop	r0
    499e:	0f 90       	pop	r0
    49a0:	0f 90       	pop	r0
    49a2:	df 91       	pop	r29
    49a4:	cf 91       	pop	r28
    49a6:	1f 91       	pop	r17
    49a8:	0f 91       	pop	r16
    49aa:	ff 90       	pop	r15
    49ac:	ef 90       	pop	r14
    49ae:	df 90       	pop	r13
    49b0:	cf 90       	pop	r12
    49b2:	bf 90       	pop	r11
    49b4:	af 90       	pop	r10
    49b6:	9f 90       	pop	r9
    49b8:	8f 90       	pop	r8
    49ba:	7f 90       	pop	r7
    49bc:	6f 90       	pop	r6
    49be:	08 95       	ret

000049c0 <_ZN5Servo17writeMicrosecondsEi>:

void Servo::writeMicroseconds(int value)
{
    49c0:	cf 93       	push	r28
    49c2:	df 93       	push	r29
    49c4:	00 d0       	rcall	.+0      	; 0x49c6 <_ZN5Servo17writeMicrosecondsEi+0x6>
    49c6:	00 d0       	rcall	.+0      	; 0x49c8 <_ZN5Servo17writeMicrosecondsEi+0x8>
    49c8:	00 d0       	rcall	.+0      	; 0x49ca <_ZN5Servo17writeMicrosecondsEi+0xa>
    49ca:	cd b7       	in	r28, 0x3d	; 61
    49cc:	de b7       	in	r29, 0x3e	; 62
    49ce:	9c 83       	std	Y+4, r25	; 0x04
    49d0:	8b 83       	std	Y+3, r24	; 0x03
    49d2:	7e 83       	std	Y+6, r23	; 0x06
    49d4:	6d 83       	std	Y+5, r22	; 0x05
  // calculate and store the values for the given channel
  byte channel = this->servoIndex;
    49d6:	8b 81       	ldd	r24, Y+3	; 0x03
    49d8:	9c 81       	ldd	r25, Y+4	; 0x04
    49da:	fc 01       	movw	r30, r24
    49dc:	80 81       	ld	r24, Z
    49de:	89 83       	std	Y+1, r24	; 0x01
  if( (channel < MAX_SERVOS) )   // ensure channel is valid
    49e0:	89 81       	ldd	r24, Y+1	; 0x01
    49e2:	8c 30       	cpi	r24, 0x0C	; 12
    49e4:	08 f0       	brcs	.+2      	; 0x49e8 <_ZN5Servo17writeMicrosecondsEi+0x28>
    49e6:	94 c0       	rjmp	.+296    	; 0x4b10 <_ZN5Servo17writeMicrosecondsEi+0x150>
  {  
    if( value < SERVO_MIN() )          // ensure pulse width is valid
    49e8:	8b 81       	ldd	r24, Y+3	; 0x03
    49ea:	9c 81       	ldd	r25, Y+4	; 0x04
    49ec:	fc 01       	movw	r30, r24
    49ee:	81 81       	ldd	r24, Z+1	; 0x01
    49f0:	99 27       	eor	r25, r25
    49f2:	87 fd       	sbrc	r24, 7
    49f4:	90 95       	com	r25
    49f6:	28 e8       	ldi	r18, 0x88	; 136
    49f8:	30 e0       	ldi	r19, 0x00	; 0
    49fa:	a9 01       	movw	r20, r18
    49fc:	48 1b       	sub	r20, r24
    49fe:	59 0b       	sbc	r21, r25
    4a00:	ca 01       	movw	r24, r20
    4a02:	9c 01       	movw	r18, r24
    4a04:	22 0f       	add	r18, r18
    4a06:	33 1f       	adc	r19, r19
    4a08:	22 0f       	add	r18, r18
    4a0a:	33 1f       	adc	r19, r19
    4a0c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a0e:	9e 81       	ldd	r25, Y+6	; 0x06
    4a10:	82 17       	cp	r24, r18
    4a12:	93 07       	cpc	r25, r19
    4a14:	a4 f4       	brge	.+40     	; 0x4a3e <_ZN5Servo17writeMicrosecondsEi+0x7e>
      value = SERVO_MIN();
    4a16:	8b 81       	ldd	r24, Y+3	; 0x03
    4a18:	9c 81       	ldd	r25, Y+4	; 0x04
    4a1a:	fc 01       	movw	r30, r24
    4a1c:	81 81       	ldd	r24, Z+1	; 0x01
    4a1e:	99 27       	eor	r25, r25
    4a20:	87 fd       	sbrc	r24, 7
    4a22:	90 95       	com	r25
    4a24:	28 e8       	ldi	r18, 0x88	; 136
    4a26:	30 e0       	ldi	r19, 0x00	; 0
    4a28:	a9 01       	movw	r20, r18
    4a2a:	48 1b       	sub	r20, r24
    4a2c:	59 0b       	sbc	r21, r25
    4a2e:	ca 01       	movw	r24, r20
    4a30:	88 0f       	add	r24, r24
    4a32:	99 1f       	adc	r25, r25
    4a34:	88 0f       	add	r24, r24
    4a36:	99 1f       	adc	r25, r25
    4a38:	9e 83       	std	Y+6, r25	; 0x06
    4a3a:	8d 83       	std	Y+5, r24	; 0x05
    4a3c:	2a c0       	rjmp	.+84     	; 0x4a92 <_ZN5Servo17writeMicrosecondsEi+0xd2>
    else if( value > SERVO_MAX() )
    4a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    4a40:	9c 81       	ldd	r25, Y+4	; 0x04
    4a42:	fc 01       	movw	r30, r24
    4a44:	82 81       	ldd	r24, Z+2	; 0x02
    4a46:	99 27       	eor	r25, r25
    4a48:	87 fd       	sbrc	r24, 7
    4a4a:	90 95       	com	r25
    4a4c:	28 e5       	ldi	r18, 0x58	; 88
    4a4e:	32 e0       	ldi	r19, 0x02	; 2
    4a50:	a9 01       	movw	r20, r18
    4a52:	48 1b       	sub	r20, r24
    4a54:	59 0b       	sbc	r21, r25
    4a56:	ca 01       	movw	r24, r20
    4a58:	9c 01       	movw	r18, r24
    4a5a:	22 0f       	add	r18, r18
    4a5c:	33 1f       	adc	r19, r19
    4a5e:	22 0f       	add	r18, r18
    4a60:	33 1f       	adc	r19, r19
    4a62:	8d 81       	ldd	r24, Y+5	; 0x05
    4a64:	9e 81       	ldd	r25, Y+6	; 0x06
    4a66:	28 17       	cp	r18, r24
    4a68:	39 07       	cpc	r19, r25
    4a6a:	9c f4       	brge	.+38     	; 0x4a92 <_ZN5Servo17writeMicrosecondsEi+0xd2>
      value = SERVO_MAX();   
    4a6c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a6e:	9c 81       	ldd	r25, Y+4	; 0x04
    4a70:	fc 01       	movw	r30, r24
    4a72:	82 81       	ldd	r24, Z+2	; 0x02
    4a74:	99 27       	eor	r25, r25
    4a76:	87 fd       	sbrc	r24, 7
    4a78:	90 95       	com	r25
    4a7a:	28 e5       	ldi	r18, 0x58	; 88
    4a7c:	32 e0       	ldi	r19, 0x02	; 2
    4a7e:	a9 01       	movw	r20, r18
    4a80:	48 1b       	sub	r20, r24
    4a82:	59 0b       	sbc	r21, r25
    4a84:	ca 01       	movw	r24, r20
    4a86:	88 0f       	add	r24, r24
    4a88:	99 1f       	adc	r25, r25
    4a8a:	88 0f       	add	r24, r24
    4a8c:	99 1f       	adc	r25, r25
    4a8e:	9e 83       	std	Y+6, r25	; 0x06
    4a90:	8d 83       	std	Y+5, r24	; 0x05
    
  	value = value - TRIM_DURATION;
    4a92:	8d 81       	ldd	r24, Y+5	; 0x05
    4a94:	9e 81       	ldd	r25, Y+6	; 0x06
    4a96:	02 97       	sbiw	r24, 0x02	; 2
    4a98:	9e 83       	std	Y+6, r25	; 0x06
    4a9a:	8d 83       	std	Y+5, r24	; 0x05
    value = usToTicks(value);  // convert to ticks after compensating for interrupt overhead - 12 Aug 2009
    4a9c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a9e:	9e 81       	ldd	r25, Y+6	; 0x06
    4aa0:	aa 27       	eor	r26, r26
    4aa2:	97 fd       	sbrc	r25, 7
    4aa4:	a0 95       	com	r26
    4aa6:	ba 2f       	mov	r27, r26
    4aa8:	88 0f       	add	r24, r24
    4aaa:	99 1f       	adc	r25, r25
    4aac:	aa 1f       	adc	r26, r26
    4aae:	bb 1f       	adc	r27, r27
    4ab0:	88 0f       	add	r24, r24
    4ab2:	99 1f       	adc	r25, r25
    4ab4:	aa 1f       	adc	r26, r26
    4ab6:	bb 1f       	adc	r27, r27
    4ab8:	88 0f       	add	r24, r24
    4aba:	99 1f       	adc	r25, r25
    4abc:	aa 1f       	adc	r26, r26
    4abe:	bb 1f       	adc	r27, r27
    4ac0:	88 0f       	add	r24, r24
    4ac2:	99 1f       	adc	r25, r25
    4ac4:	aa 1f       	adc	r26, r26
    4ac6:	bb 1f       	adc	r27, r27
    4ac8:	68 94       	set
    4aca:	12 f8       	bld	r1, 2
    4acc:	b6 95       	lsr	r27
    4ace:	a7 95       	ror	r26
    4ad0:	97 95       	ror	r25
    4ad2:	87 95       	ror	r24
    4ad4:	16 94       	lsr	r1
    4ad6:	d1 f7       	brne	.-12     	; 0x4acc <_ZN5Servo17writeMicrosecondsEi+0x10c>
    4ad8:	9e 83       	std	Y+6, r25	; 0x06
    4ada:	8d 83       	std	Y+5, r24	; 0x05

    uint8_t oldSREG = SREG;
    4adc:	8f e5       	ldi	r24, 0x5F	; 95
    4ade:	90 e0       	ldi	r25, 0x00	; 0
    4ae0:	fc 01       	movw	r30, r24
    4ae2:	80 81       	ld	r24, Z
    4ae4:	8a 83       	std	Y+2, r24	; 0x02
    cli();
    4ae6:	f8 94       	cli
    servos[channel].ticks = value;  
    4ae8:	89 81       	ldd	r24, Y+1	; 0x01
    4aea:	28 2f       	mov	r18, r24
    4aec:	30 e0       	ldi	r19, 0x00	; 0
    4aee:	4d 81       	ldd	r20, Y+5	; 0x05
    4af0:	5e 81       	ldd	r21, Y+6	; 0x06
    4af2:	c9 01       	movw	r24, r18
    4af4:	88 0f       	add	r24, r24
    4af6:	99 1f       	adc	r25, r25
    4af8:	82 0f       	add	r24, r18
    4afa:	93 1f       	adc	r25, r19
    4afc:	86 5d       	subi	r24, 0xD6	; 214
    4afe:	98 4f       	sbci	r25, 0xF8	; 248
    4b00:	fc 01       	movw	r30, r24
    4b02:	51 83       	std	Z+1, r21	; 0x01
    4b04:	40 83       	st	Z, r20
    SREG = oldSREG;   
    4b06:	8f e5       	ldi	r24, 0x5F	; 95
    4b08:	90 e0       	ldi	r25, 0x00	; 0
    4b0a:	2a 81       	ldd	r18, Y+2	; 0x02
    4b0c:	fc 01       	movw	r30, r24
    4b0e:	20 83       	st	Z, r18
  } 
}
    4b10:	26 96       	adiw	r28, 0x06	; 6
    4b12:	0f b6       	in	r0, 0x3f	; 63
    4b14:	f8 94       	cli
    4b16:	de bf       	out	0x3e, r29	; 62
    4b18:	0f be       	out	0x3f, r0	; 63
    4b1a:	cd bf       	out	0x3d, r28	; 61
    4b1c:	df 91       	pop	r29
    4b1e:	cf 91       	pop	r28
    4b20:	08 95       	ret

00004b22 <_ZN5Servo4readEv>:

int Servo::read() // return the value as degrees
{
    4b22:	2f 92       	push	r2
    4b24:	3f 92       	push	r3
    4b26:	4f 92       	push	r4
    4b28:	5f 92       	push	r5
    4b2a:	6f 92       	push	r6
    4b2c:	7f 92       	push	r7
    4b2e:	8f 92       	push	r8
    4b30:	9f 92       	push	r9
    4b32:	af 92       	push	r10
    4b34:	bf 92       	push	r11
    4b36:	cf 92       	push	r12
    4b38:	df 92       	push	r13
    4b3a:	ef 92       	push	r14
    4b3c:	ff 92       	push	r15
    4b3e:	0f 93       	push	r16
    4b40:	1f 93       	push	r17
    4b42:	cf 93       	push	r28
    4b44:	df 93       	push	r29
    4b46:	00 d0       	rcall	.+0      	; 0x4b48 <_ZN5Servo4readEv+0x26>
    4b48:	cd b7       	in	r28, 0x3d	; 61
    4b4a:	de b7       	in	r29, 0x3e	; 62
    4b4c:	9a 83       	std	Y+2, r25	; 0x02
    4b4e:	89 83       	std	Y+1, r24	; 0x01
  return  map( this->readMicroseconds()+1, SERVO_MIN(), SERVO_MAX(), 0, 180);     
    4b50:	89 81       	ldd	r24, Y+1	; 0x01
    4b52:	9a 81       	ldd	r25, Y+2	; 0x02
    4b54:	fc 01       	movw	r30, r24
    4b56:	82 81       	ldd	r24, Z+2	; 0x02
    4b58:	99 27       	eor	r25, r25
    4b5a:	87 fd       	sbrc	r24, 7
    4b5c:	90 95       	com	r25
    4b5e:	28 e5       	ldi	r18, 0x58	; 88
    4b60:	32 e0       	ldi	r19, 0x02	; 2
    4b62:	a9 01       	movw	r20, r18
    4b64:	48 1b       	sub	r20, r24
    4b66:	59 0b       	sbc	r21, r25
    4b68:	ca 01       	movw	r24, r20
    4b6a:	88 0f       	add	r24, r24
    4b6c:	99 1f       	adc	r25, r25
    4b6e:	88 0f       	add	r24, r24
    4b70:	99 1f       	adc	r25, r25
    4b72:	1c 01       	movw	r2, r24
    4b74:	44 24       	eor	r4, r4
    4b76:	37 fc       	sbrc	r3, 7
    4b78:	40 94       	com	r4
    4b7a:	54 2c       	mov	r5, r4
    4b7c:	89 81       	ldd	r24, Y+1	; 0x01
    4b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b80:	fc 01       	movw	r30, r24
    4b82:	81 81       	ldd	r24, Z+1	; 0x01
    4b84:	99 27       	eor	r25, r25
    4b86:	87 fd       	sbrc	r24, 7
    4b88:	90 95       	com	r25
    4b8a:	28 e8       	ldi	r18, 0x88	; 136
    4b8c:	30 e0       	ldi	r19, 0x00	; 0
    4b8e:	a9 01       	movw	r20, r18
    4b90:	48 1b       	sub	r20, r24
    4b92:	59 0b       	sbc	r21, r25
    4b94:	ca 01       	movw	r24, r20
    4b96:	88 0f       	add	r24, r24
    4b98:	99 1f       	adc	r25, r25
    4b9a:	88 0f       	add	r24, r24
    4b9c:	99 1f       	adc	r25, r25
    4b9e:	3c 01       	movw	r6, r24
    4ba0:	88 24       	eor	r8, r8
    4ba2:	77 fc       	sbrc	r7, 7
    4ba4:	80 94       	com	r8
    4ba6:	98 2c       	mov	r9, r8
    4ba8:	89 81       	ldd	r24, Y+1	; 0x01
    4baa:	9a 81       	ldd	r25, Y+2	; 0x02
    4bac:	0e 94 08 26 	call	0x4c10	; 0x4c10 <_ZN5Servo16readMicrosecondsEv>
    4bb0:	01 96       	adiw	r24, 0x01	; 1
    4bb2:	aa 27       	eor	r26, r26
    4bb4:	97 fd       	sbrc	r25, 7
    4bb6:	a0 95       	com	r26
    4bb8:	ba 2f       	mov	r27, r26
    4bba:	1f 92       	push	r1
    4bbc:	1f 92       	push	r1
    4bbe:	1f 92       	push	r1
    4bc0:	24 eb       	ldi	r18, 0xB4	; 180
    4bc2:	2f 93       	push	r18
    4bc4:	a1 2c       	mov	r10, r1
    4bc6:	b1 2c       	mov	r11, r1
    4bc8:	65 01       	movw	r12, r10
    4bca:	82 01       	movw	r16, r4
    4bcc:	71 01       	movw	r14, r2
    4bce:	a4 01       	movw	r20, r8
    4bd0:	93 01       	movw	r18, r6
    4bd2:	bc 01       	movw	r22, r24
    4bd4:	cd 01       	movw	r24, r26
    4bd6:	0e 94 a3 6c 	call	0xd946	; 0xd946 <_Z3maplllll>
    4bda:	0f 90       	pop	r0
    4bdc:	0f 90       	pop	r0
    4bde:	0f 90       	pop	r0
    4be0:	0f 90       	pop	r0
    4be2:	dc 01       	movw	r26, r24
    4be4:	cb 01       	movw	r24, r22
}
    4be6:	0f 90       	pop	r0
    4be8:	0f 90       	pop	r0
    4bea:	df 91       	pop	r29
    4bec:	cf 91       	pop	r28
    4bee:	1f 91       	pop	r17
    4bf0:	0f 91       	pop	r16
    4bf2:	ff 90       	pop	r15
    4bf4:	ef 90       	pop	r14
    4bf6:	df 90       	pop	r13
    4bf8:	cf 90       	pop	r12
    4bfa:	bf 90       	pop	r11
    4bfc:	af 90       	pop	r10
    4bfe:	9f 90       	pop	r9
    4c00:	8f 90       	pop	r8
    4c02:	7f 90       	pop	r7
    4c04:	6f 90       	pop	r6
    4c06:	5f 90       	pop	r5
    4c08:	4f 90       	pop	r4
    4c0a:	3f 90       	pop	r3
    4c0c:	2f 90       	pop	r2
    4c0e:	08 95       	ret

00004c10 <_ZN5Servo16readMicrosecondsEv>:

int Servo::readMicroseconds()
{
    4c10:	cf 93       	push	r28
    4c12:	df 93       	push	r29
    4c14:	00 d0       	rcall	.+0      	; 0x4c16 <_ZN5Servo16readMicrosecondsEv+0x6>
    4c16:	00 d0       	rcall	.+0      	; 0x4c18 <_ZN5Servo16readMicrosecondsEv+0x8>
    4c18:	cd b7       	in	r28, 0x3d	; 61
    4c1a:	de b7       	in	r29, 0x3e	; 62
    4c1c:	9c 83       	std	Y+4, r25	; 0x04
    4c1e:	8b 83       	std	Y+3, r24	; 0x03
  unsigned int pulsewidth;
  if( this->servoIndex != INVALID_SERVO )
    4c20:	8b 81       	ldd	r24, Y+3	; 0x03
    4c22:	9c 81       	ldd	r25, Y+4	; 0x04
    4c24:	fc 01       	movw	r30, r24
    4c26:	80 81       	ld	r24, Z
    4c28:	8f 3f       	cpi	r24, 0xFF	; 255
    4c2a:	01 f1       	breq	.+64     	; 0x4c6c <_ZN5Servo16readMicrosecondsEv+0x5c>
    pulsewidth = ticksToUs(servos[this->servoIndex].ticks)  + TRIM_DURATION ;   // 12 aug 2009
    4c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4c30:	fc 01       	movw	r30, r24
    4c32:	80 81       	ld	r24, Z
    4c34:	28 2f       	mov	r18, r24
    4c36:	30 e0       	ldi	r19, 0x00	; 0
    4c38:	c9 01       	movw	r24, r18
    4c3a:	88 0f       	add	r24, r24
    4c3c:	99 1f       	adc	r25, r25
    4c3e:	82 0f       	add	r24, r18
    4c40:	93 1f       	adc	r25, r19
    4c42:	86 5d       	subi	r24, 0xD6	; 214
    4c44:	98 4f       	sbci	r25, 0xF8	; 248
    4c46:	fc 01       	movw	r30, r24
    4c48:	80 81       	ld	r24, Z
    4c4a:	91 81       	ldd	r25, Z+1	; 0x01
    4c4c:	88 0f       	add	r24, r24
    4c4e:	99 1f       	adc	r25, r25
    4c50:	88 0f       	add	r24, r24
    4c52:	99 1f       	adc	r25, r25
    4c54:	88 0f       	add	r24, r24
    4c56:	99 1f       	adc	r25, r25
    4c58:	92 95       	swap	r25
    4c5a:	82 95       	swap	r24
    4c5c:	8f 70       	andi	r24, 0x0F	; 15
    4c5e:	89 27       	eor	r24, r25
    4c60:	9f 70       	andi	r25, 0x0F	; 15
    4c62:	89 27       	eor	r24, r25
    4c64:	02 96       	adiw	r24, 0x02	; 2
    4c66:	9a 83       	std	Y+2, r25	; 0x02
    4c68:	89 83       	std	Y+1, r24	; 0x01
    4c6a:	02 c0       	rjmp	.+4      	; 0x4c70 <_ZN5Servo16readMicrosecondsEv+0x60>
  else 
    pulsewidth  = 0;
    4c6c:	1a 82       	std	Y+2, r1	; 0x02
    4c6e:	19 82       	std	Y+1, r1	; 0x01

  return pulsewidth;   
    4c70:	89 81       	ldd	r24, Y+1	; 0x01
    4c72:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4c74:	0f 90       	pop	r0
    4c76:	0f 90       	pop	r0
    4c78:	0f 90       	pop	r0
    4c7a:	0f 90       	pop	r0
    4c7c:	df 91       	pop	r29
    4c7e:	cf 91       	pop	r28
    4c80:	08 95       	ret

00004c82 <_ZN5Servo8attachedEv>:

bool Servo::attached()
{
    4c82:	cf 93       	push	r28
    4c84:	df 93       	push	r29
    4c86:	00 d0       	rcall	.+0      	; 0x4c88 <_ZN5Servo8attachedEv+0x6>
    4c88:	cd b7       	in	r28, 0x3d	; 61
    4c8a:	de b7       	in	r29, 0x3e	; 62
    4c8c:	9a 83       	std	Y+2, r25	; 0x02
    4c8e:	89 83       	std	Y+1, r24	; 0x01
  return servos[this->servoIndex].Pin.isActive ;
    4c90:	89 81       	ldd	r24, Y+1	; 0x01
    4c92:	9a 81       	ldd	r25, Y+2	; 0x02
    4c94:	fc 01       	movw	r30, r24
    4c96:	80 81       	ld	r24, Z
    4c98:	28 2f       	mov	r18, r24
    4c9a:	30 e0       	ldi	r19, 0x00	; 0
    4c9c:	c9 01       	movw	r24, r18
    4c9e:	88 0f       	add	r24, r24
    4ca0:	99 1f       	adc	r25, r25
    4ca2:	82 0f       	add	r24, r18
    4ca4:	93 1f       	adc	r25, r19
    4ca6:	87 5d       	subi	r24, 0xD7	; 215
    4ca8:	98 4f       	sbci	r25, 0xF8	; 248
    4caa:	fc 01       	movw	r30, r24
    4cac:	80 81       	ld	r24, Z
    4cae:	86 fb       	bst	r24, 6
    4cb0:	99 27       	eor	r25, r25
    4cb2:	90 f9       	bld	r25, 0
    4cb4:	81 e0       	ldi	r24, 0x01	; 1
    4cb6:	99 23       	and	r25, r25
    4cb8:	09 f4       	brne	.+2      	; 0x4cbc <_ZN5Servo8attachedEv+0x3a>
    4cba:	80 e0       	ldi	r24, 0x00	; 0
}
    4cbc:	0f 90       	pop	r0
    4cbe:	0f 90       	pop	r0
    4cc0:	df 91       	pop	r29
    4cc2:	cf 91       	pop	r28
    4cc4:	08 95       	ret

00004cc6 <_ZN8SPIClass5beginEv>:
#include "pins_arduino.h"
#include "SPI.h"

SPIClass SPI;

void SPIClass::begin() {
    4cc6:	cf 93       	push	r28
    4cc8:	df 93       	push	r29
    4cca:	cd b7       	in	r28, 0x3d	; 61
    4ccc:	de b7       	in	r29, 0x3e	; 62

  // Set SS to high so a connected chip will be "deselected" by default
  digitalWrite(SS, HIGH);
    4cce:	61 e0       	ldi	r22, 0x01	; 1
    4cd0:	8a e0       	ldi	r24, 0x0A	; 10
    4cd2:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>

  // When the SS pin is set as OUTPUT, it can be used as
  // a general purpose output port (it doesn't influence
  // SPI operations).
  pinMode(SS, OUTPUT);
    4cd6:	61 e0       	ldi	r22, 0x01	; 1
    4cd8:	8a e0       	ldi	r24, 0x0A	; 10
    4cda:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>

  // Warning: if the SS pin ever becomes a LOW INPUT then SPI
  // automatically switches to Slave, so the data direction of
  // the SS pin MUST be kept as OUTPUT.
  SPCR |= _BV(MSTR);
    4cde:	8c e4       	ldi	r24, 0x4C	; 76
    4ce0:	90 e0       	ldi	r25, 0x00	; 0
    4ce2:	2c e4       	ldi	r18, 0x4C	; 76
    4ce4:	30 e0       	ldi	r19, 0x00	; 0
    4ce6:	f9 01       	movw	r30, r18
    4ce8:	20 81       	ld	r18, Z
    4cea:	20 61       	ori	r18, 0x10	; 16
    4cec:	fc 01       	movw	r30, r24
    4cee:	20 83       	st	Z, r18
  SPCR |= _BV(SPE);
    4cf0:	8c e4       	ldi	r24, 0x4C	; 76
    4cf2:	90 e0       	ldi	r25, 0x00	; 0
    4cf4:	2c e4       	ldi	r18, 0x4C	; 76
    4cf6:	30 e0       	ldi	r19, 0x00	; 0
    4cf8:	f9 01       	movw	r30, r18
    4cfa:	20 81       	ld	r18, Z
    4cfc:	20 64       	ori	r18, 0x40	; 64
    4cfe:	fc 01       	movw	r30, r24
    4d00:	20 83       	st	Z, r18
  // MISO pin automatically overrides to INPUT.
  // By doing this AFTER enabling SPI, we avoid accidentally
  // clocking in a single bit since the lines go directly
  // from "input" to SPI control.  
  // http://code.google.com/p/arduino/issues/detail?id=888
  pinMode(SCK, OUTPUT);
    4d02:	61 e0       	ldi	r22, 0x01	; 1
    4d04:	8d e0       	ldi	r24, 0x0D	; 13
    4d06:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
  pinMode(MOSI, OUTPUT);
    4d0a:	61 e0       	ldi	r22, 0x01	; 1
    4d0c:	8b e0       	ldi	r24, 0x0B	; 11
    4d0e:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
}
    4d12:	df 91       	pop	r29
    4d14:	cf 91       	pop	r28
    4d16:	08 95       	ret

00004d18 <_ZN8SPIClass3endEv>:


void SPIClass::end() {
    4d18:	cf 93       	push	r28
    4d1a:	df 93       	push	r29
    4d1c:	cd b7       	in	r28, 0x3d	; 61
    4d1e:	de b7       	in	r29, 0x3e	; 62
  SPCR &= ~_BV(SPE);
    4d20:	8c e4       	ldi	r24, 0x4C	; 76
    4d22:	90 e0       	ldi	r25, 0x00	; 0
    4d24:	2c e4       	ldi	r18, 0x4C	; 76
    4d26:	30 e0       	ldi	r19, 0x00	; 0
    4d28:	f9 01       	movw	r30, r18
    4d2a:	20 81       	ld	r18, Z
    4d2c:	2f 7b       	andi	r18, 0xBF	; 191
    4d2e:	fc 01       	movw	r30, r24
    4d30:	20 83       	st	Z, r18
}
    4d32:	df 91       	pop	r29
    4d34:	cf 91       	pop	r28
    4d36:	08 95       	ret

00004d38 <_ZN8SPIClass11setBitOrderEh>:

void SPIClass::setBitOrder(uint8_t bitOrder)
{
    4d38:	cf 93       	push	r28
    4d3a:	df 93       	push	r29
    4d3c:	1f 92       	push	r1
    4d3e:	cd b7       	in	r28, 0x3d	; 61
    4d40:	de b7       	in	r29, 0x3e	; 62
    4d42:	89 83       	std	Y+1, r24	; 0x01
  if(bitOrder == LSBFIRST) {
    4d44:	89 81       	ldd	r24, Y+1	; 0x01
    4d46:	88 23       	and	r24, r24
    4d48:	51 f4       	brne	.+20     	; 0x4d5e <_ZN8SPIClass11setBitOrderEh+0x26>
    SPCR |= _BV(DORD);
    4d4a:	8c e4       	ldi	r24, 0x4C	; 76
    4d4c:	90 e0       	ldi	r25, 0x00	; 0
    4d4e:	2c e4       	ldi	r18, 0x4C	; 76
    4d50:	30 e0       	ldi	r19, 0x00	; 0
    4d52:	f9 01       	movw	r30, r18
    4d54:	20 81       	ld	r18, Z
    4d56:	20 62       	ori	r18, 0x20	; 32
    4d58:	fc 01       	movw	r30, r24
    4d5a:	20 83       	st	Z, r18
    4d5c:	09 c0       	rjmp	.+18     	; 0x4d70 <_ZN8SPIClass11setBitOrderEh+0x38>
  } else {
    SPCR &= ~(_BV(DORD));
    4d5e:	8c e4       	ldi	r24, 0x4C	; 76
    4d60:	90 e0       	ldi	r25, 0x00	; 0
    4d62:	2c e4       	ldi	r18, 0x4C	; 76
    4d64:	30 e0       	ldi	r19, 0x00	; 0
    4d66:	f9 01       	movw	r30, r18
    4d68:	20 81       	ld	r18, Z
    4d6a:	2f 7d       	andi	r18, 0xDF	; 223
    4d6c:	fc 01       	movw	r30, r24
    4d6e:	20 83       	st	Z, r18
  }
}
    4d70:	0f 90       	pop	r0
    4d72:	df 91       	pop	r29
    4d74:	cf 91       	pop	r28
    4d76:	08 95       	ret

00004d78 <_ZN8SPIClass11setDataModeEh>:

void SPIClass::setDataMode(uint8_t mode)
{
    4d78:	cf 93       	push	r28
    4d7a:	df 93       	push	r29
    4d7c:	1f 92       	push	r1
    4d7e:	cd b7       	in	r28, 0x3d	; 61
    4d80:	de b7       	in	r29, 0x3e	; 62
    4d82:	89 83       	std	Y+1, r24	; 0x01
  SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
    4d84:	8c e4       	ldi	r24, 0x4C	; 76
    4d86:	90 e0       	ldi	r25, 0x00	; 0
    4d88:	2c e4       	ldi	r18, 0x4C	; 76
    4d8a:	30 e0       	ldi	r19, 0x00	; 0
    4d8c:	f9 01       	movw	r30, r18
    4d8e:	20 81       	ld	r18, Z
    4d90:	32 2f       	mov	r19, r18
    4d92:	33 7f       	andi	r19, 0xF3	; 243
    4d94:	29 81       	ldd	r18, Y+1	; 0x01
    4d96:	23 2b       	or	r18, r19
    4d98:	fc 01       	movw	r30, r24
    4d9a:	20 83       	st	Z, r18
}
    4d9c:	0f 90       	pop	r0
    4d9e:	df 91       	pop	r29
    4da0:	cf 91       	pop	r28
    4da2:	08 95       	ret

00004da4 <_ZN8SPIClass15setClockDividerEh>:

void SPIClass::setClockDivider(uint8_t rate)
{
    4da4:	cf 93       	push	r28
    4da6:	df 93       	push	r29
    4da8:	1f 92       	push	r1
    4daa:	cd b7       	in	r28, 0x3d	; 61
    4dac:	de b7       	in	r29, 0x3e	; 62
    4dae:	89 83       	std	Y+1, r24	; 0x01
  SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
    4db0:	8c e4       	ldi	r24, 0x4C	; 76
    4db2:	90 e0       	ldi	r25, 0x00	; 0
    4db4:	2c e4       	ldi	r18, 0x4C	; 76
    4db6:	30 e0       	ldi	r19, 0x00	; 0
    4db8:	f9 01       	movw	r30, r18
    4dba:	20 81       	ld	r18, Z
    4dbc:	32 2f       	mov	r19, r18
    4dbe:	3c 7f       	andi	r19, 0xFC	; 252
    4dc0:	29 81       	ldd	r18, Y+1	; 0x01
    4dc2:	23 70       	andi	r18, 0x03	; 3
    4dc4:	23 2b       	or	r18, r19
    4dc6:	fc 01       	movw	r30, r24
    4dc8:	20 83       	st	Z, r18
  SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
    4dca:	8d e4       	ldi	r24, 0x4D	; 77
    4dcc:	90 e0       	ldi	r25, 0x00	; 0
    4dce:	2d e4       	ldi	r18, 0x4D	; 77
    4dd0:	30 e0       	ldi	r19, 0x00	; 0
    4dd2:	f9 01       	movw	r30, r18
    4dd4:	20 81       	ld	r18, Z
    4dd6:	42 2f       	mov	r20, r18
    4dd8:	4e 7f       	andi	r20, 0xFE	; 254
    4dda:	29 81       	ldd	r18, Y+1	; 0x01
    4ddc:	22 2f       	mov	r18, r18
    4dde:	30 e0       	ldi	r19, 0x00	; 0
    4de0:	35 95       	asr	r19
    4de2:	27 95       	ror	r18
    4de4:	35 95       	asr	r19
    4de6:	27 95       	ror	r18
    4de8:	21 70       	andi	r18, 0x01	; 1
    4dea:	24 2b       	or	r18, r20
    4dec:	fc 01       	movw	r30, r24
    4dee:	20 83       	st	Z, r18
}
    4df0:	0f 90       	pop	r0
    4df2:	df 91       	pop	r29
    4df4:	cf 91       	pop	r28
    4df6:	08 95       	ret

00004df8 <_ZN12FirmataClass23sendValueAsTwo7bitBytesEi>:
//******************************************************************************
//* Support Functions
//******************************************************************************

void FirmataClass::sendValueAsTwo7bitBytes(int value)
{
    4df8:	cf 93       	push	r28
    4dfa:	df 93       	push	r29
    4dfc:	00 d0       	rcall	.+0      	; 0x4dfe <_ZN12FirmataClass23sendValueAsTwo7bitBytesEi+0x6>
    4dfe:	00 d0       	rcall	.+0      	; 0x4e00 <_ZN12FirmataClass23sendValueAsTwo7bitBytesEi+0x8>
    4e00:	cd b7       	in	r28, 0x3d	; 61
    4e02:	de b7       	in	r29, 0x3e	; 62
    4e04:	9a 83       	std	Y+2, r25	; 0x02
    4e06:	89 83       	std	Y+1, r24	; 0x01
    4e08:	7c 83       	std	Y+4, r23	; 0x04
    4e0a:	6b 83       	std	Y+3, r22	; 0x03
  FirmataSerial.write(value & B01111111); // LSB
    4e0c:	89 81       	ldd	r24, Y+1	; 0x01
    4e0e:	9a 81       	ldd	r25, Y+2	; 0x02
    4e10:	fc 01       	movw	r30, r24
    4e12:	80 81       	ld	r24, Z
    4e14:	91 81       	ldd	r25, Z+1	; 0x01
    4e16:	fc 01       	movw	r30, r24
    4e18:	80 81       	ld	r24, Z
    4e1a:	91 81       	ldd	r25, Z+1	; 0x01
    4e1c:	fc 01       	movw	r30, r24
    4e1e:	20 81       	ld	r18, Z
    4e20:	31 81       	ldd	r19, Z+1	; 0x01
    4e22:	8b 81       	ldd	r24, Y+3	; 0x03
    4e24:	48 2f       	mov	r20, r24
    4e26:	4f 77       	andi	r20, 0x7F	; 127
    4e28:	89 81       	ldd	r24, Y+1	; 0x01
    4e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e2c:	fc 01       	movw	r30, r24
    4e2e:	80 81       	ld	r24, Z
    4e30:	91 81       	ldd	r25, Z+1	; 0x01
    4e32:	64 2f       	mov	r22, r20
    4e34:	f9 01       	movw	r30, r18
    4e36:	09 95       	icall
  FirmataSerial.write(value >> 7 & B01111111); // MSB
    4e38:	89 81       	ldd	r24, Y+1	; 0x01
    4e3a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e3c:	fc 01       	movw	r30, r24
    4e3e:	80 81       	ld	r24, Z
    4e40:	91 81       	ldd	r25, Z+1	; 0x01
    4e42:	fc 01       	movw	r30, r24
    4e44:	80 81       	ld	r24, Z
    4e46:	91 81       	ldd	r25, Z+1	; 0x01
    4e48:	fc 01       	movw	r30, r24
    4e4a:	20 81       	ld	r18, Z
    4e4c:	31 81       	ldd	r19, Z+1	; 0x01
    4e4e:	8b 81       	ldd	r24, Y+3	; 0x03
    4e50:	9c 81       	ldd	r25, Y+4	; 0x04
    4e52:	88 0f       	add	r24, r24
    4e54:	89 2f       	mov	r24, r25
    4e56:	88 1f       	adc	r24, r24
    4e58:	99 0b       	sbc	r25, r25
    4e5a:	48 2f       	mov	r20, r24
    4e5c:	4f 77       	andi	r20, 0x7F	; 127
    4e5e:	89 81       	ldd	r24, Y+1	; 0x01
    4e60:	9a 81       	ldd	r25, Y+2	; 0x02
    4e62:	fc 01       	movw	r30, r24
    4e64:	80 81       	ld	r24, Z
    4e66:	91 81       	ldd	r25, Z+1	; 0x01
    4e68:	64 2f       	mov	r22, r20
    4e6a:	f9 01       	movw	r30, r18
    4e6c:	09 95       	icall
}
    4e6e:	0f 90       	pop	r0
    4e70:	0f 90       	pop	r0
    4e72:	0f 90       	pop	r0
    4e74:	0f 90       	pop	r0
    4e76:	df 91       	pop	r29
    4e78:	cf 91       	pop	r28
    4e7a:	08 95       	ret

00004e7c <_ZN12FirmataClass10startSysexEv>:

void FirmataClass::startSysex(void)
{
    4e7c:	cf 93       	push	r28
    4e7e:	df 93       	push	r29
    4e80:	00 d0       	rcall	.+0      	; 0x4e82 <_ZN12FirmataClass10startSysexEv+0x6>
    4e82:	cd b7       	in	r28, 0x3d	; 61
    4e84:	de b7       	in	r29, 0x3e	; 62
    4e86:	9a 83       	std	Y+2, r25	; 0x02
    4e88:	89 83       	std	Y+1, r24	; 0x01
  FirmataSerial.write(START_SYSEX);
    4e8a:	89 81       	ldd	r24, Y+1	; 0x01
    4e8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4e8e:	fc 01       	movw	r30, r24
    4e90:	80 81       	ld	r24, Z
    4e92:	91 81       	ldd	r25, Z+1	; 0x01
    4e94:	fc 01       	movw	r30, r24
    4e96:	80 81       	ld	r24, Z
    4e98:	91 81       	ldd	r25, Z+1	; 0x01
    4e9a:	fc 01       	movw	r30, r24
    4e9c:	20 81       	ld	r18, Z
    4e9e:	31 81       	ldd	r19, Z+1	; 0x01
    4ea0:	89 81       	ldd	r24, Y+1	; 0x01
    4ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ea4:	fc 01       	movw	r30, r24
    4ea6:	80 81       	ld	r24, Z
    4ea8:	91 81       	ldd	r25, Z+1	; 0x01
    4eaa:	60 ef       	ldi	r22, 0xF0	; 240
    4eac:	f9 01       	movw	r30, r18
    4eae:	09 95       	icall
}
    4eb0:	0f 90       	pop	r0
    4eb2:	0f 90       	pop	r0
    4eb4:	df 91       	pop	r29
    4eb6:	cf 91       	pop	r28
    4eb8:	08 95       	ret

00004eba <_ZN12FirmataClass8endSysexEv>:

void FirmataClass::endSysex(void)
{
    4eba:	cf 93       	push	r28
    4ebc:	df 93       	push	r29
    4ebe:	00 d0       	rcall	.+0      	; 0x4ec0 <_ZN12FirmataClass8endSysexEv+0x6>
    4ec0:	cd b7       	in	r28, 0x3d	; 61
    4ec2:	de b7       	in	r29, 0x3e	; 62
    4ec4:	9a 83       	std	Y+2, r25	; 0x02
    4ec6:	89 83       	std	Y+1, r24	; 0x01
  FirmataSerial.write(END_SYSEX);
    4ec8:	89 81       	ldd	r24, Y+1	; 0x01
    4eca:	9a 81       	ldd	r25, Y+2	; 0x02
    4ecc:	fc 01       	movw	r30, r24
    4ece:	80 81       	ld	r24, Z
    4ed0:	91 81       	ldd	r25, Z+1	; 0x01
    4ed2:	fc 01       	movw	r30, r24
    4ed4:	80 81       	ld	r24, Z
    4ed6:	91 81       	ldd	r25, Z+1	; 0x01
    4ed8:	fc 01       	movw	r30, r24
    4eda:	20 81       	ld	r18, Z
    4edc:	31 81       	ldd	r19, Z+1	; 0x01
    4ede:	89 81       	ldd	r24, Y+1	; 0x01
    4ee0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ee2:	fc 01       	movw	r30, r24
    4ee4:	80 81       	ld	r24, Z
    4ee6:	91 81       	ldd	r25, Z+1	; 0x01
    4ee8:	67 ef       	ldi	r22, 0xF7	; 247
    4eea:	f9 01       	movw	r30, r18
    4eec:	09 95       	icall
}
    4eee:	0f 90       	pop	r0
    4ef0:	0f 90       	pop	r0
    4ef2:	df 91       	pop	r29
    4ef4:	cf 91       	pop	r28
    4ef6:	08 95       	ret

00004ef8 <_ZN12FirmataClassC1ER6Stream>:

//******************************************************************************
//* Constructors
//******************************************************************************

FirmataClass::FirmataClass(Stream &s) : FirmataSerial(s)
    4ef8:	cf 93       	push	r28
    4efa:	df 93       	push	r29
    4efc:	00 d0       	rcall	.+0      	; 0x4efe <_ZN12FirmataClassC1ER6Stream+0x6>
    4efe:	00 d0       	rcall	.+0      	; 0x4f00 <_ZN12FirmataClassC1ER6Stream+0x8>
    4f00:	cd b7       	in	r28, 0x3d	; 61
    4f02:	de b7       	in	r29, 0x3e	; 62
    4f04:	9a 83       	std	Y+2, r25	; 0x02
    4f06:	89 83       	std	Y+1, r24	; 0x01
    4f08:	7c 83       	std	Y+4, r23	; 0x04
    4f0a:	6b 83       	std	Y+3, r22	; 0x03
    4f0c:	89 81       	ldd	r24, Y+1	; 0x01
    4f0e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f10:	2b 81       	ldd	r18, Y+3	; 0x03
    4f12:	3c 81       	ldd	r19, Y+4	; 0x04
    4f14:	fc 01       	movw	r30, r24
    4f16:	31 83       	std	Z+1, r19	; 0x01
    4f18:	20 83       	st	Z, r18
{
  firmwareVersionCount = 0;
    4f1a:	89 81       	ldd	r24, Y+1	; 0x01
    4f1c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f1e:	fc 01       	movw	r30, r24
    4f20:	12 82       	std	Z+2, r1	; 0x02
  systemReset();
    4f22:	89 81       	ldd	r24, Y+1	; 0x01
    4f24:	9a 81       	ldd	r25, Y+2	; 0x02
    4f26:	0e 94 41 2e 	call	0x5c82	; 0x5c82 <_ZN12FirmataClass11systemResetEv>
}
    4f2a:	0f 90       	pop	r0
    4f2c:	0f 90       	pop	r0
    4f2e:	0f 90       	pop	r0
    4f30:	0f 90       	pop	r0
    4f32:	df 91       	pop	r29
    4f34:	cf 91       	pop	r28
    4f36:	08 95       	ret

00004f38 <_ZN12FirmataClass5beginEv>:
//* Public Methods
//******************************************************************************

/* begin method for overriding default serial bitrate */
void FirmataClass::begin(void)
{
    4f38:	cf 93       	push	r28
    4f3a:	df 93       	push	r29
    4f3c:	00 d0       	rcall	.+0      	; 0x4f3e <_ZN12FirmataClass5beginEv+0x6>
    4f3e:	cd b7       	in	r28, 0x3d	; 61
    4f40:	de b7       	in	r29, 0x3e	; 62
    4f42:	9a 83       	std	Y+2, r25	; 0x02
    4f44:	89 83       	std	Y+1, r24	; 0x01
  begin(57600);
    4f46:	89 81       	ldd	r24, Y+1	; 0x01
    4f48:	9a 81       	ldd	r25, Y+2	; 0x02
    4f4a:	40 e0       	ldi	r20, 0x00	; 0
    4f4c:	51 ee       	ldi	r21, 0xE1	; 225
    4f4e:	60 e0       	ldi	r22, 0x00	; 0
    4f50:	70 e0       	ldi	r23, 0x00	; 0
    4f52:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <_ZN12FirmataClass5beginEl>
}
    4f56:	0f 90       	pop	r0
    4f58:	0f 90       	pop	r0
    4f5a:	df 91       	pop	r29
    4f5c:	cf 91       	pop	r28
    4f5e:	08 95       	ret

00004f60 <_ZN12FirmataClass5beginEl>:

/* begin method for overriding default serial bitrate */
void FirmataClass::begin(long speed)
{
    4f60:	cf 93       	push	r28
    4f62:	df 93       	push	r29
    4f64:	00 d0       	rcall	.+0      	; 0x4f66 <_ZN12FirmataClass5beginEl+0x6>
    4f66:	00 d0       	rcall	.+0      	; 0x4f68 <_ZN12FirmataClass5beginEl+0x8>
    4f68:	00 d0       	rcall	.+0      	; 0x4f6a <_ZN12FirmataClass5beginEl+0xa>
    4f6a:	cd b7       	in	r28, 0x3d	; 61
    4f6c:	de b7       	in	r29, 0x3e	; 62
    4f6e:	9a 83       	std	Y+2, r25	; 0x02
    4f70:	89 83       	std	Y+1, r24	; 0x01
    4f72:	4b 83       	std	Y+3, r20	; 0x03
    4f74:	5c 83       	std	Y+4, r21	; 0x04
    4f76:	6d 83       	std	Y+5, r22	; 0x05
    4f78:	7e 83       	std	Y+6, r23	; 0x06
  Serial.begin(speed);
    4f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    4f7c:	9c 81       	ldd	r25, Y+4	; 0x04
    4f7e:	ad 81       	ldd	r26, Y+5	; 0x05
    4f80:	be 81       	ldd	r27, Y+6	; 0x06
    4f82:	ac 01       	movw	r20, r24
    4f84:	bd 01       	movw	r22, r26
    4f86:	87 ec       	ldi	r24, 0xC7	; 199
    4f88:	98 e0       	ldi	r25, 0x08	; 8
    4f8a:	0e 94 d1 54 	call	0xa9a2	; 0xa9a2 <_ZN14HardwareSerial5beginEm>
  FirmataSerial = Serial;
    4f8e:	89 81       	ldd	r24, Y+1	; 0x01
    4f90:	9a 81       	ldd	r25, Y+2	; 0x02
    4f92:	fc 01       	movw	r30, r24
    4f94:	80 81       	ld	r24, Z
    4f96:	91 81       	ldd	r25, Z+1	; 0x01
    4f98:	67 ec       	ldi	r22, 0xC7	; 199
    4f9a:	78 e0       	ldi	r23, 0x08	; 8
    4f9c:	0e 94 0e a7 	call	0x14e1c	; 0x14e1c <_ZN6StreamaSERKS_>
  blinkVersion();
    4fa0:	89 81       	ldd	r24, Y+1	; 0x01
    4fa2:	9a 81       	ldd	r25, Y+2	; 0x02
    4fa4:	0e 94 51 28 	call	0x50a2	; 0x50a2 <_ZN12FirmataClass12blinkVersionEv>
  printVersion();
    4fa8:	89 81       	ldd	r24, Y+1	; 0x01
    4faa:	9a 81       	ldd	r25, Y+2	; 0x02
    4fac:	0e 94 0c 28 	call	0x5018	; 0x5018 <_ZN12FirmataClass12printVersionEv>
  printFirmwareVersion();
    4fb0:	89 81       	ldd	r24, Y+1	; 0x01
    4fb2:	9a 81       	ldd	r25, Y+2	; 0x02
    4fb4:	0e 94 81 28 	call	0x5102	; 0x5102 <_ZN12FirmataClass20printFirmwareVersionEv>
}
    4fb8:	26 96       	adiw	r28, 0x06	; 6
    4fba:	0f b6       	in	r0, 0x3f	; 63
    4fbc:	f8 94       	cli
    4fbe:	de bf       	out	0x3e, r29	; 62
    4fc0:	0f be       	out	0x3f, r0	; 63
    4fc2:	cd bf       	out	0x3d, r28	; 61
    4fc4:	df 91       	pop	r29
    4fc6:	cf 91       	pop	r28
    4fc8:	08 95       	ret

00004fca <_ZN12FirmataClass5beginER6Stream>:

void FirmataClass::begin(Stream &s)
{
    4fca:	cf 93       	push	r28
    4fcc:	df 93       	push	r29
    4fce:	00 d0       	rcall	.+0      	; 0x4fd0 <_ZN12FirmataClass5beginER6Stream+0x6>
    4fd0:	00 d0       	rcall	.+0      	; 0x4fd2 <_ZN12FirmataClass5beginER6Stream+0x8>
    4fd2:	cd b7       	in	r28, 0x3d	; 61
    4fd4:	de b7       	in	r29, 0x3e	; 62
    4fd6:	9a 83       	std	Y+2, r25	; 0x02
    4fd8:	89 83       	std	Y+1, r24	; 0x01
    4fda:	7c 83       	std	Y+4, r23	; 0x04
    4fdc:	6b 83       	std	Y+3, r22	; 0x03
  FirmataSerial = s;
    4fde:	89 81       	ldd	r24, Y+1	; 0x01
    4fe0:	9a 81       	ldd	r25, Y+2	; 0x02
    4fe2:	fc 01       	movw	r30, r24
    4fe4:	80 81       	ld	r24, Z
    4fe6:	91 81       	ldd	r25, Z+1	; 0x01
    4fe8:	2b 81       	ldd	r18, Y+3	; 0x03
    4fea:	3c 81       	ldd	r19, Y+4	; 0x04
    4fec:	b9 01       	movw	r22, r18
    4fee:	0e 94 0e a7 	call	0x14e1c	; 0x14e1c <_ZN6StreamaSERKS_>
  systemReset();
    4ff2:	89 81       	ldd	r24, Y+1	; 0x01
    4ff4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ff6:	0e 94 41 2e 	call	0x5c82	; 0x5c82 <_ZN12FirmataClass11systemResetEv>
  printVersion();
    4ffa:	89 81       	ldd	r24, Y+1	; 0x01
    4ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    4ffe:	0e 94 0c 28 	call	0x5018	; 0x5018 <_ZN12FirmataClass12printVersionEv>
  printFirmwareVersion();
    5002:	89 81       	ldd	r24, Y+1	; 0x01
    5004:	9a 81       	ldd	r25, Y+2	; 0x02
    5006:	0e 94 81 28 	call	0x5102	; 0x5102 <_ZN12FirmataClass20printFirmwareVersionEv>
}
    500a:	0f 90       	pop	r0
    500c:	0f 90       	pop	r0
    500e:	0f 90       	pop	r0
    5010:	0f 90       	pop	r0
    5012:	df 91       	pop	r29
    5014:	cf 91       	pop	r28
    5016:	08 95       	ret

00005018 <_ZN12FirmataClass12printVersionEv>:

// output the protocol version message to the serial port
void FirmataClass::printVersion(void) {
    5018:	cf 93       	push	r28
    501a:	df 93       	push	r29
    501c:	00 d0       	rcall	.+0      	; 0x501e <_ZN12FirmataClass12printVersionEv+0x6>
    501e:	cd b7       	in	r28, 0x3d	; 61
    5020:	de b7       	in	r29, 0x3e	; 62
    5022:	9a 83       	std	Y+2, r25	; 0x02
    5024:	89 83       	std	Y+1, r24	; 0x01
  FirmataSerial.write(REPORT_VERSION);
    5026:	89 81       	ldd	r24, Y+1	; 0x01
    5028:	9a 81       	ldd	r25, Y+2	; 0x02
    502a:	fc 01       	movw	r30, r24
    502c:	80 81       	ld	r24, Z
    502e:	91 81       	ldd	r25, Z+1	; 0x01
    5030:	fc 01       	movw	r30, r24
    5032:	80 81       	ld	r24, Z
    5034:	91 81       	ldd	r25, Z+1	; 0x01
    5036:	fc 01       	movw	r30, r24
    5038:	20 81       	ld	r18, Z
    503a:	31 81       	ldd	r19, Z+1	; 0x01
    503c:	89 81       	ldd	r24, Y+1	; 0x01
    503e:	9a 81       	ldd	r25, Y+2	; 0x02
    5040:	fc 01       	movw	r30, r24
    5042:	80 81       	ld	r24, Z
    5044:	91 81       	ldd	r25, Z+1	; 0x01
    5046:	69 ef       	ldi	r22, 0xF9	; 249
    5048:	f9 01       	movw	r30, r18
    504a:	09 95       	icall
  FirmataSerial.write(FIRMATA_MAJOR_VERSION);
    504c:	89 81       	ldd	r24, Y+1	; 0x01
    504e:	9a 81       	ldd	r25, Y+2	; 0x02
    5050:	fc 01       	movw	r30, r24
    5052:	80 81       	ld	r24, Z
    5054:	91 81       	ldd	r25, Z+1	; 0x01
    5056:	fc 01       	movw	r30, r24
    5058:	80 81       	ld	r24, Z
    505a:	91 81       	ldd	r25, Z+1	; 0x01
    505c:	fc 01       	movw	r30, r24
    505e:	20 81       	ld	r18, Z
    5060:	31 81       	ldd	r19, Z+1	; 0x01
    5062:	89 81       	ldd	r24, Y+1	; 0x01
    5064:	9a 81       	ldd	r25, Y+2	; 0x02
    5066:	fc 01       	movw	r30, r24
    5068:	80 81       	ld	r24, Z
    506a:	91 81       	ldd	r25, Z+1	; 0x01
    506c:	62 e0       	ldi	r22, 0x02	; 2
    506e:	f9 01       	movw	r30, r18
    5070:	09 95       	icall
  FirmataSerial.write(FIRMATA_MINOR_VERSION);
    5072:	89 81       	ldd	r24, Y+1	; 0x01
    5074:	9a 81       	ldd	r25, Y+2	; 0x02
    5076:	fc 01       	movw	r30, r24
    5078:	80 81       	ld	r24, Z
    507a:	91 81       	ldd	r25, Z+1	; 0x01
    507c:	fc 01       	movw	r30, r24
    507e:	80 81       	ld	r24, Z
    5080:	91 81       	ldd	r25, Z+1	; 0x01
    5082:	fc 01       	movw	r30, r24
    5084:	20 81       	ld	r18, Z
    5086:	31 81       	ldd	r19, Z+1	; 0x01
    5088:	89 81       	ldd	r24, Y+1	; 0x01
    508a:	9a 81       	ldd	r25, Y+2	; 0x02
    508c:	fc 01       	movw	r30, r24
    508e:	80 81       	ld	r24, Z
    5090:	91 81       	ldd	r25, Z+1	; 0x01
    5092:	63 e0       	ldi	r22, 0x03	; 3
    5094:	f9 01       	movw	r30, r18
    5096:	09 95       	icall
}
    5098:	0f 90       	pop	r0
    509a:	0f 90       	pop	r0
    509c:	df 91       	pop	r29
    509e:	cf 91       	pop	r28
    50a0:	08 95       	ret

000050a2 <_ZN12FirmataClass12blinkVersionEv>:

void FirmataClass::blinkVersion(void)
{
    50a2:	cf 93       	push	r28
    50a4:	df 93       	push	r29
    50a6:	00 d0       	rcall	.+0      	; 0x50a8 <_ZN12FirmataClass12blinkVersionEv+0x6>
    50a8:	cd b7       	in	r28, 0x3d	; 61
    50aa:	de b7       	in	r29, 0x3e	; 62
    50ac:	9a 83       	std	Y+2, r25	; 0x02
    50ae:	89 83       	std	Y+1, r24	; 0x01
  // flash the pin with the protocol version
  pinMode(VERSION_BLINK_PIN,OUTPUT);
    50b0:	61 e0       	ldi	r22, 0x01	; 1
    50b2:	8d e0       	ldi	r24, 0x0D	; 13
    50b4:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
  pin13strobe(FIRMATA_MAJOR_VERSION, 40, 210);
    50b8:	89 81       	ldd	r24, Y+1	; 0x01
    50ba:	9a 81       	ldd	r25, Y+2	; 0x02
    50bc:	22 ed       	ldi	r18, 0xD2	; 210
    50be:	30 e0       	ldi	r19, 0x00	; 0
    50c0:	48 e2       	ldi	r20, 0x28	; 40
    50c2:	50 e0       	ldi	r21, 0x00	; 0
    50c4:	62 e0       	ldi	r22, 0x02	; 2
    50c6:	70 e0       	ldi	r23, 0x00	; 0
    50c8:	0e 94 88 2e 	call	0x5d10	; 0x5d10 <_ZN12FirmataClass11pin13strobeEiii>
  delay(250);
    50cc:	6a ef       	ldi	r22, 0xFA	; 250
    50ce:	70 e0       	ldi	r23, 0x00	; 0
    50d0:	80 e0       	ldi	r24, 0x00	; 0
    50d2:	90 e0       	ldi	r25, 0x00	; 0
    50d4:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
  pin13strobe(FIRMATA_MINOR_VERSION, 40, 210);
    50d8:	89 81       	ldd	r24, Y+1	; 0x01
    50da:	9a 81       	ldd	r25, Y+2	; 0x02
    50dc:	22 ed       	ldi	r18, 0xD2	; 210
    50de:	30 e0       	ldi	r19, 0x00	; 0
    50e0:	48 e2       	ldi	r20, 0x28	; 40
    50e2:	50 e0       	ldi	r21, 0x00	; 0
    50e4:	63 e0       	ldi	r22, 0x03	; 3
    50e6:	70 e0       	ldi	r23, 0x00	; 0
    50e8:	0e 94 88 2e 	call	0x5d10	; 0x5d10 <_ZN12FirmataClass11pin13strobeEiii>
  delay(125);
    50ec:	6d e7       	ldi	r22, 0x7D	; 125
    50ee:	70 e0       	ldi	r23, 0x00	; 0
    50f0:	80 e0       	ldi	r24, 0x00	; 0
    50f2:	90 e0       	ldi	r25, 0x00	; 0
    50f4:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
}
    50f8:	0f 90       	pop	r0
    50fa:	0f 90       	pop	r0
    50fc:	df 91       	pop	r29
    50fe:	cf 91       	pop	r28
    5100:	08 95       	ret

00005102 <_ZN12FirmataClass20printFirmwareVersionEv>:

void FirmataClass::printFirmwareVersion(void)
{
    5102:	cf 93       	push	r28
    5104:	df 93       	push	r29
    5106:	00 d0       	rcall	.+0      	; 0x5108 <_ZN12FirmataClass20printFirmwareVersionEv+0x6>
    5108:	1f 92       	push	r1
    510a:	cd b7       	in	r28, 0x3d	; 61
    510c:	de b7       	in	r29, 0x3e	; 62
    510e:	9b 83       	std	Y+3, r25	; 0x03
    5110:	8a 83       	std	Y+2, r24	; 0x02
  byte i;

  if(firmwareVersionCount) { // make sure that the name has been set before reporting
    5112:	8a 81       	ldd	r24, Y+2	; 0x02
    5114:	9b 81       	ldd	r25, Y+3	; 0x03
    5116:	fc 01       	movw	r30, r24
    5118:	82 81       	ldd	r24, Z+2	; 0x02
    511a:	88 23       	and	r24, r24
    511c:	09 f4       	brne	.+2      	; 0x5120 <_ZN12FirmataClass20printFirmwareVersionEv+0x1e>
    511e:	74 c0       	rjmp	.+232    	; 0x5208 <_ZN12FirmataClass20printFirmwareVersionEv+0x106>
    startSysex();
    5120:	8a 81       	ldd	r24, Y+2	; 0x02
    5122:	9b 81       	ldd	r25, Y+3	; 0x03
    5124:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <_ZN12FirmataClass10startSysexEv>
    FirmataSerial.write(REPORT_FIRMWARE);
    5128:	8a 81       	ldd	r24, Y+2	; 0x02
    512a:	9b 81       	ldd	r25, Y+3	; 0x03
    512c:	fc 01       	movw	r30, r24
    512e:	80 81       	ld	r24, Z
    5130:	91 81       	ldd	r25, Z+1	; 0x01
    5132:	fc 01       	movw	r30, r24
    5134:	80 81       	ld	r24, Z
    5136:	91 81       	ldd	r25, Z+1	; 0x01
    5138:	fc 01       	movw	r30, r24
    513a:	20 81       	ld	r18, Z
    513c:	31 81       	ldd	r19, Z+1	; 0x01
    513e:	8a 81       	ldd	r24, Y+2	; 0x02
    5140:	9b 81       	ldd	r25, Y+3	; 0x03
    5142:	fc 01       	movw	r30, r24
    5144:	80 81       	ld	r24, Z
    5146:	91 81       	ldd	r25, Z+1	; 0x01
    5148:	69 e7       	ldi	r22, 0x79	; 121
    514a:	f9 01       	movw	r30, r18
    514c:	09 95       	icall
    FirmataSerial.write(firmwareVersionVector[0]); // major version number
    514e:	8a 81       	ldd	r24, Y+2	; 0x02
    5150:	9b 81       	ldd	r25, Y+3	; 0x03
    5152:	fc 01       	movw	r30, r24
    5154:	80 81       	ld	r24, Z
    5156:	91 81       	ldd	r25, Z+1	; 0x01
    5158:	fc 01       	movw	r30, r24
    515a:	80 81       	ld	r24, Z
    515c:	91 81       	ldd	r25, Z+1	; 0x01
    515e:	fc 01       	movw	r30, r24
    5160:	20 81       	ld	r18, Z
    5162:	31 81       	ldd	r19, Z+1	; 0x01
    5164:	8a 81       	ldd	r24, Y+2	; 0x02
    5166:	9b 81       	ldd	r25, Y+3	; 0x03
    5168:	fc 01       	movw	r30, r24
    516a:	83 81       	ldd	r24, Z+3	; 0x03
    516c:	94 81       	ldd	r25, Z+4	; 0x04
    516e:	fc 01       	movw	r30, r24
    5170:	40 81       	ld	r20, Z
    5172:	8a 81       	ldd	r24, Y+2	; 0x02
    5174:	9b 81       	ldd	r25, Y+3	; 0x03
    5176:	fc 01       	movw	r30, r24
    5178:	80 81       	ld	r24, Z
    517a:	91 81       	ldd	r25, Z+1	; 0x01
    517c:	64 2f       	mov	r22, r20
    517e:	f9 01       	movw	r30, r18
    5180:	09 95       	icall
    FirmataSerial.write(firmwareVersionVector[1]); // minor version number
    5182:	8a 81       	ldd	r24, Y+2	; 0x02
    5184:	9b 81       	ldd	r25, Y+3	; 0x03
    5186:	fc 01       	movw	r30, r24
    5188:	80 81       	ld	r24, Z
    518a:	91 81       	ldd	r25, Z+1	; 0x01
    518c:	fc 01       	movw	r30, r24
    518e:	80 81       	ld	r24, Z
    5190:	91 81       	ldd	r25, Z+1	; 0x01
    5192:	fc 01       	movw	r30, r24
    5194:	20 81       	ld	r18, Z
    5196:	31 81       	ldd	r19, Z+1	; 0x01
    5198:	8a 81       	ldd	r24, Y+2	; 0x02
    519a:	9b 81       	ldd	r25, Y+3	; 0x03
    519c:	fc 01       	movw	r30, r24
    519e:	83 81       	ldd	r24, Z+3	; 0x03
    51a0:	94 81       	ldd	r25, Z+4	; 0x04
    51a2:	01 96       	adiw	r24, 0x01	; 1
    51a4:	fc 01       	movw	r30, r24
    51a6:	40 81       	ld	r20, Z
    51a8:	8a 81       	ldd	r24, Y+2	; 0x02
    51aa:	9b 81       	ldd	r25, Y+3	; 0x03
    51ac:	fc 01       	movw	r30, r24
    51ae:	80 81       	ld	r24, Z
    51b0:	91 81       	ldd	r25, Z+1	; 0x01
    51b2:	64 2f       	mov	r22, r20
    51b4:	f9 01       	movw	r30, r18
    51b6:	09 95       	icall
    for(i=2; i<firmwareVersionCount; ++i) {
    51b8:	82 e0       	ldi	r24, 0x02	; 2
    51ba:	89 83       	std	Y+1, r24	; 0x01
    51bc:	16 c0       	rjmp	.+44     	; 0x51ea <_ZN12FirmataClass20printFirmwareVersionEv+0xe8>
      sendValueAsTwo7bitBytes(firmwareVersionVector[i]);
    51be:	8a 81       	ldd	r24, Y+2	; 0x02
    51c0:	9b 81       	ldd	r25, Y+3	; 0x03
    51c2:	fc 01       	movw	r30, r24
    51c4:	23 81       	ldd	r18, Z+3	; 0x03
    51c6:	34 81       	ldd	r19, Z+4	; 0x04
    51c8:	89 81       	ldd	r24, Y+1	; 0x01
    51ca:	88 2f       	mov	r24, r24
    51cc:	90 e0       	ldi	r25, 0x00	; 0
    51ce:	82 0f       	add	r24, r18
    51d0:	93 1f       	adc	r25, r19
    51d2:	fc 01       	movw	r30, r24
    51d4:	80 81       	ld	r24, Z
    51d6:	28 2f       	mov	r18, r24
    51d8:	30 e0       	ldi	r19, 0x00	; 0
    51da:	8a 81       	ldd	r24, Y+2	; 0x02
    51dc:	9b 81       	ldd	r25, Y+3	; 0x03
    51de:	b9 01       	movw	r22, r18
    51e0:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <_ZN12FirmataClass23sendValueAsTwo7bitBytesEi>
  if(firmwareVersionCount) { // make sure that the name has been set before reporting
    startSysex();
    FirmataSerial.write(REPORT_FIRMWARE);
    FirmataSerial.write(firmwareVersionVector[0]); // major version number
    FirmataSerial.write(firmwareVersionVector[1]); // minor version number
    for(i=2; i<firmwareVersionCount; ++i) {
    51e4:	89 81       	ldd	r24, Y+1	; 0x01
    51e6:	8f 5f       	subi	r24, 0xFF	; 255
    51e8:	89 83       	std	Y+1, r24	; 0x01
    51ea:	8a 81       	ldd	r24, Y+2	; 0x02
    51ec:	9b 81       	ldd	r25, Y+3	; 0x03
    51ee:	fc 01       	movw	r30, r24
    51f0:	22 81       	ldd	r18, Z+2	; 0x02
    51f2:	81 e0       	ldi	r24, 0x01	; 1
    51f4:	99 81       	ldd	r25, Y+1	; 0x01
    51f6:	92 17       	cp	r25, r18
    51f8:	08 f0       	brcs	.+2      	; 0x51fc <_ZN12FirmataClass20printFirmwareVersionEv+0xfa>
    51fa:	80 e0       	ldi	r24, 0x00	; 0
    51fc:	88 23       	and	r24, r24
    51fe:	f9 f6       	brne	.-66     	; 0x51be <_ZN12FirmataClass20printFirmwareVersionEv+0xbc>
      sendValueAsTwo7bitBytes(firmwareVersionVector[i]);
    }
    endSysex();
    5200:	8a 81       	ldd	r24, Y+2	; 0x02
    5202:	9b 81       	ldd	r25, Y+3	; 0x03
    5204:	0e 94 5d 27 	call	0x4eba	; 0x4eba <_ZN12FirmataClass8endSysexEv>
  }
}
    5208:	0f 90       	pop	r0
    520a:	0f 90       	pop	r0
    520c:	0f 90       	pop	r0
    520e:	df 91       	pop	r29
    5210:	cf 91       	pop	r28
    5212:	08 95       	ret

00005214 <_ZN12FirmataClass25setFirmwareNameAndVersionEPKchh>:

void FirmataClass::setFirmwareNameAndVersion(const char *name, byte major, byte minor)
{
    5214:	cf 93       	push	r28
    5216:	df 93       	push	r29
    5218:	cd b7       	in	r28, 0x3d	; 61
    521a:	de b7       	in	r29, 0x3e	; 62
    521c:	2a 97       	sbiw	r28, 0x0a	; 10
    521e:	0f b6       	in	r0, 0x3f	; 63
    5220:	f8 94       	cli
    5222:	de bf       	out	0x3e, r29	; 62
    5224:	0f be       	out	0x3f, r0	; 63
    5226:	cd bf       	out	0x3d, r28	; 61
    5228:	9e 83       	std	Y+6, r25	; 0x06
    522a:	8d 83       	std	Y+5, r24	; 0x05
    522c:	78 87       	std	Y+8, r23	; 0x08
    522e:	6f 83       	std	Y+7, r22	; 0x07
    5230:	49 87       	std	Y+9, r20	; 0x09
    5232:	2a 87       	std	Y+10, r18	; 0x0a
  const char *filename;
  char *extension;

  // parse out ".cpp" and "applet/" that comes from using __FILE__
  extension = strstr(name, ".cpp");
    5234:	8f 81       	ldd	r24, Y+7	; 0x07
    5236:	98 85       	ldd	r25, Y+8	; 0x08
    5238:	6c ef       	ldi	r22, 0xFC	; 252
    523a:	72 e0       	ldi	r23, 0x02	; 2
    523c:	0e 94 6c b1 	call	0x162d8	; 0x162d8 <strstr>
    5240:	9c 83       	std	Y+4, r25	; 0x04
    5242:	8b 83       	std	Y+3, r24	; 0x03
  filename = strrchr(name, '/') + 1; //points to slash, +1 gets to start of filename
    5244:	8f 81       	ldd	r24, Y+7	; 0x07
    5246:	98 85       	ldd	r25, Y+8	; 0x08
    5248:	6f e2       	ldi	r22, 0x2F	; 47
    524a:	70 e0       	ldi	r23, 0x00	; 0
    524c:	0e 94 61 b1 	call	0x162c2	; 0x162c2 <strrchr>
    5250:	01 96       	adiw	r24, 0x01	; 1
    5252:	9a 83       	std	Y+2, r25	; 0x02
    5254:	89 83       	std	Y+1, r24	; 0x01
  // add two bytes for version numbers
  if(extension && filename) {
    5256:	8b 81       	ldd	r24, Y+3	; 0x03
    5258:	9c 81       	ldd	r25, Y+4	; 0x04
    525a:	00 97       	sbiw	r24, 0x00	; 0
    525c:	99 f0       	breq	.+38     	; 0x5284 <_ZN12FirmataClass25setFirmwareNameAndVersionEPKchh+0x70>
    525e:	89 81       	ldd	r24, Y+1	; 0x01
    5260:	9a 81       	ldd	r25, Y+2	; 0x02
    5262:	00 97       	sbiw	r24, 0x00	; 0
    5264:	79 f0       	breq	.+30     	; 0x5284 <_ZN12FirmataClass25setFirmwareNameAndVersionEPKchh+0x70>
    firmwareVersionCount = extension - filename + 2;
    5266:	2b 81       	ldd	r18, Y+3	; 0x03
    5268:	3c 81       	ldd	r19, Y+4	; 0x04
    526a:	89 81       	ldd	r24, Y+1	; 0x01
    526c:	9a 81       	ldd	r25, Y+2	; 0x02
    526e:	a9 01       	movw	r20, r18
    5270:	48 1b       	sub	r20, r24
    5272:	59 0b       	sbc	r21, r25
    5274:	ca 01       	movw	r24, r20
    5276:	28 2f       	mov	r18, r24
    5278:	2e 5f       	subi	r18, 0xFE	; 254
    527a:	8d 81       	ldd	r24, Y+5	; 0x05
    527c:	9e 81       	ldd	r25, Y+6	; 0x06
    527e:	fc 01       	movw	r30, r24
    5280:	22 83       	std	Z+2, r18	; 0x02
    5282:	0e c0       	rjmp	.+28     	; 0x52a0 <_ZN12FirmataClass25setFirmwareNameAndVersionEPKchh+0x8c>
  } else {
    firmwareVersionCount = strlen(name) + 2;
    5284:	8f 81       	ldd	r24, Y+7	; 0x07
    5286:	98 85       	ldd	r25, Y+8	; 0x08
    5288:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    528c:	28 2f       	mov	r18, r24
    528e:	2e 5f       	subi	r18, 0xFE	; 254
    5290:	8d 81       	ldd	r24, Y+5	; 0x05
    5292:	9e 81       	ldd	r25, Y+6	; 0x06
    5294:	fc 01       	movw	r30, r24
    5296:	22 83       	std	Z+2, r18	; 0x02
    filename = name;
    5298:	8f 81       	ldd	r24, Y+7	; 0x07
    529a:	98 85       	ldd	r25, Y+8	; 0x08
    529c:	9a 83       	std	Y+2, r25	; 0x02
    529e:	89 83       	std	Y+1, r24	; 0x01
  }
  firmwareVersionVector = (byte *) malloc(firmwareVersionCount);
    52a0:	8d 81       	ldd	r24, Y+5	; 0x05
    52a2:	9e 81       	ldd	r25, Y+6	; 0x06
    52a4:	fc 01       	movw	r30, r24
    52a6:	82 81       	ldd	r24, Z+2	; 0x02
    52a8:	88 2f       	mov	r24, r24
    52aa:	90 e0       	ldi	r25, 0x00	; 0
    52ac:	0e 94 5a ae 	call	0x15cb4	; 0x15cb4 <malloc>
    52b0:	9c 01       	movw	r18, r24
    52b2:	8d 81       	ldd	r24, Y+5	; 0x05
    52b4:	9e 81       	ldd	r25, Y+6	; 0x06
    52b6:	fc 01       	movw	r30, r24
    52b8:	34 83       	std	Z+4, r19	; 0x04
    52ba:	23 83       	std	Z+3, r18	; 0x03
  firmwareVersionVector[firmwareVersionCount] = 0;
    52bc:	8d 81       	ldd	r24, Y+5	; 0x05
    52be:	9e 81       	ldd	r25, Y+6	; 0x06
    52c0:	fc 01       	movw	r30, r24
    52c2:	23 81       	ldd	r18, Z+3	; 0x03
    52c4:	34 81       	ldd	r19, Z+4	; 0x04
    52c6:	8d 81       	ldd	r24, Y+5	; 0x05
    52c8:	9e 81       	ldd	r25, Y+6	; 0x06
    52ca:	fc 01       	movw	r30, r24
    52cc:	82 81       	ldd	r24, Z+2	; 0x02
    52ce:	88 2f       	mov	r24, r24
    52d0:	90 e0       	ldi	r25, 0x00	; 0
    52d2:	82 0f       	add	r24, r18
    52d4:	93 1f       	adc	r25, r19
    52d6:	fc 01       	movw	r30, r24
    52d8:	10 82       	st	Z, r1
  firmwareVersionVector[0] = major;
    52da:	8d 81       	ldd	r24, Y+5	; 0x05
    52dc:	9e 81       	ldd	r25, Y+6	; 0x06
    52de:	fc 01       	movw	r30, r24
    52e0:	83 81       	ldd	r24, Z+3	; 0x03
    52e2:	94 81       	ldd	r25, Z+4	; 0x04
    52e4:	29 85       	ldd	r18, Y+9	; 0x09
    52e6:	fc 01       	movw	r30, r24
    52e8:	20 83       	st	Z, r18
  firmwareVersionVector[1] = minor;
    52ea:	8d 81       	ldd	r24, Y+5	; 0x05
    52ec:	9e 81       	ldd	r25, Y+6	; 0x06
    52ee:	fc 01       	movw	r30, r24
    52f0:	83 81       	ldd	r24, Z+3	; 0x03
    52f2:	94 81       	ldd	r25, Z+4	; 0x04
    52f4:	01 96       	adiw	r24, 0x01	; 1
    52f6:	2a 85       	ldd	r18, Y+10	; 0x0a
    52f8:	fc 01       	movw	r30, r24
    52fa:	20 83       	st	Z, r18
  strncpy((char*)firmwareVersionVector + 2, filename, firmwareVersionCount - 2);
    52fc:	8d 81       	ldd	r24, Y+5	; 0x05
    52fe:	9e 81       	ldd	r25, Y+6	; 0x06
    5300:	fc 01       	movw	r30, r24
    5302:	82 81       	ldd	r24, Z+2	; 0x02
    5304:	88 2f       	mov	r24, r24
    5306:	90 e0       	ldi	r25, 0x00	; 0
    5308:	02 97       	sbiw	r24, 0x02	; 2
    530a:	ac 01       	movw	r20, r24
    530c:	8d 81       	ldd	r24, Y+5	; 0x05
    530e:	9e 81       	ldd	r25, Y+6	; 0x06
    5310:	fc 01       	movw	r30, r24
    5312:	83 81       	ldd	r24, Z+3	; 0x03
    5314:	94 81       	ldd	r25, Z+4	; 0x04
    5316:	02 96       	adiw	r24, 0x02	; 2
    5318:	29 81       	ldd	r18, Y+1	; 0x01
    531a:	3a 81       	ldd	r19, Y+2	; 0x02
    531c:	b9 01       	movw	r22, r18
    531e:	0e 94 52 b1 	call	0x162a4	; 0x162a4 <strncpy>
  // alas, no snprintf on Arduino
  //    snprintf(firmwareVersionVector, MAX_DATA_BYTES, "%c%c%s", 
  //             (char)major, (char)minor, firmwareVersionVector);
}
    5322:	2a 96       	adiw	r28, 0x0a	; 10
    5324:	0f b6       	in	r0, 0x3f	; 63
    5326:	f8 94       	cli
    5328:	de bf       	out	0x3e, r29	; 62
    532a:	0f be       	out	0x3f, r0	; 63
    532c:	cd bf       	out	0x3d, r28	; 61
    532e:	df 91       	pop	r29
    5330:	cf 91       	pop	r28
    5332:	08 95       	ret

00005334 <_ZN12FirmataClass9availableEv>:

//------------------------------------------------------------------------------
// Serial Receive Handling

int FirmataClass::available(void)
{
    5334:	cf 93       	push	r28
    5336:	df 93       	push	r29
    5338:	00 d0       	rcall	.+0      	; 0x533a <_ZN12FirmataClass9availableEv+0x6>
    533a:	cd b7       	in	r28, 0x3d	; 61
    533c:	de b7       	in	r29, 0x3e	; 62
    533e:	9a 83       	std	Y+2, r25	; 0x02
    5340:	89 83       	std	Y+1, r24	; 0x01
  return FirmataSerial.available();
    5342:	89 81       	ldd	r24, Y+1	; 0x01
    5344:	9a 81       	ldd	r25, Y+2	; 0x02
    5346:	fc 01       	movw	r30, r24
    5348:	80 81       	ld	r24, Z
    534a:	91 81       	ldd	r25, Z+1	; 0x01
    534c:	fc 01       	movw	r30, r24
    534e:	80 81       	ld	r24, Z
    5350:	91 81       	ldd	r25, Z+1	; 0x01
    5352:	04 96       	adiw	r24, 0x04	; 4
    5354:	fc 01       	movw	r30, r24
    5356:	20 81       	ld	r18, Z
    5358:	31 81       	ldd	r19, Z+1	; 0x01
    535a:	89 81       	ldd	r24, Y+1	; 0x01
    535c:	9a 81       	ldd	r25, Y+2	; 0x02
    535e:	fc 01       	movw	r30, r24
    5360:	80 81       	ld	r24, Z
    5362:	91 81       	ldd	r25, Z+1	; 0x01
    5364:	f9 01       	movw	r30, r18
    5366:	09 95       	icall
}
    5368:	0f 90       	pop	r0
    536a:	0f 90       	pop	r0
    536c:	df 91       	pop	r29
    536e:	cf 91       	pop	r28
    5370:	08 95       	ret

00005372 <_ZN12FirmataClass19processSysexMessageEv>:


void FirmataClass::processSysexMessage(void)
{
    5372:	cf 93       	push	r28
    5374:	df 93       	push	r29
    5376:	cd b7       	in	r28, 0x3d	; 61
    5378:	de b7       	in	r29, 0x3e	; 62
    537a:	27 97       	sbiw	r28, 0x07	; 7
    537c:	0f b6       	in	r0, 0x3f	; 63
    537e:	f8 94       	cli
    5380:	de bf       	out	0x3e, r29	; 62
    5382:	0f be       	out	0x3f, r0	; 63
    5384:	cd bf       	out	0x3d, r28	; 61
    5386:	9f 83       	std	Y+7, r25	; 0x07
    5388:	8e 83       	std	Y+6, r24	; 0x06
  switch(storedInputData[0]) { //first byte in buffer is command
    538a:	8e 81       	ldd	r24, Y+6	; 0x06
    538c:	9f 81       	ldd	r25, Y+7	; 0x07
    538e:	fc 01       	movw	r30, r24
    5390:	80 85       	ldd	r24, Z+8	; 0x08
    5392:	88 2f       	mov	r24, r24
    5394:	90 e0       	ldi	r25, 0x00	; 0
    5396:	81 37       	cpi	r24, 0x71	; 113
    5398:	91 05       	cpc	r25, r1
    539a:	49 f0       	breq	.+18     	; 0x53ae <_ZN12FirmataClass19processSysexMessageEv+0x3c>
    539c:	89 37       	cpi	r24, 0x79	; 121
    539e:	91 05       	cpc	r25, r1
    53a0:	09 f0       	breq	.+2      	; 0x53a4 <_ZN12FirmataClass19processSysexMessageEv+0x32>
    53a2:	75 c0       	rjmp	.+234    	; 0x548e <_ZN12FirmataClass19processSysexMessageEv+0x11c>
  case REPORT_FIRMWARE:
    printFirmwareVersion();
    53a4:	8e 81       	ldd	r24, Y+6	; 0x06
    53a6:	9f 81       	ldd	r25, Y+7	; 0x07
    53a8:	0e 94 81 28 	call	0x5102	; 0x5102 <_ZN12FirmataClass20printFirmwareVersionEv>
    break;
    53ac:	90 c0       	rjmp	.+288    	; 0x54ce <_ZN12FirmataClass19processSysexMessageEv+0x15c>
  case STRING_DATA:
    if(currentStringCallback) {
    53ae:	8e 81       	ldd	r24, Y+6	; 0x06
    53b0:	9f 81       	ldd	r25, Y+7	; 0x07
    53b2:	fc 01       	movw	r30, r24
    53b4:	87 a9       	ldd	r24, Z+55	; 0x37
    53b6:	90 ad       	ldd	r25, Z+56	; 0x38
    53b8:	00 97       	sbiw	r24, 0x00	; 0
    53ba:	09 f4       	brne	.+2      	; 0x53be <_ZN12FirmataClass19processSysexMessageEv+0x4c>
    53bc:	87 c0       	rjmp	.+270    	; 0x54cc <_ZN12FirmataClass19processSysexMessageEv+0x15a>
      byte bufferLength = (sysexBytesRead - 1) / 2;
    53be:	8e 81       	ldd	r24, Y+6	; 0x06
    53c0:	9f 81       	ldd	r25, Y+7	; 0x07
    53c2:	fc 01       	movw	r30, r24
    53c4:	81 a5       	ldd	r24, Z+41	; 0x29
    53c6:	92 a5       	ldd	r25, Z+42	; 0x2a
    53c8:	01 97       	sbiw	r24, 0x01	; 1
    53ca:	99 23       	and	r25, r25
    53cc:	0c f4       	brge	.+2      	; 0x53d0 <_ZN12FirmataClass19processSysexMessageEv+0x5e>
    53ce:	01 96       	adiw	r24, 0x01	; 1
    53d0:	95 95       	asr	r25
    53d2:	87 95       	ror	r24
    53d4:	8b 83       	std	Y+3, r24	; 0x03
      char *buffer = (char*)malloc(bufferLength * sizeof(char));
    53d6:	8b 81       	ldd	r24, Y+3	; 0x03
    53d8:	88 2f       	mov	r24, r24
    53da:	90 e0       	ldi	r25, 0x00	; 0
    53dc:	0e 94 5a ae 	call	0x15cb4	; 0x15cb4 <malloc>
    53e0:	9d 83       	std	Y+5, r25	; 0x05
    53e2:	8c 83       	std	Y+4, r24	; 0x04
      byte i = 1;
    53e4:	81 e0       	ldi	r24, 0x01	; 1
    53e6:	89 83       	std	Y+1, r24	; 0x01
      byte j = 0;
    53e8:	1a 82       	std	Y+2, r1	; 0x02
      while(j < bufferLength) {
    53ea:	3e c0       	rjmp	.+124    	; 0x5468 <_ZN12FirmataClass19processSysexMessageEv+0xf6>
        buffer[j] = (char)storedInputData[i];
    53ec:	8a 81       	ldd	r24, Y+2	; 0x02
    53ee:	88 2f       	mov	r24, r24
    53f0:	90 e0       	ldi	r25, 0x00	; 0
    53f2:	2c 81       	ldd	r18, Y+4	; 0x04
    53f4:	3d 81       	ldd	r19, Y+5	; 0x05
    53f6:	82 0f       	add	r24, r18
    53f8:	93 1f       	adc	r25, r19
    53fa:	29 81       	ldd	r18, Y+1	; 0x01
    53fc:	22 2f       	mov	r18, r18
    53fe:	30 e0       	ldi	r19, 0x00	; 0
    5400:	4e 81       	ldd	r20, Y+6	; 0x06
    5402:	5f 81       	ldd	r21, Y+7	; 0x07
    5404:	24 0f       	add	r18, r20
    5406:	35 1f       	adc	r19, r21
    5408:	28 5f       	subi	r18, 0xF8	; 248
    540a:	3f 4f       	sbci	r19, 0xFF	; 255
    540c:	f9 01       	movw	r30, r18
    540e:	20 81       	ld	r18, Z
    5410:	fc 01       	movw	r30, r24
    5412:	20 83       	st	Z, r18
        i++;
    5414:	89 81       	ldd	r24, Y+1	; 0x01
    5416:	8f 5f       	subi	r24, 0xFF	; 255
    5418:	89 83       	std	Y+1, r24	; 0x01
        buffer[j] += (char)(storedInputData[i] << 7);
    541a:	8a 81       	ldd	r24, Y+2	; 0x02
    541c:	88 2f       	mov	r24, r24
    541e:	90 e0       	ldi	r25, 0x00	; 0
    5420:	2c 81       	ldd	r18, Y+4	; 0x04
    5422:	3d 81       	ldd	r19, Y+5	; 0x05
    5424:	82 0f       	add	r24, r18
    5426:	93 1f       	adc	r25, r19
    5428:	2a 81       	ldd	r18, Y+2	; 0x02
    542a:	22 2f       	mov	r18, r18
    542c:	30 e0       	ldi	r19, 0x00	; 0
    542e:	4c 81       	ldd	r20, Y+4	; 0x04
    5430:	5d 81       	ldd	r21, Y+5	; 0x05
    5432:	24 0f       	add	r18, r20
    5434:	35 1f       	adc	r19, r21
    5436:	f9 01       	movw	r30, r18
    5438:	60 81       	ld	r22, Z
    543a:	29 81       	ldd	r18, Y+1	; 0x01
    543c:	22 2f       	mov	r18, r18
    543e:	30 e0       	ldi	r19, 0x00	; 0
    5440:	4e 81       	ldd	r20, Y+6	; 0x06
    5442:	5f 81       	ldd	r21, Y+7	; 0x07
    5444:	24 0f       	add	r18, r20
    5446:	35 1f       	adc	r19, r21
    5448:	28 5f       	subi	r18, 0xF8	; 248
    544a:	3f 4f       	sbci	r19, 0xFF	; 255
    544c:	f9 01       	movw	r30, r18
    544e:	20 81       	ld	r18, Z
    5450:	27 95       	ror	r18
    5452:	22 27       	eor	r18, r18
    5454:	27 95       	ror	r18
    5456:	26 0f       	add	r18, r22
    5458:	fc 01       	movw	r30, r24
    545a:	20 83       	st	Z, r18
        i++;
    545c:	89 81       	ldd	r24, Y+1	; 0x01
    545e:	8f 5f       	subi	r24, 0xFF	; 255
    5460:	89 83       	std	Y+1, r24	; 0x01
        j++;
    5462:	8a 81       	ldd	r24, Y+2	; 0x02
    5464:	8f 5f       	subi	r24, 0xFF	; 255
    5466:	8a 83       	std	Y+2, r24	; 0x02
    if(currentStringCallback) {
      byte bufferLength = (sysexBytesRead - 1) / 2;
      char *buffer = (char*)malloc(bufferLength * sizeof(char));
      byte i = 1;
      byte j = 0;
      while(j < bufferLength) {
    5468:	81 e0       	ldi	r24, 0x01	; 1
    546a:	2a 81       	ldd	r18, Y+2	; 0x02
    546c:	9b 81       	ldd	r25, Y+3	; 0x03
    546e:	29 17       	cp	r18, r25
    5470:	08 f0       	brcs	.+2      	; 0x5474 <_ZN12FirmataClass19processSysexMessageEv+0x102>
    5472:	80 e0       	ldi	r24, 0x00	; 0
    5474:	88 23       	and	r24, r24
    5476:	09 f0       	breq	.+2      	; 0x547a <_ZN12FirmataClass19processSysexMessageEv+0x108>
    5478:	b9 cf       	rjmp	.-142    	; 0x53ec <_ZN12FirmataClass19processSysexMessageEv+0x7a>
        i++;
        buffer[j] += (char)(storedInputData[i] << 7);
        i++;
        j++;
      }
      (*currentStringCallback)(buffer);
    547a:	8e 81       	ldd	r24, Y+6	; 0x06
    547c:	9f 81       	ldd	r25, Y+7	; 0x07
    547e:	fc 01       	movw	r30, r24
    5480:	27 a9       	ldd	r18, Z+55	; 0x37
    5482:	30 ad       	ldd	r19, Z+56	; 0x38
    5484:	8c 81       	ldd	r24, Y+4	; 0x04
    5486:	9d 81       	ldd	r25, Y+5	; 0x05
    5488:	f9 01       	movw	r30, r18
    548a:	09 95       	icall
    }
    break;
    548c:	1f c0       	rjmp	.+62     	; 0x54cc <_ZN12FirmataClass19processSysexMessageEv+0x15a>
  default:
    if(currentSysexCallback)
    548e:	8e 81       	ldd	r24, Y+6	; 0x06
    5490:	9f 81       	ldd	r25, Y+7	; 0x07
    5492:	fc 01       	movw	r30, r24
    5494:	81 ad       	ldd	r24, Z+57	; 0x39
    5496:	92 ad       	ldd	r25, Z+58	; 0x3a
    5498:	00 97       	sbiw	r24, 0x00	; 0
    549a:	c9 f0       	breq	.+50     	; 0x54ce <_ZN12FirmataClass19processSysexMessageEv+0x15c>
      (*currentSysexCallback)(storedInputData[0], sysexBytesRead - 1, storedInputData + 1);
    549c:	8e 81       	ldd	r24, Y+6	; 0x06
    549e:	9f 81       	ldd	r25, Y+7	; 0x07
    54a0:	fc 01       	movw	r30, r24
    54a2:	21 ad       	ldd	r18, Z+57	; 0x39
    54a4:	32 ad       	ldd	r19, Z+58	; 0x3a
    54a6:	8e 81       	ldd	r24, Y+6	; 0x06
    54a8:	9f 81       	ldd	r25, Y+7	; 0x07
    54aa:	09 96       	adiw	r24, 0x09	; 9
    54ac:	4e 81       	ldd	r20, Y+6	; 0x06
    54ae:	5f 81       	ldd	r21, Y+7	; 0x07
    54b0:	fa 01       	movw	r30, r20
    54b2:	41 a5       	ldd	r20, Z+41	; 0x29
    54b4:	52 a5       	ldd	r21, Z+42	; 0x2a
    54b6:	64 2f       	mov	r22, r20
    54b8:	61 50       	subi	r22, 0x01	; 1
    54ba:	4e 81       	ldd	r20, Y+6	; 0x06
    54bc:	5f 81       	ldd	r21, Y+7	; 0x07
    54be:	fa 01       	movw	r30, r20
    54c0:	70 85       	ldd	r23, Z+8	; 0x08
    54c2:	ac 01       	movw	r20, r24
    54c4:	87 2f       	mov	r24, r23
    54c6:	f9 01       	movw	r30, r18
    54c8:	09 95       	icall
    54ca:	01 c0       	rjmp	.+2      	; 0x54ce <_ZN12FirmataClass19processSysexMessageEv+0x15c>
        i++;
        j++;
      }
      (*currentStringCallback)(buffer);
    }
    break;
    54cc:	00 00       	nop
  default:
    if(currentSysexCallback)
      (*currentSysexCallback)(storedInputData[0], sysexBytesRead - 1, storedInputData + 1);
  }
}
    54ce:	27 96       	adiw	r28, 0x07	; 7
    54d0:	0f b6       	in	r0, 0x3f	; 63
    54d2:	f8 94       	cli
    54d4:	de bf       	out	0x3e, r29	; 62
    54d6:	0f be       	out	0x3f, r0	; 63
    54d8:	cd bf       	out	0x3d, r28	; 61
    54da:	df 91       	pop	r29
    54dc:	cf 91       	pop	r28
    54de:	08 95       	ret

000054e0 <_ZN12FirmataClass12processInputEv>:

void FirmataClass::processInput(void)
{
    54e0:	cf 93       	push	r28
    54e2:	df 93       	push	r29
    54e4:	00 d0       	rcall	.+0      	; 0x54e6 <_ZN12FirmataClass12processInputEv+0x6>
    54e6:	00 d0       	rcall	.+0      	; 0x54e8 <_ZN12FirmataClass12processInputEv+0x8>
    54e8:	00 d0       	rcall	.+0      	; 0x54ea <_ZN12FirmataClass12processInputEv+0xa>
    54ea:	cd b7       	in	r28, 0x3d	; 61
    54ec:	de b7       	in	r29, 0x3e	; 62
    54ee:	9e 83       	std	Y+6, r25	; 0x06
    54f0:	8d 83       	std	Y+5, r24	; 0x05
  int inputData = FirmataSerial.read(); // this is 'int' to handle -1 when no data
    54f2:	8d 81       	ldd	r24, Y+5	; 0x05
    54f4:	9e 81       	ldd	r25, Y+6	; 0x06
    54f6:	fc 01       	movw	r30, r24
    54f8:	80 81       	ld	r24, Z
    54fa:	91 81       	ldd	r25, Z+1	; 0x01
    54fc:	fc 01       	movw	r30, r24
    54fe:	80 81       	ld	r24, Z
    5500:	91 81       	ldd	r25, Z+1	; 0x01
    5502:	06 96       	adiw	r24, 0x06	; 6
    5504:	fc 01       	movw	r30, r24
    5506:	20 81       	ld	r18, Z
    5508:	31 81       	ldd	r19, Z+1	; 0x01
    550a:	8d 81       	ldd	r24, Y+5	; 0x05
    550c:	9e 81       	ldd	r25, Y+6	; 0x06
    550e:	fc 01       	movw	r30, r24
    5510:	80 81       	ld	r24, Z
    5512:	91 81       	ldd	r25, Z+1	; 0x01
    5514:	f9 01       	movw	r30, r18
    5516:	09 95       	icall
    5518:	9c 83       	std	Y+4, r25	; 0x04
    551a:	8b 83       	std	Y+3, r24	; 0x03
  int command;
    
  // TODO make sure it handles -1 properly

  if (parsingSysex) {
    551c:	8d 81       	ldd	r24, Y+5	; 0x05
    551e:	9e 81       	ldd	r25, Y+6	; 0x06
    5520:	fc 01       	movw	r30, r24
    5522:	80 a5       	ldd	r24, Z+40	; 0x28
    5524:	88 23       	and	r24, r24
    5526:	49 f1       	breq	.+82     	; 0x557a <_ZN12FirmataClass12processInputEv+0x9a>
    if(inputData == END_SYSEX) {
    5528:	8b 81       	ldd	r24, Y+3	; 0x03
    552a:	9c 81       	ldd	r25, Y+4	; 0x04
    552c:	87 3f       	cpi	r24, 0xF7	; 247
    552e:	91 05       	cpc	r25, r1
    5530:	49 f4       	brne	.+18     	; 0x5544 <_ZN12FirmataClass12processInputEv+0x64>
      //stop sysex byte      
      parsingSysex = false;
    5532:	8d 81       	ldd	r24, Y+5	; 0x05
    5534:	9e 81       	ldd	r25, Y+6	; 0x06
    5536:	fc 01       	movw	r30, r24
    5538:	10 a6       	std	Z+40, r1	; 0x28
      //fire off handler function
      processSysexMessage();
    553a:	8d 81       	ldd	r24, Y+5	; 0x05
    553c:	9e 81       	ldd	r25, Y+6	; 0x06
    553e:	0e 94 b9 29 	call	0x5372	; 0x5372 <_ZN12FirmataClass19processSysexMessageEv>
    5542:	84 c1       	rjmp	.+776    	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
    } else {
      //normal data byte - add to buffer
      storedInputData[sysexBytesRead] = inputData;
    5544:	8d 81       	ldd	r24, Y+5	; 0x05
    5546:	9e 81       	ldd	r25, Y+6	; 0x06
    5548:	fc 01       	movw	r30, r24
    554a:	81 a5       	ldd	r24, Z+41	; 0x29
    554c:	92 a5       	ldd	r25, Z+42	; 0x2a
    554e:	4b 81       	ldd	r20, Y+3	; 0x03
    5550:	2d 81       	ldd	r18, Y+5	; 0x05
    5552:	3e 81       	ldd	r19, Y+6	; 0x06
    5554:	82 0f       	add	r24, r18
    5556:	93 1f       	adc	r25, r19
    5558:	08 96       	adiw	r24, 0x08	; 8
    555a:	fc 01       	movw	r30, r24
    555c:	40 83       	st	Z, r20
      sysexBytesRead++;
    555e:	8d 81       	ldd	r24, Y+5	; 0x05
    5560:	9e 81       	ldd	r25, Y+6	; 0x06
    5562:	fc 01       	movw	r30, r24
    5564:	81 a5       	ldd	r24, Z+41	; 0x29
    5566:	92 a5       	ldd	r25, Z+42	; 0x2a
    5568:	9c 01       	movw	r18, r24
    556a:	2f 5f       	subi	r18, 0xFF	; 255
    556c:	3f 4f       	sbci	r19, 0xFF	; 255
    556e:	8d 81       	ldd	r24, Y+5	; 0x05
    5570:	9e 81       	ldd	r25, Y+6	; 0x06
    5572:	fc 01       	movw	r30, r24
    5574:	32 a7       	std	Z+42, r19	; 0x2a
    5576:	21 a7       	std	Z+41, r18	; 0x29
    5578:	69 c1       	rjmp	.+722    	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
    }
  } else if( (waitForData > 0) && (inputData < 128) ) {  
    557a:	8d 81       	ldd	r24, Y+5	; 0x05
    557c:	9e 81       	ldd	r25, Y+6	; 0x06
    557e:	fc 01       	movw	r30, r24
    5580:	85 81       	ldd	r24, Z+5	; 0x05
    5582:	88 23       	and	r24, r24
    5584:	09 f4       	brne	.+2      	; 0x5588 <_ZN12FirmataClass12processInputEv+0xa8>
    5586:	fd c0       	rjmp	.+506    	; 0x5782 <_ZN12FirmataClass12processInputEv+0x2a2>
    5588:	8b 81       	ldd	r24, Y+3	; 0x03
    558a:	9c 81       	ldd	r25, Y+4	; 0x04
    558c:	80 38       	cpi	r24, 0x80	; 128
    558e:	91 05       	cpc	r25, r1
    5590:	0c f0       	brlt	.+2      	; 0x5594 <_ZN12FirmataClass12processInputEv+0xb4>
    5592:	f7 c0       	rjmp	.+494    	; 0x5782 <_ZN12FirmataClass12processInputEv+0x2a2>
    waitForData--;
    5594:	8d 81       	ldd	r24, Y+5	; 0x05
    5596:	9e 81       	ldd	r25, Y+6	; 0x06
    5598:	fc 01       	movw	r30, r24
    559a:	85 81       	ldd	r24, Z+5	; 0x05
    559c:	28 2f       	mov	r18, r24
    559e:	21 50       	subi	r18, 0x01	; 1
    55a0:	8d 81       	ldd	r24, Y+5	; 0x05
    55a2:	9e 81       	ldd	r25, Y+6	; 0x06
    55a4:	fc 01       	movw	r30, r24
    55a6:	25 83       	std	Z+5, r18	; 0x05
    storedInputData[waitForData] = inputData;
    55a8:	8d 81       	ldd	r24, Y+5	; 0x05
    55aa:	9e 81       	ldd	r25, Y+6	; 0x06
    55ac:	fc 01       	movw	r30, r24
    55ae:	85 81       	ldd	r24, Z+5	; 0x05
    55b0:	88 2f       	mov	r24, r24
    55b2:	90 e0       	ldi	r25, 0x00	; 0
    55b4:	4b 81       	ldd	r20, Y+3	; 0x03
    55b6:	2d 81       	ldd	r18, Y+5	; 0x05
    55b8:	3e 81       	ldd	r19, Y+6	; 0x06
    55ba:	82 0f       	add	r24, r18
    55bc:	93 1f       	adc	r25, r19
    55be:	08 96       	adiw	r24, 0x08	; 8
    55c0:	fc 01       	movw	r30, r24
    55c2:	40 83       	st	Z, r20
    if( (waitForData==0) && executeMultiByteCommand ) { // got the whole message
    55c4:	8d 81       	ldd	r24, Y+5	; 0x05
    55c6:	9e 81       	ldd	r25, Y+6	; 0x06
    55c8:	fc 01       	movw	r30, r24
    55ca:	85 81       	ldd	r24, Z+5	; 0x05
    55cc:	88 23       	and	r24, r24
    55ce:	09 f0       	breq	.+2      	; 0x55d2 <_ZN12FirmataClass12processInputEv+0xf2>
    55d0:	3d c1       	rjmp	.+634    	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
    55d2:	8d 81       	ldd	r24, Y+5	; 0x05
    55d4:	9e 81       	ldd	r25, Y+6	; 0x06
    55d6:	fc 01       	movw	r30, r24
    55d8:	86 81       	ldd	r24, Z+6	; 0x06
    55da:	88 23       	and	r24, r24
    55dc:	09 f4       	brne	.+2      	; 0x55e0 <_ZN12FirmataClass12processInputEv+0x100>
    55de:	36 c1       	rjmp	.+620    	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
      switch(executeMultiByteCommand) {
    55e0:	8d 81       	ldd	r24, Y+5	; 0x05
    55e2:	9e 81       	ldd	r25, Y+6	; 0x06
    55e4:	fc 01       	movw	r30, r24
    55e6:	86 81       	ldd	r24, Z+6	; 0x06
    55e8:	88 2f       	mov	r24, r24
    55ea:	90 e0       	ldi	r25, 0x00	; 0
    55ec:	80 3d       	cpi	r24, 0xD0	; 208
    55ee:	91 05       	cpc	r25, r1
    55f0:	09 f4       	brne	.+2      	; 0x55f4 <_ZN12FirmataClass12processInputEv+0x114>
    55f2:	9e c0       	rjmp	.+316    	; 0x5730 <_ZN12FirmataClass12processInputEv+0x250>
    55f4:	81 3d       	cpi	r24, 0xD1	; 209
    55f6:	91 05       	cpc	r25, r1
    55f8:	44 f4       	brge	.+16     	; 0x560a <_ZN12FirmataClass12processInputEv+0x12a>
    55fa:	80 39       	cpi	r24, 0x90	; 144
    55fc:	91 05       	cpc	r25, r1
    55fe:	b9 f1       	breq	.+110    	; 0x566e <_ZN12FirmataClass12processInputEv+0x18e>
    5600:	80 3c       	cpi	r24, 0xC0	; 192
    5602:	91 05       	cpc	r25, r1
    5604:	09 f4       	brne	.+2      	; 0x5608 <_ZN12FirmataClass12processInputEv+0x128>
    5606:	79 c0       	rjmp	.+242    	; 0x56fa <_ZN12FirmataClass12processInputEv+0x21a>
    5608:	b7 c0       	rjmp	.+366    	; 0x5778 <_ZN12FirmataClass12processInputEv+0x298>
    560a:	80 3e       	cpi	r24, 0xE0	; 224
    560c:	91 05       	cpc	r25, r1
    560e:	29 f0       	breq	.+10     	; 0x561a <_ZN12FirmataClass12processInputEv+0x13a>
    5610:	84 3f       	cpi	r24, 0xF4	; 244
    5612:	91 05       	cpc	r25, r1
    5614:	09 f4       	brne	.+2      	; 0x5618 <_ZN12FirmataClass12processInputEv+0x138>
    5616:	55 c0       	rjmp	.+170    	; 0x56c2 <_ZN12FirmataClass12processInputEv+0x1e2>
    5618:	af c0       	rjmp	.+350    	; 0x5778 <_ZN12FirmataClass12processInputEv+0x298>
      case ANALOG_MESSAGE:
        if(currentAnalogCallback) {
    561a:	8d 81       	ldd	r24, Y+5	; 0x05
    561c:	9e 81       	ldd	r25, Y+6	; 0x06
    561e:	fc 01       	movw	r30, r24
    5620:	83 a5       	ldd	r24, Z+43	; 0x2b
    5622:	94 a5       	ldd	r25, Z+44	; 0x2c
    5624:	00 97       	sbiw	r24, 0x00	; 0
    5626:	09 f4       	brne	.+2      	; 0x562a <_ZN12FirmataClass12processInputEv+0x14a>
    5628:	9e c0       	rjmp	.+316    	; 0x5766 <_ZN12FirmataClass12processInputEv+0x286>
          (*currentAnalogCallback)(multiByteChannel,
                                   (storedInputData[0] << 7)
                                   + storedInputData[1]);
    562a:	8d 81       	ldd	r24, Y+5	; 0x05
    562c:	9e 81       	ldd	r25, Y+6	; 0x06
    562e:	fc 01       	movw	r30, r24
    5630:	23 a5       	ldd	r18, Z+43	; 0x2b
    5632:	34 a5       	ldd	r19, Z+44	; 0x2c
    if( (waitForData==0) && executeMultiByteCommand ) { // got the whole message
      switch(executeMultiByteCommand) {
      case ANALOG_MESSAGE:
        if(currentAnalogCallback) {
          (*currentAnalogCallback)(multiByteChannel,
                                   (storedInputData[0] << 7)
    5634:	8d 81       	ldd	r24, Y+5	; 0x05
    5636:	9e 81       	ldd	r25, Y+6	; 0x06
    5638:	fc 01       	movw	r30, r24
    563a:	80 85       	ldd	r24, Z+8	; 0x08
                                   + storedInputData[1]);
    563c:	88 2f       	mov	r24, r24
    563e:	90 e0       	ldi	r25, 0x00	; 0
    5640:	ac 01       	movw	r20, r24
    5642:	56 95       	lsr	r21
    5644:	54 2f       	mov	r21, r20
    5646:	44 27       	eor	r20, r20
    5648:	57 95       	ror	r21
    564a:	47 95       	ror	r20
    564c:	8d 81       	ldd	r24, Y+5	; 0x05
    564e:	9e 81       	ldd	r25, Y+6	; 0x06
    5650:	fc 01       	movw	r30, r24
    5652:	81 85       	ldd	r24, Z+9	; 0x09
    5654:	88 2f       	mov	r24, r24
    5656:	90 e0       	ldi	r25, 0x00	; 0
    5658:	84 0f       	add	r24, r20
    565a:	95 1f       	adc	r25, r21
    565c:	4d 81       	ldd	r20, Y+5	; 0x05
    565e:	5e 81       	ldd	r21, Y+6	; 0x06
    5660:	fa 01       	movw	r30, r20
    5662:	47 81       	ldd	r20, Z+7	; 0x07
    5664:	bc 01       	movw	r22, r24
    5666:	84 2f       	mov	r24, r20
    5668:	f9 01       	movw	r30, r18
    566a:	09 95       	icall
        }
        break;
    566c:	7c c0       	rjmp	.+248    	; 0x5766 <_ZN12FirmataClass12processInputEv+0x286>
      case DIGITAL_MESSAGE:
        if(currentDigitalCallback) {
    566e:	8d 81       	ldd	r24, Y+5	; 0x05
    5670:	9e 81       	ldd	r25, Y+6	; 0x06
    5672:	fc 01       	movw	r30, r24
    5674:	85 a5       	ldd	r24, Z+45	; 0x2d
    5676:	96 a5       	ldd	r25, Z+46	; 0x2e
    5678:	00 97       	sbiw	r24, 0x00	; 0
    567a:	09 f4       	brne	.+2      	; 0x567e <_ZN12FirmataClass12processInputEv+0x19e>
    567c:	76 c0       	rjmp	.+236    	; 0x576a <_ZN12FirmataClass12processInputEv+0x28a>
          (*currentDigitalCallback)(multiByteChannel,
                                    (storedInputData[0] << 7)
                                    + storedInputData[1]);
    567e:	8d 81       	ldd	r24, Y+5	; 0x05
    5680:	9e 81       	ldd	r25, Y+6	; 0x06
    5682:	fc 01       	movw	r30, r24
    5684:	25 a5       	ldd	r18, Z+45	; 0x2d
    5686:	36 a5       	ldd	r19, Z+46	; 0x2e
        }
        break;
      case DIGITAL_MESSAGE:
        if(currentDigitalCallback) {
          (*currentDigitalCallback)(multiByteChannel,
                                    (storedInputData[0] << 7)
    5688:	8d 81       	ldd	r24, Y+5	; 0x05
    568a:	9e 81       	ldd	r25, Y+6	; 0x06
    568c:	fc 01       	movw	r30, r24
    568e:	80 85       	ldd	r24, Z+8	; 0x08
                                    + storedInputData[1]);
    5690:	88 2f       	mov	r24, r24
    5692:	90 e0       	ldi	r25, 0x00	; 0
    5694:	ac 01       	movw	r20, r24
    5696:	56 95       	lsr	r21
    5698:	54 2f       	mov	r21, r20
    569a:	44 27       	eor	r20, r20
    569c:	57 95       	ror	r21
    569e:	47 95       	ror	r20
    56a0:	8d 81       	ldd	r24, Y+5	; 0x05
    56a2:	9e 81       	ldd	r25, Y+6	; 0x06
    56a4:	fc 01       	movw	r30, r24
    56a6:	81 85       	ldd	r24, Z+9	; 0x09
    56a8:	88 2f       	mov	r24, r24
    56aa:	90 e0       	ldi	r25, 0x00	; 0
    56ac:	84 0f       	add	r24, r20
    56ae:	95 1f       	adc	r25, r21
    56b0:	4d 81       	ldd	r20, Y+5	; 0x05
    56b2:	5e 81       	ldd	r21, Y+6	; 0x06
    56b4:	fa 01       	movw	r30, r20
    56b6:	47 81       	ldd	r20, Z+7	; 0x07
    56b8:	bc 01       	movw	r22, r24
    56ba:	84 2f       	mov	r24, r20
    56bc:	f9 01       	movw	r30, r18
    56be:	09 95       	icall
        }
        break;
    56c0:	54 c0       	rjmp	.+168    	; 0x576a <_ZN12FirmataClass12processInputEv+0x28a>
      case SET_PIN_MODE:
        if(currentPinModeCallback)
    56c2:	8d 81       	ldd	r24, Y+5	; 0x05
    56c4:	9e 81       	ldd	r25, Y+6	; 0x06
    56c6:	fc 01       	movw	r30, r24
    56c8:	83 a9       	ldd	r24, Z+51	; 0x33
    56ca:	94 a9       	ldd	r25, Z+52	; 0x34
    56cc:	00 97       	sbiw	r24, 0x00	; 0
    56ce:	09 f4       	brne	.+2      	; 0x56d2 <_ZN12FirmataClass12processInputEv+0x1f2>
    56d0:	4e c0       	rjmp	.+156    	; 0x576e <_ZN12FirmataClass12processInputEv+0x28e>
          (*currentPinModeCallback)(storedInputData[1], storedInputData[0]);
    56d2:	8d 81       	ldd	r24, Y+5	; 0x05
    56d4:	9e 81       	ldd	r25, Y+6	; 0x06
    56d6:	fc 01       	movw	r30, r24
    56d8:	23 a9       	ldd	r18, Z+51	; 0x33
    56da:	34 a9       	ldd	r19, Z+52	; 0x34
    56dc:	8d 81       	ldd	r24, Y+5	; 0x05
    56de:	9e 81       	ldd	r25, Y+6	; 0x06
    56e0:	fc 01       	movw	r30, r24
    56e2:	80 85       	ldd	r24, Z+8	; 0x08
    56e4:	88 2f       	mov	r24, r24
    56e6:	90 e0       	ldi	r25, 0x00	; 0
    56e8:	4d 81       	ldd	r20, Y+5	; 0x05
    56ea:	5e 81       	ldd	r21, Y+6	; 0x06
    56ec:	fa 01       	movw	r30, r20
    56ee:	41 85       	ldd	r20, Z+9	; 0x09
    56f0:	bc 01       	movw	r22, r24
    56f2:	84 2f       	mov	r24, r20
    56f4:	f9 01       	movw	r30, r18
    56f6:	09 95       	icall
        break;
    56f8:	3a c0       	rjmp	.+116    	; 0x576e <_ZN12FirmataClass12processInputEv+0x28e>
      case REPORT_ANALOG:
        if(currentReportAnalogCallback)
    56fa:	8d 81       	ldd	r24, Y+5	; 0x05
    56fc:	9e 81       	ldd	r25, Y+6	; 0x06
    56fe:	fc 01       	movw	r30, r24
    5700:	87 a5       	ldd	r24, Z+47	; 0x2f
    5702:	90 a9       	ldd	r25, Z+48	; 0x30
    5704:	00 97       	sbiw	r24, 0x00	; 0
    5706:	a9 f1       	breq	.+106    	; 0x5772 <_ZN12FirmataClass12processInputEv+0x292>
          (*currentReportAnalogCallback)(multiByteChannel,storedInputData[0]);
    5708:	8d 81       	ldd	r24, Y+5	; 0x05
    570a:	9e 81       	ldd	r25, Y+6	; 0x06
    570c:	fc 01       	movw	r30, r24
    570e:	27 a5       	ldd	r18, Z+47	; 0x2f
    5710:	30 a9       	ldd	r19, Z+48	; 0x30
    5712:	8d 81       	ldd	r24, Y+5	; 0x05
    5714:	9e 81       	ldd	r25, Y+6	; 0x06
    5716:	fc 01       	movw	r30, r24
    5718:	80 85       	ldd	r24, Z+8	; 0x08
    571a:	88 2f       	mov	r24, r24
    571c:	90 e0       	ldi	r25, 0x00	; 0
    571e:	4d 81       	ldd	r20, Y+5	; 0x05
    5720:	5e 81       	ldd	r21, Y+6	; 0x06
    5722:	fa 01       	movw	r30, r20
    5724:	47 81       	ldd	r20, Z+7	; 0x07
    5726:	bc 01       	movw	r22, r24
    5728:	84 2f       	mov	r24, r20
    572a:	f9 01       	movw	r30, r18
    572c:	09 95       	icall
        break;
    572e:	21 c0       	rjmp	.+66     	; 0x5772 <_ZN12FirmataClass12processInputEv+0x292>
      case REPORT_DIGITAL:
        if(currentReportDigitalCallback)
    5730:	8d 81       	ldd	r24, Y+5	; 0x05
    5732:	9e 81       	ldd	r25, Y+6	; 0x06
    5734:	fc 01       	movw	r30, r24
    5736:	81 a9       	ldd	r24, Z+49	; 0x31
    5738:	92 a9       	ldd	r25, Z+50	; 0x32
    573a:	00 97       	sbiw	r24, 0x00	; 0
    573c:	e1 f0       	breq	.+56     	; 0x5776 <_ZN12FirmataClass12processInputEv+0x296>
          (*currentReportDigitalCallback)(multiByteChannel,storedInputData[0]);
    573e:	8d 81       	ldd	r24, Y+5	; 0x05
    5740:	9e 81       	ldd	r25, Y+6	; 0x06
    5742:	fc 01       	movw	r30, r24
    5744:	21 a9       	ldd	r18, Z+49	; 0x31
    5746:	32 a9       	ldd	r19, Z+50	; 0x32
    5748:	8d 81       	ldd	r24, Y+5	; 0x05
    574a:	9e 81       	ldd	r25, Y+6	; 0x06
    574c:	fc 01       	movw	r30, r24
    574e:	80 85       	ldd	r24, Z+8	; 0x08
    5750:	88 2f       	mov	r24, r24
    5752:	90 e0       	ldi	r25, 0x00	; 0
    5754:	4d 81       	ldd	r20, Y+5	; 0x05
    5756:	5e 81       	ldd	r21, Y+6	; 0x06
    5758:	fa 01       	movw	r30, r20
    575a:	47 81       	ldd	r20, Z+7	; 0x07
    575c:	bc 01       	movw	r22, r24
    575e:	84 2f       	mov	r24, r20
    5760:	f9 01       	movw	r30, r18
    5762:	09 95       	icall
        break;
    5764:	08 c0       	rjmp	.+16     	; 0x5776 <_ZN12FirmataClass12processInputEv+0x296>
        if(currentAnalogCallback) {
          (*currentAnalogCallback)(multiByteChannel,
                                   (storedInputData[0] << 7)
                                   + storedInputData[1]);
        }
        break;
    5766:	00 00       	nop
    5768:	07 c0       	rjmp	.+14     	; 0x5778 <_ZN12FirmataClass12processInputEv+0x298>
        if(currentDigitalCallback) {
          (*currentDigitalCallback)(multiByteChannel,
                                    (storedInputData[0] << 7)
                                    + storedInputData[1]);
        }
        break;
    576a:	00 00       	nop
    576c:	05 c0       	rjmp	.+10     	; 0x5778 <_ZN12FirmataClass12processInputEv+0x298>
      case SET_PIN_MODE:
        if(currentPinModeCallback)
          (*currentPinModeCallback)(storedInputData[1], storedInputData[0]);
        break;
    576e:	00 00       	nop
    5770:	03 c0       	rjmp	.+6      	; 0x5778 <_ZN12FirmataClass12processInputEv+0x298>
      case REPORT_ANALOG:
        if(currentReportAnalogCallback)
          (*currentReportAnalogCallback)(multiByteChannel,storedInputData[0]);
        break;
    5772:	00 00       	nop
    5774:	01 c0       	rjmp	.+2      	; 0x5778 <_ZN12FirmataClass12processInputEv+0x298>
      case REPORT_DIGITAL:
        if(currentReportDigitalCallback)
          (*currentReportDigitalCallback)(multiByteChannel,storedInputData[0]);
        break;
    5776:	00 00       	nop
      }
      executeMultiByteCommand = 0;
    5778:	8d 81       	ldd	r24, Y+5	; 0x05
    577a:	9e 81       	ldd	r25, Y+6	; 0x06
    577c:	fc 01       	movw	r30, r24
    577e:	16 82       	std	Z+6, r1	; 0x06
      sysexBytesRead++;
    }
  } else if( (waitForData > 0) && (inputData < 128) ) {  
    waitForData--;
    storedInputData[waitForData] = inputData;
    if( (waitForData==0) && executeMultiByteCommand ) { // got the whole message
    5780:	65 c0       	rjmp	.+202    	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
      }
      executeMultiByteCommand = 0;
    }	
  } else {
    // remove channel info from command byte if less than 0xF0
    if(inputData < 0xF0) {
    5782:	8b 81       	ldd	r24, Y+3	; 0x03
    5784:	9c 81       	ldd	r25, Y+4	; 0x04
    5786:	80 3f       	cpi	r24, 0xF0	; 240
    5788:	91 05       	cpc	r25, r1
    578a:	74 f4       	brge	.+28     	; 0x57a8 <_ZN12FirmataClass12processInputEv+0x2c8>
      command = inputData & 0xF0;
    578c:	8b 81       	ldd	r24, Y+3	; 0x03
    578e:	9c 81       	ldd	r25, Y+4	; 0x04
    5790:	80 7f       	andi	r24, 0xF0	; 240
    5792:	99 27       	eor	r25, r25
    5794:	9a 83       	std	Y+2, r25	; 0x02
    5796:	89 83       	std	Y+1, r24	; 0x01
      multiByteChannel = inputData & 0x0F;
    5798:	8b 81       	ldd	r24, Y+3	; 0x03
    579a:	28 2f       	mov	r18, r24
    579c:	2f 70       	andi	r18, 0x0F	; 15
    579e:	8d 81       	ldd	r24, Y+5	; 0x05
    57a0:	9e 81       	ldd	r25, Y+6	; 0x06
    57a2:	fc 01       	movw	r30, r24
    57a4:	27 83       	std	Z+7, r18	; 0x07
    57a6:	04 c0       	rjmp	.+8      	; 0x57b0 <_ZN12FirmataClass12processInputEv+0x2d0>
    } else {
      command = inputData;
    57a8:	8b 81       	ldd	r24, Y+3	; 0x03
    57aa:	9c 81       	ldd	r25, Y+4	; 0x04
    57ac:	9a 83       	std	Y+2, r25	; 0x02
    57ae:	89 83       	std	Y+1, r24	; 0x01
      // commands in the 0xF* range don't use channel data
    }
    switch (command) {
    57b0:	89 81       	ldd	r24, Y+1	; 0x01
    57b2:	9a 81       	ldd	r25, Y+2	; 0x02
    57b4:	80 3e       	cpi	r24, 0xE0	; 224
    57b6:	91 05       	cpc	r25, r1
    57b8:	f1 f0       	breq	.+60     	; 0x57f6 <_ZN12FirmataClass12processInputEv+0x316>
    57ba:	81 3e       	cpi	r24, 0xE1	; 225
    57bc:	91 05       	cpc	r25, r1
    57be:	54 f4       	brge	.+20     	; 0x57d4 <_ZN12FirmataClass12processInputEv+0x2f4>
    57c0:	80 3c       	cpi	r24, 0xC0	; 192
    57c2:	91 05       	cpc	r25, r1
    57c4:	19 f1       	breq	.+70     	; 0x580c <_ZN12FirmataClass12processInputEv+0x32c>
    57c6:	80 3d       	cpi	r24, 0xD0	; 208
    57c8:	91 05       	cpc	r25, r1
    57ca:	01 f1       	breq	.+64     	; 0x580c <_ZN12FirmataClass12processInputEv+0x32c>
    57cc:	80 39       	cpi	r24, 0x90	; 144
    57ce:	91 05       	cpc	r25, r1
    57d0:	91 f0       	breq	.+36     	; 0x57f6 <_ZN12FirmataClass12processInputEv+0x316>
    57d2:	3c c0       	rjmp	.+120    	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
    57d4:	84 3f       	cpi	r24, 0xF4	; 244
    57d6:	91 05       	cpc	r25, r1
    57d8:	71 f0       	breq	.+28     	; 0x57f6 <_ZN12FirmataClass12processInputEv+0x316>
    57da:	85 3f       	cpi	r24, 0xF5	; 245
    57dc:	91 05       	cpc	r25, r1
    57de:	24 f4       	brge	.+8      	; 0x57e8 <_ZN12FirmataClass12processInputEv+0x308>
    57e0:	80 3f       	cpi	r24, 0xF0	; 240
    57e2:	91 05       	cpc	r25, r1
    57e4:	f1 f0       	breq	.+60     	; 0x5822 <_ZN12FirmataClass12processInputEv+0x342>
    57e6:	32 c0       	rjmp	.+100    	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
    57e8:	89 3f       	cpi	r24, 0xF9	; 249
    57ea:	91 05       	cpc	r25, r1
    57ec:	51 f1       	breq	.+84     	; 0x5842 <_ZN12FirmataClass12processInputEv+0x362>
    57ee:	8f 3f       	cpi	r24, 0xFF	; 255
    57f0:	91 05       	cpc	r25, r1
    57f2:	11 f1       	breq	.+68     	; 0x5838 <_ZN12FirmataClass12processInputEv+0x358>
    57f4:	2b c0       	rjmp	.+86     	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
    case ANALOG_MESSAGE:
    case DIGITAL_MESSAGE:
    case SET_PIN_MODE:
      waitForData = 2; // two data bytes needed
    57f6:	8d 81       	ldd	r24, Y+5	; 0x05
    57f8:	9e 81       	ldd	r25, Y+6	; 0x06
    57fa:	22 e0       	ldi	r18, 0x02	; 2
    57fc:	fc 01       	movw	r30, r24
    57fe:	25 83       	std	Z+5, r18	; 0x05
      executeMultiByteCommand = command;
    5800:	29 81       	ldd	r18, Y+1	; 0x01
    5802:	8d 81       	ldd	r24, Y+5	; 0x05
    5804:	9e 81       	ldd	r25, Y+6	; 0x06
    5806:	fc 01       	movw	r30, r24
    5808:	26 83       	std	Z+6, r18	; 0x06
      break;
    580a:	20 c0       	rjmp	.+64     	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
    case REPORT_ANALOG:
    case REPORT_DIGITAL:
      waitForData = 1; // one data byte needed
    580c:	8d 81       	ldd	r24, Y+5	; 0x05
    580e:	9e 81       	ldd	r25, Y+6	; 0x06
    5810:	21 e0       	ldi	r18, 0x01	; 1
    5812:	fc 01       	movw	r30, r24
    5814:	25 83       	std	Z+5, r18	; 0x05
      executeMultiByteCommand = command;
    5816:	29 81       	ldd	r18, Y+1	; 0x01
    5818:	8d 81       	ldd	r24, Y+5	; 0x05
    581a:	9e 81       	ldd	r25, Y+6	; 0x06
    581c:	fc 01       	movw	r30, r24
    581e:	26 83       	std	Z+6, r18	; 0x06
      break;
    5820:	15 c0       	rjmp	.+42     	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
    case START_SYSEX:
      parsingSysex = true;
    5822:	8d 81       	ldd	r24, Y+5	; 0x05
    5824:	9e 81       	ldd	r25, Y+6	; 0x06
    5826:	21 e0       	ldi	r18, 0x01	; 1
    5828:	fc 01       	movw	r30, r24
    582a:	20 a7       	std	Z+40, r18	; 0x28
      sysexBytesRead = 0;
    582c:	8d 81       	ldd	r24, Y+5	; 0x05
    582e:	9e 81       	ldd	r25, Y+6	; 0x06
    5830:	fc 01       	movw	r30, r24
    5832:	12 a6       	std	Z+42, r1	; 0x2a
    5834:	11 a6       	std	Z+41, r1	; 0x29
      break;
    5836:	0a c0       	rjmp	.+20     	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
    case SYSTEM_RESET:
      systemReset();
    5838:	8d 81       	ldd	r24, Y+5	; 0x05
    583a:	9e 81       	ldd	r25, Y+6	; 0x06
    583c:	0e 94 41 2e 	call	0x5c82	; 0x5c82 <_ZN12FirmataClass11systemResetEv>
      break;
    5840:	05 c0       	rjmp	.+10     	; 0x584c <_ZN12FirmataClass12processInputEv+0x36c>
    case REPORT_VERSION:
      Firmata.printVersion();
    5842:	8f e4       	ldi	r24, 0x4F	; 79
    5844:	97 e0       	ldi	r25, 0x07	; 7
    5846:	0e 94 0c 28 	call	0x5018	; 0x5018 <_ZN12FirmataClass12printVersionEv>
      break;
    584a:	00 00       	nop
    }
  }
}
    584c:	26 96       	adiw	r28, 0x06	; 6
    584e:	0f b6       	in	r0, 0x3f	; 63
    5850:	f8 94       	cli
    5852:	de bf       	out	0x3e, r29	; 62
    5854:	0f be       	out	0x3f, r0	; 63
    5856:	cd bf       	out	0x3d, r28	; 61
    5858:	df 91       	pop	r29
    585a:	cf 91       	pop	r28
    585c:	08 95       	ret

0000585e <_ZN12FirmataClass10sendAnalogEhi>:
//------------------------------------------------------------------------------
// Serial Send Handling

// send an analog message
void FirmataClass::sendAnalog(byte pin, int value) 
{
    585e:	cf 93       	push	r28
    5860:	df 93       	push	r29
    5862:	00 d0       	rcall	.+0      	; 0x5864 <_ZN12FirmataClass10sendAnalogEhi+0x6>
    5864:	00 d0       	rcall	.+0      	; 0x5866 <_ZN12FirmataClass10sendAnalogEhi+0x8>
    5866:	1f 92       	push	r1
    5868:	cd b7       	in	r28, 0x3d	; 61
    586a:	de b7       	in	r29, 0x3e	; 62
    586c:	9a 83       	std	Y+2, r25	; 0x02
    586e:	89 83       	std	Y+1, r24	; 0x01
    5870:	6b 83       	std	Y+3, r22	; 0x03
    5872:	5d 83       	std	Y+5, r21	; 0x05
    5874:	4c 83       	std	Y+4, r20	; 0x04
  // pin can only be 0-15, so chop higher bits
  FirmataSerial.write(ANALOG_MESSAGE | (pin & 0xF));
    5876:	89 81       	ldd	r24, Y+1	; 0x01
    5878:	9a 81       	ldd	r25, Y+2	; 0x02
    587a:	fc 01       	movw	r30, r24
    587c:	80 81       	ld	r24, Z
    587e:	91 81       	ldd	r25, Z+1	; 0x01
    5880:	fc 01       	movw	r30, r24
    5882:	80 81       	ld	r24, Z
    5884:	91 81       	ldd	r25, Z+1	; 0x01
    5886:	fc 01       	movw	r30, r24
    5888:	20 81       	ld	r18, Z
    588a:	31 81       	ldd	r19, Z+1	; 0x01
    588c:	8b 81       	ldd	r24, Y+3	; 0x03
    588e:	8f 70       	andi	r24, 0x0F	; 15
    5890:	80 6e       	ori	r24, 0xE0	; 224
    5892:	48 2f       	mov	r20, r24
    5894:	89 81       	ldd	r24, Y+1	; 0x01
    5896:	9a 81       	ldd	r25, Y+2	; 0x02
    5898:	fc 01       	movw	r30, r24
    589a:	80 81       	ld	r24, Z
    589c:	91 81       	ldd	r25, Z+1	; 0x01
    589e:	64 2f       	mov	r22, r20
    58a0:	f9 01       	movw	r30, r18
    58a2:	09 95       	icall
  sendValueAsTwo7bitBytes(value);
    58a4:	2c 81       	ldd	r18, Y+4	; 0x04
    58a6:	3d 81       	ldd	r19, Y+5	; 0x05
    58a8:	89 81       	ldd	r24, Y+1	; 0x01
    58aa:	9a 81       	ldd	r25, Y+2	; 0x02
    58ac:	b9 01       	movw	r22, r18
    58ae:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <_ZN12FirmataClass23sendValueAsTwo7bitBytesEi>
}
    58b2:	0f 90       	pop	r0
    58b4:	0f 90       	pop	r0
    58b6:	0f 90       	pop	r0
    58b8:	0f 90       	pop	r0
    58ba:	0f 90       	pop	r0
    58bc:	df 91       	pop	r29
    58be:	cf 91       	pop	r28
    58c0:	08 95       	ret

000058c2 <_ZN12FirmataClass11sendDigitalEhi>:

// send a single digital pin in a digital message
void FirmataClass::sendDigital(byte pin, int value) 
{
    58c2:	cf 93       	push	r28
    58c4:	df 93       	push	r29
    58c6:	00 d0       	rcall	.+0      	; 0x58c8 <_ZN12FirmataClass11sendDigitalEhi+0x6>
    58c8:	00 d0       	rcall	.+0      	; 0x58ca <_ZN12FirmataClass11sendDigitalEhi+0x8>
    58ca:	1f 92       	push	r1
    58cc:	cd b7       	in	r28, 0x3d	; 61
    58ce:	de b7       	in	r29, 0x3e	; 62
    58d0:	9a 83       	std	Y+2, r25	; 0x02
    58d2:	89 83       	std	Y+1, r24	; 0x01
    58d4:	6b 83       	std	Y+3, r22	; 0x03
    58d6:	5d 83       	std	Y+5, r21	; 0x05
    58d8:	4c 83       	std	Y+4, r20	; 0x04
  // before the digital message is sent on the serial port, it should send a
  // digital message for each change.

  //    if(value == 0)
  //        sendDigitalPortPair();
}
    58da:	0f 90       	pop	r0
    58dc:	0f 90       	pop	r0
    58de:	0f 90       	pop	r0
    58e0:	0f 90       	pop	r0
    58e2:	0f 90       	pop	r0
    58e4:	df 91       	pop	r29
    58e6:	cf 91       	pop	r28
    58e8:	08 95       	ret

000058ea <_ZN12FirmataClass15sendDigitalPortEhi>:


// send 14-bits in a single digital message (protocol v1)
// send an 8-bit port in a single digital message (protocol v2)
void FirmataClass::sendDigitalPort(byte portNumber, int portData)
{
    58ea:	cf 93       	push	r28
    58ec:	df 93       	push	r29
    58ee:	00 d0       	rcall	.+0      	; 0x58f0 <_ZN12FirmataClass15sendDigitalPortEhi+0x6>
    58f0:	00 d0       	rcall	.+0      	; 0x58f2 <_ZN12FirmataClass15sendDigitalPortEhi+0x8>
    58f2:	1f 92       	push	r1
    58f4:	cd b7       	in	r28, 0x3d	; 61
    58f6:	de b7       	in	r29, 0x3e	; 62
    58f8:	9a 83       	std	Y+2, r25	; 0x02
    58fa:	89 83       	std	Y+1, r24	; 0x01
    58fc:	6b 83       	std	Y+3, r22	; 0x03
    58fe:	5d 83       	std	Y+5, r21	; 0x05
    5900:	4c 83       	std	Y+4, r20	; 0x04
  FirmataSerial.write(DIGITAL_MESSAGE | (portNumber & 0xF));
    5902:	89 81       	ldd	r24, Y+1	; 0x01
    5904:	9a 81       	ldd	r25, Y+2	; 0x02
    5906:	fc 01       	movw	r30, r24
    5908:	80 81       	ld	r24, Z
    590a:	91 81       	ldd	r25, Z+1	; 0x01
    590c:	fc 01       	movw	r30, r24
    590e:	80 81       	ld	r24, Z
    5910:	91 81       	ldd	r25, Z+1	; 0x01
    5912:	fc 01       	movw	r30, r24
    5914:	20 81       	ld	r18, Z
    5916:	31 81       	ldd	r19, Z+1	; 0x01
    5918:	8b 81       	ldd	r24, Y+3	; 0x03
    591a:	8f 70       	andi	r24, 0x0F	; 15
    591c:	80 69       	ori	r24, 0x90	; 144
    591e:	48 2f       	mov	r20, r24
    5920:	89 81       	ldd	r24, Y+1	; 0x01
    5922:	9a 81       	ldd	r25, Y+2	; 0x02
    5924:	fc 01       	movw	r30, r24
    5926:	80 81       	ld	r24, Z
    5928:	91 81       	ldd	r25, Z+1	; 0x01
    592a:	64 2f       	mov	r22, r20
    592c:	f9 01       	movw	r30, r18
    592e:	09 95       	icall
  FirmataSerial.write((byte)portData % 128); // Tx bits 0-6
    5930:	89 81       	ldd	r24, Y+1	; 0x01
    5932:	9a 81       	ldd	r25, Y+2	; 0x02
    5934:	fc 01       	movw	r30, r24
    5936:	80 81       	ld	r24, Z
    5938:	91 81       	ldd	r25, Z+1	; 0x01
    593a:	fc 01       	movw	r30, r24
    593c:	80 81       	ld	r24, Z
    593e:	91 81       	ldd	r25, Z+1	; 0x01
    5940:	fc 01       	movw	r30, r24
    5942:	20 81       	ld	r18, Z
    5944:	31 81       	ldd	r19, Z+1	; 0x01
    5946:	8c 81       	ldd	r24, Y+4	; 0x04
    5948:	48 2f       	mov	r20, r24
    594a:	4f 77       	andi	r20, 0x7F	; 127
    594c:	89 81       	ldd	r24, Y+1	; 0x01
    594e:	9a 81       	ldd	r25, Y+2	; 0x02
    5950:	fc 01       	movw	r30, r24
    5952:	80 81       	ld	r24, Z
    5954:	91 81       	ldd	r25, Z+1	; 0x01
    5956:	64 2f       	mov	r22, r20
    5958:	f9 01       	movw	r30, r18
    595a:	09 95       	icall
  FirmataSerial.write(portData >> 7);  // Tx bits 7-13
    595c:	89 81       	ldd	r24, Y+1	; 0x01
    595e:	9a 81       	ldd	r25, Y+2	; 0x02
    5960:	fc 01       	movw	r30, r24
    5962:	80 81       	ld	r24, Z
    5964:	91 81       	ldd	r25, Z+1	; 0x01
    5966:	fc 01       	movw	r30, r24
    5968:	80 81       	ld	r24, Z
    596a:	91 81       	ldd	r25, Z+1	; 0x01
    596c:	fc 01       	movw	r30, r24
    596e:	20 81       	ld	r18, Z
    5970:	31 81       	ldd	r19, Z+1	; 0x01
    5972:	8c 81       	ldd	r24, Y+4	; 0x04
    5974:	9d 81       	ldd	r25, Y+5	; 0x05
    5976:	88 0f       	add	r24, r24
    5978:	89 2f       	mov	r24, r25
    597a:	88 1f       	adc	r24, r24
    597c:	99 0b       	sbc	r25, r25
    597e:	48 2f       	mov	r20, r24
    5980:	89 81       	ldd	r24, Y+1	; 0x01
    5982:	9a 81       	ldd	r25, Y+2	; 0x02
    5984:	fc 01       	movw	r30, r24
    5986:	80 81       	ld	r24, Z
    5988:	91 81       	ldd	r25, Z+1	; 0x01
    598a:	64 2f       	mov	r22, r20
    598c:	f9 01       	movw	r30, r18
    598e:	09 95       	icall
}
    5990:	0f 90       	pop	r0
    5992:	0f 90       	pop	r0
    5994:	0f 90       	pop	r0
    5996:	0f 90       	pop	r0
    5998:	0f 90       	pop	r0
    599a:	df 91       	pop	r29
    599c:	cf 91       	pop	r28
    599e:	08 95       	ret

000059a0 <_ZN12FirmataClass9sendSysexEhhPh>:


void FirmataClass::sendSysex(byte command, byte bytec, byte* bytev) 
{
    59a0:	cf 93       	push	r28
    59a2:	df 93       	push	r29
    59a4:	cd b7       	in	r28, 0x3d	; 61
    59a6:	de b7       	in	r29, 0x3e	; 62
    59a8:	27 97       	sbiw	r28, 0x07	; 7
    59aa:	0f b6       	in	r0, 0x3f	; 63
    59ac:	f8 94       	cli
    59ae:	de bf       	out	0x3e, r29	; 62
    59b0:	0f be       	out	0x3f, r0	; 63
    59b2:	cd bf       	out	0x3d, r28	; 61
    59b4:	9b 83       	std	Y+3, r25	; 0x03
    59b6:	8a 83       	std	Y+2, r24	; 0x02
    59b8:	6c 83       	std	Y+4, r22	; 0x04
    59ba:	4d 83       	std	Y+5, r20	; 0x05
    59bc:	3f 83       	std	Y+7, r19	; 0x07
    59be:	2e 83       	std	Y+6, r18	; 0x06
  byte i;
  startSysex();
    59c0:	8a 81       	ldd	r24, Y+2	; 0x02
    59c2:	9b 81       	ldd	r25, Y+3	; 0x03
    59c4:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <_ZN12FirmataClass10startSysexEv>
  FirmataSerial.write(command);
    59c8:	8a 81       	ldd	r24, Y+2	; 0x02
    59ca:	9b 81       	ldd	r25, Y+3	; 0x03
    59cc:	fc 01       	movw	r30, r24
    59ce:	80 81       	ld	r24, Z
    59d0:	91 81       	ldd	r25, Z+1	; 0x01
    59d2:	fc 01       	movw	r30, r24
    59d4:	80 81       	ld	r24, Z
    59d6:	91 81       	ldd	r25, Z+1	; 0x01
    59d8:	fc 01       	movw	r30, r24
    59da:	20 81       	ld	r18, Z
    59dc:	31 81       	ldd	r19, Z+1	; 0x01
    59de:	8a 81       	ldd	r24, Y+2	; 0x02
    59e0:	9b 81       	ldd	r25, Y+3	; 0x03
    59e2:	fc 01       	movw	r30, r24
    59e4:	80 81       	ld	r24, Z
    59e6:	91 81       	ldd	r25, Z+1	; 0x01
    59e8:	6c 81       	ldd	r22, Y+4	; 0x04
    59ea:	f9 01       	movw	r30, r18
    59ec:	09 95       	icall
  for(i=0; i<bytec; i++) {
    59ee:	19 82       	std	Y+1, r1	; 0x01
    59f0:	13 c0       	rjmp	.+38     	; 0x5a18 <_ZN12FirmataClass9sendSysexEhhPh+0x78>
    sendValueAsTwo7bitBytes(bytev[i]);        
    59f2:	89 81       	ldd	r24, Y+1	; 0x01
    59f4:	88 2f       	mov	r24, r24
    59f6:	90 e0       	ldi	r25, 0x00	; 0
    59f8:	2e 81       	ldd	r18, Y+6	; 0x06
    59fa:	3f 81       	ldd	r19, Y+7	; 0x07
    59fc:	82 0f       	add	r24, r18
    59fe:	93 1f       	adc	r25, r19
    5a00:	fc 01       	movw	r30, r24
    5a02:	80 81       	ld	r24, Z
    5a04:	28 2f       	mov	r18, r24
    5a06:	30 e0       	ldi	r19, 0x00	; 0
    5a08:	8a 81       	ldd	r24, Y+2	; 0x02
    5a0a:	9b 81       	ldd	r25, Y+3	; 0x03
    5a0c:	b9 01       	movw	r22, r18
    5a0e:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <_ZN12FirmataClass23sendValueAsTwo7bitBytesEi>
void FirmataClass::sendSysex(byte command, byte bytec, byte* bytev) 
{
  byte i;
  startSysex();
  FirmataSerial.write(command);
  for(i=0; i<bytec; i++) {
    5a12:	89 81       	ldd	r24, Y+1	; 0x01
    5a14:	8f 5f       	subi	r24, 0xFF	; 255
    5a16:	89 83       	std	Y+1, r24	; 0x01
    5a18:	81 e0       	ldi	r24, 0x01	; 1
    5a1a:	29 81       	ldd	r18, Y+1	; 0x01
    5a1c:	9d 81       	ldd	r25, Y+5	; 0x05
    5a1e:	29 17       	cp	r18, r25
    5a20:	08 f0       	brcs	.+2      	; 0x5a24 <_ZN12FirmataClass9sendSysexEhhPh+0x84>
    5a22:	80 e0       	ldi	r24, 0x00	; 0
    5a24:	88 23       	and	r24, r24
    5a26:	29 f7       	brne	.-54     	; 0x59f2 <_ZN12FirmataClass9sendSysexEhhPh+0x52>
    sendValueAsTwo7bitBytes(bytev[i]);        
  }
  endSysex();
    5a28:	8a 81       	ldd	r24, Y+2	; 0x02
    5a2a:	9b 81       	ldd	r25, Y+3	; 0x03
    5a2c:	0e 94 5d 27 	call	0x4eba	; 0x4eba <_ZN12FirmataClass8endSysexEv>
}
    5a30:	27 96       	adiw	r28, 0x07	; 7
    5a32:	0f b6       	in	r0, 0x3f	; 63
    5a34:	f8 94       	cli
    5a36:	de bf       	out	0x3e, r29	; 62
    5a38:	0f be       	out	0x3f, r0	; 63
    5a3a:	cd bf       	out	0x3d, r28	; 61
    5a3c:	df 91       	pop	r29
    5a3e:	cf 91       	pop	r28
    5a40:	08 95       	ret

00005a42 <_ZN12FirmataClass10sendStringEhPKc>:

void FirmataClass::sendString(byte command, const char* string) 
{
    5a42:	cf 93       	push	r28
    5a44:	df 93       	push	r29
    5a46:	00 d0       	rcall	.+0      	; 0x5a48 <_ZN12FirmataClass10sendStringEhPKc+0x6>
    5a48:	00 d0       	rcall	.+0      	; 0x5a4a <_ZN12FirmataClass10sendStringEhPKc+0x8>
    5a4a:	1f 92       	push	r1
    5a4c:	cd b7       	in	r28, 0x3d	; 61
    5a4e:	de b7       	in	r29, 0x3e	; 62
    5a50:	9a 83       	std	Y+2, r25	; 0x02
    5a52:	89 83       	std	Y+1, r24	; 0x01
    5a54:	6b 83       	std	Y+3, r22	; 0x03
    5a56:	5d 83       	std	Y+5, r21	; 0x05
    5a58:	4c 83       	std	Y+4, r20	; 0x04
  sendSysex(command, strlen(string), (byte *)string);
    5a5a:	8c 81       	ldd	r24, Y+4	; 0x04
    5a5c:	9d 81       	ldd	r25, Y+5	; 0x05
    5a5e:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    5a62:	48 2f       	mov	r20, r24
    5a64:	2c 81       	ldd	r18, Y+4	; 0x04
    5a66:	3d 81       	ldd	r19, Y+5	; 0x05
    5a68:	89 81       	ldd	r24, Y+1	; 0x01
    5a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    5a6c:	6b 81       	ldd	r22, Y+3	; 0x03
    5a6e:	0e 94 d0 2c 	call	0x59a0	; 0x59a0 <_ZN12FirmataClass9sendSysexEhhPh>
}
    5a72:	0f 90       	pop	r0
    5a74:	0f 90       	pop	r0
    5a76:	0f 90       	pop	r0
    5a78:	0f 90       	pop	r0
    5a7a:	0f 90       	pop	r0
    5a7c:	df 91       	pop	r29
    5a7e:	cf 91       	pop	r28
    5a80:	08 95       	ret

00005a82 <_ZN12FirmataClass10sendStringEPKc>:


// send a string as the protocol string type
void FirmataClass::sendString(const char* string) 
{
    5a82:	cf 93       	push	r28
    5a84:	df 93       	push	r29
    5a86:	00 d0       	rcall	.+0      	; 0x5a88 <_ZN12FirmataClass10sendStringEPKc+0x6>
    5a88:	00 d0       	rcall	.+0      	; 0x5a8a <_ZN12FirmataClass10sendStringEPKc+0x8>
    5a8a:	cd b7       	in	r28, 0x3d	; 61
    5a8c:	de b7       	in	r29, 0x3e	; 62
    5a8e:	9a 83       	std	Y+2, r25	; 0x02
    5a90:	89 83       	std	Y+1, r24	; 0x01
    5a92:	7c 83       	std	Y+4, r23	; 0x04
    5a94:	6b 83       	std	Y+3, r22	; 0x03
  sendString(STRING_DATA, string);
    5a96:	2b 81       	ldd	r18, Y+3	; 0x03
    5a98:	3c 81       	ldd	r19, Y+4	; 0x04
    5a9a:	89 81       	ldd	r24, Y+1	; 0x01
    5a9c:	9a 81       	ldd	r25, Y+2	; 0x02
    5a9e:	a9 01       	movw	r20, r18
    5aa0:	61 e7       	ldi	r22, 0x71	; 113
    5aa2:	0e 94 21 2d 	call	0x5a42	; 0x5a42 <_ZN12FirmataClass10sendStringEhPKc>
}
    5aa6:	0f 90       	pop	r0
    5aa8:	0f 90       	pop	r0
    5aaa:	0f 90       	pop	r0
    5aac:	0f 90       	pop	r0
    5aae:	df 91       	pop	r29
    5ab0:	cf 91       	pop	r28
    5ab2:	08 95       	ret

00005ab4 <_ZN12FirmataClass6attachEhPFvhiE>:

// Internal Actions/////////////////////////////////////////////////////////////

// generic callbacks
void FirmataClass::attach(byte command, callbackFunction newFunction)
{
    5ab4:	cf 93       	push	r28
    5ab6:	df 93       	push	r29
    5ab8:	00 d0       	rcall	.+0      	; 0x5aba <_ZN12FirmataClass6attachEhPFvhiE+0x6>
    5aba:	00 d0       	rcall	.+0      	; 0x5abc <_ZN12FirmataClass6attachEhPFvhiE+0x8>
    5abc:	1f 92       	push	r1
    5abe:	cd b7       	in	r28, 0x3d	; 61
    5ac0:	de b7       	in	r29, 0x3e	; 62
    5ac2:	9a 83       	std	Y+2, r25	; 0x02
    5ac4:	89 83       	std	Y+1, r24	; 0x01
    5ac6:	6b 83       	std	Y+3, r22	; 0x03
    5ac8:	5d 83       	std	Y+5, r21	; 0x05
    5aca:	4c 83       	std	Y+4, r20	; 0x04
  switch(command) {
    5acc:	8b 81       	ldd	r24, Y+3	; 0x03
    5ace:	88 2f       	mov	r24, r24
    5ad0:	90 e0       	ldi	r25, 0x00	; 0
    5ad2:	80 3d       	cpi	r24, 0xD0	; 208
    5ad4:	91 05       	cpc	r25, r1
    5ad6:	49 f1       	breq	.+82     	; 0x5b2a <_ZN12FirmataClass6attachEhPFvhiE+0x76>
    5ad8:	81 3d       	cpi	r24, 0xD1	; 209
    5ada:	91 05       	cpc	r25, r1
    5adc:	3c f4       	brge	.+14     	; 0x5aec <_ZN12FirmataClass6attachEhPFvhiE+0x38>
    5ade:	80 39       	cpi	r24, 0x90	; 144
    5ae0:	91 05       	cpc	r25, r1
    5ae2:	99 f0       	breq	.+38     	; 0x5b0a <_ZN12FirmataClass6attachEhPFvhiE+0x56>
    5ae4:	80 3c       	cpi	r24, 0xC0	; 192
    5ae6:	91 05       	cpc	r25, r1
    5ae8:	c1 f0       	breq	.+48     	; 0x5b1a <_ZN12FirmataClass6attachEhPFvhiE+0x66>
    5aea:	2f c0       	rjmp	.+94     	; 0x5b4a <_ZN12FirmataClass6attachEhPFvhiE+0x96>
    5aec:	80 3e       	cpi	r24, 0xE0	; 224
    5aee:	91 05       	cpc	r25, r1
    5af0:	21 f0       	breq	.+8      	; 0x5afa <_ZN12FirmataClass6attachEhPFvhiE+0x46>
    5af2:	84 3f       	cpi	r24, 0xF4	; 244
    5af4:	91 05       	cpc	r25, r1
    5af6:	09 f1       	breq	.+66     	; 0x5b3a <_ZN12FirmataClass6attachEhPFvhiE+0x86>
    5af8:	28 c0       	rjmp	.+80     	; 0x5b4a <_ZN12FirmataClass6attachEhPFvhiE+0x96>
  case ANALOG_MESSAGE: currentAnalogCallback = newFunction; break;
    5afa:	89 81       	ldd	r24, Y+1	; 0x01
    5afc:	9a 81       	ldd	r25, Y+2	; 0x02
    5afe:	2c 81       	ldd	r18, Y+4	; 0x04
    5b00:	3d 81       	ldd	r19, Y+5	; 0x05
    5b02:	fc 01       	movw	r30, r24
    5b04:	34 a7       	std	Z+44, r19	; 0x2c
    5b06:	23 a7       	std	Z+43, r18	; 0x2b
    5b08:	20 c0       	rjmp	.+64     	; 0x5b4a <_ZN12FirmataClass6attachEhPFvhiE+0x96>
  case DIGITAL_MESSAGE: currentDigitalCallback = newFunction; break;
    5b0a:	89 81       	ldd	r24, Y+1	; 0x01
    5b0c:	9a 81       	ldd	r25, Y+2	; 0x02
    5b0e:	2c 81       	ldd	r18, Y+4	; 0x04
    5b10:	3d 81       	ldd	r19, Y+5	; 0x05
    5b12:	fc 01       	movw	r30, r24
    5b14:	36 a7       	std	Z+46, r19	; 0x2e
    5b16:	25 a7       	std	Z+45, r18	; 0x2d
    5b18:	18 c0       	rjmp	.+48     	; 0x5b4a <_ZN12FirmataClass6attachEhPFvhiE+0x96>
  case REPORT_ANALOG: currentReportAnalogCallback = newFunction; break;
    5b1a:	89 81       	ldd	r24, Y+1	; 0x01
    5b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    5b1e:	2c 81       	ldd	r18, Y+4	; 0x04
    5b20:	3d 81       	ldd	r19, Y+5	; 0x05
    5b22:	fc 01       	movw	r30, r24
    5b24:	30 ab       	std	Z+48, r19	; 0x30
    5b26:	27 a7       	std	Z+47, r18	; 0x2f
    5b28:	10 c0       	rjmp	.+32     	; 0x5b4a <_ZN12FirmataClass6attachEhPFvhiE+0x96>
  case REPORT_DIGITAL: currentReportDigitalCallback = newFunction; break;
    5b2a:	89 81       	ldd	r24, Y+1	; 0x01
    5b2c:	9a 81       	ldd	r25, Y+2	; 0x02
    5b2e:	2c 81       	ldd	r18, Y+4	; 0x04
    5b30:	3d 81       	ldd	r19, Y+5	; 0x05
    5b32:	fc 01       	movw	r30, r24
    5b34:	32 ab       	std	Z+50, r19	; 0x32
    5b36:	21 ab       	std	Z+49, r18	; 0x31
    5b38:	08 c0       	rjmp	.+16     	; 0x5b4a <_ZN12FirmataClass6attachEhPFvhiE+0x96>
  case SET_PIN_MODE: currentPinModeCallback = newFunction; break;
    5b3a:	89 81       	ldd	r24, Y+1	; 0x01
    5b3c:	9a 81       	ldd	r25, Y+2	; 0x02
    5b3e:	2c 81       	ldd	r18, Y+4	; 0x04
    5b40:	3d 81       	ldd	r19, Y+5	; 0x05
    5b42:	fc 01       	movw	r30, r24
    5b44:	34 ab       	std	Z+52, r19	; 0x34
    5b46:	23 ab       	std	Z+51, r18	; 0x33
    5b48:	00 00       	nop
  }
}
    5b4a:	0f 90       	pop	r0
    5b4c:	0f 90       	pop	r0
    5b4e:	0f 90       	pop	r0
    5b50:	0f 90       	pop	r0
    5b52:	0f 90       	pop	r0
    5b54:	df 91       	pop	r29
    5b56:	cf 91       	pop	r28
    5b58:	08 95       	ret

00005b5a <_ZN12FirmataClass6attachEhPFvvE>:

void FirmataClass::attach(byte command, systemResetCallbackFunction newFunction)
{
    5b5a:	cf 93       	push	r28
    5b5c:	df 93       	push	r29
    5b5e:	00 d0       	rcall	.+0      	; 0x5b60 <_ZN12FirmataClass6attachEhPFvvE+0x6>
    5b60:	00 d0       	rcall	.+0      	; 0x5b62 <_ZN12FirmataClass6attachEhPFvvE+0x8>
    5b62:	1f 92       	push	r1
    5b64:	cd b7       	in	r28, 0x3d	; 61
    5b66:	de b7       	in	r29, 0x3e	; 62
    5b68:	9a 83       	std	Y+2, r25	; 0x02
    5b6a:	89 83       	std	Y+1, r24	; 0x01
    5b6c:	6b 83       	std	Y+3, r22	; 0x03
    5b6e:	5d 83       	std	Y+5, r21	; 0x05
    5b70:	4c 83       	std	Y+4, r20	; 0x04
  switch(command) {
    5b72:	8b 81       	ldd	r24, Y+3	; 0x03
    5b74:	88 2f       	mov	r24, r24
    5b76:	90 e0       	ldi	r25, 0x00	; 0
    5b78:	8f 3f       	cpi	r24, 0xFF	; 255
    5b7a:	91 05       	cpc	r25, r1
    5b7c:	41 f4       	brne	.+16     	; 0x5b8e <_ZN12FirmataClass6attachEhPFvvE+0x34>
  case SYSTEM_RESET: currentSystemResetCallback = newFunction; break;
    5b7e:	89 81       	ldd	r24, Y+1	; 0x01
    5b80:	9a 81       	ldd	r25, Y+2	; 0x02
    5b82:	2c 81       	ldd	r18, Y+4	; 0x04
    5b84:	3d 81       	ldd	r19, Y+5	; 0x05
    5b86:	fc 01       	movw	r30, r24
    5b88:	36 ab       	std	Z+54, r19	; 0x36
    5b8a:	25 ab       	std	Z+53, r18	; 0x35
    5b8c:	00 00       	nop
  }
}
    5b8e:	0f 90       	pop	r0
    5b90:	0f 90       	pop	r0
    5b92:	0f 90       	pop	r0
    5b94:	0f 90       	pop	r0
    5b96:	0f 90       	pop	r0
    5b98:	df 91       	pop	r29
    5b9a:	cf 91       	pop	r28
    5b9c:	08 95       	ret

00005b9e <_ZN12FirmataClass6attachEhPFvPcE>:

void FirmataClass::attach(byte command, stringCallbackFunction newFunction)
{
    5b9e:	cf 93       	push	r28
    5ba0:	df 93       	push	r29
    5ba2:	00 d0       	rcall	.+0      	; 0x5ba4 <_ZN12FirmataClass6attachEhPFvPcE+0x6>
    5ba4:	00 d0       	rcall	.+0      	; 0x5ba6 <_ZN12FirmataClass6attachEhPFvPcE+0x8>
    5ba6:	1f 92       	push	r1
    5ba8:	cd b7       	in	r28, 0x3d	; 61
    5baa:	de b7       	in	r29, 0x3e	; 62
    5bac:	9a 83       	std	Y+2, r25	; 0x02
    5bae:	89 83       	std	Y+1, r24	; 0x01
    5bb0:	6b 83       	std	Y+3, r22	; 0x03
    5bb2:	5d 83       	std	Y+5, r21	; 0x05
    5bb4:	4c 83       	std	Y+4, r20	; 0x04
  switch(command) {
    5bb6:	8b 81       	ldd	r24, Y+3	; 0x03
    5bb8:	88 2f       	mov	r24, r24
    5bba:	90 e0       	ldi	r25, 0x00	; 0
    5bbc:	81 37       	cpi	r24, 0x71	; 113
    5bbe:	91 05       	cpc	r25, r1
    5bc0:	41 f4       	brne	.+16     	; 0x5bd2 <_ZN12FirmataClass6attachEhPFvPcE+0x34>
  case STRING_DATA: currentStringCallback = newFunction; break;
    5bc2:	89 81       	ldd	r24, Y+1	; 0x01
    5bc4:	9a 81       	ldd	r25, Y+2	; 0x02
    5bc6:	2c 81       	ldd	r18, Y+4	; 0x04
    5bc8:	3d 81       	ldd	r19, Y+5	; 0x05
    5bca:	fc 01       	movw	r30, r24
    5bcc:	30 af       	std	Z+56, r19	; 0x38
    5bce:	27 ab       	std	Z+55, r18	; 0x37
    5bd0:	00 00       	nop
  }
}
    5bd2:	0f 90       	pop	r0
    5bd4:	0f 90       	pop	r0
    5bd6:	0f 90       	pop	r0
    5bd8:	0f 90       	pop	r0
    5bda:	0f 90       	pop	r0
    5bdc:	df 91       	pop	r29
    5bde:	cf 91       	pop	r28
    5be0:	08 95       	ret

00005be2 <_ZN12FirmataClass6attachEhPFvhhPhE>:

void FirmataClass::attach(byte command, sysexCallbackFunction newFunction)
{
    5be2:	cf 93       	push	r28
    5be4:	df 93       	push	r29
    5be6:	00 d0       	rcall	.+0      	; 0x5be8 <_ZN12FirmataClass6attachEhPFvhhPhE+0x6>
    5be8:	00 d0       	rcall	.+0      	; 0x5bea <_ZN12FirmataClass6attachEhPFvhhPhE+0x8>
    5bea:	1f 92       	push	r1
    5bec:	cd b7       	in	r28, 0x3d	; 61
    5bee:	de b7       	in	r29, 0x3e	; 62
    5bf0:	9a 83       	std	Y+2, r25	; 0x02
    5bf2:	89 83       	std	Y+1, r24	; 0x01
    5bf4:	6b 83       	std	Y+3, r22	; 0x03
    5bf6:	5d 83       	std	Y+5, r21	; 0x05
    5bf8:	4c 83       	std	Y+4, r20	; 0x04
  currentSysexCallback = newFunction;
    5bfa:	89 81       	ldd	r24, Y+1	; 0x01
    5bfc:	9a 81       	ldd	r25, Y+2	; 0x02
    5bfe:	2c 81       	ldd	r18, Y+4	; 0x04
    5c00:	3d 81       	ldd	r19, Y+5	; 0x05
    5c02:	fc 01       	movw	r30, r24
    5c04:	32 af       	std	Z+58, r19	; 0x3a
    5c06:	21 af       	std	Z+57, r18	; 0x39
}
    5c08:	0f 90       	pop	r0
    5c0a:	0f 90       	pop	r0
    5c0c:	0f 90       	pop	r0
    5c0e:	0f 90       	pop	r0
    5c10:	0f 90       	pop	r0
    5c12:	df 91       	pop	r29
    5c14:	cf 91       	pop	r28
    5c16:	08 95       	ret

00005c18 <_ZN12FirmataClass6detachEh>:

void FirmataClass::detach(byte command)
{
    5c18:	cf 93       	push	r28
    5c1a:	df 93       	push	r29
    5c1c:	00 d0       	rcall	.+0      	; 0x5c1e <_ZN12FirmataClass6detachEh+0x6>
    5c1e:	1f 92       	push	r1
    5c20:	cd b7       	in	r28, 0x3d	; 61
    5c22:	de b7       	in	r29, 0x3e	; 62
    5c24:	9a 83       	std	Y+2, r25	; 0x02
    5c26:	89 83       	std	Y+1, r24	; 0x01
    5c28:	6b 83       	std	Y+3, r22	; 0x03
  switch(command) {
    5c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    5c2c:	88 2f       	mov	r24, r24
    5c2e:	90 e0       	ldi	r25, 0x00	; 0
    5c30:	80 3f       	cpi	r24, 0xF0	; 240
    5c32:	91 05       	cpc	r25, r1
    5c34:	99 f0       	breq	.+38     	; 0x5c5c <_ZN12FirmataClass6detachEh+0x44>
    5c36:	8f 3f       	cpi	r24, 0xFF	; 255
    5c38:	91 05       	cpc	r25, r1
    5c3a:	21 f0       	breq	.+8      	; 0x5c44 <_ZN12FirmataClass6detachEh+0x2c>
    5c3c:	81 37       	cpi	r24, 0x71	; 113
    5c3e:	91 05       	cpc	r25, r1
    5c40:	39 f0       	breq	.+14     	; 0x5c50 <_ZN12FirmataClass6detachEh+0x38>
    5c42:	12 c0       	rjmp	.+36     	; 0x5c68 <_ZN12FirmataClass6detachEh+0x50>
  case SYSTEM_RESET: currentSystemResetCallback = NULL; break;
    5c44:	89 81       	ldd	r24, Y+1	; 0x01
    5c46:	9a 81       	ldd	r25, Y+2	; 0x02
    5c48:	fc 01       	movw	r30, r24
    5c4a:	16 aa       	std	Z+54, r1	; 0x36
    5c4c:	15 aa       	std	Z+53, r1	; 0x35
    5c4e:	13 c0       	rjmp	.+38     	; 0x5c76 <_ZN12FirmataClass6detachEh+0x5e>
  case STRING_DATA: currentStringCallback = NULL; break;
    5c50:	89 81       	ldd	r24, Y+1	; 0x01
    5c52:	9a 81       	ldd	r25, Y+2	; 0x02
    5c54:	fc 01       	movw	r30, r24
    5c56:	10 ae       	std	Z+56, r1	; 0x38
    5c58:	17 aa       	std	Z+55, r1	; 0x37
    5c5a:	0d c0       	rjmp	.+26     	; 0x5c76 <_ZN12FirmataClass6detachEh+0x5e>
  case START_SYSEX: currentSysexCallback = NULL; break;
    5c5c:	89 81       	ldd	r24, Y+1	; 0x01
    5c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    5c60:	fc 01       	movw	r30, r24
    5c62:	12 ae       	std	Z+58, r1	; 0x3a
    5c64:	11 ae       	std	Z+57, r1	; 0x39
    5c66:	07 c0       	rjmp	.+14     	; 0x5c76 <_ZN12FirmataClass6detachEh+0x5e>
  default:
    attach(command, (callbackFunction)NULL);
    5c68:	89 81       	ldd	r24, Y+1	; 0x01
    5c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    5c6c:	40 e0       	ldi	r20, 0x00	; 0
    5c6e:	50 e0       	ldi	r21, 0x00	; 0
    5c70:	6b 81       	ldd	r22, Y+3	; 0x03
    5c72:	0e 94 5a 2d 	call	0x5ab4	; 0x5ab4 <_ZN12FirmataClass6attachEhPFvhiE>
  }
}
    5c76:	0f 90       	pop	r0
    5c78:	0f 90       	pop	r0
    5c7a:	0f 90       	pop	r0
    5c7c:	df 91       	pop	r29
    5c7e:	cf 91       	pop	r28
    5c80:	08 95       	ret

00005c82 <_ZN12FirmataClass11systemResetEv>:



// resets the system state upon a SYSTEM_RESET message from the host software
void FirmataClass::systemReset(void)
{
    5c82:	cf 93       	push	r28
    5c84:	df 93       	push	r29
    5c86:	00 d0       	rcall	.+0      	; 0x5c88 <_ZN12FirmataClass11systemResetEv+0x6>
    5c88:	1f 92       	push	r1
    5c8a:	cd b7       	in	r28, 0x3d	; 61
    5c8c:	de b7       	in	r29, 0x3e	; 62
    5c8e:	9b 83       	std	Y+3, r25	; 0x03
    5c90:	8a 83       	std	Y+2, r24	; 0x02
  byte i;

  waitForData = 0; // this flag says the next serial input will be data
    5c92:	8a 81       	ldd	r24, Y+2	; 0x02
    5c94:	9b 81       	ldd	r25, Y+3	; 0x03
    5c96:	fc 01       	movw	r30, r24
    5c98:	15 82       	std	Z+5, r1	; 0x05
  executeMultiByteCommand = 0; // execute this after getting multi-byte data
    5c9a:	8a 81       	ldd	r24, Y+2	; 0x02
    5c9c:	9b 81       	ldd	r25, Y+3	; 0x03
    5c9e:	fc 01       	movw	r30, r24
    5ca0:	16 82       	std	Z+6, r1	; 0x06
  multiByteChannel = 0; // channel data for multiByteCommands
    5ca2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ca4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ca6:	fc 01       	movw	r30, r24
    5ca8:	17 82       	std	Z+7, r1	; 0x07


  for(i=0; i<MAX_DATA_BYTES; i++) {
    5caa:	19 82       	std	Y+1, r1	; 0x01
    5cac:	0d c0       	rjmp	.+26     	; 0x5cc8 <_ZN12FirmataClass11systemResetEv+0x46>
    storedInputData[i] = 0;
    5cae:	89 81       	ldd	r24, Y+1	; 0x01
    5cb0:	88 2f       	mov	r24, r24
    5cb2:	90 e0       	ldi	r25, 0x00	; 0
    5cb4:	2a 81       	ldd	r18, Y+2	; 0x02
    5cb6:	3b 81       	ldd	r19, Y+3	; 0x03
    5cb8:	82 0f       	add	r24, r18
    5cba:	93 1f       	adc	r25, r19
    5cbc:	08 96       	adiw	r24, 0x08	; 8
    5cbe:	fc 01       	movw	r30, r24
    5cc0:	10 82       	st	Z, r1
  waitForData = 0; // this flag says the next serial input will be data
  executeMultiByteCommand = 0; // execute this after getting multi-byte data
  multiByteChannel = 0; // channel data for multiByteCommands


  for(i=0; i<MAX_DATA_BYTES; i++) {
    5cc2:	89 81       	ldd	r24, Y+1	; 0x01
    5cc4:	8f 5f       	subi	r24, 0xFF	; 255
    5cc6:	89 83       	std	Y+1, r24	; 0x01
    5cc8:	81 e0       	ldi	r24, 0x01	; 1
    5cca:	99 81       	ldd	r25, Y+1	; 0x01
    5ccc:	90 32       	cpi	r25, 0x20	; 32
    5cce:	08 f0       	brcs	.+2      	; 0x5cd2 <_ZN12FirmataClass11systemResetEv+0x50>
    5cd0:	80 e0       	ldi	r24, 0x00	; 0
    5cd2:	88 23       	and	r24, r24
    5cd4:	61 f7       	brne	.-40     	; 0x5cae <_ZN12FirmataClass11systemResetEv+0x2c>
    storedInputData[i] = 0;
  }

  parsingSysex = false;
    5cd6:	8a 81       	ldd	r24, Y+2	; 0x02
    5cd8:	9b 81       	ldd	r25, Y+3	; 0x03
    5cda:	fc 01       	movw	r30, r24
    5cdc:	10 a6       	std	Z+40, r1	; 0x28
  sysexBytesRead = 0;
    5cde:	8a 81       	ldd	r24, Y+2	; 0x02
    5ce0:	9b 81       	ldd	r25, Y+3	; 0x03
    5ce2:	fc 01       	movw	r30, r24
    5ce4:	12 a6       	std	Z+42, r1	; 0x2a
    5ce6:	11 a6       	std	Z+41, r1	; 0x29

  if(currentSystemResetCallback)
    5ce8:	8a 81       	ldd	r24, Y+2	; 0x02
    5cea:	9b 81       	ldd	r25, Y+3	; 0x03
    5cec:	fc 01       	movw	r30, r24
    5cee:	85 a9       	ldd	r24, Z+53	; 0x35
    5cf0:	96 a9       	ldd	r25, Z+54	; 0x36
    5cf2:	00 97       	sbiw	r24, 0x00	; 0
    5cf4:	39 f0       	breq	.+14     	; 0x5d04 <_ZN12FirmataClass11systemResetEv+0x82>
    (*currentSystemResetCallback)();
    5cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    5cf8:	9b 81       	ldd	r25, Y+3	; 0x03
    5cfa:	fc 01       	movw	r30, r24
    5cfc:	85 a9       	ldd	r24, Z+53	; 0x35
    5cfe:	96 a9       	ldd	r25, Z+54	; 0x36
    5d00:	fc 01       	movw	r30, r24
    5d02:	09 95       	icall

  //flush(); //TODO uncomment when Firmata is a subclass of HardwareSerial
}
    5d04:	0f 90       	pop	r0
    5d06:	0f 90       	pop	r0
    5d08:	0f 90       	pop	r0
    5d0a:	df 91       	pop	r29
    5d0c:	cf 91       	pop	r28
    5d0e:	08 95       	ret

00005d10 <_ZN12FirmataClass11pin13strobeEiii>:


// =============================================================================
// used for flashing the pin for the version number
void FirmataClass::pin13strobe(int count, int onInterval, int offInterval) 
{
    5d10:	cf 93       	push	r28
    5d12:	df 93       	push	r29
    5d14:	cd b7       	in	r28, 0x3d	; 61
    5d16:	de b7       	in	r29, 0x3e	; 62
    5d18:	29 97       	sbiw	r28, 0x09	; 9
    5d1a:	0f b6       	in	r0, 0x3f	; 63
    5d1c:	f8 94       	cli
    5d1e:	de bf       	out	0x3e, r29	; 62
    5d20:	0f be       	out	0x3f, r0	; 63
    5d22:	cd bf       	out	0x3d, r28	; 61
    5d24:	9b 83       	std	Y+3, r25	; 0x03
    5d26:	8a 83       	std	Y+2, r24	; 0x02
    5d28:	7d 83       	std	Y+5, r23	; 0x05
    5d2a:	6c 83       	std	Y+4, r22	; 0x04
    5d2c:	5f 83       	std	Y+7, r21	; 0x07
    5d2e:	4e 83       	std	Y+6, r20	; 0x06
    5d30:	39 87       	std	Y+9, r19	; 0x09
    5d32:	28 87       	std	Y+8, r18	; 0x08
  byte i;
  pinMode(VERSION_BLINK_PIN, OUTPUT);
    5d34:	61 e0       	ldi	r22, 0x01	; 1
    5d36:	8d e0       	ldi	r24, 0x0D	; 13
    5d38:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
  for(i=0; i<count; i++) {
    5d3c:	19 82       	std	Y+1, r1	; 0x01
    5d3e:	1f c0       	rjmp	.+62     	; 0x5d7e <_ZN12FirmataClass11pin13strobeEiii+0x6e>
    delay(offInterval);
    5d40:	88 85       	ldd	r24, Y+8	; 0x08
    5d42:	99 85       	ldd	r25, Y+9	; 0x09
    5d44:	aa 27       	eor	r26, r26
    5d46:	97 fd       	sbrc	r25, 7
    5d48:	a0 95       	com	r26
    5d4a:	ba 2f       	mov	r27, r26
    5d4c:	bc 01       	movw	r22, r24
    5d4e:	cd 01       	movw	r24, r26
    5d50:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
    digitalWrite(VERSION_BLINK_PIN, HIGH);
    5d54:	61 e0       	ldi	r22, 0x01	; 1
    5d56:	8d e0       	ldi	r24, 0x0D	; 13
    5d58:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
    delay(onInterval);
    5d5c:	8e 81       	ldd	r24, Y+6	; 0x06
    5d5e:	9f 81       	ldd	r25, Y+7	; 0x07
    5d60:	aa 27       	eor	r26, r26
    5d62:	97 fd       	sbrc	r25, 7
    5d64:	a0 95       	com	r26
    5d66:	ba 2f       	mov	r27, r26
    5d68:	bc 01       	movw	r22, r24
    5d6a:	cd 01       	movw	r24, r26
    5d6c:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
    digitalWrite(VERSION_BLINK_PIN, LOW);
    5d70:	60 e0       	ldi	r22, 0x00	; 0
    5d72:	8d e0       	ldi	r24, 0x0D	; 13
    5d74:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
// used for flashing the pin for the version number
void FirmataClass::pin13strobe(int count, int onInterval, int offInterval) 
{
  byte i;
  pinMode(VERSION_BLINK_PIN, OUTPUT);
  for(i=0; i<count; i++) {
    5d78:	89 81       	ldd	r24, Y+1	; 0x01
    5d7a:	8f 5f       	subi	r24, 0xFF	; 255
    5d7c:	89 83       	std	Y+1, r24	; 0x01
    5d7e:	89 81       	ldd	r24, Y+1	; 0x01
    5d80:	28 2f       	mov	r18, r24
    5d82:	30 e0       	ldi	r19, 0x00	; 0
    5d84:	41 e0       	ldi	r20, 0x01	; 1
    5d86:	8c 81       	ldd	r24, Y+4	; 0x04
    5d88:	9d 81       	ldd	r25, Y+5	; 0x05
    5d8a:	28 17       	cp	r18, r24
    5d8c:	39 07       	cpc	r19, r25
    5d8e:	0c f0       	brlt	.+2      	; 0x5d92 <_ZN12FirmataClass11pin13strobeEiii+0x82>
    5d90:	40 e0       	ldi	r20, 0x00	; 0
    5d92:	44 23       	and	r20, r20
    5d94:	a9 f6       	brne	.-86     	; 0x5d40 <_ZN12FirmataClass11pin13strobeEiii+0x30>
    delay(offInterval);
    digitalWrite(VERSION_BLINK_PIN, HIGH);
    delay(onInterval);
    digitalWrite(VERSION_BLINK_PIN, LOW);
  }
}
    5d96:	29 96       	adiw	r28, 0x09	; 9
    5d98:	0f b6       	in	r0, 0x3f	; 63
    5d9a:	f8 94       	cli
    5d9c:	de bf       	out	0x3e, r29	; 62
    5d9e:	0f be       	out	0x3f, r0	; 63
    5da0:	cd bf       	out	0x3d, r28	; 61
    5da2:	df 91       	pop	r29
    5da4:	cf 91       	pop	r28
    5da6:	08 95       	ret

00005da8 <_Z41__static_initialization_and_destruction_0ii>:


// make one instance for the user to use
FirmataClass Firmata(Serial);
    5da8:	cf 93       	push	r28
    5daa:	df 93       	push	r29
    5dac:	00 d0       	rcall	.+0      	; 0x5dae <_Z41__static_initialization_and_destruction_0ii+0x6>
    5dae:	00 d0       	rcall	.+0      	; 0x5db0 <_Z41__static_initialization_and_destruction_0ii+0x8>
    5db0:	cd b7       	in	r28, 0x3d	; 61
    5db2:	de b7       	in	r29, 0x3e	; 62
    5db4:	9a 83       	std	Y+2, r25	; 0x02
    5db6:	89 83       	std	Y+1, r24	; 0x01
    5db8:	7c 83       	std	Y+4, r23	; 0x04
    5dba:	6b 83       	std	Y+3, r22	; 0x03
    5dbc:	89 81       	ldd	r24, Y+1	; 0x01
    5dbe:	9a 81       	ldd	r25, Y+2	; 0x02
    5dc0:	81 30       	cpi	r24, 0x01	; 1
    5dc2:	91 05       	cpc	r25, r1
    5dc4:	61 f4       	brne	.+24     	; 0x5dde <_Z41__static_initialization_and_destruction_0ii+0x36>
    5dc6:	8b 81       	ldd	r24, Y+3	; 0x03
    5dc8:	9c 81       	ldd	r25, Y+4	; 0x04
    5dca:	8f 3f       	cpi	r24, 0xFF	; 255
    5dcc:	2f ef       	ldi	r18, 0xFF	; 255
    5dce:	92 07       	cpc	r25, r18
    5dd0:	31 f4       	brne	.+12     	; 0x5dde <_Z41__static_initialization_and_destruction_0ii+0x36>
    5dd2:	67 ec       	ldi	r22, 0xC7	; 199
    5dd4:	78 e0       	ldi	r23, 0x08	; 8
    5dd6:	8f e4       	ldi	r24, 0x4F	; 79
    5dd8:	97 e0       	ldi	r25, 0x07	; 7
    5dda:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <_ZN12FirmataClassC1ER6Stream>
    5dde:	0f 90       	pop	r0
    5de0:	0f 90       	pop	r0
    5de2:	0f 90       	pop	r0
    5de4:	0f 90       	pop	r0
    5de6:	df 91       	pop	r29
    5de8:	cf 91       	pop	r28
    5dea:	08 95       	ret

00005dec <_GLOBAL__sub_I__ZN12FirmataClass23sendValueAsTwo7bitBytesEi>:
    5dec:	cf 93       	push	r28
    5dee:	df 93       	push	r29
    5df0:	cd b7       	in	r28, 0x3d	; 61
    5df2:	de b7       	in	r29, 0x3e	; 62
    5df4:	6f ef       	ldi	r22, 0xFF	; 255
    5df6:	7f ef       	ldi	r23, 0xFF	; 255
    5df8:	81 e0       	ldi	r24, 0x01	; 1
    5dfa:	90 e0       	ldi	r25, 0x00	; 0
    5dfc:	0e 94 d4 2e 	call	0x5da8	; 0x5da8 <_Z41__static_initialization_and_destruction_0ii>
    5e00:	df 91       	pop	r29
    5e02:	cf 91       	pop	r28
    5e04:	08 95       	ret

00005e06 <_Z6sockethhjh>:
/**
 * @brief	This Socket function initialize the channel in perticular mode, and set the port and wait for W5100 done it.
 * @return 	1 for success else 0.
 */
uint8_t socket(SOCKET s, uint8_t protocol, uint16_t port, uint8_t flag)
{
    5e06:	cf 93       	push	r28
    5e08:	df 93       	push	r29
    5e0a:	00 d0       	rcall	.+0      	; 0x5e0c <_Z6sockethhjh+0x6>
    5e0c:	00 d0       	rcall	.+0      	; 0x5e0e <_Z6sockethhjh+0x8>
    5e0e:	1f 92       	push	r1
    5e10:	cd b7       	in	r28, 0x3d	; 61
    5e12:	de b7       	in	r29, 0x3e	; 62
    5e14:	89 83       	std	Y+1, r24	; 0x01
    5e16:	6a 83       	std	Y+2, r22	; 0x02
    5e18:	5c 83       	std	Y+4, r21	; 0x04
    5e1a:	4b 83       	std	Y+3, r20	; 0x03
    5e1c:	2d 83       	std	Y+5, r18	; 0x05
  if ((protocol == SnMR::TCP) || (protocol == SnMR::UDP) || (protocol == SnMR::IPRAW) || (protocol == SnMR::MACRAW) || (protocol == SnMR::PPPOE))
    5e1e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e20:	81 30       	cpi	r24, 0x01	; 1
    5e22:	61 f0       	breq	.+24     	; 0x5e3c <_Z6sockethhjh+0x36>
    5e24:	8a 81       	ldd	r24, Y+2	; 0x02
    5e26:	82 30       	cpi	r24, 0x02	; 2
    5e28:	49 f0       	breq	.+18     	; 0x5e3c <_Z6sockethhjh+0x36>
    5e2a:	8a 81       	ldd	r24, Y+2	; 0x02
    5e2c:	83 30       	cpi	r24, 0x03	; 3
    5e2e:	31 f0       	breq	.+12     	; 0x5e3c <_Z6sockethhjh+0x36>
    5e30:	8a 81       	ldd	r24, Y+2	; 0x02
    5e32:	84 30       	cpi	r24, 0x04	; 4
    5e34:	19 f0       	breq	.+6      	; 0x5e3c <_Z6sockethhjh+0x36>
    5e36:	8a 81       	ldd	r24, Y+2	; 0x02
    5e38:	85 30       	cpi	r24, 0x05	; 5
    5e3a:	71 f5       	brne	.+92     	; 0x5e98 <_Z6sockethhjh+0x92>
  {
    close(s);
    5e3c:	89 81       	ldd	r24, Y+1	; 0x01
    5e3e:	0e 94 55 2f 	call	0x5eaa	; 0x5eaa <_Z5closeh>
    W5100.writeSnMR(s, protocol | flag);
    5e42:	9a 81       	ldd	r25, Y+2	; 0x02
    5e44:	8d 81       	ldd	r24, Y+5	; 0x05
    5e46:	89 2b       	or	r24, r25
    5e48:	68 2f       	mov	r22, r24
    5e4a:	89 81       	ldd	r24, Y+1	; 0x01
    5e4c:	0e 94 44 a7 	call	0x14e88	; 0x14e88 <_ZN10W5100Class9writeSnMREhh>
    if (port != 0) {
    5e50:	8b 81       	ldd	r24, Y+3	; 0x03
    5e52:	9c 81       	ldd	r25, Y+4	; 0x04
    5e54:	00 97       	sbiw	r24, 0x00	; 0
    5e56:	39 f0       	breq	.+14     	; 0x5e66 <_Z6sockethhjh+0x60>
      W5100.writeSnPORT(s, port);
    5e58:	8b 81       	ldd	r24, Y+3	; 0x03
    5e5a:	9c 81       	ldd	r25, Y+4	; 0x04
    5e5c:	bc 01       	movw	r22, r24
    5e5e:	89 81       	ldd	r24, Y+1	; 0x01
    5e60:	0e 94 95 a7 	call	0x14f2a	; 0x14f2a <_ZN10W5100Class11writeSnPORTEhj>
    5e64:	11 c0       	rjmp	.+34     	; 0x5e88 <_Z6sockethhjh+0x82>
    } 
    else {
      local_port++; // if don't set the source port, set local_port number.
    5e66:	80 91 8a 07 	lds	r24, 0x078A
    5e6a:	90 91 8b 07 	lds	r25, 0x078B
    5e6e:	01 96       	adiw	r24, 0x01	; 1
    5e70:	90 93 8b 07 	sts	0x078B, r25
    5e74:	80 93 8a 07 	sts	0x078A, r24
      W5100.writeSnPORT(s, local_port);
    5e78:	80 91 8a 07 	lds	r24, 0x078A
    5e7c:	90 91 8b 07 	lds	r25, 0x078B
    5e80:	bc 01       	movw	r22, r24
    5e82:	89 81       	ldd	r24, Y+1	; 0x01
    5e84:	0e 94 95 a7 	call	0x14f2a	; 0x14f2a <_ZN10W5100Class11writeSnPORTEhj>
    }

    W5100.execCmdSn(s, Sock_OPEN);
    5e88:	41 e0       	ldi	r20, 0x01	; 1
    5e8a:	69 81       	ldd	r22, Y+1	; 0x01
    5e8c:	8c e8       	ldi	r24, 0x8C	; 140
    5e8e:	97 e0       	ldi	r25, 0x07	; 7
    5e90:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>
    
    return 1;
    5e94:	81 e0       	ldi	r24, 0x01	; 1
    5e96:	01 c0       	rjmp	.+2      	; 0x5e9a <_Z6sockethhjh+0x94>
  }

  return 0;
    5e98:	80 e0       	ldi	r24, 0x00	; 0
}
    5e9a:	0f 90       	pop	r0
    5e9c:	0f 90       	pop	r0
    5e9e:	0f 90       	pop	r0
    5ea0:	0f 90       	pop	r0
    5ea2:	0f 90       	pop	r0
    5ea4:	df 91       	pop	r29
    5ea6:	cf 91       	pop	r28
    5ea8:	08 95       	ret

00005eaa <_Z5closeh>:

/**
 * @brief	This function close the socket and parameter is "s" which represent the socket number
 */
void close(SOCKET s)
{
    5eaa:	cf 93       	push	r28
    5eac:	df 93       	push	r29
    5eae:	1f 92       	push	r1
    5eb0:	cd b7       	in	r28, 0x3d	; 61
    5eb2:	de b7       	in	r29, 0x3e	; 62
    5eb4:	89 83       	std	Y+1, r24	; 0x01
  W5100.execCmdSn(s, Sock_CLOSE);
    5eb6:	40 e1       	ldi	r20, 0x10	; 16
    5eb8:	69 81       	ldd	r22, Y+1	; 0x01
    5eba:	8c e8       	ldi	r24, 0x8C	; 140
    5ebc:	97 e0       	ldi	r25, 0x07	; 7
    5ebe:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>
  W5100.writeSnIR(s, 0xFF);
    5ec2:	6f ef       	ldi	r22, 0xFF	; 255
    5ec4:	89 81       	ldd	r24, Y+1	; 0x01
    5ec6:	0e 94 65 a7 	call	0x14eca	; 0x14eca <_ZN10W5100Class9writeSnIREhh>
}
    5eca:	0f 90       	pop	r0
    5ecc:	df 91       	pop	r29
    5ece:	cf 91       	pop	r28
    5ed0:	08 95       	ret

00005ed2 <_Z6listenh>:
/**
 * @brief	This function established  the connection for the channel in passive (server) mode. This function waits for the request from the peer.
 * @return	1 for success else 0.
 */
uint8_t listen(SOCKET s)
{
    5ed2:	cf 93       	push	r28
    5ed4:	df 93       	push	r29
    5ed6:	1f 92       	push	r1
    5ed8:	cd b7       	in	r28, 0x3d	; 61
    5eda:	de b7       	in	r29, 0x3e	; 62
    5edc:	89 83       	std	Y+1, r24	; 0x01
  if (W5100.readSnSR(s) != SnSR::INIT)
    5ede:	89 81       	ldd	r24, Y+1	; 0x01
    5ee0:	0e 94 86 a7 	call	0x14f0c	; 0x14f0c <_ZN10W5100Class8readSnSREh>
    5ee4:	98 2f       	mov	r25, r24
    5ee6:	81 e0       	ldi	r24, 0x01	; 1
    5ee8:	93 31       	cpi	r25, 0x13	; 19
    5eea:	09 f4       	brne	.+2      	; 0x5eee <_Z6listenh+0x1c>
    5eec:	80 e0       	ldi	r24, 0x00	; 0
    5eee:	88 23       	and	r24, r24
    5ef0:	11 f0       	breq	.+4      	; 0x5ef6 <_Z6listenh+0x24>
    return 0;
    5ef2:	80 e0       	ldi	r24, 0x00	; 0
    5ef4:	07 c0       	rjmp	.+14     	; 0x5f04 <_Z6listenh+0x32>
  W5100.execCmdSn(s, Sock_LISTEN);
    5ef6:	42 e0       	ldi	r20, 0x02	; 2
    5ef8:	69 81       	ldd	r22, Y+1	; 0x01
    5efa:	8c e8       	ldi	r24, 0x8C	; 140
    5efc:	97 e0       	ldi	r25, 0x07	; 7
    5efe:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>
  return 1;
    5f02:	81 e0       	ldi	r24, 0x01	; 1
}
    5f04:	0f 90       	pop	r0
    5f06:	df 91       	pop	r29
    5f08:	cf 91       	pop	r28
    5f0a:	08 95       	ret

00005f0c <_Z7connecthPhj>:
 * 		This function waits for the untill the connection is established.
 * 		
 * @return	1 for success else 0.
 */
uint8_t connect(SOCKET s, uint8_t * addr, uint16_t port)
{
    5f0c:	cf 93       	push	r28
    5f0e:	df 93       	push	r29
    5f10:	00 d0       	rcall	.+0      	; 0x5f12 <_Z7connecthPhj+0x6>
    5f12:	00 d0       	rcall	.+0      	; 0x5f14 <_Z7connecthPhj+0x8>
    5f14:	1f 92       	push	r1
    5f16:	cd b7       	in	r28, 0x3d	; 61
    5f18:	de b7       	in	r29, 0x3e	; 62
    5f1a:	89 83       	std	Y+1, r24	; 0x01
    5f1c:	7b 83       	std	Y+3, r23	; 0x03
    5f1e:	6a 83       	std	Y+2, r22	; 0x02
    5f20:	5d 83       	std	Y+5, r21	; 0x05
    5f22:	4c 83       	std	Y+4, r20	; 0x04
  if 
    (
  ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
    5f24:	8a 81       	ldd	r24, Y+2	; 0x02
    5f26:	9b 81       	ldd	r25, Y+3	; 0x03
    5f28:	fc 01       	movw	r30, r24
    5f2a:	80 81       	ld	r24, Z
 * 		
 * @return	1 for success else 0.
 */
uint8_t connect(SOCKET s, uint8_t * addr, uint16_t port)
{
  if 
    5f2c:	8f 3f       	cpi	r24, 0xFF	; 255
    5f2e:	a9 f4       	brne	.+42     	; 0x5f5a <_Z7connecthPhj+0x4e>
    (
  ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
    5f30:	8a 81       	ldd	r24, Y+2	; 0x02
    5f32:	9b 81       	ldd	r25, Y+3	; 0x03
    5f34:	01 96       	adiw	r24, 0x01	; 1
    5f36:	fc 01       	movw	r30, r24
    5f38:	80 81       	ld	r24, Z
 * 		
 * @return	1 for success else 0.
 */
uint8_t connect(SOCKET s, uint8_t * addr, uint16_t port)
{
  if 
    5f3a:	8f 3f       	cpi	r24, 0xFF	; 255
    5f3c:	71 f4       	brne	.+28     	; 0x5f5a <_Z7connecthPhj+0x4e>
    (
  ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
    5f3e:	8a 81       	ldd	r24, Y+2	; 0x02
    5f40:	9b 81       	ldd	r25, Y+3	; 0x03
    5f42:	02 96       	adiw	r24, 0x02	; 2
    5f44:	fc 01       	movw	r30, r24
    5f46:	80 81       	ld	r24, Z
 * 		
 * @return	1 for success else 0.
 */
uint8_t connect(SOCKET s, uint8_t * addr, uint16_t port)
{
  if 
    5f48:	8f 3f       	cpi	r24, 0xFF	; 255
    5f4a:	39 f4       	brne	.+14     	; 0x5f5a <_Z7connecthPhj+0x4e>
    (
  ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
    5f4c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f4e:	9b 81       	ldd	r25, Y+3	; 0x03
    5f50:	03 96       	adiw	r24, 0x03	; 3
    5f52:	fc 01       	movw	r30, r24
    5f54:	80 81       	ld	r24, Z
 * 		
 * @return	1 for success else 0.
 */
uint8_t connect(SOCKET s, uint8_t * addr, uint16_t port)
{
  if 
    5f56:	8f 3f       	cpi	r24, 0xFF	; 255
    5f58:	f9 f0       	breq	.+62     	; 0x5f98 <_Z7connecthPhj+0x8c>
    (
  ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
    ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    5f5a:	8a 81       	ldd	r24, Y+2	; 0x02
    5f5c:	9b 81       	ldd	r25, Y+3	; 0x03
    5f5e:	fc 01       	movw	r30, r24
    5f60:	80 81       	ld	r24, Z
 * 		
 * @return	1 for success else 0.
 */
uint8_t connect(SOCKET s, uint8_t * addr, uint16_t port)
{
  if 
    5f62:	88 23       	and	r24, r24
    5f64:	a9 f4       	brne	.+42     	; 0x5f90 <_Z7connecthPhj+0x84>
    (
  ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
    ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    5f66:	8a 81       	ldd	r24, Y+2	; 0x02
    5f68:	9b 81       	ldd	r25, Y+3	; 0x03
    5f6a:	01 96       	adiw	r24, 0x01	; 1
    5f6c:	fc 01       	movw	r30, r24
    5f6e:	80 81       	ld	r24, Z
 * 		
 * @return	1 for success else 0.
 */
uint8_t connect(SOCKET s, uint8_t * addr, uint16_t port)
{
  if 
    5f70:	88 23       	and	r24, r24
    5f72:	71 f4       	brne	.+28     	; 0x5f90 <_Z7connecthPhj+0x84>
    (
  ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
    ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    5f74:	8a 81       	ldd	r24, Y+2	; 0x02
    5f76:	9b 81       	ldd	r25, Y+3	; 0x03
    5f78:	02 96       	adiw	r24, 0x02	; 2
    5f7a:	fc 01       	movw	r30, r24
    5f7c:	80 81       	ld	r24, Z
 * 		
 * @return	1 for success else 0.
 */
uint8_t connect(SOCKET s, uint8_t * addr, uint16_t port)
{
  if 
    5f7e:	88 23       	and	r24, r24
    5f80:	39 f4       	brne	.+14     	; 0x5f90 <_Z7connecthPhj+0x84>
    (
  ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
    ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    5f82:	8a 81       	ldd	r24, Y+2	; 0x02
    5f84:	9b 81       	ldd	r25, Y+3	; 0x03
    5f86:	03 96       	adiw	r24, 0x03	; 3
    5f88:	fc 01       	movw	r30, r24
    5f8a:	80 81       	ld	r24, Z
 * 		
 * @return	1 for success else 0.
 */
uint8_t connect(SOCKET s, uint8_t * addr, uint16_t port)
{
  if 
    5f8c:	88 23       	and	r24, r24
    5f8e:	21 f0       	breq	.+8      	; 0x5f98 <_Z7connecthPhj+0x8c>
    5f90:	8c 81       	ldd	r24, Y+4	; 0x04
    5f92:	9d 81       	ldd	r25, Y+5	; 0x05
    5f94:	00 97       	sbiw	r24, 0x00	; 0
    5f96:	11 f4       	brne	.+4      	; 0x5f9c <_Z7connecthPhj+0x90>
    (
  ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
    ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    (port == 0x00) 
    ) 
    return 0;
    5f98:	80 e0       	ldi	r24, 0x00	; 0
    5f9a:	13 c0       	rjmp	.+38     	; 0x5fc2 <_Z7connecthPhj+0xb6>

  // set destination IP
  W5100.writeSnDIPR(s, addr);
    5f9c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f9e:	9b 81       	ldd	r25, Y+3	; 0x03
    5fa0:	bc 01       	movw	r22, r24
    5fa2:	89 81       	ldd	r24, Y+1	; 0x01
    5fa4:	0e 94 b5 a7 	call	0x14f6a	; 0x14f6a <_ZN10W5100Class11writeSnDIPREhPh>
  W5100.writeSnDPORT(s, port);
    5fa8:	8c 81       	ldd	r24, Y+4	; 0x04
    5faa:	9d 81       	ldd	r25, Y+5	; 0x05
    5fac:	bc 01       	movw	r22, r24
    5fae:	89 81       	ldd	r24, Y+1	; 0x01
    5fb0:	0e 94 ce a7 	call	0x14f9c	; 0x14f9c <_ZN10W5100Class12writeSnDPORTEhj>
  W5100.execCmdSn(s, Sock_CONNECT);
    5fb4:	44 e0       	ldi	r20, 0x04	; 4
    5fb6:	69 81       	ldd	r22, Y+1	; 0x01
    5fb8:	8c e8       	ldi	r24, 0x8C	; 140
    5fba:	97 e0       	ldi	r25, 0x07	; 7
    5fbc:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>

  return 1;
    5fc0:	81 e0       	ldi	r24, 0x01	; 1
}
    5fc2:	0f 90       	pop	r0
    5fc4:	0f 90       	pop	r0
    5fc6:	0f 90       	pop	r0
    5fc8:	0f 90       	pop	r0
    5fca:	0f 90       	pop	r0
    5fcc:	df 91       	pop	r29
    5fce:	cf 91       	pop	r28
    5fd0:	08 95       	ret

00005fd2 <_Z10disconnecth>:
/**
 * @brief	This function used for disconnect the socket and parameter is "s" which represent the socket number
 * @return	1 for success else 0.
 */
void disconnect(SOCKET s)
{
    5fd2:	cf 93       	push	r28
    5fd4:	df 93       	push	r29
    5fd6:	1f 92       	push	r1
    5fd8:	cd b7       	in	r28, 0x3d	; 61
    5fda:	de b7       	in	r29, 0x3e	; 62
    5fdc:	89 83       	std	Y+1, r24	; 0x01
  W5100.execCmdSn(s, Sock_DISCON);
    5fde:	48 e0       	ldi	r20, 0x08	; 8
    5fe0:	69 81       	ldd	r22, Y+1	; 0x01
    5fe2:	8c e8       	ldi	r24, 0x8C	; 140
    5fe4:	97 e0       	ldi	r25, 0x07	; 7
    5fe6:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>
}
    5fea:	0f 90       	pop	r0
    5fec:	df 91       	pop	r29
    5fee:	cf 91       	pop	r28
    5ff0:	08 95       	ret

00005ff2 <_Z4sendhPKhj>:
/**
 * @brief	This function used to send the data in TCP mode
 * @return	1 for success else 0.
 */
uint16_t send(SOCKET s, const uint8_t * buf, uint16_t len)
{
    5ff2:	cf 93       	push	r28
    5ff4:	df 93       	push	r29
    5ff6:	cd b7       	in	r28, 0x3d	; 61
    5ff8:	de b7       	in	r29, 0x3e	; 62
    5ffa:	2a 97       	sbiw	r28, 0x0a	; 10
    5ffc:	0f b6       	in	r0, 0x3f	; 63
    5ffe:	f8 94       	cli
    6000:	de bf       	out	0x3e, r29	; 62
    6002:	0f be       	out	0x3f, r0	; 63
    6004:	cd bf       	out	0x3d, r28	; 61
    6006:	8e 83       	std	Y+6, r24	; 0x06
    6008:	78 87       	std	Y+8, r23	; 0x08
    600a:	6f 83       	std	Y+7, r22	; 0x07
    600c:	5a 87       	std	Y+10, r21	; 0x0a
    600e:	49 87       	std	Y+9, r20	; 0x09
  uint8_t status=0;
    6010:	1b 82       	std	Y+3, r1	; 0x03
  uint16_t ret=0;
    6012:	1a 82       	std	Y+2, r1	; 0x02
    6014:	19 82       	std	Y+1, r1	; 0x01
  uint16_t freesize=0;
    6016:	1d 82       	std	Y+5, r1	; 0x05
    6018:	1c 82       	std	Y+4, r1	; 0x04

  if (len > W5100.SSIZE) 
    601a:	89 85       	ldd	r24, Y+9	; 0x09
    601c:	9a 85       	ldd	r25, Y+10	; 0x0a
    601e:	81 30       	cpi	r24, 0x01	; 1
    6020:	28 e0       	ldi	r18, 0x08	; 8
    6022:	92 07       	cpc	r25, r18
    6024:	28 f0       	brcs	.+10     	; 0x6030 <_Z4sendhPKhj+0x3e>
    ret = W5100.SSIZE; // check size not to exceed MAX size.
    6026:	80 e0       	ldi	r24, 0x00	; 0
    6028:	98 e0       	ldi	r25, 0x08	; 8
    602a:	9a 83       	std	Y+2, r25	; 0x02
    602c:	89 83       	std	Y+1, r24	; 0x01
    602e:	04 c0       	rjmp	.+8      	; 0x6038 <_Z4sendhPKhj+0x46>
  else 
    ret = len;
    6030:	89 85       	ldd	r24, Y+9	; 0x09
    6032:	9a 85       	ldd	r25, Y+10	; 0x0a
    6034:	9a 83       	std	Y+2, r25	; 0x02
    6036:	89 83       	std	Y+1, r24	; 0x01

  // if freebuf is available, start.
  do 
  {
    freesize = W5100.getTXFreeSize(s);
    6038:	6e 81       	ldd	r22, Y+6	; 0x06
    603a:	8c e8       	ldi	r24, 0x8C	; 140
    603c:	97 e0       	ldi	r25, 0x07	; 7
    603e:	0e 94 68 34 	call	0x68d0	; 0x68d0 <_ZN10W5100Class13getTXFreeSizeEh>
    6042:	9d 83       	std	Y+5, r25	; 0x05
    6044:	8c 83       	std	Y+4, r24	; 0x04
    status = W5100.readSnSR(s);
    6046:	8e 81       	ldd	r24, Y+6	; 0x06
    6048:	0e 94 86 a7 	call	0x14f0c	; 0x14f0c <_ZN10W5100Class8readSnSREh>
    604c:	8b 83       	std	Y+3, r24	; 0x03
    if ((status != SnSR::ESTABLISHED) && (status != SnSR::CLOSE_WAIT))
    604e:	8b 81       	ldd	r24, Y+3	; 0x03
    6050:	87 31       	cpi	r24, 0x17	; 23
    6052:	31 f0       	breq	.+12     	; 0x6060 <_Z4sendhPKhj+0x6e>
    6054:	8b 81       	ldd	r24, Y+3	; 0x03
    6056:	8c 31       	cpi	r24, 0x1C	; 28
    6058:	19 f0       	breq	.+6      	; 0x6060 <_Z4sendhPKhj+0x6e>
    {
      ret = 0; 
    605a:	1a 82       	std	Y+2, r1	; 0x02
    605c:	19 82       	std	Y+1, r1	; 0x01
      break;
    605e:	0b c0       	rjmp	.+22     	; 0x6076 <_Z4sendhPKhj+0x84>
    ret = W5100.SSIZE; // check size not to exceed MAX size.
  else 
    ret = len;

  // if freebuf is available, start.
  do 
    6060:	41 e0       	ldi	r20, 0x01	; 1
    6062:	2c 81       	ldd	r18, Y+4	; 0x04
    6064:	3d 81       	ldd	r19, Y+5	; 0x05
    6066:	89 81       	ldd	r24, Y+1	; 0x01
    6068:	9a 81       	ldd	r25, Y+2	; 0x02
    606a:	28 17       	cp	r18, r24
    606c:	39 07       	cpc	r19, r25
    606e:	08 f0       	brcs	.+2      	; 0x6072 <_Z4sendhPKhj+0x80>
    6070:	40 e0       	ldi	r20, 0x00	; 0
    6072:	44 23       	and	r20, r20
    6074:	09 f7       	brne	.-62     	; 0x6038 <_Z4sendhPKhj+0x46>
    }
  } 
  while (freesize < ret);

  // copy data
  W5100.send_data_processing(s, (uint8_t *)buf, ret);
    6076:	29 81       	ldd	r18, Y+1	; 0x01
    6078:	3a 81       	ldd	r19, Y+2	; 0x02
    607a:	8f 81       	ldd	r24, Y+7	; 0x07
    607c:	98 85       	ldd	r25, Y+8	; 0x08
    607e:	ac 01       	movw	r20, r24
    6080:	6e 81       	ldd	r22, Y+6	; 0x06
    6082:	8c e8       	ldi	r24, 0x8C	; 140
    6084:	97 e0       	ldi	r25, 0x07	; 7
    6086:	0e 94 d2 34 	call	0x69a4	; 0x69a4 <_ZN10W5100Class20send_data_processingEhPKhj>
  W5100.execCmdSn(s, Sock_SEND);
    608a:	40 e2       	ldi	r20, 0x20	; 32
    608c:	6e 81       	ldd	r22, Y+6	; 0x06
    608e:	8c e8       	ldi	r24, 0x8C	; 140
    6090:	97 e0       	ldi	r25, 0x07	; 7
    6092:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>

  /* +2008.01 bj */
  while ( (W5100.readSnIR(s) & SnIR::SEND_OK) != SnIR::SEND_OK ) 
    6096:	10 c0       	rjmp	.+32     	; 0x60b8 <_Z4sendhPKhj+0xc6>
  {
    /* m2008.01 [bj] : reduce code */
    if ( W5100.readSnSR(s) == SnSR::CLOSED )
    6098:	8e 81       	ldd	r24, Y+6	; 0x06
    609a:	0e 94 86 a7 	call	0x14f0c	; 0x14f0c <_ZN10W5100Class8readSnSREh>
    609e:	98 2f       	mov	r25, r24
    60a0:	81 e0       	ldi	r24, 0x01	; 1
    60a2:	99 23       	and	r25, r25
    60a4:	09 f0       	breq	.+2      	; 0x60a8 <_Z4sendhPKhj+0xb6>
    60a6:	80 e0       	ldi	r24, 0x00	; 0
    60a8:	88 23       	and	r24, r24
    60aa:	31 f0       	breq	.+12     	; 0x60b8 <_Z4sendhPKhj+0xc6>
    {
      close(s);
    60ac:	8e 81       	ldd	r24, Y+6	; 0x06
    60ae:	0e 94 55 2f 	call	0x5eaa	; 0x5eaa <_Z5closeh>
      return 0;
    60b2:	80 e0       	ldi	r24, 0x00	; 0
    60b4:	90 e0       	ldi	r25, 0x00	; 0
    60b6:	13 c0       	rjmp	.+38     	; 0x60de <_Z4sendhPKhj+0xec>
  // copy data
  W5100.send_data_processing(s, (uint8_t *)buf, ret);
  W5100.execCmdSn(s, Sock_SEND);

  /* +2008.01 bj */
  while ( (W5100.readSnIR(s) & SnIR::SEND_OK) != SnIR::SEND_OK ) 
    60b8:	8e 81       	ldd	r24, Y+6	; 0x06
    60ba:	0e 94 77 a7 	call	0x14eee	; 0x14eee <_ZN10W5100Class8readSnIREh>
    60be:	88 2f       	mov	r24, r24
    60c0:	90 e0       	ldi	r25, 0x00	; 0
    60c2:	80 71       	andi	r24, 0x10	; 16
    60c4:	99 27       	eor	r25, r25
    60c6:	21 e0       	ldi	r18, 0x01	; 1
    60c8:	00 97       	sbiw	r24, 0x00	; 0
    60ca:	09 f0       	breq	.+2      	; 0x60ce <_Z4sendhPKhj+0xdc>
    60cc:	20 e0       	ldi	r18, 0x00	; 0
    60ce:	22 23       	and	r18, r18
    60d0:	19 f7       	brne	.-58     	; 0x6098 <_Z4sendhPKhj+0xa6>
      close(s);
      return 0;
    }
  }
  /* +2008.01 bj */
  W5100.writeSnIR(s, SnIR::SEND_OK);
    60d2:	60 e1       	ldi	r22, 0x10	; 16
    60d4:	8e 81       	ldd	r24, Y+6	; 0x06
    60d6:	0e 94 65 a7 	call	0x14eca	; 0x14eca <_ZN10W5100Class9writeSnIREhh>
  return ret;
    60da:	89 81       	ldd	r24, Y+1	; 0x01
    60dc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    60de:	2a 96       	adiw	r28, 0x0a	; 10
    60e0:	0f b6       	in	r0, 0x3f	; 63
    60e2:	f8 94       	cli
    60e4:	de bf       	out	0x3e, r29	; 62
    60e6:	0f be       	out	0x3f, r0	; 63
    60e8:	cd bf       	out	0x3d, r28	; 61
    60ea:	df 91       	pop	r29
    60ec:	cf 91       	pop	r28
    60ee:	08 95       	ret

000060f0 <_Z4recvhPhi>:
 * 		It continues to wait for data as much as the application wants to receive.
 * 		
 * @return	received data size for success else -1.
 */
int16_t recv(SOCKET s, uint8_t *buf, int16_t len)
{
    60f0:	0f 93       	push	r16
    60f2:	cf 93       	push	r28
    60f4:	df 93       	push	r29
    60f6:	cd b7       	in	r28, 0x3d	; 61
    60f8:	de b7       	in	r29, 0x3e	; 62
    60fa:	28 97       	sbiw	r28, 0x08	; 8
    60fc:	0f b6       	in	r0, 0x3f	; 63
    60fe:	f8 94       	cli
    6100:	de bf       	out	0x3e, r29	; 62
    6102:	0f be       	out	0x3f, r0	; 63
    6104:	cd bf       	out	0x3d, r28	; 61
    6106:	8c 83       	std	Y+4, r24	; 0x04
    6108:	7e 83       	std	Y+6, r23	; 0x06
    610a:	6d 83       	std	Y+5, r22	; 0x05
    610c:	58 87       	std	Y+8, r21	; 0x08
    610e:	4f 83       	std	Y+7, r20	; 0x07
  // Check how much data is available
  int16_t ret = W5100.getRXReceivedSize(s);
    6110:	6c 81       	ldd	r22, Y+4	; 0x04
    6112:	8c e8       	ldi	r24, 0x8C	; 140
    6114:	97 e0       	ldi	r25, 0x07	; 7
    6116:	0e 94 9d 34 	call	0x693a	; 0x693a <_ZN10W5100Class17getRXReceivedSizeEh>
    611a:	9a 83       	std	Y+2, r25	; 0x02
    611c:	89 83       	std	Y+1, r24	; 0x01
  if ( ret == 0 )
    611e:	89 81       	ldd	r24, Y+1	; 0x01
    6120:	9a 81       	ldd	r25, Y+2	; 0x02
    6122:	00 97       	sbiw	r24, 0x00	; 0
    6124:	a9 f4       	brne	.+42     	; 0x6150 <_Z4recvhPhi+0x60>
  {
    // No data available.
    uint8_t status = W5100.readSnSR(s);
    6126:	8c 81       	ldd	r24, Y+4	; 0x04
    6128:	0e 94 86 a7 	call	0x14f0c	; 0x14f0c <_ZN10W5100Class8readSnSREh>
    612c:	8b 83       	std	Y+3, r24	; 0x03
    if ( status == SnSR::LISTEN || status == SnSR::CLOSED || status == SnSR::CLOSE_WAIT )
    612e:	8b 81       	ldd	r24, Y+3	; 0x03
    6130:	84 31       	cpi	r24, 0x14	; 20
    6132:	31 f0       	breq	.+12     	; 0x6140 <_Z4recvhPhi+0x50>
    6134:	8b 81       	ldd	r24, Y+3	; 0x03
    6136:	88 23       	and	r24, r24
    6138:	19 f0       	breq	.+6      	; 0x6140 <_Z4recvhPhi+0x50>
    613a:	8b 81       	ldd	r24, Y+3	; 0x03
    613c:	8c 31       	cpi	r24, 0x1C	; 28
    613e:	19 f4       	brne	.+6      	; 0x6146 <_Z4recvhPhi+0x56>
    {
      // The remote end has closed its side of the connection, so this is the eof state
      ret = 0;
    6140:	1a 82       	std	Y+2, r1	; 0x02
    6142:	19 82       	std	Y+1, r1	; 0x01
    6144:	10 c0       	rjmp	.+32     	; 0x6166 <_Z4recvhPhi+0x76>
    }
    else
    {
      // The connection is still up, but there's no data waiting to be read
      ret = -1;
    6146:	8f ef       	ldi	r24, 0xFF	; 255
    6148:	9f ef       	ldi	r25, 0xFF	; 255
    614a:	9a 83       	std	Y+2, r25	; 0x02
    614c:	89 83       	std	Y+1, r24	; 0x01
    614e:	0b c0       	rjmp	.+22     	; 0x6166 <_Z4recvhPhi+0x76>
    }
  }
  else if (ret > len)
    6150:	29 81       	ldd	r18, Y+1	; 0x01
    6152:	3a 81       	ldd	r19, Y+2	; 0x02
    6154:	8f 81       	ldd	r24, Y+7	; 0x07
    6156:	98 85       	ldd	r25, Y+8	; 0x08
    6158:	82 17       	cp	r24, r18
    615a:	93 07       	cpc	r25, r19
    615c:	24 f4       	brge	.+8      	; 0x6166 <_Z4recvhPhi+0x76>
  {
    ret = len;
    615e:	8f 81       	ldd	r24, Y+7	; 0x07
    6160:	98 85       	ldd	r25, Y+8	; 0x08
    6162:	9a 83       	std	Y+2, r25	; 0x02
    6164:	89 83       	std	Y+1, r24	; 0x01
  }

  if ( ret > 0 )
    6166:	89 81       	ldd	r24, Y+1	; 0x01
    6168:	9a 81       	ldd	r25, Y+2	; 0x02
    616a:	18 16       	cp	r1, r24
    616c:	19 06       	cpc	r1, r25
    616e:	8c f4       	brge	.+34     	; 0x6192 <_Z4recvhPhi+0xa2>
  {
    W5100.recv_data_processing(s, buf, ret);
    6170:	29 81       	ldd	r18, Y+1	; 0x01
    6172:	3a 81       	ldd	r19, Y+2	; 0x02
    6174:	8d 81       	ldd	r24, Y+5	; 0x05
    6176:	9e 81       	ldd	r25, Y+6	; 0x06
    6178:	00 e0       	ldi	r16, 0x00	; 0
    617a:	ac 01       	movw	r20, r24
    617c:	6c 81       	ldd	r22, Y+4	; 0x04
    617e:	8c e8       	ldi	r24, 0x8C	; 140
    6180:	97 e0       	ldi	r25, 0x07	; 7
    6182:	0e 94 91 35 	call	0x6b22	; 0x6b22 <_ZN10W5100Class20recv_data_processingEhPhjh>
    W5100.execCmdSn(s, Sock_RECV);
    6186:	40 e4       	ldi	r20, 0x40	; 64
    6188:	6c 81       	ldd	r22, Y+4	; 0x04
    618a:	8c e8       	ldi	r24, 0x8C	; 140
    618c:	97 e0       	ldi	r25, 0x07	; 7
    618e:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>
  }
  return ret;
    6192:	89 81       	ldd	r24, Y+1	; 0x01
    6194:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6196:	28 96       	adiw	r28, 0x08	; 8
    6198:	0f b6       	in	r0, 0x3f	; 63
    619a:	f8 94       	cli
    619c:	de bf       	out	0x3e, r29	; 62
    619e:	0f be       	out	0x3f, r0	; 63
    61a0:	cd bf       	out	0x3d, r28	; 61
    61a2:	df 91       	pop	r29
    61a4:	cf 91       	pop	r28
    61a6:	0f 91       	pop	r16
    61a8:	08 95       	ret

000061aa <_Z4peekhPh>:
 * @brief	Returns the first byte in the receive queue (no checking)
 * 		
 * @return
 */
uint16_t peek(SOCKET s, uint8_t *buf)
{
    61aa:	0f 93       	push	r16
    61ac:	cf 93       	push	r28
    61ae:	df 93       	push	r29
    61b0:	00 d0       	rcall	.+0      	; 0x61b2 <_Z4peekhPh+0x8>
    61b2:	1f 92       	push	r1
    61b4:	cd b7       	in	r28, 0x3d	; 61
    61b6:	de b7       	in	r29, 0x3e	; 62
    61b8:	89 83       	std	Y+1, r24	; 0x01
    61ba:	7b 83       	std	Y+3, r23	; 0x03
    61bc:	6a 83       	std	Y+2, r22	; 0x02
  W5100.recv_data_processing(s, buf, 1, 1);
    61be:	8a 81       	ldd	r24, Y+2	; 0x02
    61c0:	9b 81       	ldd	r25, Y+3	; 0x03
    61c2:	01 e0       	ldi	r16, 0x01	; 1
    61c4:	21 e0       	ldi	r18, 0x01	; 1
    61c6:	30 e0       	ldi	r19, 0x00	; 0
    61c8:	ac 01       	movw	r20, r24
    61ca:	69 81       	ldd	r22, Y+1	; 0x01
    61cc:	8c e8       	ldi	r24, 0x8C	; 140
    61ce:	97 e0       	ldi	r25, 0x07	; 7
    61d0:	0e 94 91 35 	call	0x6b22	; 0x6b22 <_ZN10W5100Class20recv_data_processingEhPhjh>

  return 1;
    61d4:	81 e0       	ldi	r24, 0x01	; 1
    61d6:	90 e0       	ldi	r25, 0x00	; 0
}
    61d8:	0f 90       	pop	r0
    61da:	0f 90       	pop	r0
    61dc:	0f 90       	pop	r0
    61de:	df 91       	pop	r29
    61e0:	cf 91       	pop	r28
    61e2:	0f 91       	pop	r16
    61e4:	08 95       	ret

000061e6 <_Z6sendtohPKhjPhj>:
 * 		Unlike TCP transmission, The peer's destination address and the port is needed.
 * 		
 * @return	This function return send data size for success else -1.
 */
uint16_t sendto(SOCKET s, const uint8_t *buf, uint16_t len, uint8_t *addr, uint16_t port)
{
    61e6:	0f 93       	push	r16
    61e8:	1f 93       	push	r17
    61ea:	cf 93       	push	r28
    61ec:	df 93       	push	r29
    61ee:	cd b7       	in	r28, 0x3d	; 61
    61f0:	de b7       	in	r29, 0x3e	; 62
    61f2:	2b 97       	sbiw	r28, 0x0b	; 11
    61f4:	0f b6       	in	r0, 0x3f	; 63
    61f6:	f8 94       	cli
    61f8:	de bf       	out	0x3e, r29	; 62
    61fa:	0f be       	out	0x3f, r0	; 63
    61fc:	cd bf       	out	0x3d, r28	; 61
    61fe:	8b 83       	std	Y+3, r24	; 0x03
    6200:	7d 83       	std	Y+5, r23	; 0x05
    6202:	6c 83       	std	Y+4, r22	; 0x04
    6204:	5f 83       	std	Y+7, r21	; 0x07
    6206:	4e 83       	std	Y+6, r20	; 0x06
    6208:	39 87       	std	Y+9, r19	; 0x09
    620a:	28 87       	std	Y+8, r18	; 0x08
    620c:	1b 87       	std	Y+11, r17	; 0x0b
    620e:	0a 87       	std	Y+10, r16	; 0x0a
  uint16_t ret=0;
    6210:	1a 82       	std	Y+2, r1	; 0x02
    6212:	19 82       	std	Y+1, r1	; 0x01

  if (len > W5100.SSIZE) ret = W5100.SSIZE; // check size not to exceed MAX size.
    6214:	8e 81       	ldd	r24, Y+6	; 0x06
    6216:	9f 81       	ldd	r25, Y+7	; 0x07
    6218:	81 30       	cpi	r24, 0x01	; 1
    621a:	28 e0       	ldi	r18, 0x08	; 8
    621c:	92 07       	cpc	r25, r18
    621e:	28 f0       	brcs	.+10     	; 0x622a <_Z6sendtohPKhjPhj+0x44>
    6220:	80 e0       	ldi	r24, 0x00	; 0
    6222:	98 e0       	ldi	r25, 0x08	; 8
    6224:	9a 83       	std	Y+2, r25	; 0x02
    6226:	89 83       	std	Y+1, r24	; 0x01
    6228:	04 c0       	rjmp	.+8      	; 0x6232 <_Z6sendtohPKhjPhj+0x4c>
  else ret = len;
    622a:	8e 81       	ldd	r24, Y+6	; 0x06
    622c:	9f 81       	ldd	r25, Y+7	; 0x07
    622e:	9a 83       	std	Y+2, r25	; 0x02
    6230:	89 83       	std	Y+1, r24	; 0x01

  if
    (
  ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    6232:	88 85       	ldd	r24, Y+8	; 0x08
    6234:	99 85       	ldd	r25, Y+9	; 0x09
    6236:	fc 01       	movw	r30, r24
    6238:	80 81       	ld	r24, Z
  uint16_t ret=0;

  if (len > W5100.SSIZE) ret = W5100.SSIZE; // check size not to exceed MAX size.
  else ret = len;

  if
    623a:	88 23       	and	r24, r24
    623c:	a9 f4       	brne	.+42     	; 0x6268 <_Z6sendtohPKhjPhj+0x82>
    (
  ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    623e:	88 85       	ldd	r24, Y+8	; 0x08
    6240:	99 85       	ldd	r25, Y+9	; 0x09
    6242:	01 96       	adiw	r24, 0x01	; 1
    6244:	fc 01       	movw	r30, r24
    6246:	80 81       	ld	r24, Z
  uint16_t ret=0;

  if (len > W5100.SSIZE) ret = W5100.SSIZE; // check size not to exceed MAX size.
  else ret = len;

  if
    6248:	88 23       	and	r24, r24
    624a:	71 f4       	brne	.+28     	; 0x6268 <_Z6sendtohPKhjPhj+0x82>
    (
  ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    624c:	88 85       	ldd	r24, Y+8	; 0x08
    624e:	99 85       	ldd	r25, Y+9	; 0x09
    6250:	02 96       	adiw	r24, 0x02	; 2
    6252:	fc 01       	movw	r30, r24
    6254:	80 81       	ld	r24, Z
  uint16_t ret=0;

  if (len > W5100.SSIZE) ret = W5100.SSIZE; // check size not to exceed MAX size.
  else ret = len;

  if
    6256:	88 23       	and	r24, r24
    6258:	39 f4       	brne	.+14     	; 0x6268 <_Z6sendtohPKhjPhj+0x82>
    (
  ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    625a:	88 85       	ldd	r24, Y+8	; 0x08
    625c:	99 85       	ldd	r25, Y+9	; 0x09
    625e:	03 96       	adiw	r24, 0x03	; 3
    6260:	fc 01       	movw	r30, r24
    6262:	80 81       	ld	r24, Z
  uint16_t ret=0;

  if (len > W5100.SSIZE) ret = W5100.SSIZE; // check size not to exceed MAX size.
  else ret = len;

  if
    6264:	88 23       	and	r24, r24
    6266:	41 f0       	breq	.+16     	; 0x6278 <_Z6sendtohPKhjPhj+0x92>
    6268:	8a 85       	ldd	r24, Y+10	; 0x0a
    626a:	9b 85       	ldd	r25, Y+11	; 0x0b
    626c:	00 97       	sbiw	r24, 0x00	; 0
    626e:	21 f0       	breq	.+8      	; 0x6278 <_Z6sendtohPKhjPhj+0x92>
    6270:	89 81       	ldd	r24, Y+1	; 0x01
    6272:	9a 81       	ldd	r25, Y+2	; 0x02
    6274:	00 97       	sbiw	r24, 0x00	; 0
    6276:	19 f4       	brne	.+6      	; 0x627e <_Z6sendtohPKhjPhj+0x98>
  ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    ((port == 0x00)) ||(ret == 0)
    ) 
  {
    /* +2008.01 [bj] : added return value */
    ret = 0;
    6278:	1a 82       	std	Y+2, r1	; 0x02
    627a:	19 82       	std	Y+1, r1	; 0x01
    627c:	42 c0       	rjmp	.+132    	; 0x6302 <_Z6sendtohPKhjPhj+0x11c>
  }
  else
  {
    W5100.writeSnDIPR(s, addr);
    627e:	88 85       	ldd	r24, Y+8	; 0x08
    6280:	99 85       	ldd	r25, Y+9	; 0x09
    6282:	bc 01       	movw	r22, r24
    6284:	8b 81       	ldd	r24, Y+3	; 0x03
    6286:	0e 94 b5 a7 	call	0x14f6a	; 0x14f6a <_ZN10W5100Class11writeSnDIPREhPh>
    W5100.writeSnDPORT(s, port);
    628a:	8a 85       	ldd	r24, Y+10	; 0x0a
    628c:	9b 85       	ldd	r25, Y+11	; 0x0b
    628e:	bc 01       	movw	r22, r24
    6290:	8b 81       	ldd	r24, Y+3	; 0x03
    6292:	0e 94 ce a7 	call	0x14f9c	; 0x14f9c <_ZN10W5100Class12writeSnDPORTEhj>

    // copy data
    W5100.send_data_processing(s, (uint8_t *)buf, ret);
    6296:	29 81       	ldd	r18, Y+1	; 0x01
    6298:	3a 81       	ldd	r19, Y+2	; 0x02
    629a:	8c 81       	ldd	r24, Y+4	; 0x04
    629c:	9d 81       	ldd	r25, Y+5	; 0x05
    629e:	ac 01       	movw	r20, r24
    62a0:	6b 81       	ldd	r22, Y+3	; 0x03
    62a2:	8c e8       	ldi	r24, 0x8C	; 140
    62a4:	97 e0       	ldi	r25, 0x07	; 7
    62a6:	0e 94 d2 34 	call	0x69a4	; 0x69a4 <_ZN10W5100Class20send_data_processingEhPKhj>
    W5100.execCmdSn(s, Sock_SEND);
    62aa:	40 e2       	ldi	r20, 0x20	; 32
    62ac:	6b 81       	ldd	r22, Y+3	; 0x03
    62ae:	8c e8       	ldi	r24, 0x8C	; 140
    62b0:	97 e0       	ldi	r25, 0x07	; 7
    62b2:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>

    /* +2008.01 bj */
    while ( (W5100.readSnIR(s) & SnIR::SEND_OK) != SnIR::SEND_OK ) 
    62b6:	14 c0       	rjmp	.+40     	; 0x62e0 <_Z6sendtohPKhjPhj+0xfa>
    {
      if (W5100.readSnIR(s) & SnIR::TIMEOUT)
    62b8:	8b 81       	ldd	r24, Y+3	; 0x03
    62ba:	0e 94 77 a7 	call	0x14eee	; 0x14eee <_ZN10W5100Class8readSnIREh>
    62be:	88 2f       	mov	r24, r24
    62c0:	90 e0       	ldi	r25, 0x00	; 0
    62c2:	88 70       	andi	r24, 0x08	; 8
    62c4:	99 27       	eor	r25, r25
    62c6:	21 e0       	ldi	r18, 0x01	; 1
    62c8:	00 97       	sbiw	r24, 0x00	; 0
    62ca:	09 f4       	brne	.+2      	; 0x62ce <_Z6sendtohPKhjPhj+0xe8>
    62cc:	20 e0       	ldi	r18, 0x00	; 0
    62ce:	22 23       	and	r18, r18
    62d0:	39 f0       	breq	.+14     	; 0x62e0 <_Z6sendtohPKhjPhj+0xfa>
      {
        /* +2008.01 [bj]: clear interrupt */
        W5100.writeSnIR(s, (SnIR::SEND_OK | SnIR::TIMEOUT)); /* clear SEND_OK & TIMEOUT */
    62d2:	68 e1       	ldi	r22, 0x18	; 24
    62d4:	8b 81       	ldd	r24, Y+3	; 0x03
    62d6:	0e 94 65 a7 	call	0x14eca	; 0x14eca <_ZN10W5100Class9writeSnIREhh>
        return 0;
    62da:	80 e0       	ldi	r24, 0x00	; 0
    62dc:	90 e0       	ldi	r25, 0x00	; 0
    62de:	13 c0       	rjmp	.+38     	; 0x6306 <_Z6sendtohPKhjPhj+0x120>
    // copy data
    W5100.send_data_processing(s, (uint8_t *)buf, ret);
    W5100.execCmdSn(s, Sock_SEND);

    /* +2008.01 bj */
    while ( (W5100.readSnIR(s) & SnIR::SEND_OK) != SnIR::SEND_OK ) 
    62e0:	8b 81       	ldd	r24, Y+3	; 0x03
    62e2:	0e 94 77 a7 	call	0x14eee	; 0x14eee <_ZN10W5100Class8readSnIREh>
    62e6:	88 2f       	mov	r24, r24
    62e8:	90 e0       	ldi	r25, 0x00	; 0
    62ea:	80 71       	andi	r24, 0x10	; 16
    62ec:	99 27       	eor	r25, r25
    62ee:	21 e0       	ldi	r18, 0x01	; 1
    62f0:	00 97       	sbiw	r24, 0x00	; 0
    62f2:	09 f0       	breq	.+2      	; 0x62f6 <_Z6sendtohPKhjPhj+0x110>
    62f4:	20 e0       	ldi	r18, 0x00	; 0
    62f6:	22 23       	and	r18, r18
    62f8:	f9 f6       	brne	.-66     	; 0x62b8 <_Z6sendtohPKhjPhj+0xd2>
        return 0;
      }
    }

    /* +2008.01 bj */
    W5100.writeSnIR(s, SnIR::SEND_OK);
    62fa:	60 e1       	ldi	r22, 0x10	; 16
    62fc:	8b 81       	ldd	r24, Y+3	; 0x03
    62fe:	0e 94 65 a7 	call	0x14eca	; 0x14eca <_ZN10W5100Class9writeSnIREhh>
  }
  return ret;
    6302:	89 81       	ldd	r24, Y+1	; 0x01
    6304:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6306:	2b 96       	adiw	r28, 0x0b	; 11
    6308:	0f b6       	in	r0, 0x3f	; 63
    630a:	f8 94       	cli
    630c:	de bf       	out	0x3e, r29	; 62
    630e:	0f be       	out	0x3f, r0	; 63
    6310:	cd bf       	out	0x3d, r28	; 61
    6312:	df 91       	pop	r29
    6314:	cf 91       	pop	r28
    6316:	1f 91       	pop	r17
    6318:	0f 91       	pop	r16
    631a:	08 95       	ret

0000631c <_Z8recvfromhPhjS_Pj>:
 * 	TCP mode. This function is used to receive UDP, IP_RAW and MAC_RAW mode, and handle the header as well. 
 * 	
 * @return	This function return received data size for success else -1.
 */
uint16_t recvfrom(SOCKET s, uint8_t *buf, uint16_t len, uint8_t *addr, uint16_t *port)
{
    631c:	0f 93       	push	r16
    631e:	1f 93       	push	r17
    6320:	cf 93       	push	r28
    6322:	df 93       	push	r29
    6324:	cd b7       	in	r28, 0x3d	; 61
    6326:	de b7       	in	r29, 0x3e	; 62
    6328:	65 97       	sbiw	r28, 0x15	; 21
    632a:	0f b6       	in	r0, 0x3f	; 63
    632c:	f8 94       	cli
    632e:	de bf       	out	0x3e, r29	; 62
    6330:	0f be       	out	0x3f, r0	; 63
    6332:	cd bf       	out	0x3d, r28	; 61
    6334:	8d 87       	std	Y+13, r24	; 0x0d
    6336:	7f 87       	std	Y+15, r23	; 0x0f
    6338:	6e 87       	std	Y+14, r22	; 0x0e
    633a:	59 8b       	std	Y+17, r21	; 0x11
    633c:	48 8b       	std	Y+16, r20	; 0x10
    633e:	3b 8b       	std	Y+19, r19	; 0x13
    6340:	2a 8b       	std	Y+18, r18	; 0x12
    6342:	1d 8b       	std	Y+21, r17	; 0x15
    6344:	0c 8b       	std	Y+20, r16	; 0x14
  uint8_t head[8];
  uint16_t data_len=0;
    6346:	1a 82       	std	Y+2, r1	; 0x02
    6348:	19 82       	std	Y+1, r1	; 0x01
  uint16_t ptr=0;
    634a:	1c 82       	std	Y+4, r1	; 0x04
    634c:	1b 82       	std	Y+3, r1	; 0x03

  if ( len > 0 )
    634e:	88 89       	ldd	r24, Y+16	; 0x10
    6350:	99 89       	ldd	r25, Y+17	; 0x11
    6352:	00 97       	sbiw	r24, 0x00	; 0
    6354:	09 f4       	brne	.+2      	; 0x6358 <_Z8recvfromhPhjS_Pj+0x3c>
    6356:	21 c1       	rjmp	.+578    	; 0x659a <_Z8recvfromhPhjS_Pj+0x27e>
  {
    ptr = W5100.readSnRX_RD(s);
    6358:	8d 85       	ldd	r24, Y+13	; 0x0d
    635a:	0e 94 0e a8 	call	0x1501c	; 0x1501c <_ZN10W5100Class11readSnRX_RDEh>
    635e:	9c 83       	std	Y+4, r25	; 0x04
    6360:	8b 83       	std	Y+3, r24	; 0x03
    switch (W5100.readSnMR(s) & 0x07)
    6362:	8d 85       	ldd	r24, Y+13	; 0x0d
    6364:	0e 94 56 a7 	call	0x14eac	; 0x14eac <_ZN10W5100Class8readSnMREh>
    6368:	88 2f       	mov	r24, r24
    636a:	90 e0       	ldi	r25, 0x00	; 0
    636c:	87 70       	andi	r24, 0x07	; 7
    636e:	99 27       	eor	r25, r25
    6370:	83 30       	cpi	r24, 0x03	; 3
    6372:	91 05       	cpc	r25, r1
    6374:	09 f4       	brne	.+2      	; 0x6378 <_Z8recvfromhPhjS_Pj+0x5c>
    6376:	76 c0       	rjmp	.+236    	; 0x6464 <_Z8recvfromhPhjS_Pj+0x148>
    6378:	84 30       	cpi	r24, 0x04	; 4
    637a:	91 05       	cpc	r25, r1
    637c:	09 f4       	brne	.+2      	; 0x6380 <_Z8recvfromhPhjS_Pj+0x64>
    637e:	c7 c0       	rjmp	.+398    	; 0x650e <_Z8recvfromhPhjS_Pj+0x1f2>
    6380:	82 30       	cpi	r24, 0x02	; 2
    6382:	91 05       	cpc	r25, r1
    6384:	09 f0       	breq	.+2      	; 0x6388 <_Z8recvfromhPhjS_Pj+0x6c>
    6386:	02 c1       	rjmp	.+516    	; 0x658c <_Z8recvfromhPhjS_Pj+0x270>
    {
    case SnMR::UDP :
      W5100.read_data(s, (uint8_t *)ptr, head, 0x08);
    6388:	8b 81       	ldd	r24, Y+3	; 0x03
    638a:	9c 81       	ldd	r25, Y+4	; 0x04
    638c:	9e 01       	movw	r18, r28
    638e:	2b 5f       	subi	r18, 0xFB	; 251
    6390:	3f 4f       	sbci	r19, 0xFF	; 255
    6392:	08 e0       	ldi	r16, 0x08	; 8
    6394:	10 e0       	ldi	r17, 0x00	; 0
    6396:	ac 01       	movw	r20, r24
    6398:	6d 85       	ldd	r22, Y+13	; 0x0d
    639a:	8c e8       	ldi	r24, 0x8C	; 140
    639c:	97 e0       	ldi	r25, 0x07	; 7
    639e:	0e 94 d2 35 	call	0x6ba4	; 0x6ba4 <_ZN10W5100Class9read_dataEhPVhS1_j>
      ptr += 8;
    63a2:	8b 81       	ldd	r24, Y+3	; 0x03
    63a4:	9c 81       	ldd	r25, Y+4	; 0x04
    63a6:	08 96       	adiw	r24, 0x08	; 8
    63a8:	9c 83       	std	Y+4, r25	; 0x04
    63aa:	8b 83       	std	Y+3, r24	; 0x03
      // read peer's IP address, port number.
      addr[0] = head[0];
    63ac:	2d 81       	ldd	r18, Y+5	; 0x05
    63ae:	8a 89       	ldd	r24, Y+18	; 0x12
    63b0:	9b 89       	ldd	r25, Y+19	; 0x13
    63b2:	fc 01       	movw	r30, r24
    63b4:	20 83       	st	Z, r18
      addr[1] = head[1];
    63b6:	8a 89       	ldd	r24, Y+18	; 0x12
    63b8:	9b 89       	ldd	r25, Y+19	; 0x13
    63ba:	01 96       	adiw	r24, 0x01	; 1
    63bc:	2e 81       	ldd	r18, Y+6	; 0x06
    63be:	fc 01       	movw	r30, r24
    63c0:	20 83       	st	Z, r18
      addr[2] = head[2];
    63c2:	8a 89       	ldd	r24, Y+18	; 0x12
    63c4:	9b 89       	ldd	r25, Y+19	; 0x13
    63c6:	02 96       	adiw	r24, 0x02	; 2
    63c8:	2f 81       	ldd	r18, Y+7	; 0x07
    63ca:	fc 01       	movw	r30, r24
    63cc:	20 83       	st	Z, r18
      addr[3] = head[3];
    63ce:	8a 89       	ldd	r24, Y+18	; 0x12
    63d0:	9b 89       	ldd	r25, Y+19	; 0x13
    63d2:	03 96       	adiw	r24, 0x03	; 3
    63d4:	28 85       	ldd	r18, Y+8	; 0x08
    63d6:	fc 01       	movw	r30, r24
    63d8:	20 83       	st	Z, r18
      *port = head[4];
    63da:	89 85       	ldd	r24, Y+9	; 0x09
    63dc:	28 2f       	mov	r18, r24
    63de:	30 e0       	ldi	r19, 0x00	; 0
    63e0:	8c 89       	ldd	r24, Y+20	; 0x14
    63e2:	9d 89       	ldd	r25, Y+21	; 0x15
    63e4:	fc 01       	movw	r30, r24
    63e6:	31 83       	std	Z+1, r19	; 0x01
    63e8:	20 83       	st	Z, r18
      *port = (*port << 8) + head[5];
    63ea:	8c 89       	ldd	r24, Y+20	; 0x14
    63ec:	9d 89       	ldd	r25, Y+21	; 0x15
    63ee:	fc 01       	movw	r30, r24
    63f0:	80 81       	ld	r24, Z
    63f2:	91 81       	ldd	r25, Z+1	; 0x01
    63f4:	38 2f       	mov	r19, r24
    63f6:	22 27       	eor	r18, r18
    63f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    63fa:	88 2f       	mov	r24, r24
    63fc:	90 e0       	ldi	r25, 0x00	; 0
    63fe:	28 0f       	add	r18, r24
    6400:	39 1f       	adc	r19, r25
    6402:	8c 89       	ldd	r24, Y+20	; 0x14
    6404:	9d 89       	ldd	r25, Y+21	; 0x15
    6406:	fc 01       	movw	r30, r24
    6408:	31 83       	std	Z+1, r19	; 0x01
    640a:	20 83       	st	Z, r18
      data_len = head[6];
    640c:	8b 85       	ldd	r24, Y+11	; 0x0b
    640e:	88 2f       	mov	r24, r24
    6410:	90 e0       	ldi	r25, 0x00	; 0
    6412:	9a 83       	std	Y+2, r25	; 0x02
    6414:	89 83       	std	Y+1, r24	; 0x01
      data_len = (data_len << 8) + head[7];
    6416:	89 81       	ldd	r24, Y+1	; 0x01
    6418:	9a 81       	ldd	r25, Y+2	; 0x02
    641a:	38 2f       	mov	r19, r24
    641c:	22 27       	eor	r18, r18
    641e:	8c 85       	ldd	r24, Y+12	; 0x0c
    6420:	88 2f       	mov	r24, r24
    6422:	90 e0       	ldi	r25, 0x00	; 0
    6424:	82 0f       	add	r24, r18
    6426:	93 1f       	adc	r25, r19
    6428:	9a 83       	std	Y+2, r25	; 0x02
    642a:	89 83       	std	Y+1, r24	; 0x01

      W5100.read_data(s, (uint8_t *)ptr, buf, data_len); // data copy.
    642c:	8b 81       	ldd	r24, Y+3	; 0x03
    642e:	9c 81       	ldd	r25, Y+4	; 0x04
    6430:	49 81       	ldd	r20, Y+1	; 0x01
    6432:	5a 81       	ldd	r21, Y+2	; 0x02
    6434:	2e 85       	ldd	r18, Y+14	; 0x0e
    6436:	3f 85       	ldd	r19, Y+15	; 0x0f
    6438:	8a 01       	movw	r16, r20
    643a:	ac 01       	movw	r20, r24
    643c:	6d 85       	ldd	r22, Y+13	; 0x0d
    643e:	8c e8       	ldi	r24, 0x8C	; 140
    6440:	97 e0       	ldi	r25, 0x07	; 7
    6442:	0e 94 d2 35 	call	0x6ba4	; 0x6ba4 <_ZN10W5100Class9read_dataEhPVhS1_j>
      ptr += data_len;
    6446:	2b 81       	ldd	r18, Y+3	; 0x03
    6448:	3c 81       	ldd	r19, Y+4	; 0x04
    644a:	89 81       	ldd	r24, Y+1	; 0x01
    644c:	9a 81       	ldd	r25, Y+2	; 0x02
    644e:	82 0f       	add	r24, r18
    6450:	93 1f       	adc	r25, r19
    6452:	9c 83       	std	Y+4, r25	; 0x04
    6454:	8b 83       	std	Y+3, r24	; 0x03

      W5100.writeSnRX_RD(s, ptr);
    6456:	8b 81       	ldd	r24, Y+3	; 0x03
    6458:	9c 81       	ldd	r25, Y+4	; 0x04
    645a:	bc 01       	movw	r22, r24
    645c:	8d 85       	ldd	r24, Y+13	; 0x0d
    645e:	0e 94 ee a7 	call	0x14fdc	; 0x14fdc <_ZN10W5100Class12writeSnRX_RDEhj>
      break;
    6462:	95 c0       	rjmp	.+298    	; 0x658e <_Z8recvfromhPhjS_Pj+0x272>

    case SnMR::IPRAW :
      W5100.read_data(s, (uint8_t *)ptr, head, 0x06);
    6464:	8b 81       	ldd	r24, Y+3	; 0x03
    6466:	9c 81       	ldd	r25, Y+4	; 0x04
    6468:	9e 01       	movw	r18, r28
    646a:	2b 5f       	subi	r18, 0xFB	; 251
    646c:	3f 4f       	sbci	r19, 0xFF	; 255
    646e:	06 e0       	ldi	r16, 0x06	; 6
    6470:	10 e0       	ldi	r17, 0x00	; 0
    6472:	ac 01       	movw	r20, r24
    6474:	6d 85       	ldd	r22, Y+13	; 0x0d
    6476:	8c e8       	ldi	r24, 0x8C	; 140
    6478:	97 e0       	ldi	r25, 0x07	; 7
    647a:	0e 94 d2 35 	call	0x6ba4	; 0x6ba4 <_ZN10W5100Class9read_dataEhPVhS1_j>
      ptr += 6;
    647e:	8b 81       	ldd	r24, Y+3	; 0x03
    6480:	9c 81       	ldd	r25, Y+4	; 0x04
    6482:	06 96       	adiw	r24, 0x06	; 6
    6484:	9c 83       	std	Y+4, r25	; 0x04
    6486:	8b 83       	std	Y+3, r24	; 0x03

      addr[0] = head[0];
    6488:	2d 81       	ldd	r18, Y+5	; 0x05
    648a:	8a 89       	ldd	r24, Y+18	; 0x12
    648c:	9b 89       	ldd	r25, Y+19	; 0x13
    648e:	fc 01       	movw	r30, r24
    6490:	20 83       	st	Z, r18
      addr[1] = head[1];
    6492:	8a 89       	ldd	r24, Y+18	; 0x12
    6494:	9b 89       	ldd	r25, Y+19	; 0x13
    6496:	01 96       	adiw	r24, 0x01	; 1
    6498:	2e 81       	ldd	r18, Y+6	; 0x06
    649a:	fc 01       	movw	r30, r24
    649c:	20 83       	st	Z, r18
      addr[2] = head[2];
    649e:	8a 89       	ldd	r24, Y+18	; 0x12
    64a0:	9b 89       	ldd	r25, Y+19	; 0x13
    64a2:	02 96       	adiw	r24, 0x02	; 2
    64a4:	2f 81       	ldd	r18, Y+7	; 0x07
    64a6:	fc 01       	movw	r30, r24
    64a8:	20 83       	st	Z, r18
      addr[3] = head[3];
    64aa:	8a 89       	ldd	r24, Y+18	; 0x12
    64ac:	9b 89       	ldd	r25, Y+19	; 0x13
    64ae:	03 96       	adiw	r24, 0x03	; 3
    64b0:	28 85       	ldd	r18, Y+8	; 0x08
    64b2:	fc 01       	movw	r30, r24
    64b4:	20 83       	st	Z, r18
      data_len = head[4];
    64b6:	89 85       	ldd	r24, Y+9	; 0x09
    64b8:	88 2f       	mov	r24, r24
    64ba:	90 e0       	ldi	r25, 0x00	; 0
    64bc:	9a 83       	std	Y+2, r25	; 0x02
    64be:	89 83       	std	Y+1, r24	; 0x01
      data_len = (data_len << 8) + head[5];
    64c0:	89 81       	ldd	r24, Y+1	; 0x01
    64c2:	9a 81       	ldd	r25, Y+2	; 0x02
    64c4:	38 2f       	mov	r19, r24
    64c6:	22 27       	eor	r18, r18
    64c8:	8a 85       	ldd	r24, Y+10	; 0x0a
    64ca:	88 2f       	mov	r24, r24
    64cc:	90 e0       	ldi	r25, 0x00	; 0
    64ce:	82 0f       	add	r24, r18
    64d0:	93 1f       	adc	r25, r19
    64d2:	9a 83       	std	Y+2, r25	; 0x02
    64d4:	89 83       	std	Y+1, r24	; 0x01

      W5100.read_data(s, (uint8_t *)ptr, buf, data_len); // data copy.
    64d6:	8b 81       	ldd	r24, Y+3	; 0x03
    64d8:	9c 81       	ldd	r25, Y+4	; 0x04
    64da:	49 81       	ldd	r20, Y+1	; 0x01
    64dc:	5a 81       	ldd	r21, Y+2	; 0x02
    64de:	2e 85       	ldd	r18, Y+14	; 0x0e
    64e0:	3f 85       	ldd	r19, Y+15	; 0x0f
    64e2:	8a 01       	movw	r16, r20
    64e4:	ac 01       	movw	r20, r24
    64e6:	6d 85       	ldd	r22, Y+13	; 0x0d
    64e8:	8c e8       	ldi	r24, 0x8C	; 140
    64ea:	97 e0       	ldi	r25, 0x07	; 7
    64ec:	0e 94 d2 35 	call	0x6ba4	; 0x6ba4 <_ZN10W5100Class9read_dataEhPVhS1_j>
      ptr += data_len;
    64f0:	2b 81       	ldd	r18, Y+3	; 0x03
    64f2:	3c 81       	ldd	r19, Y+4	; 0x04
    64f4:	89 81       	ldd	r24, Y+1	; 0x01
    64f6:	9a 81       	ldd	r25, Y+2	; 0x02
    64f8:	82 0f       	add	r24, r18
    64fa:	93 1f       	adc	r25, r19
    64fc:	9c 83       	std	Y+4, r25	; 0x04
    64fe:	8b 83       	std	Y+3, r24	; 0x03

      W5100.writeSnRX_RD(s, ptr);
    6500:	8b 81       	ldd	r24, Y+3	; 0x03
    6502:	9c 81       	ldd	r25, Y+4	; 0x04
    6504:	bc 01       	movw	r22, r24
    6506:	8d 85       	ldd	r24, Y+13	; 0x0d
    6508:	0e 94 ee a7 	call	0x14fdc	; 0x14fdc <_ZN10W5100Class12writeSnRX_RDEhj>
      break;
    650c:	40 c0       	rjmp	.+128    	; 0x658e <_Z8recvfromhPhjS_Pj+0x272>

    case SnMR::MACRAW:
      W5100.read_data(s,(uint8_t*)ptr,head,2);
    650e:	8b 81       	ldd	r24, Y+3	; 0x03
    6510:	9c 81       	ldd	r25, Y+4	; 0x04
    6512:	9e 01       	movw	r18, r28
    6514:	2b 5f       	subi	r18, 0xFB	; 251
    6516:	3f 4f       	sbci	r19, 0xFF	; 255
    6518:	02 e0       	ldi	r16, 0x02	; 2
    651a:	10 e0       	ldi	r17, 0x00	; 0
    651c:	ac 01       	movw	r20, r24
    651e:	6d 85       	ldd	r22, Y+13	; 0x0d
    6520:	8c e8       	ldi	r24, 0x8C	; 140
    6522:	97 e0       	ldi	r25, 0x07	; 7
    6524:	0e 94 d2 35 	call	0x6ba4	; 0x6ba4 <_ZN10W5100Class9read_dataEhPVhS1_j>
      ptr+=2;
    6528:	8b 81       	ldd	r24, Y+3	; 0x03
    652a:	9c 81       	ldd	r25, Y+4	; 0x04
    652c:	02 96       	adiw	r24, 0x02	; 2
    652e:	9c 83       	std	Y+4, r25	; 0x04
    6530:	8b 83       	std	Y+3, r24	; 0x03
      data_len = head[0];
    6532:	8d 81       	ldd	r24, Y+5	; 0x05
    6534:	88 2f       	mov	r24, r24
    6536:	90 e0       	ldi	r25, 0x00	; 0
    6538:	9a 83       	std	Y+2, r25	; 0x02
    653a:	89 83       	std	Y+1, r24	; 0x01
      data_len = (data_len<<8) + head[1] - 2;
    653c:	89 81       	ldd	r24, Y+1	; 0x01
    653e:	9a 81       	ldd	r25, Y+2	; 0x02
    6540:	38 2f       	mov	r19, r24
    6542:	22 27       	eor	r18, r18
    6544:	8e 81       	ldd	r24, Y+6	; 0x06
    6546:	88 2f       	mov	r24, r24
    6548:	90 e0       	ldi	r25, 0x00	; 0
    654a:	82 0f       	add	r24, r18
    654c:	93 1f       	adc	r25, r19
    654e:	02 97       	sbiw	r24, 0x02	; 2
    6550:	9a 83       	std	Y+2, r25	; 0x02
    6552:	89 83       	std	Y+1, r24	; 0x01

      W5100.read_data(s,(uint8_t*) ptr,buf,data_len);
    6554:	8b 81       	ldd	r24, Y+3	; 0x03
    6556:	9c 81       	ldd	r25, Y+4	; 0x04
    6558:	49 81       	ldd	r20, Y+1	; 0x01
    655a:	5a 81       	ldd	r21, Y+2	; 0x02
    655c:	2e 85       	ldd	r18, Y+14	; 0x0e
    655e:	3f 85       	ldd	r19, Y+15	; 0x0f
    6560:	8a 01       	movw	r16, r20
    6562:	ac 01       	movw	r20, r24
    6564:	6d 85       	ldd	r22, Y+13	; 0x0d
    6566:	8c e8       	ldi	r24, 0x8C	; 140
    6568:	97 e0       	ldi	r25, 0x07	; 7
    656a:	0e 94 d2 35 	call	0x6ba4	; 0x6ba4 <_ZN10W5100Class9read_dataEhPVhS1_j>
      ptr += data_len;
    656e:	2b 81       	ldd	r18, Y+3	; 0x03
    6570:	3c 81       	ldd	r19, Y+4	; 0x04
    6572:	89 81       	ldd	r24, Y+1	; 0x01
    6574:	9a 81       	ldd	r25, Y+2	; 0x02
    6576:	82 0f       	add	r24, r18
    6578:	93 1f       	adc	r25, r19
    657a:	9c 83       	std	Y+4, r25	; 0x04
    657c:	8b 83       	std	Y+3, r24	; 0x03
      W5100.writeSnRX_RD(s, ptr);
    657e:	8b 81       	ldd	r24, Y+3	; 0x03
    6580:	9c 81       	ldd	r25, Y+4	; 0x04
    6582:	bc 01       	movw	r22, r24
    6584:	8d 85       	ldd	r24, Y+13	; 0x0d
    6586:	0e 94 ee a7 	call	0x14fdc	; 0x14fdc <_ZN10W5100Class12writeSnRX_RDEhj>
      break;
    658a:	01 c0       	rjmp	.+2      	; 0x658e <_Z8recvfromhPhjS_Pj+0x272>

    default :
      break;
    658c:	00 00       	nop
    }
    W5100.execCmdSn(s, Sock_RECV);
    658e:	40 e4       	ldi	r20, 0x40	; 64
    6590:	6d 85       	ldd	r22, Y+13	; 0x0d
    6592:	8c e8       	ldi	r24, 0x8C	; 140
    6594:	97 e0       	ldi	r25, 0x07	; 7
    6596:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>
  }
  return data_len;
    659a:	89 81       	ldd	r24, Y+1	; 0x01
    659c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    659e:	65 96       	adiw	r28, 0x15	; 21
    65a0:	0f b6       	in	r0, 0x3f	; 63
    65a2:	f8 94       	cli
    65a4:	de bf       	out	0x3e, r29	; 62
    65a6:	0f be       	out	0x3f, r0	; 63
    65a8:	cd bf       	out	0x3d, r28	; 61
    65aa:	df 91       	pop	r29
    65ac:	cf 91       	pop	r28
    65ae:	1f 91       	pop	r17
    65b0:	0f 91       	pop	r16
    65b2:	08 95       	ret

000065b4 <_Z8igmpsendhPKhj>:


uint16_t igmpsend(SOCKET s, const uint8_t * buf, uint16_t len)
{
    65b4:	cf 93       	push	r28
    65b6:	df 93       	push	r29
    65b8:	cd b7       	in	r28, 0x3d	; 61
    65ba:	de b7       	in	r29, 0x3e	; 62
    65bc:	28 97       	sbiw	r28, 0x08	; 8
    65be:	0f b6       	in	r0, 0x3f	; 63
    65c0:	f8 94       	cli
    65c2:	de bf       	out	0x3e, r29	; 62
    65c4:	0f be       	out	0x3f, r0	; 63
    65c6:	cd bf       	out	0x3d, r28	; 61
    65c8:	8c 83       	std	Y+4, r24	; 0x04
    65ca:	7e 83       	std	Y+6, r23	; 0x06
    65cc:	6d 83       	std	Y+5, r22	; 0x05
    65ce:	58 87       	std	Y+8, r21	; 0x08
    65d0:	4f 83       	std	Y+7, r20	; 0x07
  uint8_t status=0;
    65d2:	1b 82       	std	Y+3, r1	; 0x03
  uint16_t ret=0;
    65d4:	1a 82       	std	Y+2, r1	; 0x02
    65d6:	19 82       	std	Y+1, r1	; 0x01

  if (len > W5100.SSIZE) 
    65d8:	8f 81       	ldd	r24, Y+7	; 0x07
    65da:	98 85       	ldd	r25, Y+8	; 0x08
    65dc:	81 30       	cpi	r24, 0x01	; 1
    65de:	28 e0       	ldi	r18, 0x08	; 8
    65e0:	92 07       	cpc	r25, r18
    65e2:	28 f0       	brcs	.+10     	; 0x65ee <_Z8igmpsendhPKhj+0x3a>
    ret = W5100.SSIZE; // check size not to exceed MAX size.
    65e4:	80 e0       	ldi	r24, 0x00	; 0
    65e6:	98 e0       	ldi	r25, 0x08	; 8
    65e8:	9a 83       	std	Y+2, r25	; 0x02
    65ea:	89 83       	std	Y+1, r24	; 0x01
    65ec:	04 c0       	rjmp	.+8      	; 0x65f6 <_Z8igmpsendhPKhj+0x42>
  else 
    ret = len;
    65ee:	8f 81       	ldd	r24, Y+7	; 0x07
    65f0:	98 85       	ldd	r25, Y+8	; 0x08
    65f2:	9a 83       	std	Y+2, r25	; 0x02
    65f4:	89 83       	std	Y+1, r24	; 0x01

  if (ret == 0)
    65f6:	89 81       	ldd	r24, Y+1	; 0x01
    65f8:	9a 81       	ldd	r25, Y+2	; 0x02
    65fa:	00 97       	sbiw	r24, 0x00	; 0
    65fc:	19 f4       	brne	.+6      	; 0x6604 <_Z8igmpsendhPKhj+0x50>
    return 0;
    65fe:	80 e0       	ldi	r24, 0x00	; 0
    6600:	90 e0       	ldi	r25, 0x00	; 0
    6602:	3b c0       	rjmp	.+118    	; 0x667a <_Z8igmpsendhPKhj+0xc6>

  W5100.send_data_processing(s, (uint8_t *)buf, ret);
    6604:	29 81       	ldd	r18, Y+1	; 0x01
    6606:	3a 81       	ldd	r19, Y+2	; 0x02
    6608:	8d 81       	ldd	r24, Y+5	; 0x05
    660a:	9e 81       	ldd	r25, Y+6	; 0x06
    660c:	ac 01       	movw	r20, r24
    660e:	6c 81       	ldd	r22, Y+4	; 0x04
    6610:	8c e8       	ldi	r24, 0x8C	; 140
    6612:	97 e0       	ldi	r25, 0x07	; 7
    6614:	0e 94 d2 34 	call	0x69a4	; 0x69a4 <_ZN10W5100Class20send_data_processingEhPKhj>
  W5100.execCmdSn(s, Sock_SEND);
    6618:	40 e2       	ldi	r20, 0x20	; 32
    661a:	6c 81       	ldd	r22, Y+4	; 0x04
    661c:	8c e8       	ldi	r24, 0x8C	; 140
    661e:	97 e0       	ldi	r25, 0x07	; 7
    6620:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>

  while ( (W5100.readSnIR(s) & SnIR::SEND_OK) != SnIR::SEND_OK ) 
    6624:	17 c0       	rjmp	.+46     	; 0x6654 <_Z8igmpsendhPKhj+0xa0>
  {
    status = W5100.readSnSR(s);
    6626:	8c 81       	ldd	r24, Y+4	; 0x04
    6628:	0e 94 86 a7 	call	0x14f0c	; 0x14f0c <_ZN10W5100Class8readSnSREh>
    662c:	8b 83       	std	Y+3, r24	; 0x03
    if (W5100.readSnIR(s) & SnIR::TIMEOUT)
    662e:	8c 81       	ldd	r24, Y+4	; 0x04
    6630:	0e 94 77 a7 	call	0x14eee	; 0x14eee <_ZN10W5100Class8readSnIREh>
    6634:	88 2f       	mov	r24, r24
    6636:	90 e0       	ldi	r25, 0x00	; 0
    6638:	88 70       	andi	r24, 0x08	; 8
    663a:	99 27       	eor	r25, r25
    663c:	21 e0       	ldi	r18, 0x01	; 1
    663e:	00 97       	sbiw	r24, 0x00	; 0
    6640:	09 f4       	brne	.+2      	; 0x6644 <_Z8igmpsendhPKhj+0x90>
    6642:	20 e0       	ldi	r18, 0x00	; 0
    6644:	22 23       	and	r18, r18
    6646:	31 f0       	breq	.+12     	; 0x6654 <_Z8igmpsendhPKhj+0xa0>
    {
      /* in case of igmp, if send fails, then socket closed */
      /* if you want change, remove this code. */
      close(s);
    6648:	8c 81       	ldd	r24, Y+4	; 0x04
    664a:	0e 94 55 2f 	call	0x5eaa	; 0x5eaa <_Z5closeh>
      return 0;
    664e:	80 e0       	ldi	r24, 0x00	; 0
    6650:	90 e0       	ldi	r25, 0x00	; 0
    6652:	13 c0       	rjmp	.+38     	; 0x667a <_Z8igmpsendhPKhj+0xc6>
    return 0;

  W5100.send_data_processing(s, (uint8_t *)buf, ret);
  W5100.execCmdSn(s, Sock_SEND);

  while ( (W5100.readSnIR(s) & SnIR::SEND_OK) != SnIR::SEND_OK ) 
    6654:	8c 81       	ldd	r24, Y+4	; 0x04
    6656:	0e 94 77 a7 	call	0x14eee	; 0x14eee <_ZN10W5100Class8readSnIREh>
    665a:	88 2f       	mov	r24, r24
    665c:	90 e0       	ldi	r25, 0x00	; 0
    665e:	80 71       	andi	r24, 0x10	; 16
    6660:	99 27       	eor	r25, r25
    6662:	21 e0       	ldi	r18, 0x01	; 1
    6664:	00 97       	sbiw	r24, 0x00	; 0
    6666:	09 f0       	breq	.+2      	; 0x666a <_Z8igmpsendhPKhj+0xb6>
    6668:	20 e0       	ldi	r18, 0x00	; 0
    666a:	22 23       	and	r18, r18
    666c:	e1 f6       	brne	.-72     	; 0x6626 <_Z8igmpsendhPKhj+0x72>
      close(s);
      return 0;
    }
  }

  W5100.writeSnIR(s, SnIR::SEND_OK);
    666e:	60 e1       	ldi	r22, 0x10	; 16
    6670:	8c 81       	ldd	r24, Y+4	; 0x04
    6672:	0e 94 65 a7 	call	0x14eca	; 0x14eca <_ZN10W5100Class9writeSnIREhh>
  return ret;
    6676:	89 81       	ldd	r24, Y+1	; 0x01
    6678:	9a 81       	ldd	r25, Y+2	; 0x02
}
    667a:	28 96       	adiw	r28, 0x08	; 8
    667c:	0f b6       	in	r0, 0x3f	; 63
    667e:	f8 94       	cli
    6680:	de bf       	out	0x3e, r29	; 62
    6682:	0f be       	out	0x3f, r0	; 63
    6684:	cd bf       	out	0x3d, r28	; 61
    6686:	df 91       	pop	r29
    6688:	cf 91       	pop	r28
    668a:	08 95       	ret

0000668c <_Z10bufferDatahjPKhj>:

uint16_t bufferData(SOCKET s, uint16_t offset, const uint8_t* buf, uint16_t len)
{
    668c:	0f 93       	push	r16
    668e:	1f 93       	push	r17
    6690:	cf 93       	push	r28
    6692:	df 93       	push	r29
    6694:	cd b7       	in	r28, 0x3d	; 61
    6696:	de b7       	in	r29, 0x3e	; 62
    6698:	29 97       	sbiw	r28, 0x09	; 9
    669a:	0f b6       	in	r0, 0x3f	; 63
    669c:	f8 94       	cli
    669e:	de bf       	out	0x3e, r29	; 62
    66a0:	0f be       	out	0x3f, r0	; 63
    66a2:	cd bf       	out	0x3d, r28	; 61
    66a4:	8b 83       	std	Y+3, r24	; 0x03
    66a6:	7d 83       	std	Y+5, r23	; 0x05
    66a8:	6c 83       	std	Y+4, r22	; 0x04
    66aa:	5f 83       	std	Y+7, r21	; 0x07
    66ac:	4e 83       	std	Y+6, r20	; 0x06
    66ae:	39 87       	std	Y+9, r19	; 0x09
    66b0:	28 87       	std	Y+8, r18	; 0x08
  uint16_t ret =0;
    66b2:	1a 82       	std	Y+2, r1	; 0x02
    66b4:	19 82       	std	Y+1, r1	; 0x01
  if (len > W5100.getTXFreeSize(s))
    66b6:	6b 81       	ldd	r22, Y+3	; 0x03
    66b8:	8c e8       	ldi	r24, 0x8C	; 140
    66ba:	97 e0       	ldi	r25, 0x07	; 7
    66bc:	0e 94 68 34 	call	0x68d0	; 0x68d0 <_ZN10W5100Class13getTXFreeSizeEh>
    66c0:	9c 01       	movw	r18, r24
    66c2:	41 e0       	ldi	r20, 0x01	; 1
    66c4:	88 85       	ldd	r24, Y+8	; 0x08
    66c6:	99 85       	ldd	r25, Y+9	; 0x09
    66c8:	28 17       	cp	r18, r24
    66ca:	39 07       	cpc	r19, r25
    66cc:	08 f0       	brcs	.+2      	; 0x66d0 <_Z10bufferDatahjPKhj+0x44>
    66ce:	40 e0       	ldi	r20, 0x00	; 0
    66d0:	44 23       	and	r20, r20
    66d2:	41 f0       	breq	.+16     	; 0x66e4 <_Z10bufferDatahjPKhj+0x58>
  {
    ret = W5100.getTXFreeSize(s); // check size not to exceed MAX size.
    66d4:	6b 81       	ldd	r22, Y+3	; 0x03
    66d6:	8c e8       	ldi	r24, 0x8C	; 140
    66d8:	97 e0       	ldi	r25, 0x07	; 7
    66da:	0e 94 68 34 	call	0x68d0	; 0x68d0 <_ZN10W5100Class13getTXFreeSizeEh>
    66de:	9a 83       	std	Y+2, r25	; 0x02
    66e0:	89 83       	std	Y+1, r24	; 0x01
    66e2:	04 c0       	rjmp	.+8      	; 0x66ec <_Z10bufferDatahjPKhj+0x60>
  }
  else
  {
    ret = len;
    66e4:	88 85       	ldd	r24, Y+8	; 0x08
    66e6:	99 85       	ldd	r25, Y+9	; 0x09
    66e8:	9a 83       	std	Y+2, r25	; 0x02
    66ea:	89 83       	std	Y+1, r24	; 0x01
  }
  W5100.send_data_processing_offset(s, offset, buf, ret);
    66ec:	49 81       	ldd	r20, Y+1	; 0x01
    66ee:	5a 81       	ldd	r21, Y+2	; 0x02
    66f0:	2e 81       	ldd	r18, Y+6	; 0x06
    66f2:	3f 81       	ldd	r19, Y+7	; 0x07
    66f4:	8c 81       	ldd	r24, Y+4	; 0x04
    66f6:	9d 81       	ldd	r25, Y+5	; 0x05
    66f8:	8a 01       	movw	r16, r20
    66fa:	ac 01       	movw	r20, r24
    66fc:	6b 81       	ldd	r22, Y+3	; 0x03
    66fe:	8c e8       	ldi	r24, 0x8C	; 140
    6700:	97 e0       	ldi	r25, 0x07	; 7
    6702:	0e 94 fc 34 	call	0x69f8	; 0x69f8 <_ZN10W5100Class27send_data_processing_offsetEhjPKhj>
  return ret;
    6706:	89 81       	ldd	r24, Y+1	; 0x01
    6708:	9a 81       	ldd	r25, Y+2	; 0x02
}
    670a:	29 96       	adiw	r28, 0x09	; 9
    670c:	0f b6       	in	r0, 0x3f	; 63
    670e:	f8 94       	cli
    6710:	de bf       	out	0x3e, r29	; 62
    6712:	0f be       	out	0x3f, r0	; 63
    6714:	cd bf       	out	0x3d, r28	; 61
    6716:	df 91       	pop	r29
    6718:	cf 91       	pop	r28
    671a:	1f 91       	pop	r17
    671c:	0f 91       	pop	r16
    671e:	08 95       	ret

00006720 <_Z8startUDPhPhj>:

int startUDP(SOCKET s, uint8_t* addr, uint16_t port)
{
    6720:	cf 93       	push	r28
    6722:	df 93       	push	r29
    6724:	00 d0       	rcall	.+0      	; 0x6726 <_Z8startUDPhPhj+0x6>
    6726:	00 d0       	rcall	.+0      	; 0x6728 <_Z8startUDPhPhj+0x8>
    6728:	1f 92       	push	r1
    672a:	cd b7       	in	r28, 0x3d	; 61
    672c:	de b7       	in	r29, 0x3e	; 62
    672e:	89 83       	std	Y+1, r24	; 0x01
    6730:	7b 83       	std	Y+3, r23	; 0x03
    6732:	6a 83       	std	Y+2, r22	; 0x02
    6734:	5d 83       	std	Y+5, r21	; 0x05
    6736:	4c 83       	std	Y+4, r20	; 0x04
  if
    (
     ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    6738:	8a 81       	ldd	r24, Y+2	; 0x02
    673a:	9b 81       	ldd	r25, Y+3	; 0x03
    673c:	fc 01       	movw	r30, r24
    673e:	80 81       	ld	r24, Z
  return ret;
}

int startUDP(SOCKET s, uint8_t* addr, uint16_t port)
{
  if
    6740:	88 23       	and	r24, r24
    6742:	a9 f4       	brne	.+42     	; 0x676e <_Z8startUDPhPhj+0x4e>
    (
     ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    6744:	8a 81       	ldd	r24, Y+2	; 0x02
    6746:	9b 81       	ldd	r25, Y+3	; 0x03
    6748:	01 96       	adiw	r24, 0x01	; 1
    674a:	fc 01       	movw	r30, r24
    674c:	80 81       	ld	r24, Z
  return ret;
}

int startUDP(SOCKET s, uint8_t* addr, uint16_t port)
{
  if
    674e:	88 23       	and	r24, r24
    6750:	71 f4       	brne	.+28     	; 0x676e <_Z8startUDPhPhj+0x4e>
    (
     ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    6752:	8a 81       	ldd	r24, Y+2	; 0x02
    6754:	9b 81       	ldd	r25, Y+3	; 0x03
    6756:	02 96       	adiw	r24, 0x02	; 2
    6758:	fc 01       	movw	r30, r24
    675a:	80 81       	ld	r24, Z
  return ret;
}

int startUDP(SOCKET s, uint8_t* addr, uint16_t port)
{
  if
    675c:	88 23       	and	r24, r24
    675e:	39 f4       	brne	.+14     	; 0x676e <_Z8startUDPhPhj+0x4e>
    (
     ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
    6760:	8a 81       	ldd	r24, Y+2	; 0x02
    6762:	9b 81       	ldd	r25, Y+3	; 0x03
    6764:	03 96       	adiw	r24, 0x03	; 3
    6766:	fc 01       	movw	r30, r24
    6768:	80 81       	ld	r24, Z
  return ret;
}

int startUDP(SOCKET s, uint8_t* addr, uint16_t port)
{
  if
    676a:	88 23       	and	r24, r24
    676c:	21 f0       	breq	.+8      	; 0x6776 <_Z8startUDPhPhj+0x56>
    676e:	8c 81       	ldd	r24, Y+4	; 0x04
    6770:	9d 81       	ldd	r25, Y+5	; 0x05
    6772:	00 97       	sbiw	r24, 0x00	; 0
    6774:	19 f4       	brne	.+6      	; 0x677c <_Z8startUDPhPhj+0x5c>
    (
     ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
     ((port == 0x00))
    ) 
  {
    return 0;
    6776:	80 e0       	ldi	r24, 0x00	; 0
    6778:	90 e0       	ldi	r25, 0x00	; 0
    677a:	0e c0       	rjmp	.+28     	; 0x6798 <_Z8startUDPhPhj+0x78>
  }
  else
  {
    W5100.writeSnDIPR(s, addr);
    677c:	8a 81       	ldd	r24, Y+2	; 0x02
    677e:	9b 81       	ldd	r25, Y+3	; 0x03
    6780:	bc 01       	movw	r22, r24
    6782:	89 81       	ldd	r24, Y+1	; 0x01
    6784:	0e 94 b5 a7 	call	0x14f6a	; 0x14f6a <_ZN10W5100Class11writeSnDIPREhPh>
    W5100.writeSnDPORT(s, port);
    6788:	8c 81       	ldd	r24, Y+4	; 0x04
    678a:	9d 81       	ldd	r25, Y+5	; 0x05
    678c:	bc 01       	movw	r22, r24
    678e:	89 81       	ldd	r24, Y+1	; 0x01
    6790:	0e 94 ce a7 	call	0x14f9c	; 0x14f9c <_ZN10W5100Class12writeSnDPORTEhj>
    return 1;
    6794:	81 e0       	ldi	r24, 0x01	; 1
    6796:	90 e0       	ldi	r25, 0x00	; 0
  }
}
    6798:	0f 90       	pop	r0
    679a:	0f 90       	pop	r0
    679c:	0f 90       	pop	r0
    679e:	0f 90       	pop	r0
    67a0:	0f 90       	pop	r0
    67a2:	df 91       	pop	r29
    67a4:	cf 91       	pop	r28
    67a6:	08 95       	ret

000067a8 <_Z7sendUDPh>:

int sendUDP(SOCKET s)
{
    67a8:	cf 93       	push	r28
    67aa:	df 93       	push	r29
    67ac:	1f 92       	push	r1
    67ae:	cd b7       	in	r28, 0x3d	; 61
    67b0:	de b7       	in	r29, 0x3e	; 62
    67b2:	89 83       	std	Y+1, r24	; 0x01
  W5100.execCmdSn(s, Sock_SEND);
    67b4:	40 e2       	ldi	r20, 0x20	; 32
    67b6:	69 81       	ldd	r22, Y+1	; 0x01
    67b8:	8c e8       	ldi	r24, 0x8C	; 140
    67ba:	97 e0       	ldi	r25, 0x07	; 7
    67bc:	0e 94 38 37 	call	0x6e70	; 0x6e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>
		
  /* +2008.01 bj */
  while ( (W5100.readSnIR(s) & SnIR::SEND_OK) != SnIR::SEND_OK ) 
    67c0:	14 c0       	rjmp	.+40     	; 0x67ea <_Z7sendUDPh+0x42>
  {
    if (W5100.readSnIR(s) & SnIR::TIMEOUT)
    67c2:	89 81       	ldd	r24, Y+1	; 0x01
    67c4:	0e 94 77 a7 	call	0x14eee	; 0x14eee <_ZN10W5100Class8readSnIREh>
    67c8:	88 2f       	mov	r24, r24
    67ca:	90 e0       	ldi	r25, 0x00	; 0
    67cc:	88 70       	andi	r24, 0x08	; 8
    67ce:	99 27       	eor	r25, r25
    67d0:	21 e0       	ldi	r18, 0x01	; 1
    67d2:	00 97       	sbiw	r24, 0x00	; 0
    67d4:	09 f4       	brne	.+2      	; 0x67d8 <_Z7sendUDPh+0x30>
    67d6:	20 e0       	ldi	r18, 0x00	; 0
    67d8:	22 23       	and	r18, r18
    67da:	39 f0       	breq	.+14     	; 0x67ea <_Z7sendUDPh+0x42>
    {
      /* +2008.01 [bj]: clear interrupt */
      W5100.writeSnIR(s, (SnIR::SEND_OK|SnIR::TIMEOUT));
    67dc:	68 e1       	ldi	r22, 0x18	; 24
    67de:	89 81       	ldd	r24, Y+1	; 0x01
    67e0:	0e 94 65 a7 	call	0x14eca	; 0x14eca <_ZN10W5100Class9writeSnIREhh>
      return 0;
    67e4:	80 e0       	ldi	r24, 0x00	; 0
    67e6:	90 e0       	ldi	r25, 0x00	; 0
    67e8:	13 c0       	rjmp	.+38     	; 0x6810 <_Z7sendUDPh+0x68>
int sendUDP(SOCKET s)
{
  W5100.execCmdSn(s, Sock_SEND);
		
  /* +2008.01 bj */
  while ( (W5100.readSnIR(s) & SnIR::SEND_OK) != SnIR::SEND_OK ) 
    67ea:	89 81       	ldd	r24, Y+1	; 0x01
    67ec:	0e 94 77 a7 	call	0x14eee	; 0x14eee <_ZN10W5100Class8readSnIREh>
    67f0:	88 2f       	mov	r24, r24
    67f2:	90 e0       	ldi	r25, 0x00	; 0
    67f4:	80 71       	andi	r24, 0x10	; 16
    67f6:	99 27       	eor	r25, r25
    67f8:	21 e0       	ldi	r18, 0x01	; 1
    67fa:	00 97       	sbiw	r24, 0x00	; 0
    67fc:	09 f0       	breq	.+2      	; 0x6800 <_Z7sendUDPh+0x58>
    67fe:	20 e0       	ldi	r18, 0x00	; 0
    6800:	22 23       	and	r18, r18
    6802:	f9 f6       	brne	.-66     	; 0x67c2 <_Z7sendUDPh+0x1a>
      return 0;
    }
  }

  /* +2008.01 bj */	
  W5100.writeSnIR(s, SnIR::SEND_OK);
    6804:	60 e1       	ldi	r22, 0x10	; 16
    6806:	89 81       	ldd	r24, Y+1	; 0x01
    6808:	0e 94 65 a7 	call	0x14eca	; 0x14eca <_ZN10W5100Class9writeSnIREhh>

  /* Sent ok */
  return 1;
    680c:	81 e0       	ldi	r24, 0x01	; 1
    680e:	90 e0       	ldi	r25, 0x00	; 0
}
    6810:	0f 90       	pop	r0
    6812:	df 91       	pop	r29
    6814:	cf 91       	pop	r28
    6816:	08 95       	ret

00006818 <_ZN10W5100Class4initEv>:

#define TXBUF_BASE 0x4000
#define RXBUF_BASE 0x6000

void W5100Class::init(void)
{
    6818:	cf 93       	push	r28
    681a:	df 93       	push	r29
    681c:	00 d0       	rcall	.+0      	; 0x681e <_ZN10W5100Class4initEv+0x6>
    681e:	00 d0       	rcall	.+0      	; 0x6820 <_ZN10W5100Class4initEv+0x8>
    6820:	cd b7       	in	r28, 0x3d	; 61
    6822:	de b7       	in	r29, 0x3e	; 62
    6824:	9c 83       	std	Y+4, r25	; 0x04
    6826:	8b 83       	std	Y+3, r24	; 0x03
  delay(300);
    6828:	6c e2       	ldi	r22, 0x2C	; 44
    682a:	71 e0       	ldi	r23, 0x01	; 1
    682c:	80 e0       	ldi	r24, 0x00	; 0
    682e:	90 e0       	ldi	r25, 0x00	; 0
    6830:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>

  SPI.begin();
    6834:	0e 94 63 26 	call	0x4cc6	; 0x4cc6 <_ZN8SPIClass5beginEv>
  initSS();
    6838:	0e 94 da a9 	call	0x153b4	; 0x153b4 <_ZN10W5100Class6initSSEv>
  
  writeMR(1<<RST);
    683c:	80 e8       	ldi	r24, 0x80	; 128
    683e:	0e 94 c7 a8 	call	0x1518e	; 0x1518e <_ZN10W5100Class7writeMREh>
  writeTMSR(0x55);
    6842:	85 e5       	ldi	r24, 0x55	; 85
    6844:	0e 94 e5 a8 	call	0x151ca	; 0x151ca <_ZN10W5100Class9writeTMSREh>
  writeRMSR(0x55);
    6848:	85 e5       	ldi	r24, 0x55	; 85
    684a:	0e 94 d6 a8 	call	0x151ac	; 0x151ac <_ZN10W5100Class9writeRMSREh>

  for (int i=0; i<MAX_SOCK_NUM; i++) {
    684e:	1a 82       	std	Y+2, r1	; 0x02
    6850:	19 82       	std	Y+1, r1	; 0x01
    6852:	2e c0       	rjmp	.+92     	; 0x68b0 <_ZN10W5100Class4initEv+0x98>
    SBASE[i] = TXBUF_BASE + SSIZE * i;
    6854:	89 81       	ldd	r24, Y+1	; 0x01
    6856:	9a 81       	ldd	r25, Y+2	; 0x02
    6858:	08 96       	adiw	r24, 0x08	; 8
    685a:	9c 01       	movw	r18, r24
    685c:	32 2f       	mov	r19, r18
    685e:	22 27       	eor	r18, r18
    6860:	33 0f       	add	r19, r19
    6862:	33 0f       	add	r19, r19
    6864:	33 0f       	add	r19, r19
    6866:	4b 81       	ldd	r20, Y+3	; 0x03
    6868:	5c 81       	ldd	r21, Y+4	; 0x04
    686a:	89 81       	ldd	r24, Y+1	; 0x01
    686c:	9a 81       	ldd	r25, Y+2	; 0x02
    686e:	88 0f       	add	r24, r24
    6870:	99 1f       	adc	r25, r25
    6872:	84 0f       	add	r24, r20
    6874:	95 1f       	adc	r25, r21
    6876:	fc 01       	movw	r30, r24
    6878:	31 83       	std	Z+1, r19	; 0x01
    687a:	20 83       	st	Z, r18
    RBASE[i] = RXBUF_BASE + RSIZE * i;
    687c:	89 81       	ldd	r24, Y+1	; 0x01
    687e:	9a 81       	ldd	r25, Y+2	; 0x02
    6880:	0c 96       	adiw	r24, 0x0c	; 12
    6882:	9c 01       	movw	r18, r24
    6884:	32 2f       	mov	r19, r18
    6886:	22 27       	eor	r18, r18
    6888:	33 0f       	add	r19, r19
    688a:	33 0f       	add	r19, r19
    688c:	33 0f       	add	r19, r19
    688e:	4b 81       	ldd	r20, Y+3	; 0x03
    6890:	5c 81       	ldd	r21, Y+4	; 0x04
    6892:	89 81       	ldd	r24, Y+1	; 0x01
    6894:	9a 81       	ldd	r25, Y+2	; 0x02
    6896:	04 96       	adiw	r24, 0x04	; 4
    6898:	88 0f       	add	r24, r24
    689a:	99 1f       	adc	r25, r25
    689c:	84 0f       	add	r24, r20
    689e:	95 1f       	adc	r25, r21
    68a0:	fc 01       	movw	r30, r24
    68a2:	31 83       	std	Z+1, r19	; 0x01
    68a4:	20 83       	st	Z, r18
  
  writeMR(1<<RST);
  writeTMSR(0x55);
  writeRMSR(0x55);

  for (int i=0; i<MAX_SOCK_NUM; i++) {
    68a6:	89 81       	ldd	r24, Y+1	; 0x01
    68a8:	9a 81       	ldd	r25, Y+2	; 0x02
    68aa:	01 96       	adiw	r24, 0x01	; 1
    68ac:	9a 83       	std	Y+2, r25	; 0x02
    68ae:	89 83       	std	Y+1, r24	; 0x01
    68b0:	21 e0       	ldi	r18, 0x01	; 1
    68b2:	89 81       	ldd	r24, Y+1	; 0x01
    68b4:	9a 81       	ldd	r25, Y+2	; 0x02
    68b6:	84 30       	cpi	r24, 0x04	; 4
    68b8:	91 05       	cpc	r25, r1
    68ba:	0c f0       	brlt	.+2      	; 0x68be <_ZN10W5100Class4initEv+0xa6>
    68bc:	20 e0       	ldi	r18, 0x00	; 0
    68be:	22 23       	and	r18, r18
    68c0:	49 f6       	brne	.-110    	; 0x6854 <_ZN10W5100Class4initEv+0x3c>
    SBASE[i] = TXBUF_BASE + SSIZE * i;
    RBASE[i] = RXBUF_BASE + RSIZE * i;
  }
}
    68c2:	0f 90       	pop	r0
    68c4:	0f 90       	pop	r0
    68c6:	0f 90       	pop	r0
    68c8:	0f 90       	pop	r0
    68ca:	df 91       	pop	r29
    68cc:	cf 91       	pop	r28
    68ce:	08 95       	ret

000068d0 <_ZN10W5100Class13getTXFreeSizeEh>:

uint16_t W5100Class::getTXFreeSize(SOCKET s)
{
    68d0:	cf 93       	push	r28
    68d2:	df 93       	push	r29
    68d4:	cd b7       	in	r28, 0x3d	; 61
    68d6:	de b7       	in	r29, 0x3e	; 62
    68d8:	27 97       	sbiw	r28, 0x07	; 7
    68da:	0f b6       	in	r0, 0x3f	; 63
    68dc:	f8 94       	cli
    68de:	de bf       	out	0x3e, r29	; 62
    68e0:	0f be       	out	0x3f, r0	; 63
    68e2:	cd bf       	out	0x3d, r28	; 61
    68e4:	9e 83       	std	Y+6, r25	; 0x06
    68e6:	8d 83       	std	Y+5, r24	; 0x05
    68e8:	6f 83       	std	Y+7, r22	; 0x07
  uint16_t val=0, val1=0;
    68ea:	1a 82       	std	Y+2, r1	; 0x02
    68ec:	19 82       	std	Y+1, r1	; 0x01
    68ee:	1c 82       	std	Y+4, r1	; 0x04
    68f0:	1b 82       	std	Y+3, r1	; 0x03
  do {
    val1 = readSnTX_FSR(s);
    68f2:	8f 81       	ldd	r24, Y+7	; 0x07
    68f4:	0e 94 15 a9 	call	0x1522a	; 0x1522a <_ZN10W5100Class12readSnTX_FSREh>
    68f8:	9c 83       	std	Y+4, r25	; 0x04
    68fa:	8b 83       	std	Y+3, r24	; 0x03
    if (val1 != 0)
    68fc:	8b 81       	ldd	r24, Y+3	; 0x03
    68fe:	9c 81       	ldd	r25, Y+4	; 0x04
    6900:	00 97       	sbiw	r24, 0x00	; 0
    6902:	29 f0       	breq	.+10     	; 0x690e <_ZN10W5100Class13getTXFreeSizeEh+0x3e>
      val = readSnTX_FSR(s);
    6904:	8f 81       	ldd	r24, Y+7	; 0x07
    6906:	0e 94 15 a9 	call	0x1522a	; 0x1522a <_ZN10W5100Class12readSnTX_FSREh>
    690a:	9a 83       	std	Y+2, r25	; 0x02
    690c:	89 83       	std	Y+1, r24	; 0x01
}

uint16_t W5100Class::getTXFreeSize(SOCKET s)
{
  uint16_t val=0, val1=0;
  do {
    690e:	41 e0       	ldi	r20, 0x01	; 1
    6910:	29 81       	ldd	r18, Y+1	; 0x01
    6912:	3a 81       	ldd	r19, Y+2	; 0x02
    6914:	8b 81       	ldd	r24, Y+3	; 0x03
    6916:	9c 81       	ldd	r25, Y+4	; 0x04
    6918:	28 17       	cp	r18, r24
    691a:	39 07       	cpc	r19, r25
    691c:	09 f4       	brne	.+2      	; 0x6920 <_ZN10W5100Class13getTXFreeSizeEh+0x50>
    691e:	40 e0       	ldi	r20, 0x00	; 0
    6920:	44 23       	and	r20, r20
    6922:	39 f7       	brne	.-50     	; 0x68f2 <_ZN10W5100Class13getTXFreeSizeEh+0x22>
    val1 = readSnTX_FSR(s);
    if (val1 != 0)
      val = readSnTX_FSR(s);
  } 
  while (val != val1);
  return val;
    6924:	89 81       	ldd	r24, Y+1	; 0x01
    6926:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6928:	27 96       	adiw	r28, 0x07	; 7
    692a:	0f b6       	in	r0, 0x3f	; 63
    692c:	f8 94       	cli
    692e:	de bf       	out	0x3e, r29	; 62
    6930:	0f be       	out	0x3f, r0	; 63
    6932:	cd bf       	out	0x3d, r28	; 61
    6934:	df 91       	pop	r29
    6936:	cf 91       	pop	r28
    6938:	08 95       	ret

0000693a <_ZN10W5100Class17getRXReceivedSizeEh>:

uint16_t W5100Class::getRXReceivedSize(SOCKET s)
{
    693a:	cf 93       	push	r28
    693c:	df 93       	push	r29
    693e:	cd b7       	in	r28, 0x3d	; 61
    6940:	de b7       	in	r29, 0x3e	; 62
    6942:	27 97       	sbiw	r28, 0x07	; 7
    6944:	0f b6       	in	r0, 0x3f	; 63
    6946:	f8 94       	cli
    6948:	de bf       	out	0x3e, r29	; 62
    694a:	0f be       	out	0x3f, r0	; 63
    694c:	cd bf       	out	0x3d, r28	; 61
    694e:	9e 83       	std	Y+6, r25	; 0x06
    6950:	8d 83       	std	Y+5, r24	; 0x05
    6952:	6f 83       	std	Y+7, r22	; 0x07
  uint16_t val=0,val1=0;
    6954:	1a 82       	std	Y+2, r1	; 0x02
    6956:	19 82       	std	Y+1, r1	; 0x01
    6958:	1c 82       	std	Y+4, r1	; 0x04
    695a:	1b 82       	std	Y+3, r1	; 0x03
  do {
    val1 = readSnRX_RSR(s);
    695c:	8f 81       	ldd	r24, Y+7	; 0x07
    695e:	0e 94 a3 a9 	call	0x15346	; 0x15346 <_ZN10W5100Class12readSnRX_RSREh>
    6962:	9c 83       	std	Y+4, r25	; 0x04
    6964:	8b 83       	std	Y+3, r24	; 0x03
    if (val1 != 0)
    6966:	8b 81       	ldd	r24, Y+3	; 0x03
    6968:	9c 81       	ldd	r25, Y+4	; 0x04
    696a:	00 97       	sbiw	r24, 0x00	; 0
    696c:	29 f0       	breq	.+10     	; 0x6978 <_ZN10W5100Class17getRXReceivedSizeEh+0x3e>
      val = readSnRX_RSR(s);
    696e:	8f 81       	ldd	r24, Y+7	; 0x07
    6970:	0e 94 a3 a9 	call	0x15346	; 0x15346 <_ZN10W5100Class12readSnRX_RSREh>
    6974:	9a 83       	std	Y+2, r25	; 0x02
    6976:	89 83       	std	Y+1, r24	; 0x01
}

uint16_t W5100Class::getRXReceivedSize(SOCKET s)
{
  uint16_t val=0,val1=0;
  do {
    6978:	41 e0       	ldi	r20, 0x01	; 1
    697a:	29 81       	ldd	r18, Y+1	; 0x01
    697c:	3a 81       	ldd	r19, Y+2	; 0x02
    697e:	8b 81       	ldd	r24, Y+3	; 0x03
    6980:	9c 81       	ldd	r25, Y+4	; 0x04
    6982:	28 17       	cp	r18, r24
    6984:	39 07       	cpc	r19, r25
    6986:	09 f4       	brne	.+2      	; 0x698a <_ZN10W5100Class17getRXReceivedSizeEh+0x50>
    6988:	40 e0       	ldi	r20, 0x00	; 0
    698a:	44 23       	and	r20, r20
    698c:	39 f7       	brne	.-50     	; 0x695c <_ZN10W5100Class17getRXReceivedSizeEh+0x22>
    val1 = readSnRX_RSR(s);
    if (val1 != 0)
      val = readSnRX_RSR(s);
  } 
  while (val != val1);
  return val;
    698e:	89 81       	ldd	r24, Y+1	; 0x01
    6990:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6992:	27 96       	adiw	r28, 0x07	; 7
    6994:	0f b6       	in	r0, 0x3f	; 63
    6996:	f8 94       	cli
    6998:	de bf       	out	0x3e, r29	; 62
    699a:	0f be       	out	0x3f, r0	; 63
    699c:	cd bf       	out	0x3d, r28	; 61
    699e:	df 91       	pop	r29
    69a0:	cf 91       	pop	r28
    69a2:	08 95       	ret

000069a4 <_ZN10W5100Class20send_data_processingEhPKhj>:


void W5100Class::send_data_processing(SOCKET s, const uint8_t *data, uint16_t len)
{
    69a4:	0f 93       	push	r16
    69a6:	1f 93       	push	r17
    69a8:	cf 93       	push	r28
    69aa:	df 93       	push	r29
    69ac:	cd b7       	in	r28, 0x3d	; 61
    69ae:	de b7       	in	r29, 0x3e	; 62
    69b0:	27 97       	sbiw	r28, 0x07	; 7
    69b2:	0f b6       	in	r0, 0x3f	; 63
    69b4:	f8 94       	cli
    69b6:	de bf       	out	0x3e, r29	; 62
    69b8:	0f be       	out	0x3f, r0	; 63
    69ba:	cd bf       	out	0x3d, r28	; 61
    69bc:	9a 83       	std	Y+2, r25	; 0x02
    69be:	89 83       	std	Y+1, r24	; 0x01
    69c0:	6b 83       	std	Y+3, r22	; 0x03
    69c2:	5d 83       	std	Y+5, r21	; 0x05
    69c4:	4c 83       	std	Y+4, r20	; 0x04
    69c6:	3f 83       	std	Y+7, r19	; 0x07
    69c8:	2e 83       	std	Y+6, r18	; 0x06
  // This is same as having no offset in a call to send_data_processing_offset
  send_data_processing_offset(s, 0, data, len);
    69ca:	4e 81       	ldd	r20, Y+6	; 0x06
    69cc:	5f 81       	ldd	r21, Y+7	; 0x07
    69ce:	2c 81       	ldd	r18, Y+4	; 0x04
    69d0:	3d 81       	ldd	r19, Y+5	; 0x05
    69d2:	89 81       	ldd	r24, Y+1	; 0x01
    69d4:	9a 81       	ldd	r25, Y+2	; 0x02
    69d6:	8a 01       	movw	r16, r20
    69d8:	40 e0       	ldi	r20, 0x00	; 0
    69da:	50 e0       	ldi	r21, 0x00	; 0
    69dc:	6b 81       	ldd	r22, Y+3	; 0x03
    69de:	0e 94 fc 34 	call	0x69f8	; 0x69f8 <_ZN10W5100Class27send_data_processing_offsetEhjPKhj>
}
    69e2:	27 96       	adiw	r28, 0x07	; 7
    69e4:	0f b6       	in	r0, 0x3f	; 63
    69e6:	f8 94       	cli
    69e8:	de bf       	out	0x3e, r29	; 62
    69ea:	0f be       	out	0x3f, r0	; 63
    69ec:	cd bf       	out	0x3d, r28	; 61
    69ee:	df 91       	pop	r29
    69f0:	cf 91       	pop	r28
    69f2:	1f 91       	pop	r17
    69f4:	0f 91       	pop	r16
    69f6:	08 95       	ret

000069f8 <_ZN10W5100Class27send_data_processing_offsetEhjPKhj>:

void W5100Class::send_data_processing_offset(SOCKET s, uint16_t data_offset, const uint8_t *data, uint16_t len)
{
    69f8:	0f 93       	push	r16
    69fa:	1f 93       	push	r17
    69fc:	cf 93       	push	r28
    69fe:	df 93       	push	r29
    6a00:	cd b7       	in	r28, 0x3d	; 61
    6a02:	de b7       	in	r29, 0x3e	; 62
    6a04:	61 97       	sbiw	r28, 0x11	; 17
    6a06:	0f b6       	in	r0, 0x3f	; 63
    6a08:	f8 94       	cli
    6a0a:	de bf       	out	0x3e, r29	; 62
    6a0c:	0f be       	out	0x3f, r0	; 63
    6a0e:	cd bf       	out	0x3d, r28	; 61
    6a10:	9a 87       	std	Y+10, r25	; 0x0a
    6a12:	89 87       	std	Y+9, r24	; 0x09
    6a14:	6b 87       	std	Y+11, r22	; 0x0b
    6a16:	5d 87       	std	Y+13, r21	; 0x0d
    6a18:	4c 87       	std	Y+12, r20	; 0x0c
    6a1a:	3f 87       	std	Y+15, r19	; 0x0f
    6a1c:	2e 87       	std	Y+14, r18	; 0x0e
    6a1e:	19 8b       	std	Y+17, r17	; 0x11
    6a20:	08 8b       	std	Y+16, r16	; 0x10
  uint16_t ptr = readSnTX_WR(s);
    6a22:	8b 85       	ldd	r24, Y+11	; 0x0b
    6a24:	0e 94 6c a9 	call	0x152d8	; 0x152d8 <_ZN10W5100Class11readSnTX_WREh>
    6a28:	9a 83       	std	Y+2, r25	; 0x02
    6a2a:	89 83       	std	Y+1, r24	; 0x01
  ptr += data_offset;
    6a2c:	29 81       	ldd	r18, Y+1	; 0x01
    6a2e:	3a 81       	ldd	r19, Y+2	; 0x02
    6a30:	8c 85       	ldd	r24, Y+12	; 0x0c
    6a32:	9d 85       	ldd	r25, Y+13	; 0x0d
    6a34:	82 0f       	add	r24, r18
    6a36:	93 1f       	adc	r25, r19
    6a38:	9a 83       	std	Y+2, r25	; 0x02
    6a3a:	89 83       	std	Y+1, r24	; 0x01
  uint16_t offset = ptr & SMASK;
    6a3c:	89 81       	ldd	r24, Y+1	; 0x01
    6a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    6a40:	97 70       	andi	r25, 0x07	; 7
    6a42:	9c 83       	std	Y+4, r25	; 0x04
    6a44:	8b 83       	std	Y+3, r24	; 0x03
  uint16_t dstAddr = offset + SBASE[s];
    6a46:	8b 85       	ldd	r24, Y+11	; 0x0b
    6a48:	88 2f       	mov	r24, r24
    6a4a:	90 e0       	ldi	r25, 0x00	; 0
    6a4c:	29 85       	ldd	r18, Y+9	; 0x09
    6a4e:	3a 85       	ldd	r19, Y+10	; 0x0a
    6a50:	88 0f       	add	r24, r24
    6a52:	99 1f       	adc	r25, r25
    6a54:	82 0f       	add	r24, r18
    6a56:	93 1f       	adc	r25, r19
    6a58:	fc 01       	movw	r30, r24
    6a5a:	20 81       	ld	r18, Z
    6a5c:	31 81       	ldd	r19, Z+1	; 0x01
    6a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a60:	9c 81       	ldd	r25, Y+4	; 0x04
    6a62:	82 0f       	add	r24, r18
    6a64:	93 1f       	adc	r25, r19
    6a66:	9e 83       	std	Y+6, r25	; 0x06
    6a68:	8d 83       	std	Y+5, r24	; 0x05

  if (offset + len > SSIZE) 
    6a6a:	2b 81       	ldd	r18, Y+3	; 0x03
    6a6c:	3c 81       	ldd	r19, Y+4	; 0x04
    6a6e:	88 89       	ldd	r24, Y+16	; 0x10
    6a70:	99 89       	ldd	r25, Y+17	; 0x11
    6a72:	82 0f       	add	r24, r18
    6a74:	93 1f       	adc	r25, r19
    6a76:	81 30       	cpi	r24, 0x01	; 1
    6a78:	f8 e0       	ldi	r31, 0x08	; 8
    6a7a:	9f 07       	cpc	r25, r31
    6a7c:	80 f1       	brcs	.+96     	; 0x6ade <_ZN10W5100Class27send_data_processing_offsetEhjPKhj+0xe6>
  {
    // Wrap around circular buffer
    uint16_t size = SSIZE - offset;
    6a7e:	20 e0       	ldi	r18, 0x00	; 0
    6a80:	38 e0       	ldi	r19, 0x08	; 8
    6a82:	8b 81       	ldd	r24, Y+3	; 0x03
    6a84:	9c 81       	ldd	r25, Y+4	; 0x04
    6a86:	a9 01       	movw	r20, r18
    6a88:	48 1b       	sub	r20, r24
    6a8a:	59 0b       	sbc	r21, r25
    6a8c:	ca 01       	movw	r24, r20
    6a8e:	98 87       	std	Y+8, r25	; 0x08
    6a90:	8f 83       	std	Y+7, r24	; 0x07
    write(dstAddr, data, size);
    6a92:	4f 81       	ldd	r20, Y+7	; 0x07
    6a94:	58 85       	ldd	r21, Y+8	; 0x08
    6a96:	2e 85       	ldd	r18, Y+14	; 0x0e
    6a98:	3f 85       	ldd	r19, Y+15	; 0x0f
    6a9a:	8d 81       	ldd	r24, Y+5	; 0x05
    6a9c:	9e 81       	ldd	r25, Y+6	; 0x06
    6a9e:	b9 01       	movw	r22, r18
    6aa0:	0e 94 75 36 	call	0x6cea	; 0x6cea <_ZN10W5100Class5writeEjPKhj>
    write(SBASE[s], data + size, len - size);
    6aa4:	28 89       	ldd	r18, Y+16	; 0x10
    6aa6:	39 89       	ldd	r19, Y+17	; 0x11
    6aa8:	8f 81       	ldd	r24, Y+7	; 0x07
    6aaa:	98 85       	ldd	r25, Y+8	; 0x08
    6aac:	a9 01       	movw	r20, r18
    6aae:	48 1b       	sub	r20, r24
    6ab0:	59 0b       	sbc	r21, r25
    6ab2:	2e 85       	ldd	r18, Y+14	; 0x0e
    6ab4:	3f 85       	ldd	r19, Y+15	; 0x0f
    6ab6:	8f 81       	ldd	r24, Y+7	; 0x07
    6ab8:	98 85       	ldd	r25, Y+8	; 0x08
    6aba:	28 0f       	add	r18, r24
    6abc:	39 1f       	adc	r19, r25
    6abe:	8b 85       	ldd	r24, Y+11	; 0x0b
    6ac0:	88 2f       	mov	r24, r24
    6ac2:	90 e0       	ldi	r25, 0x00	; 0
    6ac4:	69 85       	ldd	r22, Y+9	; 0x09
    6ac6:	7a 85       	ldd	r23, Y+10	; 0x0a
    6ac8:	88 0f       	add	r24, r24
    6aca:	99 1f       	adc	r25, r25
    6acc:	86 0f       	add	r24, r22
    6ace:	97 1f       	adc	r25, r23
    6ad0:	fc 01       	movw	r30, r24
    6ad2:	80 81       	ld	r24, Z
    6ad4:	91 81       	ldd	r25, Z+1	; 0x01
    6ad6:	b9 01       	movw	r22, r18
    6ad8:	0e 94 75 36 	call	0x6cea	; 0x6cea <_ZN10W5100Class5writeEjPKhj>
    6adc:	09 c0       	rjmp	.+18     	; 0x6af0 <_ZN10W5100Class27send_data_processing_offsetEhjPKhj+0xf8>
  } 
  else {
    write(dstAddr, data, len);
    6ade:	48 89       	ldd	r20, Y+16	; 0x10
    6ae0:	59 89       	ldd	r21, Y+17	; 0x11
    6ae2:	2e 85       	ldd	r18, Y+14	; 0x0e
    6ae4:	3f 85       	ldd	r19, Y+15	; 0x0f
    6ae6:	8d 81       	ldd	r24, Y+5	; 0x05
    6ae8:	9e 81       	ldd	r25, Y+6	; 0x06
    6aea:	b9 01       	movw	r22, r18
    6aec:	0e 94 75 36 	call	0x6cea	; 0x6cea <_ZN10W5100Class5writeEjPKhj>
  }

  ptr += len;
    6af0:	29 81       	ldd	r18, Y+1	; 0x01
    6af2:	3a 81       	ldd	r19, Y+2	; 0x02
    6af4:	88 89       	ldd	r24, Y+16	; 0x10
    6af6:	99 89       	ldd	r25, Y+17	; 0x11
    6af8:	82 0f       	add	r24, r18
    6afa:	93 1f       	adc	r25, r19
    6afc:	9a 83       	std	Y+2, r25	; 0x02
    6afe:	89 83       	std	Y+1, r24	; 0x01
  writeSnTX_WR(s, ptr);
    6b00:	89 81       	ldd	r24, Y+1	; 0x01
    6b02:	9a 81       	ldd	r25, Y+2	; 0x02
    6b04:	bc 01       	movw	r22, r24
    6b06:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b08:	0e 94 4c a9 	call	0x15298	; 0x15298 <_ZN10W5100Class12writeSnTX_WREhj>
}
    6b0c:	61 96       	adiw	r28, 0x11	; 17
    6b0e:	0f b6       	in	r0, 0x3f	; 63
    6b10:	f8 94       	cli
    6b12:	de bf       	out	0x3e, r29	; 62
    6b14:	0f be       	out	0x3f, r0	; 63
    6b16:	cd bf       	out	0x3d, r28	; 61
    6b18:	df 91       	pop	r29
    6b1a:	cf 91       	pop	r28
    6b1c:	1f 91       	pop	r17
    6b1e:	0f 91       	pop	r16
    6b20:	08 95       	ret

00006b22 <_ZN10W5100Class20recv_data_processingEhPhjh>:


void W5100Class::recv_data_processing(SOCKET s, uint8_t *data, uint16_t len, uint8_t peek)
{
    6b22:	0f 93       	push	r16
    6b24:	1f 93       	push	r17
    6b26:	cf 93       	push	r28
    6b28:	df 93       	push	r29
    6b2a:	cd b7       	in	r28, 0x3d	; 61
    6b2c:	de b7       	in	r29, 0x3e	; 62
    6b2e:	2a 97       	sbiw	r28, 0x0a	; 10
    6b30:	0f b6       	in	r0, 0x3f	; 63
    6b32:	f8 94       	cli
    6b34:	de bf       	out	0x3e, r29	; 62
    6b36:	0f be       	out	0x3f, r0	; 63
    6b38:	cd bf       	out	0x3d, r28	; 61
    6b3a:	9c 83       	std	Y+4, r25	; 0x04
    6b3c:	8b 83       	std	Y+3, r24	; 0x03
    6b3e:	6d 83       	std	Y+5, r22	; 0x05
    6b40:	5f 83       	std	Y+7, r21	; 0x07
    6b42:	4e 83       	std	Y+6, r20	; 0x06
    6b44:	39 87       	std	Y+9, r19	; 0x09
    6b46:	28 87       	std	Y+8, r18	; 0x08
    6b48:	0a 87       	std	Y+10, r16	; 0x0a
  uint16_t ptr;
  ptr = readSnRX_RD(s);
    6b4a:	8d 81       	ldd	r24, Y+5	; 0x05
    6b4c:	0e 94 0e a8 	call	0x1501c	; 0x1501c <_ZN10W5100Class11readSnRX_RDEh>
    6b50:	9a 83       	std	Y+2, r25	; 0x02
    6b52:	89 83       	std	Y+1, r24	; 0x01
  read_data(s, (uint8_t *)ptr, data, len);
    6b54:	49 81       	ldd	r20, Y+1	; 0x01
    6b56:	5a 81       	ldd	r21, Y+2	; 0x02
    6b58:	68 85       	ldd	r22, Y+8	; 0x08
    6b5a:	79 85       	ldd	r23, Y+9	; 0x09
    6b5c:	2e 81       	ldd	r18, Y+6	; 0x06
    6b5e:	3f 81       	ldd	r19, Y+7	; 0x07
    6b60:	8b 81       	ldd	r24, Y+3	; 0x03
    6b62:	9c 81       	ldd	r25, Y+4	; 0x04
    6b64:	8b 01       	movw	r16, r22
    6b66:	6d 81       	ldd	r22, Y+5	; 0x05
    6b68:	0e 94 d2 35 	call	0x6ba4	; 0x6ba4 <_ZN10W5100Class9read_dataEhPVhS1_j>
  if (!peek)
    6b6c:	8a 85       	ldd	r24, Y+10	; 0x0a
    6b6e:	88 23       	and	r24, r24
    6b70:	71 f4       	brne	.+28     	; 0x6b8e <_ZN10W5100Class20recv_data_processingEhPhjh+0x6c>
  {
    ptr += len;
    6b72:	29 81       	ldd	r18, Y+1	; 0x01
    6b74:	3a 81       	ldd	r19, Y+2	; 0x02
    6b76:	88 85       	ldd	r24, Y+8	; 0x08
    6b78:	99 85       	ldd	r25, Y+9	; 0x09
    6b7a:	82 0f       	add	r24, r18
    6b7c:	93 1f       	adc	r25, r19
    6b7e:	9a 83       	std	Y+2, r25	; 0x02
    6b80:	89 83       	std	Y+1, r24	; 0x01
    writeSnRX_RD(s, ptr);
    6b82:	89 81       	ldd	r24, Y+1	; 0x01
    6b84:	9a 81       	ldd	r25, Y+2	; 0x02
    6b86:	bc 01       	movw	r22, r24
    6b88:	8d 81       	ldd	r24, Y+5	; 0x05
    6b8a:	0e 94 ee a7 	call	0x14fdc	; 0x14fdc <_ZN10W5100Class12writeSnRX_RDEhj>
  }
}
    6b8e:	2a 96       	adiw	r28, 0x0a	; 10
    6b90:	0f b6       	in	r0, 0x3f	; 63
    6b92:	f8 94       	cli
    6b94:	de bf       	out	0x3e, r29	; 62
    6b96:	0f be       	out	0x3f, r0	; 63
    6b98:	cd bf       	out	0x3d, r28	; 61
    6b9a:	df 91       	pop	r29
    6b9c:	cf 91       	pop	r28
    6b9e:	1f 91       	pop	r17
    6ba0:	0f 91       	pop	r16
    6ba2:	08 95       	ret

00006ba4 <_ZN10W5100Class9read_dataEhPVhS1_j>:

void W5100Class::read_data(SOCKET s, volatile uint8_t *src, volatile uint8_t *dst, uint16_t len)
{
    6ba4:	0f 93       	push	r16
    6ba6:	1f 93       	push	r17
    6ba8:	cf 93       	push	r28
    6baa:	df 93       	push	r29
    6bac:	cd b7       	in	r28, 0x3d	; 61
    6bae:	de b7       	in	r29, 0x3e	; 62
    6bb0:	2f 97       	sbiw	r28, 0x0f	; 15
    6bb2:	0f b6       	in	r0, 0x3f	; 63
    6bb4:	f8 94       	cli
    6bb6:	de bf       	out	0x3e, r29	; 62
    6bb8:	0f be       	out	0x3f, r0	; 63
    6bba:	cd bf       	out	0x3d, r28	; 61
    6bbc:	98 87       	std	Y+8, r25	; 0x08
    6bbe:	8f 83       	std	Y+7, r24	; 0x07
    6bc0:	69 87       	std	Y+9, r22	; 0x09
    6bc2:	5b 87       	std	Y+11, r21	; 0x0b
    6bc4:	4a 87       	std	Y+10, r20	; 0x0a
    6bc6:	3d 87       	std	Y+13, r19	; 0x0d
    6bc8:	2c 87       	std	Y+12, r18	; 0x0c
    6bca:	1f 87       	std	Y+15, r17	; 0x0f
    6bcc:	0e 87       	std	Y+14, r16	; 0x0e
  uint16_t size;
  uint16_t src_mask;
  uint16_t src_ptr;

  src_mask = (uint16_t)src & RMASK;
    6bce:	8a 85       	ldd	r24, Y+10	; 0x0a
    6bd0:	9b 85       	ldd	r25, Y+11	; 0x0b
    6bd2:	97 70       	andi	r25, 0x07	; 7
    6bd4:	9a 83       	std	Y+2, r25	; 0x02
    6bd6:	89 83       	std	Y+1, r24	; 0x01
  src_ptr = RBASE[s] + src_mask;
    6bd8:	89 85       	ldd	r24, Y+9	; 0x09
    6bda:	88 2f       	mov	r24, r24
    6bdc:	90 e0       	ldi	r25, 0x00	; 0
    6bde:	2f 81       	ldd	r18, Y+7	; 0x07
    6be0:	38 85       	ldd	r19, Y+8	; 0x08
    6be2:	04 96       	adiw	r24, 0x04	; 4
    6be4:	88 0f       	add	r24, r24
    6be6:	99 1f       	adc	r25, r25
    6be8:	82 0f       	add	r24, r18
    6bea:	93 1f       	adc	r25, r19
    6bec:	fc 01       	movw	r30, r24
    6bee:	20 81       	ld	r18, Z
    6bf0:	31 81       	ldd	r19, Z+1	; 0x01
    6bf2:	89 81       	ldd	r24, Y+1	; 0x01
    6bf4:	9a 81       	ldd	r25, Y+2	; 0x02
    6bf6:	82 0f       	add	r24, r18
    6bf8:	93 1f       	adc	r25, r19
    6bfa:	9c 83       	std	Y+4, r25	; 0x04
    6bfc:	8b 83       	std	Y+3, r24	; 0x03

  if( (src_mask + len) > RSIZE ) 
    6bfe:	29 81       	ldd	r18, Y+1	; 0x01
    6c00:	3a 81       	ldd	r19, Y+2	; 0x02
    6c02:	8e 85       	ldd	r24, Y+14	; 0x0e
    6c04:	9f 85       	ldd	r25, Y+15	; 0x0f
    6c06:	82 0f       	add	r24, r18
    6c08:	93 1f       	adc	r25, r19
    6c0a:	81 30       	cpi	r24, 0x01	; 1
    6c0c:	f8 e0       	ldi	r31, 0x08	; 8
    6c0e:	9f 07       	cpc	r25, r31
    6c10:	a8 f1       	brcs	.+106    	; 0x6c7c <_ZN10W5100Class9read_dataEhPVhS1_j+0xd8>
  {
    size = RSIZE - src_mask;
    6c12:	20 e0       	ldi	r18, 0x00	; 0
    6c14:	38 e0       	ldi	r19, 0x08	; 8
    6c16:	89 81       	ldd	r24, Y+1	; 0x01
    6c18:	9a 81       	ldd	r25, Y+2	; 0x02
    6c1a:	a9 01       	movw	r20, r18
    6c1c:	48 1b       	sub	r20, r24
    6c1e:	59 0b       	sbc	r21, r25
    6c20:	ca 01       	movw	r24, r20
    6c22:	9e 83       	std	Y+6, r25	; 0x06
    6c24:	8d 83       	std	Y+5, r24	; 0x05
    read(src_ptr, (uint8_t *)dst, size);
    6c26:	4d 81       	ldd	r20, Y+5	; 0x05
    6c28:	5e 81       	ldd	r21, Y+6	; 0x06
    6c2a:	2c 85       	ldd	r18, Y+12	; 0x0c
    6c2c:	3d 85       	ldd	r19, Y+13	; 0x0d
    6c2e:	8b 81       	ldd	r24, Y+3	; 0x03
    6c30:	9c 81       	ldd	r25, Y+4	; 0x04
    6c32:	b9 01       	movw	r22, r18
    6c34:	0e 94 e5 36 	call	0x6dca	; 0x6dca <_ZN10W5100Class4readEjPhj>
    dst += size;
    6c38:	2c 85       	ldd	r18, Y+12	; 0x0c
    6c3a:	3d 85       	ldd	r19, Y+13	; 0x0d
    6c3c:	8d 81       	ldd	r24, Y+5	; 0x05
    6c3e:	9e 81       	ldd	r25, Y+6	; 0x06
    6c40:	82 0f       	add	r24, r18
    6c42:	93 1f       	adc	r25, r19
    6c44:	9d 87       	std	Y+13, r25	; 0x0d
    6c46:	8c 87       	std	Y+12, r24	; 0x0c
    read(RBASE[s], (uint8_t *) dst, len - size);
    6c48:	2e 85       	ldd	r18, Y+14	; 0x0e
    6c4a:	3f 85       	ldd	r19, Y+15	; 0x0f
    6c4c:	8d 81       	ldd	r24, Y+5	; 0x05
    6c4e:	9e 81       	ldd	r25, Y+6	; 0x06
    6c50:	a9 01       	movw	r20, r18
    6c52:	48 1b       	sub	r20, r24
    6c54:	59 0b       	sbc	r21, r25
    6c56:	89 85       	ldd	r24, Y+9	; 0x09
    6c58:	88 2f       	mov	r24, r24
    6c5a:	90 e0       	ldi	r25, 0x00	; 0
    6c5c:	2f 81       	ldd	r18, Y+7	; 0x07
    6c5e:	38 85       	ldd	r19, Y+8	; 0x08
    6c60:	04 96       	adiw	r24, 0x04	; 4
    6c62:	88 0f       	add	r24, r24
    6c64:	99 1f       	adc	r25, r25
    6c66:	82 0f       	add	r24, r18
    6c68:	93 1f       	adc	r25, r19
    6c6a:	fc 01       	movw	r30, r24
    6c6c:	80 81       	ld	r24, Z
    6c6e:	91 81       	ldd	r25, Z+1	; 0x01
    6c70:	2c 85       	ldd	r18, Y+12	; 0x0c
    6c72:	3d 85       	ldd	r19, Y+13	; 0x0d
    6c74:	b9 01       	movw	r22, r18
    6c76:	0e 94 e5 36 	call	0x6dca	; 0x6dca <_ZN10W5100Class4readEjPhj>
    6c7a:	09 c0       	rjmp	.+18     	; 0x6c8e <_ZN10W5100Class9read_dataEhPVhS1_j+0xea>
  } 
  else
    read(src_ptr, (uint8_t *) dst, len);
    6c7c:	4e 85       	ldd	r20, Y+14	; 0x0e
    6c7e:	5f 85       	ldd	r21, Y+15	; 0x0f
    6c80:	2c 85       	ldd	r18, Y+12	; 0x0c
    6c82:	3d 85       	ldd	r19, Y+13	; 0x0d
    6c84:	8b 81       	ldd	r24, Y+3	; 0x03
    6c86:	9c 81       	ldd	r25, Y+4	; 0x04
    6c88:	b9 01       	movw	r22, r18
    6c8a:	0e 94 e5 36 	call	0x6dca	; 0x6dca <_ZN10W5100Class4readEjPhj>
}
    6c8e:	2f 96       	adiw	r28, 0x0f	; 15
    6c90:	0f b6       	in	r0, 0x3f	; 63
    6c92:	f8 94       	cli
    6c94:	de bf       	out	0x3e, r29	; 62
    6c96:	0f be       	out	0x3f, r0	; 63
    6c98:	cd bf       	out	0x3d, r28	; 61
    6c9a:	df 91       	pop	r29
    6c9c:	cf 91       	pop	r28
    6c9e:	1f 91       	pop	r17
    6ca0:	0f 91       	pop	r16
    6ca2:	08 95       	ret

00006ca4 <_ZN10W5100Class5writeEjh>:


uint8_t W5100Class::write(uint16_t _addr, uint8_t _data)
{
    6ca4:	cf 93       	push	r28
    6ca6:	df 93       	push	r29
    6ca8:	00 d0       	rcall	.+0      	; 0x6caa <_ZN10W5100Class5writeEjh+0x6>
    6caa:	1f 92       	push	r1
    6cac:	cd b7       	in	r28, 0x3d	; 61
    6cae:	de b7       	in	r29, 0x3e	; 62
    6cb0:	9a 83       	std	Y+2, r25	; 0x02
    6cb2:	89 83       	std	Y+1, r24	; 0x01
    6cb4:	6b 83       	std	Y+3, r22	; 0x03
  setSS();  
    6cb6:	0e 94 ea a9 	call	0x153d4	; 0x153d4 <_ZN10W5100Class5setSSEv>
  SPI.transfer(0xF0);
    6cba:	80 ef       	ldi	r24, 0xF0	; 240
    6cbc:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
  SPI.transfer(_addr >> 8);
    6cc0:	89 81       	ldd	r24, Y+1	; 0x01
    6cc2:	9a 81       	ldd	r25, Y+2	; 0x02
    6cc4:	89 2f       	mov	r24, r25
    6cc6:	99 27       	eor	r25, r25
    6cc8:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
  SPI.transfer(_addr & 0xFF);
    6ccc:	89 81       	ldd	r24, Y+1	; 0x01
    6cce:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
  SPI.transfer(_data);
    6cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    6cd4:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
  resetSS();
    6cd8:	0e 94 fa a9 	call	0x153f4	; 0x153f4 <_ZN10W5100Class7resetSSEv>
  return 1;
    6cdc:	81 e0       	ldi	r24, 0x01	; 1
}
    6cde:	0f 90       	pop	r0
    6ce0:	0f 90       	pop	r0
    6ce2:	0f 90       	pop	r0
    6ce4:	df 91       	pop	r29
    6ce6:	cf 91       	pop	r28
    6ce8:	08 95       	ret

00006cea <_ZN10W5100Class5writeEjPKhj>:

uint16_t W5100Class::write(uint16_t _addr, const uint8_t *_buf, uint16_t _len)
{
    6cea:	cf 93       	push	r28
    6cec:	df 93       	push	r29
    6cee:	cd b7       	in	r28, 0x3d	; 61
    6cf0:	de b7       	in	r29, 0x3e	; 62
    6cf2:	28 97       	sbiw	r28, 0x08	; 8
    6cf4:	0f b6       	in	r0, 0x3f	; 63
    6cf6:	f8 94       	cli
    6cf8:	de bf       	out	0x3e, r29	; 62
    6cfa:	0f be       	out	0x3f, r0	; 63
    6cfc:	cd bf       	out	0x3d, r28	; 61
    6cfe:	9c 83       	std	Y+4, r25	; 0x04
    6d00:	8b 83       	std	Y+3, r24	; 0x03
    6d02:	7e 83       	std	Y+6, r23	; 0x06
    6d04:	6d 83       	std	Y+5, r22	; 0x05
    6d06:	58 87       	std	Y+8, r21	; 0x08
    6d08:	4f 83       	std	Y+7, r20	; 0x07
  for (uint16_t i=0; i<_len; i++)
    6d0a:	1a 82       	std	Y+2, r1	; 0x02
    6d0c:	19 82       	std	Y+1, r1	; 0x01
    6d0e:	24 c0       	rjmp	.+72     	; 0x6d58 <_ZN10W5100Class5writeEjPKhj+0x6e>
  {
    setSS();    
    6d10:	0e 94 ea a9 	call	0x153d4	; 0x153d4 <_ZN10W5100Class5setSSEv>
    SPI.transfer(0xF0);
    6d14:	80 ef       	ldi	r24, 0xF0	; 240
    6d16:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
    SPI.transfer(_addr >> 8);
    6d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    6d1c:	9c 81       	ldd	r25, Y+4	; 0x04
    6d1e:	89 2f       	mov	r24, r25
    6d20:	99 27       	eor	r25, r25
    6d22:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
    SPI.transfer(_addr & 0xFF);
    6d26:	8b 81       	ldd	r24, Y+3	; 0x03
    6d28:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
    _addr++;
    6d2c:	8b 81       	ldd	r24, Y+3	; 0x03
    6d2e:	9c 81       	ldd	r25, Y+4	; 0x04
    6d30:	01 96       	adiw	r24, 0x01	; 1
    6d32:	9c 83       	std	Y+4, r25	; 0x04
    6d34:	8b 83       	std	Y+3, r24	; 0x03
    SPI.transfer(_buf[i]);
    6d36:	2d 81       	ldd	r18, Y+5	; 0x05
    6d38:	3e 81       	ldd	r19, Y+6	; 0x06
    6d3a:	89 81       	ldd	r24, Y+1	; 0x01
    6d3c:	9a 81       	ldd	r25, Y+2	; 0x02
    6d3e:	82 0f       	add	r24, r18
    6d40:	93 1f       	adc	r25, r19
    6d42:	fc 01       	movw	r30, r24
    6d44:	80 81       	ld	r24, Z
    6d46:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
    resetSS();
    6d4a:	0e 94 fa a9 	call	0x153f4	; 0x153f4 <_ZN10W5100Class7resetSSEv>
  return 1;
}

uint16_t W5100Class::write(uint16_t _addr, const uint8_t *_buf, uint16_t _len)
{
  for (uint16_t i=0; i<_len; i++)
    6d4e:	89 81       	ldd	r24, Y+1	; 0x01
    6d50:	9a 81       	ldd	r25, Y+2	; 0x02
    6d52:	01 96       	adiw	r24, 0x01	; 1
    6d54:	9a 83       	std	Y+2, r25	; 0x02
    6d56:	89 83       	std	Y+1, r24	; 0x01
    6d58:	41 e0       	ldi	r20, 0x01	; 1
    6d5a:	29 81       	ldd	r18, Y+1	; 0x01
    6d5c:	3a 81       	ldd	r19, Y+2	; 0x02
    6d5e:	8f 81       	ldd	r24, Y+7	; 0x07
    6d60:	98 85       	ldd	r25, Y+8	; 0x08
    6d62:	28 17       	cp	r18, r24
    6d64:	39 07       	cpc	r19, r25
    6d66:	08 f0       	brcs	.+2      	; 0x6d6a <_ZN10W5100Class5writeEjPKhj+0x80>
    6d68:	40 e0       	ldi	r20, 0x00	; 0
    6d6a:	44 23       	and	r20, r20
    6d6c:	89 f6       	brne	.-94     	; 0x6d10 <_ZN10W5100Class5writeEjPKhj+0x26>
    SPI.transfer(_addr & 0xFF);
    _addr++;
    SPI.transfer(_buf[i]);
    resetSS();
  }
  return _len;
    6d6e:	8f 81       	ldd	r24, Y+7	; 0x07
    6d70:	98 85       	ldd	r25, Y+8	; 0x08
}
    6d72:	28 96       	adiw	r28, 0x08	; 8
    6d74:	0f b6       	in	r0, 0x3f	; 63
    6d76:	f8 94       	cli
    6d78:	de bf       	out	0x3e, r29	; 62
    6d7a:	0f be       	out	0x3f, r0	; 63
    6d7c:	cd bf       	out	0x3d, r28	; 61
    6d7e:	df 91       	pop	r29
    6d80:	cf 91       	pop	r28
    6d82:	08 95       	ret

00006d84 <_ZN10W5100Class4readEj>:

uint8_t W5100Class::read(uint16_t _addr)
{
    6d84:	cf 93       	push	r28
    6d86:	df 93       	push	r29
    6d88:	00 d0       	rcall	.+0      	; 0x6d8a <_ZN10W5100Class4readEj+0x6>
    6d8a:	1f 92       	push	r1
    6d8c:	cd b7       	in	r28, 0x3d	; 61
    6d8e:	de b7       	in	r29, 0x3e	; 62
    6d90:	9b 83       	std	Y+3, r25	; 0x03
    6d92:	8a 83       	std	Y+2, r24	; 0x02
  setSS();  
    6d94:	0e 94 ea a9 	call	0x153d4	; 0x153d4 <_ZN10W5100Class5setSSEv>
  SPI.transfer(0x0F);
    6d98:	8f e0       	ldi	r24, 0x0F	; 15
    6d9a:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
  SPI.transfer(_addr >> 8);
    6d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    6da0:	9b 81       	ldd	r25, Y+3	; 0x03
    6da2:	89 2f       	mov	r24, r25
    6da4:	99 27       	eor	r25, r25
    6da6:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
  SPI.transfer(_addr & 0xFF);
    6daa:	8a 81       	ldd	r24, Y+2	; 0x02
    6dac:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
  uint8_t _data = SPI.transfer(0);
    6db0:	80 e0       	ldi	r24, 0x00	; 0
    6db2:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
    6db6:	89 83       	std	Y+1, r24	; 0x01
  resetSS();
    6db8:	0e 94 fa a9 	call	0x153f4	; 0x153f4 <_ZN10W5100Class7resetSSEv>
  return _data;
    6dbc:	89 81       	ldd	r24, Y+1	; 0x01
}
    6dbe:	0f 90       	pop	r0
    6dc0:	0f 90       	pop	r0
    6dc2:	0f 90       	pop	r0
    6dc4:	df 91       	pop	r29
    6dc6:	cf 91       	pop	r28
    6dc8:	08 95       	ret

00006dca <_ZN10W5100Class4readEjPhj>:

uint16_t W5100Class::read(uint16_t _addr, uint8_t *_buf, uint16_t _len)
{
    6dca:	0f 93       	push	r16
    6dcc:	1f 93       	push	r17
    6dce:	cf 93       	push	r28
    6dd0:	df 93       	push	r29
    6dd2:	cd b7       	in	r28, 0x3d	; 61
    6dd4:	de b7       	in	r29, 0x3e	; 62
    6dd6:	28 97       	sbiw	r28, 0x08	; 8
    6dd8:	0f b6       	in	r0, 0x3f	; 63
    6dda:	f8 94       	cli
    6ddc:	de bf       	out	0x3e, r29	; 62
    6dde:	0f be       	out	0x3f, r0	; 63
    6de0:	cd bf       	out	0x3d, r28	; 61
    6de2:	9c 83       	std	Y+4, r25	; 0x04
    6de4:	8b 83       	std	Y+3, r24	; 0x03
    6de6:	7e 83       	std	Y+6, r23	; 0x06
    6de8:	6d 83       	std	Y+5, r22	; 0x05
    6dea:	58 87       	std	Y+8, r21	; 0x08
    6dec:	4f 83       	std	Y+7, r20	; 0x07
  for (uint16_t i=0; i<_len; i++)
    6dee:	1a 82       	std	Y+2, r1	; 0x02
    6df0:	19 82       	std	Y+1, r1	; 0x01
    6df2:	26 c0       	rjmp	.+76     	; 0x6e40 <_ZN10W5100Class4readEjPhj+0x76>
  {
    setSS();
    6df4:	0e 94 ea a9 	call	0x153d4	; 0x153d4 <_ZN10W5100Class5setSSEv>
    SPI.transfer(0x0F);
    6df8:	8f e0       	ldi	r24, 0x0F	; 15
    6dfa:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
    SPI.transfer(_addr >> 8);
    6dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    6e00:	9c 81       	ldd	r25, Y+4	; 0x04
    6e02:	89 2f       	mov	r24, r25
    6e04:	99 27       	eor	r25, r25
    6e06:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
    SPI.transfer(_addr & 0xFF);
    6e0a:	8b 81       	ldd	r24, Y+3	; 0x03
    6e0c:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
    _addr++;
    6e10:	8b 81       	ldd	r24, Y+3	; 0x03
    6e12:	9c 81       	ldd	r25, Y+4	; 0x04
    6e14:	01 96       	adiw	r24, 0x01	; 1
    6e16:	9c 83       	std	Y+4, r25	; 0x04
    6e18:	8b 83       	std	Y+3, r24	; 0x03
    _buf[i] = SPI.transfer(0);
    6e1a:	2d 81       	ldd	r18, Y+5	; 0x05
    6e1c:	3e 81       	ldd	r19, Y+6	; 0x06
    6e1e:	89 81       	ldd	r24, Y+1	; 0x01
    6e20:	9a 81       	ldd	r25, Y+2	; 0x02
    6e22:	89 01       	movw	r16, r18
    6e24:	08 0f       	add	r16, r24
    6e26:	19 1f       	adc	r17, r25
    6e28:	80 e0       	ldi	r24, 0x00	; 0
    6e2a:	0e 94 a9 a8 	call	0x15152	; 0x15152 <_ZN8SPIClass8transferEh>
    6e2e:	f8 01       	movw	r30, r16
    6e30:	80 83       	st	Z, r24
    resetSS();
    6e32:	0e 94 fa a9 	call	0x153f4	; 0x153f4 <_ZN10W5100Class7resetSSEv>
  return _data;
}

uint16_t W5100Class::read(uint16_t _addr, uint8_t *_buf, uint16_t _len)
{
  for (uint16_t i=0; i<_len; i++)
    6e36:	89 81       	ldd	r24, Y+1	; 0x01
    6e38:	9a 81       	ldd	r25, Y+2	; 0x02
    6e3a:	01 96       	adiw	r24, 0x01	; 1
    6e3c:	9a 83       	std	Y+2, r25	; 0x02
    6e3e:	89 83       	std	Y+1, r24	; 0x01
    6e40:	41 e0       	ldi	r20, 0x01	; 1
    6e42:	29 81       	ldd	r18, Y+1	; 0x01
    6e44:	3a 81       	ldd	r19, Y+2	; 0x02
    6e46:	8f 81       	ldd	r24, Y+7	; 0x07
    6e48:	98 85       	ldd	r25, Y+8	; 0x08
    6e4a:	28 17       	cp	r18, r24
    6e4c:	39 07       	cpc	r19, r25
    6e4e:	08 f0       	brcs	.+2      	; 0x6e52 <_ZN10W5100Class4readEjPhj+0x88>
    6e50:	40 e0       	ldi	r20, 0x00	; 0
    6e52:	44 23       	and	r20, r20
    6e54:	79 f6       	brne	.-98     	; 0x6df4 <_ZN10W5100Class4readEjPhj+0x2a>
    SPI.transfer(_addr & 0xFF);
    _addr++;
    _buf[i] = SPI.transfer(0);
    resetSS();
  }
  return _len;
    6e56:	8f 81       	ldd	r24, Y+7	; 0x07
    6e58:	98 85       	ldd	r25, Y+8	; 0x08
}
    6e5a:	28 96       	adiw	r28, 0x08	; 8
    6e5c:	0f b6       	in	r0, 0x3f	; 63
    6e5e:	f8 94       	cli
    6e60:	de bf       	out	0x3e, r29	; 62
    6e62:	0f be       	out	0x3f, r0	; 63
    6e64:	cd bf       	out	0x3d, r28	; 61
    6e66:	df 91       	pop	r29
    6e68:	cf 91       	pop	r28
    6e6a:	1f 91       	pop	r17
    6e6c:	0f 91       	pop	r16
    6e6e:	08 95       	ret

00006e70 <_ZN10W5100Class9execCmdSnEh7SockCMD>:

void W5100Class::execCmdSn(SOCKET s, SockCMD _cmd) {
    6e70:	cf 93       	push	r28
    6e72:	df 93       	push	r29
    6e74:	00 d0       	rcall	.+0      	; 0x6e76 <_ZN10W5100Class9execCmdSnEh7SockCMD+0x6>
    6e76:	00 d0       	rcall	.+0      	; 0x6e78 <_ZN10W5100Class9execCmdSnEh7SockCMD+0x8>
    6e78:	cd b7       	in	r28, 0x3d	; 61
    6e7a:	de b7       	in	r29, 0x3e	; 62
    6e7c:	9a 83       	std	Y+2, r25	; 0x02
    6e7e:	89 83       	std	Y+1, r24	; 0x01
    6e80:	6b 83       	std	Y+3, r22	; 0x03
    6e82:	4c 83       	std	Y+4, r20	; 0x04
  // Send command to socket
  writeSnCR(s, _cmd);
    6e84:	6c 81       	ldd	r22, Y+4	; 0x04
    6e86:	8b 81       	ldd	r24, Y+3	; 0x03
    6e88:	0e 94 f4 a8 	call	0x151e8	; 0x151e8 <_ZN10W5100Class9writeSnCREhh>
  // Wait for command to complete
  while (readSnCR(s))
    6e8c:	00 00       	nop
    6e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    6e90:	0e 94 06 a9 	call	0x1520c	; 0x1520c <_ZN10W5100Class8readSnCREh>
    6e94:	98 2f       	mov	r25, r24
    6e96:	81 e0       	ldi	r24, 0x01	; 1
    6e98:	99 23       	and	r25, r25
    6e9a:	09 f4       	brne	.+2      	; 0x6e9e <_ZN10W5100Class9execCmdSnEh7SockCMD+0x2e>
    6e9c:	80 e0       	ldi	r24, 0x00	; 0
    6e9e:	88 23       	and	r24, r24
    6ea0:	b1 f7       	brne	.-20     	; 0x6e8e <_ZN10W5100Class9execCmdSnEh7SockCMD+0x1e>
    ;
}
    6ea2:	0f 90       	pop	r0
    6ea4:	0f 90       	pop	r0
    6ea6:	0f 90       	pop	r0
    6ea8:	0f 90       	pop	r0
    6eaa:	df 91       	pop	r29
    6eac:	cf 91       	pop	r28
    6eae:	08 95       	ret

00006eb0 <_ZN9DhcpClass13beginWithDHCPEPhmm>:
#include "Dhcp.h"
#include "Arduino.h"
#include "util.h"

int DhcpClass::beginWithDHCP(uint8_t *mac, unsigned long timeout, unsigned long responseTimeout)
{
    6eb0:	ef 92       	push	r14
    6eb2:	ff 92       	push	r15
    6eb4:	0f 93       	push	r16
    6eb6:	1f 93       	push	r17
    6eb8:	cf 93       	push	r28
    6eba:	df 93       	push	r29
    6ebc:	cd b7       	in	r28, 0x3d	; 61
    6ebe:	de b7       	in	r29, 0x3e	; 62
    6ec0:	2c 97       	sbiw	r28, 0x0c	; 12
    6ec2:	0f b6       	in	r0, 0x3f	; 63
    6ec4:	f8 94       	cli
    6ec6:	de bf       	out	0x3e, r29	; 62
    6ec8:	0f be       	out	0x3f, r0	; 63
    6eca:	cd bf       	out	0x3d, r28	; 61
    6ecc:	9a 83       	std	Y+2, r25	; 0x02
    6ece:	89 83       	std	Y+1, r24	; 0x01
    6ed0:	7c 83       	std	Y+4, r23	; 0x04
    6ed2:	6b 83       	std	Y+3, r22	; 0x03
    6ed4:	2d 83       	std	Y+5, r18	; 0x05
    6ed6:	3e 83       	std	Y+6, r19	; 0x06
    6ed8:	4f 83       	std	Y+7, r20	; 0x07
    6eda:	58 87       	std	Y+8, r21	; 0x08
    6edc:	e9 86       	std	Y+9, r14	; 0x09
    6ede:	fa 86       	std	Y+10, r15	; 0x0a
    6ee0:	0b 87       	std	Y+11, r16	; 0x0b
    6ee2:	1c 87       	std	Y+12, r17	; 0x0c
    _dhcpLeaseTime=0;
    6ee4:	89 81       	ldd	r24, Y+1	; 0x01
    6ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    6ee8:	fc 01       	movw	r30, r24
    6eea:	12 a2       	std	Z+34, r1	; 0x22
    6eec:	13 a2       	std	Z+35, r1	; 0x23
    6eee:	14 a2       	std	Z+36, r1	; 0x24
    6ef0:	15 a2       	std	Z+37, r1	; 0x25
    _dhcpT1=0;
    6ef2:	89 81       	ldd	r24, Y+1	; 0x01
    6ef4:	9a 81       	ldd	r25, Y+2	; 0x02
    6ef6:	fc 01       	movw	r30, r24
    6ef8:	16 a2       	std	Z+38, r1	; 0x26
    6efa:	17 a2       	std	Z+39, r1	; 0x27
    6efc:	10 a6       	std	Z+40, r1	; 0x28
    6efe:	11 a6       	std	Z+41, r1	; 0x29
    _dhcpT2=0;
    6f00:	89 81       	ldd	r24, Y+1	; 0x01
    6f02:	9a 81       	ldd	r25, Y+2	; 0x02
    6f04:	fc 01       	movw	r30, r24
    6f06:	12 a6       	std	Z+42, r1	; 0x2a
    6f08:	13 a6       	std	Z+43, r1	; 0x2b
    6f0a:	14 a6       	std	Z+44, r1	; 0x2c
    6f0c:	15 a6       	std	Z+45, r1	; 0x2d
    _lastCheck=0;
    6f0e:	89 81       	ldd	r24, Y+1	; 0x01
    6f10:	9a 81       	ldd	r25, Y+2	; 0x02
    6f12:	fc 01       	movw	r30, r24
    6f14:	16 aa       	std	Z+54, r1	; 0x36
    6f16:	17 aa       	std	Z+55, r1	; 0x37
    6f18:	10 ae       	std	Z+56, r1	; 0x38
    6f1a:	11 ae       	std	Z+57, r1	; 0x39
    _timeout = timeout;
    6f1c:	29 81       	ldd	r18, Y+1	; 0x01
    6f1e:	3a 81       	ldd	r19, Y+2	; 0x02
    6f20:	8d 81       	ldd	r24, Y+5	; 0x05
    6f22:	9e 81       	ldd	r25, Y+6	; 0x06
    6f24:	af 81       	ldd	r26, Y+7	; 0x07
    6f26:	b8 85       	ldd	r27, Y+8	; 0x08
    6f28:	f9 01       	movw	r30, r18
    6f2a:	82 af       	std	Z+58, r24	; 0x3a
    6f2c:	93 af       	std	Z+59, r25	; 0x3b
    6f2e:	a4 af       	std	Z+60, r26	; 0x3c
    6f30:	b5 af       	std	Z+61, r27	; 0x3d
    _responseTimeout = responseTimeout;
    6f32:	89 81       	ldd	r24, Y+1	; 0x01
    6f34:	9a 81       	ldd	r25, Y+2	; 0x02
    6f36:	9c 01       	movw	r18, r24
    6f38:	22 5c       	subi	r18, 0xC2	; 194
    6f3a:	3f 4f       	sbci	r19, 0xFF	; 255
    6f3c:	89 85       	ldd	r24, Y+9	; 0x09
    6f3e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6f40:	ab 85       	ldd	r26, Y+11	; 0x0b
    6f42:	bc 85       	ldd	r27, Y+12	; 0x0c
    6f44:	f9 01       	movw	r30, r18
    6f46:	80 83       	st	Z, r24
    6f48:	91 83       	std	Z+1, r25	; 0x01
    6f4a:	a2 83       	std	Z+2, r26	; 0x02
    6f4c:	b3 83       	std	Z+3, r27	; 0x03

    // zero out _dhcpMacAddr
    memset(_dhcpMacAddr, 0, 6); 
    6f4e:	89 81       	ldd	r24, Y+1	; 0x01
    6f50:	9a 81       	ldd	r25, Y+2	; 0x02
    6f52:	08 96       	adiw	r24, 0x08	; 8
    6f54:	46 e0       	ldi	r20, 0x06	; 6
    6f56:	50 e0       	ldi	r21, 0x00	; 0
    6f58:	60 e0       	ldi	r22, 0x00	; 0
    6f5a:	70 e0       	ldi	r23, 0x00	; 0
    6f5c:	0e 94 19 b1 	call	0x16232	; 0x16232 <memset>
    reset_DHCP_lease();
    6f60:	89 81       	ldd	r24, Y+1	; 0x01
    6f62:	9a 81       	ldd	r25, Y+2	; 0x02
    6f64:	0e 94 d5 37 	call	0x6faa	; 0x6faa <_ZN9DhcpClass16reset_DHCP_leaseEv>

    memcpy((void*)_dhcpMacAddr, (void*)mac, 6);
    6f68:	89 81       	ldd	r24, Y+1	; 0x01
    6f6a:	9a 81       	ldd	r25, Y+2	; 0x02
    6f6c:	08 96       	adiw	r24, 0x08	; 8
    6f6e:	2b 81       	ldd	r18, Y+3	; 0x03
    6f70:	3c 81       	ldd	r19, Y+4	; 0x04
    6f72:	46 e0       	ldi	r20, 0x06	; 6
    6f74:	50 e0       	ldi	r21, 0x00	; 0
    6f76:	b9 01       	movw	r22, r18
    6f78:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
    _dhcp_state = STATE_DHCP_START;
    6f7c:	89 81       	ldd	r24, Y+1	; 0x01
    6f7e:	9a 81       	ldd	r25, Y+2	; 0x02
    6f80:	8a 5b       	subi	r24, 0xBA	; 186
    6f82:	9f 4f       	sbci	r25, 0xFF	; 255
    6f84:	fc 01       	movw	r30, r24
    6f86:	10 82       	st	Z, r1
    return request_DHCP_lease();
    6f88:	89 81       	ldd	r24, Y+1	; 0x01
    6f8a:	9a 81       	ldd	r25, Y+2	; 0x02
    6f8c:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <_ZN9DhcpClass18request_DHCP_leaseEv>
}
    6f90:	2c 96       	adiw	r28, 0x0c	; 12
    6f92:	0f b6       	in	r0, 0x3f	; 63
    6f94:	f8 94       	cli
    6f96:	de bf       	out	0x3e, r29	; 62
    6f98:	0f be       	out	0x3f, r0	; 63
    6f9a:	cd bf       	out	0x3d, r28	; 61
    6f9c:	df 91       	pop	r29
    6f9e:	cf 91       	pop	r28
    6fa0:	1f 91       	pop	r17
    6fa2:	0f 91       	pop	r16
    6fa4:	ff 90       	pop	r15
    6fa6:	ef 90       	pop	r14
    6fa8:	08 95       	ret

00006faa <_ZN9DhcpClass16reset_DHCP_leaseEv>:

void DhcpClass::reset_DHCP_lease(){
    6faa:	cf 93       	push	r28
    6fac:	df 93       	push	r29
    6fae:	00 d0       	rcall	.+0      	; 0x6fb0 <_ZN9DhcpClass16reset_DHCP_leaseEv+0x6>
    6fb0:	cd b7       	in	r28, 0x3d	; 61
    6fb2:	de b7       	in	r29, 0x3e	; 62
    6fb4:	9a 83       	std	Y+2, r25	; 0x02
    6fb6:	89 83       	std	Y+1, r24	; 0x01
    // zero out _dhcpSubnetMask, _dhcpGatewayIp, _dhcpLocalIp, _dhcpDhcpServerIp, _dhcpDnsServerIp
    memset(_dhcpLocalIp, 0, 20);
    6fb8:	89 81       	ldd	r24, Y+1	; 0x01
    6fba:	9a 81       	ldd	r25, Y+2	; 0x02
    6fbc:	0e 96       	adiw	r24, 0x0e	; 14
    6fbe:	44 e1       	ldi	r20, 0x14	; 20
    6fc0:	50 e0       	ldi	r21, 0x00	; 0
    6fc2:	60 e0       	ldi	r22, 0x00	; 0
    6fc4:	70 e0       	ldi	r23, 0x00	; 0
    6fc6:	0e 94 19 b1 	call	0x16232	; 0x16232 <memset>
}
    6fca:	0f 90       	pop	r0
    6fcc:	0f 90       	pop	r0
    6fce:	df 91       	pop	r29
    6fd0:	cf 91       	pop	r28
    6fd2:	08 95       	ret

00006fd4 <_ZN9DhcpClass18request_DHCP_leaseEv>:

//return:0 on error, 1 if request is sent and response is received
int DhcpClass::request_DHCP_lease(){
    6fd4:	ef 92       	push	r14
    6fd6:	ff 92       	push	r15
    6fd8:	0f 93       	push	r16
    6fda:	1f 93       	push	r17
    6fdc:	cf 93       	push	r28
    6fde:	df 93       	push	r29
    6fe0:	cd b7       	in	r28, 0x3d	; 61
    6fe2:	de b7       	in	r29, 0x3e	; 62
    6fe4:	61 97       	sbiw	r28, 0x11	; 17
    6fe6:	0f b6       	in	r0, 0x3f	; 63
    6fe8:	f8 94       	cli
    6fea:	de bf       	out	0x3e, r29	; 62
    6fec:	0f be       	out	0x3f, r0	; 63
    6fee:	cd bf       	out	0x3d, r28	; 61
    6ff0:	99 8b       	std	Y+17, r25	; 0x11
    6ff2:	88 8b       	std	Y+16, r24	; 0x10
    
    uint8_t messageType = 0;
    6ff4:	19 82       	std	Y+1, r1	; 0x01
  
    
  
    // Pick an initial transaction ID
    _dhcpTransactionId = random(1UL, 2000UL);
    6ff6:	20 ed       	ldi	r18, 0xD0	; 208
    6ff8:	37 e0       	ldi	r19, 0x07	; 7
    6ffa:	40 e0       	ldi	r20, 0x00	; 0
    6ffc:	50 e0       	ldi	r21, 0x00	; 0
    6ffe:	61 e0       	ldi	r22, 0x01	; 1
    7000:	70 e0       	ldi	r23, 0x00	; 0
    7002:	80 e0       	ldi	r24, 0x00	; 0
    7004:	90 e0       	ldi	r25, 0x00	; 0
    7006:	0e 94 46 6c 	call	0xd88c	; 0xd88c <_Z6randomll>
    700a:	dc 01       	movw	r26, r24
    700c:	cb 01       	movw	r24, r22
    700e:	28 89       	ldd	r18, Y+16	; 0x10
    7010:	39 89       	ldd	r19, Y+17	; 0x11
    7012:	f9 01       	movw	r30, r18
    7014:	84 83       	std	Z+4, r24	; 0x04
    7016:	95 83       	std	Z+5, r25	; 0x05
    7018:	a6 83       	std	Z+6, r26	; 0x06
    701a:	b7 83       	std	Z+7, r27	; 0x07
    _dhcpInitialTransactionId = _dhcpTransactionId;
    701c:	88 89       	ldd	r24, Y+16	; 0x10
    701e:	99 89       	ldd	r25, Y+17	; 0x11
    7020:	fc 01       	movw	r30, r24
    7022:	84 81       	ldd	r24, Z+4	; 0x04
    7024:	95 81       	ldd	r25, Z+5	; 0x05
    7026:	a6 81       	ldd	r26, Z+6	; 0x06
    7028:	b7 81       	ldd	r27, Z+7	; 0x07
    702a:	28 89       	ldd	r18, Y+16	; 0x10
    702c:	39 89       	ldd	r19, Y+17	; 0x11
    702e:	f9 01       	movw	r30, r18
    7030:	80 83       	st	Z, r24
    7032:	91 83       	std	Z+1, r25	; 0x01
    7034:	a2 83       	std	Z+2, r26	; 0x02
    7036:	b3 83       	std	Z+3, r27	; 0x03

    _dhcpUdpSocket.stop();
    7038:	88 89       	ldd	r24, Y+16	; 0x10
    703a:	99 89       	ldd	r25, Y+17	; 0x11
    703c:	89 5b       	subi	r24, 0xB9	; 185
    703e:	9f 4f       	sbci	r25, 0xFF	; 255
    7040:	0e 94 6b 50 	call	0xa0d6	; 0xa0d6 <_ZN11EthernetUDP4stopEv>
    if (_dhcpUdpSocket.begin(DHCP_CLIENT_PORT) == 0)
    7044:	88 89       	ldd	r24, Y+16	; 0x10
    7046:	99 89       	ldd	r25, Y+17	; 0x11
    7048:	89 5b       	subi	r24, 0xB9	; 185
    704a:	9f 4f       	sbci	r25, 0xFF	; 255
    704c:	64 e4       	ldi	r22, 0x44	; 68
    704e:	70 e0       	ldi	r23, 0x00	; 0
    7050:	0e 94 f6 4f 	call	0x9fec	; 0x9fec <_ZN11EthernetUDP5beginEj>
    7054:	98 2f       	mov	r25, r24
    7056:	81 e0       	ldi	r24, 0x01	; 1
    7058:	99 23       	and	r25, r25
    705a:	09 f0       	breq	.+2      	; 0x705e <_ZN9DhcpClass18request_DHCP_leaseEv+0x8a>
    705c:	80 e0       	ldi	r24, 0x00	; 0
    705e:	88 23       	and	r24, r24
    7060:	19 f0       	breq	.+6      	; 0x7068 <_ZN9DhcpClass18request_DHCP_leaseEv+0x94>
    {
      // Couldn't get a socket
      return 0;
    7062:	80 e0       	ldi	r24, 0x00	; 0
    7064:	90 e0       	ldi	r25, 0x00	; 0
    7066:	dc c1       	rjmp	.+952    	; 0x7420 <_ZN9DhcpClass18request_DHCP_leaseEv+0x44c>
    }
    
    presend_DHCP();
    7068:	88 89       	ldd	r24, Y+16	; 0x10
    706a:	99 89       	ldd	r25, Y+17	; 0x11
    706c:	0e 94 1d 3a 	call	0x743a	; 0x743a <_ZN9DhcpClass12presend_DHCPEv>
    
    int result = 0;
    7070:	1b 82       	std	Y+3, r1	; 0x03
    7072:	1a 82       	std	Y+2, r1	; 0x02
    
    unsigned long startTime = millis();
    7074:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    7078:	dc 01       	movw	r26, r24
    707a:	cb 01       	movw	r24, r22
    707c:	8c 83       	std	Y+4, r24	; 0x04
    707e:	9d 83       	std	Y+5, r25	; 0x05
    7080:	ae 83       	std	Y+6, r26	; 0x06
    7082:	bf 83       	std	Y+7, r27	; 0x07
    
    while(_dhcp_state != STATE_DHCP_LEASED)
    7084:	a5 c1       	rjmp	.+842    	; 0x73d0 <_ZN9DhcpClass18request_DHCP_leaseEv+0x3fc>
    {
        if(_dhcp_state == STATE_DHCP_START)
    7086:	88 89       	ldd	r24, Y+16	; 0x10
    7088:	99 89       	ldd	r25, Y+17	; 0x11
    708a:	8a 5b       	subi	r24, 0xBA	; 186
    708c:	9f 4f       	sbci	r25, 0xFF	; 255
    708e:	fc 01       	movw	r30, r24
    7090:	80 81       	ld	r24, Z
    7092:	88 23       	and	r24, r24
    7094:	d1 f5       	brne	.+116    	; 0x710a <_ZN9DhcpClass18request_DHCP_leaseEv+0x136>
        {
            _dhcpTransactionId++;
    7096:	88 89       	ldd	r24, Y+16	; 0x10
    7098:	99 89       	ldd	r25, Y+17	; 0x11
    709a:	fc 01       	movw	r30, r24
    709c:	84 81       	ldd	r24, Z+4	; 0x04
    709e:	95 81       	ldd	r25, Z+5	; 0x05
    70a0:	a6 81       	ldd	r26, Z+6	; 0x06
    70a2:	b7 81       	ldd	r27, Z+7	; 0x07
    70a4:	01 96       	adiw	r24, 0x01	; 1
    70a6:	a1 1d       	adc	r26, r1
    70a8:	b1 1d       	adc	r27, r1
    70aa:	28 89       	ldd	r18, Y+16	; 0x10
    70ac:	39 89       	ldd	r19, Y+17	; 0x11
    70ae:	f9 01       	movw	r30, r18
    70b0:	84 83       	std	Z+4, r24	; 0x04
    70b2:	95 83       	std	Z+5, r25	; 0x05
    70b4:	a6 83       	std	Z+6, r26	; 0x06
    70b6:	b7 83       	std	Z+7, r27	; 0x07
            
            send_DHCP_MESSAGE(DHCP_DISCOVER, ((millis() - startTime) / 1000));
    70b8:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    70bc:	9b 01       	movw	r18, r22
    70be:	ac 01       	movw	r20, r24
    70c0:	8c 81       	ldd	r24, Y+4	; 0x04
    70c2:	9d 81       	ldd	r25, Y+5	; 0x05
    70c4:	ae 81       	ldd	r26, Y+6	; 0x06
    70c6:	bf 81       	ldd	r27, Y+7	; 0x07
    70c8:	79 01       	movw	r14, r18
    70ca:	8a 01       	movw	r16, r20
    70cc:	e8 1a       	sub	r14, r24
    70ce:	f9 0a       	sbc	r15, r25
    70d0:	0a 0b       	sbc	r16, r26
    70d2:	1b 0b       	sbc	r17, r27
    70d4:	d8 01       	movw	r26, r16
    70d6:	c7 01       	movw	r24, r14
    70d8:	28 ee       	ldi	r18, 0xE8	; 232
    70da:	33 e0       	ldi	r19, 0x03	; 3
    70dc:	40 e0       	ldi	r20, 0x00	; 0
    70de:	50 e0       	ldi	r21, 0x00	; 0
    70e0:	bc 01       	movw	r22, r24
    70e2:	cd 01       	movw	r24, r26
    70e4:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    70e8:	da 01       	movw	r26, r20
    70ea:	c9 01       	movw	r24, r18
    70ec:	9c 01       	movw	r18, r24
    70ee:	88 89       	ldd	r24, Y+16	; 0x10
    70f0:	99 89       	ldd	r25, Y+17	; 0x11
    70f2:	a9 01       	movw	r20, r18
    70f4:	61 e0       	ldi	r22, 0x01	; 1
    70f6:	0e 94 29 3a 	call	0x7452	; 0x7452 <_ZN9DhcpClass17send_DHCP_MESSAGEEhj>
            _dhcp_state = STATE_DHCP_DISCOVER;
    70fa:	88 89       	ldd	r24, Y+16	; 0x10
    70fc:	99 89       	ldd	r25, Y+17	; 0x11
    70fe:	8a 5b       	subi	r24, 0xBA	; 186
    7100:	9f 4f       	sbci	r25, 0xFF	; 255
    7102:	21 e0       	ldi	r18, 0x01	; 1
    7104:	fc 01       	movw	r30, r24
    7106:	20 83       	st	Z, r18
    7108:	37 c1       	rjmp	.+622    	; 0x7378 <_ZN9DhcpClass18request_DHCP_leaseEv+0x3a4>
        }
        else if(_dhcp_state == STATE_DHCP_REREQUEST){
    710a:	88 89       	ldd	r24, Y+16	; 0x10
    710c:	99 89       	ldd	r25, Y+17	; 0x11
    710e:	8a 5b       	subi	r24, 0xBA	; 186
    7110:	9f 4f       	sbci	r25, 0xFF	; 255
    7112:	fc 01       	movw	r30, r24
    7114:	80 81       	ld	r24, Z
    7116:	84 30       	cpi	r24, 0x04	; 4
    7118:	d1 f5       	brne	.+116    	; 0x718e <_ZN9DhcpClass18request_DHCP_leaseEv+0x1ba>
            _dhcpTransactionId++;
    711a:	88 89       	ldd	r24, Y+16	; 0x10
    711c:	99 89       	ldd	r25, Y+17	; 0x11
    711e:	fc 01       	movw	r30, r24
    7120:	84 81       	ldd	r24, Z+4	; 0x04
    7122:	95 81       	ldd	r25, Z+5	; 0x05
    7124:	a6 81       	ldd	r26, Z+6	; 0x06
    7126:	b7 81       	ldd	r27, Z+7	; 0x07
    7128:	01 96       	adiw	r24, 0x01	; 1
    712a:	a1 1d       	adc	r26, r1
    712c:	b1 1d       	adc	r27, r1
    712e:	28 89       	ldd	r18, Y+16	; 0x10
    7130:	39 89       	ldd	r19, Y+17	; 0x11
    7132:	f9 01       	movw	r30, r18
    7134:	84 83       	std	Z+4, r24	; 0x04
    7136:	95 83       	std	Z+5, r25	; 0x05
    7138:	a6 83       	std	Z+6, r26	; 0x06
    713a:	b7 83       	std	Z+7, r27	; 0x07
            send_DHCP_MESSAGE(DHCP_REQUEST, ((millis() - startTime)/1000));
    713c:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    7140:	9b 01       	movw	r18, r22
    7142:	ac 01       	movw	r20, r24
    7144:	8c 81       	ldd	r24, Y+4	; 0x04
    7146:	9d 81       	ldd	r25, Y+5	; 0x05
    7148:	ae 81       	ldd	r26, Y+6	; 0x06
    714a:	bf 81       	ldd	r27, Y+7	; 0x07
    714c:	79 01       	movw	r14, r18
    714e:	8a 01       	movw	r16, r20
    7150:	e8 1a       	sub	r14, r24
    7152:	f9 0a       	sbc	r15, r25
    7154:	0a 0b       	sbc	r16, r26
    7156:	1b 0b       	sbc	r17, r27
    7158:	d8 01       	movw	r26, r16
    715a:	c7 01       	movw	r24, r14
    715c:	28 ee       	ldi	r18, 0xE8	; 232
    715e:	33 e0       	ldi	r19, 0x03	; 3
    7160:	40 e0       	ldi	r20, 0x00	; 0
    7162:	50 e0       	ldi	r21, 0x00	; 0
    7164:	bc 01       	movw	r22, r24
    7166:	cd 01       	movw	r24, r26
    7168:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    716c:	da 01       	movw	r26, r20
    716e:	c9 01       	movw	r24, r18
    7170:	9c 01       	movw	r18, r24
    7172:	88 89       	ldd	r24, Y+16	; 0x10
    7174:	99 89       	ldd	r25, Y+17	; 0x11
    7176:	a9 01       	movw	r20, r18
    7178:	63 e0       	ldi	r22, 0x03	; 3
    717a:	0e 94 29 3a 	call	0x7452	; 0x7452 <_ZN9DhcpClass17send_DHCP_MESSAGEEhj>
            _dhcp_state = STATE_DHCP_REQUEST;
    717e:	88 89       	ldd	r24, Y+16	; 0x10
    7180:	99 89       	ldd	r25, Y+17	; 0x11
    7182:	8a 5b       	subi	r24, 0xBA	; 186
    7184:	9f 4f       	sbci	r25, 0xFF	; 255
    7186:	22 e0       	ldi	r18, 0x02	; 2
    7188:	fc 01       	movw	r30, r24
    718a:	20 83       	st	Z, r18
    718c:	f5 c0       	rjmp	.+490    	; 0x7378 <_ZN9DhcpClass18request_DHCP_leaseEv+0x3a4>
        }
        else if(_dhcp_state == STATE_DHCP_DISCOVER)
    718e:	88 89       	ldd	r24, Y+16	; 0x10
    7190:	99 89       	ldd	r25, Y+17	; 0x11
    7192:	8a 5b       	subi	r24, 0xBA	; 186
    7194:	9f 4f       	sbci	r25, 0xFF	; 255
    7196:	fc 01       	movw	r30, r24
    7198:	80 81       	ld	r24, Z
    719a:	81 30       	cpi	r24, 0x01	; 1
    719c:	09 f0       	breq	.+2      	; 0x71a0 <_ZN9DhcpClass18request_DHCP_leaseEv+0x1cc>
    719e:	4b c0       	rjmp	.+150    	; 0x7236 <_ZN9DhcpClass18request_DHCP_leaseEv+0x262>
        {
            uint32_t respId;
            messageType = parseDHCPResponse(_responseTimeout, respId);
    71a0:	88 89       	ldd	r24, Y+16	; 0x10
    71a2:	99 89       	ldd	r25, Y+17	; 0x11
    71a4:	ce 96       	adiw	r24, 0x3e	; 62
    71a6:	fc 01       	movw	r30, r24
    71a8:	80 81       	ld	r24, Z
    71aa:	91 81       	ldd	r25, Z+1	; 0x01
    71ac:	a2 81       	ldd	r26, Z+2	; 0x02
    71ae:	b3 81       	ldd	r27, Z+3	; 0x03
    71b0:	9e 01       	movw	r18, r28
    71b2:	28 5f       	subi	r18, 0xF8	; 248
    71b4:	3f 4f       	sbci	r19, 0xFF	; 255
    71b6:	e8 89       	ldd	r30, Y+16	; 0x10
    71b8:	f9 89       	ldd	r31, Y+17	; 0x11
    71ba:	ac 01       	movw	r20, r24
    71bc:	bd 01       	movw	r22, r26
    71be:	cf 01       	movw	r24, r30
    71c0:	0e 94 f4 3b 	call	0x77e8	; 0x77e8 <_ZN9DhcpClass17parseDHCPResponseEmRm>
    71c4:	89 83       	std	Y+1, r24	; 0x01
            if(messageType == DHCP_OFFER)
    71c6:	89 81       	ldd	r24, Y+1	; 0x01
    71c8:	82 30       	cpi	r24, 0x02	; 2
    71ca:	09 f0       	breq	.+2      	; 0x71ce <_ZN9DhcpClass18request_DHCP_leaseEv+0x1fa>
    71cc:	d5 c0       	rjmp	.+426    	; 0x7378 <_ZN9DhcpClass18request_DHCP_leaseEv+0x3a4>
            {
                // We'll use the transaction ID that the offer came with,
                // rather than the one we were up to
                _dhcpTransactionId = respId;
    71ce:	88 85       	ldd	r24, Y+8	; 0x08
    71d0:	99 85       	ldd	r25, Y+9	; 0x09
    71d2:	aa 85       	ldd	r26, Y+10	; 0x0a
    71d4:	bb 85       	ldd	r27, Y+11	; 0x0b
    71d6:	28 89       	ldd	r18, Y+16	; 0x10
    71d8:	39 89       	ldd	r19, Y+17	; 0x11
    71da:	f9 01       	movw	r30, r18
    71dc:	84 83       	std	Z+4, r24	; 0x04
    71de:	95 83       	std	Z+5, r25	; 0x05
    71e0:	a6 83       	std	Z+6, r26	; 0x06
    71e2:	b7 83       	std	Z+7, r27	; 0x07
                send_DHCP_MESSAGE(DHCP_REQUEST, ((millis() - startTime) / 1000));
    71e4:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    71e8:	9b 01       	movw	r18, r22
    71ea:	ac 01       	movw	r20, r24
    71ec:	8c 81       	ldd	r24, Y+4	; 0x04
    71ee:	9d 81       	ldd	r25, Y+5	; 0x05
    71f0:	ae 81       	ldd	r26, Y+6	; 0x06
    71f2:	bf 81       	ldd	r27, Y+7	; 0x07
    71f4:	79 01       	movw	r14, r18
    71f6:	8a 01       	movw	r16, r20
    71f8:	e8 1a       	sub	r14, r24
    71fa:	f9 0a       	sbc	r15, r25
    71fc:	0a 0b       	sbc	r16, r26
    71fe:	1b 0b       	sbc	r17, r27
    7200:	d8 01       	movw	r26, r16
    7202:	c7 01       	movw	r24, r14
    7204:	28 ee       	ldi	r18, 0xE8	; 232
    7206:	33 e0       	ldi	r19, 0x03	; 3
    7208:	40 e0       	ldi	r20, 0x00	; 0
    720a:	50 e0       	ldi	r21, 0x00	; 0
    720c:	bc 01       	movw	r22, r24
    720e:	cd 01       	movw	r24, r26
    7210:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    7214:	da 01       	movw	r26, r20
    7216:	c9 01       	movw	r24, r18
    7218:	9c 01       	movw	r18, r24
    721a:	88 89       	ldd	r24, Y+16	; 0x10
    721c:	99 89       	ldd	r25, Y+17	; 0x11
    721e:	a9 01       	movw	r20, r18
    7220:	63 e0       	ldi	r22, 0x03	; 3
    7222:	0e 94 29 3a 	call	0x7452	; 0x7452 <_ZN9DhcpClass17send_DHCP_MESSAGEEhj>
                _dhcp_state = STATE_DHCP_REQUEST;
    7226:	88 89       	ldd	r24, Y+16	; 0x10
    7228:	99 89       	ldd	r25, Y+17	; 0x11
    722a:	8a 5b       	subi	r24, 0xBA	; 186
    722c:	9f 4f       	sbci	r25, 0xFF	; 255
    722e:	22 e0       	ldi	r18, 0x02	; 2
    7230:	fc 01       	movw	r30, r24
    7232:	20 83       	st	Z, r18
    7234:	a1 c0       	rjmp	.+322    	; 0x7378 <_ZN9DhcpClass18request_DHCP_leaseEv+0x3a4>
            }
        }
        else if(_dhcp_state == STATE_DHCP_REQUEST)
    7236:	88 89       	ldd	r24, Y+16	; 0x10
    7238:	99 89       	ldd	r25, Y+17	; 0x11
    723a:	8a 5b       	subi	r24, 0xBA	; 186
    723c:	9f 4f       	sbci	r25, 0xFF	; 255
    723e:	fc 01       	movw	r30, r24
    7240:	80 81       	ld	r24, Z
    7242:	82 30       	cpi	r24, 0x02	; 2
    7244:	09 f0       	breq	.+2      	; 0x7248 <_ZN9DhcpClass18request_DHCP_leaseEv+0x274>
    7246:	98 c0       	rjmp	.+304    	; 0x7378 <_ZN9DhcpClass18request_DHCP_leaseEv+0x3a4>
        {
            uint32_t respId;
            messageType = parseDHCPResponse(_responseTimeout, respId);
    7248:	88 89       	ldd	r24, Y+16	; 0x10
    724a:	99 89       	ldd	r25, Y+17	; 0x11
    724c:	ce 96       	adiw	r24, 0x3e	; 62
    724e:	fc 01       	movw	r30, r24
    7250:	80 81       	ld	r24, Z
    7252:	91 81       	ldd	r25, Z+1	; 0x01
    7254:	a2 81       	ldd	r26, Z+2	; 0x02
    7256:	b3 81       	ldd	r27, Z+3	; 0x03
    7258:	9e 01       	movw	r18, r28
    725a:	24 5f       	subi	r18, 0xF4	; 244
    725c:	3f 4f       	sbci	r19, 0xFF	; 255
    725e:	e8 89       	ldd	r30, Y+16	; 0x10
    7260:	f9 89       	ldd	r31, Y+17	; 0x11
    7262:	ac 01       	movw	r20, r24
    7264:	bd 01       	movw	r22, r26
    7266:	cf 01       	movw	r24, r30
    7268:	0e 94 f4 3b 	call	0x77e8	; 0x77e8 <_ZN9DhcpClass17parseDHCPResponseEmRm>
    726c:	89 83       	std	Y+1, r24	; 0x01
            if(messageType == DHCP_ACK)
    726e:	89 81       	ldd	r24, Y+1	; 0x01
    7270:	85 30       	cpi	r24, 0x05	; 5
    7272:	09 f0       	breq	.+2      	; 0x7276 <_ZN9DhcpClass18request_DHCP_leaseEv+0x2a2>
    7274:	78 c0       	rjmp	.+240    	; 0x7366 <_ZN9DhcpClass18request_DHCP_leaseEv+0x392>
            {
                _dhcp_state = STATE_DHCP_LEASED;
    7276:	88 89       	ldd	r24, Y+16	; 0x10
    7278:	99 89       	ldd	r25, Y+17	; 0x11
    727a:	8a 5b       	subi	r24, 0xBA	; 186
    727c:	9f 4f       	sbci	r25, 0xFF	; 255
    727e:	23 e0       	ldi	r18, 0x03	; 3
    7280:	fc 01       	movw	r30, r24
    7282:	20 83       	st	Z, r18
                result = 1;
    7284:	81 e0       	ldi	r24, 0x01	; 1
    7286:	90 e0       	ldi	r25, 0x00	; 0
    7288:	9b 83       	std	Y+3, r25	; 0x03
    728a:	8a 83       	std	Y+2, r24	; 0x02
                //use default lease time if we didn't get it
                if(_dhcpLeaseTime == 0){
    728c:	88 89       	ldd	r24, Y+16	; 0x10
    728e:	99 89       	ldd	r25, Y+17	; 0x11
    7290:	fc 01       	movw	r30, r24
    7292:	82 a1       	ldd	r24, Z+34	; 0x22
    7294:	93 a1       	ldd	r25, Z+35	; 0x23
    7296:	a4 a1       	ldd	r26, Z+36	; 0x24
    7298:	b5 a1       	ldd	r27, Z+37	; 0x25
    729a:	00 97       	sbiw	r24, 0x00	; 0
    729c:	a1 05       	cpc	r26, r1
    729e:	b1 05       	cpc	r27, r1
    72a0:	59 f4       	brne	.+22     	; 0x72b8 <_ZN9DhcpClass18request_DHCP_leaseEv+0x2e4>
                    _dhcpLeaseTime = DEFAULT_LEASE;
    72a2:	28 89       	ldd	r18, Y+16	; 0x10
    72a4:	39 89       	ldd	r19, Y+17	; 0x11
    72a6:	84 e8       	ldi	r24, 0x84	; 132
    72a8:	93 e0       	ldi	r25, 0x03	; 3
    72aa:	a0 e0       	ldi	r26, 0x00	; 0
    72ac:	b0 e0       	ldi	r27, 0x00	; 0
    72ae:	f9 01       	movw	r30, r18
    72b0:	82 a3       	std	Z+34, r24	; 0x22
    72b2:	93 a3       	std	Z+35, r25	; 0x23
    72b4:	a4 a3       	std	Z+36, r26	; 0x24
    72b6:	b5 a3       	std	Z+37, r27	; 0x25
                }
                //calculate T1 & T2 if we didn't get it
                if(_dhcpT1 == 0){
    72b8:	88 89       	ldd	r24, Y+16	; 0x10
    72ba:	99 89       	ldd	r25, Y+17	; 0x11
    72bc:	fc 01       	movw	r30, r24
    72be:	86 a1       	ldd	r24, Z+38	; 0x26
    72c0:	97 a1       	ldd	r25, Z+39	; 0x27
    72c2:	a0 a5       	ldd	r26, Z+40	; 0x28
    72c4:	b1 a5       	ldd	r27, Z+41	; 0x29
    72c6:	00 97       	sbiw	r24, 0x00	; 0
    72c8:	a1 05       	cpc	r26, r1
    72ca:	b1 05       	cpc	r27, r1
    72cc:	91 f4       	brne	.+36     	; 0x72f2 <_ZN9DhcpClass18request_DHCP_leaseEv+0x31e>
                    //T1 should be 50% of _dhcpLeaseTime
                    _dhcpT1 = _dhcpLeaseTime >> 1;
    72ce:	88 89       	ldd	r24, Y+16	; 0x10
    72d0:	99 89       	ldd	r25, Y+17	; 0x11
    72d2:	fc 01       	movw	r30, r24
    72d4:	82 a1       	ldd	r24, Z+34	; 0x22
    72d6:	93 a1       	ldd	r25, Z+35	; 0x23
    72d8:	a4 a1       	ldd	r26, Z+36	; 0x24
    72da:	b5 a1       	ldd	r27, Z+37	; 0x25
    72dc:	b6 95       	lsr	r27
    72de:	a7 95       	ror	r26
    72e0:	97 95       	ror	r25
    72e2:	87 95       	ror	r24
    72e4:	28 89       	ldd	r18, Y+16	; 0x10
    72e6:	39 89       	ldd	r19, Y+17	; 0x11
    72e8:	f9 01       	movw	r30, r18
    72ea:	86 a3       	std	Z+38, r24	; 0x26
    72ec:	97 a3       	std	Z+39, r25	; 0x27
    72ee:	a0 a7       	std	Z+40, r26	; 0x28
    72f0:	b1 a7       	std	Z+41, r27	; 0x29
                }
                if(_dhcpT2 == 0){
    72f2:	88 89       	ldd	r24, Y+16	; 0x10
    72f4:	99 89       	ldd	r25, Y+17	; 0x11
    72f6:	fc 01       	movw	r30, r24
    72f8:	82 a5       	ldd	r24, Z+42	; 0x2a
    72fa:	93 a5       	ldd	r25, Z+43	; 0x2b
    72fc:	a4 a5       	ldd	r26, Z+44	; 0x2c
    72fe:	b5 a5       	ldd	r27, Z+45	; 0x2d
    7300:	00 97       	sbiw	r24, 0x00	; 0
    7302:	a1 05       	cpc	r26, r1
    7304:	b1 05       	cpc	r27, r1
    7306:	91 f4       	brne	.+36     	; 0x732c <_ZN9DhcpClass18request_DHCP_leaseEv+0x358>
                    //T2 should be 87.5% (7/8ths) of _dhcpLeaseTime
                    _dhcpT2 = _dhcpT1 << 1;
    7308:	88 89       	ldd	r24, Y+16	; 0x10
    730a:	99 89       	ldd	r25, Y+17	; 0x11
    730c:	fc 01       	movw	r30, r24
    730e:	86 a1       	ldd	r24, Z+38	; 0x26
    7310:	97 a1       	ldd	r25, Z+39	; 0x27
    7312:	a0 a5       	ldd	r26, Z+40	; 0x28
    7314:	b1 a5       	ldd	r27, Z+41	; 0x29
    7316:	88 0f       	add	r24, r24
    7318:	99 1f       	adc	r25, r25
    731a:	aa 1f       	adc	r26, r26
    731c:	bb 1f       	adc	r27, r27
    731e:	28 89       	ldd	r18, Y+16	; 0x10
    7320:	39 89       	ldd	r19, Y+17	; 0x11
    7322:	f9 01       	movw	r30, r18
    7324:	82 a7       	std	Z+42, r24	; 0x2a
    7326:	93 a7       	std	Z+43, r25	; 0x2b
    7328:	a4 a7       	std	Z+44, r26	; 0x2c
    732a:	b5 a7       	std	Z+45, r27	; 0x2d
                }
                _renewInSec = _dhcpT1;
    732c:	88 89       	ldd	r24, Y+16	; 0x10
    732e:	99 89       	ldd	r25, Y+17	; 0x11
    7330:	fc 01       	movw	r30, r24
    7332:	86 a1       	ldd	r24, Z+38	; 0x26
    7334:	97 a1       	ldd	r25, Z+39	; 0x27
    7336:	a0 a5       	ldd	r26, Z+40	; 0x28
    7338:	b1 a5       	ldd	r27, Z+41	; 0x29
    733a:	28 89       	ldd	r18, Y+16	; 0x10
    733c:	39 89       	ldd	r19, Y+17	; 0x11
    733e:	f9 01       	movw	r30, r18
    7340:	86 a7       	std	Z+46, r24	; 0x2e
    7342:	97 a7       	std	Z+47, r25	; 0x2f
    7344:	a0 ab       	std	Z+48, r26	; 0x30
    7346:	b1 ab       	std	Z+49, r27	; 0x31
                _rebindInSec = _dhcpT2;
    7348:	88 89       	ldd	r24, Y+16	; 0x10
    734a:	99 89       	ldd	r25, Y+17	; 0x11
    734c:	fc 01       	movw	r30, r24
    734e:	82 a5       	ldd	r24, Z+42	; 0x2a
    7350:	93 a5       	ldd	r25, Z+43	; 0x2b
    7352:	a4 a5       	ldd	r26, Z+44	; 0x2c
    7354:	b5 a5       	ldd	r27, Z+45	; 0x2d
    7356:	28 89       	ldd	r18, Y+16	; 0x10
    7358:	39 89       	ldd	r19, Y+17	; 0x11
    735a:	f9 01       	movw	r30, r18
    735c:	82 ab       	std	Z+50, r24	; 0x32
    735e:	93 ab       	std	Z+51, r25	; 0x33
    7360:	a4 ab       	std	Z+52, r26	; 0x34
    7362:	b5 ab       	std	Z+53, r27	; 0x35
    7364:	09 c0       	rjmp	.+18     	; 0x7378 <_ZN9DhcpClass18request_DHCP_leaseEv+0x3a4>
            }
            else if(messageType == DHCP_NAK)
    7366:	89 81       	ldd	r24, Y+1	; 0x01
    7368:	86 30       	cpi	r24, 0x06	; 6
    736a:	31 f4       	brne	.+12     	; 0x7378 <_ZN9DhcpClass18request_DHCP_leaseEv+0x3a4>
                _dhcp_state = STATE_DHCP_START;
    736c:	88 89       	ldd	r24, Y+16	; 0x10
    736e:	99 89       	ldd	r25, Y+17	; 0x11
    7370:	8a 5b       	subi	r24, 0xBA	; 186
    7372:	9f 4f       	sbci	r25, 0xFF	; 255
    7374:	fc 01       	movw	r30, r24
    7376:	10 82       	st	Z, r1
        }
        
        if(messageType == 255)
    7378:	89 81       	ldd	r24, Y+1	; 0x01
    737a:	8f 3f       	cpi	r24, 0xFF	; 255
    737c:	39 f4       	brne	.+14     	; 0x738c <_ZN9DhcpClass18request_DHCP_leaseEv+0x3b8>
        {
            messageType = 0;
    737e:	19 82       	std	Y+1, r1	; 0x01
            _dhcp_state = STATE_DHCP_START;
    7380:	88 89       	ldd	r24, Y+16	; 0x10
    7382:	99 89       	ldd	r25, Y+17	; 0x11
    7384:	8a 5b       	subi	r24, 0xBA	; 186
    7386:	9f 4f       	sbci	r25, 0xFF	; 255
    7388:	fc 01       	movw	r30, r24
    738a:	10 82       	st	Z, r1
        }
        
        if(result != 1 && ((millis() - startTime) > _timeout))
    738c:	8a 81       	ldd	r24, Y+2	; 0x02
    738e:	9b 81       	ldd	r25, Y+3	; 0x03
    7390:	81 30       	cpi	r24, 0x01	; 1
    7392:	91 05       	cpc	r25, r1
    7394:	d1 f0       	breq	.+52     	; 0x73ca <_ZN9DhcpClass18request_DHCP_leaseEv+0x3f6>
    7396:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    739a:	9b 01       	movw	r18, r22
    739c:	ac 01       	movw	r20, r24
    739e:	8c 81       	ldd	r24, Y+4	; 0x04
    73a0:	9d 81       	ldd	r25, Y+5	; 0x05
    73a2:	ae 81       	ldd	r26, Y+6	; 0x06
    73a4:	bf 81       	ldd	r27, Y+7	; 0x07
    73a6:	28 1b       	sub	r18, r24
    73a8:	39 0b       	sbc	r19, r25
    73aa:	4a 0b       	sbc	r20, r26
    73ac:	5b 0b       	sbc	r21, r27
    73ae:	88 89       	ldd	r24, Y+16	; 0x10
    73b0:	99 89       	ldd	r25, Y+17	; 0x11
    73b2:	fc 01       	movw	r30, r24
    73b4:	82 ad       	ldd	r24, Z+58	; 0x3a
    73b6:	93 ad       	ldd	r25, Z+59	; 0x3b
    73b8:	a4 ad       	ldd	r26, Z+60	; 0x3c
    73ba:	b5 ad       	ldd	r27, Z+61	; 0x3d
    73bc:	82 17       	cp	r24, r18
    73be:	93 07       	cpc	r25, r19
    73c0:	a4 07       	cpc	r26, r20
    73c2:	b5 07       	cpc	r27, r21
    73c4:	10 f4       	brcc	.+4      	; 0x73ca <_ZN9DhcpClass18request_DHCP_leaseEv+0x3f6>
    73c6:	81 e0       	ldi	r24, 0x01	; 1
    73c8:	01 c0       	rjmp	.+2      	; 0x73cc <_ZN9DhcpClass18request_DHCP_leaseEv+0x3f8>
    73ca:	80 e0       	ldi	r24, 0x00	; 0
    73cc:	88 23       	and	r24, r24
    73ce:	71 f4       	brne	.+28     	; 0x73ec <_ZN9DhcpClass18request_DHCP_leaseEv+0x418>
    
    int result = 0;
    
    unsigned long startTime = millis();
    
    while(_dhcp_state != STATE_DHCP_LEASED)
    73d0:	88 89       	ldd	r24, Y+16	; 0x10
    73d2:	99 89       	ldd	r25, Y+17	; 0x11
    73d4:	8a 5b       	subi	r24, 0xBA	; 186
    73d6:	9f 4f       	sbci	r25, 0xFF	; 255
    73d8:	fc 01       	movw	r30, r24
    73da:	90 81       	ld	r25, Z
    73dc:	81 e0       	ldi	r24, 0x01	; 1
    73de:	93 30       	cpi	r25, 0x03	; 3
    73e0:	09 f4       	brne	.+2      	; 0x73e4 <_ZN9DhcpClass18request_DHCP_leaseEv+0x410>
    73e2:	80 e0       	ldi	r24, 0x00	; 0
    73e4:	88 23       	and	r24, r24
    73e6:	09 f0       	breq	.+2      	; 0x73ea <_ZN9DhcpClass18request_DHCP_leaseEv+0x416>
    73e8:	4e ce       	rjmp	.-868    	; 0x7086 <_ZN9DhcpClass18request_DHCP_leaseEv+0xb2>
    73ea:	01 c0       	rjmp	.+2      	; 0x73ee <_ZN9DhcpClass18request_DHCP_leaseEv+0x41a>
            messageType = 0;
            _dhcp_state = STATE_DHCP_START;
        }
        
        if(result != 1 && ((millis() - startTime) > _timeout))
            break;
    73ec:	00 00       	nop
    }
    
    // We're done with the socket now
    _dhcpUdpSocket.stop();
    73ee:	88 89       	ldd	r24, Y+16	; 0x10
    73f0:	99 89       	ldd	r25, Y+17	; 0x11
    73f2:	89 5b       	subi	r24, 0xB9	; 185
    73f4:	9f 4f       	sbci	r25, 0xFF	; 255
    73f6:	0e 94 6b 50 	call	0xa0d6	; 0xa0d6 <_ZN11EthernetUDP4stopEv>
    _dhcpTransactionId++;
    73fa:	88 89       	ldd	r24, Y+16	; 0x10
    73fc:	99 89       	ldd	r25, Y+17	; 0x11
    73fe:	fc 01       	movw	r30, r24
    7400:	84 81       	ldd	r24, Z+4	; 0x04
    7402:	95 81       	ldd	r25, Z+5	; 0x05
    7404:	a6 81       	ldd	r26, Z+6	; 0x06
    7406:	b7 81       	ldd	r27, Z+7	; 0x07
    7408:	01 96       	adiw	r24, 0x01	; 1
    740a:	a1 1d       	adc	r26, r1
    740c:	b1 1d       	adc	r27, r1
    740e:	28 89       	ldd	r18, Y+16	; 0x10
    7410:	39 89       	ldd	r19, Y+17	; 0x11
    7412:	f9 01       	movw	r30, r18
    7414:	84 83       	std	Z+4, r24	; 0x04
    7416:	95 83       	std	Z+5, r25	; 0x05
    7418:	a6 83       	std	Z+6, r26	; 0x06
    741a:	b7 83       	std	Z+7, r27	; 0x07

    return result;
    741c:	8a 81       	ldd	r24, Y+2	; 0x02
    741e:	9b 81       	ldd	r25, Y+3	; 0x03
}
    7420:	61 96       	adiw	r28, 0x11	; 17
    7422:	0f b6       	in	r0, 0x3f	; 63
    7424:	f8 94       	cli
    7426:	de bf       	out	0x3e, r29	; 62
    7428:	0f be       	out	0x3f, r0	; 63
    742a:	cd bf       	out	0x3d, r28	; 61
    742c:	df 91       	pop	r29
    742e:	cf 91       	pop	r28
    7430:	1f 91       	pop	r17
    7432:	0f 91       	pop	r16
    7434:	ff 90       	pop	r15
    7436:	ef 90       	pop	r14
    7438:	08 95       	ret

0000743a <_ZN9DhcpClass12presend_DHCPEv>:

void DhcpClass::presend_DHCP()
{
    743a:	cf 93       	push	r28
    743c:	df 93       	push	r29
    743e:	00 d0       	rcall	.+0      	; 0x7440 <_ZN9DhcpClass12presend_DHCPEv+0x6>
    7440:	cd b7       	in	r28, 0x3d	; 61
    7442:	de b7       	in	r29, 0x3e	; 62
    7444:	9a 83       	std	Y+2, r25	; 0x02
    7446:	89 83       	std	Y+1, r24	; 0x01
}
    7448:	0f 90       	pop	r0
    744a:	0f 90       	pop	r0
    744c:	df 91       	pop	r29
    744e:	cf 91       	pop	r28
    7450:	08 95       	ret

00007452 <_ZN9DhcpClass17send_DHCP_MESSAGEEhj>:

void DhcpClass::send_DHCP_MESSAGE(uint8_t messageType, uint16_t secondsElapsed)
{
    7452:	0f 93       	push	r16
    7454:	cf 93       	push	r28
    7456:	df 93       	push	r29
    7458:	cd b7       	in	r28, 0x3d	; 61
    745a:	de b7       	in	r29, 0x3e	; 62
    745c:	e9 97       	sbiw	r28, 0x39	; 57
    745e:	0f b6       	in	r0, 0x3f	; 63
    7460:	f8 94       	cli
    7462:	de bf       	out	0x3e, r29	; 62
    7464:	0f be       	out	0x3f, r0	; 63
    7466:	cd bf       	out	0x3d, r28	; 61
    7468:	9e ab       	std	Y+54, r25	; 0x36
    746a:	8d ab       	std	Y+53, r24	; 0x35
    746c:	6f ab       	std	Y+55, r22	; 0x37
    746e:	59 af       	std	Y+57, r21	; 0x39
    7470:	48 af       	std	Y+56, r20	; 0x38
    uint8_t buffer[32];
    memset(buffer, 0, 32);
    7472:	ce 01       	movw	r24, r28
    7474:	45 96       	adiw	r24, 0x15	; 21
    7476:	40 e2       	ldi	r20, 0x20	; 32
    7478:	50 e0       	ldi	r21, 0x00	; 0
    747a:	60 e0       	ldi	r22, 0x00	; 0
    747c:	70 e0       	ldi	r23, 0x00	; 0
    747e:	0e 94 19 b1 	call	0x16232	; 0x16232 <memset>
    IPAddress dest_addr( 255, 255, 255, 255 ); // Broadcast address
    7482:	ce 01       	movw	r24, r28
    7484:	09 96       	adiw	r24, 0x09	; 9
    7486:	0f ef       	ldi	r16, 0xFF	; 255
    7488:	2f ef       	ldi	r18, 0xFF	; 255
    748a:	4f ef       	ldi	r20, 0xFF	; 255
    748c:	6f ef       	ldi	r22, 0xFF	; 255
    748e:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>

    if (-1 == _dhcpUdpSocket.beginPacket(dest_addr, DHCP_SERVER_PORT))
    7492:	9e 01       	movw	r18, r28
    7494:	27 5f       	subi	r18, 0xF7	; 247
    7496:	3f 4f       	sbci	r19, 0xFF	; 255
    7498:	ce 01       	movw	r24, r28
    749a:	03 96       	adiw	r24, 0x03	; 3
    749c:	b9 01       	movw	r22, r18
    749e:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    74a2:	8d a9       	ldd	r24, Y+53	; 0x35
    74a4:	9e a9       	ldd	r25, Y+54	; 0x36
    74a6:	89 5b       	subi	r24, 0xB9	; 185
    74a8:	9f 4f       	sbci	r25, 0xFF	; 255
    74aa:	9e 01       	movw	r18, r28
    74ac:	2d 5f       	subi	r18, 0xFD	; 253
    74ae:	3f 4f       	sbci	r19, 0xFF	; 255
    74b0:	43 e4       	ldi	r20, 0x43	; 67
    74b2:	50 e0       	ldi	r21, 0x00	; 0
    74b4:	b9 01       	movw	r22, r18
    74b6:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <_ZN11EthernetUDP11beginPacketE9IPAddressj>
    74ba:	21 e0       	ldi	r18, 0x01	; 1
    74bc:	8f 3f       	cpi	r24, 0xFF	; 255
    74be:	3f ef       	ldi	r19, 0xFF	; 255
    74c0:	93 07       	cpc	r25, r19
    74c2:	09 f0       	breq	.+2      	; 0x74c6 <_ZN9DhcpClass17send_DHCP_MESSAGEEhj+0x74>
    74c4:	20 e0       	ldi	r18, 0x00	; 0
    74c6:	22 23       	and	r18, r18
    74c8:	09 f0       	breq	.+2      	; 0x74cc <_ZN9DhcpClass17send_DHCP_MESSAGEEhj+0x7a>
    74ca:	84 c1       	rjmp	.+776    	; 0x77d4 <_ZN9DhcpClass17send_DHCP_MESSAGEEhj+0x382>
    {
        // FIXME Need to return errors
        return;
    }

    buffer[0] = DHCP_BOOTREQUEST;   // op
    74cc:	81 e0       	ldi	r24, 0x01	; 1
    74ce:	8d 8b       	std	Y+21, r24	; 0x15
    buffer[1] = DHCP_HTYPE10MB;     // htype
    74d0:	81 e0       	ldi	r24, 0x01	; 1
    74d2:	8e 8b       	std	Y+22, r24	; 0x16
    buffer[2] = DHCP_HLENETHERNET;  // hlen
    74d4:	86 e0       	ldi	r24, 0x06	; 6
    74d6:	8f 8b       	std	Y+23, r24	; 0x17
    buffer[3] = DHCP_HOPS;          // hops
    74d8:	18 8e       	std	Y+24, r1	; 0x18

    // xid
    unsigned long xid = htonl(_dhcpTransactionId);
    74da:	8d a9       	ldd	r24, Y+53	; 0x35
    74dc:	9e a9       	ldd	r25, Y+54	; 0x36
    74de:	fc 01       	movw	r30, r24
    74e0:	84 81       	ldd	r24, Z+4	; 0x04
    74e2:	95 81       	ldd	r25, Z+5	; 0x05
    74e4:	a6 81       	ldd	r26, Z+6	; 0x06
    74e6:	b7 81       	ldd	r27, Z+7	; 0x07
    74e8:	58 2f       	mov	r21, r24
    74ea:	44 27       	eor	r20, r20
    74ec:	33 27       	eor	r19, r19
    74ee:	22 27       	eor	r18, r18
    74f0:	8d a9       	ldd	r24, Y+53	; 0x35
    74f2:	9e a9       	ldd	r25, Y+54	; 0x36
    74f4:	fc 01       	movw	r30, r24
    74f6:	84 81       	ldd	r24, Z+4	; 0x04
    74f8:	95 81       	ldd	r25, Z+5	; 0x05
    74fa:	a6 81       	ldd	r26, Z+6	; 0x06
    74fc:	b7 81       	ldd	r27, Z+7	; 0x07
    74fe:	ba 2f       	mov	r27, r26
    7500:	a9 2f       	mov	r26, r25
    7502:	98 2f       	mov	r25, r24
    7504:	88 27       	eor	r24, r24
    7506:	88 27       	eor	r24, r24
    7508:	99 27       	eor	r25, r25
    750a:	bb 27       	eor	r27, r27
    750c:	28 2b       	or	r18, r24
    750e:	39 2b       	or	r19, r25
    7510:	4a 2b       	or	r20, r26
    7512:	5b 2b       	or	r21, r27
    7514:	8d a9       	ldd	r24, Y+53	; 0x35
    7516:	9e a9       	ldd	r25, Y+54	; 0x36
    7518:	fc 01       	movw	r30, r24
    751a:	84 81       	ldd	r24, Z+4	; 0x04
    751c:	95 81       	ldd	r25, Z+5	; 0x05
    751e:	a6 81       	ldd	r26, Z+6	; 0x06
    7520:	b7 81       	ldd	r27, Z+7	; 0x07
    7522:	89 2f       	mov	r24, r25
    7524:	9a 2f       	mov	r25, r26
    7526:	ab 2f       	mov	r26, r27
    7528:	bb 27       	eor	r27, r27
    752a:	88 27       	eor	r24, r24
    752c:	aa 27       	eor	r26, r26
    752e:	bb 27       	eor	r27, r27
    7530:	28 2b       	or	r18, r24
    7532:	39 2b       	or	r19, r25
    7534:	4a 2b       	or	r20, r26
    7536:	5b 2b       	or	r21, r27
    7538:	8d a9       	ldd	r24, Y+53	; 0x35
    753a:	9e a9       	ldd	r25, Y+54	; 0x36
    753c:	fc 01       	movw	r30, r24
    753e:	84 81       	ldd	r24, Z+4	; 0x04
    7540:	95 81       	ldd	r25, Z+5	; 0x05
    7542:	a6 81       	ldd	r26, Z+6	; 0x06
    7544:	b7 81       	ldd	r27, Z+7	; 0x07
    7546:	8b 2f       	mov	r24, r27
    7548:	99 27       	eor	r25, r25
    754a:	aa 27       	eor	r26, r26
    754c:	bb 27       	eor	r27, r27
    754e:	82 2b       	or	r24, r18
    7550:	93 2b       	or	r25, r19
    7552:	a4 2b       	or	r26, r20
    7554:	b5 2b       	or	r27, r21
    7556:	8f 87       	std	Y+15, r24	; 0x0f
    7558:	98 8b       	std	Y+16, r25	; 0x10
    755a:	a9 8b       	std	Y+17, r26	; 0x11
    755c:	ba 8b       	std	Y+18, r27	; 0x12
    memcpy(buffer + 4, &(xid), 4);
    755e:	9e 01       	movw	r18, r28
    7560:	2b 5e       	subi	r18, 0xEB	; 235
    7562:	3f 4f       	sbci	r19, 0xFF	; 255
    7564:	2c 5f       	subi	r18, 0xFC	; 252
    7566:	3f 4f       	sbci	r19, 0xFF	; 255
    7568:	8f 85       	ldd	r24, Y+15	; 0x0f
    756a:	98 89       	ldd	r25, Y+16	; 0x10
    756c:	a9 89       	ldd	r26, Y+17	; 0x11
    756e:	ba 89       	ldd	r27, Y+18	; 0x12
    7570:	f9 01       	movw	r30, r18
    7572:	80 83       	st	Z, r24
    7574:	91 83       	std	Z+1, r25	; 0x01
    7576:	a2 83       	std	Z+2, r26	; 0x02
    7578:	b3 83       	std	Z+3, r27	; 0x03

    // 8, 9 - seconds elapsed
    buffer[8] = ((secondsElapsed & 0xff00) >> 8);
    757a:	88 ad       	ldd	r24, Y+56	; 0x38
    757c:	99 ad       	ldd	r25, Y+57	; 0x39
    757e:	89 2f       	mov	r24, r25
    7580:	99 27       	eor	r25, r25
    7582:	8d 8f       	std	Y+29, r24	; 0x1d
    buffer[9] = (secondsElapsed & 0x00ff);
    7584:	88 ad       	ldd	r24, Y+56	; 0x38
    7586:	8e 8f       	std	Y+30, r24	; 0x1e

    // flags
    unsigned short flags = htons(DHCP_FLAGSBROADCAST);
    7588:	80 e8       	ldi	r24, 0x80	; 128
    758a:	90 e0       	ldi	r25, 0x00	; 0
    758c:	9c 8b       	std	Y+20, r25	; 0x14
    758e:	8b 8b       	std	Y+19, r24	; 0x13
    memcpy(buffer + 10, &(flags), 2);
    7590:	ce 01       	movw	r24, r28
    7592:	45 96       	adiw	r24, 0x15	; 21
    7594:	0a 96       	adiw	r24, 0x0a	; 10
    7596:	2b 89       	ldd	r18, Y+19	; 0x13
    7598:	3c 89       	ldd	r19, Y+20	; 0x14
    759a:	fc 01       	movw	r30, r24
    759c:	31 83       	std	Z+1, r19	; 0x01
    759e:	20 83       	st	Z, r18
    // yiaddr: already zeroed
    // siaddr: already zeroed
    // giaddr: already zeroed

    //put data in W5100 transmit buffer
    _dhcpUdpSocket.write(buffer, 28);
    75a0:	8d a9       	ldd	r24, Y+53	; 0x35
    75a2:	9e a9       	ldd	r25, Y+54	; 0x36
    75a4:	89 5b       	subi	r24, 0xB9	; 185
    75a6:	9f 4f       	sbci	r25, 0xFF	; 255
    75a8:	9e 01       	movw	r18, r28
    75aa:	2b 5e       	subi	r18, 0xEB	; 235
    75ac:	3f 4f       	sbci	r19, 0xFF	; 255
    75ae:	4c e1       	ldi	r20, 0x1C	; 28
    75b0:	50 e0       	ldi	r21, 0x00	; 0
    75b2:	b9 01       	movw	r22, r18
    75b4:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>

    memset(buffer, 0, 32); // clear local buffer
    75b8:	ce 01       	movw	r24, r28
    75ba:	45 96       	adiw	r24, 0x15	; 21
    75bc:	40 e2       	ldi	r20, 0x20	; 32
    75be:	50 e0       	ldi	r21, 0x00	; 0
    75c0:	60 e0       	ldi	r22, 0x00	; 0
    75c2:	70 e0       	ldi	r23, 0x00	; 0
    75c4:	0e 94 19 b1 	call	0x16232	; 0x16232 <memset>

    memcpy(buffer, _dhcpMacAddr, 6); // chaddr
    75c8:	8d a9       	ldd	r24, Y+53	; 0x35
    75ca:	9e a9       	ldd	r25, Y+54	; 0x36
    75cc:	9c 01       	movw	r18, r24
    75ce:	28 5f       	subi	r18, 0xF8	; 248
    75d0:	3f 4f       	sbci	r19, 0xFF	; 255
    75d2:	ce 01       	movw	r24, r28
    75d4:	45 96       	adiw	r24, 0x15	; 21
    75d6:	46 e0       	ldi	r20, 0x06	; 6
    75d8:	50 e0       	ldi	r21, 0x00	; 0
    75da:	b9 01       	movw	r22, r18
    75dc:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>

    //put data in W5100 transmit buffer
    _dhcpUdpSocket.write(buffer, 16);
    75e0:	8d a9       	ldd	r24, Y+53	; 0x35
    75e2:	9e a9       	ldd	r25, Y+54	; 0x36
    75e4:	89 5b       	subi	r24, 0xB9	; 185
    75e6:	9f 4f       	sbci	r25, 0xFF	; 255
    75e8:	9e 01       	movw	r18, r28
    75ea:	2b 5e       	subi	r18, 0xEB	; 235
    75ec:	3f 4f       	sbci	r19, 0xFF	; 255
    75ee:	40 e1       	ldi	r20, 0x10	; 16
    75f0:	50 e0       	ldi	r21, 0x00	; 0
    75f2:	b9 01       	movw	r22, r18
    75f4:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>

    memset(buffer, 0, 32); // clear local buffer
    75f8:	ce 01       	movw	r24, r28
    75fa:	45 96       	adiw	r24, 0x15	; 21
    75fc:	40 e2       	ldi	r20, 0x20	; 32
    75fe:	50 e0       	ldi	r21, 0x00	; 0
    7600:	60 e0       	ldi	r22, 0x00	; 0
    7602:	70 e0       	ldi	r23, 0x00	; 0
    7604:	0e 94 19 b1 	call	0x16232	; 0x16232 <memset>

    // leave zeroed out for sname && file
    // put in W5100 transmit buffer x 6 (192 bytes)
  
    for(int i = 0; i < 6; i++) {
    7608:	1a 82       	std	Y+2, r1	; 0x02
    760a:	19 82       	std	Y+1, r1	; 0x01
    760c:	11 c0       	rjmp	.+34     	; 0x7630 <_ZN9DhcpClass17send_DHCP_MESSAGEEhj+0x1de>
        _dhcpUdpSocket.write(buffer, 32);
    760e:	8d a9       	ldd	r24, Y+53	; 0x35
    7610:	9e a9       	ldd	r25, Y+54	; 0x36
    7612:	89 5b       	subi	r24, 0xB9	; 185
    7614:	9f 4f       	sbci	r25, 0xFF	; 255
    7616:	9e 01       	movw	r18, r28
    7618:	2b 5e       	subi	r18, 0xEB	; 235
    761a:	3f 4f       	sbci	r19, 0xFF	; 255
    761c:	40 e2       	ldi	r20, 0x20	; 32
    761e:	50 e0       	ldi	r21, 0x00	; 0
    7620:	b9 01       	movw	r22, r18
    7622:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>
    memset(buffer, 0, 32); // clear local buffer

    // leave zeroed out for sname && file
    // put in W5100 transmit buffer x 6 (192 bytes)
  
    for(int i = 0; i < 6; i++) {
    7626:	89 81       	ldd	r24, Y+1	; 0x01
    7628:	9a 81       	ldd	r25, Y+2	; 0x02
    762a:	01 96       	adiw	r24, 0x01	; 1
    762c:	9a 83       	std	Y+2, r25	; 0x02
    762e:	89 83       	std	Y+1, r24	; 0x01
    7630:	21 e0       	ldi	r18, 0x01	; 1
    7632:	89 81       	ldd	r24, Y+1	; 0x01
    7634:	9a 81       	ldd	r25, Y+2	; 0x02
    7636:	86 30       	cpi	r24, 0x06	; 6
    7638:	91 05       	cpc	r25, r1
    763a:	0c f0       	brlt	.+2      	; 0x763e <_ZN9DhcpClass17send_DHCP_MESSAGEEhj+0x1ec>
    763c:	20 e0       	ldi	r18, 0x00	; 0
    763e:	22 23       	and	r18, r18
    7640:	31 f7       	brne	.-52     	; 0x760e <_ZN9DhcpClass17send_DHCP_MESSAGEEhj+0x1bc>
        _dhcpUdpSocket.write(buffer, 32);
    }
  
    // OPT - Magic Cookie
    buffer[0] = (uint8_t)((MAGIC_COOKIE >> 24)& 0xFF);
    7642:	83 e6       	ldi	r24, 0x63	; 99
    7644:	8d 8b       	std	Y+21, r24	; 0x15
    buffer[1] = (uint8_t)((MAGIC_COOKIE >> 16)& 0xFF);
    7646:	82 e8       	ldi	r24, 0x82	; 130
    7648:	8e 8b       	std	Y+22, r24	; 0x16
    buffer[2] = (uint8_t)((MAGIC_COOKIE >> 8)& 0xFF);
    764a:	83 e5       	ldi	r24, 0x53	; 83
    764c:	8f 8b       	std	Y+23, r24	; 0x17
    buffer[3] = (uint8_t)(MAGIC_COOKIE& 0xFF);
    764e:	83 e6       	ldi	r24, 0x63	; 99
    7650:	88 8f       	std	Y+24, r24	; 0x18

    // OPT - message type
    buffer[4] = dhcpMessageType;
    7652:	85 e3       	ldi	r24, 0x35	; 53
    7654:	89 8f       	std	Y+25, r24	; 0x19
    buffer[5] = 0x01;
    7656:	81 e0       	ldi	r24, 0x01	; 1
    7658:	8a 8f       	std	Y+26, r24	; 0x1a
    buffer[6] = messageType; //DHCP_REQUEST;
    765a:	8f a9       	ldd	r24, Y+55	; 0x37
    765c:	8b 8f       	std	Y+27, r24	; 0x1b

    // OPT - client identifier
    buffer[7] = dhcpClientIdentifier;
    765e:	8d e3       	ldi	r24, 0x3D	; 61
    7660:	8c 8f       	std	Y+28, r24	; 0x1c
    buffer[8] = 0x07;
    7662:	87 e0       	ldi	r24, 0x07	; 7
    7664:	8d 8f       	std	Y+29, r24	; 0x1d
    buffer[9] = 0x01;
    7666:	81 e0       	ldi	r24, 0x01	; 1
    7668:	8e 8f       	std	Y+30, r24	; 0x1e
    memcpy(buffer + 10, _dhcpMacAddr, 6);
    766a:	8d a9       	ldd	r24, Y+53	; 0x35
    766c:	9e a9       	ldd	r25, Y+54	; 0x36
    766e:	9c 01       	movw	r18, r24
    7670:	28 5f       	subi	r18, 0xF8	; 248
    7672:	3f 4f       	sbci	r19, 0xFF	; 255
    7674:	ce 01       	movw	r24, r28
    7676:	45 96       	adiw	r24, 0x15	; 21
    7678:	0a 96       	adiw	r24, 0x0a	; 10
    767a:	46 e0       	ldi	r20, 0x06	; 6
    767c:	50 e0       	ldi	r21, 0x00	; 0
    767e:	b9 01       	movw	r22, r18
    7680:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>

    // OPT - host name
    buffer[16] = hostName;
    7684:	8c e0       	ldi	r24, 0x0C	; 12
    7686:	8d a3       	std	Y+37, r24	; 0x25
    buffer[17] = strlen(HOST_NAME) + 6; // length of hostname + last 3 bytes of mac address
    7688:	8c e0       	ldi	r24, 0x0C	; 12
    768a:	8e a3       	std	Y+38, r24	; 0x26
    strcpy((char*)&(buffer[18]), HOST_NAME);
    768c:	ce 01       	movw	r24, r28
    768e:	45 96       	adiw	r24, 0x15	; 21
    7690:	42 96       	adiw	r24, 0x12	; 18
    7692:	27 e0       	ldi	r18, 0x07	; 7
    7694:	ee e2       	ldi	r30, 0x2E	; 46
    7696:	f3 e0       	ldi	r31, 0x03	; 3
    7698:	dc 01       	movw	r26, r24
    769a:	01 90       	ld	r0, Z+
    769c:	0d 92       	st	X+, r0
    769e:	2a 95       	dec	r18
    76a0:	e1 f7       	brne	.-8      	; 0x769a <_ZN9DhcpClass17send_DHCP_MESSAGEEhj+0x248>

    printByte((char*)&(buffer[24]), _dhcpMacAddr[3]);
    76a2:	8d a9       	ldd	r24, Y+53	; 0x35
    76a4:	9e a9       	ldd	r25, Y+54	; 0x36
    76a6:	fc 01       	movw	r30, r24
    76a8:	43 85       	ldd	r20, Z+11	; 0x0b
    76aa:	ce 01       	movw	r24, r28
    76ac:	45 96       	adiw	r24, 0x15	; 21
    76ae:	9c 01       	movw	r18, r24
    76b0:	28 5e       	subi	r18, 0xE8	; 232
    76b2:	3f 4f       	sbci	r19, 0xFF	; 255
    76b4:	8d a9       	ldd	r24, Y+53	; 0x35
    76b6:	9e a9       	ldd	r25, Y+54	; 0x36
    76b8:	b9 01       	movw	r22, r18
    76ba:	0e 94 8b 41 	call	0x8316	; 0x8316 <_ZN9DhcpClass9printByteEPch>
    printByte((char*)&(buffer[26]), _dhcpMacAddr[4]);
    76be:	8d a9       	ldd	r24, Y+53	; 0x35
    76c0:	9e a9       	ldd	r25, Y+54	; 0x36
    76c2:	fc 01       	movw	r30, r24
    76c4:	44 85       	ldd	r20, Z+12	; 0x0c
    76c6:	ce 01       	movw	r24, r28
    76c8:	45 96       	adiw	r24, 0x15	; 21
    76ca:	9c 01       	movw	r18, r24
    76cc:	26 5e       	subi	r18, 0xE6	; 230
    76ce:	3f 4f       	sbci	r19, 0xFF	; 255
    76d0:	8d a9       	ldd	r24, Y+53	; 0x35
    76d2:	9e a9       	ldd	r25, Y+54	; 0x36
    76d4:	b9 01       	movw	r22, r18
    76d6:	0e 94 8b 41 	call	0x8316	; 0x8316 <_ZN9DhcpClass9printByteEPch>
    printByte((char*)&(buffer[28]), _dhcpMacAddr[5]);
    76da:	8d a9       	ldd	r24, Y+53	; 0x35
    76dc:	9e a9       	ldd	r25, Y+54	; 0x36
    76de:	fc 01       	movw	r30, r24
    76e0:	45 85       	ldd	r20, Z+13	; 0x0d
    76e2:	ce 01       	movw	r24, r28
    76e4:	45 96       	adiw	r24, 0x15	; 21
    76e6:	9c 01       	movw	r18, r24
    76e8:	24 5e       	subi	r18, 0xE4	; 228
    76ea:	3f 4f       	sbci	r19, 0xFF	; 255
    76ec:	8d a9       	ldd	r24, Y+53	; 0x35
    76ee:	9e a9       	ldd	r25, Y+54	; 0x36
    76f0:	b9 01       	movw	r22, r18
    76f2:	0e 94 8b 41 	call	0x8316	; 0x8316 <_ZN9DhcpClass9printByteEPch>

    //put data in W5100 transmit buffer
    _dhcpUdpSocket.write(buffer, 30);
    76f6:	8d a9       	ldd	r24, Y+53	; 0x35
    76f8:	9e a9       	ldd	r25, Y+54	; 0x36
    76fa:	89 5b       	subi	r24, 0xB9	; 185
    76fc:	9f 4f       	sbci	r25, 0xFF	; 255
    76fe:	9e 01       	movw	r18, r28
    7700:	2b 5e       	subi	r18, 0xEB	; 235
    7702:	3f 4f       	sbci	r19, 0xFF	; 255
    7704:	4e e1       	ldi	r20, 0x1E	; 30
    7706:	50 e0       	ldi	r21, 0x00	; 0
    7708:	b9 01       	movw	r22, r18
    770a:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>

    if(messageType == DHCP_REQUEST)
    770e:	8f a9       	ldd	r24, Y+55	; 0x37
    7710:	83 30       	cpi	r24, 0x03	; 3
    7712:	e1 f5       	brne	.+120    	; 0x778c <_ZN9DhcpClass17send_DHCP_MESSAGEEhj+0x33a>
    {
        buffer[0] = dhcpRequestedIPaddr;
    7714:	82 e3       	ldi	r24, 0x32	; 50
    7716:	8d 8b       	std	Y+21, r24	; 0x15
        buffer[1] = 0x04;
    7718:	84 e0       	ldi	r24, 0x04	; 4
    771a:	8e 8b       	std	Y+22, r24	; 0x16
        buffer[2] = _dhcpLocalIp[0];
    771c:	8d a9       	ldd	r24, Y+53	; 0x35
    771e:	9e a9       	ldd	r25, Y+54	; 0x36
    7720:	fc 01       	movw	r30, r24
    7722:	86 85       	ldd	r24, Z+14	; 0x0e
    7724:	8f 8b       	std	Y+23, r24	; 0x17
        buffer[3] = _dhcpLocalIp[1];
    7726:	8d a9       	ldd	r24, Y+53	; 0x35
    7728:	9e a9       	ldd	r25, Y+54	; 0x36
    772a:	fc 01       	movw	r30, r24
    772c:	87 85       	ldd	r24, Z+15	; 0x0f
    772e:	88 8f       	std	Y+24, r24	; 0x18
        buffer[4] = _dhcpLocalIp[2];
    7730:	8d a9       	ldd	r24, Y+53	; 0x35
    7732:	9e a9       	ldd	r25, Y+54	; 0x36
    7734:	fc 01       	movw	r30, r24
    7736:	80 89       	ldd	r24, Z+16	; 0x10
    7738:	89 8f       	std	Y+25, r24	; 0x19
        buffer[5] = _dhcpLocalIp[3];
    773a:	8d a9       	ldd	r24, Y+53	; 0x35
    773c:	9e a9       	ldd	r25, Y+54	; 0x36
    773e:	fc 01       	movw	r30, r24
    7740:	81 89       	ldd	r24, Z+17	; 0x11
    7742:	8a 8f       	std	Y+26, r24	; 0x1a

        buffer[6] = dhcpServerIdentifier;
    7744:	86 e3       	ldi	r24, 0x36	; 54
    7746:	8b 8f       	std	Y+27, r24	; 0x1b
        buffer[7] = 0x04;
    7748:	84 e0       	ldi	r24, 0x04	; 4
    774a:	8c 8f       	std	Y+28, r24	; 0x1c
        buffer[8] = _dhcpDhcpServerIp[0];
    774c:	8d a9       	ldd	r24, Y+53	; 0x35
    774e:	9e a9       	ldd	r25, Y+54	; 0x36
    7750:	fc 01       	movw	r30, r24
    7752:	82 8d       	ldd	r24, Z+26	; 0x1a
    7754:	8d 8f       	std	Y+29, r24	; 0x1d
        buffer[9] = _dhcpDhcpServerIp[1];
    7756:	8d a9       	ldd	r24, Y+53	; 0x35
    7758:	9e a9       	ldd	r25, Y+54	; 0x36
    775a:	fc 01       	movw	r30, r24
    775c:	83 8d       	ldd	r24, Z+27	; 0x1b
    775e:	8e 8f       	std	Y+30, r24	; 0x1e
        buffer[10] = _dhcpDhcpServerIp[2];
    7760:	8d a9       	ldd	r24, Y+53	; 0x35
    7762:	9e a9       	ldd	r25, Y+54	; 0x36
    7764:	fc 01       	movw	r30, r24
    7766:	84 8d       	ldd	r24, Z+28	; 0x1c
    7768:	8f 8f       	std	Y+31, r24	; 0x1f
        buffer[11] = _dhcpDhcpServerIp[3];
    776a:	8d a9       	ldd	r24, Y+53	; 0x35
    776c:	9e a9       	ldd	r25, Y+54	; 0x36
    776e:	fc 01       	movw	r30, r24
    7770:	85 8d       	ldd	r24, Z+29	; 0x1d
    7772:	88 a3       	std	Y+32, r24	; 0x20

        //put data in W5100 transmit buffer
        _dhcpUdpSocket.write(buffer, 12);
    7774:	8d a9       	ldd	r24, Y+53	; 0x35
    7776:	9e a9       	ldd	r25, Y+54	; 0x36
    7778:	89 5b       	subi	r24, 0xB9	; 185
    777a:	9f 4f       	sbci	r25, 0xFF	; 255
    777c:	9e 01       	movw	r18, r28
    777e:	2b 5e       	subi	r18, 0xEB	; 235
    7780:	3f 4f       	sbci	r19, 0xFF	; 255
    7782:	4c e0       	ldi	r20, 0x0C	; 12
    7784:	50 e0       	ldi	r21, 0x00	; 0
    7786:	b9 01       	movw	r22, r18
    7788:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>
    }
    
    buffer[0] = dhcpParamRequest;
    778c:	87 e3       	ldi	r24, 0x37	; 55
    778e:	8d 8b       	std	Y+21, r24	; 0x15
    buffer[1] = 0x06;
    7790:	86 e0       	ldi	r24, 0x06	; 6
    7792:	8e 8b       	std	Y+22, r24	; 0x16
    buffer[2] = subnetMask;
    7794:	81 e0       	ldi	r24, 0x01	; 1
    7796:	8f 8b       	std	Y+23, r24	; 0x17
    buffer[3] = routersOnSubnet;
    7798:	83 e0       	ldi	r24, 0x03	; 3
    779a:	88 8f       	std	Y+24, r24	; 0x18
    buffer[4] = dns;
    779c:	86 e0       	ldi	r24, 0x06	; 6
    779e:	89 8f       	std	Y+25, r24	; 0x19
    buffer[5] = domainName;
    77a0:	8f e0       	ldi	r24, 0x0F	; 15
    77a2:	8a 8f       	std	Y+26, r24	; 0x1a
    buffer[6] = dhcpT1value;
    77a4:	8a e3       	ldi	r24, 0x3A	; 58
    77a6:	8b 8f       	std	Y+27, r24	; 0x1b
    buffer[7] = dhcpT2value;
    77a8:	8b e3       	ldi	r24, 0x3B	; 59
    77aa:	8c 8f       	std	Y+28, r24	; 0x1c
    buffer[8] = endOption;
    77ac:	8f ef       	ldi	r24, 0xFF	; 255
    77ae:	8d 8f       	std	Y+29, r24	; 0x1d
    
    //put data in W5100 transmit buffer
    _dhcpUdpSocket.write(buffer, 9);
    77b0:	8d a9       	ldd	r24, Y+53	; 0x35
    77b2:	9e a9       	ldd	r25, Y+54	; 0x36
    77b4:	89 5b       	subi	r24, 0xB9	; 185
    77b6:	9f 4f       	sbci	r25, 0xFF	; 255
    77b8:	9e 01       	movw	r18, r28
    77ba:	2b 5e       	subi	r18, 0xEB	; 235
    77bc:	3f 4f       	sbci	r19, 0xFF	; 255
    77be:	49 e0       	ldi	r20, 0x09	; 9
    77c0:	50 e0       	ldi	r21, 0x00	; 0
    77c2:	b9 01       	movw	r22, r18
    77c4:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>

    _dhcpUdpSocket.endPacket();
    77c8:	8d a9       	ldd	r24, Y+53	; 0x35
    77ca:	9e a9       	ldd	r25, Y+54	; 0x36
    77cc:	89 5b       	subi	r24, 0xB9	; 185
    77ce:	9f 4f       	sbci	r25, 0xFF	; 255
    77d0:	0e 94 2b 51 	call	0xa256	; 0xa256 <_ZN11EthernetUDP9endPacketEv>
}
    77d4:	e9 96       	adiw	r28, 0x39	; 57
    77d6:	0f b6       	in	r0, 0x3f	; 63
    77d8:	f8 94       	cli
    77da:	de bf       	out	0x3e, r29	; 62
    77dc:	0f be       	out	0x3f, r0	; 63
    77de:	cd bf       	out	0x3d, r28	; 61
    77e0:	df 91       	pop	r29
    77e2:	cf 91       	pop	r28
    77e4:	0f 91       	pop	r16
    77e6:	08 95       	ret

000077e8 <_ZN9DhcpClass17parseDHCPResponseEmRm>:

uint8_t DhcpClass::parseDHCPResponse(unsigned long responseTimeout, uint32_t& transactionId)
{
    77e8:	cf 93       	push	r28
    77ea:	df 93       	push	r29
    77ec:	cd b7       	in	r28, 0x3d	; 61
    77ee:	de b7       	in	r29, 0x3e	; 62
    77f0:	c2 54       	subi	r28, 0x42	; 66
    77f2:	d1 09       	sbc	r29, r1
    77f4:	0f b6       	in	r0, 0x3f	; 63
    77f6:	f8 94       	cli
    77f8:	de bf       	out	0x3e, r29	; 62
    77fa:	0f be       	out	0x3f, r0	; 63
    77fc:	cd bf       	out	0x3d, r28	; 61
    77fe:	9c af       	std	Y+60, r25	; 0x3c
    7800:	8b af       	std	Y+59, r24	; 0x3b
    7802:	ce 01       	movw	r24, r28
    7804:	cd 96       	adiw	r24, 0x3d	; 61
    7806:	fc 01       	movw	r30, r24
    7808:	40 83       	st	Z, r20
    780a:	51 83       	std	Z+1, r21	; 0x01
    780c:	62 83       	std	Z+2, r22	; 0x02
    780e:	73 83       	std	Z+3, r23	; 0x03
    7810:	ce 01       	movw	r24, r28
    7812:	8f 5b       	subi	r24, 0xBF	; 191
    7814:	9f 4f       	sbci	r25, 0xFF	; 255
    7816:	fc 01       	movw	r30, r24
    7818:	31 83       	std	Z+1, r19	; 0x01
    781a:	20 83       	st	Z, r18
    uint8_t type = 0;
    781c:	19 82       	std	Y+1, r1	; 0x01
    uint8_t opt_len = 0;
    781e:	1a 82       	std	Y+2, r1	; 0x02
     
    unsigned long startTime = millis();
    7820:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    7824:	dc 01       	movw	r26, r24
    7826:	cb 01       	movw	r24, r22
    7828:	89 87       	std	Y+9, r24	; 0x09
    782a:	9a 87       	std	Y+10, r25	; 0x0a
    782c:	ab 87       	std	Y+11, r26	; 0x0b
    782e:	bc 87       	std	Y+12, r27	; 0x0c

    while(_dhcpUdpSocket.parsePacket() <= 0)
    7830:	24 c0       	rjmp	.+72     	; 0x787a <_ZN9DhcpClass17parseDHCPResponseEmRm+0x92>
    {
        if((millis() - startTime) > responseTimeout)
    7832:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    7836:	9b 01       	movw	r18, r22
    7838:	ac 01       	movw	r20, r24
    783a:	89 85       	ldd	r24, Y+9	; 0x09
    783c:	9a 85       	ldd	r25, Y+10	; 0x0a
    783e:	ab 85       	ldd	r26, Y+11	; 0x0b
    7840:	bc 85       	ldd	r27, Y+12	; 0x0c
    7842:	28 1b       	sub	r18, r24
    7844:	39 0b       	sbc	r19, r25
    7846:	4a 0b       	sbc	r20, r26
    7848:	5b 0b       	sbc	r21, r27
    784a:	61 e0       	ldi	r22, 0x01	; 1
    784c:	ce 01       	movw	r24, r28
    784e:	cd 96       	adiw	r24, 0x3d	; 61
    7850:	fc 01       	movw	r30, r24
    7852:	80 81       	ld	r24, Z
    7854:	91 81       	ldd	r25, Z+1	; 0x01
    7856:	a2 81       	ldd	r26, Z+2	; 0x02
    7858:	b3 81       	ldd	r27, Z+3	; 0x03
    785a:	82 17       	cp	r24, r18
    785c:	93 07       	cpc	r25, r19
    785e:	a4 07       	cpc	r26, r20
    7860:	b5 07       	cpc	r27, r21
    7862:	08 f0       	brcs	.+2      	; 0x7866 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x7e>
    7864:	60 e0       	ldi	r22, 0x00	; 0
    7866:	66 23       	and	r22, r22
    7868:	11 f0       	breq	.+4      	; 0x786e <_ZN9DhcpClass17parseDHCPResponseEmRm+0x86>
        {
            return 255;
    786a:	8f ef       	ldi	r24, 0xFF	; 255
    786c:	42 c3       	rjmp	.+1668   	; 0x7ef2 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x70a>
        }
        delay(50);
    786e:	62 e3       	ldi	r22, 0x32	; 50
    7870:	70 e0       	ldi	r23, 0x00	; 0
    7872:	80 e0       	ldi	r24, 0x00	; 0
    7874:	90 e0       	ldi	r25, 0x00	; 0
    7876:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
    uint8_t type = 0;
    uint8_t opt_len = 0;
     
    unsigned long startTime = millis();

    while(_dhcpUdpSocket.parsePacket() <= 0)
    787a:	8b ad       	ldd	r24, Y+59	; 0x3b
    787c:	9c ad       	ldd	r25, Y+60	; 0x3c
    787e:	89 5b       	subi	r24, 0xB9	; 185
    7880:	9f 4f       	sbci	r25, 0xFF	; 255
    7882:	0e 94 9f 51 	call	0xa33e	; 0xa33e <_ZN11EthernetUDP11parsePacketEv>
    7886:	21 e0       	ldi	r18, 0x01	; 1
    7888:	18 16       	cp	r1, r24
    788a:	19 06       	cpc	r1, r25
    788c:	0c f4       	brge	.+2      	; 0x7890 <_ZN9DhcpClass17parseDHCPResponseEmRm+0xa8>
    788e:	20 e0       	ldi	r18, 0x00	; 0
    7890:	22 23       	and	r18, r18
    7892:	79 f6       	brne	.-98     	; 0x7832 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x4a>
        }
        delay(50);
    }
    // start reading in the packet
    RIP_MSG_FIXED fixedMsg;
    _dhcpUdpSocket.read((uint8_t*)&fixedMsg, sizeof(RIP_MSG_FIXED));
    7894:	8b ad       	ldd	r24, Y+59	; 0x3b
    7896:	9c ad       	ldd	r25, Y+60	; 0x3c
    7898:	89 5b       	subi	r24, 0xB9	; 185
    789a:	9f 4f       	sbci	r25, 0xFF	; 255
    789c:	9e 01       	movw	r18, r28
    789e:	27 5e       	subi	r18, 0xE7	; 231
    78a0:	3f 4f       	sbci	r19, 0xFF	; 255
    78a2:	42 e2       	ldi	r20, 0x22	; 34
    78a4:	50 e0       	ldi	r21, 0x00	; 0
    78a6:	b9 01       	movw	r22, r18
    78a8:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
  
    if(fixedMsg.op == DHCP_BOOTREPLY && _dhcpUdpSocket.remotePort() == DHCP_SERVER_PORT)
    78ac:	89 8d       	ldd	r24, Y+25	; 0x19
    78ae:	82 30       	cpi	r24, 0x02	; 2
    78b0:	59 f4       	brne	.+22     	; 0x78c8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0xe0>
    78b2:	8b ad       	ldd	r24, Y+59	; 0x3b
    78b4:	9c ad       	ldd	r25, Y+60	; 0x3c
    78b6:	89 5b       	subi	r24, 0xB9	; 185
    78b8:	9f 4f       	sbci	r25, 0xFF	; 255
    78ba:	0e 94 50 aa 	call	0x154a0	; 0x154a0 <_ZN11EthernetUDP10remotePortEv>
    78be:	83 34       	cpi	r24, 0x43	; 67
    78c0:	91 05       	cpc	r25, r1
    78c2:	11 f4       	brne	.+4      	; 0x78c8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0xe0>
    78c4:	81 e0       	ldi	r24, 0x01	; 1
    78c6:	01 c0       	rjmp	.+2      	; 0x78ca <_ZN9DhcpClass17parseDHCPResponseEmRm+0xe2>
    78c8:	80 e0       	ldi	r24, 0x00	; 0
    78ca:	88 23       	and	r24, r24
    78cc:	09 f4       	brne	.+2      	; 0x78d0 <_ZN9DhcpClass17parseDHCPResponseEmRm+0xe8>
    78ce:	0a c3       	rjmp	.+1556   	; 0x7ee4 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6fc>
    {
        transactionId = ntohl(fixedMsg.xid);
    78d0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    78d2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    78d4:	af 8d       	ldd	r26, Y+31	; 0x1f
    78d6:	b8 a1       	ldd	r27, Y+32	; 0x20
    78d8:	58 2f       	mov	r21, r24
    78da:	44 27       	eor	r20, r20
    78dc:	33 27       	eor	r19, r19
    78de:	22 27       	eor	r18, r18
    78e0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    78e2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    78e4:	af 8d       	ldd	r26, Y+31	; 0x1f
    78e6:	b8 a1       	ldd	r27, Y+32	; 0x20
    78e8:	ba 2f       	mov	r27, r26
    78ea:	a9 2f       	mov	r26, r25
    78ec:	98 2f       	mov	r25, r24
    78ee:	88 27       	eor	r24, r24
    78f0:	88 27       	eor	r24, r24
    78f2:	99 27       	eor	r25, r25
    78f4:	bb 27       	eor	r27, r27
    78f6:	28 2b       	or	r18, r24
    78f8:	39 2b       	or	r19, r25
    78fa:	4a 2b       	or	r20, r26
    78fc:	5b 2b       	or	r21, r27
    78fe:	8d 8d       	ldd	r24, Y+29	; 0x1d
    7900:	9e 8d       	ldd	r25, Y+30	; 0x1e
    7902:	af 8d       	ldd	r26, Y+31	; 0x1f
    7904:	b8 a1       	ldd	r27, Y+32	; 0x20
    7906:	89 2f       	mov	r24, r25
    7908:	9a 2f       	mov	r25, r26
    790a:	ab 2f       	mov	r26, r27
    790c:	bb 27       	eor	r27, r27
    790e:	88 27       	eor	r24, r24
    7910:	aa 27       	eor	r26, r26
    7912:	bb 27       	eor	r27, r27
    7914:	28 2b       	or	r18, r24
    7916:	39 2b       	or	r19, r25
    7918:	4a 2b       	or	r20, r26
    791a:	5b 2b       	or	r21, r27
    791c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    791e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    7920:	af 8d       	ldd	r26, Y+31	; 0x1f
    7922:	b8 a1       	ldd	r27, Y+32	; 0x20
    7924:	8b 2f       	mov	r24, r27
    7926:	99 27       	eor	r25, r25
    7928:	aa 27       	eor	r26, r26
    792a:	bb 27       	eor	r27, r27
    792c:	82 2b       	or	r24, r18
    792e:	93 2b       	or	r25, r19
    7930:	a4 2b       	or	r26, r20
    7932:	b5 2b       	or	r27, r21
    7934:	9e 01       	movw	r18, r28
    7936:	2f 5b       	subi	r18, 0xBF	; 191
    7938:	3f 4f       	sbci	r19, 0xFF	; 255
    793a:	f9 01       	movw	r30, r18
    793c:	20 81       	ld	r18, Z
    793e:	31 81       	ldd	r19, Z+1	; 0x01
    7940:	f9 01       	movw	r30, r18
    7942:	80 83       	st	Z, r24
    7944:	91 83       	std	Z+1, r25	; 0x01
    7946:	a2 83       	std	Z+2, r26	; 0x02
    7948:	b3 83       	std	Z+3, r27	; 0x03
        if(memcmp(fixedMsg.chaddr, _dhcpMacAddr, 6) != 0 || (transactionId < _dhcpInitialTransactionId) || (transactionId > _dhcpTransactionId))
    794a:	8b ad       	ldd	r24, Y+59	; 0x3b
    794c:	9c ad       	ldd	r25, Y+60	; 0x3c
    794e:	9c 01       	movw	r18, r24
    7950:	28 5f       	subi	r18, 0xF8	; 248
    7952:	3f 4f       	sbci	r19, 0xFF	; 255
    7954:	ce 01       	movw	r24, r28
    7956:	49 96       	adiw	r24, 0x19	; 25
    7958:	4c 96       	adiw	r24, 0x1c	; 28
    795a:	46 e0       	ldi	r20, 0x06	; 6
    795c:	50 e0       	ldi	r21, 0x00	; 0
    795e:	b9 01       	movw	r22, r18
    7960:	0e 94 f1 b0 	call	0x161e2	; 0x161e2 <memcmp>
    7964:	00 97       	sbiw	r24, 0x00	; 0
    7966:	71 f5       	brne	.+92     	; 0x79c4 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x1dc>
    7968:	ce 01       	movw	r24, r28
    796a:	8f 5b       	subi	r24, 0xBF	; 191
    796c:	9f 4f       	sbci	r25, 0xFF	; 255
    796e:	fc 01       	movw	r30, r24
    7970:	80 81       	ld	r24, Z
    7972:	91 81       	ldd	r25, Z+1	; 0x01
    7974:	fc 01       	movw	r30, r24
    7976:	20 81       	ld	r18, Z
    7978:	31 81       	ldd	r19, Z+1	; 0x01
    797a:	42 81       	ldd	r20, Z+2	; 0x02
    797c:	53 81       	ldd	r21, Z+3	; 0x03
    797e:	8b ad       	ldd	r24, Y+59	; 0x3b
    7980:	9c ad       	ldd	r25, Y+60	; 0x3c
    7982:	fc 01       	movw	r30, r24
    7984:	80 81       	ld	r24, Z
    7986:	91 81       	ldd	r25, Z+1	; 0x01
    7988:	a2 81       	ldd	r26, Z+2	; 0x02
    798a:	b3 81       	ldd	r27, Z+3	; 0x03
    798c:	28 17       	cp	r18, r24
    798e:	39 07       	cpc	r19, r25
    7990:	4a 07       	cpc	r20, r26
    7992:	5b 07       	cpc	r21, r27
    7994:	b8 f0       	brcs	.+46     	; 0x79c4 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x1dc>
    7996:	ce 01       	movw	r24, r28
    7998:	8f 5b       	subi	r24, 0xBF	; 191
    799a:	9f 4f       	sbci	r25, 0xFF	; 255
    799c:	fc 01       	movw	r30, r24
    799e:	80 81       	ld	r24, Z
    79a0:	91 81       	ldd	r25, Z+1	; 0x01
    79a2:	fc 01       	movw	r30, r24
    79a4:	20 81       	ld	r18, Z
    79a6:	31 81       	ldd	r19, Z+1	; 0x01
    79a8:	42 81       	ldd	r20, Z+2	; 0x02
    79aa:	53 81       	ldd	r21, Z+3	; 0x03
    79ac:	8b ad       	ldd	r24, Y+59	; 0x3b
    79ae:	9c ad       	ldd	r25, Y+60	; 0x3c
    79b0:	fc 01       	movw	r30, r24
    79b2:	84 81       	ldd	r24, Z+4	; 0x04
    79b4:	95 81       	ldd	r25, Z+5	; 0x05
    79b6:	a6 81       	ldd	r26, Z+6	; 0x06
    79b8:	b7 81       	ldd	r27, Z+7	; 0x07
    79ba:	82 17       	cp	r24, r18
    79bc:	93 07       	cpc	r25, r19
    79be:	a4 07       	cpc	r26, r20
    79c0:	b5 07       	cpc	r27, r21
    79c2:	40 f4       	brcc	.+16     	; 0x79d4 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x1ec>
        {
            // Need to read the rest of the packet here regardless
            _dhcpUdpSocket.flush();
    79c4:	8b ad       	ldd	r24, Y+59	; 0x3b
    79c6:	9c ad       	ldd	r25, Y+60	; 0x3c
    79c8:	89 5b       	subi	r24, 0xB9	; 185
    79ca:	9f 4f       	sbci	r25, 0xFF	; 255
    79cc:	0e 94 fd 52 	call	0xa5fa	; 0xa5fa <_ZN11EthernetUDP5flushEv>
            return 0;
    79d0:	80 e0       	ldi	r24, 0x00	; 0
    79d2:	8f c2       	rjmp	.+1310   	; 0x7ef2 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x70a>
        }

        memcpy(_dhcpLocalIp, fixedMsg.yiaddr, 4);
    79d4:	8b ad       	ldd	r24, Y+59	; 0x3b
    79d6:	9c ad       	ldd	r25, Y+60	; 0x3c
    79d8:	9c 01       	movw	r18, r24
    79da:	22 5f       	subi	r18, 0xF2	; 242
    79dc:	3f 4f       	sbci	r19, 0xFF	; 255
    79de:	89 a5       	ldd	r24, Y+41	; 0x29
    79e0:	9a a5       	ldd	r25, Y+42	; 0x2a
    79e2:	ab a5       	ldd	r26, Y+43	; 0x2b
    79e4:	bc a5       	ldd	r27, Y+44	; 0x2c
    79e6:	f9 01       	movw	r30, r18
    79e8:	80 83       	st	Z, r24
    79ea:	91 83       	std	Z+1, r25	; 0x01
    79ec:	a2 83       	std	Z+2, r26	; 0x02
    79ee:	b3 83       	std	Z+3, r27	; 0x03

        // Skip to the option part
        // Doing this a byte at a time so we don't have to put a big buffer
        // on the stack (as we don't have lots of memory lying around)
        for (int i =0; i < (240 - (int)sizeof(RIP_MSG_FIXED)); i++)
    79f0:	1c 82       	std	Y+4, r1	; 0x04
    79f2:	1b 82       	std	Y+3, r1	; 0x03
    79f4:	0b c0       	rjmp	.+22     	; 0x7a0c <_ZN9DhcpClass17parseDHCPResponseEmRm+0x224>
        {
            _dhcpUdpSocket.read(); // we don't care about the returned byte
    79f6:	8b ad       	ldd	r24, Y+59	; 0x3b
    79f8:	9c ad       	ldd	r25, Y+60	; 0x3c
    79fa:	89 5b       	subi	r24, 0xB9	; 185
    79fc:	9f 4f       	sbci	r25, 0xFF	; 255
    79fe:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
        memcpy(_dhcpLocalIp, fixedMsg.yiaddr, 4);

        // Skip to the option part
        // Doing this a byte at a time so we don't have to put a big buffer
        // on the stack (as we don't have lots of memory lying around)
        for (int i =0; i < (240 - (int)sizeof(RIP_MSG_FIXED)); i++)
    7a02:	8b 81       	ldd	r24, Y+3	; 0x03
    7a04:	9c 81       	ldd	r25, Y+4	; 0x04
    7a06:	01 96       	adiw	r24, 0x01	; 1
    7a08:	9c 83       	std	Y+4, r25	; 0x04
    7a0a:	8b 83       	std	Y+3, r24	; 0x03
    7a0c:	21 e0       	ldi	r18, 0x01	; 1
    7a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    7a10:	9c 81       	ldd	r25, Y+4	; 0x04
    7a12:	8e 3c       	cpi	r24, 0xCE	; 206
    7a14:	91 05       	cpc	r25, r1
    7a16:	0c f0       	brlt	.+2      	; 0x7a1a <_ZN9DhcpClass17parseDHCPResponseEmRm+0x232>
    7a18:	20 e0       	ldi	r18, 0x00	; 0
    7a1a:	22 23       	and	r18, r18
    7a1c:	61 f7       	brne	.-40     	; 0x79f6 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x20e>
        {
            _dhcpUdpSocket.read(); // we don't care about the returned byte
        }

        while (_dhcpUdpSocket.available() > 0) 
    7a1e:	54 c2       	rjmp	.+1192   	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>
        {
            switch (_dhcpUdpSocket.read()) 
    7a20:	8b ad       	ldd	r24, Y+59	; 0x3b
    7a22:	9c ad       	ldd	r25, Y+60	; 0x3c
    7a24:	89 5b       	subi	r24, 0xB9	; 185
    7a26:	9f 4f       	sbci	r25, 0xFF	; 255
    7a28:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7a2c:	83 33       	cpi	r24, 0x33	; 51
    7a2e:	91 05       	cpc	r25, r1
    7a30:	09 f4       	brne	.+2      	; 0x7a34 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x24c>
    7a32:	c5 c1       	rjmp	.+906    	; 0x7dbe <_ZN9DhcpClass17parseDHCPResponseEmRm+0x5d6>
    7a34:	84 33       	cpi	r24, 0x34	; 52
    7a36:	91 05       	cpc	r25, r1
    7a38:	9c f4       	brge	.+38     	; 0x7a60 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x278>
    7a3a:	81 30       	cpi	r24, 0x01	; 1
    7a3c:	91 05       	cpc	r25, r1
    7a3e:	b9 f1       	breq	.+110    	; 0x7aae <_ZN9DhcpClass17parseDHCPResponseEmRm+0x2c6>
    7a40:	82 30       	cpi	r24, 0x02	; 2
    7a42:	91 05       	cpc	r25, r1
    7a44:	24 f4       	brge	.+8      	; 0x7a4e <_ZN9DhcpClass17parseDHCPResponseEmRm+0x266>
    7a46:	00 97       	sbiw	r24, 0x00	; 0
    7a48:	09 f4       	brne	.+2      	; 0x7a4c <_ZN9DhcpClass17parseDHCPResponseEmRm+0x264>
    7a4a:	3b c2       	rjmp	.+1142   	; 0x7ec2 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6da>
    7a4c:	21 c2       	rjmp	.+1090   	; 0x7e90 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6a8>
    7a4e:	83 30       	cpi	r24, 0x03	; 3
    7a50:	91 05       	cpc	r25, r1
    7a52:	09 f4       	brne	.+2      	; 0x7a56 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x26e>
    7a54:	42 c0       	rjmp	.+132    	; 0x7ada <_ZN9DhcpClass17parseDHCPResponseEmRm+0x2f2>
    7a56:	86 30       	cpi	r24, 0x06	; 6
    7a58:	91 05       	cpc	r25, r1
    7a5a:	09 f4       	brne	.+2      	; 0x7a5e <_ZN9DhcpClass17parseDHCPResponseEmRm+0x276>
    7a5c:	71 c0       	rjmp	.+226    	; 0x7b40 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x358>
    7a5e:	18 c2       	rjmp	.+1072   	; 0x7e90 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6a8>
    7a60:	8a 33       	cpi	r24, 0x3A	; 58
    7a62:	91 05       	cpc	r25, r1
    7a64:	09 f4       	brne	.+2      	; 0x7a68 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x280>
    7a66:	f5 c0       	rjmp	.+490    	; 0x7c52 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x46a>
    7a68:	8b 33       	cpi	r24, 0x3B	; 59
    7a6a:	91 05       	cpc	r25, r1
    7a6c:	44 f4       	brge	.+16     	; 0x7a7e <_ZN9DhcpClass17parseDHCPResponseEmRm+0x296>
    7a6e:	85 33       	cpi	r24, 0x35	; 53
    7a70:	91 05       	cpc	r25, r1
    7a72:	71 f0       	breq	.+28     	; 0x7a90 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x2a8>
    7a74:	86 33       	cpi	r24, 0x36	; 54
    7a76:	91 05       	cpc	r25, r1
    7a78:	09 f4       	brne	.+2      	; 0x7a7c <_ZN9DhcpClass17parseDHCPResponseEmRm+0x294>
    7a7a:	95 c0       	rjmp	.+298    	; 0x7ba6 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x3be>
    7a7c:	09 c2       	rjmp	.+1042   	; 0x7e90 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6a8>
    7a7e:	8b 33       	cpi	r24, 0x3B	; 59
    7a80:	91 05       	cpc	r25, r1
    7a82:	09 f4       	brne	.+2      	; 0x7a86 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x29e>
    7a84:	41 c1       	rjmp	.+642    	; 0x7d08 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x520>
    7a86:	8f 3f       	cpi	r24, 0xFF	; 255
    7a88:	91 05       	cpc	r25, r1
    7a8a:	09 f4       	brne	.+2      	; 0x7a8e <_ZN9DhcpClass17parseDHCPResponseEmRm+0x2a6>
    7a8c:	1c c2       	rjmp	.+1080   	; 0x7ec6 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6de>
    7a8e:	00 c2       	rjmp	.+1024   	; 0x7e90 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6a8>
                    
                case padOption :
                    break;
                
                case dhcpMessageType :
                    opt_len = _dhcpUdpSocket.read();
    7a90:	8b ad       	ldd	r24, Y+59	; 0x3b
    7a92:	9c ad       	ldd	r25, Y+60	; 0x3c
    7a94:	89 5b       	subi	r24, 0xB9	; 185
    7a96:	9f 4f       	sbci	r25, 0xFF	; 255
    7a98:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7a9c:	8a 83       	std	Y+2, r24	; 0x02
                    type = _dhcpUdpSocket.read();
    7a9e:	8b ad       	ldd	r24, Y+59	; 0x3b
    7aa0:	9c ad       	ldd	r25, Y+60	; 0x3c
    7aa2:	89 5b       	subi	r24, 0xB9	; 185
    7aa4:	9f 4f       	sbci	r25, 0xFF	; 255
    7aa6:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7aaa:	89 83       	std	Y+1, r24	; 0x01
                    break;
    7aac:	0d c2       	rjmp	.+1050   	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>
                
                case subnetMask :
                    opt_len = _dhcpUdpSocket.read();
    7aae:	8b ad       	ldd	r24, Y+59	; 0x3b
    7ab0:	9c ad       	ldd	r25, Y+60	; 0x3c
    7ab2:	89 5b       	subi	r24, 0xB9	; 185
    7ab4:	9f 4f       	sbci	r25, 0xFF	; 255
    7ab6:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7aba:	8a 83       	std	Y+2, r24	; 0x02
                    _dhcpUdpSocket.read(_dhcpSubnetMask, 4);
    7abc:	8b ad       	ldd	r24, Y+59	; 0x3b
    7abe:	9c ad       	ldd	r25, Y+60	; 0x3c
    7ac0:	9c 01       	movw	r18, r24
    7ac2:	2e 5e       	subi	r18, 0xEE	; 238
    7ac4:	3f 4f       	sbci	r19, 0xFF	; 255
    7ac6:	8b ad       	ldd	r24, Y+59	; 0x3b
    7ac8:	9c ad       	ldd	r25, Y+60	; 0x3c
    7aca:	89 5b       	subi	r24, 0xB9	; 185
    7acc:	9f 4f       	sbci	r25, 0xFF	; 255
    7ace:	44 e0       	ldi	r20, 0x04	; 4
    7ad0:	50 e0       	ldi	r21, 0x00	; 0
    7ad2:	b9 01       	movw	r22, r18
    7ad4:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
                    break;
    7ad8:	f7 c1       	rjmp	.+1006   	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>
                
                case routersOnSubnet :
                    opt_len = _dhcpUdpSocket.read();
    7ada:	8b ad       	ldd	r24, Y+59	; 0x3b
    7adc:	9c ad       	ldd	r25, Y+60	; 0x3c
    7ade:	89 5b       	subi	r24, 0xB9	; 185
    7ae0:	9f 4f       	sbci	r25, 0xFF	; 255
    7ae2:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7ae6:	8a 83       	std	Y+2, r24	; 0x02
                    _dhcpUdpSocket.read(_dhcpGatewayIp, 4);
    7ae8:	8b ad       	ldd	r24, Y+59	; 0x3b
    7aea:	9c ad       	ldd	r25, Y+60	; 0x3c
    7aec:	9c 01       	movw	r18, r24
    7aee:	2a 5e       	subi	r18, 0xEA	; 234
    7af0:	3f 4f       	sbci	r19, 0xFF	; 255
    7af2:	8b ad       	ldd	r24, Y+59	; 0x3b
    7af4:	9c ad       	ldd	r25, Y+60	; 0x3c
    7af6:	89 5b       	subi	r24, 0xB9	; 185
    7af8:	9f 4f       	sbci	r25, 0xFF	; 255
    7afa:	44 e0       	ldi	r20, 0x04	; 4
    7afc:	50 e0       	ldi	r21, 0x00	; 0
    7afe:	b9 01       	movw	r22, r18
    7b00:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
                    for (int i = 0; i < opt_len-4; i++)
    7b04:	1e 82       	std	Y+6, r1	; 0x06
    7b06:	1d 82       	std	Y+5, r1	; 0x05
    7b08:	0b c0       	rjmp	.+22     	; 0x7b20 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x338>
                    {
                        _dhcpUdpSocket.read();
    7b0a:	8b ad       	ldd	r24, Y+59	; 0x3b
    7b0c:	9c ad       	ldd	r25, Y+60	; 0x3c
    7b0e:	89 5b       	subi	r24, 0xB9	; 185
    7b10:	9f 4f       	sbci	r25, 0xFF	; 255
    7b12:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
                    break;
                
                case routersOnSubnet :
                    opt_len = _dhcpUdpSocket.read();
                    _dhcpUdpSocket.read(_dhcpGatewayIp, 4);
                    for (int i = 0; i < opt_len-4; i++)
    7b16:	8d 81       	ldd	r24, Y+5	; 0x05
    7b18:	9e 81       	ldd	r25, Y+6	; 0x06
    7b1a:	01 96       	adiw	r24, 0x01	; 1
    7b1c:	9e 83       	std	Y+6, r25	; 0x06
    7b1e:	8d 83       	std	Y+5, r24	; 0x05
    7b20:	8a 81       	ldd	r24, Y+2	; 0x02
    7b22:	88 2f       	mov	r24, r24
    7b24:	90 e0       	ldi	r25, 0x00	; 0
    7b26:	9c 01       	movw	r18, r24
    7b28:	24 50       	subi	r18, 0x04	; 4
    7b2a:	31 09       	sbc	r19, r1
    7b2c:	41 e0       	ldi	r20, 0x01	; 1
    7b2e:	8d 81       	ldd	r24, Y+5	; 0x05
    7b30:	9e 81       	ldd	r25, Y+6	; 0x06
    7b32:	82 17       	cp	r24, r18
    7b34:	93 07       	cpc	r25, r19
    7b36:	0c f0       	brlt	.+2      	; 0x7b3a <_ZN9DhcpClass17parseDHCPResponseEmRm+0x352>
    7b38:	40 e0       	ldi	r20, 0x00	; 0
    7b3a:	44 23       	and	r20, r20
    7b3c:	31 f7       	brne	.-52     	; 0x7b0a <_ZN9DhcpClass17parseDHCPResponseEmRm+0x322>
                    {
                        _dhcpUdpSocket.read();
                    }
                    break;
    7b3e:	c4 c1       	rjmp	.+904    	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>
                
                case dns :
                    opt_len = _dhcpUdpSocket.read();
    7b40:	8b ad       	ldd	r24, Y+59	; 0x3b
    7b42:	9c ad       	ldd	r25, Y+60	; 0x3c
    7b44:	89 5b       	subi	r24, 0xB9	; 185
    7b46:	9f 4f       	sbci	r25, 0xFF	; 255
    7b48:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7b4c:	8a 83       	std	Y+2, r24	; 0x02
                    _dhcpUdpSocket.read(_dhcpDnsServerIp, 4);
    7b4e:	8b ad       	ldd	r24, Y+59	; 0x3b
    7b50:	9c ad       	ldd	r25, Y+60	; 0x3c
    7b52:	9c 01       	movw	r18, r24
    7b54:	22 5e       	subi	r18, 0xE2	; 226
    7b56:	3f 4f       	sbci	r19, 0xFF	; 255
    7b58:	8b ad       	ldd	r24, Y+59	; 0x3b
    7b5a:	9c ad       	ldd	r25, Y+60	; 0x3c
    7b5c:	89 5b       	subi	r24, 0xB9	; 185
    7b5e:	9f 4f       	sbci	r25, 0xFF	; 255
    7b60:	44 e0       	ldi	r20, 0x04	; 4
    7b62:	50 e0       	ldi	r21, 0x00	; 0
    7b64:	b9 01       	movw	r22, r18
    7b66:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
                    for (int i = 0; i < opt_len-4; i++)
    7b6a:	18 86       	std	Y+8, r1	; 0x08
    7b6c:	1f 82       	std	Y+7, r1	; 0x07
    7b6e:	0b c0       	rjmp	.+22     	; 0x7b86 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x39e>
                    {
                        _dhcpUdpSocket.read();
    7b70:	8b ad       	ldd	r24, Y+59	; 0x3b
    7b72:	9c ad       	ldd	r25, Y+60	; 0x3c
    7b74:	89 5b       	subi	r24, 0xB9	; 185
    7b76:	9f 4f       	sbci	r25, 0xFF	; 255
    7b78:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
                    break;
                
                case dns :
                    opt_len = _dhcpUdpSocket.read();
                    _dhcpUdpSocket.read(_dhcpDnsServerIp, 4);
                    for (int i = 0; i < opt_len-4; i++)
    7b7c:	8f 81       	ldd	r24, Y+7	; 0x07
    7b7e:	98 85       	ldd	r25, Y+8	; 0x08
    7b80:	01 96       	adiw	r24, 0x01	; 1
    7b82:	98 87       	std	Y+8, r25	; 0x08
    7b84:	8f 83       	std	Y+7, r24	; 0x07
    7b86:	8a 81       	ldd	r24, Y+2	; 0x02
    7b88:	88 2f       	mov	r24, r24
    7b8a:	90 e0       	ldi	r25, 0x00	; 0
    7b8c:	9c 01       	movw	r18, r24
    7b8e:	24 50       	subi	r18, 0x04	; 4
    7b90:	31 09       	sbc	r19, r1
    7b92:	41 e0       	ldi	r20, 0x01	; 1
    7b94:	8f 81       	ldd	r24, Y+7	; 0x07
    7b96:	98 85       	ldd	r25, Y+8	; 0x08
    7b98:	82 17       	cp	r24, r18
    7b9a:	93 07       	cpc	r25, r19
    7b9c:	0c f0       	brlt	.+2      	; 0x7ba0 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x3b8>
    7b9e:	40 e0       	ldi	r20, 0x00	; 0
    7ba0:	44 23       	and	r20, r20
    7ba2:	31 f7       	brne	.-52     	; 0x7b70 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x388>
                    {
                        _dhcpUdpSocket.read();
                    }
                    break;
    7ba4:	91 c1       	rjmp	.+802    	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>
                
                case dhcpServerIdentifier :
                    opt_len = _dhcpUdpSocket.read();
    7ba6:	8b ad       	ldd	r24, Y+59	; 0x3b
    7ba8:	9c ad       	ldd	r25, Y+60	; 0x3c
    7baa:	89 5b       	subi	r24, 0xB9	; 185
    7bac:	9f 4f       	sbci	r25, 0xFF	; 255
    7bae:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7bb2:	8a 83       	std	Y+2, r24	; 0x02
                    if( *((uint32_t*)_dhcpDhcpServerIp) == 0 || 
    7bb4:	8b ad       	ldd	r24, Y+59	; 0x3b
    7bb6:	9c ad       	ldd	r25, Y+60	; 0x3c
    7bb8:	4a 96       	adiw	r24, 0x1a	; 26
    7bba:	fc 01       	movw	r30, r24
    7bbc:	80 81       	ld	r24, Z
    7bbe:	91 81       	ldd	r25, Z+1	; 0x01
    7bc0:	a2 81       	ldd	r26, Z+2	; 0x02
    7bc2:	b3 81       	ldd	r27, Z+3	; 0x03
    7bc4:	00 97       	sbiw	r24, 0x00	; 0
    7bc6:	a1 05       	cpc	r26, r1
    7bc8:	b1 05       	cpc	r27, r1
    7bca:	f1 f0       	breq	.+60     	; 0x7c08 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x420>
                        IPAddress(_dhcpDhcpServerIp) == _dhcpUdpSocket.remoteIP() )
    7bcc:	8b ad       	ldd	r24, Y+59	; 0x3b
    7bce:	9c ad       	ldd	r25, Y+60	; 0x3c
    7bd0:	9c 01       	movw	r18, r24
    7bd2:	29 5b       	subi	r18, 0xB9	; 185
    7bd4:	3f 4f       	sbci	r19, 0xFF	; 255
    7bd6:	ce 01       	movw	r24, r28
    7bd8:	43 96       	adiw	r24, 0x13	; 19
    7bda:	b9 01       	movw	r22, r18
    7bdc:	0e 94 33 aa 	call	0x15466	; 0x15466 <_ZN11EthernetUDP8remoteIPEv>
    7be0:	8b ad       	ldd	r24, Y+59	; 0x3b
    7be2:	9c ad       	ldd	r25, Y+60	; 0x3c
    7be4:	9c 01       	movw	r18, r24
    7be6:	26 5e       	subi	r18, 0xE6	; 230
    7be8:	3f 4f       	sbci	r19, 0xFF	; 255
    7bea:	ce 01       	movw	r24, r28
    7bec:	0d 96       	adiw	r24, 0x0d	; 13
    7bee:	b9 01       	movw	r22, r18
    7bf0:	0e 94 0f 5a 	call	0xb41e	; 0xb41e <_ZN9IPAddressC1EPKh>
    7bf4:	9e 01       	movw	r18, r28
    7bf6:	2d 5e       	subi	r18, 0xED	; 237
    7bf8:	3f 4f       	sbci	r19, 0xFF	; 255
    7bfa:	ce 01       	movw	r24, r28
    7bfc:	0d 96       	adiw	r24, 0x0d	; 13
    7bfe:	b9 01       	movw	r22, r18
    7c00:	0e 94 0a aa 	call	0x15414	; 0x15414 <_ZN9IPAddresseqERKS_>
                    }
                    break;
                
                case dhcpServerIdentifier :
                    opt_len = _dhcpUdpSocket.read();
                    if( *((uint32_t*)_dhcpDhcpServerIp) == 0 || 
    7c04:	88 23       	and	r24, r24
    7c06:	11 f0       	breq	.+4      	; 0x7c0c <_ZN9DhcpClass17parseDHCPResponseEmRm+0x424>
    7c08:	81 e0       	ldi	r24, 0x01	; 1
    7c0a:	01 c0       	rjmp	.+2      	; 0x7c0e <_ZN9DhcpClass17parseDHCPResponseEmRm+0x426>
    7c0c:	80 e0       	ldi	r24, 0x00	; 0
    7c0e:	88 23       	and	r24, r24
    7c10:	a9 f0       	breq	.+42     	; 0x7c3c <_ZN9DhcpClass17parseDHCPResponseEmRm+0x454>
                        IPAddress(_dhcpDhcpServerIp) == _dhcpUdpSocket.remoteIP() )
                    {
                        _dhcpUdpSocket.read(_dhcpDhcpServerIp, sizeof(_dhcpDhcpServerIp));
    7c12:	8b ad       	ldd	r24, Y+59	; 0x3b
    7c14:	9c ad       	ldd	r25, Y+60	; 0x3c
    7c16:	9c 01       	movw	r18, r24
    7c18:	26 5e       	subi	r18, 0xE6	; 230
    7c1a:	3f 4f       	sbci	r19, 0xFF	; 255
    7c1c:	8b ad       	ldd	r24, Y+59	; 0x3b
    7c1e:	9c ad       	ldd	r25, Y+60	; 0x3c
    7c20:	89 5b       	subi	r24, 0xB9	; 185
    7c22:	9f 4f       	sbci	r25, 0xFF	; 255
    7c24:	44 e0       	ldi	r20, 0x04	; 4
    7c26:	50 e0       	ldi	r21, 0x00	; 0
    7c28:	b9 01       	movw	r22, r18
    7c2a:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
                        while (opt_len--)
                        {
                            _dhcpUdpSocket.read();
                        }
                    }
                    break;
    7c2e:	4c c1       	rjmp	.+664    	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>
                    else
                    {
                        // Skip over the rest of this option
                        while (opt_len--)
                        {
                            _dhcpUdpSocket.read();
    7c30:	8b ad       	ldd	r24, Y+59	; 0x3b
    7c32:	9c ad       	ldd	r25, Y+60	; 0x3c
    7c34:	89 5b       	subi	r24, 0xB9	; 185
    7c36:	9f 4f       	sbci	r25, 0xFF	; 255
    7c38:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
                        _dhcpUdpSocket.read(_dhcpDhcpServerIp, sizeof(_dhcpDhcpServerIp));
                    }
                    else
                    {
                        // Skip over the rest of this option
                        while (opt_len--)
    7c3c:	81 e0       	ldi	r24, 0x01	; 1
    7c3e:	9a 81       	ldd	r25, Y+2	; 0x02
    7c40:	99 23       	and	r25, r25
    7c42:	09 f4       	brne	.+2      	; 0x7c46 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x45e>
    7c44:	80 e0       	ldi	r24, 0x00	; 0
    7c46:	9a 81       	ldd	r25, Y+2	; 0x02
    7c48:	91 50       	subi	r25, 0x01	; 1
    7c4a:	9a 83       	std	Y+2, r25	; 0x02
    7c4c:	88 23       	and	r24, r24
    7c4e:	81 f7       	brne	.-32     	; 0x7c30 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x448>
                        {
                            _dhcpUdpSocket.read();
                        }
                    }
                    break;
    7c50:	3b c1       	rjmp	.+630    	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>

                case dhcpT1value : 
                    opt_len = _dhcpUdpSocket.read();
    7c52:	8b ad       	ldd	r24, Y+59	; 0x3b
    7c54:	9c ad       	ldd	r25, Y+60	; 0x3c
    7c56:	89 5b       	subi	r24, 0xB9	; 185
    7c58:	9f 4f       	sbci	r25, 0xFF	; 255
    7c5a:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7c5e:	8a 83       	std	Y+2, r24	; 0x02
                    _dhcpUdpSocket.read((uint8_t*)&_dhcpT1, sizeof(_dhcpT1));
    7c60:	8b ad       	ldd	r24, Y+59	; 0x3b
    7c62:	9c ad       	ldd	r25, Y+60	; 0x3c
    7c64:	9c 01       	movw	r18, r24
    7c66:	2a 5d       	subi	r18, 0xDA	; 218
    7c68:	3f 4f       	sbci	r19, 0xFF	; 255
    7c6a:	8b ad       	ldd	r24, Y+59	; 0x3b
    7c6c:	9c ad       	ldd	r25, Y+60	; 0x3c
    7c6e:	89 5b       	subi	r24, 0xB9	; 185
    7c70:	9f 4f       	sbci	r25, 0xFF	; 255
    7c72:	44 e0       	ldi	r20, 0x04	; 4
    7c74:	50 e0       	ldi	r21, 0x00	; 0
    7c76:	b9 01       	movw	r22, r18
    7c78:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
                    _dhcpT1 = ntohl(_dhcpT1);
    7c7c:	8b ad       	ldd	r24, Y+59	; 0x3b
    7c7e:	9c ad       	ldd	r25, Y+60	; 0x3c
    7c80:	fc 01       	movw	r30, r24
    7c82:	86 a1       	ldd	r24, Z+38	; 0x26
    7c84:	97 a1       	ldd	r25, Z+39	; 0x27
    7c86:	a0 a5       	ldd	r26, Z+40	; 0x28
    7c88:	b1 a5       	ldd	r27, Z+41	; 0x29
    7c8a:	58 2f       	mov	r21, r24
    7c8c:	44 27       	eor	r20, r20
    7c8e:	33 27       	eor	r19, r19
    7c90:	22 27       	eor	r18, r18
    7c92:	8b ad       	ldd	r24, Y+59	; 0x3b
    7c94:	9c ad       	ldd	r25, Y+60	; 0x3c
    7c96:	fc 01       	movw	r30, r24
    7c98:	86 a1       	ldd	r24, Z+38	; 0x26
    7c9a:	97 a1       	ldd	r25, Z+39	; 0x27
    7c9c:	a0 a5       	ldd	r26, Z+40	; 0x28
    7c9e:	b1 a5       	ldd	r27, Z+41	; 0x29
    7ca0:	ba 2f       	mov	r27, r26
    7ca2:	a9 2f       	mov	r26, r25
    7ca4:	98 2f       	mov	r25, r24
    7ca6:	88 27       	eor	r24, r24
    7ca8:	88 27       	eor	r24, r24
    7caa:	99 27       	eor	r25, r25
    7cac:	bb 27       	eor	r27, r27
    7cae:	28 2b       	or	r18, r24
    7cb0:	39 2b       	or	r19, r25
    7cb2:	4a 2b       	or	r20, r26
    7cb4:	5b 2b       	or	r21, r27
    7cb6:	8b ad       	ldd	r24, Y+59	; 0x3b
    7cb8:	9c ad       	ldd	r25, Y+60	; 0x3c
    7cba:	fc 01       	movw	r30, r24
    7cbc:	86 a1       	ldd	r24, Z+38	; 0x26
    7cbe:	97 a1       	ldd	r25, Z+39	; 0x27
    7cc0:	a0 a5       	ldd	r26, Z+40	; 0x28
    7cc2:	b1 a5       	ldd	r27, Z+41	; 0x29
    7cc4:	89 2f       	mov	r24, r25
    7cc6:	9a 2f       	mov	r25, r26
    7cc8:	ab 2f       	mov	r26, r27
    7cca:	bb 27       	eor	r27, r27
    7ccc:	88 27       	eor	r24, r24
    7cce:	aa 27       	eor	r26, r26
    7cd0:	bb 27       	eor	r27, r27
    7cd2:	28 2b       	or	r18, r24
    7cd4:	39 2b       	or	r19, r25
    7cd6:	4a 2b       	or	r20, r26
    7cd8:	5b 2b       	or	r21, r27
    7cda:	8b ad       	ldd	r24, Y+59	; 0x3b
    7cdc:	9c ad       	ldd	r25, Y+60	; 0x3c
    7cde:	fc 01       	movw	r30, r24
    7ce0:	86 a1       	ldd	r24, Z+38	; 0x26
    7ce2:	97 a1       	ldd	r25, Z+39	; 0x27
    7ce4:	a0 a5       	ldd	r26, Z+40	; 0x28
    7ce6:	b1 a5       	ldd	r27, Z+41	; 0x29
    7ce8:	8b 2f       	mov	r24, r27
    7cea:	99 27       	eor	r25, r25
    7cec:	aa 27       	eor	r26, r26
    7cee:	bb 27       	eor	r27, r27
    7cf0:	82 2b       	or	r24, r18
    7cf2:	93 2b       	or	r25, r19
    7cf4:	a4 2b       	or	r26, r20
    7cf6:	b5 2b       	or	r27, r21
    7cf8:	2b ad       	ldd	r18, Y+59	; 0x3b
    7cfa:	3c ad       	ldd	r19, Y+60	; 0x3c
    7cfc:	f9 01       	movw	r30, r18
    7cfe:	86 a3       	std	Z+38, r24	; 0x26
    7d00:	97 a3       	std	Z+39, r25	; 0x27
    7d02:	a0 a7       	std	Z+40, r26	; 0x28
    7d04:	b1 a7       	std	Z+41, r27	; 0x29
                    break;
    7d06:	e0 c0       	rjmp	.+448    	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>

                case dhcpT2value : 
                    opt_len = _dhcpUdpSocket.read();
    7d08:	8b ad       	ldd	r24, Y+59	; 0x3b
    7d0a:	9c ad       	ldd	r25, Y+60	; 0x3c
    7d0c:	89 5b       	subi	r24, 0xB9	; 185
    7d0e:	9f 4f       	sbci	r25, 0xFF	; 255
    7d10:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7d14:	8a 83       	std	Y+2, r24	; 0x02
                    _dhcpUdpSocket.read((uint8_t*)&_dhcpT2, sizeof(_dhcpT2));
    7d16:	8b ad       	ldd	r24, Y+59	; 0x3b
    7d18:	9c ad       	ldd	r25, Y+60	; 0x3c
    7d1a:	9c 01       	movw	r18, r24
    7d1c:	26 5d       	subi	r18, 0xD6	; 214
    7d1e:	3f 4f       	sbci	r19, 0xFF	; 255
    7d20:	8b ad       	ldd	r24, Y+59	; 0x3b
    7d22:	9c ad       	ldd	r25, Y+60	; 0x3c
    7d24:	89 5b       	subi	r24, 0xB9	; 185
    7d26:	9f 4f       	sbci	r25, 0xFF	; 255
    7d28:	44 e0       	ldi	r20, 0x04	; 4
    7d2a:	50 e0       	ldi	r21, 0x00	; 0
    7d2c:	b9 01       	movw	r22, r18
    7d2e:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
                    _dhcpT2 = ntohl(_dhcpT2);
    7d32:	8b ad       	ldd	r24, Y+59	; 0x3b
    7d34:	9c ad       	ldd	r25, Y+60	; 0x3c
    7d36:	fc 01       	movw	r30, r24
    7d38:	82 a5       	ldd	r24, Z+42	; 0x2a
    7d3a:	93 a5       	ldd	r25, Z+43	; 0x2b
    7d3c:	a4 a5       	ldd	r26, Z+44	; 0x2c
    7d3e:	b5 a5       	ldd	r27, Z+45	; 0x2d
    7d40:	58 2f       	mov	r21, r24
    7d42:	44 27       	eor	r20, r20
    7d44:	33 27       	eor	r19, r19
    7d46:	22 27       	eor	r18, r18
    7d48:	8b ad       	ldd	r24, Y+59	; 0x3b
    7d4a:	9c ad       	ldd	r25, Y+60	; 0x3c
    7d4c:	fc 01       	movw	r30, r24
    7d4e:	82 a5       	ldd	r24, Z+42	; 0x2a
    7d50:	93 a5       	ldd	r25, Z+43	; 0x2b
    7d52:	a4 a5       	ldd	r26, Z+44	; 0x2c
    7d54:	b5 a5       	ldd	r27, Z+45	; 0x2d
    7d56:	ba 2f       	mov	r27, r26
    7d58:	a9 2f       	mov	r26, r25
    7d5a:	98 2f       	mov	r25, r24
    7d5c:	88 27       	eor	r24, r24
    7d5e:	88 27       	eor	r24, r24
    7d60:	99 27       	eor	r25, r25
    7d62:	bb 27       	eor	r27, r27
    7d64:	28 2b       	or	r18, r24
    7d66:	39 2b       	or	r19, r25
    7d68:	4a 2b       	or	r20, r26
    7d6a:	5b 2b       	or	r21, r27
    7d6c:	8b ad       	ldd	r24, Y+59	; 0x3b
    7d6e:	9c ad       	ldd	r25, Y+60	; 0x3c
    7d70:	fc 01       	movw	r30, r24
    7d72:	82 a5       	ldd	r24, Z+42	; 0x2a
    7d74:	93 a5       	ldd	r25, Z+43	; 0x2b
    7d76:	a4 a5       	ldd	r26, Z+44	; 0x2c
    7d78:	b5 a5       	ldd	r27, Z+45	; 0x2d
    7d7a:	89 2f       	mov	r24, r25
    7d7c:	9a 2f       	mov	r25, r26
    7d7e:	ab 2f       	mov	r26, r27
    7d80:	bb 27       	eor	r27, r27
    7d82:	88 27       	eor	r24, r24
    7d84:	aa 27       	eor	r26, r26
    7d86:	bb 27       	eor	r27, r27
    7d88:	28 2b       	or	r18, r24
    7d8a:	39 2b       	or	r19, r25
    7d8c:	4a 2b       	or	r20, r26
    7d8e:	5b 2b       	or	r21, r27
    7d90:	8b ad       	ldd	r24, Y+59	; 0x3b
    7d92:	9c ad       	ldd	r25, Y+60	; 0x3c
    7d94:	fc 01       	movw	r30, r24
    7d96:	82 a5       	ldd	r24, Z+42	; 0x2a
    7d98:	93 a5       	ldd	r25, Z+43	; 0x2b
    7d9a:	a4 a5       	ldd	r26, Z+44	; 0x2c
    7d9c:	b5 a5       	ldd	r27, Z+45	; 0x2d
    7d9e:	8b 2f       	mov	r24, r27
    7da0:	99 27       	eor	r25, r25
    7da2:	aa 27       	eor	r26, r26
    7da4:	bb 27       	eor	r27, r27
    7da6:	82 2b       	or	r24, r18
    7da8:	93 2b       	or	r25, r19
    7daa:	a4 2b       	or	r26, r20
    7dac:	b5 2b       	or	r27, r21
    7dae:	2b ad       	ldd	r18, Y+59	; 0x3b
    7db0:	3c ad       	ldd	r19, Y+60	; 0x3c
    7db2:	f9 01       	movw	r30, r18
    7db4:	82 a7       	std	Z+42, r24	; 0x2a
    7db6:	93 a7       	std	Z+43, r25	; 0x2b
    7db8:	a4 a7       	std	Z+44, r26	; 0x2c
    7dba:	b5 a7       	std	Z+45, r27	; 0x2d
                    break;
    7dbc:	85 c0       	rjmp	.+266    	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>

                case dhcpIPaddrLeaseTime :
                    opt_len = _dhcpUdpSocket.read();
    7dbe:	8b ad       	ldd	r24, Y+59	; 0x3b
    7dc0:	9c ad       	ldd	r25, Y+60	; 0x3c
    7dc2:	89 5b       	subi	r24, 0xB9	; 185
    7dc4:	9f 4f       	sbci	r25, 0xFF	; 255
    7dc6:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7dca:	8a 83       	std	Y+2, r24	; 0x02
                    _dhcpUdpSocket.read((uint8_t*)&_dhcpLeaseTime, sizeof(_dhcpLeaseTime));
    7dcc:	8b ad       	ldd	r24, Y+59	; 0x3b
    7dce:	9c ad       	ldd	r25, Y+60	; 0x3c
    7dd0:	9c 01       	movw	r18, r24
    7dd2:	2e 5d       	subi	r18, 0xDE	; 222
    7dd4:	3f 4f       	sbci	r19, 0xFF	; 255
    7dd6:	8b ad       	ldd	r24, Y+59	; 0x3b
    7dd8:	9c ad       	ldd	r25, Y+60	; 0x3c
    7dda:	89 5b       	subi	r24, 0xB9	; 185
    7ddc:	9f 4f       	sbci	r25, 0xFF	; 255
    7dde:	44 e0       	ldi	r20, 0x04	; 4
    7de0:	50 e0       	ldi	r21, 0x00	; 0
    7de2:	b9 01       	movw	r22, r18
    7de4:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
                    _dhcpLeaseTime = ntohl(_dhcpLeaseTime);
    7de8:	8b ad       	ldd	r24, Y+59	; 0x3b
    7dea:	9c ad       	ldd	r25, Y+60	; 0x3c
    7dec:	fc 01       	movw	r30, r24
    7dee:	82 a1       	ldd	r24, Z+34	; 0x22
    7df0:	93 a1       	ldd	r25, Z+35	; 0x23
    7df2:	a4 a1       	ldd	r26, Z+36	; 0x24
    7df4:	b5 a1       	ldd	r27, Z+37	; 0x25
    7df6:	58 2f       	mov	r21, r24
    7df8:	44 27       	eor	r20, r20
    7dfa:	33 27       	eor	r19, r19
    7dfc:	22 27       	eor	r18, r18
    7dfe:	8b ad       	ldd	r24, Y+59	; 0x3b
    7e00:	9c ad       	ldd	r25, Y+60	; 0x3c
    7e02:	fc 01       	movw	r30, r24
    7e04:	82 a1       	ldd	r24, Z+34	; 0x22
    7e06:	93 a1       	ldd	r25, Z+35	; 0x23
    7e08:	a4 a1       	ldd	r26, Z+36	; 0x24
    7e0a:	b5 a1       	ldd	r27, Z+37	; 0x25
    7e0c:	ba 2f       	mov	r27, r26
    7e0e:	a9 2f       	mov	r26, r25
    7e10:	98 2f       	mov	r25, r24
    7e12:	88 27       	eor	r24, r24
    7e14:	88 27       	eor	r24, r24
    7e16:	99 27       	eor	r25, r25
    7e18:	bb 27       	eor	r27, r27
    7e1a:	28 2b       	or	r18, r24
    7e1c:	39 2b       	or	r19, r25
    7e1e:	4a 2b       	or	r20, r26
    7e20:	5b 2b       	or	r21, r27
    7e22:	8b ad       	ldd	r24, Y+59	; 0x3b
    7e24:	9c ad       	ldd	r25, Y+60	; 0x3c
    7e26:	fc 01       	movw	r30, r24
    7e28:	82 a1       	ldd	r24, Z+34	; 0x22
    7e2a:	93 a1       	ldd	r25, Z+35	; 0x23
    7e2c:	a4 a1       	ldd	r26, Z+36	; 0x24
    7e2e:	b5 a1       	ldd	r27, Z+37	; 0x25
    7e30:	89 2f       	mov	r24, r25
    7e32:	9a 2f       	mov	r25, r26
    7e34:	ab 2f       	mov	r26, r27
    7e36:	bb 27       	eor	r27, r27
    7e38:	88 27       	eor	r24, r24
    7e3a:	aa 27       	eor	r26, r26
    7e3c:	bb 27       	eor	r27, r27
    7e3e:	28 2b       	or	r18, r24
    7e40:	39 2b       	or	r19, r25
    7e42:	4a 2b       	or	r20, r26
    7e44:	5b 2b       	or	r21, r27
    7e46:	8b ad       	ldd	r24, Y+59	; 0x3b
    7e48:	9c ad       	ldd	r25, Y+60	; 0x3c
    7e4a:	fc 01       	movw	r30, r24
    7e4c:	82 a1       	ldd	r24, Z+34	; 0x22
    7e4e:	93 a1       	ldd	r25, Z+35	; 0x23
    7e50:	a4 a1       	ldd	r26, Z+36	; 0x24
    7e52:	b5 a1       	ldd	r27, Z+37	; 0x25
    7e54:	8b 2f       	mov	r24, r27
    7e56:	99 27       	eor	r25, r25
    7e58:	aa 27       	eor	r26, r26
    7e5a:	bb 27       	eor	r27, r27
    7e5c:	82 2b       	or	r24, r18
    7e5e:	93 2b       	or	r25, r19
    7e60:	a4 2b       	or	r26, r20
    7e62:	b5 2b       	or	r27, r21
    7e64:	2b ad       	ldd	r18, Y+59	; 0x3b
    7e66:	3c ad       	ldd	r19, Y+60	; 0x3c
    7e68:	f9 01       	movw	r30, r18
    7e6a:	82 a3       	std	Z+34, r24	; 0x22
    7e6c:	93 a3       	std	Z+35, r25	; 0x23
    7e6e:	a4 a3       	std	Z+36, r26	; 0x24
    7e70:	b5 a3       	std	Z+37, r27	; 0x25
                    _renewInSec = _dhcpLeaseTime;
    7e72:	8b ad       	ldd	r24, Y+59	; 0x3b
    7e74:	9c ad       	ldd	r25, Y+60	; 0x3c
    7e76:	fc 01       	movw	r30, r24
    7e78:	82 a1       	ldd	r24, Z+34	; 0x22
    7e7a:	93 a1       	ldd	r25, Z+35	; 0x23
    7e7c:	a4 a1       	ldd	r26, Z+36	; 0x24
    7e7e:	b5 a1       	ldd	r27, Z+37	; 0x25
    7e80:	2b ad       	ldd	r18, Y+59	; 0x3b
    7e82:	3c ad       	ldd	r19, Y+60	; 0x3c
    7e84:	f9 01       	movw	r30, r18
    7e86:	86 a7       	std	Z+46, r24	; 0x2e
    7e88:	97 a7       	std	Z+47, r25	; 0x2f
    7e8a:	a0 ab       	std	Z+48, r26	; 0x30
    7e8c:	b1 ab       	std	Z+49, r27	; 0x31
                    break;
    7e8e:	1c c0       	rjmp	.+56     	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>

                default :
                    opt_len = _dhcpUdpSocket.read();
    7e90:	8b ad       	ldd	r24, Y+59	; 0x3b
    7e92:	9c ad       	ldd	r25, Y+60	; 0x3c
    7e94:	89 5b       	subi	r24, 0xB9	; 185
    7e96:	9f 4f       	sbci	r25, 0xFF	; 255
    7e98:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
    7e9c:	8a 83       	std	Y+2, r24	; 0x02
                    // Skip over the rest of this option
                    while (opt_len--)
    7e9e:	06 c0       	rjmp	.+12     	; 0x7eac <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6c4>
                    {
                        _dhcpUdpSocket.read();
    7ea0:	8b ad       	ldd	r24, Y+59	; 0x3b
    7ea2:	9c ad       	ldd	r25, Y+60	; 0x3c
    7ea4:	89 5b       	subi	r24, 0xB9	; 185
    7ea6:	9f 4f       	sbci	r25, 0xFF	; 255
    7ea8:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
                    break;

                default :
                    opt_len = _dhcpUdpSocket.read();
                    // Skip over the rest of this option
                    while (opt_len--)
    7eac:	81 e0       	ldi	r24, 0x01	; 1
    7eae:	9a 81       	ldd	r25, Y+2	; 0x02
    7eb0:	99 23       	and	r25, r25
    7eb2:	09 f4       	brne	.+2      	; 0x7eb6 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6ce>
    7eb4:	80 e0       	ldi	r24, 0x00	; 0
    7eb6:	9a 81       	ldd	r25, Y+2	; 0x02
    7eb8:	91 50       	subi	r25, 0x01	; 1
    7eba:	9a 83       	std	Y+2, r25	; 0x02
    7ebc:	88 23       	and	r24, r24
    7ebe:	81 f7       	brne	.-32     	; 0x7ea0 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6b8>
                    {
                        _dhcpUdpSocket.read();
                    }
                    break;
    7ec0:	03 c0       	rjmp	.+6      	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>
            {
                case endOption :
                    break;
                    
                case padOption :
                    break;
    7ec2:	00 00       	nop
    7ec4:	01 c0       	rjmp	.+2      	; 0x7ec8 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6e0>
        while (_dhcpUdpSocket.available() > 0) 
        {
            switch (_dhcpUdpSocket.read()) 
            {
                case endOption :
                    break;
    7ec6:	00 00       	nop
        for (int i =0; i < (240 - (int)sizeof(RIP_MSG_FIXED)); i++)
        {
            _dhcpUdpSocket.read(); // we don't care about the returned byte
        }

        while (_dhcpUdpSocket.available() > 0) 
    7ec8:	8b ad       	ldd	r24, Y+59	; 0x3b
    7eca:	9c ad       	ldd	r25, Y+60	; 0x3c
    7ecc:	89 5b       	subi	r24, 0xB9	; 185
    7ece:	9f 4f       	sbci	r25, 0xFF	; 255
    7ed0:	0e 94 5a 50 	call	0xa0b4	; 0xa0b4 <_ZN11EthernetUDP9availableEv>
    7ed4:	21 e0       	ldi	r18, 0x01	; 1
    7ed6:	18 16       	cp	r1, r24
    7ed8:	19 06       	cpc	r1, r25
    7eda:	0c f0       	brlt	.+2      	; 0x7ede <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6f6>
    7edc:	20 e0       	ldi	r18, 0x00	; 0
    7ede:	22 23       	and	r18, r18
    7ee0:	09 f0       	breq	.+2      	; 0x7ee4 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x6fc>
    7ee2:	9e cd       	rjmp	.-1220   	; 0x7a20 <_ZN9DhcpClass17parseDHCPResponseEmRm+0x238>
            }
        }
    }

    // Need to skip to end of the packet regardless here
    _dhcpUdpSocket.flush();
    7ee4:	8b ad       	ldd	r24, Y+59	; 0x3b
    7ee6:	9c ad       	ldd	r25, Y+60	; 0x3c
    7ee8:	89 5b       	subi	r24, 0xB9	; 185
    7eea:	9f 4f       	sbci	r25, 0xFF	; 255
    7eec:	0e 94 fd 52 	call	0xa5fa	; 0xa5fa <_ZN11EthernetUDP5flushEv>

    return type;
    7ef0:	89 81       	ldd	r24, Y+1	; 0x01
}
    7ef2:	ce 5b       	subi	r28, 0xBE	; 190
    7ef4:	df 4f       	sbci	r29, 0xFF	; 255
    7ef6:	0f b6       	in	r0, 0x3f	; 63
    7ef8:	f8 94       	cli
    7efa:	de bf       	out	0x3e, r29	; 62
    7efc:	0f be       	out	0x3f, r0	; 63
    7efe:	cd bf       	out	0x3d, r28	; 61
    7f00:	df 91       	pop	r29
    7f02:	cf 91       	pop	r28
    7f04:	08 95       	ret

00007f06 <_ZN9DhcpClass10checkLeaseEv>:
    1/DHCP_CHECK_RENEW_FAIL: renew failed
    2/DHCP_CHECK_RENEW_OK: renew success
    3/DHCP_CHECK_REBIND_FAIL: rebind fail
    4/DHCP_CHECK_REBIND_OK: rebind success
*/
int DhcpClass::checkLease(){
    7f06:	ef 92       	push	r14
    7f08:	ff 92       	push	r15
    7f0a:	0f 93       	push	r16
    7f0c:	1f 93       	push	r17
    7f0e:	cf 93       	push	r28
    7f10:	df 93       	push	r29
    7f12:	cd b7       	in	r28, 0x3d	; 61
    7f14:	de b7       	in	r29, 0x3e	; 62
    7f16:	60 97       	sbiw	r28, 0x10	; 16
    7f18:	0f b6       	in	r0, 0x3f	; 63
    7f1a:	f8 94       	cli
    7f1c:	de bf       	out	0x3e, r29	; 62
    7f1e:	0f be       	out	0x3f, r0	; 63
    7f20:	cd bf       	out	0x3d, r28	; 61
    7f22:	98 8b       	std	Y+16, r25	; 0x10
    7f24:	8f 87       	std	Y+15, r24	; 0x0f
    //this uses a signed / unsigned trick to deal with millis overflow
    unsigned long now = millis();
    7f26:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    7f2a:	dc 01       	movw	r26, r24
    7f2c:	cb 01       	movw	r24, r22
    7f2e:	8b 83       	std	Y+3, r24	; 0x03
    7f30:	9c 83       	std	Y+4, r25	; 0x04
    7f32:	ad 83       	std	Y+5, r26	; 0x05
    7f34:	be 83       	std	Y+6, r27	; 0x06
    signed long snow = (long)now;
    7f36:	8b 81       	ldd	r24, Y+3	; 0x03
    7f38:	9c 81       	ldd	r25, Y+4	; 0x04
    7f3a:	ad 81       	ldd	r26, Y+5	; 0x05
    7f3c:	be 81       	ldd	r27, Y+6	; 0x06
    7f3e:	8f 83       	std	Y+7, r24	; 0x07
    7f40:	98 87       	std	Y+8, r25	; 0x08
    7f42:	a9 87       	std	Y+9, r26	; 0x09
    7f44:	ba 87       	std	Y+10, r27	; 0x0a
    int rc=DHCP_CHECK_NONE;
    7f46:	1a 82       	std	Y+2, r1	; 0x02
    7f48:	19 82       	std	Y+1, r1	; 0x01
    if (_lastCheck != 0){
    7f4a:	8f 85       	ldd	r24, Y+15	; 0x0f
    7f4c:	98 89       	ldd	r25, Y+16	; 0x10
    7f4e:	fc 01       	movw	r30, r24
    7f50:	86 a9       	ldd	r24, Z+54	; 0x36
    7f52:	97 a9       	ldd	r25, Z+55	; 0x37
    7f54:	a0 ad       	ldd	r26, Z+56	; 0x38
    7f56:	b1 ad       	ldd	r27, Z+57	; 0x39
    7f58:	00 97       	sbiw	r24, 0x00	; 0
    7f5a:	a1 05       	cpc	r26, r1
    7f5c:	b1 05       	cpc	r27, r1
    7f5e:	09 f4       	brne	.+2      	; 0x7f62 <_ZN9DhcpClass10checkLeaseEv+0x5c>
    7f60:	1e c1       	rjmp	.+572    	; 0x819e <_ZN9DhcpClass10checkLeaseEv+0x298>
        signed long factor;
        //calc how many ms past the timeout we are
        factor = snow - (long)_secTimeout;
    7f62:	8f 85       	ldd	r24, Y+15	; 0x0f
    7f64:	98 89       	ldd	r25, Y+16	; 0x10
    7f66:	8e 5b       	subi	r24, 0xBE	; 190
    7f68:	9f 4f       	sbci	r25, 0xFF	; 255
    7f6a:	fc 01       	movw	r30, r24
    7f6c:	80 81       	ld	r24, Z
    7f6e:	91 81       	ldd	r25, Z+1	; 0x01
    7f70:	a2 81       	ldd	r26, Z+2	; 0x02
    7f72:	b3 81       	ldd	r27, Z+3	; 0x03
    7f74:	2f 81       	ldd	r18, Y+7	; 0x07
    7f76:	38 85       	ldd	r19, Y+8	; 0x08
    7f78:	49 85       	ldd	r20, Y+9	; 0x09
    7f7a:	5a 85       	ldd	r21, Y+10	; 0x0a
    7f7c:	79 01       	movw	r14, r18
    7f7e:	8a 01       	movw	r16, r20
    7f80:	e8 1a       	sub	r14, r24
    7f82:	f9 0a       	sbc	r15, r25
    7f84:	0a 0b       	sbc	r16, r26
    7f86:	1b 0b       	sbc	r17, r27
    7f88:	d8 01       	movw	r26, r16
    7f8a:	c7 01       	movw	r24, r14
    7f8c:	8b 87       	std	Y+11, r24	; 0x0b
    7f8e:	9c 87       	std	Y+12, r25	; 0x0c
    7f90:	ad 87       	std	Y+13, r26	; 0x0d
    7f92:	be 87       	std	Y+14, r27	; 0x0e
        //if on or passed the timeout, reduce the counters
        if ( factor >= 0 ){
    7f94:	8b 85       	ldd	r24, Y+11	; 0x0b
    7f96:	9c 85       	ldd	r25, Y+12	; 0x0c
    7f98:	ad 85       	ldd	r26, Y+13	; 0x0d
    7f9a:	be 85       	ldd	r27, Y+14	; 0x0e
    7f9c:	bb 23       	and	r27, r27
    7f9e:	0c f4       	brge	.+2      	; 0x7fa2 <_ZN9DhcpClass10checkLeaseEv+0x9c>
    7fa0:	ae c0       	rjmp	.+348    	; 0x80fe <_ZN9DhcpClass10checkLeaseEv+0x1f8>
            //next timeout should be now plus 1000 ms minus parts of second in factor
            _secTimeout = snow + 1000 - factor % 1000;
    7fa2:	8f 81       	ldd	r24, Y+7	; 0x07
    7fa4:	98 85       	ldd	r25, Y+8	; 0x08
    7fa6:	a9 85       	ldd	r26, Y+9	; 0x09
    7fa8:	ba 85       	ldd	r27, Y+10	; 0x0a
    7faa:	18 ee       	ldi	r17, 0xE8	; 232
    7fac:	e1 2e       	mov	r14, r17
    7fae:	13 e0       	ldi	r17, 0x03	; 3
    7fb0:	f1 2e       	mov	r15, r17
    7fb2:	00 e0       	ldi	r16, 0x00	; 0
    7fb4:	10 e0       	ldi	r17, 0x00	; 0
    7fb6:	e8 0e       	add	r14, r24
    7fb8:	f9 1e       	adc	r15, r25
    7fba:	0a 1f       	adc	r16, r26
    7fbc:	1b 1f       	adc	r17, r27
    7fbe:	8b 85       	ldd	r24, Y+11	; 0x0b
    7fc0:	9c 85       	ldd	r25, Y+12	; 0x0c
    7fc2:	ad 85       	ldd	r26, Y+13	; 0x0d
    7fc4:	be 85       	ldd	r27, Y+14	; 0x0e
    7fc6:	28 ee       	ldi	r18, 0xE8	; 232
    7fc8:	33 e0       	ldi	r19, 0x03	; 3
    7fca:	40 e0       	ldi	r20, 0x00	; 0
    7fcc:	50 e0       	ldi	r21, 0x00	; 0
    7fce:	bc 01       	movw	r22, r24
    7fd0:	cd 01       	movw	r24, r26
    7fd2:	0e 94 cf ad 	call	0x15b9e	; 0x15b9e <__divmodsi4>
    7fd6:	dc 01       	movw	r26, r24
    7fd8:	cb 01       	movw	r24, r22
    7fda:	a8 01       	movw	r20, r16
    7fdc:	97 01       	movw	r18, r14
    7fde:	28 1b       	sub	r18, r24
    7fe0:	39 0b       	sbc	r19, r25
    7fe2:	4a 0b       	sbc	r20, r26
    7fe4:	5b 0b       	sbc	r21, r27
    7fe6:	da 01       	movw	r26, r20
    7fe8:	c9 01       	movw	r24, r18
    7fea:	2f 85       	ldd	r18, Y+15	; 0x0f
    7fec:	38 89       	ldd	r19, Y+16	; 0x10
    7fee:	2e 5b       	subi	r18, 0xBE	; 190
    7ff0:	3f 4f       	sbci	r19, 0xFF	; 255
    7ff2:	f9 01       	movw	r30, r18
    7ff4:	80 83       	st	Z, r24
    7ff6:	91 83       	std	Z+1, r25	; 0x01
    7ff8:	a2 83       	std	Z+2, r26	; 0x02
    7ffa:	b3 83       	std	Z+3, r27	; 0x03
            //how many seconds late are we, minimum 1
            factor = factor / 1000 +1;
    7ffc:	8b 85       	ldd	r24, Y+11	; 0x0b
    7ffe:	9c 85       	ldd	r25, Y+12	; 0x0c
    8000:	ad 85       	ldd	r26, Y+13	; 0x0d
    8002:	be 85       	ldd	r27, Y+14	; 0x0e
    8004:	28 ee       	ldi	r18, 0xE8	; 232
    8006:	33 e0       	ldi	r19, 0x03	; 3
    8008:	40 e0       	ldi	r20, 0x00	; 0
    800a:	50 e0       	ldi	r21, 0x00	; 0
    800c:	bc 01       	movw	r22, r24
    800e:	cd 01       	movw	r24, r26
    8010:	0e 94 cf ad 	call	0x15b9e	; 0x15b9e <__divmodsi4>
    8014:	da 01       	movw	r26, r20
    8016:	c9 01       	movw	r24, r18
    8018:	01 96       	adiw	r24, 0x01	; 1
    801a:	a1 1d       	adc	r26, r1
    801c:	b1 1d       	adc	r27, r1
    801e:	8b 87       	std	Y+11, r24	; 0x0b
    8020:	9c 87       	std	Y+12, r25	; 0x0c
    8022:	ad 87       	std	Y+13, r26	; 0x0d
    8024:	be 87       	std	Y+14, r27	; 0x0e
            
            //reduce the counters by that mouch
            //if we can assume that the cycle time (factor) is fairly constant
            //and if the remainder is less than cycle time * 2 
            //do it early instead of late
            if(_renewInSec < factor*2 )
    8026:	8f 85       	ldd	r24, Y+15	; 0x0f
    8028:	98 89       	ldd	r25, Y+16	; 0x10
    802a:	fc 01       	movw	r30, r24
    802c:	26 a5       	ldd	r18, Z+46	; 0x2e
    802e:	37 a5       	ldd	r19, Z+47	; 0x2f
    8030:	40 a9       	ldd	r20, Z+48	; 0x30
    8032:	51 a9       	ldd	r21, Z+49	; 0x31
    8034:	8b 85       	ldd	r24, Y+11	; 0x0b
    8036:	9c 85       	ldd	r25, Y+12	; 0x0c
    8038:	ad 85       	ldd	r26, Y+13	; 0x0d
    803a:	be 85       	ldd	r27, Y+14	; 0x0e
    803c:	88 0f       	add	r24, r24
    803e:	99 1f       	adc	r25, r25
    8040:	aa 1f       	adc	r26, r26
    8042:	bb 1f       	adc	r27, r27
    8044:	28 17       	cp	r18, r24
    8046:	39 07       	cpc	r19, r25
    8048:	4a 07       	cpc	r20, r26
    804a:	5b 07       	cpc	r21, r27
    804c:	44 f4       	brge	.+16     	; 0x805e <_ZN9DhcpClass10checkLeaseEv+0x158>
                _renewInSec = 0;
    804e:	8f 85       	ldd	r24, Y+15	; 0x0f
    8050:	98 89       	ldd	r25, Y+16	; 0x10
    8052:	fc 01       	movw	r30, r24
    8054:	16 a6       	std	Z+46, r1	; 0x2e
    8056:	17 a6       	std	Z+47, r1	; 0x2f
    8058:	10 aa       	std	Z+48, r1	; 0x30
    805a:	11 aa       	std	Z+49, r1	; 0x31
    805c:	1a c0       	rjmp	.+52     	; 0x8092 <_ZN9DhcpClass10checkLeaseEv+0x18c>
            else
                _renewInSec -= factor;
    805e:	8f 85       	ldd	r24, Y+15	; 0x0f
    8060:	98 89       	ldd	r25, Y+16	; 0x10
    8062:	fc 01       	movw	r30, r24
    8064:	26 a5       	ldd	r18, Z+46	; 0x2e
    8066:	37 a5       	ldd	r19, Z+47	; 0x2f
    8068:	40 a9       	ldd	r20, Z+48	; 0x30
    806a:	51 a9       	ldd	r21, Z+49	; 0x31
    806c:	8b 85       	ldd	r24, Y+11	; 0x0b
    806e:	9c 85       	ldd	r25, Y+12	; 0x0c
    8070:	ad 85       	ldd	r26, Y+13	; 0x0d
    8072:	be 85       	ldd	r27, Y+14	; 0x0e
    8074:	79 01       	movw	r14, r18
    8076:	8a 01       	movw	r16, r20
    8078:	e8 1a       	sub	r14, r24
    807a:	f9 0a       	sbc	r15, r25
    807c:	0a 0b       	sbc	r16, r26
    807e:	1b 0b       	sbc	r17, r27
    8080:	d8 01       	movw	r26, r16
    8082:	c7 01       	movw	r24, r14
    8084:	2f 85       	ldd	r18, Y+15	; 0x0f
    8086:	38 89       	ldd	r19, Y+16	; 0x10
    8088:	f9 01       	movw	r30, r18
    808a:	86 a7       	std	Z+46, r24	; 0x2e
    808c:	97 a7       	std	Z+47, r25	; 0x2f
    808e:	a0 ab       	std	Z+48, r26	; 0x30
    8090:	b1 ab       	std	Z+49, r27	; 0x31
            
            if(_rebindInSec < factor*2 )
    8092:	8f 85       	ldd	r24, Y+15	; 0x0f
    8094:	98 89       	ldd	r25, Y+16	; 0x10
    8096:	fc 01       	movw	r30, r24
    8098:	22 a9       	ldd	r18, Z+50	; 0x32
    809a:	33 a9       	ldd	r19, Z+51	; 0x33
    809c:	44 a9       	ldd	r20, Z+52	; 0x34
    809e:	55 a9       	ldd	r21, Z+53	; 0x35
    80a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    80a2:	9c 85       	ldd	r25, Y+12	; 0x0c
    80a4:	ad 85       	ldd	r26, Y+13	; 0x0d
    80a6:	be 85       	ldd	r27, Y+14	; 0x0e
    80a8:	88 0f       	add	r24, r24
    80aa:	99 1f       	adc	r25, r25
    80ac:	aa 1f       	adc	r26, r26
    80ae:	bb 1f       	adc	r27, r27
    80b0:	28 17       	cp	r18, r24
    80b2:	39 07       	cpc	r19, r25
    80b4:	4a 07       	cpc	r20, r26
    80b6:	5b 07       	cpc	r21, r27
    80b8:	44 f4       	brge	.+16     	; 0x80ca <_ZN9DhcpClass10checkLeaseEv+0x1c4>
                _rebindInSec = 0;
    80ba:	8f 85       	ldd	r24, Y+15	; 0x0f
    80bc:	98 89       	ldd	r25, Y+16	; 0x10
    80be:	fc 01       	movw	r30, r24
    80c0:	12 aa       	std	Z+50, r1	; 0x32
    80c2:	13 aa       	std	Z+51, r1	; 0x33
    80c4:	14 aa       	std	Z+52, r1	; 0x34
    80c6:	15 aa       	std	Z+53, r1	; 0x35
    80c8:	1a c0       	rjmp	.+52     	; 0x80fe <_ZN9DhcpClass10checkLeaseEv+0x1f8>
            else
                _rebindInSec -= factor;
    80ca:	8f 85       	ldd	r24, Y+15	; 0x0f
    80cc:	98 89       	ldd	r25, Y+16	; 0x10
    80ce:	fc 01       	movw	r30, r24
    80d0:	22 a9       	ldd	r18, Z+50	; 0x32
    80d2:	33 a9       	ldd	r19, Z+51	; 0x33
    80d4:	44 a9       	ldd	r20, Z+52	; 0x34
    80d6:	55 a9       	ldd	r21, Z+53	; 0x35
    80d8:	8b 85       	ldd	r24, Y+11	; 0x0b
    80da:	9c 85       	ldd	r25, Y+12	; 0x0c
    80dc:	ad 85       	ldd	r26, Y+13	; 0x0d
    80de:	be 85       	ldd	r27, Y+14	; 0x0e
    80e0:	79 01       	movw	r14, r18
    80e2:	8a 01       	movw	r16, r20
    80e4:	e8 1a       	sub	r14, r24
    80e6:	f9 0a       	sbc	r15, r25
    80e8:	0a 0b       	sbc	r16, r26
    80ea:	1b 0b       	sbc	r17, r27
    80ec:	d8 01       	movw	r26, r16
    80ee:	c7 01       	movw	r24, r14
    80f0:	2f 85       	ldd	r18, Y+15	; 0x0f
    80f2:	38 89       	ldd	r19, Y+16	; 0x10
    80f4:	f9 01       	movw	r30, r18
    80f6:	82 ab       	std	Z+50, r24	; 0x32
    80f8:	93 ab       	std	Z+51, r25	; 0x33
    80fa:	a4 ab       	std	Z+52, r26	; 0x34
    80fc:	b5 ab       	std	Z+53, r27	; 0x35
        }

        //if we have a lease but should renew, do it
        if (_dhcp_state == STATE_DHCP_LEASED && _renewInSec <=0){
    80fe:	8f 85       	ldd	r24, Y+15	; 0x0f
    8100:	98 89       	ldd	r25, Y+16	; 0x10
    8102:	8a 5b       	subi	r24, 0xBA	; 186
    8104:	9f 4f       	sbci	r25, 0xFF	; 255
    8106:	fc 01       	movw	r30, r24
    8108:	80 81       	ld	r24, Z
    810a:	83 30       	cpi	r24, 0x03	; 3
    810c:	d1 f4       	brne	.+52     	; 0x8142 <_ZN9DhcpClass10checkLeaseEv+0x23c>
    810e:	8f 85       	ldd	r24, Y+15	; 0x0f
    8110:	98 89       	ldd	r25, Y+16	; 0x10
    8112:	fc 01       	movw	r30, r24
    8114:	86 a5       	ldd	r24, Z+46	; 0x2e
    8116:	97 a5       	ldd	r25, Z+47	; 0x2f
    8118:	a0 a9       	ldd	r26, Z+48	; 0x30
    811a:	b1 a9       	ldd	r27, Z+49	; 0x31
    811c:	18 16       	cp	r1, r24
    811e:	19 06       	cpc	r1, r25
    8120:	1a 06       	cpc	r1, r26
    8122:	1b 06       	cpc	r1, r27
    8124:	74 f0       	brlt	.+28     	; 0x8142 <_ZN9DhcpClass10checkLeaseEv+0x23c>
            _dhcp_state = STATE_DHCP_REREQUEST;
    8126:	8f 85       	ldd	r24, Y+15	; 0x0f
    8128:	98 89       	ldd	r25, Y+16	; 0x10
    812a:	8a 5b       	subi	r24, 0xBA	; 186
    812c:	9f 4f       	sbci	r25, 0xFF	; 255
    812e:	24 e0       	ldi	r18, 0x04	; 4
    8130:	fc 01       	movw	r30, r24
    8132:	20 83       	st	Z, r18
            rc = 1 + request_DHCP_lease();
    8134:	8f 85       	ldd	r24, Y+15	; 0x0f
    8136:	98 89       	ldd	r25, Y+16	; 0x10
    8138:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <_ZN9DhcpClass18request_DHCP_leaseEv>
    813c:	01 96       	adiw	r24, 0x01	; 1
    813e:	9a 83       	std	Y+2, r25	; 0x02
    8140:	89 83       	std	Y+1, r24	; 0x01
        }

        //if we have a lease or is renewing but should bind, do it
        if( (_dhcp_state == STATE_DHCP_LEASED || _dhcp_state == STATE_DHCP_START) && _rebindInSec <=0){
    8142:	8f 85       	ldd	r24, Y+15	; 0x0f
    8144:	98 89       	ldd	r25, Y+16	; 0x10
    8146:	8a 5b       	subi	r24, 0xBA	; 186
    8148:	9f 4f       	sbci	r25, 0xFF	; 255
    814a:	fc 01       	movw	r30, r24
    814c:	80 81       	ld	r24, Z
    814e:	83 30       	cpi	r24, 0x03	; 3
    8150:	41 f0       	breq	.+16     	; 0x8162 <_ZN9DhcpClass10checkLeaseEv+0x25c>
    8152:	8f 85       	ldd	r24, Y+15	; 0x0f
    8154:	98 89       	ldd	r25, Y+16	; 0x10
    8156:	8a 5b       	subi	r24, 0xBA	; 186
    8158:	9f 4f       	sbci	r25, 0xFF	; 255
    815a:	fc 01       	movw	r30, r24
    815c:	80 81       	ld	r24, Z
    815e:	88 23       	and	r24, r24
    8160:	79 f5       	brne	.+94     	; 0x81c0 <_ZN9DhcpClass10checkLeaseEv+0x2ba>
    8162:	8f 85       	ldd	r24, Y+15	; 0x0f
    8164:	98 89       	ldd	r25, Y+16	; 0x10
    8166:	fc 01       	movw	r30, r24
    8168:	82 a9       	ldd	r24, Z+50	; 0x32
    816a:	93 a9       	ldd	r25, Z+51	; 0x33
    816c:	a4 a9       	ldd	r26, Z+52	; 0x34
    816e:	b5 a9       	ldd	r27, Z+53	; 0x35
    8170:	18 16       	cp	r1, r24
    8172:	19 06       	cpc	r1, r25
    8174:	1a 06       	cpc	r1, r26
    8176:	1b 06       	cpc	r1, r27
    8178:	1c f1       	brlt	.+70     	; 0x81c0 <_ZN9DhcpClass10checkLeaseEv+0x2ba>
            //this should basically restart completely
            _dhcp_state = STATE_DHCP_START;
    817a:	8f 85       	ldd	r24, Y+15	; 0x0f
    817c:	98 89       	ldd	r25, Y+16	; 0x10
    817e:	8a 5b       	subi	r24, 0xBA	; 186
    8180:	9f 4f       	sbci	r25, 0xFF	; 255
    8182:	fc 01       	movw	r30, r24
    8184:	10 82       	st	Z, r1
            reset_DHCP_lease();
    8186:	8f 85       	ldd	r24, Y+15	; 0x0f
    8188:	98 89       	ldd	r25, Y+16	; 0x10
    818a:	0e 94 d5 37 	call	0x6faa	; 0x6faa <_ZN9DhcpClass16reset_DHCP_leaseEv>
            rc = 3 + request_DHCP_lease();
    818e:	8f 85       	ldd	r24, Y+15	; 0x0f
    8190:	98 89       	ldd	r25, Y+16	; 0x10
    8192:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <_ZN9DhcpClass18request_DHCP_leaseEv>
    8196:	03 96       	adiw	r24, 0x03	; 3
    8198:	9a 83       	std	Y+2, r25	; 0x02
    819a:	89 83       	std	Y+1, r24	; 0x01
    819c:	11 c0       	rjmp	.+34     	; 0x81c0 <_ZN9DhcpClass10checkLeaseEv+0x2ba>
        }
    }
    else{
        _secTimeout = snow + 1000;
    819e:	8f 81       	ldd	r24, Y+7	; 0x07
    81a0:	98 85       	ldd	r25, Y+8	; 0x08
    81a2:	a9 85       	ldd	r26, Y+9	; 0x09
    81a4:	ba 85       	ldd	r27, Y+10	; 0x0a
    81a6:	88 51       	subi	r24, 0x18	; 24
    81a8:	9c 4f       	sbci	r25, 0xFC	; 252
    81aa:	af 4f       	sbci	r26, 0xFF	; 255
    81ac:	bf 4f       	sbci	r27, 0xFF	; 255
    81ae:	2f 85       	ldd	r18, Y+15	; 0x0f
    81b0:	38 89       	ldd	r19, Y+16	; 0x10
    81b2:	2e 5b       	subi	r18, 0xBE	; 190
    81b4:	3f 4f       	sbci	r19, 0xFF	; 255
    81b6:	f9 01       	movw	r30, r18
    81b8:	80 83       	st	Z, r24
    81ba:	91 83       	std	Z+1, r25	; 0x01
    81bc:	a2 83       	std	Z+2, r26	; 0x02
    81be:	b3 83       	std	Z+3, r27	; 0x03
    }

    _lastCheck = now;
    81c0:	8b 81       	ldd	r24, Y+3	; 0x03
    81c2:	9c 81       	ldd	r25, Y+4	; 0x04
    81c4:	ad 81       	ldd	r26, Y+5	; 0x05
    81c6:	be 81       	ldd	r27, Y+6	; 0x06
    81c8:	2f 85       	ldd	r18, Y+15	; 0x0f
    81ca:	38 89       	ldd	r19, Y+16	; 0x10
    81cc:	f9 01       	movw	r30, r18
    81ce:	86 ab       	std	Z+54, r24	; 0x36
    81d0:	97 ab       	std	Z+55, r25	; 0x37
    81d2:	a0 af       	std	Z+56, r26	; 0x38
    81d4:	b1 af       	std	Z+57, r27	; 0x39
    return rc;
    81d6:	89 81       	ldd	r24, Y+1	; 0x01
    81d8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    81da:	60 96       	adiw	r28, 0x10	; 16
    81dc:	0f b6       	in	r0, 0x3f	; 63
    81de:	f8 94       	cli
    81e0:	de bf       	out	0x3e, r29	; 62
    81e2:	0f be       	out	0x3f, r0	; 63
    81e4:	cd bf       	out	0x3d, r28	; 61
    81e6:	df 91       	pop	r29
    81e8:	cf 91       	pop	r28
    81ea:	1f 91       	pop	r17
    81ec:	0f 91       	pop	r16
    81ee:	ff 90       	pop	r15
    81f0:	ef 90       	pop	r14
    81f2:	08 95       	ret

000081f4 <_ZN9DhcpClass10getLocalIpEv>:

IPAddress DhcpClass::getLocalIp()
{
    81f4:	cf 93       	push	r28
    81f6:	df 93       	push	r29
    81f8:	00 d0       	rcall	.+0      	; 0x81fa <_ZN9DhcpClass10getLocalIpEv+0x6>
    81fa:	00 d0       	rcall	.+0      	; 0x81fc <_ZN9DhcpClass10getLocalIpEv+0x8>
    81fc:	cd b7       	in	r28, 0x3d	; 61
    81fe:	de b7       	in	r29, 0x3e	; 62
    8200:	9a 83       	std	Y+2, r25	; 0x02
    8202:	89 83       	std	Y+1, r24	; 0x01
    8204:	7c 83       	std	Y+4, r23	; 0x04
    8206:	6b 83       	std	Y+3, r22	; 0x03
    return IPAddress(_dhcpLocalIp);
    8208:	8b 81       	ldd	r24, Y+3	; 0x03
    820a:	9c 81       	ldd	r25, Y+4	; 0x04
    820c:	9c 01       	movw	r18, r24
    820e:	22 5f       	subi	r18, 0xF2	; 242
    8210:	3f 4f       	sbci	r19, 0xFF	; 255
    8212:	89 81       	ldd	r24, Y+1	; 0x01
    8214:	9a 81       	ldd	r25, Y+2	; 0x02
    8216:	b9 01       	movw	r22, r18
    8218:	0e 94 0f 5a 	call	0xb41e	; 0xb41e <_ZN9IPAddressC1EPKh>
}
    821c:	89 81       	ldd	r24, Y+1	; 0x01
    821e:	9a 81       	ldd	r25, Y+2	; 0x02
    8220:	0f 90       	pop	r0
    8222:	0f 90       	pop	r0
    8224:	0f 90       	pop	r0
    8226:	0f 90       	pop	r0
    8228:	df 91       	pop	r29
    822a:	cf 91       	pop	r28
    822c:	08 95       	ret

0000822e <_ZN9DhcpClass13getSubnetMaskEv>:

IPAddress DhcpClass::getSubnetMask()
{
    822e:	cf 93       	push	r28
    8230:	df 93       	push	r29
    8232:	00 d0       	rcall	.+0      	; 0x8234 <_ZN9DhcpClass13getSubnetMaskEv+0x6>
    8234:	00 d0       	rcall	.+0      	; 0x8236 <_ZN9DhcpClass13getSubnetMaskEv+0x8>
    8236:	cd b7       	in	r28, 0x3d	; 61
    8238:	de b7       	in	r29, 0x3e	; 62
    823a:	9a 83       	std	Y+2, r25	; 0x02
    823c:	89 83       	std	Y+1, r24	; 0x01
    823e:	7c 83       	std	Y+4, r23	; 0x04
    8240:	6b 83       	std	Y+3, r22	; 0x03
    return IPAddress(_dhcpSubnetMask);
    8242:	8b 81       	ldd	r24, Y+3	; 0x03
    8244:	9c 81       	ldd	r25, Y+4	; 0x04
    8246:	9c 01       	movw	r18, r24
    8248:	2e 5e       	subi	r18, 0xEE	; 238
    824a:	3f 4f       	sbci	r19, 0xFF	; 255
    824c:	89 81       	ldd	r24, Y+1	; 0x01
    824e:	9a 81       	ldd	r25, Y+2	; 0x02
    8250:	b9 01       	movw	r22, r18
    8252:	0e 94 0f 5a 	call	0xb41e	; 0xb41e <_ZN9IPAddressC1EPKh>
}
    8256:	89 81       	ldd	r24, Y+1	; 0x01
    8258:	9a 81       	ldd	r25, Y+2	; 0x02
    825a:	0f 90       	pop	r0
    825c:	0f 90       	pop	r0
    825e:	0f 90       	pop	r0
    8260:	0f 90       	pop	r0
    8262:	df 91       	pop	r29
    8264:	cf 91       	pop	r28
    8266:	08 95       	ret

00008268 <_ZN9DhcpClass12getGatewayIpEv>:

IPAddress DhcpClass::getGatewayIp()
{
    8268:	cf 93       	push	r28
    826a:	df 93       	push	r29
    826c:	00 d0       	rcall	.+0      	; 0x826e <_ZN9DhcpClass12getGatewayIpEv+0x6>
    826e:	00 d0       	rcall	.+0      	; 0x8270 <_ZN9DhcpClass12getGatewayIpEv+0x8>
    8270:	cd b7       	in	r28, 0x3d	; 61
    8272:	de b7       	in	r29, 0x3e	; 62
    8274:	9a 83       	std	Y+2, r25	; 0x02
    8276:	89 83       	std	Y+1, r24	; 0x01
    8278:	7c 83       	std	Y+4, r23	; 0x04
    827a:	6b 83       	std	Y+3, r22	; 0x03
    return IPAddress(_dhcpGatewayIp);
    827c:	8b 81       	ldd	r24, Y+3	; 0x03
    827e:	9c 81       	ldd	r25, Y+4	; 0x04
    8280:	9c 01       	movw	r18, r24
    8282:	2a 5e       	subi	r18, 0xEA	; 234
    8284:	3f 4f       	sbci	r19, 0xFF	; 255
    8286:	89 81       	ldd	r24, Y+1	; 0x01
    8288:	9a 81       	ldd	r25, Y+2	; 0x02
    828a:	b9 01       	movw	r22, r18
    828c:	0e 94 0f 5a 	call	0xb41e	; 0xb41e <_ZN9IPAddressC1EPKh>
}
    8290:	89 81       	ldd	r24, Y+1	; 0x01
    8292:	9a 81       	ldd	r25, Y+2	; 0x02
    8294:	0f 90       	pop	r0
    8296:	0f 90       	pop	r0
    8298:	0f 90       	pop	r0
    829a:	0f 90       	pop	r0
    829c:	df 91       	pop	r29
    829e:	cf 91       	pop	r28
    82a0:	08 95       	ret

000082a2 <_ZN9DhcpClass15getDhcpServerIpEv>:

IPAddress DhcpClass::getDhcpServerIp()
{
    82a2:	cf 93       	push	r28
    82a4:	df 93       	push	r29
    82a6:	00 d0       	rcall	.+0      	; 0x82a8 <_ZN9DhcpClass15getDhcpServerIpEv+0x6>
    82a8:	00 d0       	rcall	.+0      	; 0x82aa <_ZN9DhcpClass15getDhcpServerIpEv+0x8>
    82aa:	cd b7       	in	r28, 0x3d	; 61
    82ac:	de b7       	in	r29, 0x3e	; 62
    82ae:	9a 83       	std	Y+2, r25	; 0x02
    82b0:	89 83       	std	Y+1, r24	; 0x01
    82b2:	7c 83       	std	Y+4, r23	; 0x04
    82b4:	6b 83       	std	Y+3, r22	; 0x03
    return IPAddress(_dhcpDhcpServerIp);
    82b6:	8b 81       	ldd	r24, Y+3	; 0x03
    82b8:	9c 81       	ldd	r25, Y+4	; 0x04
    82ba:	9c 01       	movw	r18, r24
    82bc:	26 5e       	subi	r18, 0xE6	; 230
    82be:	3f 4f       	sbci	r19, 0xFF	; 255
    82c0:	89 81       	ldd	r24, Y+1	; 0x01
    82c2:	9a 81       	ldd	r25, Y+2	; 0x02
    82c4:	b9 01       	movw	r22, r18
    82c6:	0e 94 0f 5a 	call	0xb41e	; 0xb41e <_ZN9IPAddressC1EPKh>
}
    82ca:	89 81       	ldd	r24, Y+1	; 0x01
    82cc:	9a 81       	ldd	r25, Y+2	; 0x02
    82ce:	0f 90       	pop	r0
    82d0:	0f 90       	pop	r0
    82d2:	0f 90       	pop	r0
    82d4:	0f 90       	pop	r0
    82d6:	df 91       	pop	r29
    82d8:	cf 91       	pop	r28
    82da:	08 95       	ret

000082dc <_ZN9DhcpClass14getDnsServerIpEv>:

IPAddress DhcpClass::getDnsServerIp()
{
    82dc:	cf 93       	push	r28
    82de:	df 93       	push	r29
    82e0:	00 d0       	rcall	.+0      	; 0x82e2 <_ZN9DhcpClass14getDnsServerIpEv+0x6>
    82e2:	00 d0       	rcall	.+0      	; 0x82e4 <_ZN9DhcpClass14getDnsServerIpEv+0x8>
    82e4:	cd b7       	in	r28, 0x3d	; 61
    82e6:	de b7       	in	r29, 0x3e	; 62
    82e8:	9a 83       	std	Y+2, r25	; 0x02
    82ea:	89 83       	std	Y+1, r24	; 0x01
    82ec:	7c 83       	std	Y+4, r23	; 0x04
    82ee:	6b 83       	std	Y+3, r22	; 0x03
    return IPAddress(_dhcpDnsServerIp);
    82f0:	8b 81       	ldd	r24, Y+3	; 0x03
    82f2:	9c 81       	ldd	r25, Y+4	; 0x04
    82f4:	9c 01       	movw	r18, r24
    82f6:	22 5e       	subi	r18, 0xE2	; 226
    82f8:	3f 4f       	sbci	r19, 0xFF	; 255
    82fa:	89 81       	ldd	r24, Y+1	; 0x01
    82fc:	9a 81       	ldd	r25, Y+2	; 0x02
    82fe:	b9 01       	movw	r22, r18
    8300:	0e 94 0f 5a 	call	0xb41e	; 0xb41e <_ZN9IPAddressC1EPKh>
}
    8304:	89 81       	ldd	r24, Y+1	; 0x01
    8306:	9a 81       	ldd	r25, Y+2	; 0x02
    8308:	0f 90       	pop	r0
    830a:	0f 90       	pop	r0
    830c:	0f 90       	pop	r0
    830e:	0f 90       	pop	r0
    8310:	df 91       	pop	r29
    8312:	cf 91       	pop	r28
    8314:	08 95       	ret

00008316 <_ZN9DhcpClass9printByteEPch>:

void DhcpClass::printByte(char * buf, uint8_t n ) {
    8316:	cf 93       	push	r28
    8318:	df 93       	push	r29
    831a:	cd b7       	in	r28, 0x3d	; 61
    831c:	de b7       	in	r29, 0x3e	; 62
    831e:	2c 97       	sbiw	r28, 0x0c	; 12
    8320:	0f b6       	in	r0, 0x3f	; 63
    8322:	f8 94       	cli
    8324:	de bf       	out	0x3e, r29	; 62
    8326:	0f be       	out	0x3f, r0	; 63
    8328:	cd bf       	out	0x3d, r28	; 61
    832a:	99 87       	std	Y+9, r25	; 0x09
    832c:	88 87       	std	Y+8, r24	; 0x08
    832e:	7b 87       	std	Y+11, r23	; 0x0b
    8330:	6a 87       	std	Y+10, r22	; 0x0a
    8332:	4c 87       	std	Y+12, r20	; 0x0c
  char *str = &buf[1];
    8334:	8a 85       	ldd	r24, Y+10	; 0x0a
    8336:	9b 85       	ldd	r25, Y+11	; 0x0b
    8338:	01 96       	adiw	r24, 0x01	; 1
    833a:	9a 83       	std	Y+2, r25	; 0x02
    833c:	89 83       	std	Y+1, r24	; 0x01
  buf[0]='0';
    833e:	8a 85       	ldd	r24, Y+10	; 0x0a
    8340:	9b 85       	ldd	r25, Y+11	; 0x0b
    8342:	20 e3       	ldi	r18, 0x30	; 48
    8344:	fc 01       	movw	r30, r24
    8346:	20 83       	st	Z, r18
  do {
    unsigned long m = n;
    8348:	8c 85       	ldd	r24, Y+12	; 0x0c
    834a:	88 2f       	mov	r24, r24
    834c:	90 e0       	ldi	r25, 0x00	; 0
    834e:	a0 e0       	ldi	r26, 0x00	; 0
    8350:	b0 e0       	ldi	r27, 0x00	; 0
    8352:	8b 83       	std	Y+3, r24	; 0x03
    8354:	9c 83       	std	Y+4, r25	; 0x04
    8356:	ad 83       	std	Y+5, r26	; 0x05
    8358:	be 83       	std	Y+6, r27	; 0x06
    n /= 16;
    835a:	8c 85       	ldd	r24, Y+12	; 0x0c
    835c:	82 95       	swap	r24
    835e:	8f 70       	andi	r24, 0x0F	; 15
    8360:	8c 87       	std	Y+12, r24	; 0x0c
    char c = m - 16 * n;
    8362:	9b 81       	ldd	r25, Y+3	; 0x03
    8364:	8c 85       	ldd	r24, Y+12	; 0x0c
    8366:	82 95       	swap	r24
    8368:	80 7f       	andi	r24, 0xF0	; 240
    836a:	f9 2f       	mov	r31, r25
    836c:	f8 1b       	sub	r31, r24
    836e:	8f 2f       	mov	r24, r31
    8370:	8f 83       	std	Y+7, r24	; 0x07
    *str-- = c < 10 ? c + '0' : c + 'A' - 10;
    8372:	8f 81       	ldd	r24, Y+7	; 0x07
    8374:	8a 30       	cpi	r24, 0x0A	; 10
    8376:	20 f4       	brcc	.+8      	; 0x8380 <_ZN9DhcpClass9printByteEPch+0x6a>
    8378:	8f 81       	ldd	r24, Y+7	; 0x07
    837a:	28 2f       	mov	r18, r24
    837c:	20 5d       	subi	r18, 0xD0	; 208
    837e:	03 c0       	rjmp	.+6      	; 0x8386 <_ZN9DhcpClass9printByteEPch+0x70>
    8380:	8f 81       	ldd	r24, Y+7	; 0x07
    8382:	28 2f       	mov	r18, r24
    8384:	29 5c       	subi	r18, 0xC9	; 201
    8386:	89 81       	ldd	r24, Y+1	; 0x01
    8388:	9a 81       	ldd	r25, Y+2	; 0x02
    838a:	fc 01       	movw	r30, r24
    838c:	20 83       	st	Z, r18
    838e:	89 81       	ldd	r24, Y+1	; 0x01
    8390:	9a 81       	ldd	r25, Y+2	; 0x02
    8392:	01 97       	sbiw	r24, 0x01	; 1
    8394:	9a 83       	std	Y+2, r25	; 0x02
    8396:	89 83       	std	Y+1, r24	; 0x01
}

void DhcpClass::printByte(char * buf, uint8_t n ) {
  char *str = &buf[1];
  buf[0]='0';
  do {
    8398:	81 e0       	ldi	r24, 0x01	; 1
    839a:	9c 85       	ldd	r25, Y+12	; 0x0c
    839c:	99 23       	and	r25, r25
    839e:	09 f4       	brne	.+2      	; 0x83a2 <_ZN9DhcpClass9printByteEPch+0x8c>
    83a0:	80 e0       	ldi	r24, 0x00	; 0
    83a2:	88 23       	and	r24, r24
    83a4:	89 f6       	brne	.-94     	; 0x8348 <_ZN9DhcpClass9printByteEPch+0x32>
    unsigned long m = n;
    n /= 16;
    char c = m - 16 * n;
    *str-- = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);
}
    83a6:	2c 96       	adiw	r28, 0x0c	; 12
    83a8:	0f b6       	in	r0, 0x3f	; 63
    83aa:	f8 94       	cli
    83ac:	de bf       	out	0x3e, r29	; 62
    83ae:	0f be       	out	0x3f, r0	; 63
    83b0:	cd bf       	out	0x3d, r28	; 61
    83b2:	df 91       	pop	r29
    83b4:	cf 91       	pop	r28
    83b6:	08 95       	ret

000083b8 <_Z41__static_initialization_and_destruction_0ii>:
    83b8:	0f 93       	push	r16
    83ba:	cf 93       	push	r28
    83bc:	df 93       	push	r29
    83be:	00 d0       	rcall	.+0      	; 0x83c0 <_Z41__static_initialization_and_destruction_0ii+0x8>
    83c0:	00 d0       	rcall	.+0      	; 0x83c2 <_Z41__static_initialization_and_destruction_0ii+0xa>
    83c2:	cd b7       	in	r28, 0x3d	; 61
    83c4:	de b7       	in	r29, 0x3e	; 62
    83c6:	9a 83       	std	Y+2, r25	; 0x02
    83c8:	89 83       	std	Y+1, r24	; 0x01
    83ca:	7c 83       	std	Y+4, r23	; 0x04
    83cc:	6b 83       	std	Y+3, r22	; 0x03
    83ce:	89 81       	ldd	r24, Y+1	; 0x01
    83d0:	9a 81       	ldd	r25, Y+2	; 0x02
    83d2:	81 30       	cpi	r24, 0x01	; 1
    83d4:	91 05       	cpc	r25, r1
    83d6:	71 f4       	brne	.+28     	; 0x83f4 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    83d8:	8b 81       	ldd	r24, Y+3	; 0x03
    83da:	9c 81       	ldd	r25, Y+4	; 0x04
    83dc:	8f 3f       	cpi	r24, 0xFF	; 255
    83de:	2f ef       	ldi	r18, 0xFF	; 255
    83e0:	92 07       	cpc	r25, r18
    83e2:	41 f4       	brne	.+16     	; 0x83f4 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    83e4:	00 e0       	ldi	r16, 0x00	; 0
    83e6:	20 e0       	ldi	r18, 0x00	; 0
    83e8:	40 e0       	ldi	r20, 0x00	; 0
    83ea:	60 e0       	ldi	r22, 0x00	; 0
    83ec:	8c e9       	ldi	r24, 0x9C	; 156
    83ee:	97 e0       	ldi	r25, 0x07	; 7
    83f0:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    83f4:	0f 90       	pop	r0
    83f6:	0f 90       	pop	r0
    83f8:	0f 90       	pop	r0
    83fa:	0f 90       	pop	r0
    83fc:	df 91       	pop	r29
    83fe:	cf 91       	pop	r28
    8400:	0f 91       	pop	r16
    8402:	08 95       	ret

00008404 <_GLOBAL__sub_I__ZN9DhcpClass13beginWithDHCPEPhmm>:
    8404:	cf 93       	push	r28
    8406:	df 93       	push	r29
    8408:	cd b7       	in	r28, 0x3d	; 61
    840a:	de b7       	in	r29, 0x3e	; 62
    840c:	6f ef       	ldi	r22, 0xFF	; 255
    840e:	7f ef       	ldi	r23, 0xFF	; 255
    8410:	81 e0       	ldi	r24, 0x01	; 1
    8412:	90 e0       	ldi	r25, 0x00	; 0
    8414:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <_Z41__static_initialization_and_destruction_0ii>
    8418:	df 91       	pop	r29
    841a:	cf 91       	pop	r28
    841c:	08 95       	ret

0000841e <_ZN9DNSClient5beginERK9IPAddress>:
#define INVALID_SERVER   -2
#define TRUNCATED        -3
#define INVALID_RESPONSE -4

void DNSClient::begin(const IPAddress& aDNSServer)
{
    841e:	cf 93       	push	r28
    8420:	df 93       	push	r29
    8422:	00 d0       	rcall	.+0      	; 0x8424 <_ZN9DNSClient5beginERK9IPAddress+0x6>
    8424:	00 d0       	rcall	.+0      	; 0x8426 <_ZN9DNSClient5beginERK9IPAddress+0x8>
    8426:	cd b7       	in	r28, 0x3d	; 61
    8428:	de b7       	in	r29, 0x3e	; 62
    842a:	9a 83       	std	Y+2, r25	; 0x02
    842c:	89 83       	std	Y+1, r24	; 0x01
    842e:	7c 83       	std	Y+4, r23	; 0x04
    8430:	6b 83       	std	Y+3, r22	; 0x03
    iDNSServer = aDNSServer;
    8432:	89 81       	ldd	r24, Y+1	; 0x01
    8434:	9a 81       	ldd	r25, Y+2	; 0x02
    8436:	2b 81       	ldd	r18, Y+3	; 0x03
    8438:	3c 81       	ldd	r19, Y+4	; 0x04
    843a:	b9 01       	movw	r22, r18
    843c:	0e 94 9b aa 	call	0x15536	; 0x15536 <_ZN9IPAddressaSERKS_>
    iRequestId = 0;
    8440:	89 81       	ldd	r24, Y+1	; 0x01
    8442:	9a 81       	ldd	r25, Y+2	; 0x02
    8444:	fc 01       	movw	r30, r24
    8446:	17 82       	std	Z+7, r1	; 0x07
    8448:	16 82       	std	Z+6, r1	; 0x06
}
    844a:	0f 90       	pop	r0
    844c:	0f 90       	pop	r0
    844e:	0f 90       	pop	r0
    8450:	0f 90       	pop	r0
    8452:	df 91       	pop	r29
    8454:	cf 91       	pop	r28
    8456:	08 95       	ret

00008458 <_ZN9DNSClient9inet_atonEPKcR9IPAddress>:


int DNSClient::inet_aton(const char* aIPAddrString, IPAddress& aResult)
{
    8458:	cf 93       	push	r28
    845a:	df 93       	push	r29
    845c:	cd b7       	in	r28, 0x3d	; 61
    845e:	de b7       	in	r29, 0x3e	; 62
    8460:	2c 97       	sbiw	r28, 0x0c	; 12
    8462:	0f b6       	in	r0, 0x3f	; 63
    8464:	f8 94       	cli
    8466:	de bf       	out	0x3e, r29	; 62
    8468:	0f be       	out	0x3f, r0	; 63
    846a:	cd bf       	out	0x3d, r28	; 61
    846c:	98 87       	std	Y+8, r25	; 0x08
    846e:	8f 83       	std	Y+7, r24	; 0x07
    8470:	7a 87       	std	Y+10, r23	; 0x0a
    8472:	69 87       	std	Y+9, r22	; 0x09
    8474:	5c 87       	std	Y+12, r21	; 0x0c
    8476:	4b 87       	std	Y+11, r20	; 0x0b
    // See if we've been given a valid IP address
    const char* p =aIPAddrString;
    8478:	89 85       	ldd	r24, Y+9	; 0x09
    847a:	9a 85       	ldd	r25, Y+10	; 0x0a
    847c:	9a 83       	std	Y+2, r25	; 0x02
    847e:	89 83       	std	Y+1, r24	; 0x01
    while (*p &&
    8480:	05 c0       	rjmp	.+10     	; 0x848c <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x34>
           ( (*p == '.') || (*p >= '0') || (*p <= '9') ))
    {
        p++;
    8482:	89 81       	ldd	r24, Y+1	; 0x01
    8484:	9a 81       	ldd	r25, Y+2	; 0x02
    8486:	01 96       	adiw	r24, 0x01	; 1
    8488:	9a 83       	std	Y+2, r25	; 0x02
    848a:	89 83       	std	Y+1, r24	; 0x01

int DNSClient::inet_aton(const char* aIPAddrString, IPAddress& aResult)
{
    // See if we've been given a valid IP address
    const char* p =aIPAddrString;
    while (*p &&
    848c:	89 81       	ldd	r24, Y+1	; 0x01
    848e:	9a 81       	ldd	r25, Y+2	; 0x02
    8490:	fc 01       	movw	r30, r24
    8492:	80 81       	ld	r24, Z
    8494:	88 23       	and	r24, r24
    8496:	a1 f0       	breq	.+40     	; 0x84c0 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x68>
    8498:	89 81       	ldd	r24, Y+1	; 0x01
    849a:	9a 81       	ldd	r25, Y+2	; 0x02
    849c:	fc 01       	movw	r30, r24
    849e:	80 81       	ld	r24, Z
    84a0:	8e 32       	cpi	r24, 0x2E	; 46
    84a2:	61 f0       	breq	.+24     	; 0x84bc <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x64>
    84a4:	89 81       	ldd	r24, Y+1	; 0x01
    84a6:	9a 81       	ldd	r25, Y+2	; 0x02
    84a8:	fc 01       	movw	r30, r24
    84aa:	80 81       	ld	r24, Z
    84ac:	80 33       	cpi	r24, 0x30	; 48
    84ae:	30 f4       	brcc	.+12     	; 0x84bc <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x64>
    84b0:	89 81       	ldd	r24, Y+1	; 0x01
    84b2:	9a 81       	ldd	r25, Y+2	; 0x02
    84b4:	fc 01       	movw	r30, r24
    84b6:	80 81       	ld	r24, Z
    84b8:	8a 33       	cpi	r24, 0x3A	; 58
    84ba:	10 f4       	brcc	.+4      	; 0x84c0 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x68>
    84bc:	81 e0       	ldi	r24, 0x01	; 1
    84be:	01 c0       	rjmp	.+2      	; 0x84c2 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x6a>
    84c0:	80 e0       	ldi	r24, 0x00	; 0
    84c2:	88 23       	and	r24, r24
    84c4:	f1 f6       	brne	.-68     	; 0x8482 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x2a>
           ( (*p == '.') || (*p >= '0') || (*p <= '9') ))
    {
        p++;
    }

    if (*p == '\0')
    84c6:	89 81       	ldd	r24, Y+1	; 0x01
    84c8:	9a 81       	ldd	r25, Y+2	; 0x02
    84ca:	fc 01       	movw	r30, r24
    84cc:	80 81       	ld	r24, Z
    84ce:	88 23       	and	r24, r24
    84d0:	09 f0       	breq	.+2      	; 0x84d4 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x7c>
    84d2:	71 c0       	rjmp	.+226    	; 0x85b6 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x15e>
    {
        // It's looking promising, we haven't found any invalid characters
        p = aIPAddrString;
    84d4:	89 85       	ldd	r24, Y+9	; 0x09
    84d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    84d8:	9a 83       	std	Y+2, r25	; 0x02
    84da:	89 83       	std	Y+1, r24	; 0x01
        int segment =0;
    84dc:	1c 82       	std	Y+4, r1	; 0x04
    84de:	1b 82       	std	Y+3, r1	; 0x03
        int segmentValue =0;
    84e0:	1e 82       	std	Y+6, r1	; 0x06
    84e2:	1d 82       	std	Y+5, r1	; 0x05
        while (*p && (segment < 4))
    84e4:	3c c0       	rjmp	.+120    	; 0x855e <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x106>
        {
            if (*p == '.')
    84e6:	89 81       	ldd	r24, Y+1	; 0x01
    84e8:	9a 81       	ldd	r25, Y+2	; 0x02
    84ea:	fc 01       	movw	r30, r24
    84ec:	80 81       	ld	r24, Z
    84ee:	8e 32       	cpi	r24, 0x2E	; 46
    84f0:	d9 f4       	brne	.+54     	; 0x8528 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0xd0>
            {
                // We've reached the end of a segment
                if (segmentValue > 255)
    84f2:	8d 81       	ldd	r24, Y+5	; 0x05
    84f4:	9e 81       	ldd	r25, Y+6	; 0x06
    84f6:	8f 3f       	cpi	r24, 0xFF	; 255
    84f8:	91 05       	cpc	r25, r1
    84fa:	21 f0       	breq	.+8      	; 0x8504 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0xac>
    84fc:	1c f0       	brlt	.+6      	; 0x8504 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0xac>
                {
                    // You can't have IP address segments that don't fit in a byte
                    return 0;
    84fe:	80 e0       	ldi	r24, 0x00	; 0
    8500:	90 e0       	ldi	r25, 0x00	; 0
    8502:	5b c0       	rjmp	.+182    	; 0x85ba <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x162>
                }
                else
                {
                    aResult[segment] = (byte)segmentValue;
    8504:	2b 81       	ldd	r18, Y+3	; 0x03
    8506:	3c 81       	ldd	r19, Y+4	; 0x04
    8508:	8b 85       	ldd	r24, Y+11	; 0x0b
    850a:	9c 85       	ldd	r25, Y+12	; 0x0c
    850c:	b9 01       	movw	r22, r18
    850e:	0e 94 70 aa 	call	0x154e0	; 0x154e0 <_ZN9IPAddressixEi>
    8512:	2d 81       	ldd	r18, Y+5	; 0x05
    8514:	fc 01       	movw	r30, r24
    8516:	20 83       	st	Z, r18
                    segment++;
    8518:	8b 81       	ldd	r24, Y+3	; 0x03
    851a:	9c 81       	ldd	r25, Y+4	; 0x04
    851c:	01 96       	adiw	r24, 0x01	; 1
    851e:	9c 83       	std	Y+4, r25	; 0x04
    8520:	8b 83       	std	Y+3, r24	; 0x03
                    segmentValue = 0;
    8522:	1e 82       	std	Y+6, r1	; 0x06
    8524:	1d 82       	std	Y+5, r1	; 0x05
    8526:	16 c0       	rjmp	.+44     	; 0x8554 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0xfc>
                }
            }
            else
            {
                // Next digit
                segmentValue = (segmentValue*10)+(*p - '0');
    8528:	8d 81       	ldd	r24, Y+5	; 0x05
    852a:	9e 81       	ldd	r25, Y+6	; 0x06
    852c:	88 0f       	add	r24, r24
    852e:	99 1f       	adc	r25, r25
    8530:	9c 01       	movw	r18, r24
    8532:	22 0f       	add	r18, r18
    8534:	33 1f       	adc	r19, r19
    8536:	22 0f       	add	r18, r18
    8538:	33 1f       	adc	r19, r19
    853a:	28 0f       	add	r18, r24
    853c:	39 1f       	adc	r19, r25
    853e:	89 81       	ldd	r24, Y+1	; 0x01
    8540:	9a 81       	ldd	r25, Y+2	; 0x02
    8542:	fc 01       	movw	r30, r24
    8544:	80 81       	ld	r24, Z
    8546:	88 2f       	mov	r24, r24
    8548:	90 e0       	ldi	r25, 0x00	; 0
    854a:	c0 97       	sbiw	r24, 0x30	; 48
    854c:	82 0f       	add	r24, r18
    854e:	93 1f       	adc	r25, r19
    8550:	9e 83       	std	Y+6, r25	; 0x06
    8552:	8d 83       	std	Y+5, r24	; 0x05
            }
            p++;
    8554:	89 81       	ldd	r24, Y+1	; 0x01
    8556:	9a 81       	ldd	r25, Y+2	; 0x02
    8558:	01 96       	adiw	r24, 0x01	; 1
    855a:	9a 83       	std	Y+2, r25	; 0x02
    855c:	89 83       	std	Y+1, r24	; 0x01
    {
        // It's looking promising, we haven't found any invalid characters
        p = aIPAddrString;
        int segment =0;
        int segmentValue =0;
        while (*p && (segment < 4))
    855e:	89 81       	ldd	r24, Y+1	; 0x01
    8560:	9a 81       	ldd	r25, Y+2	; 0x02
    8562:	fc 01       	movw	r30, r24
    8564:	80 81       	ld	r24, Z
    8566:	88 23       	and	r24, r24
    8568:	39 f0       	breq	.+14     	; 0x8578 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x120>
    856a:	8b 81       	ldd	r24, Y+3	; 0x03
    856c:	9c 81       	ldd	r25, Y+4	; 0x04
    856e:	84 30       	cpi	r24, 0x04	; 4
    8570:	91 05       	cpc	r25, r1
    8572:	14 f4       	brge	.+4      	; 0x8578 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x120>
    8574:	81 e0       	ldi	r24, 0x01	; 1
    8576:	01 c0       	rjmp	.+2      	; 0x857a <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x122>
    8578:	80 e0       	ldi	r24, 0x00	; 0
    857a:	88 23       	and	r24, r24
    857c:	09 f0       	breq	.+2      	; 0x8580 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x128>
    857e:	b3 cf       	rjmp	.-154    	; 0x84e6 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x8e>
            }
            p++;
        }
        // We've reached the end of address, but there'll still be the last
        // segment to deal with
        if ((segmentValue > 255) || (segment > 3))
    8580:	8d 81       	ldd	r24, Y+5	; 0x05
    8582:	9e 81       	ldd	r25, Y+6	; 0x06
    8584:	8f 3f       	cpi	r24, 0xFF	; 255
    8586:	91 05       	cpc	r25, r1
    8588:	09 f0       	breq	.+2      	; 0x858c <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x134>
    858a:	2c f4       	brge	.+10     	; 0x8596 <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x13e>
    858c:	8b 81       	ldd	r24, Y+3	; 0x03
    858e:	9c 81       	ldd	r25, Y+4	; 0x04
    8590:	84 30       	cpi	r24, 0x04	; 4
    8592:	91 05       	cpc	r25, r1
    8594:	1c f0       	brlt	.+6      	; 0x859c <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x144>
        {
            // You can't have IP address segments that don't fit in a byte,
            // or more than four segments
            return 0;
    8596:	80 e0       	ldi	r24, 0x00	; 0
    8598:	90 e0       	ldi	r25, 0x00	; 0
    859a:	0f c0       	rjmp	.+30     	; 0x85ba <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x162>
        }
        else
        {
            aResult[segment] = (byte)segmentValue;
    859c:	2b 81       	ldd	r18, Y+3	; 0x03
    859e:	3c 81       	ldd	r19, Y+4	; 0x04
    85a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    85a2:	9c 85       	ldd	r25, Y+12	; 0x0c
    85a4:	b9 01       	movw	r22, r18
    85a6:	0e 94 70 aa 	call	0x154e0	; 0x154e0 <_ZN9IPAddressixEi>
    85aa:	2d 81       	ldd	r18, Y+5	; 0x05
    85ac:	fc 01       	movw	r30, r24
    85ae:	20 83       	st	Z, r18
            return 1;
    85b0:	81 e0       	ldi	r24, 0x01	; 1
    85b2:	90 e0       	ldi	r25, 0x00	; 0
    85b4:	02 c0       	rjmp	.+4      	; 0x85ba <_ZN9DNSClient9inet_atonEPKcR9IPAddress+0x162>
        }
    }
    else
    {
        return 0;
    85b6:	80 e0       	ldi	r24, 0x00	; 0
    85b8:	90 e0       	ldi	r25, 0x00	; 0
    }
}
    85ba:	2c 96       	adiw	r28, 0x0c	; 12
    85bc:	0f b6       	in	r0, 0x3f	; 63
    85be:	f8 94       	cli
    85c0:	de bf       	out	0x3e, r29	; 62
    85c2:	0f be       	out	0x3f, r0	; 63
    85c4:	cd bf       	out	0x3d, r28	; 61
    85c6:	df 91       	pop	r29
    85c8:	cf 91       	pop	r28
    85ca:	08 95       	ret

000085cc <_ZN9DNSClient13getHostByNameEPKcR9IPAddress>:

int DNSClient::getHostByName(const char* aHostname, IPAddress& aResult)
{
    85cc:	cf 93       	push	r28
    85ce:	df 93       	push	r29
    85d0:	cd b7       	in	r28, 0x3d	; 61
    85d2:	de b7       	in	r29, 0x3e	; 62
    85d4:	62 97       	sbiw	r28, 0x12	; 18
    85d6:	0f b6       	in	r0, 0x3f	; 63
    85d8:	f8 94       	cli
    85da:	de bf       	out	0x3e, r29	; 62
    85dc:	0f be       	out	0x3f, r0	; 63
    85de:	cd bf       	out	0x3d, r28	; 61
    85e0:	9e 87       	std	Y+14, r25	; 0x0e
    85e2:	8d 87       	std	Y+13, r24	; 0x0d
    85e4:	78 8b       	std	Y+16, r23	; 0x10
    85e6:	6f 87       	std	Y+15, r22	; 0x0f
    85e8:	5a 8b       	std	Y+18, r21	; 0x12
    85ea:	49 8b       	std	Y+17, r20	; 0x11
    int ret =0;
    85ec:	1a 82       	std	Y+2, r1	; 0x02
    85ee:	19 82       	std	Y+1, r1	; 0x01

    // See if it's a numeric IP address
    if (inet_aton(aHostname, aResult))
    85f0:	49 89       	ldd	r20, Y+17	; 0x11
    85f2:	5a 89       	ldd	r21, Y+18	; 0x12
    85f4:	2f 85       	ldd	r18, Y+15	; 0x0f
    85f6:	38 89       	ldd	r19, Y+16	; 0x10
    85f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    85fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    85fc:	b9 01       	movw	r22, r18
    85fe:	0e 94 2c 42 	call	0x8458	; 0x8458 <_ZN9DNSClient9inet_atonEPKcR9IPAddress>
    8602:	21 e0       	ldi	r18, 0x01	; 1
    8604:	00 97       	sbiw	r24, 0x00	; 0
    8606:	09 f4       	brne	.+2      	; 0x860a <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x3e>
    8608:	20 e0       	ldi	r18, 0x00	; 0
    860a:	22 23       	and	r18, r18
    860c:	19 f0       	breq	.+6      	; 0x8614 <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x48>
    {
        // It is, our work here is done
        return 1;
    860e:	81 e0       	ldi	r24, 0x01	; 1
    8610:	90 e0       	ldi	r25, 0x00	; 0
    8612:	87 c0       	rjmp	.+270    	; 0x8722 <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x156>
    }

    // Check we've got a valid DNS server to use
    if (iDNSServer == INADDR_NONE)
    8614:	8d 85       	ldd	r24, Y+13	; 0x0d
    8616:	9e 85       	ldd	r25, Y+14	; 0x0e
    8618:	62 ea       	ldi	r22, 0xA2	; 162
    861a:	77 e0       	ldi	r23, 0x07	; 7
    861c:	0e 94 0a aa 	call	0x15414	; 0x15414 <_ZN9IPAddresseqERKS_>
    8620:	88 23       	and	r24, r24
    8622:	19 f0       	breq	.+6      	; 0x862a <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x5e>
    {
        return INVALID_SERVER;
    8624:	8e ef       	ldi	r24, 0xFE	; 254
    8626:	9f ef       	ldi	r25, 0xFF	; 255
    8628:	7c c0       	rjmp	.+248    	; 0x8722 <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x156>
    }
	
    // Find a socket to use
    if (iUdp.begin(1024+(millis() & 0xF)) == 1)
    862a:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    862e:	dc 01       	movw	r26, r24
    8630:	cb 01       	movw	r24, r22
    8632:	8f 70       	andi	r24, 0x0F	; 15
    8634:	99 27       	eor	r25, r25
    8636:	9c 01       	movw	r18, r24
    8638:	3c 5f       	subi	r19, 0xFC	; 252
    863a:	8d 85       	ldd	r24, Y+13	; 0x0d
    863c:	9e 85       	ldd	r25, Y+14	; 0x0e
    863e:	08 96       	adiw	r24, 0x08	; 8
    8640:	b9 01       	movw	r22, r18
    8642:	0e 94 f6 4f 	call	0x9fec	; 0x9fec <_ZN11EthernetUDP5beginEj>
    8646:	98 2f       	mov	r25, r24
    8648:	81 e0       	ldi	r24, 0x01	; 1
    864a:	91 30       	cpi	r25, 0x01	; 1
    864c:	09 f0       	breq	.+2      	; 0x8650 <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x84>
    864e:	80 e0       	ldi	r24, 0x00	; 0
    8650:	88 23       	and	r24, r24
    8652:	09 f4       	brne	.+2      	; 0x8656 <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x8a>
    8654:	64 c0       	rjmp	.+200    	; 0x871e <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x152>
    {
        // Try up to three times
        int retries = 0;
    8656:	1e 82       	std	Y+6, r1	; 0x06
    8658:	1d 82       	std	Y+5, r1	; 0x05
//        while ((retries < 3) && (ret <= 0))
        {
            // Send DNS request
            ret = iUdp.beginPacket(iDNSServer, DNS_PORT);
    865a:	2d 85       	ldd	r18, Y+13	; 0x0d
    865c:	3e 85       	ldd	r19, Y+14	; 0x0e
    865e:	ce 01       	movw	r24, r28
    8660:	07 96       	adiw	r24, 0x07	; 7
    8662:	b9 01       	movw	r22, r18
    8664:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    8668:	8d 85       	ldd	r24, Y+13	; 0x0d
    866a:	9e 85       	ldd	r25, Y+14	; 0x0e
    866c:	08 96       	adiw	r24, 0x08	; 8
    866e:	9e 01       	movw	r18, r28
    8670:	29 5f       	subi	r18, 0xF9	; 249
    8672:	3f 4f       	sbci	r19, 0xFF	; 255
    8674:	45 e3       	ldi	r20, 0x35	; 53
    8676:	50 e0       	ldi	r21, 0x00	; 0
    8678:	b9 01       	movw	r22, r18
    867a:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <_ZN11EthernetUDP11beginPacketE9IPAddressj>
    867e:	9a 83       	std	Y+2, r25	; 0x02
    8680:	89 83       	std	Y+1, r24	; 0x01
            if (ret != 0)
    8682:	89 81       	ldd	r24, Y+1	; 0x01
    8684:	9a 81       	ldd	r25, Y+2	; 0x02
    8686:	00 97       	sbiw	r24, 0x00	; 0
    8688:	09 f4       	brne	.+2      	; 0x868c <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0xc0>
    868a:	3f c0       	rjmp	.+126    	; 0x870a <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x13e>
            {
                // Now output the request data
                ret = BuildRequest(aHostname);
    868c:	2f 85       	ldd	r18, Y+15	; 0x0f
    868e:	38 89       	ldd	r19, Y+16	; 0x10
    8690:	8d 85       	ldd	r24, Y+13	; 0x0d
    8692:	9e 85       	ldd	r25, Y+14	; 0x0e
    8694:	b9 01       	movw	r22, r18
    8696:	0e 94 9a 43 	call	0x8734	; 0x8734 <_ZN9DNSClient12BuildRequestEPKc>
    869a:	9a 83       	std	Y+2, r25	; 0x02
    869c:	89 83       	std	Y+1, r24	; 0x01
                if (ret != 0)
    869e:	89 81       	ldd	r24, Y+1	; 0x01
    86a0:	9a 81       	ldd	r25, Y+2	; 0x02
    86a2:	00 97       	sbiw	r24, 0x00	; 0
    86a4:	91 f1       	breq	.+100    	; 0x870a <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x13e>
                {
                    // And finally send the request
                    ret = iUdp.endPacket();
    86a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    86a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    86aa:	08 96       	adiw	r24, 0x08	; 8
    86ac:	0e 94 2b 51 	call	0xa256	; 0xa256 <_ZN11EthernetUDP9endPacketEv>
    86b0:	9a 83       	std	Y+2, r25	; 0x02
    86b2:	89 83       	std	Y+1, r24	; 0x01
                    if (ret != 0)
    86b4:	89 81       	ldd	r24, Y+1	; 0x01
    86b6:	9a 81       	ldd	r25, Y+2	; 0x02
    86b8:	00 97       	sbiw	r24, 0x00	; 0
    86ba:	39 f1       	breq	.+78     	; 0x870a <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x13e>
                    {
                        // Now wait for a response
                        int wait_retries = 0;
    86bc:	1c 82       	std	Y+4, r1	; 0x04
    86be:	1b 82       	std	Y+3, r1	; 0x03
                        ret = TIMED_OUT;
    86c0:	8f ef       	ldi	r24, 0xFF	; 255
    86c2:	9f ef       	ldi	r25, 0xFF	; 255
    86c4:	9a 83       	std	Y+2, r25	; 0x02
    86c6:	89 83       	std	Y+1, r24	; 0x01
                        while ((wait_retries < 3) && (ret == TIMED_OUT))
    86c8:	10 c0       	rjmp	.+32     	; 0x86ea <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x11e>
                        {
                            ret = ProcessResponse(5000, aResult);
    86ca:	29 89       	ldd	r18, Y+17	; 0x11
    86cc:	3a 89       	ldd	r19, Y+18	; 0x12
    86ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    86d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    86d2:	a9 01       	movw	r20, r18
    86d4:	68 e8       	ldi	r22, 0x88	; 136
    86d6:	73 e1       	ldi	r23, 0x13	; 19
    86d8:	0e 94 99 44 	call	0x8932	; 0x8932 <_ZN9DNSClient15ProcessResponseEjR9IPAddress>
    86dc:	9a 83       	std	Y+2, r25	; 0x02
    86de:	89 83       	std	Y+1, r24	; 0x01
                            wait_retries++;
    86e0:	8b 81       	ldd	r24, Y+3	; 0x03
    86e2:	9c 81       	ldd	r25, Y+4	; 0x04
    86e4:	01 96       	adiw	r24, 0x01	; 1
    86e6:	9c 83       	std	Y+4, r25	; 0x04
    86e8:	8b 83       	std	Y+3, r24	; 0x03
                    if (ret != 0)
                    {
                        // Now wait for a response
                        int wait_retries = 0;
                        ret = TIMED_OUT;
                        while ((wait_retries < 3) && (ret == TIMED_OUT))
    86ea:	8b 81       	ldd	r24, Y+3	; 0x03
    86ec:	9c 81       	ldd	r25, Y+4	; 0x04
    86ee:	83 30       	cpi	r24, 0x03	; 3
    86f0:	91 05       	cpc	r25, r1
    86f2:	44 f4       	brge	.+16     	; 0x8704 <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x138>
    86f4:	89 81       	ldd	r24, Y+1	; 0x01
    86f6:	9a 81       	ldd	r25, Y+2	; 0x02
    86f8:	8f 3f       	cpi	r24, 0xFF	; 255
    86fa:	2f ef       	ldi	r18, 0xFF	; 255
    86fc:	92 07       	cpc	r25, r18
    86fe:	11 f4       	brne	.+4      	; 0x8704 <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x138>
    8700:	81 e0       	ldi	r24, 0x01	; 1
    8702:	01 c0       	rjmp	.+2      	; 0x8706 <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0x13a>
    8704:	80 e0       	ldi	r24, 0x00	; 0
    8706:	88 23       	and	r24, r24
    8708:	01 f7       	brne	.-64     	; 0x86ca <_ZN9DNSClient13getHostByNameEPKcR9IPAddress+0xfe>
                            wait_retries++;
                        }
                    }
                }
            }
            retries++;
    870a:	8d 81       	ldd	r24, Y+5	; 0x05
    870c:	9e 81       	ldd	r25, Y+6	; 0x06
    870e:	01 96       	adiw	r24, 0x01	; 1
    8710:	9e 83       	std	Y+6, r25	; 0x06
    8712:	8d 83       	std	Y+5, r24	; 0x05
        }

        // We're done with the socket now
        iUdp.stop();
    8714:	8d 85       	ldd	r24, Y+13	; 0x0d
    8716:	9e 85       	ldd	r25, Y+14	; 0x0e
    8718:	08 96       	adiw	r24, 0x08	; 8
    871a:	0e 94 6b 50 	call	0xa0d6	; 0xa0d6 <_ZN11EthernetUDP4stopEv>
    }

    return ret;
    871e:	89 81       	ldd	r24, Y+1	; 0x01
    8720:	9a 81       	ldd	r25, Y+2	; 0x02
}
    8722:	62 96       	adiw	r28, 0x12	; 18
    8724:	0f b6       	in	r0, 0x3f	; 63
    8726:	f8 94       	cli
    8728:	de bf       	out	0x3e, r29	; 62
    872a:	0f be       	out	0x3f, r0	; 63
    872c:	cd bf       	out	0x3d, r28	; 61
    872e:	df 91       	pop	r29
    8730:	cf 91       	pop	r28
    8732:	08 95       	ret

00008734 <_ZN9DNSClient12BuildRequestEPKc>:

uint16_t DNSClient::BuildRequest(const char* aName)
{
    8734:	cf 93       	push	r28
    8736:	df 93       	push	r29
    8738:	cd b7       	in	r28, 0x3d	; 61
    873a:	de b7       	in	r29, 0x3e	; 62
    873c:	2b 97       	sbiw	r28, 0x0b	; 11
    873e:	0f b6       	in	r0, 0x3f	; 63
    8740:	f8 94       	cli
    8742:	de bf       	out	0x3e, r29	; 62
    8744:	0f be       	out	0x3f, r0	; 63
    8746:	cd bf       	out	0x3d, r28	; 61
    8748:	99 87       	std	Y+9, r25	; 0x09
    874a:	88 87       	std	Y+8, r24	; 0x08
    874c:	7b 87       	std	Y+11, r23	; 0x0b
    874e:	6a 87       	std	Y+10, r22	; 0x0a
    //    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    //    |                    ARCOUNT                    |
    //    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    // As we only support one request at a time at present, we can simplify
    // some of this header
    iRequestId = millis(); // generate a random ID
    8750:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    8754:	dc 01       	movw	r26, r24
    8756:	cb 01       	movw	r24, r22
    8758:	9c 01       	movw	r18, r24
    875a:	88 85       	ldd	r24, Y+8	; 0x08
    875c:	99 85       	ldd	r25, Y+9	; 0x09
    875e:	fc 01       	movw	r30, r24
    8760:	37 83       	std	Z+7, r19	; 0x07
    8762:	26 83       	std	Z+6, r18	; 0x06
    uint16_t twoByteBuffer;

    // FIXME We should also check that there's enough space available to write to, rather
    // FIXME than assume there's enough space (as the code does at present)
    iUdp.write((uint8_t*)&iRequestId, sizeof(iRequestId));
    8764:	88 85       	ldd	r24, Y+8	; 0x08
    8766:	99 85       	ldd	r25, Y+9	; 0x09
    8768:	9c 01       	movw	r18, r24
    876a:	2a 5f       	subi	r18, 0xFA	; 250
    876c:	3f 4f       	sbci	r19, 0xFF	; 255
    876e:	88 85       	ldd	r24, Y+8	; 0x08
    8770:	99 85       	ldd	r25, Y+9	; 0x09
    8772:	08 96       	adiw	r24, 0x08	; 8
    8774:	42 e0       	ldi	r20, 0x02	; 2
    8776:	50 e0       	ldi	r21, 0x00	; 0
    8778:	b9 01       	movw	r22, r18
    877a:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>

    twoByteBuffer = htons(QUERY_FLAG | OPCODE_STANDARD_QUERY | RECURSION_DESIRED_FLAG);
    877e:	81 e0       	ldi	r24, 0x01	; 1
    8780:	90 e0       	ldi	r25, 0x00	; 0
    8782:	9e 83       	std	Y+6, r25	; 0x06
    8784:	8d 83       	std	Y+5, r24	; 0x05
    iUdp.write((uint8_t*)&twoByteBuffer, sizeof(twoByteBuffer));
    8786:	88 85       	ldd	r24, Y+8	; 0x08
    8788:	99 85       	ldd	r25, Y+9	; 0x09
    878a:	08 96       	adiw	r24, 0x08	; 8
    878c:	9e 01       	movw	r18, r28
    878e:	2b 5f       	subi	r18, 0xFB	; 251
    8790:	3f 4f       	sbci	r19, 0xFF	; 255
    8792:	42 e0       	ldi	r20, 0x02	; 2
    8794:	50 e0       	ldi	r21, 0x00	; 0
    8796:	b9 01       	movw	r22, r18
    8798:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>

    twoByteBuffer = htons(1);  // One question record
    879c:	80 e0       	ldi	r24, 0x00	; 0
    879e:	91 e0       	ldi	r25, 0x01	; 1
    87a0:	9e 83       	std	Y+6, r25	; 0x06
    87a2:	8d 83       	std	Y+5, r24	; 0x05
    iUdp.write((uint8_t*)&twoByteBuffer, sizeof(twoByteBuffer));
    87a4:	88 85       	ldd	r24, Y+8	; 0x08
    87a6:	99 85       	ldd	r25, Y+9	; 0x09
    87a8:	08 96       	adiw	r24, 0x08	; 8
    87aa:	9e 01       	movw	r18, r28
    87ac:	2b 5f       	subi	r18, 0xFB	; 251
    87ae:	3f 4f       	sbci	r19, 0xFF	; 255
    87b0:	42 e0       	ldi	r20, 0x02	; 2
    87b2:	50 e0       	ldi	r21, 0x00	; 0
    87b4:	b9 01       	movw	r22, r18
    87b6:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>

    twoByteBuffer = 0;  // Zero answer records
    87ba:	1e 82       	std	Y+6, r1	; 0x06
    87bc:	1d 82       	std	Y+5, r1	; 0x05
    iUdp.write((uint8_t*)&twoByteBuffer, sizeof(twoByteBuffer));
    87be:	88 85       	ldd	r24, Y+8	; 0x08
    87c0:	99 85       	ldd	r25, Y+9	; 0x09
    87c2:	08 96       	adiw	r24, 0x08	; 8
    87c4:	9e 01       	movw	r18, r28
    87c6:	2b 5f       	subi	r18, 0xFB	; 251
    87c8:	3f 4f       	sbci	r19, 0xFF	; 255
    87ca:	42 e0       	ldi	r20, 0x02	; 2
    87cc:	50 e0       	ldi	r21, 0x00	; 0
    87ce:	b9 01       	movw	r22, r18
    87d0:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>

    iUdp.write((uint8_t*)&twoByteBuffer, sizeof(twoByteBuffer));
    87d4:	88 85       	ldd	r24, Y+8	; 0x08
    87d6:	99 85       	ldd	r25, Y+9	; 0x09
    87d8:	08 96       	adiw	r24, 0x08	; 8
    87da:	9e 01       	movw	r18, r28
    87dc:	2b 5f       	subi	r18, 0xFB	; 251
    87de:	3f 4f       	sbci	r19, 0xFF	; 255
    87e0:	42 e0       	ldi	r20, 0x02	; 2
    87e2:	50 e0       	ldi	r21, 0x00	; 0
    87e4:	b9 01       	movw	r22, r18
    87e6:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>
    // and zero additional records
    iUdp.write((uint8_t*)&twoByteBuffer, sizeof(twoByteBuffer));
    87ea:	88 85       	ldd	r24, Y+8	; 0x08
    87ec:	99 85       	ldd	r25, Y+9	; 0x09
    87ee:	08 96       	adiw	r24, 0x08	; 8
    87f0:	9e 01       	movw	r18, r28
    87f2:	2b 5f       	subi	r18, 0xFB	; 251
    87f4:	3f 4f       	sbci	r19, 0xFF	; 255
    87f6:	42 e0       	ldi	r20, 0x02	; 2
    87f8:	50 e0       	ldi	r21, 0x00	; 0
    87fa:	b9 01       	movw	r22, r18
    87fc:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>

    // Build question
    const char* start =aName;
    8800:	8a 85       	ldd	r24, Y+10	; 0x0a
    8802:	9b 85       	ldd	r25, Y+11	; 0x0b
    8804:	9a 83       	std	Y+2, r25	; 0x02
    8806:	89 83       	std	Y+1, r24	; 0x01
    const char* end =start;
    8808:	89 81       	ldd	r24, Y+1	; 0x01
    880a:	9a 81       	ldd	r25, Y+2	; 0x02
    880c:	9c 83       	std	Y+4, r25	; 0x04
    880e:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t len;
    // Run through the name being requested
    while (*end)
    8810:	50 c0       	rjmp	.+160    	; 0x88b2 <_ZN9DNSClient12BuildRequestEPKc+0x17e>
    {
        // Find out how long this section of the name is
        end = start;
    8812:	89 81       	ldd	r24, Y+1	; 0x01
    8814:	9a 81       	ldd	r25, Y+2	; 0x02
    8816:	9c 83       	std	Y+4, r25	; 0x04
    8818:	8b 83       	std	Y+3, r24	; 0x03
        while (*end && (*end != '.') )
    881a:	05 c0       	rjmp	.+10     	; 0x8826 <_ZN9DNSClient12BuildRequestEPKc+0xf2>
        {
            end++;
    881c:	8b 81       	ldd	r24, Y+3	; 0x03
    881e:	9c 81       	ldd	r25, Y+4	; 0x04
    8820:	01 96       	adiw	r24, 0x01	; 1
    8822:	9c 83       	std	Y+4, r25	; 0x04
    8824:	8b 83       	std	Y+3, r24	; 0x03
    // Run through the name being requested
    while (*end)
    {
        // Find out how long this section of the name is
        end = start;
        while (*end && (*end != '.') )
    8826:	8b 81       	ldd	r24, Y+3	; 0x03
    8828:	9c 81       	ldd	r25, Y+4	; 0x04
    882a:	fc 01       	movw	r30, r24
    882c:	80 81       	ld	r24, Z
    882e:	88 23       	and	r24, r24
    8830:	41 f0       	breq	.+16     	; 0x8842 <_ZN9DNSClient12BuildRequestEPKc+0x10e>
    8832:	8b 81       	ldd	r24, Y+3	; 0x03
    8834:	9c 81       	ldd	r25, Y+4	; 0x04
    8836:	fc 01       	movw	r30, r24
    8838:	80 81       	ld	r24, Z
    883a:	8e 32       	cpi	r24, 0x2E	; 46
    883c:	11 f0       	breq	.+4      	; 0x8842 <_ZN9DNSClient12BuildRequestEPKc+0x10e>
    883e:	81 e0       	ldi	r24, 0x01	; 1
    8840:	01 c0       	rjmp	.+2      	; 0x8844 <_ZN9DNSClient12BuildRequestEPKc+0x110>
    8842:	80 e0       	ldi	r24, 0x00	; 0
    8844:	88 23       	and	r24, r24
    8846:	51 f7       	brne	.-44     	; 0x881c <_ZN9DNSClient12BuildRequestEPKc+0xe8>
        {
            end++;
        }

        if (end-start > 0)
    8848:	2b 81       	ldd	r18, Y+3	; 0x03
    884a:	3c 81       	ldd	r19, Y+4	; 0x04
    884c:	89 81       	ldd	r24, Y+1	; 0x01
    884e:	9a 81       	ldd	r25, Y+2	; 0x02
    8850:	a9 01       	movw	r20, r18
    8852:	48 1b       	sub	r20, r24
    8854:	59 0b       	sbc	r21, r25
    8856:	ca 01       	movw	r24, r20
    8858:	18 16       	cp	r1, r24
    885a:	19 06       	cpc	r1, r25
    885c:	2c f5       	brge	.+74     	; 0x88a8 <_ZN9DNSClient12BuildRequestEPKc+0x174>
        {
            // Write out the size of this section
            len = end-start;
    885e:	2b 81       	ldd	r18, Y+3	; 0x03
    8860:	3c 81       	ldd	r19, Y+4	; 0x04
    8862:	89 81       	ldd	r24, Y+1	; 0x01
    8864:	9a 81       	ldd	r25, Y+2	; 0x02
    8866:	f9 01       	movw	r30, r18
    8868:	e8 1b       	sub	r30, r24
    886a:	f9 0b       	sbc	r31, r25
    886c:	cf 01       	movw	r24, r30
    886e:	8f 83       	std	Y+7, r24	; 0x07
            iUdp.write(&len, sizeof(len));
    8870:	88 85       	ldd	r24, Y+8	; 0x08
    8872:	99 85       	ldd	r25, Y+9	; 0x09
    8874:	08 96       	adiw	r24, 0x08	; 8
    8876:	9e 01       	movw	r18, r28
    8878:	29 5f       	subi	r18, 0xF9	; 249
    887a:	3f 4f       	sbci	r19, 0xFF	; 255
    887c:	41 e0       	ldi	r20, 0x01	; 1
    887e:	50 e0       	ldi	r21, 0x00	; 0
    8880:	b9 01       	movw	r22, r18
    8882:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>
            // And then write out the section
            iUdp.write((uint8_t*)start, end-start);
    8886:	2b 81       	ldd	r18, Y+3	; 0x03
    8888:	3c 81       	ldd	r19, Y+4	; 0x04
    888a:	89 81       	ldd	r24, Y+1	; 0x01
    888c:	9a 81       	ldd	r25, Y+2	; 0x02
    888e:	a9 01       	movw	r20, r18
    8890:	48 1b       	sub	r20, r24
    8892:	59 0b       	sbc	r21, r25
    8894:	ca 01       	movw	r24, r20
    8896:	ac 01       	movw	r20, r24
    8898:	88 85       	ldd	r24, Y+8	; 0x08
    889a:	99 85       	ldd	r25, Y+9	; 0x09
    889c:	08 96       	adiw	r24, 0x08	; 8
    889e:	29 81       	ldd	r18, Y+1	; 0x01
    88a0:	3a 81       	ldd	r19, Y+2	; 0x02
    88a2:	b9 01       	movw	r22, r18
    88a4:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>
        }
        start = end+1;
    88a8:	8b 81       	ldd	r24, Y+3	; 0x03
    88aa:	9c 81       	ldd	r25, Y+4	; 0x04
    88ac:	01 96       	adiw	r24, 0x01	; 1
    88ae:	9a 83       	std	Y+2, r25	; 0x02
    88b0:	89 83       	std	Y+1, r24	; 0x01
    // Build question
    const char* start =aName;
    const char* end =start;
    uint8_t len;
    // Run through the name being requested
    while (*end)
    88b2:	8b 81       	ldd	r24, Y+3	; 0x03
    88b4:	9c 81       	ldd	r25, Y+4	; 0x04
    88b6:	fc 01       	movw	r30, r24
    88b8:	90 81       	ld	r25, Z
    88ba:	81 e0       	ldi	r24, 0x01	; 1
    88bc:	99 23       	and	r25, r25
    88be:	09 f4       	brne	.+2      	; 0x88c2 <_ZN9DNSClient12BuildRequestEPKc+0x18e>
    88c0:	80 e0       	ldi	r24, 0x00	; 0
    88c2:	88 23       	and	r24, r24
    88c4:	09 f0       	breq	.+2      	; 0x88c8 <_ZN9DNSClient12BuildRequestEPKc+0x194>
    88c6:	a5 cf       	rjmp	.-182    	; 0x8812 <_ZN9DNSClient12BuildRequestEPKc+0xde>
        start = end+1;
    }

    // We've got to the end of the question name, so
    // terminate it with a zero-length section
    len = 0;
    88c8:	1f 82       	std	Y+7, r1	; 0x07
    iUdp.write(&len, sizeof(len));
    88ca:	88 85       	ldd	r24, Y+8	; 0x08
    88cc:	99 85       	ldd	r25, Y+9	; 0x09
    88ce:	08 96       	adiw	r24, 0x08	; 8
    88d0:	9e 01       	movw	r18, r28
    88d2:	29 5f       	subi	r18, 0xF9	; 249
    88d4:	3f 4f       	sbci	r19, 0xFF	; 255
    88d6:	41 e0       	ldi	r20, 0x01	; 1
    88d8:	50 e0       	ldi	r21, 0x00	; 0
    88da:	b9 01       	movw	r22, r18
    88dc:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>
    // Finally the type and class of question
    twoByteBuffer = htons(TYPE_A);
    88e0:	80 e0       	ldi	r24, 0x00	; 0
    88e2:	91 e0       	ldi	r25, 0x01	; 1
    88e4:	9e 83       	std	Y+6, r25	; 0x06
    88e6:	8d 83       	std	Y+5, r24	; 0x05
    iUdp.write((uint8_t*)&twoByteBuffer, sizeof(twoByteBuffer));
    88e8:	88 85       	ldd	r24, Y+8	; 0x08
    88ea:	99 85       	ldd	r25, Y+9	; 0x09
    88ec:	08 96       	adiw	r24, 0x08	; 8
    88ee:	9e 01       	movw	r18, r28
    88f0:	2b 5f       	subi	r18, 0xFB	; 251
    88f2:	3f 4f       	sbci	r19, 0xFF	; 255
    88f4:	42 e0       	ldi	r20, 0x02	; 2
    88f6:	50 e0       	ldi	r21, 0x00	; 0
    88f8:	b9 01       	movw	r22, r18
    88fa:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>

    twoByteBuffer = htons(CLASS_IN);  // Internet class of question
    88fe:	80 e0       	ldi	r24, 0x00	; 0
    8900:	91 e0       	ldi	r25, 0x01	; 1
    8902:	9e 83       	std	Y+6, r25	; 0x06
    8904:	8d 83       	std	Y+5, r24	; 0x05
    iUdp.write((uint8_t*)&twoByteBuffer, sizeof(twoByteBuffer));
    8906:	88 85       	ldd	r24, Y+8	; 0x08
    8908:	99 85       	ldd	r25, Y+9	; 0x09
    890a:	08 96       	adiw	r24, 0x08	; 8
    890c:	9e 01       	movw	r18, r28
    890e:	2b 5f       	subi	r18, 0xFB	; 251
    8910:	3f 4f       	sbci	r19, 0xFF	; 255
    8912:	42 e0       	ldi	r20, 0x02	; 2
    8914:	50 e0       	ldi	r21, 0x00	; 0
    8916:	b9 01       	movw	r22, r18
    8918:	0e 94 5e 51 	call	0xa2bc	; 0xa2bc <_ZN11EthernetUDP5writeEPKhj>
    // Success!  Everything buffered okay
    return 1;
    891c:	81 e0       	ldi	r24, 0x01	; 1
    891e:	90 e0       	ldi	r25, 0x00	; 0
}
    8920:	2b 96       	adiw	r28, 0x0b	; 11
    8922:	0f b6       	in	r0, 0x3f	; 63
    8924:	f8 94       	cli
    8926:	de bf       	out	0x3e, r29	; 62
    8928:	0f be       	out	0x3f, r0	; 63
    892a:	cd bf       	out	0x3d, r28	; 61
    892c:	df 91       	pop	r29
    892e:	cf 91       	pop	r28
    8930:	08 95       	ret

00008932 <_ZN9DNSClient15ProcessResponseEjR9IPAddress>:


uint16_t DNSClient::ProcessResponse(uint16_t aTimeout, IPAddress& aAddress)
{
    8932:	cf 92       	push	r12
    8934:	df 92       	push	r13
    8936:	ef 92       	push	r14
    8938:	ff 92       	push	r15
    893a:	cf 93       	push	r28
    893c:	df 93       	push	r29
    893e:	cd b7       	in	r28, 0x3d	; 61
    8940:	de b7       	in	r29, 0x3e	; 62
    8942:	e0 97       	sbiw	r28, 0x30	; 48
    8944:	0f b6       	in	r0, 0x3f	; 63
    8946:	f8 94       	cli
    8948:	de bf       	out	0x3e, r29	; 62
    894a:	0f be       	out	0x3f, r0	; 63
    894c:	cd bf       	out	0x3d, r28	; 61
    894e:	9c a7       	std	Y+44, r25	; 0x2c
    8950:	8b a7       	std	Y+43, r24	; 0x2b
    8952:	7e a7       	std	Y+46, r23	; 0x2e
    8954:	6d a7       	std	Y+45, r22	; 0x2d
    8956:	58 ab       	std	Y+48, r21	; 0x30
    8958:	4f a7       	std	Y+47, r20	; 0x2f
    uint32_t startTime = millis();
    895a:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    895e:	dc 01       	movw	r26, r24
    8960:	cb 01       	movw	r24, r22
    8962:	8b 87       	std	Y+11, r24	; 0x0b
    8964:	9c 87       	std	Y+12, r25	; 0x0c
    8966:	ad 87       	std	Y+13, r26	; 0x0d
    8968:	be 87       	std	Y+14, r27	; 0x0e

    // Wait for a response packet
    while(iUdp.parsePacket() <= 0)
    896a:	23 c0       	rjmp	.+70     	; 0x89b2 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x80>
    {
        if((millis() - startTime) > aTimeout)
    896c:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    8970:	9b 01       	movw	r18, r22
    8972:	ac 01       	movw	r20, r24
    8974:	8b 85       	ldd	r24, Y+11	; 0x0b
    8976:	9c 85       	ldd	r25, Y+12	; 0x0c
    8978:	ad 85       	ldd	r26, Y+13	; 0x0d
    897a:	be 85       	ldd	r27, Y+14	; 0x0e
    897c:	28 1b       	sub	r18, r24
    897e:	39 0b       	sbc	r19, r25
    8980:	4a 0b       	sbc	r20, r26
    8982:	5b 0b       	sbc	r21, r27
    8984:	8d a5       	ldd	r24, Y+45	; 0x2d
    8986:	9e a5       	ldd	r25, Y+46	; 0x2e
    8988:	cc 01       	movw	r24, r24
    898a:	a0 e0       	ldi	r26, 0x00	; 0
    898c:	b0 e0       	ldi	r27, 0x00	; 0
    898e:	61 e0       	ldi	r22, 0x01	; 1
    8990:	82 17       	cp	r24, r18
    8992:	93 07       	cpc	r25, r19
    8994:	a4 07       	cpc	r26, r20
    8996:	b5 07       	cpc	r27, r21
    8998:	08 f0       	brcs	.+2      	; 0x899c <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x6a>
    899a:	60 e0       	ldi	r22, 0x00	; 0
    899c:	66 23       	and	r22, r22
    899e:	19 f0       	breq	.+6      	; 0x89a6 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x74>
            return TIMED_OUT;
    89a0:	8f ef       	ldi	r24, 0xFF	; 255
    89a2:	9f ef       	ldi	r25, 0xFF	; 255
    89a4:	c8 c1       	rjmp	.+912    	; 0x8d36 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x404>
        delay(50);
    89a6:	62 e3       	ldi	r22, 0x32	; 50
    89a8:	70 e0       	ldi	r23, 0x00	; 0
    89aa:	80 e0       	ldi	r24, 0x00	; 0
    89ac:	90 e0       	ldi	r25, 0x00	; 0
    89ae:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
uint16_t DNSClient::ProcessResponse(uint16_t aTimeout, IPAddress& aAddress)
{
    uint32_t startTime = millis();

    // Wait for a response packet
    while(iUdp.parsePacket() <= 0)
    89b2:	8b a5       	ldd	r24, Y+43	; 0x2b
    89b4:	9c a5       	ldd	r25, Y+44	; 0x2c
    89b6:	08 96       	adiw	r24, 0x08	; 8
    89b8:	0e 94 9f 51 	call	0xa33e	; 0xa33e <_ZN11EthernetUDP11parsePacketEv>
    89bc:	21 e0       	ldi	r18, 0x01	; 1
    89be:	18 16       	cp	r1, r24
    89c0:	19 06       	cpc	r1, r25
    89c2:	0c f4       	brge	.+2      	; 0x89c6 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x94>
    89c4:	20 e0       	ldi	r18, 0x00	; 0
    89c6:	22 23       	and	r18, r18
    89c8:	89 f6       	brne	.-94     	; 0x896c <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x3a>

    // We've had a reply!
    // Read the UDP header
    uint8_t header[DNS_HEADER_SIZE]; // Enough space to reuse for the DNS header
    // Check that it's a response from the right server and the right port
    if ( (iDNSServer != iUdp.remoteIP()) || 
    89ca:	8b a5       	ldd	r24, Y+43	; 0x2b
    89cc:	9c a5       	ldd	r25, Y+44	; 0x2c
    89ce:	0e 94 bb a5 	call	0x14b76	; 0x14b76 <_ZN9IPAddresscvmEv>
    89d2:	6b 01       	movw	r12, r22
    89d4:	7c 01       	movw	r14, r24
    89d6:	8b a5       	ldd	r24, Y+43	; 0x2b
    89d8:	9c a5       	ldd	r25, Y+44	; 0x2c
    89da:	9c 01       	movw	r18, r24
    89dc:	28 5f       	subi	r18, 0xF8	; 248
    89de:	3f 4f       	sbci	r19, 0xFF	; 255
    89e0:	ce 01       	movw	r24, r28
    89e2:	41 96       	adiw	r24, 0x11	; 17
    89e4:	b9 01       	movw	r22, r18
    89e6:	0e 94 33 aa 	call	0x15466	; 0x15466 <_ZN11EthernetUDP8remoteIPEv>
    89ea:	ce 01       	movw	r24, r28
    89ec:	41 96       	adiw	r24, 0x11	; 17
    89ee:	0e 94 bb a5 	call	0x14b76	; 0x14b76 <_ZN9IPAddresscvmEv>
    89f2:	dc 01       	movw	r26, r24
    89f4:	cb 01       	movw	r24, r22
    89f6:	c8 16       	cp	r12, r24
    89f8:	d9 06       	cpc	r13, r25
    89fa:	ea 06       	cpc	r14, r26
    89fc:	fb 06       	cpc	r15, r27
    89fe:	41 f4       	brne	.+16     	; 0x8a10 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0xde>
        (iUdp.remotePort() != DNS_PORT) )
    8a00:	8b a5       	ldd	r24, Y+43	; 0x2b
    8a02:	9c a5       	ldd	r25, Y+44	; 0x2c
    8a04:	08 96       	adiw	r24, 0x08	; 8
    8a06:	0e 94 50 aa 	call	0x154a0	; 0x154a0 <_ZN11EthernetUDP10remotePortEv>

    // We've had a reply!
    // Read the UDP header
    uint8_t header[DNS_HEADER_SIZE]; // Enough space to reuse for the DNS header
    // Check that it's a response from the right server and the right port
    if ( (iDNSServer != iUdp.remoteIP()) || 
    8a0a:	85 33       	cpi	r24, 0x35	; 53
    8a0c:	91 05       	cpc	r25, r1
    8a0e:	11 f0       	breq	.+4      	; 0x8a14 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0xe2>
    8a10:	81 e0       	ldi	r24, 0x01	; 1
    8a12:	01 c0       	rjmp	.+2      	; 0x8a16 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0xe4>
    8a14:	80 e0       	ldi	r24, 0x00	; 0
    8a16:	88 23       	and	r24, r24
    8a18:	19 f0       	breq	.+6      	; 0x8a20 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0xee>
        (iUdp.remotePort() != DNS_PORT) )
    {
        // It's not from who we expected
        return INVALID_SERVER;
    8a1a:	8e ef       	ldi	r24, 0xFE	; 254
    8a1c:	9f ef       	ldi	r25, 0xFF	; 255
    8a1e:	8b c1       	rjmp	.+790    	; 0x8d36 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x404>
    }

    // Read through the rest of the response
    if (iUdp.available() < DNS_HEADER_SIZE)
    8a20:	8b a5       	ldd	r24, Y+43	; 0x2b
    8a22:	9c a5       	ldd	r25, Y+44	; 0x2c
    8a24:	08 96       	adiw	r24, 0x08	; 8
    8a26:	0e 94 5a 50 	call	0xa0b4	; 0xa0b4 <_ZN11EthernetUDP9availableEv>
    8a2a:	21 e0       	ldi	r18, 0x01	; 1
    8a2c:	8c 30       	cpi	r24, 0x0C	; 12
    8a2e:	91 05       	cpc	r25, r1
    8a30:	0c f0       	brlt	.+2      	; 0x8a34 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x102>
    8a32:	20 e0       	ldi	r18, 0x00	; 0
    8a34:	22 23       	and	r18, r18
    8a36:	19 f0       	breq	.+6      	; 0x8a3e <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x10c>
    {
        return TRUNCATED;
    8a38:	8d ef       	ldi	r24, 0xFD	; 253
    8a3a:	9f ef       	ldi	r25, 0xFF	; 255
    8a3c:	7c c1       	rjmp	.+760    	; 0x8d36 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x404>
    }
    iUdp.read(header, DNS_HEADER_SIZE);
    8a3e:	8b a5       	ldd	r24, Y+43	; 0x2b
    8a40:	9c a5       	ldd	r25, Y+44	; 0x2c
    8a42:	08 96       	adiw	r24, 0x08	; 8
    8a44:	9e 01       	movw	r18, r28
    8a46:	29 5e       	subi	r18, 0xE9	; 233
    8a48:	3f 4f       	sbci	r19, 0xFF	; 255
    8a4a:	4c e0       	ldi	r20, 0x0C	; 12
    8a4c:	50 e0       	ldi	r21, 0x00	; 0
    8a4e:	b9 01       	movw	r22, r18
    8a50:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>

    uint16_t header_flags = htons(*((uint16_t*)&header[2]));
    8a54:	ce 01       	movw	r24, r28
    8a56:	47 96       	adiw	r24, 0x17	; 23
    8a58:	02 96       	adiw	r24, 0x02	; 2
    8a5a:	fc 01       	movw	r30, r24
    8a5c:	80 81       	ld	r24, Z
    8a5e:	91 81       	ldd	r25, Z+1	; 0x01
    8a60:	98 27       	eor	r25, r24
    8a62:	89 27       	eor	r24, r25
    8a64:	98 27       	eor	r25, r24
    8a66:	9c a3       	std	Y+36, r25	; 0x24
    8a68:	8b a3       	std	Y+35, r24	; 0x23
    // Check that it's a response to this request
    if ( ( iRequestId != (*((uint16_t*)&header[0])) ) ||
    8a6a:	8b a5       	ldd	r24, Y+43	; 0x2b
    8a6c:	9c a5       	ldd	r25, Y+44	; 0x2c
    8a6e:	fc 01       	movw	r30, r24
    8a70:	26 81       	ldd	r18, Z+6	; 0x06
    8a72:	37 81       	ldd	r19, Z+7	; 0x07
    8a74:	ce 01       	movw	r24, r28
    8a76:	47 96       	adiw	r24, 0x17	; 23
    8a78:	fc 01       	movw	r30, r24
    8a7a:	80 81       	ld	r24, Z
    8a7c:	91 81       	ldd	r25, Z+1	; 0x01
    8a7e:	28 17       	cp	r18, r24
    8a80:	39 07       	cpc	r19, r25
    8a82:	21 f4       	brne	.+8      	; 0x8a8c <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x15a>
    8a84:	8b a1       	ldd	r24, Y+35	; 0x23
    8a86:	9c a1       	ldd	r25, Y+36	; 0x24
    8a88:	99 23       	and	r25, r25
    8a8a:	44 f0       	brlt	.+16     	; 0x8a9c <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x16a>
        ((header_flags & QUERY_RESPONSE_MASK) != (uint16_t)RESPONSE_FLAG) )
    {
        // Mark the entire packet as read
        iUdp.flush();
    8a8c:	8b a5       	ldd	r24, Y+43	; 0x2b
    8a8e:	9c a5       	ldd	r25, Y+44	; 0x2c
    8a90:	08 96       	adiw	r24, 0x08	; 8
    8a92:	0e 94 fd 52 	call	0xa5fa	; 0xa5fa <_ZN11EthernetUDP5flushEv>
        return INVALID_RESPONSE;
    8a96:	8c ef       	ldi	r24, 0xFC	; 252
    8a98:	9f ef       	ldi	r25, 0xFF	; 255
    8a9a:	4d c1       	rjmp	.+666    	; 0x8d36 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x404>
    }
    // Check for any errors in the response (or in our request)
    // although we don't do anything to get round these
    if ( (header_flags & TRUNCATION_FLAG) || (header_flags & RESP_MASK) )
    8a9c:	8b a1       	ldd	r24, Y+35	; 0x23
    8a9e:	9c a1       	ldd	r25, Y+36	; 0x24
    8aa0:	88 27       	eor	r24, r24
    8aa2:	92 70       	andi	r25, 0x02	; 2
    8aa4:	00 97       	sbiw	r24, 0x00	; 0
    8aa6:	31 f4       	brne	.+12     	; 0x8ab4 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x182>
    8aa8:	8b a1       	ldd	r24, Y+35	; 0x23
    8aaa:	9c a1       	ldd	r25, Y+36	; 0x24
    8aac:	8f 70       	andi	r24, 0x0F	; 15
    8aae:	99 27       	eor	r25, r25
    8ab0:	00 97       	sbiw	r24, 0x00	; 0
    8ab2:	41 f0       	breq	.+16     	; 0x8ac4 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x192>
    {
        // Mark the entire packet as read
        iUdp.flush();
    8ab4:	8b a5       	ldd	r24, Y+43	; 0x2b
    8ab6:	9c a5       	ldd	r25, Y+44	; 0x2c
    8ab8:	08 96       	adiw	r24, 0x08	; 8
    8aba:	0e 94 fd 52 	call	0xa5fa	; 0xa5fa <_ZN11EthernetUDP5flushEv>
        return -5; //INVALID_RESPONSE;
    8abe:	8b ef       	ldi	r24, 0xFB	; 251
    8ac0:	9f ef       	ldi	r25, 0xFF	; 255
    8ac2:	39 c1       	rjmp	.+626    	; 0x8d36 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x404>
    }

    // And make sure we've got (at least) one answer
    uint16_t answerCount = htons(*((uint16_t*)&header[6]));
    8ac4:	ce 01       	movw	r24, r28
    8ac6:	47 96       	adiw	r24, 0x17	; 23
    8ac8:	06 96       	adiw	r24, 0x06	; 6
    8aca:	fc 01       	movw	r30, r24
    8acc:	80 81       	ld	r24, Z
    8ace:	91 81       	ldd	r25, Z+1	; 0x01
    8ad0:	98 27       	eor	r25, r24
    8ad2:	89 27       	eor	r24, r25
    8ad4:	98 27       	eor	r25, r24
    8ad6:	98 8b       	std	Y+16, r25	; 0x10
    8ad8:	8f 87       	std	Y+15, r24	; 0x0f
    if (answerCount == 0 )
    8ada:	8f 85       	ldd	r24, Y+15	; 0x0f
    8adc:	98 89       	ldd	r25, Y+16	; 0x10
    8ade:	00 97       	sbiw	r24, 0x00	; 0
    8ae0:	41 f4       	brne	.+16     	; 0x8af2 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x1c0>
    {
        // Mark the entire packet as read
        iUdp.flush();
    8ae2:	8b a5       	ldd	r24, Y+43	; 0x2b
    8ae4:	9c a5       	ldd	r25, Y+44	; 0x2c
    8ae6:	08 96       	adiw	r24, 0x08	; 8
    8ae8:	0e 94 fd 52 	call	0xa5fa	; 0xa5fa <_ZN11EthernetUDP5flushEv>
        return -6; //INVALID_RESPONSE;
    8aec:	8a ef       	ldi	r24, 0xFA	; 250
    8aee:	9f ef       	ldi	r25, 0xFF	; 255
    8af0:	22 c1       	rjmp	.+580    	; 0x8d36 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x404>
    }

    // Skip over any questions
    for (uint16_t i =0; i < htons(*((uint16_t*)&header[4])); i++)
    8af2:	1a 82       	std	Y+2, r1	; 0x02
    8af4:	19 82       	std	Y+1, r1	; 0x01
    8af6:	3f c0       	rjmp	.+126    	; 0x8b76 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x244>
    {
        // Skip over the name
        uint8_t len;
        do
        {
            iUdp.read(&len, sizeof(len));
    8af8:	8b a5       	ldd	r24, Y+43	; 0x2b
    8afa:	9c a5       	ldd	r25, Y+44	; 0x2c
    8afc:	08 96       	adiw	r24, 0x08	; 8
    8afe:	9e 01       	movw	r18, r28
    8b00:	2b 5d       	subi	r18, 0xDB	; 219
    8b02:	3f 4f       	sbci	r19, 0xFF	; 255
    8b04:	41 e0       	ldi	r20, 0x01	; 1
    8b06:	50 e0       	ldi	r21, 0x00	; 0
    8b08:	b9 01       	movw	r22, r18
    8b0a:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
            if (len > 0)
    8b0e:	8d a1       	ldd	r24, Y+37	; 0x25
    8b10:	88 23       	and	r24, r24
    8b12:	79 f0       	breq	.+30     	; 0x8b32 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x200>
            {
                // Don't need to actually read the data out for the string, just
                // advance ptr to beyond it
                while(len--)
    8b14:	05 c0       	rjmp	.+10     	; 0x8b20 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x1ee>
                {
                    iUdp.read(); // we don't care about the returned byte
    8b16:	8b a5       	ldd	r24, Y+43	; 0x2b
    8b18:	9c a5       	ldd	r25, Y+44	; 0x2c
    8b1a:	08 96       	adiw	r24, 0x08	; 8
    8b1c:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
            iUdp.read(&len, sizeof(len));
            if (len > 0)
            {
                // Don't need to actually read the data out for the string, just
                // advance ptr to beyond it
                while(len--)
    8b20:	9d a1       	ldd	r25, Y+37	; 0x25
    8b22:	81 e0       	ldi	r24, 0x01	; 1
    8b24:	99 23       	and	r25, r25
    8b26:	09 f4       	brne	.+2      	; 0x8b2a <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x1f8>
    8b28:	80 e0       	ldi	r24, 0x00	; 0
    8b2a:	91 50       	subi	r25, 0x01	; 1
    8b2c:	9d a3       	std	Y+37, r25	; 0x25
    8b2e:	88 23       	and	r24, r24
    8b30:	91 f7       	brne	.-28     	; 0x8b16 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x1e4>
    // Skip over any questions
    for (uint16_t i =0; i < htons(*((uint16_t*)&header[4])); i++)
    {
        // Skip over the name
        uint8_t len;
        do
    8b32:	9d a1       	ldd	r25, Y+37	; 0x25
    8b34:	81 e0       	ldi	r24, 0x01	; 1
    8b36:	99 23       	and	r25, r25
    8b38:	09 f4       	brne	.+2      	; 0x8b3c <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x20a>
    8b3a:	80 e0       	ldi	r24, 0x00	; 0
    8b3c:	88 23       	and	r24, r24
    8b3e:	e1 f6       	brne	.-72     	; 0x8af8 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x1c6>
                }
            }
        } while (len != 0);

        // Now jump over the type and class
        for (int i =0; i < 4; i++)
    8b40:	1c 82       	std	Y+4, r1	; 0x04
    8b42:	1b 82       	std	Y+3, r1	; 0x03
    8b44:	0a c0       	rjmp	.+20     	; 0x8b5a <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x228>
        {
            iUdp.read(); // we don't care about the returned byte
    8b46:	8b a5       	ldd	r24, Y+43	; 0x2b
    8b48:	9c a5       	ldd	r25, Y+44	; 0x2c
    8b4a:	08 96       	adiw	r24, 0x08	; 8
    8b4c:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
                }
            }
        } while (len != 0);

        // Now jump over the type and class
        for (int i =0; i < 4; i++)
    8b50:	8b 81       	ldd	r24, Y+3	; 0x03
    8b52:	9c 81       	ldd	r25, Y+4	; 0x04
    8b54:	01 96       	adiw	r24, 0x01	; 1
    8b56:	9c 83       	std	Y+4, r25	; 0x04
    8b58:	8b 83       	std	Y+3, r24	; 0x03
    8b5a:	21 e0       	ldi	r18, 0x01	; 1
    8b5c:	8b 81       	ldd	r24, Y+3	; 0x03
    8b5e:	9c 81       	ldd	r25, Y+4	; 0x04
    8b60:	84 30       	cpi	r24, 0x04	; 4
    8b62:	91 05       	cpc	r25, r1
    8b64:	0c f0       	brlt	.+2      	; 0x8b68 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x236>
    8b66:	20 e0       	ldi	r18, 0x00	; 0
    8b68:	22 23       	and	r18, r18
    8b6a:	69 f7       	brne	.-38     	; 0x8b46 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x214>
        iUdp.flush();
        return -6; //INVALID_RESPONSE;
    }

    // Skip over any questions
    for (uint16_t i =0; i < htons(*((uint16_t*)&header[4])); i++)
    8b6c:	89 81       	ldd	r24, Y+1	; 0x01
    8b6e:	9a 81       	ldd	r25, Y+2	; 0x02
    8b70:	01 96       	adiw	r24, 0x01	; 1
    8b72:	9a 83       	std	Y+2, r25	; 0x02
    8b74:	89 83       	std	Y+1, r24	; 0x01
    8b76:	ce 01       	movw	r24, r28
    8b78:	47 96       	adiw	r24, 0x17	; 23
    8b7a:	04 96       	adiw	r24, 0x04	; 4
    8b7c:	fc 01       	movw	r30, r24
    8b7e:	80 81       	ld	r24, Z
    8b80:	91 81       	ldd	r25, Z+1	; 0x01
    8b82:	38 2f       	mov	r19, r24
    8b84:	29 2f       	mov	r18, r25
    8b86:	41 e0       	ldi	r20, 0x01	; 1
    8b88:	89 81       	ldd	r24, Y+1	; 0x01
    8b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    8b8c:	82 17       	cp	r24, r18
    8b8e:	93 07       	cpc	r25, r19
    8b90:	08 f0       	brcs	.+2      	; 0x8b94 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x262>
    8b92:	40 e0       	ldi	r20, 0x00	; 0
    8b94:	44 23       	and	r20, r20
    8b96:	09 f0       	breq	.+2      	; 0x8b9a <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x268>
    8b98:	af cf       	rjmp	.-162    	; 0x8af8 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x1c6>
    // Now we're up to the bit we're interested in, the answer
    // There might be more than one answer (although we'll just use the first
    // type A answer) and some authority and additional resource records but
    // we're going to ignore all of them.

    for (uint16_t i =0; i < answerCount; i++)
    8b9a:	1e 82       	std	Y+6, r1	; 0x06
    8b9c:	1d 82       	std	Y+5, r1	; 0x05
    8b9e:	b8 c0       	rjmp	.+368    	; 0x8d10 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x3de>
    {
        // Skip the name
        uint8_t len;
        do
        {
            iUdp.read(&len, sizeof(len));
    8ba0:	8b a5       	ldd	r24, Y+43	; 0x2b
    8ba2:	9c a5       	ldd	r25, Y+44	; 0x2c
    8ba4:	08 96       	adiw	r24, 0x08	; 8
    8ba6:	9e 01       	movw	r18, r28
    8ba8:	2a 5d       	subi	r18, 0xDA	; 218
    8baa:	3f 4f       	sbci	r19, 0xFF	; 255
    8bac:	41 e0       	ldi	r20, 0x01	; 1
    8bae:	50 e0       	ldi	r21, 0x00	; 0
    8bb0:	b9 01       	movw	r22, r18
    8bb2:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
            if ((len & LABEL_COMPRESSION_MASK) == 0)
    8bb6:	8e a1       	ldd	r24, Y+38	; 0x26
    8bb8:	88 2f       	mov	r24, r24
    8bba:	90 e0       	ldi	r25, 0x00	; 0
    8bbc:	80 7c       	andi	r24, 0xC0	; 192
    8bbe:	99 27       	eor	r25, r25
    8bc0:	00 97       	sbiw	r24, 0x00	; 0
    8bc2:	99 f4       	brne	.+38     	; 0x8bea <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x2b8>
            {
                // It's just a normal label
                if (len > 0)
    8bc4:	8e a1       	ldd	r24, Y+38	; 0x26
    8bc6:	88 23       	and	r24, r24
    8bc8:	b1 f0       	breq	.+44     	; 0x8bf6 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x2c4>
                {
                    // And it's got a length
                    // Don't need to actually read the data out for the string,
                    // just advance ptr to beyond it
                    while(len--)
    8bca:	05 c0       	rjmp	.+10     	; 0x8bd6 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x2a4>
                    {
                        iUdp.read(); // we don't care about the returned byte
    8bcc:	8b a5       	ldd	r24, Y+43	; 0x2b
    8bce:	9c a5       	ldd	r25, Y+44	; 0x2c
    8bd0:	08 96       	adiw	r24, 0x08	; 8
    8bd2:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
                if (len > 0)
                {
                    // And it's got a length
                    // Don't need to actually read the data out for the string,
                    // just advance ptr to beyond it
                    while(len--)
    8bd6:	9e a1       	ldd	r25, Y+38	; 0x26
    8bd8:	81 e0       	ldi	r24, 0x01	; 1
    8bda:	99 23       	and	r25, r25
    8bdc:	09 f4       	brne	.+2      	; 0x8be0 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x2ae>
    8bde:	80 e0       	ldi	r24, 0x00	; 0
    8be0:	91 50       	subi	r25, 0x01	; 1
    8be2:	9e a3       	std	Y+38, r25	; 0x26
    8be4:	88 23       	and	r24, r24
    8be6:	91 f7       	brne	.-28     	; 0x8bcc <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x29a>
    8be8:	06 c0       	rjmp	.+12     	; 0x8bf6 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x2c4>
                // says that a name is either a sequence of labels ended with a
                // 0 length octet or a pointer or a sequence of labels ending in
                // a pointer.  Either way, when we get here we're at the end of
                // the name
                // Skip over the pointer
                iUdp.read(); // we don't care about the returned byte
    8bea:	8b a5       	ldd	r24, Y+43	; 0x2b
    8bec:	9c a5       	ldd	r25, Y+44	; 0x2c
    8bee:	08 96       	adiw	r24, 0x08	; 8
    8bf0:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
                // And set len so that we drop out of the name loop
                len = 0;
    8bf4:	1e a2       	std	Y+38, r1	; 0x26

    for (uint16_t i =0; i < answerCount; i++)
    {
        // Skip the name
        uint8_t len;
        do
    8bf6:	9e a1       	ldd	r25, Y+38	; 0x26
    8bf8:	81 e0       	ldi	r24, 0x01	; 1
    8bfa:	99 23       	and	r25, r25
    8bfc:	09 f4       	brne	.+2      	; 0x8c00 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x2ce>
    8bfe:	80 e0       	ldi	r24, 0x00	; 0
    8c00:	88 23       	and	r24, r24
    8c02:	71 f6       	brne	.-100    	; 0x8ba0 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x26e>
        } while (len != 0);

        // Check the type and class
        uint16_t answerType;
        uint16_t answerClass;
        iUdp.read((uint8_t*)&answerType, sizeof(answerType));
    8c04:	8b a5       	ldd	r24, Y+43	; 0x2b
    8c06:	9c a5       	ldd	r25, Y+44	; 0x2c
    8c08:	08 96       	adiw	r24, 0x08	; 8
    8c0a:	9e 01       	movw	r18, r28
    8c0c:	29 5d       	subi	r18, 0xD9	; 217
    8c0e:	3f 4f       	sbci	r19, 0xFF	; 255
    8c10:	42 e0       	ldi	r20, 0x02	; 2
    8c12:	50 e0       	ldi	r21, 0x00	; 0
    8c14:	b9 01       	movw	r22, r18
    8c16:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
        iUdp.read((uint8_t*)&answerClass, sizeof(answerClass));
    8c1a:	8b a5       	ldd	r24, Y+43	; 0x2b
    8c1c:	9c a5       	ldd	r25, Y+44	; 0x2c
    8c1e:	08 96       	adiw	r24, 0x08	; 8
    8c20:	9e 01       	movw	r18, r28
    8c22:	27 5d       	subi	r18, 0xD7	; 215
    8c24:	3f 4f       	sbci	r19, 0xFF	; 255
    8c26:	42 e0       	ldi	r20, 0x02	; 2
    8c28:	50 e0       	ldi	r21, 0x00	; 0
    8c2a:	b9 01       	movw	r22, r18
    8c2c:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>

        // Ignore the Time-To-Live as we don't do any caching
        for (int i =0; i < TTL_SIZE; i++)
    8c30:	18 86       	std	Y+8, r1	; 0x08
    8c32:	1f 82       	std	Y+7, r1	; 0x07
    8c34:	0a c0       	rjmp	.+20     	; 0x8c4a <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x318>
        {
            iUdp.read(); // we don't care about the returned byte
    8c36:	8b a5       	ldd	r24, Y+43	; 0x2b
    8c38:	9c a5       	ldd	r25, Y+44	; 0x2c
    8c3a:	08 96       	adiw	r24, 0x08	; 8
    8c3c:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
        uint16_t answerClass;
        iUdp.read((uint8_t*)&answerType, sizeof(answerType));
        iUdp.read((uint8_t*)&answerClass, sizeof(answerClass));

        // Ignore the Time-To-Live as we don't do any caching
        for (int i =0; i < TTL_SIZE; i++)
    8c40:	8f 81       	ldd	r24, Y+7	; 0x07
    8c42:	98 85       	ldd	r25, Y+8	; 0x08
    8c44:	01 96       	adiw	r24, 0x01	; 1
    8c46:	98 87       	std	Y+8, r25	; 0x08
    8c48:	8f 83       	std	Y+7, r24	; 0x07
    8c4a:	21 e0       	ldi	r18, 0x01	; 1
    8c4c:	8f 81       	ldd	r24, Y+7	; 0x07
    8c4e:	98 85       	ldd	r25, Y+8	; 0x08
    8c50:	84 30       	cpi	r24, 0x04	; 4
    8c52:	91 05       	cpc	r25, r1
    8c54:	0c f0       	brlt	.+2      	; 0x8c58 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x326>
    8c56:	20 e0       	ldi	r18, 0x00	; 0
    8c58:	22 23       	and	r18, r18
    8c5a:	69 f7       	brne	.-38     	; 0x8c36 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x304>
            iUdp.read(); // we don't care about the returned byte
        }

        // And read out the length of this answer
        // Don't need header_flags anymore, so we can reuse it here
        iUdp.read((uint8_t*)&header_flags, sizeof(header_flags));
    8c5c:	8b a5       	ldd	r24, Y+43	; 0x2b
    8c5e:	9c a5       	ldd	r25, Y+44	; 0x2c
    8c60:	08 96       	adiw	r24, 0x08	; 8
    8c62:	9e 01       	movw	r18, r28
    8c64:	2d 5d       	subi	r18, 0xDD	; 221
    8c66:	3f 4f       	sbci	r19, 0xFF	; 255
    8c68:	42 e0       	ldi	r20, 0x02	; 2
    8c6a:	50 e0       	ldi	r21, 0x00	; 0
    8c6c:	b9 01       	movw	r22, r18
    8c6e:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>

        if ( (htons(answerType) == TYPE_A) && (htons(answerClass) == CLASS_IN) )
    8c72:	8f a1       	ldd	r24, Y+39	; 0x27
    8c74:	98 a5       	ldd	r25, Y+40	; 0x28
    8c76:	98 27       	eor	r25, r24
    8c78:	89 27       	eor	r24, r25
    8c7a:	98 27       	eor	r25, r24
    8c7c:	81 30       	cpi	r24, 0x01	; 1
    8c7e:	91 05       	cpc	r25, r1
    8c80:	41 f5       	brne	.+80     	; 0x8cd2 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x3a0>
    8c82:	89 a5       	ldd	r24, Y+41	; 0x29
    8c84:	9a a5       	ldd	r25, Y+42	; 0x2a
    8c86:	98 27       	eor	r25, r24
    8c88:	89 27       	eor	r24, r25
    8c8a:	98 27       	eor	r25, r24
    8c8c:	81 30       	cpi	r24, 0x01	; 1
    8c8e:	91 05       	cpc	r25, r1
    8c90:	01 f5       	brne	.+64     	; 0x8cd2 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x3a0>
        {
            if (htons(header_flags) != 4)
    8c92:	8b a1       	ldd	r24, Y+35	; 0x23
    8c94:	9c a1       	ldd	r25, Y+36	; 0x24
    8c96:	98 27       	eor	r25, r24
    8c98:	89 27       	eor	r24, r25
    8c9a:	98 27       	eor	r25, r24
    8c9c:	84 30       	cpi	r24, 0x04	; 4
    8c9e:	91 05       	cpc	r25, r1
    8ca0:	41 f0       	breq	.+16     	; 0x8cb2 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x380>
            {
                // It's a weird size
                // Mark the entire packet as read
                iUdp.flush();
    8ca2:	8b a5       	ldd	r24, Y+43	; 0x2b
    8ca4:	9c a5       	ldd	r25, Y+44	; 0x2c
    8ca6:	08 96       	adiw	r24, 0x08	; 8
    8ca8:	0e 94 fd 52 	call	0xa5fa	; 0xa5fa <_ZN11EthernetUDP5flushEv>
                return -9;//INVALID_RESPONSE;
    8cac:	87 ef       	ldi	r24, 0xF7	; 247
    8cae:	9f ef       	ldi	r25, 0xFF	; 255
    8cb0:	42 c0       	rjmp	.+132    	; 0x8d36 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x404>
            }
            iUdp.read(aAddress.raw_address(), 4);
    8cb2:	8f a5       	ldd	r24, Y+47	; 0x2f
    8cb4:	98 a9       	ldd	r25, Y+48	; 0x30
    8cb6:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    8cba:	9c 01       	movw	r18, r24
    8cbc:	8b a5       	ldd	r24, Y+43	; 0x2b
    8cbe:	9c a5       	ldd	r25, Y+44	; 0x2c
    8cc0:	08 96       	adiw	r24, 0x08	; 8
    8cc2:	44 e0       	ldi	r20, 0x04	; 4
    8cc4:	50 e0       	ldi	r21, 0x00	; 0
    8cc6:	b9 01       	movw	r22, r18
    8cc8:	0e 94 6a 52 	call	0xa4d4	; 0xa4d4 <_ZN11EthernetUDP4readEPhj>
            return SUCCESS;
    8ccc:	81 e0       	ldi	r24, 0x01	; 1
    8cce:	90 e0       	ldi	r25, 0x00	; 0
    8cd0:	32 c0       	rjmp	.+100    	; 0x8d36 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x404>
        }
        else
        {
            // This isn't an answer type we're after, move onto the next one
            for (uint16_t i =0; i < htons(header_flags); i++)
    8cd2:	1a 86       	std	Y+10, r1	; 0x0a
    8cd4:	19 86       	std	Y+9, r1	; 0x09
    8cd6:	0a c0       	rjmp	.+20     	; 0x8cec <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x3ba>
            {
                iUdp.read(); // we don't care about the returned byte
    8cd8:	8b a5       	ldd	r24, Y+43	; 0x2b
    8cda:	9c a5       	ldd	r25, Y+44	; 0x2c
    8cdc:	08 96       	adiw	r24, 0x08	; 8
    8cde:	0e 94 2e 52 	call	0xa45c	; 0xa45c <_ZN11EthernetUDP4readEv>
            return SUCCESS;
        }
        else
        {
            // This isn't an answer type we're after, move onto the next one
            for (uint16_t i =0; i < htons(header_flags); i++)
    8ce2:	89 85       	ldd	r24, Y+9	; 0x09
    8ce4:	9a 85       	ldd	r25, Y+10	; 0x0a
    8ce6:	01 96       	adiw	r24, 0x01	; 1
    8ce8:	9a 87       	std	Y+10, r25	; 0x0a
    8cea:	89 87       	std	Y+9, r24	; 0x09
    8cec:	8b a1       	ldd	r24, Y+35	; 0x23
    8cee:	9c a1       	ldd	r25, Y+36	; 0x24
    8cf0:	38 2f       	mov	r19, r24
    8cf2:	29 2f       	mov	r18, r25
    8cf4:	41 e0       	ldi	r20, 0x01	; 1
    8cf6:	89 85       	ldd	r24, Y+9	; 0x09
    8cf8:	9a 85       	ldd	r25, Y+10	; 0x0a
    8cfa:	82 17       	cp	r24, r18
    8cfc:	93 07       	cpc	r25, r19
    8cfe:	08 f0       	brcs	.+2      	; 0x8d02 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x3d0>
    8d00:	40 e0       	ldi	r20, 0x00	; 0
    8d02:	44 23       	and	r20, r20
    8d04:	49 f7       	brne	.-46     	; 0x8cd8 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x3a6>
    // Now we're up to the bit we're interested in, the answer
    // There might be more than one answer (although we'll just use the first
    // type A answer) and some authority and additional resource records but
    // we're going to ignore all of them.

    for (uint16_t i =0; i < answerCount; i++)
    8d06:	8d 81       	ldd	r24, Y+5	; 0x05
    8d08:	9e 81       	ldd	r25, Y+6	; 0x06
    8d0a:	01 96       	adiw	r24, 0x01	; 1
    8d0c:	9e 83       	std	Y+6, r25	; 0x06
    8d0e:	8d 83       	std	Y+5, r24	; 0x05
    8d10:	41 e0       	ldi	r20, 0x01	; 1
    8d12:	2d 81       	ldd	r18, Y+5	; 0x05
    8d14:	3e 81       	ldd	r19, Y+6	; 0x06
    8d16:	8f 85       	ldd	r24, Y+15	; 0x0f
    8d18:	98 89       	ldd	r25, Y+16	; 0x10
    8d1a:	28 17       	cp	r18, r24
    8d1c:	39 07       	cpc	r19, r25
    8d1e:	08 f0       	brcs	.+2      	; 0x8d22 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x3f0>
    8d20:	40 e0       	ldi	r20, 0x00	; 0
    8d22:	44 23       	and	r20, r20
    8d24:	09 f0       	breq	.+2      	; 0x8d28 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x3f6>
    8d26:	3c cf       	rjmp	.-392    	; 0x8ba0 <_ZN9DNSClient15ProcessResponseEjR9IPAddress+0x26e>
            }
        }
    }

    // Mark the entire packet as read
    iUdp.flush();
    8d28:	8b a5       	ldd	r24, Y+43	; 0x2b
    8d2a:	9c a5       	ldd	r25, Y+44	; 0x2c
    8d2c:	08 96       	adiw	r24, 0x08	; 8
    8d2e:	0e 94 fd 52 	call	0xa5fa	; 0xa5fa <_ZN11EthernetUDP5flushEv>

    // If we get here then we haven't found an answer
    return -10;//INVALID_RESPONSE;
    8d32:	86 ef       	ldi	r24, 0xF6	; 246
    8d34:	9f ef       	ldi	r25, 0xFF	; 255
}
    8d36:	e0 96       	adiw	r28, 0x30	; 48
    8d38:	0f b6       	in	r0, 0x3f	; 63
    8d3a:	f8 94       	cli
    8d3c:	de bf       	out	0x3e, r29	; 62
    8d3e:	0f be       	out	0x3f, r0	; 63
    8d40:	cd bf       	out	0x3d, r28	; 61
    8d42:	df 91       	pop	r29
    8d44:	cf 91       	pop	r28
    8d46:	ff 90       	pop	r15
    8d48:	ef 90       	pop	r14
    8d4a:	df 90       	pop	r13
    8d4c:	cf 90       	pop	r12
    8d4e:	08 95       	ret

00008d50 <_Z41__static_initialization_and_destruction_0ii>:
    8d50:	0f 93       	push	r16
    8d52:	cf 93       	push	r28
    8d54:	df 93       	push	r29
    8d56:	00 d0       	rcall	.+0      	; 0x8d58 <_Z41__static_initialization_and_destruction_0ii+0x8>
    8d58:	00 d0       	rcall	.+0      	; 0x8d5a <_Z41__static_initialization_and_destruction_0ii+0xa>
    8d5a:	cd b7       	in	r28, 0x3d	; 61
    8d5c:	de b7       	in	r29, 0x3e	; 62
    8d5e:	9a 83       	std	Y+2, r25	; 0x02
    8d60:	89 83       	std	Y+1, r24	; 0x01
    8d62:	7c 83       	std	Y+4, r23	; 0x04
    8d64:	6b 83       	std	Y+3, r22	; 0x03
    8d66:	89 81       	ldd	r24, Y+1	; 0x01
    8d68:	9a 81       	ldd	r25, Y+2	; 0x02
    8d6a:	81 30       	cpi	r24, 0x01	; 1
    8d6c:	91 05       	cpc	r25, r1
    8d6e:	71 f4       	brne	.+28     	; 0x8d8c <_Z41__static_initialization_and_destruction_0ii+0x3c>
    8d70:	8b 81       	ldd	r24, Y+3	; 0x03
    8d72:	9c 81       	ldd	r25, Y+4	; 0x04
    8d74:	8f 3f       	cpi	r24, 0xFF	; 255
    8d76:	2f ef       	ldi	r18, 0xFF	; 255
    8d78:	92 07       	cpc	r25, r18
    8d7a:	41 f4       	brne	.+16     	; 0x8d8c <_Z41__static_initialization_and_destruction_0ii+0x3c>
    8d7c:	00 e0       	ldi	r16, 0x00	; 0
    8d7e:	20 e0       	ldi	r18, 0x00	; 0
    8d80:	40 e0       	ldi	r20, 0x00	; 0
    8d82:	60 e0       	ldi	r22, 0x00	; 0
    8d84:	82 ea       	ldi	r24, 0xA2	; 162
    8d86:	97 e0       	ldi	r25, 0x07	; 7
    8d88:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    8d8c:	0f 90       	pop	r0
    8d8e:	0f 90       	pop	r0
    8d90:	0f 90       	pop	r0
    8d92:	0f 90       	pop	r0
    8d94:	df 91       	pop	r29
    8d96:	cf 91       	pop	r28
    8d98:	0f 91       	pop	r16
    8d9a:	08 95       	ret

00008d9c <_GLOBAL__sub_I__ZN9DNSClient5beginERK9IPAddress>:
    8d9c:	cf 93       	push	r28
    8d9e:	df 93       	push	r29
    8da0:	cd b7       	in	r28, 0x3d	; 61
    8da2:	de b7       	in	r29, 0x3e	; 62
    8da4:	6f ef       	ldi	r22, 0xFF	; 255
    8da6:	7f ef       	ldi	r23, 0xFF	; 255
    8da8:	81 e0       	ldi	r24, 0x01	; 1
    8daa:	90 e0       	ldi	r25, 0x00	; 0
    8dac:	0e 94 a8 46 	call	0x8d50	; 0x8d50 <_Z41__static_initialization_and_destruction_0ii>
    8db0:	df 91       	pop	r29
    8db2:	cf 91       	pop	r28
    8db4:	08 95       	ret

00008db6 <_ZN13EthernetClass5beginEPh>:
  0, 0, 0, 0 };
uint16_t EthernetClass::_server_port[MAX_SOCK_NUM] = { 
  0, 0, 0, 0 };

int EthernetClass::begin(uint8_t *mac_address)
{
    8db6:	ef 92       	push	r14
    8db8:	ff 92       	push	r15
    8dba:	0f 93       	push	r16
    8dbc:	1f 93       	push	r17
    8dbe:	cf 93       	push	r28
    8dc0:	df 93       	push	r29
    8dc2:	cd b7       	in	r28, 0x3d	; 61
    8dc4:	de b7       	in	r29, 0x3e	; 62
    8dc6:	a4 97       	sbiw	r28, 0x24	; 36
    8dc8:	0f b6       	in	r0, 0x3f	; 63
    8dca:	f8 94       	cli
    8dcc:	de bf       	out	0x3e, r29	; 62
    8dce:	0f be       	out	0x3f, r0	; 63
    8dd0:	cd bf       	out	0x3d, r28	; 61
    8dd2:	9a a3       	std	Y+34, r25	; 0x22
    8dd4:	89 a3       	std	Y+33, r24	; 0x21
    8dd6:	7c a3       	std	Y+36, r23	; 0x24
    8dd8:	6b a3       	std	Y+35, r22	; 0x23
  static DhcpClass s_dhcp;
    8dda:	82 ec       	ldi	r24, 0xC2	; 194
    8ddc:	97 e0       	ldi	r25, 0x07	; 7
    8dde:	fc 01       	movw	r30, r24
    8de0:	80 81       	ld	r24, Z
    8de2:	88 23       	and	r24, r24
    8de4:	91 f4       	brne	.+36     	; 0x8e0a <_ZN13EthernetClass5beginEPh+0x54>
    8de6:	82 ec       	ldi	r24, 0xC2	; 194
    8de8:	97 e0       	ldi	r25, 0x07	; 7
    8dea:	0e 94 12 7d 	call	0xfa24	; 0xfa24 <__cxa_guard_acquire>
    8dee:	21 e0       	ldi	r18, 0x01	; 1
    8df0:	00 97       	sbiw	r24, 0x00	; 0
    8df2:	09 f4       	brne	.+2      	; 0x8df6 <_ZN13EthernetClass5beginEPh+0x40>
    8df4:	20 e0       	ldi	r18, 0x00	; 0
    8df6:	22 23       	and	r18, r18
    8df8:	41 f0       	breq	.+16     	; 0x8e0a <_ZN13EthernetClass5beginEPh+0x54>
    8dfa:	8a ec       	ldi	r24, 0xCA	; 202
    8dfc:	97 e0       	ldi	r25, 0x07	; 7
    8dfe:	0e 94 e9 ab 	call	0x157d2	; 0x157d2 <_ZN9DhcpClassC1Ev>
    8e02:	82 ec       	ldi	r24, 0xC2	; 194
    8e04:	97 e0       	ldi	r25, 0x07	; 7
    8e06:	0e 94 28 7d 	call	0xfa50	; 0xfa50 <__cxa_guard_release>
  _dhcp = &s_dhcp;
    8e0a:	89 a1       	ldd	r24, Y+33	; 0x21
    8e0c:	9a a1       	ldd	r25, Y+34	; 0x22
    8e0e:	2a ec       	ldi	r18, 0xCA	; 202
    8e10:	37 e0       	ldi	r19, 0x07	; 7
    8e12:	fc 01       	movw	r30, r24
    8e14:	37 83       	std	Z+7, r19	; 0x07
    8e16:	26 83       	std	Z+6, r18	; 0x06


  // Initialise the basic info
  W5100.init();
    8e18:	8c e8       	ldi	r24, 0x8C	; 140
    8e1a:	97 e0       	ldi	r25, 0x07	; 7
    8e1c:	0e 94 0c 34 	call	0x6818	; 0x6818 <_ZN10W5100Class4initEv>
  W5100.setMACAddress(mac_address);
    8e20:	8b a1       	ldd	r24, Y+35	; 0x23
    8e22:	9c a1       	ldd	r25, Y+36	; 0x24
    8e24:	bc 01       	movw	r22, r24
    8e26:	8c e8       	ldi	r24, 0x8C	; 140
    8e28:	97 e0       	ldi	r25, 0x07	; 7
    8e2a:	0e 94 aa ab 	call	0x15754	; 0x15754 <_ZN10W5100Class13setMACAddressEPh>
  W5100.setIPAddress(IPAddress(0,0,0,0).raw_address());
    8e2e:	ce 01       	movw	r24, r28
    8e30:	4b 96       	adiw	r24, 0x1b	; 27
    8e32:	00 e0       	ldi	r16, 0x00	; 0
    8e34:	20 e0       	ldi	r18, 0x00	; 0
    8e36:	40 e0       	ldi	r20, 0x00	; 0
    8e38:	60 e0       	ldi	r22, 0x00	; 0
    8e3a:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    8e3e:	ce 01       	movw	r24, r28
    8e40:	4b 96       	adiw	r24, 0x1b	; 27
    8e42:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    8e46:	bc 01       	movw	r22, r24
    8e48:	8c e8       	ldi	r24, 0x8C	; 140
    8e4a:	97 e0       	ldi	r25, 0x07	; 7
    8e4c:	0e 94 d4 ab 	call	0x157a8	; 0x157a8 <_ZN10W5100Class12setIPAddressEPh>

  // Now try to get our config info from a DHCP server
  int ret = _dhcp->beginWithDHCP(mac_address);
    8e50:	89 a1       	ldd	r24, Y+33	; 0x21
    8e52:	9a a1       	ldd	r25, Y+34	; 0x22
    8e54:	fc 01       	movw	r30, r24
    8e56:	86 81       	ldd	r24, Z+6	; 0x06
    8e58:	97 81       	ldd	r25, Z+7	; 0x07
    8e5a:	6b a1       	ldd	r22, Y+35	; 0x23
    8e5c:	7c a1       	ldd	r23, Y+36	; 0x24
    8e5e:	10 ea       	ldi	r17, 0xA0	; 160
    8e60:	e1 2e       	mov	r14, r17
    8e62:	1f e0       	ldi	r17, 0x0F	; 15
    8e64:	f1 2e       	mov	r15, r17
    8e66:	00 e0       	ldi	r16, 0x00	; 0
    8e68:	10 e0       	ldi	r17, 0x00	; 0
    8e6a:	20 e6       	ldi	r18, 0x60	; 96
    8e6c:	3a ee       	ldi	r19, 0xEA	; 234
    8e6e:	40 e0       	ldi	r20, 0x00	; 0
    8e70:	50 e0       	ldi	r21, 0x00	; 0
    8e72:	0e 94 58 37 	call	0x6eb0	; 0x6eb0 <_ZN9DhcpClass13beginWithDHCPEPhmm>
    8e76:	9a 83       	std	Y+2, r25	; 0x02
    8e78:	89 83       	std	Y+1, r24	; 0x01
  if(ret == 1)
    8e7a:	89 81       	ldd	r24, Y+1	; 0x01
    8e7c:	9a 81       	ldd	r25, Y+2	; 0x02
    8e7e:	81 30       	cpi	r24, 0x01	; 1
    8e80:	91 05       	cpc	r25, r1
    8e82:	09 f0       	breq	.+2      	; 0x8e86 <_ZN13EthernetClass5beginEPh+0xd0>
    8e84:	4b c0       	rjmp	.+150    	; 0x8f1c <_ZN13EthernetClass5beginEPh+0x166>
  {
    // We've successfully found a DHCP server and got our configuration info, so set things
    // accordingly
    W5100.setIPAddress(_dhcp->getLocalIp().raw_address());
    8e86:	89 a1       	ldd	r24, Y+33	; 0x21
    8e88:	9a a1       	ldd	r25, Y+34	; 0x22
    8e8a:	fc 01       	movw	r30, r24
    8e8c:	26 81       	ldd	r18, Z+6	; 0x06
    8e8e:	37 81       	ldd	r19, Z+7	; 0x07
    8e90:	ce 01       	movw	r24, r28
    8e92:	45 96       	adiw	r24, 0x15	; 21
    8e94:	b9 01       	movw	r22, r18
    8e96:	0e 94 fa 40 	call	0x81f4	; 0x81f4 <_ZN9DhcpClass10getLocalIpEv>
    8e9a:	ce 01       	movw	r24, r28
    8e9c:	45 96       	adiw	r24, 0x15	; 21
    8e9e:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    8ea2:	bc 01       	movw	r22, r24
    8ea4:	8c e8       	ldi	r24, 0x8C	; 140
    8ea6:	97 e0       	ldi	r25, 0x07	; 7
    8ea8:	0e 94 d4 ab 	call	0x157a8	; 0x157a8 <_ZN10W5100Class12setIPAddressEPh>
    W5100.setGatewayIp(_dhcp->getGatewayIp().raw_address());
    8eac:	89 a1       	ldd	r24, Y+33	; 0x21
    8eae:	9a a1       	ldd	r25, Y+34	; 0x22
    8eb0:	fc 01       	movw	r30, r24
    8eb2:	26 81       	ldd	r18, Z+6	; 0x06
    8eb4:	37 81       	ldd	r19, Z+7	; 0x07
    8eb6:	ce 01       	movw	r24, r28
    8eb8:	0f 96       	adiw	r24, 0x0f	; 15
    8eba:	b9 01       	movw	r22, r18
    8ebc:	0e 94 34 41 	call	0x8268	; 0x8268 <_ZN9DhcpClass12getGatewayIpEv>
    8ec0:	ce 01       	movw	r24, r28
    8ec2:	0f 96       	adiw	r24, 0x0f	; 15
    8ec4:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    8ec8:	bc 01       	movw	r22, r24
    8eca:	8c e8       	ldi	r24, 0x8C	; 140
    8ecc:	97 e0       	ldi	r25, 0x07	; 7
    8ece:	0e 94 6b ab 	call	0x156d6	; 0x156d6 <_ZN10W5100Class12setGatewayIpEPh>
    W5100.setSubnetMask(_dhcp->getSubnetMask().raw_address());
    8ed2:	89 a1       	ldd	r24, Y+33	; 0x21
    8ed4:	9a a1       	ldd	r25, Y+34	; 0x22
    8ed6:	fc 01       	movw	r30, r24
    8ed8:	26 81       	ldd	r18, Z+6	; 0x06
    8eda:	37 81       	ldd	r19, Z+7	; 0x07
    8edc:	ce 01       	movw	r24, r28
    8ede:	09 96       	adiw	r24, 0x09	; 9
    8ee0:	b9 01       	movw	r22, r18
    8ee2:	0e 94 17 41 	call	0x822e	; 0x822e <_ZN9DhcpClass13getSubnetMaskEv>
    8ee6:	ce 01       	movw	r24, r28
    8ee8:	09 96       	adiw	r24, 0x09	; 9
    8eea:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    8eee:	bc 01       	movw	r22, r24
    8ef0:	8c e8       	ldi	r24, 0x8C	; 140
    8ef2:	97 e0       	ldi	r25, 0x07	; 7
    8ef4:	0e 94 95 ab 	call	0x1572a	; 0x1572a <_ZN10W5100Class13setSubnetMaskEPh>
    _dnsServerAddress = _dhcp->getDnsServerIp();
    8ef8:	89 a1       	ldd	r24, Y+33	; 0x21
    8efa:	9a a1       	ldd	r25, Y+34	; 0x22
    8efc:	fc 01       	movw	r30, r24
    8efe:	26 81       	ldd	r18, Z+6	; 0x06
    8f00:	37 81       	ldd	r19, Z+7	; 0x07
    8f02:	ce 01       	movw	r24, r28
    8f04:	03 96       	adiw	r24, 0x03	; 3
    8f06:	b9 01       	movw	r22, r18
    8f08:	0e 94 6e 41 	call	0x82dc	; 0x82dc <_ZN9DhcpClass14getDnsServerIpEv>
    8f0c:	89 a1       	ldd	r24, Y+33	; 0x21
    8f0e:	9a a1       	ldd	r25, Y+34	; 0x22
    8f10:	9e 01       	movw	r18, r28
    8f12:	2d 5f       	subi	r18, 0xFD	; 253
    8f14:	3f 4f       	sbci	r19, 0xFF	; 255
    8f16:	b9 01       	movw	r22, r18
    8f18:	0e 94 9b aa 	call	0x15536	; 0x15536 <_ZN9IPAddressaSERKS_>
  }

  return ret;
    8f1c:	89 81       	ldd	r24, Y+1	; 0x01
    8f1e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    8f20:	a4 96       	adiw	r28, 0x24	; 36
    8f22:	0f b6       	in	r0, 0x3f	; 63
    8f24:	f8 94       	cli
    8f26:	de bf       	out	0x3e, r29	; 62
    8f28:	0f be       	out	0x3f, r0	; 63
    8f2a:	cd bf       	out	0x3d, r28	; 61
    8f2c:	df 91       	pop	r29
    8f2e:	cf 91       	pop	r28
    8f30:	1f 91       	pop	r17
    8f32:	0f 91       	pop	r16
    8f34:	ff 90       	pop	r15
    8f36:	ef 90       	pop	r14
    8f38:	08 95       	ret

00008f3a <_ZN13EthernetClass5beginEPh9IPAddress>:

void EthernetClass::begin(uint8_t *mac_address, IPAddress local_ip)
{
    8f3a:	cf 93       	push	r28
    8f3c:	df 93       	push	r29
    8f3e:	cd b7       	in	r28, 0x3d	; 61
    8f40:	de b7       	in	r29, 0x3e	; 62
    8f42:	68 97       	sbiw	r28, 0x18	; 24
    8f44:	0f b6       	in	r0, 0x3f	; 63
    8f46:	f8 94       	cli
    8f48:	de bf       	out	0x3e, r29	; 62
    8f4a:	0f be       	out	0x3f, r0	; 63
    8f4c:	cd bf       	out	0x3d, r28	; 61
    8f4e:	9c 8b       	std	Y+20, r25	; 0x14
    8f50:	8b 8b       	std	Y+19, r24	; 0x13
    8f52:	7e 8b       	std	Y+22, r23	; 0x16
    8f54:	6d 8b       	std	Y+21, r22	; 0x15
    8f56:	58 8f       	std	Y+24, r21	; 0x18
    8f58:	4f 8b       	std	Y+23, r20	; 0x17
  // Assume the DNS server will be the machine on the same network as the local IP
  // but with last octet being '1'
  IPAddress dns_server = local_ip;
    8f5a:	2f 89       	ldd	r18, Y+23	; 0x17
    8f5c:	38 8d       	ldd	r19, Y+24	; 0x18
    8f5e:	ce 01       	movw	r24, r28
    8f60:	0d 96       	adiw	r24, 0x0d	; 13
    8f62:	b9 01       	movw	r22, r18
    8f64:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
  dns_server[3] = 1;
    8f68:	ce 01       	movw	r24, r28
    8f6a:	0d 96       	adiw	r24, 0x0d	; 13
    8f6c:	63 e0       	ldi	r22, 0x03	; 3
    8f6e:	70 e0       	ldi	r23, 0x00	; 0
    8f70:	0e 94 70 aa 	call	0x154e0	; 0x154e0 <_ZN9IPAddressixEi>
    8f74:	21 e0       	ldi	r18, 0x01	; 1
    8f76:	fc 01       	movw	r30, r24
    8f78:	20 83       	st	Z, r18
  begin(mac_address, local_ip, dns_server);
    8f7a:	9e 01       	movw	r18, r28
    8f7c:	23 5f       	subi	r18, 0xF3	; 243
    8f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    8f80:	ce 01       	movw	r24, r28
    8f82:	07 96       	adiw	r24, 0x07	; 7
    8f84:	b9 01       	movw	r22, r18
    8f86:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    8f8a:	8f 89       	ldd	r24, Y+23	; 0x17
    8f8c:	98 8d       	ldd	r25, Y+24	; 0x18
    8f8e:	bc 01       	movw	r22, r24
    8f90:	ce 01       	movw	r24, r28
    8f92:	01 96       	adiw	r24, 0x01	; 1
    8f94:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    8f98:	9e 01       	movw	r18, r28
    8f9a:	29 5f       	subi	r18, 0xF9	; 249
    8f9c:	3f 4f       	sbci	r19, 0xFF	; 255
    8f9e:	6d 89       	ldd	r22, Y+21	; 0x15
    8fa0:	7e 89       	ldd	r23, Y+22	; 0x16
    8fa2:	8b 89       	ldd	r24, Y+19	; 0x13
    8fa4:	9c 89       	ldd	r25, Y+20	; 0x14
    8fa6:	ae 01       	movw	r20, r28
    8fa8:	4f 5f       	subi	r20, 0xFF	; 255
    8faa:	5f 4f       	sbci	r21, 0xFF	; 255
    8fac:	0e 94 e1 47 	call	0x8fc2	; 0x8fc2 <_ZN13EthernetClass5beginEPh9IPAddressS1_>
}
    8fb0:	68 96       	adiw	r28, 0x18	; 24
    8fb2:	0f b6       	in	r0, 0x3f	; 63
    8fb4:	f8 94       	cli
    8fb6:	de bf       	out	0x3e, r29	; 62
    8fb8:	0f be       	out	0x3f, r0	; 63
    8fba:	cd bf       	out	0x3d, r28	; 61
    8fbc:	df 91       	pop	r29
    8fbe:	cf 91       	pop	r28
    8fc0:	08 95       	ret

00008fc2 <_ZN13EthernetClass5beginEPh9IPAddressS1_>:

void EthernetClass::begin(uint8_t *mac_address, IPAddress local_ip, IPAddress dns_server)
{
    8fc2:	0f 93       	push	r16
    8fc4:	1f 93       	push	r17
    8fc6:	cf 93       	push	r28
    8fc8:	df 93       	push	r29
    8fca:	cd b7       	in	r28, 0x3d	; 61
    8fcc:	de b7       	in	r29, 0x3e	; 62
    8fce:	a0 97       	sbiw	r28, 0x20	; 32
    8fd0:	0f b6       	in	r0, 0x3f	; 63
    8fd2:	f8 94       	cli
    8fd4:	de bf       	out	0x3e, r29	; 62
    8fd6:	0f be       	out	0x3f, r0	; 63
    8fd8:	cd bf       	out	0x3d, r28	; 61
    8fda:	9a 8f       	std	Y+26, r25	; 0x1a
    8fdc:	89 8f       	std	Y+25, r24	; 0x19
    8fde:	7c 8f       	std	Y+28, r23	; 0x1c
    8fe0:	6b 8f       	std	Y+27, r22	; 0x1b
    8fe2:	5e 8f       	std	Y+30, r21	; 0x1e
    8fe4:	4d 8f       	std	Y+29, r20	; 0x1d
    8fe6:	38 a3       	std	Y+32, r19	; 0x20
    8fe8:	2f 8f       	std	Y+31, r18	; 0x1f
  // Assume the gateway will be the machine on the same network as the local IP
  // but with last octet being '1'
  IPAddress gateway = local_ip;
    8fea:	2d 8d       	ldd	r18, Y+29	; 0x1d
    8fec:	3e 8d       	ldd	r19, Y+30	; 0x1e
    8fee:	ce 01       	movw	r24, r28
    8ff0:	43 96       	adiw	r24, 0x13	; 19
    8ff2:	b9 01       	movw	r22, r18
    8ff4:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
  gateway[3] = 1;
    8ff8:	ce 01       	movw	r24, r28
    8ffa:	43 96       	adiw	r24, 0x13	; 19
    8ffc:	63 e0       	ldi	r22, 0x03	; 3
    8ffe:	70 e0       	ldi	r23, 0x00	; 0
    9000:	0e 94 70 aa 	call	0x154e0	; 0x154e0 <_ZN9IPAddressixEi>
    9004:	21 e0       	ldi	r18, 0x01	; 1
    9006:	fc 01       	movw	r30, r24
    9008:	20 83       	st	Z, r18
  begin(mac_address, local_ip, dns_server, gateway);
    900a:	9e 01       	movw	r18, r28
    900c:	2d 5e       	subi	r18, 0xED	; 237
    900e:	3f 4f       	sbci	r19, 0xFF	; 255
    9010:	ce 01       	movw	r24, r28
    9012:	0d 96       	adiw	r24, 0x0d	; 13
    9014:	b9 01       	movw	r22, r18
    9016:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    901a:	2f 8d       	ldd	r18, Y+31	; 0x1f
    901c:	38 a1       	ldd	r19, Y+32	; 0x20
    901e:	ce 01       	movw	r24, r28
    9020:	07 96       	adiw	r24, 0x07	; 7
    9022:	b9 01       	movw	r22, r18
    9024:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    9028:	8d 8d       	ldd	r24, Y+29	; 0x1d
    902a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    902c:	bc 01       	movw	r22, r24
    902e:	ce 01       	movw	r24, r28
    9030:	01 96       	adiw	r24, 0x01	; 1
    9032:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    9036:	ae 01       	movw	r20, r28
    9038:	43 5f       	subi	r20, 0xF3	; 243
    903a:	5f 4f       	sbci	r21, 0xFF	; 255
    903c:	9e 01       	movw	r18, r28
    903e:	29 5f       	subi	r18, 0xF9	; 249
    9040:	3f 4f       	sbci	r19, 0xFF	; 255
    9042:	6b 8d       	ldd	r22, Y+27	; 0x1b
    9044:	7c 8d       	ldd	r23, Y+28	; 0x1c
    9046:	89 8d       	ldd	r24, Y+25	; 0x19
    9048:	9a 8d       	ldd	r25, Y+26	; 0x1a
    904a:	8a 01       	movw	r16, r20
    904c:	ae 01       	movw	r20, r28
    904e:	4f 5f       	subi	r20, 0xFF	; 255
    9050:	5f 4f       	sbci	r21, 0xFF	; 255
    9052:	0e 94 36 48 	call	0x906c	; 0x906c <_ZN13EthernetClass5beginEPh9IPAddressS1_S1_>
}
    9056:	a0 96       	adiw	r28, 0x20	; 32
    9058:	0f b6       	in	r0, 0x3f	; 63
    905a:	f8 94       	cli
    905c:	de bf       	out	0x3e, r29	; 62
    905e:	0f be       	out	0x3f, r0	; 63
    9060:	cd bf       	out	0x3d, r28	; 61
    9062:	df 91       	pop	r29
    9064:	cf 91       	pop	r28
    9066:	1f 91       	pop	r17
    9068:	0f 91       	pop	r16
    906a:	08 95       	ret

0000906c <_ZN13EthernetClass5beginEPh9IPAddressS1_S1_>:

void EthernetClass::begin(uint8_t *mac_address, IPAddress local_ip, IPAddress dns_server, IPAddress gateway)
{
    906c:	ef 92       	push	r14
    906e:	ff 92       	push	r15
    9070:	0f 93       	push	r16
    9072:	1f 93       	push	r17
    9074:	cf 93       	push	r28
    9076:	df 93       	push	r29
    9078:	cd b7       	in	r28, 0x3d	; 61
    907a:	de b7       	in	r29, 0x3e	; 62
    907c:	a8 97       	sbiw	r28, 0x28	; 40
    907e:	0f b6       	in	r0, 0x3f	; 63
    9080:	f8 94       	cli
    9082:	de bf       	out	0x3e, r29	; 62
    9084:	0f be       	out	0x3f, r0	; 63
    9086:	cd bf       	out	0x3d, r28	; 61
    9088:	98 a3       	std	Y+32, r25	; 0x20
    908a:	8f 8f       	std	Y+31, r24	; 0x1f
    908c:	7a a3       	std	Y+34, r23	; 0x22
    908e:	69 a3       	std	Y+33, r22	; 0x21
    9090:	5c a3       	std	Y+36, r21	; 0x24
    9092:	4b a3       	std	Y+35, r20	; 0x23
    9094:	3e a3       	std	Y+38, r19	; 0x26
    9096:	2d a3       	std	Y+37, r18	; 0x25
    9098:	18 a7       	std	Y+40, r17	; 0x28
    909a:	0f a3       	std	Y+39, r16	; 0x27
  IPAddress subnet(255, 255, 255, 0);
    909c:	ce 01       	movw	r24, r28
    909e:	49 96       	adiw	r24, 0x19	; 25
    90a0:	00 e0       	ldi	r16, 0x00	; 0
    90a2:	2f ef       	ldi	r18, 0xFF	; 255
    90a4:	4f ef       	ldi	r20, 0xFF	; 255
    90a6:	6f ef       	ldi	r22, 0xFF	; 255
    90a8:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
  begin(mac_address, local_ip, dns_server, gateway, subnet);
    90ac:	9e 01       	movw	r18, r28
    90ae:	27 5e       	subi	r18, 0xE7	; 231
    90b0:	3f 4f       	sbci	r19, 0xFF	; 255
    90b2:	ce 01       	movw	r24, r28
    90b4:	43 96       	adiw	r24, 0x13	; 19
    90b6:	b9 01       	movw	r22, r18
    90b8:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    90bc:	2f a1       	ldd	r18, Y+39	; 0x27
    90be:	38 a5       	ldd	r19, Y+40	; 0x28
    90c0:	ce 01       	movw	r24, r28
    90c2:	0d 96       	adiw	r24, 0x0d	; 13
    90c4:	b9 01       	movw	r22, r18
    90c6:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    90ca:	2d a1       	ldd	r18, Y+37	; 0x25
    90cc:	3e a1       	ldd	r19, Y+38	; 0x26
    90ce:	ce 01       	movw	r24, r28
    90d0:	07 96       	adiw	r24, 0x07	; 7
    90d2:	b9 01       	movw	r22, r18
    90d4:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    90d8:	8b a1       	ldd	r24, Y+35	; 0x23
    90da:	9c a1       	ldd	r25, Y+36	; 0x24
    90dc:	bc 01       	movw	r22, r24
    90de:	ce 01       	movw	r24, r28
    90e0:	01 96       	adiw	r24, 0x01	; 1
    90e2:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    90e6:	fe 01       	movw	r30, r28
    90e8:	73 96       	adiw	r30, 0x13	; 19
    90ea:	ae 01       	movw	r20, r28
    90ec:	43 5f       	subi	r20, 0xF3	; 243
    90ee:	5f 4f       	sbci	r21, 0xFF	; 255
    90f0:	9e 01       	movw	r18, r28
    90f2:	29 5f       	subi	r18, 0xF9	; 249
    90f4:	3f 4f       	sbci	r19, 0xFF	; 255
    90f6:	69 a1       	ldd	r22, Y+33	; 0x21
    90f8:	7a a1       	ldd	r23, Y+34	; 0x22
    90fa:	8f 8d       	ldd	r24, Y+31	; 0x1f
    90fc:	98 a1       	ldd	r25, Y+32	; 0x20
    90fe:	7f 01       	movw	r14, r30
    9100:	8a 01       	movw	r16, r20
    9102:	ae 01       	movw	r20, r28
    9104:	4f 5f       	subi	r20, 0xFF	; 255
    9106:	5f 4f       	sbci	r21, 0xFF	; 255
    9108:	0e 94 93 48 	call	0x9126	; 0x9126 <_ZN13EthernetClass5beginEPh9IPAddressS1_S1_S1_>
}
    910c:	a8 96       	adiw	r28, 0x28	; 40
    910e:	0f b6       	in	r0, 0x3f	; 63
    9110:	f8 94       	cli
    9112:	de bf       	out	0x3e, r29	; 62
    9114:	0f be       	out	0x3f, r0	; 63
    9116:	cd bf       	out	0x3d, r28	; 61
    9118:	df 91       	pop	r29
    911a:	cf 91       	pop	r28
    911c:	1f 91       	pop	r17
    911e:	0f 91       	pop	r16
    9120:	ff 90       	pop	r15
    9122:	ef 90       	pop	r14
    9124:	08 95       	ret

00009126 <_ZN13EthernetClass5beginEPh9IPAddressS1_S1_S1_>:

void EthernetClass::begin(uint8_t *mac, IPAddress local_ip, IPAddress dns_server, IPAddress gateway, IPAddress subnet)
{
    9126:	ef 92       	push	r14
    9128:	ff 92       	push	r15
    912a:	0f 93       	push	r16
    912c:	1f 93       	push	r17
    912e:	cf 93       	push	r28
    9130:	df 93       	push	r29
    9132:	cd b7       	in	r28, 0x3d	; 61
    9134:	de b7       	in	r29, 0x3e	; 62
    9136:	2c 97       	sbiw	r28, 0x0c	; 12
    9138:	0f b6       	in	r0, 0x3f	; 63
    913a:	f8 94       	cli
    913c:	de bf       	out	0x3e, r29	; 62
    913e:	0f be       	out	0x3f, r0	; 63
    9140:	cd bf       	out	0x3d, r28	; 61
    9142:	9a 83       	std	Y+2, r25	; 0x02
    9144:	89 83       	std	Y+1, r24	; 0x01
    9146:	7c 83       	std	Y+4, r23	; 0x04
    9148:	6b 83       	std	Y+3, r22	; 0x03
    914a:	5e 83       	std	Y+6, r21	; 0x06
    914c:	4d 83       	std	Y+5, r20	; 0x05
    914e:	38 87       	std	Y+8, r19	; 0x08
    9150:	2f 83       	std	Y+7, r18	; 0x07
    9152:	1a 87       	std	Y+10, r17	; 0x0a
    9154:	09 87       	std	Y+9, r16	; 0x09
    9156:	fc 86       	std	Y+12, r15	; 0x0c
    9158:	eb 86       	std	Y+11, r14	; 0x0b
  W5100.init();
    915a:	8c e8       	ldi	r24, 0x8C	; 140
    915c:	97 e0       	ldi	r25, 0x07	; 7
    915e:	0e 94 0c 34 	call	0x6818	; 0x6818 <_ZN10W5100Class4initEv>
  W5100.setMACAddress(mac);
    9162:	8b 81       	ldd	r24, Y+3	; 0x03
    9164:	9c 81       	ldd	r25, Y+4	; 0x04
    9166:	bc 01       	movw	r22, r24
    9168:	8c e8       	ldi	r24, 0x8C	; 140
    916a:	97 e0       	ldi	r25, 0x07	; 7
    916c:	0e 94 aa ab 	call	0x15754	; 0x15754 <_ZN10W5100Class13setMACAddressEPh>
  W5100.setIPAddress(local_ip._address);
    9170:	8d 81       	ldd	r24, Y+5	; 0x05
    9172:	9e 81       	ldd	r25, Y+6	; 0x06
    9174:	02 96       	adiw	r24, 0x02	; 2
    9176:	bc 01       	movw	r22, r24
    9178:	8c e8       	ldi	r24, 0x8C	; 140
    917a:	97 e0       	ldi	r25, 0x07	; 7
    917c:	0e 94 d4 ab 	call	0x157a8	; 0x157a8 <_ZN10W5100Class12setIPAddressEPh>
  W5100.setGatewayIp(gateway._address);
    9180:	89 85       	ldd	r24, Y+9	; 0x09
    9182:	9a 85       	ldd	r25, Y+10	; 0x0a
    9184:	02 96       	adiw	r24, 0x02	; 2
    9186:	bc 01       	movw	r22, r24
    9188:	8c e8       	ldi	r24, 0x8C	; 140
    918a:	97 e0       	ldi	r25, 0x07	; 7
    918c:	0e 94 6b ab 	call	0x156d6	; 0x156d6 <_ZN10W5100Class12setGatewayIpEPh>
  W5100.setSubnetMask(subnet._address);
    9190:	8b 85       	ldd	r24, Y+11	; 0x0b
    9192:	9c 85       	ldd	r25, Y+12	; 0x0c
    9194:	02 96       	adiw	r24, 0x02	; 2
    9196:	bc 01       	movw	r22, r24
    9198:	8c e8       	ldi	r24, 0x8C	; 140
    919a:	97 e0       	ldi	r25, 0x07	; 7
    919c:	0e 94 95 ab 	call	0x1572a	; 0x1572a <_ZN10W5100Class13setSubnetMaskEPh>
  _dnsServerAddress = dns_server;
    91a0:	89 81       	ldd	r24, Y+1	; 0x01
    91a2:	9a 81       	ldd	r25, Y+2	; 0x02
    91a4:	2f 81       	ldd	r18, Y+7	; 0x07
    91a6:	38 85       	ldd	r19, Y+8	; 0x08
    91a8:	b9 01       	movw	r22, r18
    91aa:	0e 94 9b aa 	call	0x15536	; 0x15536 <_ZN9IPAddressaSERKS_>
}
    91ae:	2c 96       	adiw	r28, 0x0c	; 12
    91b0:	0f b6       	in	r0, 0x3f	; 63
    91b2:	f8 94       	cli
    91b4:	de bf       	out	0x3e, r29	; 62
    91b6:	0f be       	out	0x3f, r0	; 63
    91b8:	cd bf       	out	0x3d, r28	; 61
    91ba:	df 91       	pop	r29
    91bc:	cf 91       	pop	r28
    91be:	1f 91       	pop	r17
    91c0:	0f 91       	pop	r16
    91c2:	ff 90       	pop	r15
    91c4:	ef 90       	pop	r14
    91c6:	08 95       	ret

000091c8 <_ZN13EthernetClass8maintainEv>:

int EthernetClass::maintain(){
    91c8:	cf 93       	push	r28
    91ca:	df 93       	push	r29
    91cc:	cd b7       	in	r28, 0x3d	; 61
    91ce:	de b7       	in	r29, 0x3e	; 62
    91d0:	6c 97       	sbiw	r28, 0x1c	; 28
    91d2:	0f b6       	in	r0, 0x3f	; 63
    91d4:	f8 94       	cli
    91d6:	de bf       	out	0x3e, r29	; 62
    91d8:	0f be       	out	0x3f, r0	; 63
    91da:	cd bf       	out	0x3d, r28	; 61
    91dc:	9c 8f       	std	Y+28, r25	; 0x1c
    91de:	8b 8f       	std	Y+27, r24	; 0x1b
  int rc = DHCP_CHECK_NONE;
    91e0:	1a 82       	std	Y+2, r1	; 0x02
    91e2:	19 82       	std	Y+1, r1	; 0x01
  if(_dhcp != NULL){
    91e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    91e6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    91e8:	fc 01       	movw	r30, r24
    91ea:	86 81       	ldd	r24, Z+6	; 0x06
    91ec:	97 81       	ldd	r25, Z+7	; 0x07
    91ee:	00 97       	sbiw	r24, 0x00	; 0
    91f0:	09 f4       	brne	.+2      	; 0x91f4 <_ZN13EthernetClass8maintainEv+0x2c>
    91f2:	64 c0       	rjmp	.+200    	; 0x92bc <_ZN13EthernetClass8maintainEv+0xf4>
    //we have a pointer to dhcp, use it
    rc = _dhcp->checkLease();
    91f4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    91f6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    91f8:	fc 01       	movw	r30, r24
    91fa:	86 81       	ldd	r24, Z+6	; 0x06
    91fc:	97 81       	ldd	r25, Z+7	; 0x07
    91fe:	0e 94 83 3f 	call	0x7f06	; 0x7f06 <_ZN9DhcpClass10checkLeaseEv>
    9202:	9a 83       	std	Y+2, r25	; 0x02
    9204:	89 83       	std	Y+1, r24	; 0x01
    switch ( rc ){
    9206:	89 81       	ldd	r24, Y+1	; 0x01
    9208:	9a 81       	ldd	r25, Y+2	; 0x02
    920a:	82 30       	cpi	r24, 0x02	; 2
    920c:	91 05       	cpc	r25, r1
    920e:	39 f0       	breq	.+14     	; 0x921e <_ZN13EthernetClass8maintainEv+0x56>
    9210:	84 30       	cpi	r24, 0x04	; 4
    9212:	91 05       	cpc	r25, r1
    9214:	21 f0       	breq	.+8      	; 0x921e <_ZN13EthernetClass8maintainEv+0x56>
    9216:	00 97       	sbiw	r24, 0x00	; 0
    9218:	09 f4       	brne	.+2      	; 0x921c <_ZN13EthernetClass8maintainEv+0x54>
    921a:	4f c0       	rjmp	.+158    	; 0x92ba <_ZN13EthernetClass8maintainEv+0xf2>
    921c:	4c c0       	rjmp	.+152    	; 0x92b6 <_ZN13EthernetClass8maintainEv+0xee>
        //nothing done
        break;
      case DHCP_CHECK_RENEW_OK:
      case DHCP_CHECK_REBIND_OK:
        //we might have got a new IP.
        W5100.setIPAddress(_dhcp->getLocalIp().raw_address());
    921e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    9220:	9c 8d       	ldd	r25, Y+28	; 0x1c
    9222:	fc 01       	movw	r30, r24
    9224:	26 81       	ldd	r18, Z+6	; 0x06
    9226:	37 81       	ldd	r19, Z+7	; 0x07
    9228:	ce 01       	movw	r24, r28
    922a:	45 96       	adiw	r24, 0x15	; 21
    922c:	b9 01       	movw	r22, r18
    922e:	0e 94 fa 40 	call	0x81f4	; 0x81f4 <_ZN9DhcpClass10getLocalIpEv>
    9232:	ce 01       	movw	r24, r28
    9234:	45 96       	adiw	r24, 0x15	; 21
    9236:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    923a:	bc 01       	movw	r22, r24
    923c:	8c e8       	ldi	r24, 0x8C	; 140
    923e:	97 e0       	ldi	r25, 0x07	; 7
    9240:	0e 94 d4 ab 	call	0x157a8	; 0x157a8 <_ZN10W5100Class12setIPAddressEPh>
        W5100.setGatewayIp(_dhcp->getGatewayIp().raw_address());
    9244:	8b 8d       	ldd	r24, Y+27	; 0x1b
    9246:	9c 8d       	ldd	r25, Y+28	; 0x1c
    9248:	fc 01       	movw	r30, r24
    924a:	26 81       	ldd	r18, Z+6	; 0x06
    924c:	37 81       	ldd	r19, Z+7	; 0x07
    924e:	ce 01       	movw	r24, r28
    9250:	0f 96       	adiw	r24, 0x0f	; 15
    9252:	b9 01       	movw	r22, r18
    9254:	0e 94 34 41 	call	0x8268	; 0x8268 <_ZN9DhcpClass12getGatewayIpEv>
    9258:	ce 01       	movw	r24, r28
    925a:	0f 96       	adiw	r24, 0x0f	; 15
    925c:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    9260:	bc 01       	movw	r22, r24
    9262:	8c e8       	ldi	r24, 0x8C	; 140
    9264:	97 e0       	ldi	r25, 0x07	; 7
    9266:	0e 94 6b ab 	call	0x156d6	; 0x156d6 <_ZN10W5100Class12setGatewayIpEPh>
        W5100.setSubnetMask(_dhcp->getSubnetMask().raw_address());
    926a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    926c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    926e:	fc 01       	movw	r30, r24
    9270:	26 81       	ldd	r18, Z+6	; 0x06
    9272:	37 81       	ldd	r19, Z+7	; 0x07
    9274:	ce 01       	movw	r24, r28
    9276:	09 96       	adiw	r24, 0x09	; 9
    9278:	b9 01       	movw	r22, r18
    927a:	0e 94 17 41 	call	0x822e	; 0x822e <_ZN9DhcpClass13getSubnetMaskEv>
    927e:	ce 01       	movw	r24, r28
    9280:	09 96       	adiw	r24, 0x09	; 9
    9282:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    9286:	bc 01       	movw	r22, r24
    9288:	8c e8       	ldi	r24, 0x8C	; 140
    928a:	97 e0       	ldi	r25, 0x07	; 7
    928c:	0e 94 95 ab 	call	0x1572a	; 0x1572a <_ZN10W5100Class13setSubnetMaskEPh>
        _dnsServerAddress = _dhcp->getDnsServerIp();
    9290:	8b 8d       	ldd	r24, Y+27	; 0x1b
    9292:	9c 8d       	ldd	r25, Y+28	; 0x1c
    9294:	fc 01       	movw	r30, r24
    9296:	26 81       	ldd	r18, Z+6	; 0x06
    9298:	37 81       	ldd	r19, Z+7	; 0x07
    929a:	ce 01       	movw	r24, r28
    929c:	03 96       	adiw	r24, 0x03	; 3
    929e:	b9 01       	movw	r22, r18
    92a0:	0e 94 6e 41 	call	0x82dc	; 0x82dc <_ZN9DhcpClass14getDnsServerIpEv>
    92a4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    92a6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    92a8:	9e 01       	movw	r18, r28
    92aa:	2d 5f       	subi	r18, 0xFD	; 253
    92ac:	3f 4f       	sbci	r19, 0xFF	; 255
    92ae:	b9 01       	movw	r22, r18
    92b0:	0e 94 9b aa 	call	0x15536	; 0x15536 <_ZN9IPAddressaSERKS_>
        break;
    92b4:	03 c0       	rjmp	.+6      	; 0x92bc <_ZN13EthernetClass8maintainEv+0xf4>
      default:
        //this is actually a error, it will retry though
        break;
    92b6:	00 00       	nop
    92b8:	01 c0       	rjmp	.+2      	; 0x92bc <_ZN13EthernetClass8maintainEv+0xf4>
    //we have a pointer to dhcp, use it
    rc = _dhcp->checkLease();
    switch ( rc ){
      case DHCP_CHECK_NONE:
        //nothing done
        break;
    92ba:	00 00       	nop
      default:
        //this is actually a error, it will retry though
        break;
    }
  }
  return rc;
    92bc:	89 81       	ldd	r24, Y+1	; 0x01
    92be:	9a 81       	ldd	r25, Y+2	; 0x02
}
    92c0:	6c 96       	adiw	r28, 0x1c	; 28
    92c2:	0f b6       	in	r0, 0x3f	; 63
    92c4:	f8 94       	cli
    92c6:	de bf       	out	0x3e, r29	; 62
    92c8:	0f be       	out	0x3f, r0	; 63
    92ca:	cd bf       	out	0x3d, r28	; 61
    92cc:	df 91       	pop	r29
    92ce:	cf 91       	pop	r28
    92d0:	08 95       	ret

000092d2 <_ZN13EthernetClass7localIPEv>:

IPAddress EthernetClass::localIP()
{
    92d2:	cf 93       	push	r28
    92d4:	df 93       	push	r29
    92d6:	00 d0       	rcall	.+0      	; 0x92d8 <_ZN13EthernetClass7localIPEv+0x6>
    92d8:	00 d0       	rcall	.+0      	; 0x92da <_ZN13EthernetClass7localIPEv+0x8>
    92da:	cd b7       	in	r28, 0x3d	; 61
    92dc:	de b7       	in	r29, 0x3e	; 62
    92de:	9a 83       	std	Y+2, r25	; 0x02
    92e0:	89 83       	std	Y+1, r24	; 0x01
    92e2:	7c 83       	std	Y+4, r23	; 0x04
    92e4:	6b 83       	std	Y+3, r22	; 0x03
  IPAddress ret;
    92e6:	89 81       	ldd	r24, Y+1	; 0x01
    92e8:	9a 81       	ldd	r25, Y+2	; 0x02
    92ea:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>
  W5100.getIPAddress(ret.raw_address());
    92ee:	89 81       	ldd	r24, Y+1	; 0x01
    92f0:	9a 81       	ldd	r25, Y+2	; 0x02
    92f2:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    92f6:	bc 01       	movw	r22, r24
    92f8:	8c e8       	ldi	r24, 0x8C	; 140
    92fa:	97 e0       	ldi	r25, 0x07	; 7
    92fc:	0e 94 bf ab 	call	0x1577e	; 0x1577e <_ZN10W5100Class12getIPAddressEPh>
  return ret;
    9300:	00 00       	nop
}
    9302:	89 81       	ldd	r24, Y+1	; 0x01
    9304:	9a 81       	ldd	r25, Y+2	; 0x02
    9306:	0f 90       	pop	r0
    9308:	0f 90       	pop	r0
    930a:	0f 90       	pop	r0
    930c:	0f 90       	pop	r0
    930e:	df 91       	pop	r29
    9310:	cf 91       	pop	r28
    9312:	08 95       	ret

00009314 <_ZN13EthernetClass10subnetMaskEv>:

IPAddress EthernetClass::subnetMask()
{
    9314:	cf 93       	push	r28
    9316:	df 93       	push	r29
    9318:	00 d0       	rcall	.+0      	; 0x931a <_ZN13EthernetClass10subnetMaskEv+0x6>
    931a:	00 d0       	rcall	.+0      	; 0x931c <_ZN13EthernetClass10subnetMaskEv+0x8>
    931c:	cd b7       	in	r28, 0x3d	; 61
    931e:	de b7       	in	r29, 0x3e	; 62
    9320:	9a 83       	std	Y+2, r25	; 0x02
    9322:	89 83       	std	Y+1, r24	; 0x01
    9324:	7c 83       	std	Y+4, r23	; 0x04
    9326:	6b 83       	std	Y+3, r22	; 0x03
  IPAddress ret;
    9328:	89 81       	ldd	r24, Y+1	; 0x01
    932a:	9a 81       	ldd	r25, Y+2	; 0x02
    932c:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>
  W5100.getSubnetMask(ret.raw_address());
    9330:	89 81       	ldd	r24, Y+1	; 0x01
    9332:	9a 81       	ldd	r25, Y+2	; 0x02
    9334:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    9338:	bc 01       	movw	r22, r24
    933a:	8c e8       	ldi	r24, 0x8C	; 140
    933c:	97 e0       	ldi	r25, 0x07	; 7
    933e:	0e 94 80 ab 	call	0x15700	; 0x15700 <_ZN10W5100Class13getSubnetMaskEPh>
  return ret;
    9342:	00 00       	nop
}
    9344:	89 81       	ldd	r24, Y+1	; 0x01
    9346:	9a 81       	ldd	r25, Y+2	; 0x02
    9348:	0f 90       	pop	r0
    934a:	0f 90       	pop	r0
    934c:	0f 90       	pop	r0
    934e:	0f 90       	pop	r0
    9350:	df 91       	pop	r29
    9352:	cf 91       	pop	r28
    9354:	08 95       	ret

00009356 <_ZN13EthernetClass9gatewayIPEv>:

IPAddress EthernetClass::gatewayIP()
{
    9356:	cf 93       	push	r28
    9358:	df 93       	push	r29
    935a:	00 d0       	rcall	.+0      	; 0x935c <_ZN13EthernetClass9gatewayIPEv+0x6>
    935c:	00 d0       	rcall	.+0      	; 0x935e <_ZN13EthernetClass9gatewayIPEv+0x8>
    935e:	cd b7       	in	r28, 0x3d	; 61
    9360:	de b7       	in	r29, 0x3e	; 62
    9362:	9a 83       	std	Y+2, r25	; 0x02
    9364:	89 83       	std	Y+1, r24	; 0x01
    9366:	7c 83       	std	Y+4, r23	; 0x04
    9368:	6b 83       	std	Y+3, r22	; 0x03
  IPAddress ret;
    936a:	89 81       	ldd	r24, Y+1	; 0x01
    936c:	9a 81       	ldd	r25, Y+2	; 0x02
    936e:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>
  W5100.getGatewayIp(ret.raw_address());
    9372:	89 81       	ldd	r24, Y+1	; 0x01
    9374:	9a 81       	ldd	r25, Y+2	; 0x02
    9376:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
    937a:	bc 01       	movw	r22, r24
    937c:	8c e8       	ldi	r24, 0x8C	; 140
    937e:	97 e0       	ldi	r25, 0x07	; 7
    9380:	0e 94 56 ab 	call	0x156ac	; 0x156ac <_ZN10W5100Class12getGatewayIpEPh>
  return ret;
    9384:	00 00       	nop
}
    9386:	89 81       	ldd	r24, Y+1	; 0x01
    9388:	9a 81       	ldd	r25, Y+2	; 0x02
    938a:	0f 90       	pop	r0
    938c:	0f 90       	pop	r0
    938e:	0f 90       	pop	r0
    9390:	0f 90       	pop	r0
    9392:	df 91       	pop	r29
    9394:	cf 91       	pop	r28
    9396:	08 95       	ret

00009398 <_ZN13EthernetClass11dnsServerIPEv>:

IPAddress EthernetClass::dnsServerIP()
{
    9398:	cf 93       	push	r28
    939a:	df 93       	push	r29
    939c:	00 d0       	rcall	.+0      	; 0x939e <_ZN13EthernetClass11dnsServerIPEv+0x6>
    939e:	00 d0       	rcall	.+0      	; 0x93a0 <_ZN13EthernetClass11dnsServerIPEv+0x8>
    93a0:	cd b7       	in	r28, 0x3d	; 61
    93a2:	de b7       	in	r29, 0x3e	; 62
    93a4:	9a 83       	std	Y+2, r25	; 0x02
    93a6:	89 83       	std	Y+1, r24	; 0x01
    93a8:	7c 83       	std	Y+4, r23	; 0x04
    93aa:	6b 83       	std	Y+3, r22	; 0x03
  return _dnsServerAddress;
    93ac:	2b 81       	ldd	r18, Y+3	; 0x03
    93ae:	3c 81       	ldd	r19, Y+4	; 0x04
    93b0:	89 81       	ldd	r24, Y+1	; 0x01
    93b2:	9a 81       	ldd	r25, Y+2	; 0x02
    93b4:	b9 01       	movw	r22, r18
    93b6:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
}
    93ba:	89 81       	ldd	r24, Y+1	; 0x01
    93bc:	9a 81       	ldd	r25, Y+2	; 0x02
    93be:	0f 90       	pop	r0
    93c0:	0f 90       	pop	r0
    93c2:	0f 90       	pop	r0
    93c4:	0f 90       	pop	r0
    93c6:	df 91       	pop	r29
    93c8:	cf 91       	pop	r28
    93ca:	08 95       	ret

000093cc <_Z41__static_initialization_and_destruction_0ii>:

EthernetClass Ethernet;
    93cc:	0f 93       	push	r16
    93ce:	cf 93       	push	r28
    93d0:	df 93       	push	r29
    93d2:	00 d0       	rcall	.+0      	; 0x93d4 <_Z41__static_initialization_and_destruction_0ii+0x8>
    93d4:	00 d0       	rcall	.+0      	; 0x93d6 <_Z41__static_initialization_and_destruction_0ii+0xa>
    93d6:	cd b7       	in	r28, 0x3d	; 61
    93d8:	de b7       	in	r29, 0x3e	; 62
    93da:	9a 83       	std	Y+2, r25	; 0x02
    93dc:	89 83       	std	Y+1, r24	; 0x01
    93de:	7c 83       	std	Y+4, r23	; 0x04
    93e0:	6b 83       	std	Y+3, r22	; 0x03
    93e2:	89 81       	ldd	r24, Y+1	; 0x01
    93e4:	9a 81       	ldd	r25, Y+2	; 0x02
    93e6:	81 30       	cpi	r24, 0x01	; 1
    93e8:	91 05       	cpc	r25, r1
    93ea:	91 f4       	brne	.+36     	; 0x9410 <_Z41__static_initialization_and_destruction_0ii+0x44>
    93ec:	8b 81       	ldd	r24, Y+3	; 0x03
    93ee:	9c 81       	ldd	r25, Y+4	; 0x04
    93f0:	8f 3f       	cpi	r24, 0xFF	; 255
    93f2:	2f ef       	ldi	r18, 0xFF	; 255
    93f4:	92 07       	cpc	r25, r18
    93f6:	61 f4       	brne	.+24     	; 0x9410 <_Z41__static_initialization_and_destruction_0ii+0x44>
    93f8:	00 e0       	ldi	r16, 0x00	; 0
    93fa:	20 e0       	ldi	r18, 0x00	; 0
    93fc:	40 e0       	ldi	r20, 0x00	; 0
    93fe:	60 e0       	ldi	r22, 0x00	; 0
    9400:	8c eb       	ldi	r24, 0xBC	; 188
    9402:	97 e0       	ldi	r25, 0x07	; 7
    9404:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    9408:	84 eb       	ldi	r24, 0xB4	; 180
    940a:	97 e0       	ldi	r25, 0x07	; 7
    940c:	0e 94 fb ab 	call	0x157f6	; 0x157f6 <_ZN13EthernetClassC1Ev>
    9410:	0f 90       	pop	r0
    9412:	0f 90       	pop	r0
    9414:	0f 90       	pop	r0
    9416:	0f 90       	pop	r0
    9418:	df 91       	pop	r29
    941a:	cf 91       	pop	r28
    941c:	0f 91       	pop	r16
    941e:	08 95       	ret

00009420 <_GLOBAL__sub_I__ZN13EthernetClass6_stateE>:
    9420:	cf 93       	push	r28
    9422:	df 93       	push	r29
    9424:	cd b7       	in	r28, 0x3d	; 61
    9426:	de b7       	in	r29, 0x3e	; 62
    9428:	6f ef       	ldi	r22, 0xFF	; 255
    942a:	7f ef       	ldi	r23, 0xFF	; 255
    942c:	81 e0       	ldi	r24, 0x01	; 1
    942e:	90 e0       	ldi	r25, 0x00	; 0
    9430:	0e 94 e6 49 	call	0x93cc	; 0x93cc <_Z41__static_initialization_and_destruction_0ii>
    9434:	df 91       	pop	r29
    9436:	cf 91       	pop	r28
    9438:	08 95       	ret

0000943a <_ZN14EthernetClientC1Ev>:
#include "EthernetServer.h"
#include "Dns.h"

uint16_t EthernetClient::_srcport = 1024;

EthernetClient::EthernetClient() : _sock(MAX_SOCK_NUM) {
    943a:	cf 93       	push	r28
    943c:	df 93       	push	r29
    943e:	00 d0       	rcall	.+0      	; 0x9440 <_ZN14EthernetClientC1Ev+0x6>
    9440:	cd b7       	in	r28, 0x3d	; 61
    9442:	de b7       	in	r29, 0x3e	; 62
    9444:	9a 83       	std	Y+2, r25	; 0x02
    9446:	89 83       	std	Y+1, r24	; 0x01
    9448:	89 81       	ldd	r24, Y+1	; 0x01
    944a:	9a 81       	ldd	r25, Y+2	; 0x02
    944c:	0e 94 d1 a5 	call	0x14ba2	; 0x14ba2 <_ZN6ClientC1Ev>
    9450:	89 81       	ldd	r24, Y+1	; 0x01
    9452:	9a 81       	ldd	r25, Y+2	; 0x02
    9454:	2d e3       	ldi	r18, 0x3D	; 61
    9456:	35 e0       	ldi	r19, 0x05	; 5
    9458:	fc 01       	movw	r30, r24
    945a:	31 83       	std	Z+1, r19	; 0x01
    945c:	20 83       	st	Z, r18
    945e:	89 81       	ldd	r24, Y+1	; 0x01
    9460:	9a 81       	ldd	r25, Y+2	; 0x02
    9462:	24 e0       	ldi	r18, 0x04	; 4
    9464:	fc 01       	movw	r30, r24
    9466:	24 87       	std	Z+12, r18	; 0x0c
}
    9468:	0f 90       	pop	r0
    946a:	0f 90       	pop	r0
    946c:	df 91       	pop	r29
    946e:	cf 91       	pop	r28
    9470:	08 95       	ret

00009472 <_ZN14EthernetClientC1Eh>:

EthernetClient::EthernetClient(uint8_t sock) : _sock(sock) {
    9472:	cf 93       	push	r28
    9474:	df 93       	push	r29
    9476:	00 d0       	rcall	.+0      	; 0x9478 <_ZN14EthernetClientC1Eh+0x6>
    9478:	1f 92       	push	r1
    947a:	cd b7       	in	r28, 0x3d	; 61
    947c:	de b7       	in	r29, 0x3e	; 62
    947e:	9a 83       	std	Y+2, r25	; 0x02
    9480:	89 83       	std	Y+1, r24	; 0x01
    9482:	6b 83       	std	Y+3, r22	; 0x03
    9484:	89 81       	ldd	r24, Y+1	; 0x01
    9486:	9a 81       	ldd	r25, Y+2	; 0x02
    9488:	0e 94 d1 a5 	call	0x14ba2	; 0x14ba2 <_ZN6ClientC1Ev>
    948c:	89 81       	ldd	r24, Y+1	; 0x01
    948e:	9a 81       	ldd	r25, Y+2	; 0x02
    9490:	2d e3       	ldi	r18, 0x3D	; 61
    9492:	35 e0       	ldi	r19, 0x05	; 5
    9494:	fc 01       	movw	r30, r24
    9496:	31 83       	std	Z+1, r19	; 0x01
    9498:	20 83       	st	Z, r18
    949a:	89 81       	ldd	r24, Y+1	; 0x01
    949c:	9a 81       	ldd	r25, Y+2	; 0x02
    949e:	2b 81       	ldd	r18, Y+3	; 0x03
    94a0:	fc 01       	movw	r30, r24
    94a2:	24 87       	std	Z+12, r18	; 0x0c
}
    94a4:	0f 90       	pop	r0
    94a6:	0f 90       	pop	r0
    94a8:	0f 90       	pop	r0
    94aa:	df 91       	pop	r29
    94ac:	cf 91       	pop	r28
    94ae:	08 95       	ret

000094b0 <_ZN14EthernetClient7connectEPKcj>:

int EthernetClient::connect(const char* host, uint16_t port) {
    94b0:	0f 93       	push	r16
    94b2:	1f 93       	push	r17
    94b4:	cf 93       	push	r28
    94b6:	df 93       	push	r29
    94b8:	cd b7       	in	r28, 0x3d	; 61
    94ba:	de b7       	in	r29, 0x3e	; 62
    94bc:	ed 97       	sbiw	r28, 0x3d	; 61
    94be:	0f b6       	in	r0, 0x3f	; 63
    94c0:	f8 94       	cli
    94c2:	de bf       	out	0x3e, r29	; 62
    94c4:	0f be       	out	0x3f, r0	; 63
    94c6:	cd bf       	out	0x3d, r28	; 61
    94c8:	99 af       	std	Y+57, r25	; 0x39
    94ca:	88 af       	std	Y+56, r24	; 0x38
    94cc:	7b af       	std	Y+59, r23	; 0x3b
    94ce:	6a af       	std	Y+58, r22	; 0x3a
    94d0:	5d af       	std	Y+61, r21	; 0x3d
    94d2:	4c af       	std	Y+60, r20	; 0x3c
  // Look up the host first
  int ret = 0;
    94d4:	1a 82       	std	Y+2, r1	; 0x02
    94d6:	19 82       	std	Y+1, r1	; 0x01
  DNSClient dns;
    94d8:	ce 01       	movw	r24, r28
    94da:	45 96       	adiw	r24, 0x15	; 21
    94dc:	0e 94 20 ac 	call	0x15840	; 0x15840 <_ZN9DNSClientC1Ev>
  IPAddress remote_addr;
    94e0:	ce 01       	movw	r24, r28
    94e2:	0f 96       	adiw	r24, 0x0f	; 15
    94e4:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>

  dns.begin(Ethernet.dnsServerIP());
    94e8:	ce 01       	movw	r24, r28
    94ea:	09 96       	adiw	r24, 0x09	; 9
    94ec:	64 eb       	ldi	r22, 0xB4	; 180
    94ee:	77 e0       	ldi	r23, 0x07	; 7
    94f0:	0e 94 cc 49 	call	0x9398	; 0x9398 <_ZN13EthernetClass11dnsServerIPEv>
    94f4:	9e 01       	movw	r18, r28
    94f6:	27 5f       	subi	r18, 0xF7	; 247
    94f8:	3f 4f       	sbci	r19, 0xFF	; 255
    94fa:	ce 01       	movw	r24, r28
    94fc:	45 96       	adiw	r24, 0x15	; 21
    94fe:	b9 01       	movw	r22, r18
    9500:	0e 94 0f 42 	call	0x841e	; 0x841e <_ZN9DNSClient5beginERK9IPAddress>
  ret = dns.getHostByName(host, remote_addr);
    9504:	ae 01       	movw	r20, r28
    9506:	41 5f       	subi	r20, 0xF1	; 241
    9508:	5f 4f       	sbci	r21, 0xFF	; 255
    950a:	2a ad       	ldd	r18, Y+58	; 0x3a
    950c:	3b ad       	ldd	r19, Y+59	; 0x3b
    950e:	ce 01       	movw	r24, r28
    9510:	45 96       	adiw	r24, 0x15	; 21
    9512:	b9 01       	movw	r22, r18
    9514:	0e 94 e6 42 	call	0x85cc	; 0x85cc <_ZN9DNSClient13getHostByNameEPKcR9IPAddress>
    9518:	9a 83       	std	Y+2, r25	; 0x02
    951a:	89 83       	std	Y+1, r24	; 0x01
  if (ret == 1) {
    951c:	89 81       	ldd	r24, Y+1	; 0x01
    951e:	9a 81       	ldd	r25, Y+2	; 0x02
    9520:	81 30       	cpi	r24, 0x01	; 1
    9522:	91 05       	cpc	r25, r1
    9524:	e1 f4       	brne	.+56     	; 0x955e <_ZN14EthernetClient7connectEPKcj+0xae>
    return connect(remote_addr, port);
    9526:	88 ad       	ldd	r24, Y+56	; 0x38
    9528:	99 ad       	ldd	r25, Y+57	; 0x39
    952a:	fc 01       	movw	r30, r24
    952c:	80 81       	ld	r24, Z
    952e:	91 81       	ldd	r25, Z+1	; 0x01
    9530:	0c 96       	adiw	r24, 0x0c	; 12
    9532:	fc 01       	movw	r30, r24
    9534:	00 81       	ld	r16, Z
    9536:	11 81       	ldd	r17, Z+1	; 0x01
    9538:	9e 01       	movw	r18, r28
    953a:	21 5f       	subi	r18, 0xF1	; 241
    953c:	3f 4f       	sbci	r19, 0xFF	; 255
    953e:	ce 01       	movw	r24, r28
    9540:	03 96       	adiw	r24, 0x03	; 3
    9542:	b9 01       	movw	r22, r18
    9544:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    9548:	4c ad       	ldd	r20, Y+60	; 0x3c
    954a:	5d ad       	ldd	r21, Y+61	; 0x3d
    954c:	9e 01       	movw	r18, r28
    954e:	2d 5f       	subi	r18, 0xFD	; 253
    9550:	3f 4f       	sbci	r19, 0xFF	; 255
    9552:	88 ad       	ldd	r24, Y+56	; 0x38
    9554:	99 ad       	ldd	r25, Y+57	; 0x39
    9556:	b9 01       	movw	r22, r18
    9558:	f8 01       	movw	r30, r16
    955a:	09 95       	icall
    955c:	02 c0       	rjmp	.+4      	; 0x9562 <_ZN14EthernetClient7connectEPKcj+0xb2>
  } else {
    return ret;
    955e:	89 81       	ldd	r24, Y+1	; 0x01
    9560:	9a 81       	ldd	r25, Y+2	; 0x02
  }
}
    9562:	ed 96       	adiw	r28, 0x3d	; 61
    9564:	0f b6       	in	r0, 0x3f	; 63
    9566:	f8 94       	cli
    9568:	de bf       	out	0x3e, r29	; 62
    956a:	0f be       	out	0x3f, r0	; 63
    956c:	cd bf       	out	0x3d, r28	; 61
    956e:	df 91       	pop	r29
    9570:	cf 91       	pop	r28
    9572:	1f 91       	pop	r17
    9574:	0f 91       	pop	r16
    9576:	08 95       	ret

00009578 <_ZN14EthernetClient7connectE9IPAddressj>:

int EthernetClient::connect(IPAddress ip, uint16_t port) {
    9578:	cf 93       	push	r28
    957a:	df 93       	push	r29
    957c:	cd b7       	in	r28, 0x3d	; 61
    957e:	de b7       	in	r29, 0x3e	; 62
    9580:	29 97       	sbiw	r28, 0x09	; 9
    9582:	0f b6       	in	r0, 0x3f	; 63
    9584:	f8 94       	cli
    9586:	de bf       	out	0x3e, r29	; 62
    9588:	0f be       	out	0x3f, r0	; 63
    958a:	cd bf       	out	0x3d, r28	; 61
    958c:	9d 83       	std	Y+5, r25	; 0x05
    958e:	8c 83       	std	Y+4, r24	; 0x04
    9590:	7f 83       	std	Y+7, r23	; 0x07
    9592:	6e 83       	std	Y+6, r22	; 0x06
    9594:	59 87       	std	Y+9, r21	; 0x09
    9596:	48 87       	std	Y+8, r20	; 0x08
  if (_sock != MAX_SOCK_NUM)
    9598:	8c 81       	ldd	r24, Y+4	; 0x04
    959a:	9d 81       	ldd	r25, Y+5	; 0x05
    959c:	dc 01       	movw	r26, r24
    959e:	1c 96       	adiw	r26, 0x0c	; 12
    95a0:	8c 91       	ld	r24, X
    95a2:	1c 97       	sbiw	r26, 0x0c	; 12
    95a4:	84 30       	cpi	r24, 0x04	; 4
    95a6:	19 f0       	breq	.+6      	; 0x95ae <_ZN14EthernetClient7connectE9IPAddressj+0x36>
    return 0;
    95a8:	80 e0       	ldi	r24, 0x00	; 0
    95aa:	90 e0       	ldi	r25, 0x00	; 0
    95ac:	9d c0       	rjmp	.+314    	; 0x96e8 <_ZN14EthernetClient7connectE9IPAddressj+0x170>

  for (int i = 0; i < MAX_SOCK_NUM; i++) {
    95ae:	1a 82       	std	Y+2, r1	; 0x02
    95b0:	19 82       	std	Y+1, r1	; 0x01
    95b2:	18 c0       	rjmp	.+48     	; 0x95e4 <_ZN14EthernetClient7connectE9IPAddressj+0x6c>
    uint8_t s = W5100.readSnSR(i);
    95b4:	89 81       	ldd	r24, Y+1	; 0x01
    95b6:	0e 94 86 a7 	call	0x14f0c	; 0x14f0c <_ZN10W5100Class8readSnSREh>
    95ba:	8b 83       	std	Y+3, r24	; 0x03
    if (s == SnSR::CLOSED || s == SnSR::FIN_WAIT || s == SnSR::CLOSE_WAIT) {
    95bc:	8b 81       	ldd	r24, Y+3	; 0x03
    95be:	88 23       	and	r24, r24
    95c0:	31 f0       	breq	.+12     	; 0x95ce <_ZN14EthernetClient7connectE9IPAddressj+0x56>
    95c2:	8b 81       	ldd	r24, Y+3	; 0x03
    95c4:	88 31       	cpi	r24, 0x18	; 24
    95c6:	19 f0       	breq	.+6      	; 0x95ce <_ZN14EthernetClient7connectE9IPAddressj+0x56>
    95c8:	8b 81       	ldd	r24, Y+3	; 0x03
    95ca:	8c 31       	cpi	r24, 0x1C	; 28
    95cc:	31 f4       	brne	.+12     	; 0x95da <_ZN14EthernetClient7connectE9IPAddressj+0x62>
      _sock = i;
    95ce:	29 81       	ldd	r18, Y+1	; 0x01
    95d0:	8c 81       	ldd	r24, Y+4	; 0x04
    95d2:	9d 81       	ldd	r25, Y+5	; 0x05
    95d4:	fc 01       	movw	r30, r24
    95d6:	24 87       	std	Z+12, r18	; 0x0c
      break;
    95d8:	0e c0       	rjmp	.+28     	; 0x95f6 <_ZN14EthernetClient7connectE9IPAddressj+0x7e>

int EthernetClient::connect(IPAddress ip, uint16_t port) {
  if (_sock != MAX_SOCK_NUM)
    return 0;

  for (int i = 0; i < MAX_SOCK_NUM; i++) {
    95da:	89 81       	ldd	r24, Y+1	; 0x01
    95dc:	9a 81       	ldd	r25, Y+2	; 0x02
    95de:	01 96       	adiw	r24, 0x01	; 1
    95e0:	9a 83       	std	Y+2, r25	; 0x02
    95e2:	89 83       	std	Y+1, r24	; 0x01
    95e4:	21 e0       	ldi	r18, 0x01	; 1
    95e6:	89 81       	ldd	r24, Y+1	; 0x01
    95e8:	9a 81       	ldd	r25, Y+2	; 0x02
    95ea:	84 30       	cpi	r24, 0x04	; 4
    95ec:	91 05       	cpc	r25, r1
    95ee:	0c f0       	brlt	.+2      	; 0x95f2 <_ZN14EthernetClient7connectE9IPAddressj+0x7a>
    95f0:	20 e0       	ldi	r18, 0x00	; 0
    95f2:	22 23       	and	r18, r18
    95f4:	f9 f6       	brne	.-66     	; 0x95b4 <_ZN14EthernetClient7connectE9IPAddressj+0x3c>
      _sock = i;
      break;
    }
  }

  if (_sock == MAX_SOCK_NUM)
    95f6:	8c 81       	ldd	r24, Y+4	; 0x04
    95f8:	9d 81       	ldd	r25, Y+5	; 0x05
    95fa:	dc 01       	movw	r26, r24
    95fc:	1c 96       	adiw	r26, 0x0c	; 12
    95fe:	8c 91       	ld	r24, X
    9600:	1c 97       	sbiw	r26, 0x0c	; 12
    9602:	84 30       	cpi	r24, 0x04	; 4
    9604:	19 f4       	brne	.+6      	; 0x960c <_ZN14EthernetClient7connectE9IPAddressj+0x94>
    return 0;
    9606:	80 e0       	ldi	r24, 0x00	; 0
    9608:	90 e0       	ldi	r25, 0x00	; 0
    960a:	6e c0       	rjmp	.+220    	; 0x96e8 <_ZN14EthernetClient7connectE9IPAddressj+0x170>

  _srcport++;
    960c:	80 91 42 02 	lds	r24, 0x0242
    9610:	90 91 43 02 	lds	r25, 0x0243
    9614:	01 96       	adiw	r24, 0x01	; 1
    9616:	90 93 43 02 	sts	0x0243, r25
    961a:	80 93 42 02 	sts	0x0242, r24
  if (_srcport == 0) _srcport = 1024;
    961e:	80 91 42 02 	lds	r24, 0x0242
    9622:	90 91 43 02 	lds	r25, 0x0243
    9626:	00 97       	sbiw	r24, 0x00	; 0
    9628:	31 f4       	brne	.+12     	; 0x9636 <_ZN14EthernetClient7connectE9IPAddressj+0xbe>
    962a:	80 e0       	ldi	r24, 0x00	; 0
    962c:	94 e0       	ldi	r25, 0x04	; 4
    962e:	90 93 43 02 	sts	0x0243, r25
    9632:	80 93 42 02 	sts	0x0242, r24
  socket(_sock, SnMR::TCP, _srcport, 0);
    9636:	80 91 42 02 	lds	r24, 0x0242
    963a:	90 91 43 02 	lds	r25, 0x0243
    963e:	2c 81       	ldd	r18, Y+4	; 0x04
    9640:	3d 81       	ldd	r19, Y+5	; 0x05
    9642:	f9 01       	movw	r30, r18
    9644:	34 85       	ldd	r19, Z+12	; 0x0c
    9646:	20 e0       	ldi	r18, 0x00	; 0
    9648:	ac 01       	movw	r20, r24
    964a:	61 e0       	ldi	r22, 0x01	; 1
    964c:	83 2f       	mov	r24, r19
    964e:	0e 94 03 2f 	call	0x5e06	; 0x5e06 <_Z6sockethhjh>

  if (!::connect(_sock, rawIPAddress(ip), port)) {
    9652:	8c 81       	ldd	r24, Y+4	; 0x04
    9654:	9d 81       	ldd	r25, Y+5	; 0x05
    9656:	2e 81       	ldd	r18, Y+6	; 0x06
    9658:	3f 81       	ldd	r19, Y+7	; 0x07
    965a:	b9 01       	movw	r22, r18
    965c:	0e 94 0b ac 	call	0x15816	; 0x15816 <_ZN6Client12rawIPAddressER9IPAddress>
    9660:	2c 81       	ldd	r18, Y+4	; 0x04
    9662:	3d 81       	ldd	r19, Y+5	; 0x05
    9664:	d9 01       	movw	r26, r18
    9666:	1c 96       	adiw	r26, 0x0c	; 12
    9668:	ec 91       	ld	r30, X
    966a:	28 85       	ldd	r18, Y+8	; 0x08
    966c:	39 85       	ldd	r19, Y+9	; 0x09
    966e:	a9 01       	movw	r20, r18
    9670:	bc 01       	movw	r22, r24
    9672:	8e 2f       	mov	r24, r30
    9674:	0e 94 86 2f 	call	0x5f0c	; 0x5f0c <_Z7connecthPhj>
    9678:	98 2f       	mov	r25, r24
    967a:	81 e0       	ldi	r24, 0x01	; 1
    967c:	99 23       	and	r25, r25
    967e:	09 f0       	breq	.+2      	; 0x9682 <_ZN14EthernetClient7connectE9IPAddressj+0x10a>
    9680:	80 e0       	ldi	r24, 0x00	; 0
    9682:	88 23       	and	r24, r24
    9684:	19 f1       	breq	.+70     	; 0x96cc <_ZN14EthernetClient7connectE9IPAddressj+0x154>
    _sock = MAX_SOCK_NUM;
    9686:	8c 81       	ldd	r24, Y+4	; 0x04
    9688:	9d 81       	ldd	r25, Y+5	; 0x05
    968a:	24 e0       	ldi	r18, 0x04	; 4
    968c:	fc 01       	movw	r30, r24
    968e:	24 87       	std	Z+12, r18	; 0x0c
    return 0;
    9690:	80 e0       	ldi	r24, 0x00	; 0
    9692:	90 e0       	ldi	r25, 0x00	; 0
    9694:	29 c0       	rjmp	.+82     	; 0x96e8 <_ZN14EthernetClient7connectE9IPAddressj+0x170>
  }

  while (status() != SnSR::ESTABLISHED) {
    delay(1);
    9696:	61 e0       	ldi	r22, 0x01	; 1
    9698:	70 e0       	ldi	r23, 0x00	; 0
    969a:	80 e0       	ldi	r24, 0x00	; 0
    969c:	90 e0       	ldi	r25, 0x00	; 0
    969e:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
    if (status() == SnSR::CLOSED) {
    96a2:	8c 81       	ldd	r24, Y+4	; 0x04
    96a4:	9d 81       	ldd	r25, Y+5	; 0x05
    96a6:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
    96aa:	98 2f       	mov	r25, r24
    96ac:	81 e0       	ldi	r24, 0x01	; 1
    96ae:	99 23       	and	r25, r25
    96b0:	09 f0       	breq	.+2      	; 0x96b4 <_ZN14EthernetClient7connectE9IPAddressj+0x13c>
    96b2:	80 e0       	ldi	r24, 0x00	; 0
    96b4:	88 23       	and	r24, r24
    96b6:	59 f0       	breq	.+22     	; 0x96ce <_ZN14EthernetClient7connectE9IPAddressj+0x156>
      _sock = MAX_SOCK_NUM;
    96b8:	8c 81       	ldd	r24, Y+4	; 0x04
    96ba:	9d 81       	ldd	r25, Y+5	; 0x05
    96bc:	24 e0       	ldi	r18, 0x04	; 4
    96be:	dc 01       	movw	r26, r24
    96c0:	1c 96       	adiw	r26, 0x0c	; 12
    96c2:	2c 93       	st	X, r18
    96c4:	1c 97       	sbiw	r26, 0x0c	; 12
      return 0;
    96c6:	80 e0       	ldi	r24, 0x00	; 0
    96c8:	90 e0       	ldi	r25, 0x00	; 0
    96ca:	0e c0       	rjmp	.+28     	; 0x96e8 <_ZN14EthernetClient7connectE9IPAddressj+0x170>
  if (!::connect(_sock, rawIPAddress(ip), port)) {
    _sock = MAX_SOCK_NUM;
    return 0;
  }

  while (status() != SnSR::ESTABLISHED) {
    96cc:	00 00       	nop
    96ce:	8c 81       	ldd	r24, Y+4	; 0x04
    96d0:	9d 81       	ldd	r25, Y+5	; 0x05
    96d2:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
    96d6:	98 2f       	mov	r25, r24
    96d8:	81 e0       	ldi	r24, 0x01	; 1
    96da:	97 31       	cpi	r25, 0x17	; 23
    96dc:	09 f4       	brne	.+2      	; 0x96e0 <_ZN14EthernetClient7connectE9IPAddressj+0x168>
    96de:	80 e0       	ldi	r24, 0x00	; 0
    96e0:	88 23       	and	r24, r24
    96e2:	c9 f6       	brne	.-78     	; 0x9696 <_ZN14EthernetClient7connectE9IPAddressj+0x11e>
      _sock = MAX_SOCK_NUM;
      return 0;
    }
  }

  return 1;
    96e4:	81 e0       	ldi	r24, 0x01	; 1
    96e6:	90 e0       	ldi	r25, 0x00	; 0
}
    96e8:	29 96       	adiw	r28, 0x09	; 9
    96ea:	0f b6       	in	r0, 0x3f	; 63
    96ec:	f8 94       	cli
    96ee:	de bf       	out	0x3e, r29	; 62
    96f0:	0f be       	out	0x3f, r0	; 63
    96f2:	cd bf       	out	0x3d, r28	; 61
    96f4:	df 91       	pop	r29
    96f6:	cf 91       	pop	r28
    96f8:	08 95       	ret

000096fa <_ZN14EthernetClient5writeEh>:

size_t EthernetClient::write(uint8_t b) {
    96fa:	cf 93       	push	r28
    96fc:	df 93       	push	r29
    96fe:	00 d0       	rcall	.+0      	; 0x9700 <_ZN14EthernetClient5writeEh+0x6>
    9700:	1f 92       	push	r1
    9702:	cd b7       	in	r28, 0x3d	; 61
    9704:	de b7       	in	r29, 0x3e	; 62
    9706:	9a 83       	std	Y+2, r25	; 0x02
    9708:	89 83       	std	Y+1, r24	; 0x01
    970a:	6b 83       	std	Y+3, r22	; 0x03
  return write(&b, 1);
    970c:	89 81       	ldd	r24, Y+1	; 0x01
    970e:	9a 81       	ldd	r25, Y+2	; 0x02
    9710:	fc 01       	movw	r30, r24
    9712:	80 81       	ld	r24, Z
    9714:	91 81       	ldd	r25, Z+1	; 0x01
    9716:	02 96       	adiw	r24, 0x02	; 2
    9718:	fc 01       	movw	r30, r24
    971a:	20 81       	ld	r18, Z
    971c:	31 81       	ldd	r19, Z+1	; 0x01
    971e:	be 01       	movw	r22, r28
    9720:	6d 5f       	subi	r22, 0xFD	; 253
    9722:	7f 4f       	sbci	r23, 0xFF	; 255
    9724:	89 81       	ldd	r24, Y+1	; 0x01
    9726:	9a 81       	ldd	r25, Y+2	; 0x02
    9728:	41 e0       	ldi	r20, 0x01	; 1
    972a:	50 e0       	ldi	r21, 0x00	; 0
    972c:	f9 01       	movw	r30, r18
    972e:	09 95       	icall
}
    9730:	0f 90       	pop	r0
    9732:	0f 90       	pop	r0
    9734:	0f 90       	pop	r0
    9736:	df 91       	pop	r29
    9738:	cf 91       	pop	r28
    973a:	08 95       	ret

0000973c <_ZN14EthernetClient5writeEPKhj>:

size_t EthernetClient::write(const uint8_t *buf, size_t size) {
    973c:	cf 93       	push	r28
    973e:	df 93       	push	r29
    9740:	00 d0       	rcall	.+0      	; 0x9742 <_ZN14EthernetClient5writeEPKhj+0x6>
    9742:	00 d0       	rcall	.+0      	; 0x9744 <_ZN14EthernetClient5writeEPKhj+0x8>
    9744:	00 d0       	rcall	.+0      	; 0x9746 <_ZN14EthernetClient5writeEPKhj+0xa>
    9746:	cd b7       	in	r28, 0x3d	; 61
    9748:	de b7       	in	r29, 0x3e	; 62
    974a:	9a 83       	std	Y+2, r25	; 0x02
    974c:	89 83       	std	Y+1, r24	; 0x01
    974e:	7c 83       	std	Y+4, r23	; 0x04
    9750:	6b 83       	std	Y+3, r22	; 0x03
    9752:	5e 83       	std	Y+6, r21	; 0x06
    9754:	4d 83       	std	Y+5, r20	; 0x05
  if (_sock == MAX_SOCK_NUM) {
    9756:	89 81       	ldd	r24, Y+1	; 0x01
    9758:	9a 81       	ldd	r25, Y+2	; 0x02
    975a:	dc 01       	movw	r26, r24
    975c:	1c 96       	adiw	r26, 0x0c	; 12
    975e:	8c 91       	ld	r24, X
    9760:	1c 97       	sbiw	r26, 0x0c	; 12
    9762:	84 30       	cpi	r24, 0x04	; 4
    9764:	49 f4       	brne	.+18     	; 0x9778 <_ZN14EthernetClient5writeEPKhj+0x3c>
    setWriteError();
    9766:	89 81       	ldd	r24, Y+1	; 0x01
    9768:	9a 81       	ldd	r25, Y+2	; 0x02
    976a:	61 e0       	ldi	r22, 0x01	; 1
    976c:	70 e0       	ldi	r23, 0x00	; 0
    976e:	0e 94 69 a5 	call	0x14ad2	; 0x14ad2 <_ZN5Print13setWriteErrorEi>
    return 0;
    9772:	80 e0       	ldi	r24, 0x00	; 0
    9774:	90 e0       	ldi	r25, 0x00	; 0
    9776:	1f c0       	rjmp	.+62     	; 0x97b6 <_ZN14EthernetClient5writeEPKhj+0x7a>
  }
  if (!send(_sock, buf, size)) {
    9778:	89 81       	ldd	r24, Y+1	; 0x01
    977a:	9a 81       	ldd	r25, Y+2	; 0x02
    977c:	dc 01       	movw	r26, r24
    977e:	1c 96       	adiw	r26, 0x0c	; 12
    9780:	ec 91       	ld	r30, X
    9782:	2d 81       	ldd	r18, Y+5	; 0x05
    9784:	3e 81       	ldd	r19, Y+6	; 0x06
    9786:	8b 81       	ldd	r24, Y+3	; 0x03
    9788:	9c 81       	ldd	r25, Y+4	; 0x04
    978a:	a9 01       	movw	r20, r18
    978c:	bc 01       	movw	r22, r24
    978e:	8e 2f       	mov	r24, r30
    9790:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <_Z4sendhPKhj>
    9794:	21 e0       	ldi	r18, 0x01	; 1
    9796:	00 97       	sbiw	r24, 0x00	; 0
    9798:	09 f0       	breq	.+2      	; 0x979c <_ZN14EthernetClient5writeEPKhj+0x60>
    979a:	20 e0       	ldi	r18, 0x00	; 0
    979c:	22 23       	and	r18, r18
    979e:	49 f0       	breq	.+18     	; 0x97b2 <_ZN14EthernetClient5writeEPKhj+0x76>
    setWriteError();
    97a0:	89 81       	ldd	r24, Y+1	; 0x01
    97a2:	9a 81       	ldd	r25, Y+2	; 0x02
    97a4:	61 e0       	ldi	r22, 0x01	; 1
    97a6:	70 e0       	ldi	r23, 0x00	; 0
    97a8:	0e 94 69 a5 	call	0x14ad2	; 0x14ad2 <_ZN5Print13setWriteErrorEi>
    return 0;
    97ac:	80 e0       	ldi	r24, 0x00	; 0
    97ae:	90 e0       	ldi	r25, 0x00	; 0
    97b0:	02 c0       	rjmp	.+4      	; 0x97b6 <_ZN14EthernetClient5writeEPKhj+0x7a>
  }
  return size;
    97b2:	8d 81       	ldd	r24, Y+5	; 0x05
    97b4:	9e 81       	ldd	r25, Y+6	; 0x06
}
    97b6:	26 96       	adiw	r28, 0x06	; 6
    97b8:	0f b6       	in	r0, 0x3f	; 63
    97ba:	f8 94       	cli
    97bc:	de bf       	out	0x3e, r29	; 62
    97be:	0f be       	out	0x3f, r0	; 63
    97c0:	cd bf       	out	0x3d, r28	; 61
    97c2:	df 91       	pop	r29
    97c4:	cf 91       	pop	r28
    97c6:	08 95       	ret

000097c8 <_ZN14EthernetClient9availableEv>:

int EthernetClient::available() {
    97c8:	cf 93       	push	r28
    97ca:	df 93       	push	r29
    97cc:	00 d0       	rcall	.+0      	; 0x97ce <_ZN14EthernetClient9availableEv+0x6>
    97ce:	cd b7       	in	r28, 0x3d	; 61
    97d0:	de b7       	in	r29, 0x3e	; 62
    97d2:	9a 83       	std	Y+2, r25	; 0x02
    97d4:	89 83       	std	Y+1, r24	; 0x01
  if (_sock != MAX_SOCK_NUM)
    97d6:	89 81       	ldd	r24, Y+1	; 0x01
    97d8:	9a 81       	ldd	r25, Y+2	; 0x02
    97da:	fc 01       	movw	r30, r24
    97dc:	84 85       	ldd	r24, Z+12	; 0x0c
    97de:	84 30       	cpi	r24, 0x04	; 4
    97e0:	51 f0       	breq	.+20     	; 0x97f6 <_ZN14EthernetClient9availableEv+0x2e>
    return W5100.getRXReceivedSize(_sock);
    97e2:	89 81       	ldd	r24, Y+1	; 0x01
    97e4:	9a 81       	ldd	r25, Y+2	; 0x02
    97e6:	fc 01       	movw	r30, r24
    97e8:	84 85       	ldd	r24, Z+12	; 0x0c
    97ea:	68 2f       	mov	r22, r24
    97ec:	8c e8       	ldi	r24, 0x8C	; 140
    97ee:	97 e0       	ldi	r25, 0x07	; 7
    97f0:	0e 94 9d 34 	call	0x693a	; 0x693a <_ZN10W5100Class17getRXReceivedSizeEh>
    97f4:	02 c0       	rjmp	.+4      	; 0x97fa <_ZN14EthernetClient9availableEv+0x32>
  return 0;
    97f6:	80 e0       	ldi	r24, 0x00	; 0
    97f8:	90 e0       	ldi	r25, 0x00	; 0
}
    97fa:	0f 90       	pop	r0
    97fc:	0f 90       	pop	r0
    97fe:	df 91       	pop	r29
    9800:	cf 91       	pop	r28
    9802:	08 95       	ret

00009804 <_ZN14EthernetClient4readEv>:

int EthernetClient::read() {
    9804:	cf 93       	push	r28
    9806:	df 93       	push	r29
    9808:	00 d0       	rcall	.+0      	; 0x980a <_ZN14EthernetClient4readEv+0x6>
    980a:	1f 92       	push	r1
    980c:	cd b7       	in	r28, 0x3d	; 61
    980e:	de b7       	in	r29, 0x3e	; 62
    9810:	9b 83       	std	Y+3, r25	; 0x03
    9812:	8a 83       	std	Y+2, r24	; 0x02
  uint8_t b;
  if ( recv(_sock, &b, 1) > 0 )
    9814:	8a 81       	ldd	r24, Y+2	; 0x02
    9816:	9b 81       	ldd	r25, Y+3	; 0x03
    9818:	fc 01       	movw	r30, r24
    981a:	24 85       	ldd	r18, Z+12	; 0x0c
    981c:	41 e0       	ldi	r20, 0x01	; 1
    981e:	50 e0       	ldi	r21, 0x00	; 0
    9820:	ce 01       	movw	r24, r28
    9822:	01 96       	adiw	r24, 0x01	; 1
    9824:	bc 01       	movw	r22, r24
    9826:	82 2f       	mov	r24, r18
    9828:	0e 94 78 30 	call	0x60f0	; 0x60f0 <_Z4recvhPhi>
    982c:	21 e0       	ldi	r18, 0x01	; 1
    982e:	18 16       	cp	r1, r24
    9830:	19 06       	cpc	r1, r25
    9832:	0c f0       	brlt	.+2      	; 0x9836 <_ZN14EthernetClient4readEv+0x32>
    9834:	20 e0       	ldi	r18, 0x00	; 0
    9836:	22 23       	and	r18, r18
    9838:	21 f0       	breq	.+8      	; 0x9842 <_ZN14EthernetClient4readEv+0x3e>
  {
    // recv worked
    return b;
    983a:	89 81       	ldd	r24, Y+1	; 0x01
    983c:	88 2f       	mov	r24, r24
    983e:	90 e0       	ldi	r25, 0x00	; 0
    9840:	02 c0       	rjmp	.+4      	; 0x9846 <_ZN14EthernetClient4readEv+0x42>
  }
  else
  {
    // No data available
    return -1;
    9842:	8f ef       	ldi	r24, 0xFF	; 255
    9844:	9f ef       	ldi	r25, 0xFF	; 255
  }
}
    9846:	0f 90       	pop	r0
    9848:	0f 90       	pop	r0
    984a:	0f 90       	pop	r0
    984c:	df 91       	pop	r29
    984e:	cf 91       	pop	r28
    9850:	08 95       	ret

00009852 <_ZN14EthernetClient4readEPhj>:

int EthernetClient::read(uint8_t *buf, size_t size) {
    9852:	cf 93       	push	r28
    9854:	df 93       	push	r29
    9856:	00 d0       	rcall	.+0      	; 0x9858 <_ZN14EthernetClient4readEPhj+0x6>
    9858:	00 d0       	rcall	.+0      	; 0x985a <_ZN14EthernetClient4readEPhj+0x8>
    985a:	00 d0       	rcall	.+0      	; 0x985c <_ZN14EthernetClient4readEPhj+0xa>
    985c:	cd b7       	in	r28, 0x3d	; 61
    985e:	de b7       	in	r29, 0x3e	; 62
    9860:	9a 83       	std	Y+2, r25	; 0x02
    9862:	89 83       	std	Y+1, r24	; 0x01
    9864:	7c 83       	std	Y+4, r23	; 0x04
    9866:	6b 83       	std	Y+3, r22	; 0x03
    9868:	5e 83       	std	Y+6, r21	; 0x06
    986a:	4d 83       	std	Y+5, r20	; 0x05
  return recv(_sock, buf, size);
    986c:	2d 81       	ldd	r18, Y+5	; 0x05
    986e:	3e 81       	ldd	r19, Y+6	; 0x06
    9870:	89 81       	ldd	r24, Y+1	; 0x01
    9872:	9a 81       	ldd	r25, Y+2	; 0x02
    9874:	dc 01       	movw	r26, r24
    9876:	1c 96       	adiw	r26, 0x0c	; 12
    9878:	ec 91       	ld	r30, X
    987a:	8b 81       	ldd	r24, Y+3	; 0x03
    987c:	9c 81       	ldd	r25, Y+4	; 0x04
    987e:	a9 01       	movw	r20, r18
    9880:	bc 01       	movw	r22, r24
    9882:	8e 2f       	mov	r24, r30
    9884:	0e 94 78 30 	call	0x60f0	; 0x60f0 <_Z4recvhPhi>
}
    9888:	26 96       	adiw	r28, 0x06	; 6
    988a:	0f b6       	in	r0, 0x3f	; 63
    988c:	f8 94       	cli
    988e:	de bf       	out	0x3e, r29	; 62
    9890:	0f be       	out	0x3f, r0	; 63
    9892:	cd bf       	out	0x3d, r28	; 61
    9894:	df 91       	pop	r29
    9896:	cf 91       	pop	r28
    9898:	08 95       	ret

0000989a <_ZN14EthernetClient4peekEv>:

int EthernetClient::peek() {
    989a:	cf 93       	push	r28
    989c:	df 93       	push	r29
    989e:	00 d0       	rcall	.+0      	; 0x98a0 <_ZN14EthernetClient4peekEv+0x6>
    98a0:	1f 92       	push	r1
    98a2:	cd b7       	in	r28, 0x3d	; 61
    98a4:	de b7       	in	r29, 0x3e	; 62
    98a6:	9b 83       	std	Y+3, r25	; 0x03
    98a8:	8a 83       	std	Y+2, r24	; 0x02
  uint8_t b;
  // Unlike recv, peek doesn't check to see if there's any data available, so we must
  if (!available())
    98aa:	8a 81       	ldd	r24, Y+2	; 0x02
    98ac:	9b 81       	ldd	r25, Y+3	; 0x03
    98ae:	fc 01       	movw	r30, r24
    98b0:	80 81       	ld	r24, Z
    98b2:	91 81       	ldd	r25, Z+1	; 0x01
    98b4:	04 96       	adiw	r24, 0x04	; 4
    98b6:	fc 01       	movw	r30, r24
    98b8:	20 81       	ld	r18, Z
    98ba:	31 81       	ldd	r19, Z+1	; 0x01
    98bc:	8a 81       	ldd	r24, Y+2	; 0x02
    98be:	9b 81       	ldd	r25, Y+3	; 0x03
    98c0:	f9 01       	movw	r30, r18
    98c2:	09 95       	icall
    98c4:	21 e0       	ldi	r18, 0x01	; 1
    98c6:	00 97       	sbiw	r24, 0x00	; 0
    98c8:	09 f0       	breq	.+2      	; 0x98cc <_ZN14EthernetClient4peekEv+0x32>
    98ca:	20 e0       	ldi	r18, 0x00	; 0
    98cc:	22 23       	and	r18, r18
    98ce:	19 f0       	breq	.+6      	; 0x98d6 <_ZN14EthernetClient4peekEv+0x3c>
    return -1;
    98d0:	8f ef       	ldi	r24, 0xFF	; 255
    98d2:	9f ef       	ldi	r25, 0xFF	; 255
    98d4:	0d c0       	rjmp	.+26     	; 0x98f0 <_ZN14EthernetClient4peekEv+0x56>
  ::peek(_sock, &b);
    98d6:	8a 81       	ldd	r24, Y+2	; 0x02
    98d8:	9b 81       	ldd	r25, Y+3	; 0x03
    98da:	fc 01       	movw	r30, r24
    98dc:	24 85       	ldd	r18, Z+12	; 0x0c
    98de:	ce 01       	movw	r24, r28
    98e0:	01 96       	adiw	r24, 0x01	; 1
    98e2:	bc 01       	movw	r22, r24
    98e4:	82 2f       	mov	r24, r18
    98e6:	0e 94 d5 30 	call	0x61aa	; 0x61aa <_Z4peekhPh>
  return b;
    98ea:	89 81       	ldd	r24, Y+1	; 0x01
    98ec:	88 2f       	mov	r24, r24
    98ee:	90 e0       	ldi	r25, 0x00	; 0
}
    98f0:	0f 90       	pop	r0
    98f2:	0f 90       	pop	r0
    98f4:	0f 90       	pop	r0
    98f6:	df 91       	pop	r29
    98f8:	cf 91       	pop	r28
    98fa:	08 95       	ret

000098fc <_ZN14EthernetClient5flushEv>:

void EthernetClient::flush() {
    98fc:	cf 93       	push	r28
    98fe:	df 93       	push	r29
    9900:	00 d0       	rcall	.+0      	; 0x9902 <_ZN14EthernetClient5flushEv+0x6>
    9902:	cd b7       	in	r28, 0x3d	; 61
    9904:	de b7       	in	r29, 0x3e	; 62
    9906:	9a 83       	std	Y+2, r25	; 0x02
    9908:	89 83       	std	Y+1, r24	; 0x01
  while (available())
    990a:	0d c0       	rjmp	.+26     	; 0x9926 <_ZN14EthernetClient5flushEv+0x2a>
    read();
    990c:	89 81       	ldd	r24, Y+1	; 0x01
    990e:	9a 81       	ldd	r25, Y+2	; 0x02
    9910:	fc 01       	movw	r30, r24
    9912:	80 81       	ld	r24, Z
    9914:	91 81       	ldd	r25, Z+1	; 0x01
    9916:	06 96       	adiw	r24, 0x06	; 6
    9918:	fc 01       	movw	r30, r24
    991a:	20 81       	ld	r18, Z
    991c:	31 81       	ldd	r19, Z+1	; 0x01
    991e:	89 81       	ldd	r24, Y+1	; 0x01
    9920:	9a 81       	ldd	r25, Y+2	; 0x02
    9922:	f9 01       	movw	r30, r18
    9924:	09 95       	icall
  ::peek(_sock, &b);
  return b;
}

void EthernetClient::flush() {
  while (available())
    9926:	89 81       	ldd	r24, Y+1	; 0x01
    9928:	9a 81       	ldd	r25, Y+2	; 0x02
    992a:	fc 01       	movw	r30, r24
    992c:	80 81       	ld	r24, Z
    992e:	91 81       	ldd	r25, Z+1	; 0x01
    9930:	04 96       	adiw	r24, 0x04	; 4
    9932:	fc 01       	movw	r30, r24
    9934:	20 81       	ld	r18, Z
    9936:	31 81       	ldd	r19, Z+1	; 0x01
    9938:	89 81       	ldd	r24, Y+1	; 0x01
    993a:	9a 81       	ldd	r25, Y+2	; 0x02
    993c:	f9 01       	movw	r30, r18
    993e:	09 95       	icall
    9940:	21 e0       	ldi	r18, 0x01	; 1
    9942:	00 97       	sbiw	r24, 0x00	; 0
    9944:	09 f4       	brne	.+2      	; 0x9948 <_ZN14EthernetClient5flushEv+0x4c>
    9946:	20 e0       	ldi	r18, 0x00	; 0
    9948:	22 23       	and	r18, r18
    994a:	01 f7       	brne	.-64     	; 0x990c <_ZN14EthernetClient5flushEv+0x10>
    read();
}
    994c:	0f 90       	pop	r0
    994e:	0f 90       	pop	r0
    9950:	df 91       	pop	r29
    9952:	cf 91       	pop	r28
    9954:	08 95       	ret

00009956 <_ZN14EthernetClient4stopEv>:

void EthernetClient::stop() {
    9956:	ef 92       	push	r14
    9958:	ff 92       	push	r15
    995a:	0f 93       	push	r16
    995c:	1f 93       	push	r17
    995e:	cf 93       	push	r28
    9960:	df 93       	push	r29
    9962:	00 d0       	rcall	.+0      	; 0x9964 <_ZN14EthernetClient4stopEv+0xe>
    9964:	00 d0       	rcall	.+0      	; 0x9966 <_ZN14EthernetClient4stopEv+0x10>
    9966:	00 d0       	rcall	.+0      	; 0x9968 <_ZN14EthernetClient4stopEv+0x12>
    9968:	cd b7       	in	r28, 0x3d	; 61
    996a:	de b7       	in	r29, 0x3e	; 62
    996c:	9e 83       	std	Y+6, r25	; 0x06
    996e:	8d 83       	std	Y+5, r24	; 0x05
  if (_sock == MAX_SOCK_NUM)
    9970:	8d 81       	ldd	r24, Y+5	; 0x05
    9972:	9e 81       	ldd	r25, Y+6	; 0x06
    9974:	fc 01       	movw	r30, r24
    9976:	84 85       	ldd	r24, Z+12	; 0x0c
    9978:	84 30       	cpi	r24, 0x04	; 4
    997a:	09 f4       	brne	.+2      	; 0x997e <_ZN14EthernetClient4stopEv+0x28>
    997c:	5a c0       	rjmp	.+180    	; 0x9a32 <_ZN14EthernetClient4stopEv+0xdc>
    return;

  // attempt to close the connection gracefully (send a FIN to other side)
  disconnect(_sock);
    997e:	8d 81       	ldd	r24, Y+5	; 0x05
    9980:	9e 81       	ldd	r25, Y+6	; 0x06
    9982:	fc 01       	movw	r30, r24
    9984:	84 85       	ldd	r24, Z+12	; 0x0c
    9986:	0e 94 e9 2f 	call	0x5fd2	; 0x5fd2 <_Z10disconnecth>
  unsigned long start = millis();
    998a:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    998e:	dc 01       	movw	r26, r24
    9990:	cb 01       	movw	r24, r22
    9992:	89 83       	std	Y+1, r24	; 0x01
    9994:	9a 83       	std	Y+2, r25	; 0x02
    9996:	ab 83       	std	Y+3, r26	; 0x03
    9998:	bc 83       	std	Y+4, r27	; 0x04

  // wait a second for the connection to close
  while (status() != SnSR::CLOSED && millis() - start < 1000)
    999a:	06 c0       	rjmp	.+12     	; 0x99a8 <_ZN14EthernetClient4stopEv+0x52>
    delay(1);
    999c:	61 e0       	ldi	r22, 0x01	; 1
    999e:	70 e0       	ldi	r23, 0x00	; 0
    99a0:	80 e0       	ldi	r24, 0x00	; 0
    99a2:	90 e0       	ldi	r25, 0x00	; 0
    99a4:	0e 94 49 7e 	call	0xfc92	; 0xfc92 <delay>
  // attempt to close the connection gracefully (send a FIN to other side)
  disconnect(_sock);
  unsigned long start = millis();

  // wait a second for the connection to close
  while (status() != SnSR::CLOSED && millis() - start < 1000)
    99a8:	8d 81       	ldd	r24, Y+5	; 0x05
    99aa:	9e 81       	ldd	r25, Y+6	; 0x06
    99ac:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
    99b0:	88 23       	and	r24, r24
    99b2:	c1 f0       	breq	.+48     	; 0x99e4 <_ZN14EthernetClient4stopEv+0x8e>
    99b4:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    99b8:	9b 01       	movw	r18, r22
    99ba:	ac 01       	movw	r20, r24
    99bc:	89 81       	ldd	r24, Y+1	; 0x01
    99be:	9a 81       	ldd	r25, Y+2	; 0x02
    99c0:	ab 81       	ldd	r26, Y+3	; 0x03
    99c2:	bc 81       	ldd	r27, Y+4	; 0x04
    99c4:	79 01       	movw	r14, r18
    99c6:	8a 01       	movw	r16, r20
    99c8:	e8 1a       	sub	r14, r24
    99ca:	f9 0a       	sbc	r15, r25
    99cc:	0a 0b       	sbc	r16, r26
    99ce:	1b 0b       	sbc	r17, r27
    99d0:	d8 01       	movw	r26, r16
    99d2:	c7 01       	movw	r24, r14
    99d4:	88 3e       	cpi	r24, 0xE8	; 232
    99d6:	03 e0       	ldi	r16, 0x03	; 3
    99d8:	90 07       	cpc	r25, r16
    99da:	a1 05       	cpc	r26, r1
    99dc:	b1 05       	cpc	r27, r1
    99de:	10 f4       	brcc	.+4      	; 0x99e4 <_ZN14EthernetClient4stopEv+0x8e>
    99e0:	81 e0       	ldi	r24, 0x01	; 1
    99e2:	01 c0       	rjmp	.+2      	; 0x99e6 <_ZN14EthernetClient4stopEv+0x90>
    99e4:	80 e0       	ldi	r24, 0x00	; 0
    99e6:	88 23       	and	r24, r24
    99e8:	c9 f6       	brne	.-78     	; 0x999c <_ZN14EthernetClient4stopEv+0x46>
    delay(1);

  // if it hasn't closed, close it forcefully
  if (status() != SnSR::CLOSED)
    99ea:	8d 81       	ldd	r24, Y+5	; 0x05
    99ec:	9e 81       	ldd	r25, Y+6	; 0x06
    99ee:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
    99f2:	98 2f       	mov	r25, r24
    99f4:	81 e0       	ldi	r24, 0x01	; 1
    99f6:	99 23       	and	r25, r25
    99f8:	09 f4       	brne	.+2      	; 0x99fc <_ZN14EthernetClient4stopEv+0xa6>
    99fa:	80 e0       	ldi	r24, 0x00	; 0
    99fc:	88 23       	and	r24, r24
    99fe:	31 f0       	breq	.+12     	; 0x9a0c <_ZN14EthernetClient4stopEv+0xb6>
    close(_sock);
    9a00:	8d 81       	ldd	r24, Y+5	; 0x05
    9a02:	9e 81       	ldd	r25, Y+6	; 0x06
    9a04:	fc 01       	movw	r30, r24
    9a06:	84 85       	ldd	r24, Z+12	; 0x0c
    9a08:	0e 94 55 2f 	call	0x5eaa	; 0x5eaa <_Z5closeh>

  EthernetClass::_server_port[_sock] = 0;
    9a0c:	8d 81       	ldd	r24, Y+5	; 0x05
    9a0e:	9e 81       	ldd	r25, Y+6	; 0x06
    9a10:	fc 01       	movw	r30, r24
    9a12:	84 85       	ldd	r24, Z+12	; 0x0c
    9a14:	88 2f       	mov	r24, r24
    9a16:	90 e0       	ldi	r25, 0x00	; 0
    9a18:	88 0f       	add	r24, r24
    9a1a:	99 1f       	adc	r25, r25
    9a1c:	84 55       	subi	r24, 0x54	; 84
    9a1e:	98 4f       	sbci	r25, 0xF8	; 248
    9a20:	fc 01       	movw	r30, r24
    9a22:	11 82       	std	Z+1, r1	; 0x01
    9a24:	10 82       	st	Z, r1
  _sock = MAX_SOCK_NUM;
    9a26:	8d 81       	ldd	r24, Y+5	; 0x05
    9a28:	9e 81       	ldd	r25, Y+6	; 0x06
    9a2a:	24 e0       	ldi	r18, 0x04	; 4
    9a2c:	fc 01       	movw	r30, r24
    9a2e:	24 87       	std	Z+12, r18	; 0x0c
    9a30:	01 c0       	rjmp	.+2      	; 0x9a34 <_ZN14EthernetClient4stopEv+0xde>
    read();
}

void EthernetClient::stop() {
  if (_sock == MAX_SOCK_NUM)
    return;
    9a32:	00 00       	nop
  if (status() != SnSR::CLOSED)
    close(_sock);

  EthernetClass::_server_port[_sock] = 0;
  _sock = MAX_SOCK_NUM;
}
    9a34:	26 96       	adiw	r28, 0x06	; 6
    9a36:	0f b6       	in	r0, 0x3f	; 63
    9a38:	f8 94       	cli
    9a3a:	de bf       	out	0x3e, r29	; 62
    9a3c:	0f be       	out	0x3f, r0	; 63
    9a3e:	cd bf       	out	0x3d, r28	; 61
    9a40:	df 91       	pop	r29
    9a42:	cf 91       	pop	r28
    9a44:	1f 91       	pop	r17
    9a46:	0f 91       	pop	r16
    9a48:	ff 90       	pop	r15
    9a4a:	ef 90       	pop	r14
    9a4c:	08 95       	ret

00009a4e <_ZN14EthernetClient9connectedEv>:

uint8_t EthernetClient::connected() {
    9a4e:	cf 93       	push	r28
    9a50:	df 93       	push	r29
    9a52:	00 d0       	rcall	.+0      	; 0x9a54 <_ZN14EthernetClient9connectedEv+0x6>
    9a54:	1f 92       	push	r1
    9a56:	cd b7       	in	r28, 0x3d	; 61
    9a58:	de b7       	in	r29, 0x3e	; 62
    9a5a:	9b 83       	std	Y+3, r25	; 0x03
    9a5c:	8a 83       	std	Y+2, r24	; 0x02
  if (_sock == MAX_SOCK_NUM) return 0;
    9a5e:	8a 81       	ldd	r24, Y+2	; 0x02
    9a60:	9b 81       	ldd	r25, Y+3	; 0x03
    9a62:	fc 01       	movw	r30, r24
    9a64:	84 85       	ldd	r24, Z+12	; 0x0c
    9a66:	84 30       	cpi	r24, 0x04	; 4
    9a68:	11 f4       	brne	.+4      	; 0x9a6e <_ZN14EthernetClient9connectedEv+0x20>
    9a6a:	80 e0       	ldi	r24, 0x00	; 0
    9a6c:	23 c0       	rjmp	.+70     	; 0x9ab4 <_ZN14EthernetClient9connectedEv+0x66>
  
  uint8_t s = status();
    9a6e:	8a 81       	ldd	r24, Y+2	; 0x02
    9a70:	9b 81       	ldd	r25, Y+3	; 0x03
    9a72:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
    9a76:	89 83       	std	Y+1, r24	; 0x01
  return !(s == SnSR::LISTEN || s == SnSR::CLOSED || s == SnSR::FIN_WAIT ||
    (s == SnSR::CLOSE_WAIT && !available()));
    9a78:	89 81       	ldd	r24, Y+1	; 0x01
    9a7a:	84 31       	cpi	r24, 0x14	; 20
    9a7c:	d1 f0       	breq	.+52     	; 0x9ab2 <_ZN14EthernetClient9connectedEv+0x64>
    9a7e:	89 81       	ldd	r24, Y+1	; 0x01
    9a80:	88 23       	and	r24, r24
    9a82:	b9 f0       	breq	.+46     	; 0x9ab2 <_ZN14EthernetClient9connectedEv+0x64>
    9a84:	89 81       	ldd	r24, Y+1	; 0x01
    9a86:	88 31       	cpi	r24, 0x18	; 24
    9a88:	a1 f0       	breq	.+40     	; 0x9ab2 <_ZN14EthernetClient9connectedEv+0x64>
    9a8a:	89 81       	ldd	r24, Y+1	; 0x01
    9a8c:	8c 31       	cpi	r24, 0x1C	; 28
    9a8e:	79 f4       	brne	.+30     	; 0x9aae <_ZN14EthernetClient9connectedEv+0x60>
    9a90:	8a 81       	ldd	r24, Y+2	; 0x02
    9a92:	9b 81       	ldd	r25, Y+3	; 0x03
    9a94:	fc 01       	movw	r30, r24
    9a96:	80 81       	ld	r24, Z
    9a98:	91 81       	ldd	r25, Z+1	; 0x01
    9a9a:	04 96       	adiw	r24, 0x04	; 4
    9a9c:	fc 01       	movw	r30, r24
    9a9e:	20 81       	ld	r18, Z
    9aa0:	31 81       	ldd	r19, Z+1	; 0x01
    9aa2:	8a 81       	ldd	r24, Y+2	; 0x02
    9aa4:	9b 81       	ldd	r25, Y+3	; 0x03
    9aa6:	f9 01       	movw	r30, r18
    9aa8:	09 95       	icall
    9aaa:	00 97       	sbiw	r24, 0x00	; 0
    9aac:	11 f0       	breq	.+4      	; 0x9ab2 <_ZN14EthernetClient9connectedEv+0x64>
    9aae:	81 e0       	ldi	r24, 0x01	; 1
    9ab0:	01 c0       	rjmp	.+2      	; 0x9ab4 <_ZN14EthernetClient9connectedEv+0x66>
    9ab2:	80 e0       	ldi	r24, 0x00	; 0
}
    9ab4:	0f 90       	pop	r0
    9ab6:	0f 90       	pop	r0
    9ab8:	0f 90       	pop	r0
    9aba:	df 91       	pop	r29
    9abc:	cf 91       	pop	r28
    9abe:	08 95       	ret

00009ac0 <_ZN14EthernetClient6statusEv>:

uint8_t EthernetClient::status() {
    9ac0:	cf 93       	push	r28
    9ac2:	df 93       	push	r29
    9ac4:	00 d0       	rcall	.+0      	; 0x9ac6 <_ZN14EthernetClient6statusEv+0x6>
    9ac6:	cd b7       	in	r28, 0x3d	; 61
    9ac8:	de b7       	in	r29, 0x3e	; 62
    9aca:	9a 83       	std	Y+2, r25	; 0x02
    9acc:	89 83       	std	Y+1, r24	; 0x01
  if (_sock == MAX_SOCK_NUM) return SnSR::CLOSED;
    9ace:	89 81       	ldd	r24, Y+1	; 0x01
    9ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    9ad2:	fc 01       	movw	r30, r24
    9ad4:	84 85       	ldd	r24, Z+12	; 0x0c
    9ad6:	84 30       	cpi	r24, 0x04	; 4
    9ad8:	11 f4       	brne	.+4      	; 0x9ade <_ZN14EthernetClient6statusEv+0x1e>
    9ada:	80 e0       	ldi	r24, 0x00	; 0
    9adc:	06 c0       	rjmp	.+12     	; 0x9aea <_ZN14EthernetClient6statusEv+0x2a>
  return W5100.readSnSR(_sock);
    9ade:	89 81       	ldd	r24, Y+1	; 0x01
    9ae0:	9a 81       	ldd	r25, Y+2	; 0x02
    9ae2:	fc 01       	movw	r30, r24
    9ae4:	84 85       	ldd	r24, Z+12	; 0x0c
    9ae6:	0e 94 86 a7 	call	0x14f0c	; 0x14f0c <_ZN10W5100Class8readSnSREh>
}
    9aea:	0f 90       	pop	r0
    9aec:	0f 90       	pop	r0
    9aee:	df 91       	pop	r29
    9af0:	cf 91       	pop	r28
    9af2:	08 95       	ret

00009af4 <_ZN14EthernetClientcvbEv>:

// the next function allows us to use the client returned by
// EthernetServer::available() as the condition in an if-statement.

EthernetClient::operator bool() {
    9af4:	cf 93       	push	r28
    9af6:	df 93       	push	r29
    9af8:	00 d0       	rcall	.+0      	; 0x9afa <_ZN14EthernetClientcvbEv+0x6>
    9afa:	cd b7       	in	r28, 0x3d	; 61
    9afc:	de b7       	in	r29, 0x3e	; 62
    9afe:	9a 83       	std	Y+2, r25	; 0x02
    9b00:	89 83       	std	Y+1, r24	; 0x01
  return _sock != MAX_SOCK_NUM;
    9b02:	89 81       	ldd	r24, Y+1	; 0x01
    9b04:	9a 81       	ldd	r25, Y+2	; 0x02
    9b06:	fc 01       	movw	r30, r24
    9b08:	94 85       	ldd	r25, Z+12	; 0x0c
    9b0a:	81 e0       	ldi	r24, 0x01	; 1
    9b0c:	94 30       	cpi	r25, 0x04	; 4
    9b0e:	09 f4       	brne	.+2      	; 0x9b12 <_ZN14EthernetClientcvbEv+0x1e>
    9b10:	80 e0       	ldi	r24, 0x00	; 0
}
    9b12:	0f 90       	pop	r0
    9b14:	0f 90       	pop	r0
    9b16:	df 91       	pop	r29
    9b18:	cf 91       	pop	r28
    9b1a:	08 95       	ret

00009b1c <_Z41__static_initialization_and_destruction_0ii>:
    9b1c:	0f 93       	push	r16
    9b1e:	cf 93       	push	r28
    9b20:	df 93       	push	r29
    9b22:	00 d0       	rcall	.+0      	; 0x9b24 <_Z41__static_initialization_and_destruction_0ii+0x8>
    9b24:	00 d0       	rcall	.+0      	; 0x9b26 <_Z41__static_initialization_and_destruction_0ii+0xa>
    9b26:	cd b7       	in	r28, 0x3d	; 61
    9b28:	de b7       	in	r29, 0x3e	; 62
    9b2a:	9a 83       	std	Y+2, r25	; 0x02
    9b2c:	89 83       	std	Y+1, r24	; 0x01
    9b2e:	7c 83       	std	Y+4, r23	; 0x04
    9b30:	6b 83       	std	Y+3, r22	; 0x03
    9b32:	89 81       	ldd	r24, Y+1	; 0x01
    9b34:	9a 81       	ldd	r25, Y+2	; 0x02
    9b36:	81 30       	cpi	r24, 0x01	; 1
    9b38:	91 05       	cpc	r25, r1
    9b3a:	71 f4       	brne	.+28     	; 0x9b58 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    9b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    9b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    9b40:	8f 3f       	cpi	r24, 0xFF	; 255
    9b42:	2f ef       	ldi	r18, 0xFF	; 255
    9b44:	92 07       	cpc	r25, r18
    9b46:	41 f4       	brne	.+16     	; 0x9b58 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    9b48:	00 e0       	ldi	r16, 0x00	; 0
    9b4a:	20 e0       	ldi	r18, 0x00	; 0
    9b4c:	40 e0       	ldi	r20, 0x00	; 0
    9b4e:	60 e0       	ldi	r22, 0x00	; 0
    9b50:	8c e2       	ldi	r24, 0x2C	; 44
    9b52:	98 e0       	ldi	r25, 0x08	; 8
    9b54:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    9b58:	0f 90       	pop	r0
    9b5a:	0f 90       	pop	r0
    9b5c:	0f 90       	pop	r0
    9b5e:	0f 90       	pop	r0
    9b60:	df 91       	pop	r29
    9b62:	cf 91       	pop	r28
    9b64:	0f 91       	pop	r16
    9b66:	08 95       	ret

00009b68 <_GLOBAL__sub_I__ZN14EthernetClient8_srcportE>:
    9b68:	cf 93       	push	r28
    9b6a:	df 93       	push	r29
    9b6c:	cd b7       	in	r28, 0x3d	; 61
    9b6e:	de b7       	in	r29, 0x3e	; 62
    9b70:	6f ef       	ldi	r22, 0xFF	; 255
    9b72:	7f ef       	ldi	r23, 0xFF	; 255
    9b74:	81 e0       	ldi	r24, 0x01	; 1
    9b76:	90 e0       	ldi	r25, 0x00	; 0
    9b78:	0e 94 8e 4d 	call	0x9b1c	; 0x9b1c <_Z41__static_initialization_and_destruction_0ii>
    9b7c:	df 91       	pop	r29
    9b7e:	cf 91       	pop	r28
    9b80:	08 95       	ret

00009b82 <_ZN14EthernetServerC1Ej>:

#include "Ethernet.h"
#include "EthernetClient.h"
#include "EthernetServer.h"

EthernetServer::EthernetServer(uint16_t port)
    9b82:	cf 93       	push	r28
    9b84:	df 93       	push	r29
    9b86:	00 d0       	rcall	.+0      	; 0x9b88 <_ZN14EthernetServerC1Ej+0x6>
    9b88:	00 d0       	rcall	.+0      	; 0x9b8a <_ZN14EthernetServerC1Ej+0x8>
    9b8a:	cd b7       	in	r28, 0x3d	; 61
    9b8c:	de b7       	in	r29, 0x3e	; 62
    9b8e:	9a 83       	std	Y+2, r25	; 0x02
    9b90:	89 83       	std	Y+1, r24	; 0x01
    9b92:	7c 83       	std	Y+4, r23	; 0x04
    9b94:	6b 83       	std	Y+3, r22	; 0x03
    9b96:	89 81       	ldd	r24, Y+1	; 0x01
    9b98:	9a 81       	ldd	r25, Y+2	; 0x02
    9b9a:	0e 94 2d a6 	call	0x14c5a	; 0x14c5a <_ZN6ServerC1Ev>
    9b9e:	89 81       	ldd	r24, Y+1	; 0x01
    9ba0:	9a 81       	ldd	r25, Y+2	; 0x02
    9ba2:	29 e5       	ldi	r18, 0x59	; 89
    9ba4:	35 e0       	ldi	r19, 0x05	; 5
    9ba6:	fc 01       	movw	r30, r24
    9ba8:	31 83       	std	Z+1, r19	; 0x01
    9baa:	20 83       	st	Z, r18
{
  _port = port;
    9bac:	89 81       	ldd	r24, Y+1	; 0x01
    9bae:	9a 81       	ldd	r25, Y+2	; 0x02
    9bb0:	2b 81       	ldd	r18, Y+3	; 0x03
    9bb2:	3c 81       	ldd	r19, Y+4	; 0x04
    9bb4:	fc 01       	movw	r30, r24
    9bb6:	35 83       	std	Z+5, r19	; 0x05
    9bb8:	24 83       	std	Z+4, r18	; 0x04
}
    9bba:	0f 90       	pop	r0
    9bbc:	0f 90       	pop	r0
    9bbe:	0f 90       	pop	r0
    9bc0:	0f 90       	pop	r0
    9bc2:	df 91       	pop	r29
    9bc4:	cf 91       	pop	r28
    9bc6:	08 95       	ret

00009bc8 <_ZN14EthernetServer5beginEv>:

void EthernetServer::begin()
{
    9bc8:	cf 93       	push	r28
    9bca:	df 93       	push	r29
    9bcc:	cd b7       	in	r28, 0x3d	; 61
    9bce:	de b7       	in	r29, 0x3e	; 62
    9bd0:	61 97       	sbiw	r28, 0x11	; 17
    9bd2:	0f b6       	in	r0, 0x3f	; 63
    9bd4:	f8 94       	cli
    9bd6:	de bf       	out	0x3e, r29	; 62
    9bd8:	0f be       	out	0x3f, r0	; 63
    9bda:	cd bf       	out	0x3d, r28	; 61
    9bdc:	99 8b       	std	Y+17, r25	; 0x11
    9bde:	88 8b       	std	Y+16, r24	; 0x10
  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    9be0:	1a 82       	std	Y+2, r1	; 0x02
    9be2:	19 82       	std	Y+1, r1	; 0x01
    9be4:	34 c0       	rjmp	.+104    	; 0x9c4e <_ZN14EthernetServer5beginEv+0x86>
    EthernetClient client(sock);
    9be6:	29 81       	ldd	r18, Y+1	; 0x01
    9be8:	ce 01       	movw	r24, r28
    9bea:	03 96       	adiw	r24, 0x03	; 3
    9bec:	62 2f       	mov	r22, r18
    9bee:	0e 94 39 4a 	call	0x9472	; 0x9472 <_ZN14EthernetClientC1Eh>
    if (client.status() == SnSR::CLOSED) {
    9bf2:	ce 01       	movw	r24, r28
    9bf4:	03 96       	adiw	r24, 0x03	; 3
    9bf6:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
    9bfa:	98 2f       	mov	r25, r24
    9bfc:	81 e0       	ldi	r24, 0x01	; 1
    9bfe:	99 23       	and	r25, r25
    9c00:	09 f0       	breq	.+2      	; 0x9c04 <_ZN14EthernetServer5beginEv+0x3c>
    9c02:	80 e0       	ldi	r24, 0x00	; 0
    9c04:	88 23       	and	r24, r24
    9c06:	f1 f0       	breq	.+60     	; 0x9c44 <_ZN14EthernetServer5beginEv+0x7c>
      socket(sock, SnMR::TCP, _port, 0);
    9c08:	88 89       	ldd	r24, Y+16	; 0x10
    9c0a:	99 89       	ldd	r25, Y+17	; 0x11
    9c0c:	fc 01       	movw	r30, r24
    9c0e:	84 81       	ldd	r24, Z+4	; 0x04
    9c10:	95 81       	ldd	r25, Z+5	; 0x05
    9c12:	39 81       	ldd	r19, Y+1	; 0x01
    9c14:	20 e0       	ldi	r18, 0x00	; 0
    9c16:	ac 01       	movw	r20, r24
    9c18:	61 e0       	ldi	r22, 0x01	; 1
    9c1a:	83 2f       	mov	r24, r19
    9c1c:	0e 94 03 2f 	call	0x5e06	; 0x5e06 <_Z6sockethhjh>
      listen(sock);
    9c20:	89 81       	ldd	r24, Y+1	; 0x01
    9c22:	0e 94 69 2f 	call	0x5ed2	; 0x5ed2 <_Z6listenh>
      EthernetClass::_server_port[sock] = _port;
    9c26:	88 89       	ldd	r24, Y+16	; 0x10
    9c28:	99 89       	ldd	r25, Y+17	; 0x11
    9c2a:	fc 01       	movw	r30, r24
    9c2c:	24 81       	ldd	r18, Z+4	; 0x04
    9c2e:	35 81       	ldd	r19, Z+5	; 0x05
    9c30:	89 81       	ldd	r24, Y+1	; 0x01
    9c32:	9a 81       	ldd	r25, Y+2	; 0x02
    9c34:	88 0f       	add	r24, r24
    9c36:	99 1f       	adc	r25, r25
    9c38:	84 55       	subi	r24, 0x54	; 84
    9c3a:	98 4f       	sbci	r25, 0xF8	; 248
    9c3c:	fc 01       	movw	r30, r24
    9c3e:	31 83       	std	Z+1, r19	; 0x01
    9c40:	20 83       	st	Z, r18
    9c42:	0e c0       	rjmp	.+28     	; 0x9c60 <_ZN14EthernetServer5beginEv+0x98>
  _port = port;
}

void EthernetServer::begin()
{
  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    9c44:	89 81       	ldd	r24, Y+1	; 0x01
    9c46:	9a 81       	ldd	r25, Y+2	; 0x02
    9c48:	01 96       	adiw	r24, 0x01	; 1
    9c4a:	9a 83       	std	Y+2, r25	; 0x02
    9c4c:	89 83       	std	Y+1, r24	; 0x01
    9c4e:	21 e0       	ldi	r18, 0x01	; 1
    9c50:	89 81       	ldd	r24, Y+1	; 0x01
    9c52:	9a 81       	ldd	r25, Y+2	; 0x02
    9c54:	84 30       	cpi	r24, 0x04	; 4
    9c56:	91 05       	cpc	r25, r1
    9c58:	0c f0       	brlt	.+2      	; 0x9c5c <_ZN14EthernetServer5beginEv+0x94>
    9c5a:	20 e0       	ldi	r18, 0x00	; 0
    9c5c:	22 23       	and	r18, r18
    9c5e:	19 f6       	brne	.-122    	; 0x9be6 <_ZN14EthernetServer5beginEv+0x1e>
      listen(sock);
      EthernetClass::_server_port[sock] = _port;
      break;
    }
  }  
}
    9c60:	61 96       	adiw	r28, 0x11	; 17
    9c62:	0f b6       	in	r0, 0x3f	; 63
    9c64:	f8 94       	cli
    9c66:	de bf       	out	0x3e, r29	; 62
    9c68:	0f be       	out	0x3f, r0	; 63
    9c6a:	cd bf       	out	0x3d, r28	; 61
    9c6c:	df 91       	pop	r29
    9c6e:	cf 91       	pop	r28
    9c70:	08 95       	ret

00009c72 <_ZN14EthernetServer6acceptEv>:

void EthernetServer::accept()
{
    9c72:	cf 93       	push	r28
    9c74:	df 93       	push	r29
    9c76:	cd b7       	in	r28, 0x3d	; 61
    9c78:	de b7       	in	r29, 0x3e	; 62
    9c7a:	63 97       	sbiw	r28, 0x13	; 19
    9c7c:	0f b6       	in	r0, 0x3f	; 63
    9c7e:	f8 94       	cli
    9c80:	de bf       	out	0x3e, r29	; 62
    9c82:	0f be       	out	0x3f, r0	; 63
    9c84:	cd bf       	out	0x3d, r28	; 61
    9c86:	9b 8b       	std	Y+19, r25	; 0x13
    9c88:	8a 8b       	std	Y+18, r24	; 0x12
  int listening = 0;
    9c8a:	1a 82       	std	Y+2, r1	; 0x02
    9c8c:	19 82       	std	Y+1, r1	; 0x01

  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    9c8e:	1c 82       	std	Y+4, r1	; 0x04
    9c90:	1b 82       	std	Y+3, r1	; 0x03
    9c92:	41 c0       	rjmp	.+130    	; 0x9d16 <_ZN14EthernetServer6acceptEv+0xa4>
    EthernetClient client(sock);
    9c94:	2b 81       	ldd	r18, Y+3	; 0x03
    9c96:	ce 01       	movw	r24, r28
    9c98:	05 96       	adiw	r24, 0x05	; 5
    9c9a:	62 2f       	mov	r22, r18
    9c9c:	0e 94 39 4a 	call	0x9472	; 0x9472 <_ZN14EthernetClientC1Eh>

    if (EthernetClass::_server_port[sock] == _port) {
    9ca0:	8b 81       	ldd	r24, Y+3	; 0x03
    9ca2:	9c 81       	ldd	r25, Y+4	; 0x04
    9ca4:	88 0f       	add	r24, r24
    9ca6:	99 1f       	adc	r25, r25
    9ca8:	84 55       	subi	r24, 0x54	; 84
    9caa:	98 4f       	sbci	r25, 0xF8	; 248
    9cac:	fc 01       	movw	r30, r24
    9cae:	20 81       	ld	r18, Z
    9cb0:	31 81       	ldd	r19, Z+1	; 0x01
    9cb2:	8a 89       	ldd	r24, Y+18	; 0x12
    9cb4:	9b 89       	ldd	r25, Y+19	; 0x13
    9cb6:	fc 01       	movw	r30, r24
    9cb8:	84 81       	ldd	r24, Z+4	; 0x04
    9cba:	95 81       	ldd	r25, Z+5	; 0x05
    9cbc:	28 17       	cp	r18, r24
    9cbe:	39 07       	cpc	r19, r25
    9cc0:	29 f5       	brne	.+74     	; 0x9d0c <_ZN14EthernetServer6acceptEv+0x9a>
      if (client.status() == SnSR::LISTEN) {
    9cc2:	ce 01       	movw	r24, r28
    9cc4:	05 96       	adiw	r24, 0x05	; 5
    9cc6:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
    9cca:	98 2f       	mov	r25, r24
    9ccc:	81 e0       	ldi	r24, 0x01	; 1
    9cce:	94 31       	cpi	r25, 0x14	; 20
    9cd0:	09 f0       	breq	.+2      	; 0x9cd4 <_ZN14EthernetServer6acceptEv+0x62>
    9cd2:	80 e0       	ldi	r24, 0x00	; 0
    9cd4:	88 23       	and	r24, r24
    9cd6:	29 f0       	breq	.+10     	; 0x9ce2 <_ZN14EthernetServer6acceptEv+0x70>
        listening = 1;
    9cd8:	81 e0       	ldi	r24, 0x01	; 1
    9cda:	90 e0       	ldi	r25, 0x00	; 0
    9cdc:	9a 83       	std	Y+2, r25	; 0x02
    9cde:	89 83       	std	Y+1, r24	; 0x01
    9ce0:	15 c0       	rjmp	.+42     	; 0x9d0c <_ZN14EthernetServer6acceptEv+0x9a>
      } 
      else if (client.status() == SnSR::CLOSE_WAIT && !client.available()) {
    9ce2:	ce 01       	movw	r24, r28
    9ce4:	05 96       	adiw	r24, 0x05	; 5
    9ce6:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
    9cea:	8c 31       	cpi	r24, 0x1C	; 28
    9cec:	41 f4       	brne	.+16     	; 0x9cfe <_ZN14EthernetServer6acceptEv+0x8c>
    9cee:	ce 01       	movw	r24, r28
    9cf0:	05 96       	adiw	r24, 0x05	; 5
    9cf2:	0e 94 e4 4b 	call	0x97c8	; 0x97c8 <_ZN14EthernetClient9availableEv>
    9cf6:	00 97       	sbiw	r24, 0x00	; 0
    9cf8:	11 f4       	brne	.+4      	; 0x9cfe <_ZN14EthernetServer6acceptEv+0x8c>
    9cfa:	81 e0       	ldi	r24, 0x01	; 1
    9cfc:	01 c0       	rjmp	.+2      	; 0x9d00 <_ZN14EthernetServer6acceptEv+0x8e>
    9cfe:	80 e0       	ldi	r24, 0x00	; 0
    9d00:	88 23       	and	r24, r24
    9d02:	21 f0       	breq	.+8      	; 0x9d0c <_ZN14EthernetServer6acceptEv+0x9a>
        client.stop();
    9d04:	ce 01       	movw	r24, r28
    9d06:	05 96       	adiw	r24, 0x05	; 5
    9d08:	0e 94 ab 4c 	call	0x9956	; 0x9956 <_ZN14EthernetClient4stopEv>

void EthernetServer::accept()
{
  int listening = 0;

  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    9d0c:	8b 81       	ldd	r24, Y+3	; 0x03
    9d0e:	9c 81       	ldd	r25, Y+4	; 0x04
    9d10:	01 96       	adiw	r24, 0x01	; 1
    9d12:	9c 83       	std	Y+4, r25	; 0x04
    9d14:	8b 83       	std	Y+3, r24	; 0x03
    9d16:	21 e0       	ldi	r18, 0x01	; 1
    9d18:	8b 81       	ldd	r24, Y+3	; 0x03
    9d1a:	9c 81       	ldd	r25, Y+4	; 0x04
    9d1c:	84 30       	cpi	r24, 0x04	; 4
    9d1e:	91 05       	cpc	r25, r1
    9d20:	0c f0       	brlt	.+2      	; 0x9d24 <_ZN14EthernetServer6acceptEv+0xb2>
    9d22:	20 e0       	ldi	r18, 0x00	; 0
    9d24:	22 23       	and	r18, r18
    9d26:	09 f0       	breq	.+2      	; 0x9d2a <_ZN14EthernetServer6acceptEv+0xb8>
    9d28:	b5 cf       	rjmp	.-150    	; 0x9c94 <_ZN14EthernetServer6acceptEv+0x22>
        client.stop();
      }
    } 
  }

  if (!listening) {
    9d2a:	89 81       	ldd	r24, Y+1	; 0x01
    9d2c:	9a 81       	ldd	r25, Y+2	; 0x02
    9d2e:	00 97       	sbiw	r24, 0x00	; 0
    9d30:	69 f4       	brne	.+26     	; 0x9d4c <_ZN14EthernetServer6acceptEv+0xda>
    begin();
    9d32:	8a 89       	ldd	r24, Y+18	; 0x12
    9d34:	9b 89       	ldd	r25, Y+19	; 0x13
    9d36:	fc 01       	movw	r30, r24
    9d38:	80 81       	ld	r24, Z
    9d3a:	91 81       	ldd	r25, Z+1	; 0x01
    9d3c:	04 96       	adiw	r24, 0x04	; 4
    9d3e:	fc 01       	movw	r30, r24
    9d40:	20 81       	ld	r18, Z
    9d42:	31 81       	ldd	r19, Z+1	; 0x01
    9d44:	8a 89       	ldd	r24, Y+18	; 0x12
    9d46:	9b 89       	ldd	r25, Y+19	; 0x13
    9d48:	f9 01       	movw	r30, r18
    9d4a:	09 95       	icall
  }
}
    9d4c:	63 96       	adiw	r28, 0x13	; 19
    9d4e:	0f b6       	in	r0, 0x3f	; 63
    9d50:	f8 94       	cli
    9d52:	de bf       	out	0x3e, r29	; 62
    9d54:	0f be       	out	0x3f, r0	; 63
    9d56:	cd bf       	out	0x3d, r28	; 61
    9d58:	df 91       	pop	r29
    9d5a:	cf 91       	pop	r28
    9d5c:	08 95       	ret

00009d5e <_ZN14EthernetServer9availableEv>:

EthernetClient EthernetServer::available()
{
    9d5e:	cf 93       	push	r28
    9d60:	df 93       	push	r29
    9d62:	cd b7       	in	r28, 0x3d	; 61
    9d64:	de b7       	in	r29, 0x3e	; 62
    9d66:	63 97       	sbiw	r28, 0x13	; 19
    9d68:	0f b6       	in	r0, 0x3f	; 63
    9d6a:	f8 94       	cli
    9d6c:	de bf       	out	0x3e, r29	; 62
    9d6e:	0f be       	out	0x3f, r0	; 63
    9d70:	cd bf       	out	0x3d, r28	; 61
    9d72:	99 8b       	std	Y+17, r25	; 0x11
    9d74:	88 8b       	std	Y+16, r24	; 0x10
    9d76:	7b 8b       	std	Y+19, r23	; 0x13
    9d78:	6a 8b       	std	Y+18, r22	; 0x12
  accept();
    9d7a:	8a 89       	ldd	r24, Y+18	; 0x12
    9d7c:	9b 89       	ldd	r25, Y+19	; 0x13
    9d7e:	0e 94 39 4e 	call	0x9c72	; 0x9c72 <_ZN14EthernetServer6acceptEv>

  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    9d82:	1a 82       	std	Y+2, r1	; 0x02
    9d84:	19 82       	std	Y+1, r1	; 0x01
    9d86:	40 c0       	rjmp	.+128    	; 0x9e08 <_ZN14EthernetServer9availableEv+0xaa>
    EthernetClient client(sock);
    9d88:	29 81       	ldd	r18, Y+1	; 0x01
    9d8a:	ce 01       	movw	r24, r28
    9d8c:	03 96       	adiw	r24, 0x03	; 3
    9d8e:	62 2f       	mov	r22, r18
    9d90:	0e 94 39 4a 	call	0x9472	; 0x9472 <_ZN14EthernetClientC1Eh>
    if (EthernetClass::_server_port[sock] == _port &&
    9d94:	89 81       	ldd	r24, Y+1	; 0x01
    9d96:	9a 81       	ldd	r25, Y+2	; 0x02
    9d98:	88 0f       	add	r24, r24
    9d9a:	99 1f       	adc	r25, r25
    9d9c:	84 55       	subi	r24, 0x54	; 84
    9d9e:	98 4f       	sbci	r25, 0xF8	; 248
    9da0:	fc 01       	movw	r30, r24
    9da2:	20 81       	ld	r18, Z
    9da4:	31 81       	ldd	r19, Z+1	; 0x01
    9da6:	8a 89       	ldd	r24, Y+18	; 0x12
    9da8:	9b 89       	ldd	r25, Y+19	; 0x13
    9daa:	fc 01       	movw	r30, r24
    9dac:	84 81       	ldd	r24, Z+4	; 0x04
    9dae:	95 81       	ldd	r25, Z+5	; 0x05
    9db0:	28 17       	cp	r18, r24
    9db2:	39 07       	cpc	r19, r25
    9db4:	71 f4       	brne	.+28     	; 0x9dd2 <_ZN14EthernetServer9availableEv+0x74>
        (client.status() == SnSR::ESTABLISHED ||
    9db6:	ce 01       	movw	r24, r28
    9db8:	03 96       	adiw	r24, 0x03	; 3
    9dba:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
{
  accept();

  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    EthernetClient client(sock);
    if (EthernetClass::_server_port[sock] == _port &&
    9dbe:	87 31       	cpi	r24, 0x17	; 23
    9dc0:	31 f0       	breq	.+12     	; 0x9dce <_ZN14EthernetServer9availableEv+0x70>
        (client.status() == SnSR::ESTABLISHED ||
         client.status() == SnSR::CLOSE_WAIT)) {
    9dc2:	ce 01       	movw	r24, r28
    9dc4:	03 96       	adiw	r24, 0x03	; 3
    9dc6:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
{
  accept();

  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    EthernetClient client(sock);
    if (EthernetClass::_server_port[sock] == _port &&
    9dca:	8c 31       	cpi	r24, 0x1C	; 28
    9dcc:	11 f4       	brne	.+4      	; 0x9dd2 <_ZN14EthernetServer9availableEv+0x74>
    9dce:	81 e0       	ldi	r24, 0x01	; 1
    9dd0:	01 c0       	rjmp	.+2      	; 0x9dd4 <_ZN14EthernetServer9availableEv+0x76>
    9dd2:	80 e0       	ldi	r24, 0x00	; 0
    9dd4:	88 23       	and	r24, r24
    9dd6:	99 f0       	breq	.+38     	; 0x9dfe <_ZN14EthernetServer9availableEv+0xa0>
        (client.status() == SnSR::ESTABLISHED ||
         client.status() == SnSR::CLOSE_WAIT)) {
      if (client.available()) {
    9dd8:	ce 01       	movw	r24, r28
    9dda:	03 96       	adiw	r24, 0x03	; 3
    9ddc:	0e 94 e4 4b 	call	0x97c8	; 0x97c8 <_ZN14EthernetClient9availableEv>
    9de0:	21 e0       	ldi	r18, 0x01	; 1
    9de2:	00 97       	sbiw	r24, 0x00	; 0
    9de4:	09 f4       	brne	.+2      	; 0x9de8 <_ZN14EthernetServer9availableEv+0x8a>
    9de6:	20 e0       	ldi	r18, 0x00	; 0
    9de8:	22 23       	and	r18, r18
    9dea:	49 f0       	breq	.+18     	; 0x9dfe <_ZN14EthernetServer9availableEv+0xa0>
        // XXX: don't always pick the lowest numbered socket.
        return client;
    9dec:	9e 01       	movw	r18, r28
    9dee:	2d 5f       	subi	r18, 0xFD	; 253
    9df0:	3f 4f       	sbci	r19, 0xFF	; 255
    9df2:	88 89       	ldd	r24, Y+16	; 0x10
    9df4:	99 89       	ldd	r25, Y+17	; 0x11
    9df6:	b9 01       	movw	r22, r18
    9df8:	0e 94 35 ac 	call	0x1586a	; 0x1586a <_ZN14EthernetClientC1ERKS_>
    9dfc:	14 c0       	rjmp	.+40     	; 0x9e26 <_ZN14EthernetServer9availableEv+0xc8>

EthernetClient EthernetServer::available()
{
  accept();

  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    9dfe:	89 81       	ldd	r24, Y+1	; 0x01
    9e00:	9a 81       	ldd	r25, Y+2	; 0x02
    9e02:	01 96       	adiw	r24, 0x01	; 1
    9e04:	9a 83       	std	Y+2, r25	; 0x02
    9e06:	89 83       	std	Y+1, r24	; 0x01
    9e08:	21 e0       	ldi	r18, 0x01	; 1
    9e0a:	89 81       	ldd	r24, Y+1	; 0x01
    9e0c:	9a 81       	ldd	r25, Y+2	; 0x02
    9e0e:	84 30       	cpi	r24, 0x04	; 4
    9e10:	91 05       	cpc	r25, r1
    9e12:	0c f0       	brlt	.+2      	; 0x9e16 <_ZN14EthernetServer9availableEv+0xb8>
    9e14:	20 e0       	ldi	r18, 0x00	; 0
    9e16:	22 23       	and	r18, r18
    9e18:	09 f0       	breq	.+2      	; 0x9e1c <_ZN14EthernetServer9availableEv+0xbe>
    9e1a:	b6 cf       	rjmp	.-148    	; 0x9d88 <_ZN14EthernetServer9availableEv+0x2a>
        return client;
      }
    }
  }

  return EthernetClient(MAX_SOCK_NUM);
    9e1c:	88 89       	ldd	r24, Y+16	; 0x10
    9e1e:	99 89       	ldd	r25, Y+17	; 0x11
    9e20:	64 e0       	ldi	r22, 0x04	; 4
    9e22:	0e 94 39 4a 	call	0x9472	; 0x9472 <_ZN14EthernetClientC1Eh>
}
    9e26:	88 89       	ldd	r24, Y+16	; 0x10
    9e28:	99 89       	ldd	r25, Y+17	; 0x11
    9e2a:	63 96       	adiw	r28, 0x13	; 19
    9e2c:	0f b6       	in	r0, 0x3f	; 63
    9e2e:	f8 94       	cli
    9e30:	de bf       	out	0x3e, r29	; 62
    9e32:	0f be       	out	0x3f, r0	; 63
    9e34:	cd bf       	out	0x3d, r28	; 61
    9e36:	df 91       	pop	r29
    9e38:	cf 91       	pop	r28
    9e3a:	08 95       	ret

00009e3c <_ZN14EthernetServer5writeEh>:

size_t EthernetServer::write(uint8_t b) 
{
    9e3c:	cf 93       	push	r28
    9e3e:	df 93       	push	r29
    9e40:	00 d0       	rcall	.+0      	; 0x9e42 <_ZN14EthernetServer5writeEh+0x6>
    9e42:	1f 92       	push	r1
    9e44:	cd b7       	in	r28, 0x3d	; 61
    9e46:	de b7       	in	r29, 0x3e	; 62
    9e48:	9a 83       	std	Y+2, r25	; 0x02
    9e4a:	89 83       	std	Y+1, r24	; 0x01
    9e4c:	6b 83       	std	Y+3, r22	; 0x03
  return write(&b, 1);
    9e4e:	89 81       	ldd	r24, Y+1	; 0x01
    9e50:	9a 81       	ldd	r25, Y+2	; 0x02
    9e52:	fc 01       	movw	r30, r24
    9e54:	80 81       	ld	r24, Z
    9e56:	91 81       	ldd	r25, Z+1	; 0x01
    9e58:	02 96       	adiw	r24, 0x02	; 2
    9e5a:	fc 01       	movw	r30, r24
    9e5c:	20 81       	ld	r18, Z
    9e5e:	31 81       	ldd	r19, Z+1	; 0x01
    9e60:	be 01       	movw	r22, r28
    9e62:	6d 5f       	subi	r22, 0xFD	; 253
    9e64:	7f 4f       	sbci	r23, 0xFF	; 255
    9e66:	89 81       	ldd	r24, Y+1	; 0x01
    9e68:	9a 81       	ldd	r25, Y+2	; 0x02
    9e6a:	41 e0       	ldi	r20, 0x01	; 1
    9e6c:	50 e0       	ldi	r21, 0x00	; 0
    9e6e:	f9 01       	movw	r30, r18
    9e70:	09 95       	icall
}
    9e72:	0f 90       	pop	r0
    9e74:	0f 90       	pop	r0
    9e76:	0f 90       	pop	r0
    9e78:	df 91       	pop	r29
    9e7a:	cf 91       	pop	r28
    9e7c:	08 95       	ret

00009e7e <_ZN14EthernetServer5writeEPKhj>:

size_t EthernetServer::write(const uint8_t *buffer, size_t size) 
{
    9e7e:	cf 93       	push	r28
    9e80:	df 93       	push	r29
    9e82:	cd b7       	in	r28, 0x3d	; 61
    9e84:	de b7       	in	r29, 0x3e	; 62
    9e86:	67 97       	sbiw	r28, 0x17	; 23
    9e88:	0f b6       	in	r0, 0x3f	; 63
    9e8a:	f8 94       	cli
    9e8c:	de bf       	out	0x3e, r29	; 62
    9e8e:	0f be       	out	0x3f, r0	; 63
    9e90:	cd bf       	out	0x3d, r28	; 61
    9e92:	9b 8b       	std	Y+19, r25	; 0x13
    9e94:	8a 8b       	std	Y+18, r24	; 0x12
    9e96:	7d 8b       	std	Y+21, r23	; 0x15
    9e98:	6c 8b       	std	Y+20, r22	; 0x14
    9e9a:	5f 8b       	std	Y+23, r21	; 0x17
    9e9c:	4e 8b       	std	Y+22, r20	; 0x16
  size_t n = 0;
    9e9e:	1a 82       	std	Y+2, r1	; 0x02
    9ea0:	19 82       	std	Y+1, r1	; 0x01
  
  accept();
    9ea2:	8a 89       	ldd	r24, Y+18	; 0x12
    9ea4:	9b 89       	ldd	r25, Y+19	; 0x13
    9ea6:	0e 94 39 4e 	call	0x9c72	; 0x9c72 <_ZN14EthernetServer6acceptEv>

  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    9eaa:	1c 82       	std	Y+4, r1	; 0x04
    9eac:	1b 82       	std	Y+3, r1	; 0x03
    9eae:	36 c0       	rjmp	.+108    	; 0x9f1c <_ZN14EthernetServer5writeEPKhj+0x9e>
    EthernetClient client(sock);
    9eb0:	2b 81       	ldd	r18, Y+3	; 0x03
    9eb2:	ce 01       	movw	r24, r28
    9eb4:	05 96       	adiw	r24, 0x05	; 5
    9eb6:	62 2f       	mov	r22, r18
    9eb8:	0e 94 39 4a 	call	0x9472	; 0x9472 <_ZN14EthernetClientC1Eh>

    if (EthernetClass::_server_port[sock] == _port &&
    9ebc:	8b 81       	ldd	r24, Y+3	; 0x03
    9ebe:	9c 81       	ldd	r25, Y+4	; 0x04
    9ec0:	88 0f       	add	r24, r24
    9ec2:	99 1f       	adc	r25, r25
    9ec4:	84 55       	subi	r24, 0x54	; 84
    9ec6:	98 4f       	sbci	r25, 0xF8	; 248
    9ec8:	fc 01       	movw	r30, r24
    9eca:	20 81       	ld	r18, Z
    9ecc:	31 81       	ldd	r19, Z+1	; 0x01
    9ece:	8a 89       	ldd	r24, Y+18	; 0x12
    9ed0:	9b 89       	ldd	r25, Y+19	; 0x13
    9ed2:	fc 01       	movw	r30, r24
    9ed4:	84 81       	ldd	r24, Z+4	; 0x04
    9ed6:	95 81       	ldd	r25, Z+5	; 0x05
    9ed8:	28 17       	cp	r18, r24
    9eda:	39 07       	cpc	r19, r25
    9edc:	41 f4       	brne	.+16     	; 0x9eee <_ZN14EthernetServer5writeEPKhj+0x70>
      client.status() == SnSR::ESTABLISHED) {
    9ede:	ce 01       	movw	r24, r28
    9ee0:	05 96       	adiw	r24, 0x05	; 5
    9ee2:	0e 94 60 4d 	call	0x9ac0	; 0x9ac0 <_ZN14EthernetClient6statusEv>
  accept();

  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    EthernetClient client(sock);

    if (EthernetClass::_server_port[sock] == _port &&
    9ee6:	87 31       	cpi	r24, 0x17	; 23
    9ee8:	11 f4       	brne	.+4      	; 0x9eee <_ZN14EthernetServer5writeEPKhj+0x70>
    9eea:	81 e0       	ldi	r24, 0x01	; 1
    9eec:	01 c0       	rjmp	.+2      	; 0x9ef0 <_ZN14EthernetServer5writeEPKhj+0x72>
    9eee:	80 e0       	ldi	r24, 0x00	; 0
    9ef0:	88 23       	and	r24, r24
    9ef2:	79 f0       	breq	.+30     	; 0x9f12 <_ZN14EthernetServer5writeEPKhj+0x94>
      client.status() == SnSR::ESTABLISHED) {
      n += client.write(buffer, size);
    9ef4:	4e 89       	ldd	r20, Y+22	; 0x16
    9ef6:	5f 89       	ldd	r21, Y+23	; 0x17
    9ef8:	2c 89       	ldd	r18, Y+20	; 0x14
    9efa:	3d 89       	ldd	r19, Y+21	; 0x15
    9efc:	ce 01       	movw	r24, r28
    9efe:	05 96       	adiw	r24, 0x05	; 5
    9f00:	b9 01       	movw	r22, r18
    9f02:	0e 94 9e 4b 	call	0x973c	; 0x973c <_ZN14EthernetClient5writeEPKhj>
    9f06:	29 81       	ldd	r18, Y+1	; 0x01
    9f08:	3a 81       	ldd	r19, Y+2	; 0x02
    9f0a:	82 0f       	add	r24, r18
    9f0c:	93 1f       	adc	r25, r19
    9f0e:	9a 83       	std	Y+2, r25	; 0x02
    9f10:	89 83       	std	Y+1, r24	; 0x01
{
  size_t n = 0;
  
  accept();

  for (int sock = 0; sock < MAX_SOCK_NUM; sock++) {
    9f12:	8b 81       	ldd	r24, Y+3	; 0x03
    9f14:	9c 81       	ldd	r25, Y+4	; 0x04
    9f16:	01 96       	adiw	r24, 0x01	; 1
    9f18:	9c 83       	std	Y+4, r25	; 0x04
    9f1a:	8b 83       	std	Y+3, r24	; 0x03
    9f1c:	21 e0       	ldi	r18, 0x01	; 1
    9f1e:	8b 81       	ldd	r24, Y+3	; 0x03
    9f20:	9c 81       	ldd	r25, Y+4	; 0x04
    9f22:	84 30       	cpi	r24, 0x04	; 4
    9f24:	91 05       	cpc	r25, r1
    9f26:	0c f0       	brlt	.+2      	; 0x9f2a <_ZN14EthernetServer5writeEPKhj+0xac>
    9f28:	20 e0       	ldi	r18, 0x00	; 0
    9f2a:	22 23       	and	r18, r18
    9f2c:	09 f6       	brne	.-126    	; 0x9eb0 <_ZN14EthernetServer5writeEPKhj+0x32>
      client.status() == SnSR::ESTABLISHED) {
      n += client.write(buffer, size);
    }
  }
  
  return n;
    9f2e:	89 81       	ldd	r24, Y+1	; 0x01
    9f30:	9a 81       	ldd	r25, Y+2	; 0x02
}
    9f32:	67 96       	adiw	r28, 0x17	; 23
    9f34:	0f b6       	in	r0, 0x3f	; 63
    9f36:	f8 94       	cli
    9f38:	de bf       	out	0x3e, r29	; 62
    9f3a:	0f be       	out	0x3f, r0	; 63
    9f3c:	cd bf       	out	0x3d, r28	; 61
    9f3e:	df 91       	pop	r29
    9f40:	cf 91       	pop	r28
    9f42:	08 95       	ret

00009f44 <_Z41__static_initialization_and_destruction_0ii>:
    9f44:	0f 93       	push	r16
    9f46:	cf 93       	push	r28
    9f48:	df 93       	push	r29
    9f4a:	00 d0       	rcall	.+0      	; 0x9f4c <_Z41__static_initialization_and_destruction_0ii+0x8>
    9f4c:	00 d0       	rcall	.+0      	; 0x9f4e <_Z41__static_initialization_and_destruction_0ii+0xa>
    9f4e:	cd b7       	in	r28, 0x3d	; 61
    9f50:	de b7       	in	r29, 0x3e	; 62
    9f52:	9a 83       	std	Y+2, r25	; 0x02
    9f54:	89 83       	std	Y+1, r24	; 0x01
    9f56:	7c 83       	std	Y+4, r23	; 0x04
    9f58:	6b 83       	std	Y+3, r22	; 0x03
    9f5a:	89 81       	ldd	r24, Y+1	; 0x01
    9f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    9f5e:	81 30       	cpi	r24, 0x01	; 1
    9f60:	91 05       	cpc	r25, r1
    9f62:	71 f4       	brne	.+28     	; 0x9f80 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    9f64:	8b 81       	ldd	r24, Y+3	; 0x03
    9f66:	9c 81       	ldd	r25, Y+4	; 0x04
    9f68:	8f 3f       	cpi	r24, 0xFF	; 255
    9f6a:	2f ef       	ldi	r18, 0xFF	; 255
    9f6c:	92 07       	cpc	r25, r18
    9f6e:	41 f4       	brne	.+16     	; 0x9f80 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    9f70:	00 e0       	ldi	r16, 0x00	; 0
    9f72:	20 e0       	ldi	r18, 0x00	; 0
    9f74:	40 e0       	ldi	r20, 0x00	; 0
    9f76:	60 e0       	ldi	r22, 0x00	; 0
    9f78:	82 e3       	ldi	r24, 0x32	; 50
    9f7a:	98 e0       	ldi	r25, 0x08	; 8
    9f7c:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    9f80:	0f 90       	pop	r0
    9f82:	0f 90       	pop	r0
    9f84:	0f 90       	pop	r0
    9f86:	0f 90       	pop	r0
    9f88:	df 91       	pop	r29
    9f8a:	cf 91       	pop	r28
    9f8c:	0f 91       	pop	r16
    9f8e:	08 95       	ret

00009f90 <_GLOBAL__sub_I__ZN14EthernetServerC2Ej>:
    9f90:	cf 93       	push	r28
    9f92:	df 93       	push	r29
    9f94:	cd b7       	in	r28, 0x3d	; 61
    9f96:	de b7       	in	r29, 0x3e	; 62
    9f98:	6f ef       	ldi	r22, 0xFF	; 255
    9f9a:	7f ef       	ldi	r23, 0xFF	; 255
    9f9c:	81 e0       	ldi	r24, 0x01	; 1
    9f9e:	90 e0       	ldi	r25, 0x00	; 0
    9fa0:	0e 94 a2 4f 	call	0x9f44	; 0x9f44 <_Z41__static_initialization_and_destruction_0ii>
    9fa4:	df 91       	pop	r29
    9fa6:	cf 91       	pop	r28
    9fa8:	08 95       	ret

00009faa <_ZN11EthernetUDPC1Ev>:
#include "Ethernet.h"
#include "Udp.h"
#include "Dns.h"

/* Constructor */
EthernetUDP::EthernetUDP() : _sock(MAX_SOCK_NUM) {}
    9faa:	cf 93       	push	r28
    9fac:	df 93       	push	r29
    9fae:	00 d0       	rcall	.+0      	; 0x9fb0 <_ZN11EthernetUDPC1Ev+0x6>
    9fb0:	cd b7       	in	r28, 0x3d	; 61
    9fb2:	de b7       	in	r29, 0x3e	; 62
    9fb4:	9a 83       	std	Y+2, r25	; 0x02
    9fb6:	89 83       	std	Y+1, r24	; 0x01
    9fb8:	89 81       	ldd	r24, Y+1	; 0x01
    9fba:	9a 81       	ldd	r25, Y+2	; 0x02
    9fbc:	0e 94 98 ac 	call	0x15930	; 0x15930 <_ZN3UDPC1Ev>
    9fc0:	89 81       	ldd	r24, Y+1	; 0x01
    9fc2:	9a 81       	ldd	r25, Y+2	; 0x02
    9fc4:	23 e6       	ldi	r18, 0x63	; 99
    9fc6:	35 e0       	ldi	r19, 0x05	; 5
    9fc8:	fc 01       	movw	r30, r24
    9fca:	31 83       	std	Z+1, r19	; 0x01
    9fcc:	20 83       	st	Z, r18
    9fce:	89 81       	ldd	r24, Y+1	; 0x01
    9fd0:	9a 81       	ldd	r25, Y+2	; 0x02
    9fd2:	24 e0       	ldi	r18, 0x04	; 4
    9fd4:	fc 01       	movw	r30, r24
    9fd6:	24 87       	std	Z+12, r18	; 0x0c
    9fd8:	89 81       	ldd	r24, Y+1	; 0x01
    9fda:	9a 81       	ldd	r25, Y+2	; 0x02
    9fdc:	0f 96       	adiw	r24, 0x0f	; 15
    9fde:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>
    9fe2:	0f 90       	pop	r0
    9fe4:	0f 90       	pop	r0
    9fe6:	df 91       	pop	r29
    9fe8:	cf 91       	pop	r28
    9fea:	08 95       	ret

00009fec <_ZN11EthernetUDP5beginEj>:

/* Start EthernetUDP socket, listening at local port PORT */
uint8_t EthernetUDP::begin(uint16_t port) {
    9fec:	cf 93       	push	r28
    9fee:	df 93       	push	r29
    9ff0:	cd b7       	in	r28, 0x3d	; 61
    9ff2:	de b7       	in	r29, 0x3e	; 62
    9ff4:	27 97       	sbiw	r28, 0x07	; 7
    9ff6:	0f b6       	in	r0, 0x3f	; 63
    9ff8:	f8 94       	cli
    9ffa:	de bf       	out	0x3e, r29	; 62
    9ffc:	0f be       	out	0x3f, r0	; 63
    9ffe:	cd bf       	out	0x3d, r28	; 61
    a000:	9d 83       	std	Y+5, r25	; 0x05
    a002:	8c 83       	std	Y+4, r24	; 0x04
    a004:	7f 83       	std	Y+7, r23	; 0x07
    a006:	6e 83       	std	Y+6, r22	; 0x06
  if (_sock != MAX_SOCK_NUM)
    a008:	8c 81       	ldd	r24, Y+4	; 0x04
    a00a:	9d 81       	ldd	r25, Y+5	; 0x05
    a00c:	fc 01       	movw	r30, r24
    a00e:	84 85       	ldd	r24, Z+12	; 0x0c
    a010:	84 30       	cpi	r24, 0x04	; 4
    a012:	11 f0       	breq	.+4      	; 0xa018 <_ZN11EthernetUDP5beginEj+0x2c>
    return 0;
    a014:	80 e0       	ldi	r24, 0x00	; 0
    a016:	45 c0       	rjmp	.+138    	; 0xa0a2 <_ZN11EthernetUDP5beginEj+0xb6>

  for (int i = 0; i < MAX_SOCK_NUM; i++) {
    a018:	1a 82       	std	Y+2, r1	; 0x02
    a01a:	19 82       	std	Y+1, r1	; 0x01
    a01c:	15 c0       	rjmp	.+42     	; 0xa048 <_ZN11EthernetUDP5beginEj+0x5c>
    uint8_t s = W5100.readSnSR(i);
    a01e:	89 81       	ldd	r24, Y+1	; 0x01
    a020:	0e 94 86 a7 	call	0x14f0c	; 0x14f0c <_ZN10W5100Class8readSnSREh>
    a024:	8b 83       	std	Y+3, r24	; 0x03
    if (s == SnSR::CLOSED || s == SnSR::FIN_WAIT) {
    a026:	8b 81       	ldd	r24, Y+3	; 0x03
    a028:	88 23       	and	r24, r24
    a02a:	19 f0       	breq	.+6      	; 0xa032 <_ZN11EthernetUDP5beginEj+0x46>
    a02c:	8b 81       	ldd	r24, Y+3	; 0x03
    a02e:	88 31       	cpi	r24, 0x18	; 24
    a030:	31 f4       	brne	.+12     	; 0xa03e <_ZN11EthernetUDP5beginEj+0x52>
      _sock = i;
    a032:	29 81       	ldd	r18, Y+1	; 0x01
    a034:	8c 81       	ldd	r24, Y+4	; 0x04
    a036:	9d 81       	ldd	r25, Y+5	; 0x05
    a038:	fc 01       	movw	r30, r24
    a03a:	24 87       	std	Z+12, r18	; 0x0c
      break;
    a03c:	0e c0       	rjmp	.+28     	; 0xa05a <_ZN11EthernetUDP5beginEj+0x6e>
/* Start EthernetUDP socket, listening at local port PORT */
uint8_t EthernetUDP::begin(uint16_t port) {
  if (_sock != MAX_SOCK_NUM)
    return 0;

  for (int i = 0; i < MAX_SOCK_NUM; i++) {
    a03e:	89 81       	ldd	r24, Y+1	; 0x01
    a040:	9a 81       	ldd	r25, Y+2	; 0x02
    a042:	01 96       	adiw	r24, 0x01	; 1
    a044:	9a 83       	std	Y+2, r25	; 0x02
    a046:	89 83       	std	Y+1, r24	; 0x01
    a048:	21 e0       	ldi	r18, 0x01	; 1
    a04a:	89 81       	ldd	r24, Y+1	; 0x01
    a04c:	9a 81       	ldd	r25, Y+2	; 0x02
    a04e:	84 30       	cpi	r24, 0x04	; 4
    a050:	91 05       	cpc	r25, r1
    a052:	0c f0       	brlt	.+2      	; 0xa056 <_ZN11EthernetUDP5beginEj+0x6a>
    a054:	20 e0       	ldi	r18, 0x00	; 0
    a056:	22 23       	and	r18, r18
    a058:	11 f7       	brne	.-60     	; 0xa01e <_ZN11EthernetUDP5beginEj+0x32>
      _sock = i;
      break;
    }
  }

  if (_sock == MAX_SOCK_NUM)
    a05a:	8c 81       	ldd	r24, Y+4	; 0x04
    a05c:	9d 81       	ldd	r25, Y+5	; 0x05
    a05e:	fc 01       	movw	r30, r24
    a060:	84 85       	ldd	r24, Z+12	; 0x0c
    a062:	84 30       	cpi	r24, 0x04	; 4
    a064:	11 f4       	brne	.+4      	; 0xa06a <_ZN11EthernetUDP5beginEj+0x7e>
    return 0;
    a066:	80 e0       	ldi	r24, 0x00	; 0
    a068:	1c c0       	rjmp	.+56     	; 0xa0a2 <_ZN11EthernetUDP5beginEj+0xb6>

  _port = port;
    a06a:	8c 81       	ldd	r24, Y+4	; 0x04
    a06c:	9d 81       	ldd	r25, Y+5	; 0x05
    a06e:	2e 81       	ldd	r18, Y+6	; 0x06
    a070:	3f 81       	ldd	r19, Y+7	; 0x07
    a072:	fc 01       	movw	r30, r24
    a074:	36 87       	std	Z+14, r19	; 0x0e
    a076:	25 87       	std	Z+13, r18	; 0x0d
  _remaining = 0;
    a078:	8c 81       	ldd	r24, Y+4	; 0x04
    a07a:	9d 81       	ldd	r25, Y+5	; 0x05
    a07c:	fc 01       	movw	r30, r24
    a07e:	12 8e       	std	Z+26, r1	; 0x1a
    a080:	11 8e       	std	Z+25, r1	; 0x19
  socket(_sock, SnMR::UDP, _port, 0);
    a082:	8c 81       	ldd	r24, Y+4	; 0x04
    a084:	9d 81       	ldd	r25, Y+5	; 0x05
    a086:	fc 01       	movw	r30, r24
    a088:	85 85       	ldd	r24, Z+13	; 0x0d
    a08a:	96 85       	ldd	r25, Z+14	; 0x0e
    a08c:	2c 81       	ldd	r18, Y+4	; 0x04
    a08e:	3d 81       	ldd	r19, Y+5	; 0x05
    a090:	f9 01       	movw	r30, r18
    a092:	34 85       	ldd	r19, Z+12	; 0x0c
    a094:	20 e0       	ldi	r18, 0x00	; 0
    a096:	ac 01       	movw	r20, r24
    a098:	62 e0       	ldi	r22, 0x02	; 2
    a09a:	83 2f       	mov	r24, r19
    a09c:	0e 94 03 2f 	call	0x5e06	; 0x5e06 <_Z6sockethhjh>

  return 1;
    a0a0:	81 e0       	ldi	r24, 0x01	; 1
}
    a0a2:	27 96       	adiw	r28, 0x07	; 7
    a0a4:	0f b6       	in	r0, 0x3f	; 63
    a0a6:	f8 94       	cli
    a0a8:	de bf       	out	0x3e, r29	; 62
    a0aa:	0f be       	out	0x3f, r0	; 63
    a0ac:	cd bf       	out	0x3d, r28	; 61
    a0ae:	df 91       	pop	r29
    a0b0:	cf 91       	pop	r28
    a0b2:	08 95       	ret

0000a0b4 <_ZN11EthernetUDP9availableEv>:

/* return number of bytes available in the current packet,
   will return zero if parsePacket hasn't been called yet */
int EthernetUDP::available() {
    a0b4:	cf 93       	push	r28
    a0b6:	df 93       	push	r29
    a0b8:	00 d0       	rcall	.+0      	; 0xa0ba <_ZN11EthernetUDP9availableEv+0x6>
    a0ba:	cd b7       	in	r28, 0x3d	; 61
    a0bc:	de b7       	in	r29, 0x3e	; 62
    a0be:	9a 83       	std	Y+2, r25	; 0x02
    a0c0:	89 83       	std	Y+1, r24	; 0x01
  return _remaining;
    a0c2:	89 81       	ldd	r24, Y+1	; 0x01
    a0c4:	9a 81       	ldd	r25, Y+2	; 0x02
    a0c6:	fc 01       	movw	r30, r24
    a0c8:	81 8d       	ldd	r24, Z+25	; 0x19
    a0ca:	92 8d       	ldd	r25, Z+26	; 0x1a
}
    a0cc:	0f 90       	pop	r0
    a0ce:	0f 90       	pop	r0
    a0d0:	df 91       	pop	r29
    a0d2:	cf 91       	pop	r28
    a0d4:	08 95       	ret

0000a0d6 <_ZN11EthernetUDP4stopEv>:

/* Release any resources being used by this EthernetUDP instance */
void EthernetUDP::stop()
{
    a0d6:	cf 93       	push	r28
    a0d8:	df 93       	push	r29
    a0da:	00 d0       	rcall	.+0      	; 0xa0dc <_ZN11EthernetUDP4stopEv+0x6>
    a0dc:	cd b7       	in	r28, 0x3d	; 61
    a0de:	de b7       	in	r29, 0x3e	; 62
    a0e0:	9a 83       	std	Y+2, r25	; 0x02
    a0e2:	89 83       	std	Y+1, r24	; 0x01
  if (_sock == MAX_SOCK_NUM)
    a0e4:	89 81       	ldd	r24, Y+1	; 0x01
    a0e6:	9a 81       	ldd	r25, Y+2	; 0x02
    a0e8:	fc 01       	movw	r30, r24
    a0ea:	84 85       	ldd	r24, Z+12	; 0x0c
    a0ec:	84 30       	cpi	r24, 0x04	; 4
    a0ee:	c9 f0       	breq	.+50     	; 0xa122 <_ZN11EthernetUDP4stopEv+0x4c>
    return;

  close(_sock);
    a0f0:	89 81       	ldd	r24, Y+1	; 0x01
    a0f2:	9a 81       	ldd	r25, Y+2	; 0x02
    a0f4:	fc 01       	movw	r30, r24
    a0f6:	84 85       	ldd	r24, Z+12	; 0x0c
    a0f8:	0e 94 55 2f 	call	0x5eaa	; 0x5eaa <_Z5closeh>

  EthernetClass::_server_port[_sock] = 0;
    a0fc:	89 81       	ldd	r24, Y+1	; 0x01
    a0fe:	9a 81       	ldd	r25, Y+2	; 0x02
    a100:	fc 01       	movw	r30, r24
    a102:	84 85       	ldd	r24, Z+12	; 0x0c
    a104:	88 2f       	mov	r24, r24
    a106:	90 e0       	ldi	r25, 0x00	; 0
    a108:	88 0f       	add	r24, r24
    a10a:	99 1f       	adc	r25, r25
    a10c:	84 55       	subi	r24, 0x54	; 84
    a10e:	98 4f       	sbci	r25, 0xF8	; 248
    a110:	fc 01       	movw	r30, r24
    a112:	11 82       	std	Z+1, r1	; 0x01
    a114:	10 82       	st	Z, r1
  _sock = MAX_SOCK_NUM;
    a116:	89 81       	ldd	r24, Y+1	; 0x01
    a118:	9a 81       	ldd	r25, Y+2	; 0x02
    a11a:	24 e0       	ldi	r18, 0x04	; 4
    a11c:	fc 01       	movw	r30, r24
    a11e:	24 87       	std	Z+12, r18	; 0x0c
    a120:	01 c0       	rjmp	.+2      	; 0xa124 <_ZN11EthernetUDP4stopEv+0x4e>

/* Release any resources being used by this EthernetUDP instance */
void EthernetUDP::stop()
{
  if (_sock == MAX_SOCK_NUM)
    return;
    a122:	00 00       	nop

  close(_sock);

  EthernetClass::_server_port[_sock] = 0;
  _sock = MAX_SOCK_NUM;
}
    a124:	0f 90       	pop	r0
    a126:	0f 90       	pop	r0
    a128:	df 91       	pop	r29
    a12a:	cf 91       	pop	r28
    a12c:	08 95       	ret

0000a12e <_ZN11EthernetUDP11beginPacketEPKcj>:

int EthernetUDP::beginPacket(const char *host, uint16_t port)
{
    a12e:	0f 93       	push	r16
    a130:	1f 93       	push	r17
    a132:	cf 93       	push	r28
    a134:	df 93       	push	r29
    a136:	cd b7       	in	r28, 0x3d	; 61
    a138:	de b7       	in	r29, 0x3e	; 62
    a13a:	ed 97       	sbiw	r28, 0x3d	; 61
    a13c:	0f b6       	in	r0, 0x3f	; 63
    a13e:	f8 94       	cli
    a140:	de bf       	out	0x3e, r29	; 62
    a142:	0f be       	out	0x3f, r0	; 63
    a144:	cd bf       	out	0x3d, r28	; 61
    a146:	99 af       	std	Y+57, r25	; 0x39
    a148:	88 af       	std	Y+56, r24	; 0x38
    a14a:	7b af       	std	Y+59, r23	; 0x3b
    a14c:	6a af       	std	Y+58, r22	; 0x3a
    a14e:	5d af       	std	Y+61, r21	; 0x3d
    a150:	4c af       	std	Y+60, r20	; 0x3c
  // Look up the host first
  int ret = 0;
    a152:	1a 82       	std	Y+2, r1	; 0x02
    a154:	19 82       	std	Y+1, r1	; 0x01
  DNSClient dns;
    a156:	ce 01       	movw	r24, r28
    a158:	45 96       	adiw	r24, 0x15	; 21
    a15a:	0e 94 20 ac 	call	0x15840	; 0x15840 <_ZN9DNSClientC1Ev>
  IPAddress remote_addr;
    a15e:	ce 01       	movw	r24, r28
    a160:	0f 96       	adiw	r24, 0x0f	; 15
    a162:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>

  dns.begin(Ethernet.dnsServerIP());
    a166:	ce 01       	movw	r24, r28
    a168:	09 96       	adiw	r24, 0x09	; 9
    a16a:	64 eb       	ldi	r22, 0xB4	; 180
    a16c:	77 e0       	ldi	r23, 0x07	; 7
    a16e:	0e 94 cc 49 	call	0x9398	; 0x9398 <_ZN13EthernetClass11dnsServerIPEv>
    a172:	9e 01       	movw	r18, r28
    a174:	27 5f       	subi	r18, 0xF7	; 247
    a176:	3f 4f       	sbci	r19, 0xFF	; 255
    a178:	ce 01       	movw	r24, r28
    a17a:	45 96       	adiw	r24, 0x15	; 21
    a17c:	b9 01       	movw	r22, r18
    a17e:	0e 94 0f 42 	call	0x841e	; 0x841e <_ZN9DNSClient5beginERK9IPAddress>
  ret = dns.getHostByName(host, remote_addr);
    a182:	ae 01       	movw	r20, r28
    a184:	41 5f       	subi	r20, 0xF1	; 241
    a186:	5f 4f       	sbci	r21, 0xFF	; 255
    a188:	2a ad       	ldd	r18, Y+58	; 0x3a
    a18a:	3b ad       	ldd	r19, Y+59	; 0x3b
    a18c:	ce 01       	movw	r24, r28
    a18e:	45 96       	adiw	r24, 0x15	; 21
    a190:	b9 01       	movw	r22, r18
    a192:	0e 94 e6 42 	call	0x85cc	; 0x85cc <_ZN9DNSClient13getHostByNameEPKcR9IPAddress>
    a196:	9a 83       	std	Y+2, r25	; 0x02
    a198:	89 83       	std	Y+1, r24	; 0x01
  if (ret == 1) {
    a19a:	89 81       	ldd	r24, Y+1	; 0x01
    a19c:	9a 81       	ldd	r25, Y+2	; 0x02
    a19e:	81 30       	cpi	r24, 0x01	; 1
    a1a0:	91 05       	cpc	r25, r1
    a1a2:	e1 f4       	brne	.+56     	; 0xa1dc <_ZN11EthernetUDP11beginPacketEPKcj+0xae>
    return beginPacket(remote_addr, port);
    a1a4:	88 ad       	ldd	r24, Y+56	; 0x38
    a1a6:	99 ad       	ldd	r25, Y+57	; 0x39
    a1a8:	fc 01       	movw	r30, r24
    a1aa:	80 81       	ld	r24, Z
    a1ac:	91 81       	ldd	r25, Z+1	; 0x01
    a1ae:	40 96       	adiw	r24, 0x10	; 16
    a1b0:	fc 01       	movw	r30, r24
    a1b2:	00 81       	ld	r16, Z
    a1b4:	11 81       	ldd	r17, Z+1	; 0x01
    a1b6:	9e 01       	movw	r18, r28
    a1b8:	21 5f       	subi	r18, 0xF1	; 241
    a1ba:	3f 4f       	sbci	r19, 0xFF	; 255
    a1bc:	ce 01       	movw	r24, r28
    a1be:	03 96       	adiw	r24, 0x03	; 3
    a1c0:	b9 01       	movw	r22, r18
    a1c2:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
    a1c6:	4c ad       	ldd	r20, Y+60	; 0x3c
    a1c8:	5d ad       	ldd	r21, Y+61	; 0x3d
    a1ca:	9e 01       	movw	r18, r28
    a1cc:	2d 5f       	subi	r18, 0xFD	; 253
    a1ce:	3f 4f       	sbci	r19, 0xFF	; 255
    a1d0:	88 ad       	ldd	r24, Y+56	; 0x38
    a1d2:	99 ad       	ldd	r25, Y+57	; 0x39
    a1d4:	b9 01       	movw	r22, r18
    a1d6:	f8 01       	movw	r30, r16
    a1d8:	09 95       	icall
    a1da:	02 c0       	rjmp	.+4      	; 0xa1e0 <_ZN11EthernetUDP11beginPacketEPKcj+0xb2>
  } else {
    return ret;
    a1dc:	89 81       	ldd	r24, Y+1	; 0x01
    a1de:	9a 81       	ldd	r25, Y+2	; 0x02
  }
}
    a1e0:	ed 96       	adiw	r28, 0x3d	; 61
    a1e2:	0f b6       	in	r0, 0x3f	; 63
    a1e4:	f8 94       	cli
    a1e6:	de bf       	out	0x3e, r29	; 62
    a1e8:	0f be       	out	0x3f, r0	; 63
    a1ea:	cd bf       	out	0x3d, r28	; 61
    a1ec:	df 91       	pop	r29
    a1ee:	cf 91       	pop	r28
    a1f0:	1f 91       	pop	r17
    a1f2:	0f 91       	pop	r16
    a1f4:	08 95       	ret

0000a1f6 <_ZN11EthernetUDP11beginPacketE9IPAddressj>:

int EthernetUDP::beginPacket(IPAddress ip, uint16_t port)
{
    a1f6:	cf 93       	push	r28
    a1f8:	df 93       	push	r29
    a1fa:	00 d0       	rcall	.+0      	; 0xa1fc <_ZN11EthernetUDP11beginPacketE9IPAddressj+0x6>
    a1fc:	00 d0       	rcall	.+0      	; 0xa1fe <_ZN11EthernetUDP11beginPacketE9IPAddressj+0x8>
    a1fe:	00 d0       	rcall	.+0      	; 0xa200 <_ZN11EthernetUDP11beginPacketE9IPAddressj+0xa>
    a200:	cd b7       	in	r28, 0x3d	; 61
    a202:	de b7       	in	r29, 0x3e	; 62
    a204:	9a 83       	std	Y+2, r25	; 0x02
    a206:	89 83       	std	Y+1, r24	; 0x01
    a208:	7c 83       	std	Y+4, r23	; 0x04
    a20a:	6b 83       	std	Y+3, r22	; 0x03
    a20c:	5e 83       	std	Y+6, r21	; 0x06
    a20e:	4d 83       	std	Y+5, r20	; 0x05
  _offset = 0;
    a210:	89 81       	ldd	r24, Y+1	; 0x01
    a212:	9a 81       	ldd	r25, Y+2	; 0x02
    a214:	dc 01       	movw	r26, r24
    a216:	58 96       	adiw	r26, 0x18	; 24
    a218:	1c 92       	st	X, r1
    a21a:	1e 92       	st	-X, r1
    a21c:	57 97       	sbiw	r26, 0x17	; 23
  return startUDP(_sock, rawIPAddress(ip), port);
    a21e:	89 81       	ldd	r24, Y+1	; 0x01
    a220:	9a 81       	ldd	r25, Y+2	; 0x02
    a222:	2b 81       	ldd	r18, Y+3	; 0x03
    a224:	3c 81       	ldd	r19, Y+4	; 0x04
    a226:	b9 01       	movw	r22, r18
    a228:	0e 94 5c ac 	call	0x158b8	; 0x158b8 <_ZN3UDP12rawIPAddressER9IPAddress>
    a22c:	29 81       	ldd	r18, Y+1	; 0x01
    a22e:	3a 81       	ldd	r19, Y+2	; 0x02
    a230:	d9 01       	movw	r26, r18
    a232:	1c 96       	adiw	r26, 0x0c	; 12
    a234:	ec 91       	ld	r30, X
    a236:	2d 81       	ldd	r18, Y+5	; 0x05
    a238:	3e 81       	ldd	r19, Y+6	; 0x06
    a23a:	a9 01       	movw	r20, r18
    a23c:	bc 01       	movw	r22, r24
    a23e:	8e 2f       	mov	r24, r30
    a240:	0e 94 90 33 	call	0x6720	; 0x6720 <_Z8startUDPhPhj>
}
    a244:	26 96       	adiw	r28, 0x06	; 6
    a246:	0f b6       	in	r0, 0x3f	; 63
    a248:	f8 94       	cli
    a24a:	de bf       	out	0x3e, r29	; 62
    a24c:	0f be       	out	0x3f, r0	; 63
    a24e:	cd bf       	out	0x3d, r28	; 61
    a250:	df 91       	pop	r29
    a252:	cf 91       	pop	r28
    a254:	08 95       	ret

0000a256 <_ZN11EthernetUDP9endPacketEv>:

int EthernetUDP::endPacket()
{
    a256:	cf 93       	push	r28
    a258:	df 93       	push	r29
    a25a:	00 d0       	rcall	.+0      	; 0xa25c <_ZN11EthernetUDP9endPacketEv+0x6>
    a25c:	cd b7       	in	r28, 0x3d	; 61
    a25e:	de b7       	in	r29, 0x3e	; 62
    a260:	9a 83       	std	Y+2, r25	; 0x02
    a262:	89 83       	std	Y+1, r24	; 0x01
  return sendUDP(_sock);
    a264:	89 81       	ldd	r24, Y+1	; 0x01
    a266:	9a 81       	ldd	r25, Y+2	; 0x02
    a268:	fc 01       	movw	r30, r24
    a26a:	84 85       	ldd	r24, Z+12	; 0x0c
    a26c:	0e 94 d4 33 	call	0x67a8	; 0x67a8 <_Z7sendUDPh>
}
    a270:	0f 90       	pop	r0
    a272:	0f 90       	pop	r0
    a274:	df 91       	pop	r29
    a276:	cf 91       	pop	r28
    a278:	08 95       	ret

0000a27a <_ZN11EthernetUDP5writeEh>:

size_t EthernetUDP::write(uint8_t byte)
{
    a27a:	cf 93       	push	r28
    a27c:	df 93       	push	r29
    a27e:	00 d0       	rcall	.+0      	; 0xa280 <_ZN11EthernetUDP5writeEh+0x6>
    a280:	1f 92       	push	r1
    a282:	cd b7       	in	r28, 0x3d	; 61
    a284:	de b7       	in	r29, 0x3e	; 62
    a286:	9a 83       	std	Y+2, r25	; 0x02
    a288:	89 83       	std	Y+1, r24	; 0x01
    a28a:	6b 83       	std	Y+3, r22	; 0x03
  return write(&byte, 1);
    a28c:	89 81       	ldd	r24, Y+1	; 0x01
    a28e:	9a 81       	ldd	r25, Y+2	; 0x02
    a290:	fc 01       	movw	r30, r24
    a292:	80 81       	ld	r24, Z
    a294:	91 81       	ldd	r25, Z+1	; 0x01
    a296:	02 96       	adiw	r24, 0x02	; 2
    a298:	fc 01       	movw	r30, r24
    a29a:	20 81       	ld	r18, Z
    a29c:	31 81       	ldd	r19, Z+1	; 0x01
    a29e:	be 01       	movw	r22, r28
    a2a0:	6d 5f       	subi	r22, 0xFD	; 253
    a2a2:	7f 4f       	sbci	r23, 0xFF	; 255
    a2a4:	89 81       	ldd	r24, Y+1	; 0x01
    a2a6:	9a 81       	ldd	r25, Y+2	; 0x02
    a2a8:	41 e0       	ldi	r20, 0x01	; 1
    a2aa:	50 e0       	ldi	r21, 0x00	; 0
    a2ac:	f9 01       	movw	r30, r18
    a2ae:	09 95       	icall
}
    a2b0:	0f 90       	pop	r0
    a2b2:	0f 90       	pop	r0
    a2b4:	0f 90       	pop	r0
    a2b6:	df 91       	pop	r29
    a2b8:	cf 91       	pop	r28
    a2ba:	08 95       	ret

0000a2bc <_ZN11EthernetUDP5writeEPKhj>:

size_t EthernetUDP::write(const uint8_t *buffer, size_t size)
{
    a2bc:	cf 93       	push	r28
    a2be:	df 93       	push	r29
    a2c0:	cd b7       	in	r28, 0x3d	; 61
    a2c2:	de b7       	in	r29, 0x3e	; 62
    a2c4:	28 97       	sbiw	r28, 0x08	; 8
    a2c6:	0f b6       	in	r0, 0x3f	; 63
    a2c8:	f8 94       	cli
    a2ca:	de bf       	out	0x3e, r29	; 62
    a2cc:	0f be       	out	0x3f, r0	; 63
    a2ce:	cd bf       	out	0x3d, r28	; 61
    a2d0:	9c 83       	std	Y+4, r25	; 0x04
    a2d2:	8b 83       	std	Y+3, r24	; 0x03
    a2d4:	7e 83       	std	Y+6, r23	; 0x06
    a2d6:	6d 83       	std	Y+5, r22	; 0x05
    a2d8:	58 87       	std	Y+8, r21	; 0x08
    a2da:	4f 83       	std	Y+7, r20	; 0x07
  uint16_t bytes_written = bufferData(_sock, _offset, buffer, size);
    a2dc:	8b 81       	ldd	r24, Y+3	; 0x03
    a2de:	9c 81       	ldd	r25, Y+4	; 0x04
    a2e0:	dc 01       	movw	r26, r24
    a2e2:	57 96       	adiw	r26, 0x17	; 23
    a2e4:	8d 91       	ld	r24, X+
    a2e6:	9c 91       	ld	r25, X
    a2e8:	58 97       	sbiw	r26, 0x18	; 24
    a2ea:	2b 81       	ldd	r18, Y+3	; 0x03
    a2ec:	3c 81       	ldd	r19, Y+4	; 0x04
    a2ee:	d9 01       	movw	r26, r18
    a2f0:	1c 96       	adiw	r26, 0x0c	; 12
    a2f2:	ec 91       	ld	r30, X
    a2f4:	2f 81       	ldd	r18, Y+7	; 0x07
    a2f6:	38 85       	ldd	r19, Y+8	; 0x08
    a2f8:	4d 81       	ldd	r20, Y+5	; 0x05
    a2fa:	5e 81       	ldd	r21, Y+6	; 0x06
    a2fc:	bc 01       	movw	r22, r24
    a2fe:	8e 2f       	mov	r24, r30
    a300:	0e 94 46 33 	call	0x668c	; 0x668c <_Z10bufferDatahjPKhj>
    a304:	9a 83       	std	Y+2, r25	; 0x02
    a306:	89 83       	std	Y+1, r24	; 0x01
  _offset += bytes_written;
    a308:	8b 81       	ldd	r24, Y+3	; 0x03
    a30a:	9c 81       	ldd	r25, Y+4	; 0x04
    a30c:	fc 01       	movw	r30, r24
    a30e:	27 89       	ldd	r18, Z+23	; 0x17
    a310:	30 8d       	ldd	r19, Z+24	; 0x18
    a312:	89 81       	ldd	r24, Y+1	; 0x01
    a314:	9a 81       	ldd	r25, Y+2	; 0x02
    a316:	28 0f       	add	r18, r24
    a318:	39 1f       	adc	r19, r25
    a31a:	8b 81       	ldd	r24, Y+3	; 0x03
    a31c:	9c 81       	ldd	r25, Y+4	; 0x04
    a31e:	dc 01       	movw	r26, r24
    a320:	58 96       	adiw	r26, 0x18	; 24
    a322:	3c 93       	st	X, r19
    a324:	2e 93       	st	-X, r18
    a326:	57 97       	sbiw	r26, 0x17	; 23
  return bytes_written;
    a328:	89 81       	ldd	r24, Y+1	; 0x01
    a32a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    a32c:	28 96       	adiw	r28, 0x08	; 8
    a32e:	0f b6       	in	r0, 0x3f	; 63
    a330:	f8 94       	cli
    a332:	de bf       	out	0x3e, r29	; 62
    a334:	0f be       	out	0x3f, r0	; 63
    a336:	cd bf       	out	0x3d, r28	; 61
    a338:	df 91       	pop	r29
    a33a:	cf 91       	pop	r28
    a33c:	08 95       	ret

0000a33e <_ZN11EthernetUDP11parsePacketEv>:

int EthernetUDP::parsePacket()
{
    a33e:	cf 93       	push	r28
    a340:	df 93       	push	r29
    a342:	cd b7       	in	r28, 0x3d	; 61
    a344:	de b7       	in	r29, 0x3e	; 62
    a346:	2c 97       	sbiw	r28, 0x0c	; 12
    a348:	0f b6       	in	r0, 0x3f	; 63
    a34a:	f8 94       	cli
    a34c:	de bf       	out	0x3e, r29	; 62
    a34e:	0f be       	out	0x3f, r0	; 63
    a350:	cd bf       	out	0x3d, r28	; 61
    a352:	9c 87       	std	Y+12, r25	; 0x0c
    a354:	8b 87       	std	Y+11, r24	; 0x0b
  // discard any remaining bytes in the last packet
  flush();
    a356:	8b 85       	ldd	r24, Y+11	; 0x0b
    a358:	9c 85       	ldd	r25, Y+12	; 0x0c
    a35a:	fc 01       	movw	r30, r24
    a35c:	80 81       	ld	r24, Z
    a35e:	91 81       	ldd	r25, Z+1	; 0x01
    a360:	0a 96       	adiw	r24, 0x0a	; 10
    a362:	fc 01       	movw	r30, r24
    a364:	20 81       	ld	r18, Z
    a366:	31 81       	ldd	r19, Z+1	; 0x01
    a368:	8b 85       	ldd	r24, Y+11	; 0x0b
    a36a:	9c 85       	ldd	r25, Y+12	; 0x0c
    a36c:	f9 01       	movw	r30, r18
    a36e:	09 95       	icall

  if (W5100.getRXReceivedSize(_sock) > 0)
    a370:	8b 85       	ldd	r24, Y+11	; 0x0b
    a372:	9c 85       	ldd	r25, Y+12	; 0x0c
    a374:	fc 01       	movw	r30, r24
    a376:	84 85       	ldd	r24, Z+12	; 0x0c
    a378:	68 2f       	mov	r22, r24
    a37a:	8c e8       	ldi	r24, 0x8C	; 140
    a37c:	97 e0       	ldi	r25, 0x07	; 7
    a37e:	0e 94 9d 34 	call	0x693a	; 0x693a <_ZN10W5100Class17getRXReceivedSizeEh>
    a382:	21 e0       	ldi	r18, 0x01	; 1
    a384:	00 97       	sbiw	r24, 0x00	; 0
    a386:	09 f4       	brne	.+2      	; 0xa38a <_ZN11EthernetUDP11parsePacketEv+0x4c>
    a388:	20 e0       	ldi	r18, 0x00	; 0
    a38a:	22 23       	and	r18, r18
    a38c:	09 f4       	brne	.+2      	; 0xa390 <_ZN11EthernetUDP11parsePacketEv+0x52>
    a38e:	5b c0       	rjmp	.+182    	; 0xa446 <_ZN11EthernetUDP11parsePacketEv+0x108>
  {
    //HACK - hand-parse the UDP packet using TCP recv method
    uint8_t tmpBuf[8];
    int ret =0; 
    a390:	1a 82       	std	Y+2, r1	; 0x02
    a392:	19 82       	std	Y+1, r1	; 0x01
    //read 8 header bytes and get IP and port from it
    ret = recv(_sock,tmpBuf,8);
    a394:	8b 85       	ldd	r24, Y+11	; 0x0b
    a396:	9c 85       	ldd	r25, Y+12	; 0x0c
    a398:	fc 01       	movw	r30, r24
    a39a:	24 85       	ldd	r18, Z+12	; 0x0c
    a39c:	ce 01       	movw	r24, r28
    a39e:	03 96       	adiw	r24, 0x03	; 3
    a3a0:	48 e0       	ldi	r20, 0x08	; 8
    a3a2:	50 e0       	ldi	r21, 0x00	; 0
    a3a4:	bc 01       	movw	r22, r24
    a3a6:	82 2f       	mov	r24, r18
    a3a8:	0e 94 78 30 	call	0x60f0	; 0x60f0 <_Z4recvhPhi>
    a3ac:	9a 83       	std	Y+2, r25	; 0x02
    a3ae:	89 83       	std	Y+1, r24	; 0x01
    if (ret > 0)
    a3b0:	89 81       	ldd	r24, Y+1	; 0x01
    a3b2:	9a 81       	ldd	r25, Y+2	; 0x02
    a3b4:	18 16       	cp	r1, r24
    a3b6:	19 06       	cpc	r1, r25
    a3b8:	0c f0       	brlt	.+2      	; 0xa3bc <_ZN11EthernetUDP11parsePacketEv+0x7e>
    a3ba:	42 c0       	rjmp	.+132    	; 0xa440 <_ZN11EthernetUDP11parsePacketEv+0x102>
    {
      _remoteIP = tmpBuf;
    a3bc:	8b 85       	ldd	r24, Y+11	; 0x0b
    a3be:	9c 85       	ldd	r25, Y+12	; 0x0c
    a3c0:	0f 96       	adiw	r24, 0x0f	; 15
    a3c2:	9e 01       	movw	r18, r28
    a3c4:	2d 5f       	subi	r18, 0xFD	; 253
    a3c6:	3f 4f       	sbci	r19, 0xFF	; 255
    a3c8:	b9 01       	movw	r22, r18
    a3ca:	0e 94 35 5a 	call	0xb46a	; 0xb46a <_ZN9IPAddressaSEPKh>
      _remotePort = tmpBuf[4];
    a3ce:	8f 81       	ldd	r24, Y+7	; 0x07
    a3d0:	28 2f       	mov	r18, r24
    a3d2:	30 e0       	ldi	r19, 0x00	; 0
    a3d4:	8b 85       	ldd	r24, Y+11	; 0x0b
    a3d6:	9c 85       	ldd	r25, Y+12	; 0x0c
    a3d8:	fc 01       	movw	r30, r24
    a3da:	36 8b       	std	Z+22, r19	; 0x16
    a3dc:	25 8b       	std	Z+21, r18	; 0x15
      _remotePort = (_remotePort << 8) + tmpBuf[5];
    a3de:	8b 85       	ldd	r24, Y+11	; 0x0b
    a3e0:	9c 85       	ldd	r25, Y+12	; 0x0c
    a3e2:	fc 01       	movw	r30, r24
    a3e4:	85 89       	ldd	r24, Z+21	; 0x15
    a3e6:	96 89       	ldd	r25, Z+22	; 0x16
    a3e8:	38 2f       	mov	r19, r24
    a3ea:	22 27       	eor	r18, r18
    a3ec:	88 85       	ldd	r24, Y+8	; 0x08
    a3ee:	88 2f       	mov	r24, r24
    a3f0:	90 e0       	ldi	r25, 0x00	; 0
    a3f2:	28 0f       	add	r18, r24
    a3f4:	39 1f       	adc	r19, r25
    a3f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    a3f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    a3fa:	fc 01       	movw	r30, r24
    a3fc:	36 8b       	std	Z+22, r19	; 0x16
    a3fe:	25 8b       	std	Z+21, r18	; 0x15
      _remaining = tmpBuf[6];
    a400:	89 85       	ldd	r24, Y+9	; 0x09
    a402:	28 2f       	mov	r18, r24
    a404:	30 e0       	ldi	r19, 0x00	; 0
    a406:	8b 85       	ldd	r24, Y+11	; 0x0b
    a408:	9c 85       	ldd	r25, Y+12	; 0x0c
    a40a:	fc 01       	movw	r30, r24
    a40c:	32 8f       	std	Z+26, r19	; 0x1a
    a40e:	21 8f       	std	Z+25, r18	; 0x19
      _remaining = (_remaining << 8) + tmpBuf[7];
    a410:	8b 85       	ldd	r24, Y+11	; 0x0b
    a412:	9c 85       	ldd	r25, Y+12	; 0x0c
    a414:	fc 01       	movw	r30, r24
    a416:	81 8d       	ldd	r24, Z+25	; 0x19
    a418:	92 8d       	ldd	r25, Z+26	; 0x1a
    a41a:	38 2f       	mov	r19, r24
    a41c:	22 27       	eor	r18, r18
    a41e:	8a 85       	ldd	r24, Y+10	; 0x0a
    a420:	88 2f       	mov	r24, r24
    a422:	90 e0       	ldi	r25, 0x00	; 0
    a424:	28 0f       	add	r18, r24
    a426:	39 1f       	adc	r19, r25
    a428:	8b 85       	ldd	r24, Y+11	; 0x0b
    a42a:	9c 85       	ldd	r25, Y+12	; 0x0c
    a42c:	fc 01       	movw	r30, r24
    a42e:	32 8f       	std	Z+26, r19	; 0x1a
    a430:	21 8f       	std	Z+25, r18	; 0x19

      // When we get here, any remaining bytes are the data
      ret = _remaining;
    a432:	8b 85       	ldd	r24, Y+11	; 0x0b
    a434:	9c 85       	ldd	r25, Y+12	; 0x0c
    a436:	fc 01       	movw	r30, r24
    a438:	81 8d       	ldd	r24, Z+25	; 0x19
    a43a:	92 8d       	ldd	r25, Z+26	; 0x1a
    a43c:	9a 83       	std	Y+2, r25	; 0x02
    a43e:	89 83       	std	Y+1, r24	; 0x01
    }
    return ret;
    a440:	89 81       	ldd	r24, Y+1	; 0x01
    a442:	9a 81       	ldd	r25, Y+2	; 0x02
    a444:	02 c0       	rjmp	.+4      	; 0xa44a <_ZN11EthernetUDP11parsePacketEv+0x10c>
  }
  // There aren't any packets available
  return 0;
    a446:	80 e0       	ldi	r24, 0x00	; 0
    a448:	90 e0       	ldi	r25, 0x00	; 0
}
    a44a:	2c 96       	adiw	r28, 0x0c	; 12
    a44c:	0f b6       	in	r0, 0x3f	; 63
    a44e:	f8 94       	cli
    a450:	de bf       	out	0x3e, r29	; 62
    a452:	0f be       	out	0x3f, r0	; 63
    a454:	cd bf       	out	0x3d, r28	; 61
    a456:	df 91       	pop	r29
    a458:	cf 91       	pop	r28
    a45a:	08 95       	ret

0000a45c <_ZN11EthernetUDP4readEv>:

int EthernetUDP::read()
{
    a45c:	cf 93       	push	r28
    a45e:	df 93       	push	r29
    a460:	00 d0       	rcall	.+0      	; 0xa462 <_ZN11EthernetUDP4readEv+0x6>
    a462:	1f 92       	push	r1
    a464:	cd b7       	in	r28, 0x3d	; 61
    a466:	de b7       	in	r29, 0x3e	; 62
    a468:	9b 83       	std	Y+3, r25	; 0x03
    a46a:	8a 83       	std	Y+2, r24	; 0x02
  uint8_t byte;

  if ((_remaining > 0) && (recv(_sock, &byte, 1) > 0))
    a46c:	8a 81       	ldd	r24, Y+2	; 0x02
    a46e:	9b 81       	ldd	r25, Y+3	; 0x03
    a470:	fc 01       	movw	r30, r24
    a472:	81 8d       	ldd	r24, Z+25	; 0x19
    a474:	92 8d       	ldd	r25, Z+26	; 0x1a
    a476:	00 97       	sbiw	r24, 0x00	; 0
    a478:	89 f0       	breq	.+34     	; 0xa49c <_ZN11EthernetUDP4readEv+0x40>
    a47a:	8a 81       	ldd	r24, Y+2	; 0x02
    a47c:	9b 81       	ldd	r25, Y+3	; 0x03
    a47e:	fc 01       	movw	r30, r24
    a480:	24 85       	ldd	r18, Z+12	; 0x0c
    a482:	41 e0       	ldi	r20, 0x01	; 1
    a484:	50 e0       	ldi	r21, 0x00	; 0
    a486:	ce 01       	movw	r24, r28
    a488:	01 96       	adiw	r24, 0x01	; 1
    a48a:	bc 01       	movw	r22, r24
    a48c:	82 2f       	mov	r24, r18
    a48e:	0e 94 78 30 	call	0x60f0	; 0x60f0 <_Z4recvhPhi>
    a492:	18 16       	cp	r1, r24
    a494:	19 06       	cpc	r1, r25
    a496:	14 f4       	brge	.+4      	; 0xa49c <_ZN11EthernetUDP4readEv+0x40>
    a498:	81 e0       	ldi	r24, 0x01	; 1
    a49a:	01 c0       	rjmp	.+2      	; 0xa49e <_ZN11EthernetUDP4readEv+0x42>
    a49c:	80 e0       	ldi	r24, 0x00	; 0
    a49e:	88 23       	and	r24, r24
    a4a0:	89 f0       	breq	.+34     	; 0xa4c4 <_ZN11EthernetUDP4readEv+0x68>
  {
    // We read things without any problems
    _remaining--;
    a4a2:	8a 81       	ldd	r24, Y+2	; 0x02
    a4a4:	9b 81       	ldd	r25, Y+3	; 0x03
    a4a6:	fc 01       	movw	r30, r24
    a4a8:	81 8d       	ldd	r24, Z+25	; 0x19
    a4aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    a4ac:	9c 01       	movw	r18, r24
    a4ae:	21 50       	subi	r18, 0x01	; 1
    a4b0:	31 09       	sbc	r19, r1
    a4b2:	8a 81       	ldd	r24, Y+2	; 0x02
    a4b4:	9b 81       	ldd	r25, Y+3	; 0x03
    a4b6:	fc 01       	movw	r30, r24
    a4b8:	32 8f       	std	Z+26, r19	; 0x1a
    a4ba:	21 8f       	std	Z+25, r18	; 0x19
    return byte;
    a4bc:	89 81       	ldd	r24, Y+1	; 0x01
    a4be:	88 2f       	mov	r24, r24
    a4c0:	90 e0       	ldi	r25, 0x00	; 0
    a4c2:	02 c0       	rjmp	.+4      	; 0xa4c8 <_ZN11EthernetUDP4readEv+0x6c>
  }

  // If we get here, there's no data available
  return -1;
    a4c4:	8f ef       	ldi	r24, 0xFF	; 255
    a4c6:	9f ef       	ldi	r25, 0xFF	; 255
}
    a4c8:	0f 90       	pop	r0
    a4ca:	0f 90       	pop	r0
    a4cc:	0f 90       	pop	r0
    a4ce:	df 91       	pop	r29
    a4d0:	cf 91       	pop	r28
    a4d2:	08 95       	ret

0000a4d4 <_ZN11EthernetUDP4readEPhj>:

int EthernetUDP::read(unsigned char* buffer, size_t len)
{
    a4d4:	cf 93       	push	r28
    a4d6:	df 93       	push	r29
    a4d8:	cd b7       	in	r28, 0x3d	; 61
    a4da:	de b7       	in	r29, 0x3e	; 62
    a4dc:	28 97       	sbiw	r28, 0x08	; 8
    a4de:	0f b6       	in	r0, 0x3f	; 63
    a4e0:	f8 94       	cli
    a4e2:	de bf       	out	0x3e, r29	; 62
    a4e4:	0f be       	out	0x3f, r0	; 63
    a4e6:	cd bf       	out	0x3d, r28	; 61
    a4e8:	9c 83       	std	Y+4, r25	; 0x04
    a4ea:	8b 83       	std	Y+3, r24	; 0x03
    a4ec:	7e 83       	std	Y+6, r23	; 0x06
    a4ee:	6d 83       	std	Y+5, r22	; 0x05
    a4f0:	58 87       	std	Y+8, r21	; 0x08
    a4f2:	4f 83       	std	Y+7, r20	; 0x07

  if (_remaining > 0)
    a4f4:	8b 81       	ldd	r24, Y+3	; 0x03
    a4f6:	9c 81       	ldd	r25, Y+4	; 0x04
    a4f8:	dc 01       	movw	r26, r24
    a4fa:	59 96       	adiw	r26, 0x19	; 25
    a4fc:	8d 91       	ld	r24, X+
    a4fe:	9c 91       	ld	r25, X
    a500:	5a 97       	sbiw	r26, 0x1a	; 26
    a502:	00 97       	sbiw	r24, 0x00	; 0
    a504:	09 f4       	brne	.+2      	; 0xa508 <_ZN11EthernetUDP4readEPhj+0x34>
    a506:	49 c0       	rjmp	.+146    	; 0xa59a <_ZN11EthernetUDP4readEPhj+0xc6>
  {

    int got;

    if (_remaining <= len)
    a508:	8b 81       	ldd	r24, Y+3	; 0x03
    a50a:	9c 81       	ldd	r25, Y+4	; 0x04
    a50c:	fc 01       	movw	r30, r24
    a50e:	21 8d       	ldd	r18, Z+25	; 0x19
    a510:	32 8d       	ldd	r19, Z+26	; 0x1a
    a512:	8f 81       	ldd	r24, Y+7	; 0x07
    a514:	98 85       	ldd	r25, Y+8	; 0x08
    a516:	82 17       	cp	r24, r18
    a518:	93 07       	cpc	r25, r19
    a51a:	b8 f0       	brcs	.+46     	; 0xa54a <_ZN11EthernetUDP4readEPhj+0x76>
    {
      // data should fit in the buffer
      got = recv(_sock, buffer, _remaining);
    a51c:	8b 81       	ldd	r24, Y+3	; 0x03
    a51e:	9c 81       	ldd	r25, Y+4	; 0x04
    a520:	dc 01       	movw	r26, r24
    a522:	59 96       	adiw	r26, 0x19	; 25
    a524:	8d 91       	ld	r24, X+
    a526:	9c 91       	ld	r25, X
    a528:	5a 97       	sbiw	r26, 0x1a	; 26
    a52a:	9c 01       	movw	r18, r24
    a52c:	8b 81       	ldd	r24, Y+3	; 0x03
    a52e:	9c 81       	ldd	r25, Y+4	; 0x04
    a530:	dc 01       	movw	r26, r24
    a532:	1c 96       	adiw	r26, 0x0c	; 12
    a534:	ec 91       	ld	r30, X
    a536:	8d 81       	ldd	r24, Y+5	; 0x05
    a538:	9e 81       	ldd	r25, Y+6	; 0x06
    a53a:	a9 01       	movw	r20, r18
    a53c:	bc 01       	movw	r22, r24
    a53e:	8e 2f       	mov	r24, r30
    a540:	0e 94 78 30 	call	0x60f0	; 0x60f0 <_Z4recvhPhi>
    a544:	9a 83       	std	Y+2, r25	; 0x02
    a546:	89 83       	std	Y+1, r24	; 0x01
    a548:	10 c0       	rjmp	.+32     	; 0xa56a <_ZN11EthernetUDP4readEPhj+0x96>
    }
    else
    {
      // too much data for the buffer, 
      // grab as much as will fit
      got = recv(_sock, buffer, len);
    a54a:	2f 81       	ldd	r18, Y+7	; 0x07
    a54c:	38 85       	ldd	r19, Y+8	; 0x08
    a54e:	8b 81       	ldd	r24, Y+3	; 0x03
    a550:	9c 81       	ldd	r25, Y+4	; 0x04
    a552:	dc 01       	movw	r26, r24
    a554:	1c 96       	adiw	r26, 0x0c	; 12
    a556:	ec 91       	ld	r30, X
    a558:	8d 81       	ldd	r24, Y+5	; 0x05
    a55a:	9e 81       	ldd	r25, Y+6	; 0x06
    a55c:	a9 01       	movw	r20, r18
    a55e:	bc 01       	movw	r22, r24
    a560:	8e 2f       	mov	r24, r30
    a562:	0e 94 78 30 	call	0x60f0	; 0x60f0 <_Z4recvhPhi>
    a566:	9a 83       	std	Y+2, r25	; 0x02
    a568:	89 83       	std	Y+1, r24	; 0x01
    }

    if (got > 0)
    a56a:	89 81       	ldd	r24, Y+1	; 0x01
    a56c:	9a 81       	ldd	r25, Y+2	; 0x02
    a56e:	18 16       	cp	r1, r24
    a570:	19 06       	cpc	r1, r25
    a572:	9c f4       	brge	.+38     	; 0xa59a <_ZN11EthernetUDP4readEPhj+0xc6>
    {
      _remaining -= got;
    a574:	8b 81       	ldd	r24, Y+3	; 0x03
    a576:	9c 81       	ldd	r25, Y+4	; 0x04
    a578:	fc 01       	movw	r30, r24
    a57a:	21 8d       	ldd	r18, Z+25	; 0x19
    a57c:	32 8d       	ldd	r19, Z+26	; 0x1a
    a57e:	89 81       	ldd	r24, Y+1	; 0x01
    a580:	9a 81       	ldd	r25, Y+2	; 0x02
    a582:	28 1b       	sub	r18, r24
    a584:	39 0b       	sbc	r19, r25
    a586:	8b 81       	ldd	r24, Y+3	; 0x03
    a588:	9c 81       	ldd	r25, Y+4	; 0x04
    a58a:	dc 01       	movw	r26, r24
    a58c:	5a 96       	adiw	r26, 0x1a	; 26
    a58e:	3c 93       	st	X, r19
    a590:	2e 93       	st	-X, r18
    a592:	59 97       	sbiw	r26, 0x19	; 25
      return got;
    a594:	89 81       	ldd	r24, Y+1	; 0x01
    a596:	9a 81       	ldd	r25, Y+2	; 0x02
    a598:	02 c0       	rjmp	.+4      	; 0xa59e <_ZN11EthernetUDP4readEPhj+0xca>
    }

  }

  // If we get here, there's no data available or recv failed
  return -1;
    a59a:	8f ef       	ldi	r24, 0xFF	; 255
    a59c:	9f ef       	ldi	r25, 0xFF	; 255

}
    a59e:	28 96       	adiw	r28, 0x08	; 8
    a5a0:	0f b6       	in	r0, 0x3f	; 63
    a5a2:	f8 94       	cli
    a5a4:	de bf       	out	0x3e, r29	; 62
    a5a6:	0f be       	out	0x3f, r0	; 63
    a5a8:	cd bf       	out	0x3d, r28	; 61
    a5aa:	df 91       	pop	r29
    a5ac:	cf 91       	pop	r28
    a5ae:	08 95       	ret

0000a5b0 <_ZN11EthernetUDP4peekEv>:

int EthernetUDP::peek()
{
    a5b0:	cf 93       	push	r28
    a5b2:	df 93       	push	r29
    a5b4:	00 d0       	rcall	.+0      	; 0xa5b6 <_ZN11EthernetUDP4peekEv+0x6>
    a5b6:	1f 92       	push	r1
    a5b8:	cd b7       	in	r28, 0x3d	; 61
    a5ba:	de b7       	in	r29, 0x3e	; 62
    a5bc:	9b 83       	std	Y+3, r25	; 0x03
    a5be:	8a 83       	std	Y+2, r24	; 0x02
  uint8_t b;
  // Unlike recv, peek doesn't check to see if there's any data available, so we must.
  // If the user hasn't called parsePacket yet then return nothing otherwise they
  // may get the UDP header
  if (!_remaining)
    a5c0:	8a 81       	ldd	r24, Y+2	; 0x02
    a5c2:	9b 81       	ldd	r25, Y+3	; 0x03
    a5c4:	fc 01       	movw	r30, r24
    a5c6:	81 8d       	ldd	r24, Z+25	; 0x19
    a5c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    a5ca:	00 97       	sbiw	r24, 0x00	; 0
    a5cc:	19 f4       	brne	.+6      	; 0xa5d4 <_ZN11EthernetUDP4peekEv+0x24>
    return -1;
    a5ce:	8f ef       	ldi	r24, 0xFF	; 255
    a5d0:	9f ef       	ldi	r25, 0xFF	; 255
    a5d2:	0d c0       	rjmp	.+26     	; 0xa5ee <_ZN11EthernetUDP4peekEv+0x3e>
  ::peek(_sock, &b);
    a5d4:	8a 81       	ldd	r24, Y+2	; 0x02
    a5d6:	9b 81       	ldd	r25, Y+3	; 0x03
    a5d8:	fc 01       	movw	r30, r24
    a5da:	24 85       	ldd	r18, Z+12	; 0x0c
    a5dc:	ce 01       	movw	r24, r28
    a5de:	01 96       	adiw	r24, 0x01	; 1
    a5e0:	bc 01       	movw	r22, r24
    a5e2:	82 2f       	mov	r24, r18
    a5e4:	0e 94 d5 30 	call	0x61aa	; 0x61aa <_Z4peekhPh>
  return b;
    a5e8:	89 81       	ldd	r24, Y+1	; 0x01
    a5ea:	88 2f       	mov	r24, r24
    a5ec:	90 e0       	ldi	r25, 0x00	; 0
}
    a5ee:	0f 90       	pop	r0
    a5f0:	0f 90       	pop	r0
    a5f2:	0f 90       	pop	r0
    a5f4:	df 91       	pop	r29
    a5f6:	cf 91       	pop	r28
    a5f8:	08 95       	ret

0000a5fa <_ZN11EthernetUDP5flushEv>:

void EthernetUDP::flush()
{
    a5fa:	cf 93       	push	r28
    a5fc:	df 93       	push	r29
    a5fe:	00 d0       	rcall	.+0      	; 0xa600 <_ZN11EthernetUDP5flushEv+0x6>
    a600:	cd b7       	in	r28, 0x3d	; 61
    a602:	de b7       	in	r29, 0x3e	; 62
    a604:	9a 83       	std	Y+2, r25	; 0x02
    a606:	89 83       	std	Y+1, r24	; 0x01
  // could this fail (loop endlessly) if _remaining > 0 and recv in read fails?
  // should only occur if recv fails after telling us the data is there, lets
  // hope the w5100 always behaves :)

  while (_remaining)
    a608:	0d c0       	rjmp	.+26     	; 0xa624 <_ZN11EthernetUDP5flushEv+0x2a>
  {
    read();
    a60a:	89 81       	ldd	r24, Y+1	; 0x01
    a60c:	9a 81       	ldd	r25, Y+2	; 0x02
    a60e:	fc 01       	movw	r30, r24
    a610:	80 81       	ld	r24, Z
    a612:	91 81       	ldd	r25, Z+1	; 0x01
    a614:	06 96       	adiw	r24, 0x06	; 6
    a616:	fc 01       	movw	r30, r24
    a618:	20 81       	ld	r18, Z
    a61a:	31 81       	ldd	r19, Z+1	; 0x01
    a61c:	89 81       	ldd	r24, Y+1	; 0x01
    a61e:	9a 81       	ldd	r25, Y+2	; 0x02
    a620:	f9 01       	movw	r30, r18
    a622:	09 95       	icall
{
  // could this fail (loop endlessly) if _remaining > 0 and recv in read fails?
  // should only occur if recv fails after telling us the data is there, lets
  // hope the w5100 always behaves :)

  while (_remaining)
    a624:	89 81       	ldd	r24, Y+1	; 0x01
    a626:	9a 81       	ldd	r25, Y+2	; 0x02
    a628:	fc 01       	movw	r30, r24
    a62a:	81 8d       	ldd	r24, Z+25	; 0x19
    a62c:	92 8d       	ldd	r25, Z+26	; 0x1a
    a62e:	21 e0       	ldi	r18, 0x01	; 1
    a630:	00 97       	sbiw	r24, 0x00	; 0
    a632:	09 f4       	brne	.+2      	; 0xa636 <_ZN11EthernetUDP5flushEv+0x3c>
    a634:	20 e0       	ldi	r18, 0x00	; 0
    a636:	22 23       	and	r18, r18
    a638:	41 f7       	brne	.-48     	; 0xa60a <_ZN11EthernetUDP5flushEv+0x10>
  {
    read();
  }
}
    a63a:	0f 90       	pop	r0
    a63c:	0f 90       	pop	r0
    a63e:	df 91       	pop	r29
    a640:	cf 91       	pop	r28
    a642:	08 95       	ret

0000a644 <_Z41__static_initialization_and_destruction_0ii>:
    a644:	0f 93       	push	r16
    a646:	cf 93       	push	r28
    a648:	df 93       	push	r29
    a64a:	00 d0       	rcall	.+0      	; 0xa64c <_Z41__static_initialization_and_destruction_0ii+0x8>
    a64c:	00 d0       	rcall	.+0      	; 0xa64e <_Z41__static_initialization_and_destruction_0ii+0xa>
    a64e:	cd b7       	in	r28, 0x3d	; 61
    a650:	de b7       	in	r29, 0x3e	; 62
    a652:	9a 83       	std	Y+2, r25	; 0x02
    a654:	89 83       	std	Y+1, r24	; 0x01
    a656:	7c 83       	std	Y+4, r23	; 0x04
    a658:	6b 83       	std	Y+3, r22	; 0x03
    a65a:	89 81       	ldd	r24, Y+1	; 0x01
    a65c:	9a 81       	ldd	r25, Y+2	; 0x02
    a65e:	81 30       	cpi	r24, 0x01	; 1
    a660:	91 05       	cpc	r25, r1
    a662:	71 f4       	brne	.+28     	; 0xa680 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    a664:	8b 81       	ldd	r24, Y+3	; 0x03
    a666:	9c 81       	ldd	r25, Y+4	; 0x04
    a668:	8f 3f       	cpi	r24, 0xFF	; 255
    a66a:	2f ef       	ldi	r18, 0xFF	; 255
    a66c:	92 07       	cpc	r25, r18
    a66e:	41 f4       	brne	.+16     	; 0xa680 <_Z41__static_initialization_and_destruction_0ii+0x3c>
    a670:	00 e0       	ldi	r16, 0x00	; 0
    a672:	20 e0       	ldi	r18, 0x00	; 0
    a674:	40 e0       	ldi	r20, 0x00	; 0
    a676:	60 e0       	ldi	r22, 0x00	; 0
    a678:	88 e3       	ldi	r24, 0x38	; 56
    a67a:	98 e0       	ldi	r25, 0x08	; 8
    a67c:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    a680:	0f 90       	pop	r0
    a682:	0f 90       	pop	r0
    a684:	0f 90       	pop	r0
    a686:	0f 90       	pop	r0
    a688:	df 91       	pop	r29
    a68a:	cf 91       	pop	r28
    a68c:	0f 91       	pop	r16
    a68e:	08 95       	ret

0000a690 <_GLOBAL__sub_I__ZN11EthernetUDPC2Ev>:
    a690:	cf 93       	push	r28
    a692:	df 93       	push	r29
    a694:	cd b7       	in	r28, 0x3d	; 61
    a696:	de b7       	in	r29, 0x3e	; 62
    a698:	6f ef       	ldi	r22, 0xFF	; 255
    a69a:	7f ef       	ldi	r23, 0xFF	; 255
    a69c:	81 e0       	ldi	r24, 0x01	; 1
    a69e:	90 e0       	ldi	r25, 0x00	; 0
    a6a0:	0e 94 22 53 	call	0xa644	; 0xa644 <_Z41__static_initialization_and_destruction_0ii>
    a6a4:	df 91       	pop	r29
    a6a6:	cf 91       	pop	r28
    a6a8:	08 95       	ret

0000a6aa <_ZN11EEPROMClass4readEi>:
/******************************************************************************
 * User API
 ******************************************************************************/

uint8_t EEPROMClass::read(int address)
{
    a6aa:	cf 93       	push	r28
    a6ac:	df 93       	push	r29
    a6ae:	00 d0       	rcall	.+0      	; 0xa6b0 <_ZN11EEPROMClass4readEi+0x6>
    a6b0:	00 d0       	rcall	.+0      	; 0xa6b2 <_ZN11EEPROMClass4readEi+0x8>
    a6b2:	cd b7       	in	r28, 0x3d	; 61
    a6b4:	de b7       	in	r29, 0x3e	; 62
    a6b6:	9a 83       	std	Y+2, r25	; 0x02
    a6b8:	89 83       	std	Y+1, r24	; 0x01
    a6ba:	7c 83       	std	Y+4, r23	; 0x04
    a6bc:	6b 83       	std	Y+3, r22	; 0x03
	return eeprom_read_byte((unsigned char *) address);
    a6be:	8b 81       	ldd	r24, Y+3	; 0x03
    a6c0:	9c 81       	ldd	r25, Y+4	; 0x04
    a6c2:	0e 94 2b b2 	call	0x16456	; 0x16456 <__eerd_byte_m328p>
}
    a6c6:	0f 90       	pop	r0
    a6c8:	0f 90       	pop	r0
    a6ca:	0f 90       	pop	r0
    a6cc:	0f 90       	pop	r0
    a6ce:	df 91       	pop	r29
    a6d0:	cf 91       	pop	r28
    a6d2:	08 95       	ret

0000a6d4 <_ZN11EEPROMClass5writeEih>:

void EEPROMClass::write(int address, uint8_t value)
{
    a6d4:	cf 93       	push	r28
    a6d6:	df 93       	push	r29
    a6d8:	00 d0       	rcall	.+0      	; 0xa6da <_ZN11EEPROMClass5writeEih+0x6>
    a6da:	00 d0       	rcall	.+0      	; 0xa6dc <_ZN11EEPROMClass5writeEih+0x8>
    a6dc:	1f 92       	push	r1
    a6de:	cd b7       	in	r28, 0x3d	; 61
    a6e0:	de b7       	in	r29, 0x3e	; 62
    a6e2:	9a 83       	std	Y+2, r25	; 0x02
    a6e4:	89 83       	std	Y+1, r24	; 0x01
    a6e6:	7c 83       	std	Y+4, r23	; 0x04
    a6e8:	6b 83       	std	Y+3, r22	; 0x03
    a6ea:	4d 83       	std	Y+5, r20	; 0x05
	eeprom_write_byte((unsigned char *) address, value);
    a6ec:	8b 81       	ldd	r24, Y+3	; 0x03
    a6ee:	9c 81       	ldd	r25, Y+4	; 0x04
    a6f0:	6d 81       	ldd	r22, Y+5	; 0x05
    a6f2:	0e 94 33 b2 	call	0x16466	; 0x16466 <__eewr_byte_m328p>
}
    a6f6:	0f 90       	pop	r0
    a6f8:	0f 90       	pop	r0
    a6fa:	0f 90       	pop	r0
    a6fc:	0f 90       	pop	r0
    a6fe:	0f 90       	pop	r0
    a700:	df 91       	pop	r29
    a702:	cf 91       	pop	r28
    a704:	08 95       	ret

0000a706 <_Z11serialEventv>:
    a706:	cf 93       	push	r28
    a708:	df 93       	push	r29
    a70a:	cd b7       	in	r28, 0x3d	; 61
    a70c:	de b7       	in	r29, 0x3e	; 62
    a70e:	df 91       	pop	r29
    a710:	cf 91       	pop	r28
    a712:	08 95       	ret

0000a714 <__vector_18>:
#elif defined(USART0_RX_vect)
  SIGNAL(USART0_RX_vect)
#elif defined(SIG_UART_RECV)
  SIGNAL(SIG_UART_RECV)
#endif
  {
    a714:	1f 92       	push	r1
    a716:	0f 92       	push	r0
    a718:	00 90 5f 00 	lds	r0, 0x005F
    a71c:	0f 92       	push	r0
    a71e:	11 24       	eor	r1, r1
    a720:	2f 93       	push	r18
    a722:	3f 93       	push	r19
    a724:	4f 93       	push	r20
    a726:	5f 93       	push	r21
    a728:	6f 93       	push	r22
    a72a:	7f 93       	push	r23
    a72c:	8f 93       	push	r24
    a72e:	9f 93       	push	r25
    a730:	af 93       	push	r26
    a732:	bf 93       	push	r27
    a734:	ef 93       	push	r30
    a736:	ff 93       	push	r31
    a738:	cf 93       	push	r28
    a73a:	df 93       	push	r29
    a73c:	00 d0       	rcall	.+0      	; 0xa73e <__vector_18+0x2a>
    a73e:	cd b7       	in	r28, 0x3d	; 61
    a740:	de b7       	in	r29, 0x3e	; 62
  #if defined(UDR0)
    if (bit_is_clear(UCSR0A, UPE0)) {
    a742:	80 ec       	ldi	r24, 0xC0	; 192
    a744:	90 e0       	ldi	r25, 0x00	; 0
    a746:	fc 01       	movw	r30, r24
    a748:	80 81       	ld	r24, Z
    a74a:	88 2f       	mov	r24, r24
    a74c:	90 e0       	ldi	r25, 0x00	; 0
    a74e:	84 70       	andi	r24, 0x04	; 4
    a750:	99 27       	eor	r25, r25
    a752:	21 e0       	ldi	r18, 0x01	; 1
    a754:	00 97       	sbiw	r24, 0x00	; 0
    a756:	09 f0       	breq	.+2      	; 0xa75a <__vector_18+0x46>
    a758:	20 e0       	ldi	r18, 0x00	; 0
    a75a:	22 23       	and	r18, r18
    a75c:	59 f0       	breq	.+22     	; 0xa774 <__vector_18+0x60>
      unsigned char c = UDR0;
    a75e:	86 ec       	ldi	r24, 0xC6	; 198
    a760:	90 e0       	ldi	r25, 0x00	; 0
    a762:	fc 01       	movw	r30, r24
    a764:	80 81       	ld	r24, Z
    a766:	89 83       	std	Y+1, r24	; 0x01
      store_char(c, &rx_buffer);
    a768:	6f e3       	ldi	r22, 0x3F	; 63
    a76a:	78 e0       	ldi	r23, 0x08	; 8
    a76c:	89 81       	ldd	r24, Y+1	; 0x01
    a76e:	0e 94 af ac 	call	0x1595e	; 0x1595e <_Z10store_charhP11ring_buffer>
    a772:	05 c0       	rjmp	.+10     	; 0xa77e <__vector_18+0x6a>
    } else {
      unsigned char c = UDR0;
    a774:	86 ec       	ldi	r24, 0xC6	; 198
    a776:	90 e0       	ldi	r25, 0x00	; 0
    a778:	fc 01       	movw	r30, r24
    a77a:	80 81       	ld	r24, Z
    a77c:	8a 83       	std	Y+2, r24	; 0x02
      unsigned char c = UDR;
    };
  #else
    #error UDR not defined
  #endif
  }
    a77e:	0f 90       	pop	r0
    a780:	0f 90       	pop	r0
    a782:	df 91       	pop	r29
    a784:	cf 91       	pop	r28
    a786:	ff 91       	pop	r31
    a788:	ef 91       	pop	r30
    a78a:	bf 91       	pop	r27
    a78c:	af 91       	pop	r26
    a78e:	9f 91       	pop	r25
    a790:	8f 91       	pop	r24
    a792:	7f 91       	pop	r23
    a794:	6f 91       	pop	r22
    a796:	5f 91       	pop	r21
    a798:	4f 91       	pop	r20
    a79a:	3f 91       	pop	r19
    a79c:	2f 91       	pop	r18
    a79e:	0f 90       	pop	r0
    a7a0:	00 92 5f 00 	sts	0x005F, r0
    a7a4:	0f 90       	pop	r0
    a7a6:	1f 90       	pop	r1
    a7a8:	18 95       	reti

0000a7aa <_Z14serialEventRunv>:
#elif defined(SIG_USART3_RECV)
  #error SIG_USART3_RECV
#endif

void serialEventRun(void)
{
    a7aa:	cf 93       	push	r28
    a7ac:	df 93       	push	r29
    a7ae:	cd b7       	in	r28, 0x3d	; 61
    a7b0:	de b7       	in	r29, 0x3e	; 62
#ifdef serialEvent_implemented
  if (Serial.available()) serialEvent();
    a7b2:	87 ec       	ldi	r24, 0xC7	; 199
    a7b4:	98 e0       	ldi	r25, 0x08	; 8
    a7b6:	0e 94 a0 57 	call	0xaf40	; 0xaf40 <_ZN14HardwareSerial9availableEv>
    a7ba:	21 e0       	ldi	r18, 0x01	; 1
    a7bc:	00 97       	sbiw	r24, 0x00	; 0
    a7be:	09 f4       	brne	.+2      	; 0xa7c2 <_Z14serialEventRunv+0x18>
    a7c0:	20 e0       	ldi	r18, 0x00	; 0
    a7c2:	22 23       	and	r18, r18
    a7c4:	11 f0       	breq	.+4      	; 0xa7ca <_Z14serialEventRunv+0x20>
    a7c6:	0e 94 83 53 	call	0xa706	; 0xa706 <_Z11serialEventv>
  if (Serial2.available()) serialEvent2();
#endif
#ifdef serialEvent3_implemented
  if (Serial3.available()) serialEvent3();
#endif
}
    a7ca:	df 91       	pop	r29
    a7cc:	cf 91       	pop	r28
    a7ce:	08 95       	ret

0000a7d0 <__vector_19>:
#elif defined(USART0_UDRE_vect)
ISR(USART0_UDRE_vect)
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#endif
{
    a7d0:	1f 92       	push	r1
    a7d2:	0f 92       	push	r0
    a7d4:	00 90 5f 00 	lds	r0, 0x005F
    a7d8:	0f 92       	push	r0
    a7da:	11 24       	eor	r1, r1
    a7dc:	2f 93       	push	r18
    a7de:	3f 93       	push	r19
    a7e0:	4f 93       	push	r20
    a7e2:	8f 93       	push	r24
    a7e4:	9f 93       	push	r25
    a7e6:	ef 93       	push	r30
    a7e8:	ff 93       	push	r31
    a7ea:	cf 93       	push	r28
    a7ec:	df 93       	push	r29
    a7ee:	1f 92       	push	r1
    a7f0:	cd b7       	in	r28, 0x3d	; 61
    a7f2:	de b7       	in	r29, 0x3e	; 62
  if (tx_buffer.head == tx_buffer.tail) {
    a7f4:	20 91 c3 08 	lds	r18, 0x08C3
    a7f8:	30 91 c4 08 	lds	r19, 0x08C4
    a7fc:	80 91 c5 08 	lds	r24, 0x08C5
    a800:	90 91 c6 08 	lds	r25, 0x08C6
    a804:	41 e0       	ldi	r20, 0x01	; 1
    a806:	28 17       	cp	r18, r24
    a808:	39 07       	cpc	r19, r25
    a80a:	09 f0       	breq	.+2      	; 0xa80e <__vector_19+0x3e>
    a80c:	40 e0       	ldi	r20, 0x00	; 0
    a80e:	44 23       	and	r20, r20
    a810:	51 f0       	breq	.+20     	; 0xa826 <__vector_19+0x56>
	// Buffer empty, so disable interrupts
#if defined(UCSR0B)
    cbi(UCSR0B, UDRIE0);
    a812:	81 ec       	ldi	r24, 0xC1	; 193
    a814:	90 e0       	ldi	r25, 0x00	; 0
    a816:	21 ec       	ldi	r18, 0xC1	; 193
    a818:	30 e0       	ldi	r19, 0x00	; 0
    a81a:	f9 01       	movw	r30, r18
    a81c:	20 81       	ld	r18, Z
    a81e:	2f 7d       	andi	r18, 0xDF	; 223
    a820:	fc 01       	movw	r30, r24
    a822:	20 83       	st	Z, r18
    a824:	19 c0       	rjmp	.+50     	; 0xa858 <__vector_19+0x88>
    cbi(UCSRB, UDRIE);
#endif
  }
  else {
    // There is more data in the output buffer. Send the next byte
    unsigned char c = tx_buffer.buffer[tx_buffer.tail];
    a826:	80 91 c5 08 	lds	r24, 0x08C5
    a82a:	90 91 c6 08 	lds	r25, 0x08C6
    a82e:	8d 57       	subi	r24, 0x7D	; 125
    a830:	97 4f       	sbci	r25, 0xF7	; 247
    a832:	fc 01       	movw	r30, r24
    a834:	80 81       	ld	r24, Z
    a836:	89 83       	std	Y+1, r24	; 0x01
    tx_buffer.tail = (tx_buffer.tail + 1) % SERIAL_BUFFER_SIZE;
    a838:	80 91 c5 08 	lds	r24, 0x08C5
    a83c:	90 91 c6 08 	lds	r25, 0x08C6
    a840:	01 96       	adiw	r24, 0x01	; 1
    a842:	8f 73       	andi	r24, 0x3F	; 63
    a844:	99 27       	eor	r25, r25
    a846:	90 93 c6 08 	sts	0x08C6, r25
    a84a:	80 93 c5 08 	sts	0x08C5, r24
	
  #if defined(UDR0)
    UDR0 = c;
    a84e:	86 ec       	ldi	r24, 0xC6	; 198
    a850:	90 e0       	ldi	r25, 0x00	; 0
    a852:	29 81       	ldd	r18, Y+1	; 0x01
    a854:	fc 01       	movw	r30, r24
    a856:	20 83       	st	Z, r18
    UDR = c;
  #else
    #error UDR not defined
  #endif
  }
}
    a858:	0f 90       	pop	r0
    a85a:	df 91       	pop	r29
    a85c:	cf 91       	pop	r28
    a85e:	ff 91       	pop	r31
    a860:	ef 91       	pop	r30
    a862:	9f 91       	pop	r25
    a864:	8f 91       	pop	r24
    a866:	4f 91       	pop	r20
    a868:	3f 91       	pop	r19
    a86a:	2f 91       	pop	r18
    a86c:	0f 90       	pop	r0
    a86e:	00 92 5f 00 	sts	0x005F, r0
    a872:	0f 90       	pop	r0
    a874:	1f 90       	pop	r1
    a876:	18 95       	reti

0000a878 <_ZN14HardwareSerialC1EP11ring_bufferS1_PVhS3_S3_S3_S3_S3_hhhhh>:
#endif


// Constructors ////////////////////////////////////////////////////////////////

HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
    a878:	8f 92       	push	r8
    a87a:	9f 92       	push	r9
    a87c:	af 92       	push	r10
    a87e:	bf 92       	push	r11
    a880:	cf 92       	push	r12
    a882:	df 92       	push	r13
    a884:	ef 92       	push	r14
    a886:	ff 92       	push	r15
    a888:	0f 93       	push	r16
    a88a:	1f 93       	push	r17
    a88c:	cf 93       	push	r28
    a88e:	df 93       	push	r29
    a890:	cd b7       	in	r28, 0x3d	; 61
    a892:	de b7       	in	r29, 0x3e	; 62
    a894:	62 97       	sbiw	r28, 0x12	; 18
    a896:	0f b6       	in	r0, 0x3f	; 63
    a898:	f8 94       	cli
    a89a:	de bf       	out	0x3e, r29	; 62
    a89c:	0f be       	out	0x3f, r0	; 63
    a89e:	cd bf       	out	0x3d, r28	; 61
    a8a0:	9a 83       	std	Y+2, r25	; 0x02
    a8a2:	89 83       	std	Y+1, r24	; 0x01
    a8a4:	7c 83       	std	Y+4, r23	; 0x04
    a8a6:	6b 83       	std	Y+3, r22	; 0x03
    a8a8:	5e 83       	std	Y+6, r21	; 0x06
    a8aa:	4d 83       	std	Y+5, r20	; 0x05
    a8ac:	38 87       	std	Y+8, r19	; 0x08
    a8ae:	2f 83       	std	Y+7, r18	; 0x07
    a8b0:	1a 87       	std	Y+10, r17	; 0x0a
    a8b2:	09 87       	std	Y+9, r16	; 0x09
    a8b4:	fc 86       	std	Y+12, r15	; 0x0c
    a8b6:	eb 86       	std	Y+11, r14	; 0x0b
    a8b8:	de 86       	std	Y+14, r13	; 0x0e
    a8ba:	cd 86       	std	Y+13, r12	; 0x0d
    a8bc:	b8 8a       	std	Y+16, r11	; 0x10
    a8be:	af 86       	std	Y+15, r10	; 0x0f
    a8c0:	9a 8a       	std	Y+18, r9	; 0x12
    a8c2:	89 8a       	std	Y+17, r8	; 0x11
  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
  volatile uint8_t *ucsrc, volatile uint8_t *udr,
  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
    a8c4:	89 81       	ldd	r24, Y+1	; 0x01
    a8c6:	9a 81       	ldd	r25, Y+2	; 0x02
    a8c8:	0e 94 99 a5 	call	0x14b32	; 0x14b32 <_ZN6StreamC1Ev>
    a8cc:	89 81       	ldd	r24, Y+1	; 0x01
    a8ce:	9a 81       	ldd	r25, Y+2	; 0x02
    a8d0:	2b ea       	ldi	r18, 0xAB	; 171
    a8d2:	35 e0       	ldi	r19, 0x05	; 5
    a8d4:	fc 01       	movw	r30, r24
    a8d6:	31 83       	std	Z+1, r19	; 0x01
    a8d8:	20 83       	st	Z, r18
{
  _rx_buffer = rx_buffer;
    a8da:	89 81       	ldd	r24, Y+1	; 0x01
    a8dc:	9a 81       	ldd	r25, Y+2	; 0x02
    a8de:	2b 81       	ldd	r18, Y+3	; 0x03
    a8e0:	3c 81       	ldd	r19, Y+4	; 0x04
    a8e2:	fc 01       	movw	r30, r24
    a8e4:	35 87       	std	Z+13, r19	; 0x0d
    a8e6:	24 87       	std	Z+12, r18	; 0x0c
  _tx_buffer = tx_buffer;
    a8e8:	89 81       	ldd	r24, Y+1	; 0x01
    a8ea:	9a 81       	ldd	r25, Y+2	; 0x02
    a8ec:	2d 81       	ldd	r18, Y+5	; 0x05
    a8ee:	3e 81       	ldd	r19, Y+6	; 0x06
    a8f0:	fc 01       	movw	r30, r24
    a8f2:	37 87       	std	Z+15, r19	; 0x0f
    a8f4:	26 87       	std	Z+14, r18	; 0x0e
  _ubrrh = ubrrh;
    a8f6:	89 81       	ldd	r24, Y+1	; 0x01
    a8f8:	9a 81       	ldd	r25, Y+2	; 0x02
    a8fa:	2f 81       	ldd	r18, Y+7	; 0x07
    a8fc:	38 85       	ldd	r19, Y+8	; 0x08
    a8fe:	fc 01       	movw	r30, r24
    a900:	31 8b       	std	Z+17, r19	; 0x11
    a902:	20 8b       	std	Z+16, r18	; 0x10
  _ubrrl = ubrrl;
    a904:	89 81       	ldd	r24, Y+1	; 0x01
    a906:	9a 81       	ldd	r25, Y+2	; 0x02
    a908:	29 85       	ldd	r18, Y+9	; 0x09
    a90a:	3a 85       	ldd	r19, Y+10	; 0x0a
    a90c:	fc 01       	movw	r30, r24
    a90e:	33 8b       	std	Z+19, r19	; 0x13
    a910:	22 8b       	std	Z+18, r18	; 0x12
  _ucsra = ucsra;
    a912:	89 81       	ldd	r24, Y+1	; 0x01
    a914:	9a 81       	ldd	r25, Y+2	; 0x02
    a916:	2b 85       	ldd	r18, Y+11	; 0x0b
    a918:	3c 85       	ldd	r19, Y+12	; 0x0c
    a91a:	fc 01       	movw	r30, r24
    a91c:	35 8b       	std	Z+21, r19	; 0x15
    a91e:	24 8b       	std	Z+20, r18	; 0x14
  _ucsrb = ucsrb;
    a920:	89 81       	ldd	r24, Y+1	; 0x01
    a922:	9a 81       	ldd	r25, Y+2	; 0x02
    a924:	2d 85       	ldd	r18, Y+13	; 0x0d
    a926:	3e 85       	ldd	r19, Y+14	; 0x0e
    a928:	fc 01       	movw	r30, r24
    a92a:	37 8b       	std	Z+23, r19	; 0x17
    a92c:	26 8b       	std	Z+22, r18	; 0x16
  _ucsrc = ucsrc;
    a92e:	89 81       	ldd	r24, Y+1	; 0x01
    a930:	9a 81       	ldd	r25, Y+2	; 0x02
    a932:	2f 85       	ldd	r18, Y+15	; 0x0f
    a934:	38 89       	ldd	r19, Y+16	; 0x10
    a936:	fc 01       	movw	r30, r24
    a938:	31 8f       	std	Z+25, r19	; 0x19
    a93a:	20 8f       	std	Z+24, r18	; 0x18
  _udr = udr;
    a93c:	89 81       	ldd	r24, Y+1	; 0x01
    a93e:	9a 81       	ldd	r25, Y+2	; 0x02
    a940:	29 89       	ldd	r18, Y+17	; 0x11
    a942:	3a 89       	ldd	r19, Y+18	; 0x12
    a944:	fc 01       	movw	r30, r24
    a946:	33 8f       	std	Z+27, r19	; 0x1b
    a948:	22 8f       	std	Z+26, r18	; 0x1a
  _rxen = rxen;
    a94a:	89 81       	ldd	r24, Y+1	; 0x01
    a94c:	9a 81       	ldd	r25, Y+2	; 0x02
    a94e:	29 a1       	ldd	r18, Y+33	; 0x21
    a950:	fc 01       	movw	r30, r24
    a952:	24 8f       	std	Z+28, r18	; 0x1c
  _txen = txen;
    a954:	89 81       	ldd	r24, Y+1	; 0x01
    a956:	9a 81       	ldd	r25, Y+2	; 0x02
    a958:	2a a1       	ldd	r18, Y+34	; 0x22
    a95a:	fc 01       	movw	r30, r24
    a95c:	25 8f       	std	Z+29, r18	; 0x1d
  _rxcie = rxcie;
    a95e:	89 81       	ldd	r24, Y+1	; 0x01
    a960:	9a 81       	ldd	r25, Y+2	; 0x02
    a962:	2b a1       	ldd	r18, Y+35	; 0x23
    a964:	fc 01       	movw	r30, r24
    a966:	26 8f       	std	Z+30, r18	; 0x1e
  _udrie = udrie;
    a968:	89 81       	ldd	r24, Y+1	; 0x01
    a96a:	9a 81       	ldd	r25, Y+2	; 0x02
    a96c:	2c a1       	ldd	r18, Y+36	; 0x24
    a96e:	fc 01       	movw	r30, r24
    a970:	27 8f       	std	Z+31, r18	; 0x1f
  _u2x = u2x;
    a972:	89 81       	ldd	r24, Y+1	; 0x01
    a974:	9a 81       	ldd	r25, Y+2	; 0x02
    a976:	2d a1       	ldd	r18, Y+37	; 0x25
    a978:	fc 01       	movw	r30, r24
    a97a:	20 a3       	std	Z+32, r18	; 0x20
}
    a97c:	62 96       	adiw	r28, 0x12	; 18
    a97e:	0f b6       	in	r0, 0x3f	; 63
    a980:	f8 94       	cli
    a982:	de bf       	out	0x3e, r29	; 62
    a984:	0f be       	out	0x3f, r0	; 63
    a986:	cd bf       	out	0x3d, r28	; 61
    a988:	df 91       	pop	r29
    a98a:	cf 91       	pop	r28
    a98c:	1f 91       	pop	r17
    a98e:	0f 91       	pop	r16
    a990:	ff 90       	pop	r15
    a992:	ef 90       	pop	r14
    a994:	df 90       	pop	r13
    a996:	cf 90       	pop	r12
    a998:	bf 90       	pop	r11
    a99a:	af 90       	pop	r10
    a99c:	9f 90       	pop	r9
    a99e:	8f 90       	pop	r8
    a9a0:	08 95       	ret

0000a9a2 <_ZN14HardwareSerial5beginEm>:

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud)
{
    a9a2:	cf 93       	push	r28
    a9a4:	df 93       	push	r29
    a9a6:	cd b7       	in	r28, 0x3d	; 61
    a9a8:	de b7       	in	r29, 0x3e	; 62
    a9aa:	29 97       	sbiw	r28, 0x09	; 9
    a9ac:	0f b6       	in	r0, 0x3f	; 63
    a9ae:	f8 94       	cli
    a9b0:	de bf       	out	0x3e, r29	; 62
    a9b2:	0f be       	out	0x3f, r0	; 63
    a9b4:	cd bf       	out	0x3d, r28	; 61
    a9b6:	9d 83       	std	Y+5, r25	; 0x05
    a9b8:	8c 83       	std	Y+4, r24	; 0x04
    a9ba:	4e 83       	std	Y+6, r20	; 0x06
    a9bc:	5f 83       	std	Y+7, r21	; 0x07
    a9be:	68 87       	std	Y+8, r22	; 0x08
    a9c0:	79 87       	std	Y+9, r23	; 0x09
  uint16_t baud_setting;
  bool use_u2x = true;
    a9c2:	81 e0       	ldi	r24, 0x01	; 1
    a9c4:	8b 83       	std	Y+3, r24	; 0x03

#if F_CPU == 16000000UL
  // hardcoded exception for compatibility with the bootloader shipped
  // with the Duemilanove and previous boards and the firmware on the 8U2
  // on the Uno and Mega 2560.
  if (baud == 57600) {
    a9c6:	8e 81       	ldd	r24, Y+6	; 0x06
    a9c8:	9f 81       	ldd	r25, Y+7	; 0x07
    a9ca:	a8 85       	ldd	r26, Y+8	; 0x08
    a9cc:	b9 85       	ldd	r27, Y+9	; 0x09
    a9ce:	81 15       	cp	r24, r1
    a9d0:	21 ee       	ldi	r18, 0xE1	; 225
    a9d2:	92 07       	cpc	r25, r18
    a9d4:	a1 05       	cpc	r26, r1
    a9d6:	b1 05       	cpc	r27, r1
    a9d8:	09 f4       	brne	.+2      	; 0xa9dc <_ZN14HardwareSerial5beginEm+0x3a>
    use_u2x = false;
    a9da:	1b 82       	std	Y+3, r1	; 0x03
  }
#endif

try_again:
  
  if (use_u2x) {
    a9dc:	8b 81       	ldd	r24, Y+3	; 0x03
    a9de:	88 23       	and	r24, r24
    a9e0:	61 f1       	breq	.+88     	; 0xaa3a <_ZN14HardwareSerial5beginEm+0x98>
    *_ucsra = 1 << _u2x;
    a9e2:	8c 81       	ldd	r24, Y+4	; 0x04
    a9e4:	9d 81       	ldd	r25, Y+5	; 0x05
    a9e6:	fc 01       	movw	r30, r24
    a9e8:	84 89       	ldd	r24, Z+20	; 0x14
    a9ea:	95 89       	ldd	r25, Z+21	; 0x15
    a9ec:	2c 81       	ldd	r18, Y+4	; 0x04
    a9ee:	3d 81       	ldd	r19, Y+5	; 0x05
    a9f0:	f9 01       	movw	r30, r18
    a9f2:	20 a1       	ldd	r18, Z+32	; 0x20
    a9f4:	42 2f       	mov	r20, r18
    a9f6:	50 e0       	ldi	r21, 0x00	; 0
    a9f8:	21 e0       	ldi	r18, 0x01	; 1
    a9fa:	30 e0       	ldi	r19, 0x00	; 0
    a9fc:	02 c0       	rjmp	.+4      	; 0xaa02 <_ZN14HardwareSerial5beginEm+0x60>
    a9fe:	22 0f       	add	r18, r18
    aa00:	33 1f       	adc	r19, r19
    aa02:	4a 95       	dec	r20
    aa04:	e2 f7       	brpl	.-8      	; 0xa9fe <_ZN14HardwareSerial5beginEm+0x5c>
    aa06:	fc 01       	movw	r30, r24
    aa08:	20 83       	st	Z, r18
    baud_setting = (F_CPU / 4 / baud - 1) / 2;
    aa0a:	80 e0       	ldi	r24, 0x00	; 0
    aa0c:	99 e0       	ldi	r25, 0x09	; 9
    aa0e:	ad e3       	ldi	r26, 0x3D	; 61
    aa10:	b0 e0       	ldi	r27, 0x00	; 0
    aa12:	2e 81       	ldd	r18, Y+6	; 0x06
    aa14:	3f 81       	ldd	r19, Y+7	; 0x07
    aa16:	48 85       	ldd	r20, Y+8	; 0x08
    aa18:	59 85       	ldd	r21, Y+9	; 0x09
    aa1a:	bc 01       	movw	r22, r24
    aa1c:	cd 01       	movw	r24, r26
    aa1e:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    aa22:	da 01       	movw	r26, r20
    aa24:	c9 01       	movw	r24, r18
    aa26:	01 97       	sbiw	r24, 0x01	; 1
    aa28:	a1 09       	sbc	r26, r1
    aa2a:	b1 09       	sbc	r27, r1
    aa2c:	b6 95       	lsr	r27
    aa2e:	a7 95       	ror	r26
    aa30:	97 95       	ror	r25
    aa32:	87 95       	ror	r24
    aa34:	9a 83       	std	Y+2, r25	; 0x02
    aa36:	89 83       	std	Y+1, r24	; 0x01
    aa38:	1e c0       	rjmp	.+60     	; 0xaa76 <_ZN14HardwareSerial5beginEm+0xd4>
  } else {
    *_ucsra = 0;
    aa3a:	8c 81       	ldd	r24, Y+4	; 0x04
    aa3c:	9d 81       	ldd	r25, Y+5	; 0x05
    aa3e:	fc 01       	movw	r30, r24
    aa40:	84 89       	ldd	r24, Z+20	; 0x14
    aa42:	95 89       	ldd	r25, Z+21	; 0x15
    aa44:	fc 01       	movw	r30, r24
    aa46:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    aa48:	80 e8       	ldi	r24, 0x80	; 128
    aa4a:	94 e8       	ldi	r25, 0x84	; 132
    aa4c:	ae e1       	ldi	r26, 0x1E	; 30
    aa4e:	b0 e0       	ldi	r27, 0x00	; 0
    aa50:	2e 81       	ldd	r18, Y+6	; 0x06
    aa52:	3f 81       	ldd	r19, Y+7	; 0x07
    aa54:	48 85       	ldd	r20, Y+8	; 0x08
    aa56:	59 85       	ldd	r21, Y+9	; 0x09
    aa58:	bc 01       	movw	r22, r24
    aa5a:	cd 01       	movw	r24, r26
    aa5c:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    aa60:	da 01       	movw	r26, r20
    aa62:	c9 01       	movw	r24, r18
    aa64:	01 97       	sbiw	r24, 0x01	; 1
    aa66:	a1 09       	sbc	r26, r1
    aa68:	b1 09       	sbc	r27, r1
    aa6a:	b6 95       	lsr	r27
    aa6c:	a7 95       	ror	r26
    aa6e:	97 95       	ror	r25
    aa70:	87 95       	ror	r24
    aa72:	9a 83       	std	Y+2, r25	; 0x02
    aa74:	89 83       	std	Y+1, r24	; 0x01
  }
  
  if ((baud_setting > 4095) && use_u2x)
    aa76:	89 81       	ldd	r24, Y+1	; 0x01
    aa78:	9a 81       	ldd	r25, Y+2	; 0x02
    aa7a:	81 15       	cp	r24, r1
    aa7c:	f0 e1       	ldi	r31, 0x10	; 16
    aa7e:	9f 07       	cpc	r25, r31
    aa80:	28 f0       	brcs	.+10     	; 0xaa8c <_ZN14HardwareSerial5beginEm+0xea>
    aa82:	8b 81       	ldd	r24, Y+3	; 0x03
    aa84:	88 23       	and	r24, r24
    aa86:	11 f0       	breq	.+4      	; 0xaa8c <_ZN14HardwareSerial5beginEm+0xea>
  {
    use_u2x = false;
    aa88:	1b 82       	std	Y+3, r1	; 0x03
    goto try_again;
    aa8a:	a8 cf       	rjmp	.-176    	; 0xa9dc <_ZN14HardwareSerial5beginEm+0x3a>
  }

  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    aa8c:	8c 81       	ldd	r24, Y+4	; 0x04
    aa8e:	9d 81       	ldd	r25, Y+5	; 0x05
    aa90:	fc 01       	movw	r30, r24
    aa92:	80 89       	ldd	r24, Z+16	; 0x10
    aa94:	91 89       	ldd	r25, Z+17	; 0x11
    aa96:	29 81       	ldd	r18, Y+1	; 0x01
    aa98:	3a 81       	ldd	r19, Y+2	; 0x02
    aa9a:	23 2f       	mov	r18, r19
    aa9c:	33 27       	eor	r19, r19
    aa9e:	fc 01       	movw	r30, r24
    aaa0:	20 83       	st	Z, r18
  *_ubrrl = baud_setting;
    aaa2:	8c 81       	ldd	r24, Y+4	; 0x04
    aaa4:	9d 81       	ldd	r25, Y+5	; 0x05
    aaa6:	fc 01       	movw	r30, r24
    aaa8:	82 89       	ldd	r24, Z+18	; 0x12
    aaaa:	93 89       	ldd	r25, Z+19	; 0x13
    aaac:	29 81       	ldd	r18, Y+1	; 0x01
    aaae:	fc 01       	movw	r30, r24
    aab0:	20 83       	st	Z, r18

  transmitting = false;
    aab2:	8c 81       	ldd	r24, Y+4	; 0x04
    aab4:	9d 81       	ldd	r25, Y+5	; 0x05
    aab6:	fc 01       	movw	r30, r24
    aab8:	11 a2       	std	Z+33, r1	; 0x21

  sbi(*_ucsrb, _rxen);
    aaba:	8c 81       	ldd	r24, Y+4	; 0x04
    aabc:	9d 81       	ldd	r25, Y+5	; 0x05
    aabe:	fc 01       	movw	r30, r24
    aac0:	86 89       	ldd	r24, Z+22	; 0x16
    aac2:	97 89       	ldd	r25, Z+23	; 0x17
    aac4:	2c 81       	ldd	r18, Y+4	; 0x04
    aac6:	3d 81       	ldd	r19, Y+5	; 0x05
    aac8:	f9 01       	movw	r30, r18
    aaca:	26 89       	ldd	r18, Z+22	; 0x16
    aacc:	37 89       	ldd	r19, Z+23	; 0x17
    aace:	f9 01       	movw	r30, r18
    aad0:	20 81       	ld	r18, Z
    aad2:	62 2f       	mov	r22, r18
    aad4:	2c 81       	ldd	r18, Y+4	; 0x04
    aad6:	3d 81       	ldd	r19, Y+5	; 0x05
    aad8:	f9 01       	movw	r30, r18
    aada:	24 8d       	ldd	r18, Z+28	; 0x1c
    aadc:	42 2f       	mov	r20, r18
    aade:	50 e0       	ldi	r21, 0x00	; 0
    aae0:	21 e0       	ldi	r18, 0x01	; 1
    aae2:	30 e0       	ldi	r19, 0x00	; 0
    aae4:	02 c0       	rjmp	.+4      	; 0xaaea <_ZN14HardwareSerial5beginEm+0x148>
    aae6:	22 0f       	add	r18, r18
    aae8:	33 1f       	adc	r19, r19
    aaea:	4a 95       	dec	r20
    aaec:	e2 f7       	brpl	.-8      	; 0xaae6 <_ZN14HardwareSerial5beginEm+0x144>
    aaee:	26 2b       	or	r18, r22
    aaf0:	fc 01       	movw	r30, r24
    aaf2:	20 83       	st	Z, r18
  sbi(*_ucsrb, _txen);
    aaf4:	8c 81       	ldd	r24, Y+4	; 0x04
    aaf6:	9d 81       	ldd	r25, Y+5	; 0x05
    aaf8:	fc 01       	movw	r30, r24
    aafa:	86 89       	ldd	r24, Z+22	; 0x16
    aafc:	97 89       	ldd	r25, Z+23	; 0x17
    aafe:	2c 81       	ldd	r18, Y+4	; 0x04
    ab00:	3d 81       	ldd	r19, Y+5	; 0x05
    ab02:	f9 01       	movw	r30, r18
    ab04:	26 89       	ldd	r18, Z+22	; 0x16
    ab06:	37 89       	ldd	r19, Z+23	; 0x17
    ab08:	f9 01       	movw	r30, r18
    ab0a:	20 81       	ld	r18, Z
    ab0c:	62 2f       	mov	r22, r18
    ab0e:	2c 81       	ldd	r18, Y+4	; 0x04
    ab10:	3d 81       	ldd	r19, Y+5	; 0x05
    ab12:	f9 01       	movw	r30, r18
    ab14:	25 8d       	ldd	r18, Z+29	; 0x1d
    ab16:	42 2f       	mov	r20, r18
    ab18:	50 e0       	ldi	r21, 0x00	; 0
    ab1a:	21 e0       	ldi	r18, 0x01	; 1
    ab1c:	30 e0       	ldi	r19, 0x00	; 0
    ab1e:	02 c0       	rjmp	.+4      	; 0xab24 <_ZN14HardwareSerial5beginEm+0x182>
    ab20:	22 0f       	add	r18, r18
    ab22:	33 1f       	adc	r19, r19
    ab24:	4a 95       	dec	r20
    ab26:	e2 f7       	brpl	.-8      	; 0xab20 <_ZN14HardwareSerial5beginEm+0x17e>
    ab28:	26 2b       	or	r18, r22
    ab2a:	fc 01       	movw	r30, r24
    ab2c:	20 83       	st	Z, r18
  sbi(*_ucsrb, _rxcie);
    ab2e:	8c 81       	ldd	r24, Y+4	; 0x04
    ab30:	9d 81       	ldd	r25, Y+5	; 0x05
    ab32:	fc 01       	movw	r30, r24
    ab34:	86 89       	ldd	r24, Z+22	; 0x16
    ab36:	97 89       	ldd	r25, Z+23	; 0x17
    ab38:	2c 81       	ldd	r18, Y+4	; 0x04
    ab3a:	3d 81       	ldd	r19, Y+5	; 0x05
    ab3c:	f9 01       	movw	r30, r18
    ab3e:	26 89       	ldd	r18, Z+22	; 0x16
    ab40:	37 89       	ldd	r19, Z+23	; 0x17
    ab42:	f9 01       	movw	r30, r18
    ab44:	20 81       	ld	r18, Z
    ab46:	62 2f       	mov	r22, r18
    ab48:	2c 81       	ldd	r18, Y+4	; 0x04
    ab4a:	3d 81       	ldd	r19, Y+5	; 0x05
    ab4c:	f9 01       	movw	r30, r18
    ab4e:	26 8d       	ldd	r18, Z+30	; 0x1e
    ab50:	42 2f       	mov	r20, r18
    ab52:	50 e0       	ldi	r21, 0x00	; 0
    ab54:	21 e0       	ldi	r18, 0x01	; 1
    ab56:	30 e0       	ldi	r19, 0x00	; 0
    ab58:	02 c0       	rjmp	.+4      	; 0xab5e <_ZN14HardwareSerial5beginEm+0x1bc>
    ab5a:	22 0f       	add	r18, r18
    ab5c:	33 1f       	adc	r19, r19
    ab5e:	4a 95       	dec	r20
    ab60:	e2 f7       	brpl	.-8      	; 0xab5a <_ZN14HardwareSerial5beginEm+0x1b8>
    ab62:	26 2b       	or	r18, r22
    ab64:	fc 01       	movw	r30, r24
    ab66:	20 83       	st	Z, r18
  cbi(*_ucsrb, _udrie);
    ab68:	8c 81       	ldd	r24, Y+4	; 0x04
    ab6a:	9d 81       	ldd	r25, Y+5	; 0x05
    ab6c:	fc 01       	movw	r30, r24
    ab6e:	86 89       	ldd	r24, Z+22	; 0x16
    ab70:	97 89       	ldd	r25, Z+23	; 0x17
    ab72:	2c 81       	ldd	r18, Y+4	; 0x04
    ab74:	3d 81       	ldd	r19, Y+5	; 0x05
    ab76:	f9 01       	movw	r30, r18
    ab78:	26 89       	ldd	r18, Z+22	; 0x16
    ab7a:	37 89       	ldd	r19, Z+23	; 0x17
    ab7c:	f9 01       	movw	r30, r18
    ab7e:	20 81       	ld	r18, Z
    ab80:	62 2f       	mov	r22, r18
    ab82:	2c 81       	ldd	r18, Y+4	; 0x04
    ab84:	3d 81       	ldd	r19, Y+5	; 0x05
    ab86:	f9 01       	movw	r30, r18
    ab88:	27 8d       	ldd	r18, Z+31	; 0x1f
    ab8a:	42 2f       	mov	r20, r18
    ab8c:	50 e0       	ldi	r21, 0x00	; 0
    ab8e:	21 e0       	ldi	r18, 0x01	; 1
    ab90:	30 e0       	ldi	r19, 0x00	; 0
    ab92:	04 2e       	mov	r0, r20
    ab94:	02 c0       	rjmp	.+4      	; 0xab9a <_ZN14HardwareSerial5beginEm+0x1f8>
    ab96:	22 0f       	add	r18, r18
    ab98:	33 1f       	adc	r19, r19
    ab9a:	0a 94       	dec	r0
    ab9c:	e2 f7       	brpl	.-8      	; 0xab96 <_ZN14HardwareSerial5beginEm+0x1f4>
    ab9e:	20 95       	com	r18
    aba0:	26 23       	and	r18, r22
    aba2:	fc 01       	movw	r30, r24
    aba4:	20 83       	st	Z, r18
}
    aba6:	29 96       	adiw	r28, 0x09	; 9
    aba8:	0f b6       	in	r0, 0x3f	; 63
    abaa:	f8 94       	cli
    abac:	de bf       	out	0x3e, r29	; 62
    abae:	0f be       	out	0x3f, r0	; 63
    abb0:	cd bf       	out	0x3d, r28	; 61
    abb2:	df 91       	pop	r29
    abb4:	cf 91       	pop	r28
    abb6:	08 95       	ret

0000abb8 <_ZN14HardwareSerial5beginEmh>:

void HardwareSerial::begin(unsigned long baud, byte config)
{
    abb8:	cf 93       	push	r28
    abba:	df 93       	push	r29
    abbc:	cd b7       	in	r28, 0x3d	; 61
    abbe:	de b7       	in	r29, 0x3e	; 62
    abc0:	2a 97       	sbiw	r28, 0x0a	; 10
    abc2:	0f b6       	in	r0, 0x3f	; 63
    abc4:	f8 94       	cli
    abc6:	de bf       	out	0x3e, r29	; 62
    abc8:	0f be       	out	0x3f, r0	; 63
    abca:	cd bf       	out	0x3d, r28	; 61
    abcc:	9d 83       	std	Y+5, r25	; 0x05
    abce:	8c 83       	std	Y+4, r24	; 0x04
    abd0:	4e 83       	std	Y+6, r20	; 0x06
    abd2:	5f 83       	std	Y+7, r21	; 0x07
    abd4:	68 87       	std	Y+8, r22	; 0x08
    abd6:	79 87       	std	Y+9, r23	; 0x09
    abd8:	2a 87       	std	Y+10, r18	; 0x0a
  uint16_t baud_setting;
  uint8_t current_config;
  bool use_u2x = true;
    abda:	81 e0       	ldi	r24, 0x01	; 1
    abdc:	8b 83       	std	Y+3, r24	; 0x03

#if F_CPU == 16000000UL
  // hardcoded exception for compatibility with the bootloader shipped
  // with the Duemilanove and previous boards and the firmware on the 8U2
  // on the Uno and Mega 2560.
  if (baud == 57600) {
    abde:	8e 81       	ldd	r24, Y+6	; 0x06
    abe0:	9f 81       	ldd	r25, Y+7	; 0x07
    abe2:	a8 85       	ldd	r26, Y+8	; 0x08
    abe4:	b9 85       	ldd	r27, Y+9	; 0x09
    abe6:	81 15       	cp	r24, r1
    abe8:	21 ee       	ldi	r18, 0xE1	; 225
    abea:	92 07       	cpc	r25, r18
    abec:	a1 05       	cpc	r26, r1
    abee:	b1 05       	cpc	r27, r1
    abf0:	09 f4       	brne	.+2      	; 0xabf4 <_ZN14HardwareSerial5beginEmh+0x3c>
    use_u2x = false;
    abf2:	1b 82       	std	Y+3, r1	; 0x03
  }
#endif

try_again:
  
  if (use_u2x) {
    abf4:	8b 81       	ldd	r24, Y+3	; 0x03
    abf6:	88 23       	and	r24, r24
    abf8:	61 f1       	breq	.+88     	; 0xac52 <_ZN14HardwareSerial5beginEmh+0x9a>
    *_ucsra = 1 << _u2x;
    abfa:	8c 81       	ldd	r24, Y+4	; 0x04
    abfc:	9d 81       	ldd	r25, Y+5	; 0x05
    abfe:	fc 01       	movw	r30, r24
    ac00:	84 89       	ldd	r24, Z+20	; 0x14
    ac02:	95 89       	ldd	r25, Z+21	; 0x15
    ac04:	2c 81       	ldd	r18, Y+4	; 0x04
    ac06:	3d 81       	ldd	r19, Y+5	; 0x05
    ac08:	f9 01       	movw	r30, r18
    ac0a:	20 a1       	ldd	r18, Z+32	; 0x20
    ac0c:	42 2f       	mov	r20, r18
    ac0e:	50 e0       	ldi	r21, 0x00	; 0
    ac10:	21 e0       	ldi	r18, 0x01	; 1
    ac12:	30 e0       	ldi	r19, 0x00	; 0
    ac14:	02 c0       	rjmp	.+4      	; 0xac1a <_ZN14HardwareSerial5beginEmh+0x62>
    ac16:	22 0f       	add	r18, r18
    ac18:	33 1f       	adc	r19, r19
    ac1a:	4a 95       	dec	r20
    ac1c:	e2 f7       	brpl	.-8      	; 0xac16 <_ZN14HardwareSerial5beginEmh+0x5e>
    ac1e:	fc 01       	movw	r30, r24
    ac20:	20 83       	st	Z, r18
    baud_setting = (F_CPU / 4 / baud - 1) / 2;
    ac22:	80 e0       	ldi	r24, 0x00	; 0
    ac24:	99 e0       	ldi	r25, 0x09	; 9
    ac26:	ad e3       	ldi	r26, 0x3D	; 61
    ac28:	b0 e0       	ldi	r27, 0x00	; 0
    ac2a:	2e 81       	ldd	r18, Y+6	; 0x06
    ac2c:	3f 81       	ldd	r19, Y+7	; 0x07
    ac2e:	48 85       	ldd	r20, Y+8	; 0x08
    ac30:	59 85       	ldd	r21, Y+9	; 0x09
    ac32:	bc 01       	movw	r22, r24
    ac34:	cd 01       	movw	r24, r26
    ac36:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    ac3a:	da 01       	movw	r26, r20
    ac3c:	c9 01       	movw	r24, r18
    ac3e:	01 97       	sbiw	r24, 0x01	; 1
    ac40:	a1 09       	sbc	r26, r1
    ac42:	b1 09       	sbc	r27, r1
    ac44:	b6 95       	lsr	r27
    ac46:	a7 95       	ror	r26
    ac48:	97 95       	ror	r25
    ac4a:	87 95       	ror	r24
    ac4c:	9a 83       	std	Y+2, r25	; 0x02
    ac4e:	89 83       	std	Y+1, r24	; 0x01
    ac50:	1e c0       	rjmp	.+60     	; 0xac8e <_ZN14HardwareSerial5beginEmh+0xd6>
  } else {
    *_ucsra = 0;
    ac52:	8c 81       	ldd	r24, Y+4	; 0x04
    ac54:	9d 81       	ldd	r25, Y+5	; 0x05
    ac56:	fc 01       	movw	r30, r24
    ac58:	84 89       	ldd	r24, Z+20	; 0x14
    ac5a:	95 89       	ldd	r25, Z+21	; 0x15
    ac5c:	fc 01       	movw	r30, r24
    ac5e:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    ac60:	80 e8       	ldi	r24, 0x80	; 128
    ac62:	94 e8       	ldi	r25, 0x84	; 132
    ac64:	ae e1       	ldi	r26, 0x1E	; 30
    ac66:	b0 e0       	ldi	r27, 0x00	; 0
    ac68:	2e 81       	ldd	r18, Y+6	; 0x06
    ac6a:	3f 81       	ldd	r19, Y+7	; 0x07
    ac6c:	48 85       	ldd	r20, Y+8	; 0x08
    ac6e:	59 85       	ldd	r21, Y+9	; 0x09
    ac70:	bc 01       	movw	r22, r24
    ac72:	cd 01       	movw	r24, r26
    ac74:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    ac78:	da 01       	movw	r26, r20
    ac7a:	c9 01       	movw	r24, r18
    ac7c:	01 97       	sbiw	r24, 0x01	; 1
    ac7e:	a1 09       	sbc	r26, r1
    ac80:	b1 09       	sbc	r27, r1
    ac82:	b6 95       	lsr	r27
    ac84:	a7 95       	ror	r26
    ac86:	97 95       	ror	r25
    ac88:	87 95       	ror	r24
    ac8a:	9a 83       	std	Y+2, r25	; 0x02
    ac8c:	89 83       	std	Y+1, r24	; 0x01
  }
  
  if ((baud_setting > 4095) && use_u2x)
    ac8e:	89 81       	ldd	r24, Y+1	; 0x01
    ac90:	9a 81       	ldd	r25, Y+2	; 0x02
    ac92:	81 15       	cp	r24, r1
    ac94:	f0 e1       	ldi	r31, 0x10	; 16
    ac96:	9f 07       	cpc	r25, r31
    ac98:	28 f0       	brcs	.+10     	; 0xaca4 <_ZN14HardwareSerial5beginEmh+0xec>
    ac9a:	8b 81       	ldd	r24, Y+3	; 0x03
    ac9c:	88 23       	and	r24, r24
    ac9e:	11 f0       	breq	.+4      	; 0xaca4 <_ZN14HardwareSerial5beginEmh+0xec>
  {
    use_u2x = false;
    aca0:	1b 82       	std	Y+3, r1	; 0x03
    goto try_again;
    aca2:	a8 cf       	rjmp	.-176    	; 0xabf4 <_ZN14HardwareSerial5beginEmh+0x3c>
  }

  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    aca4:	8c 81       	ldd	r24, Y+4	; 0x04
    aca6:	9d 81       	ldd	r25, Y+5	; 0x05
    aca8:	fc 01       	movw	r30, r24
    acaa:	80 89       	ldd	r24, Z+16	; 0x10
    acac:	91 89       	ldd	r25, Z+17	; 0x11
    acae:	29 81       	ldd	r18, Y+1	; 0x01
    acb0:	3a 81       	ldd	r19, Y+2	; 0x02
    acb2:	23 2f       	mov	r18, r19
    acb4:	33 27       	eor	r19, r19
    acb6:	fc 01       	movw	r30, r24
    acb8:	20 83       	st	Z, r18
  *_ubrrl = baud_setting;
    acba:	8c 81       	ldd	r24, Y+4	; 0x04
    acbc:	9d 81       	ldd	r25, Y+5	; 0x05
    acbe:	fc 01       	movw	r30, r24
    acc0:	82 89       	ldd	r24, Z+18	; 0x12
    acc2:	93 89       	ldd	r25, Z+19	; 0x13
    acc4:	29 81       	ldd	r18, Y+1	; 0x01
    acc6:	fc 01       	movw	r30, r24
    acc8:	20 83       	st	Z, r18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    acca:	8c 81       	ldd	r24, Y+4	; 0x04
    accc:	9d 81       	ldd	r25, Y+5	; 0x05
    acce:	fc 01       	movw	r30, r24
    acd0:	80 8d       	ldd	r24, Z+24	; 0x18
    acd2:	91 8d       	ldd	r25, Z+25	; 0x19
    acd4:	2a 85       	ldd	r18, Y+10	; 0x0a
    acd6:	fc 01       	movw	r30, r24
    acd8:	20 83       	st	Z, r18
  
  sbi(*_ucsrb, _rxen);
    acda:	8c 81       	ldd	r24, Y+4	; 0x04
    acdc:	9d 81       	ldd	r25, Y+5	; 0x05
    acde:	fc 01       	movw	r30, r24
    ace0:	86 89       	ldd	r24, Z+22	; 0x16
    ace2:	97 89       	ldd	r25, Z+23	; 0x17
    ace4:	2c 81       	ldd	r18, Y+4	; 0x04
    ace6:	3d 81       	ldd	r19, Y+5	; 0x05
    ace8:	f9 01       	movw	r30, r18
    acea:	26 89       	ldd	r18, Z+22	; 0x16
    acec:	37 89       	ldd	r19, Z+23	; 0x17
    acee:	f9 01       	movw	r30, r18
    acf0:	20 81       	ld	r18, Z
    acf2:	62 2f       	mov	r22, r18
    acf4:	2c 81       	ldd	r18, Y+4	; 0x04
    acf6:	3d 81       	ldd	r19, Y+5	; 0x05
    acf8:	f9 01       	movw	r30, r18
    acfa:	24 8d       	ldd	r18, Z+28	; 0x1c
    acfc:	42 2f       	mov	r20, r18
    acfe:	50 e0       	ldi	r21, 0x00	; 0
    ad00:	21 e0       	ldi	r18, 0x01	; 1
    ad02:	30 e0       	ldi	r19, 0x00	; 0
    ad04:	02 c0       	rjmp	.+4      	; 0xad0a <_ZN14HardwareSerial5beginEmh+0x152>
    ad06:	22 0f       	add	r18, r18
    ad08:	33 1f       	adc	r19, r19
    ad0a:	4a 95       	dec	r20
    ad0c:	e2 f7       	brpl	.-8      	; 0xad06 <_ZN14HardwareSerial5beginEmh+0x14e>
    ad0e:	26 2b       	or	r18, r22
    ad10:	fc 01       	movw	r30, r24
    ad12:	20 83       	st	Z, r18
  sbi(*_ucsrb, _txen);
    ad14:	8c 81       	ldd	r24, Y+4	; 0x04
    ad16:	9d 81       	ldd	r25, Y+5	; 0x05
    ad18:	fc 01       	movw	r30, r24
    ad1a:	86 89       	ldd	r24, Z+22	; 0x16
    ad1c:	97 89       	ldd	r25, Z+23	; 0x17
    ad1e:	2c 81       	ldd	r18, Y+4	; 0x04
    ad20:	3d 81       	ldd	r19, Y+5	; 0x05
    ad22:	f9 01       	movw	r30, r18
    ad24:	26 89       	ldd	r18, Z+22	; 0x16
    ad26:	37 89       	ldd	r19, Z+23	; 0x17
    ad28:	f9 01       	movw	r30, r18
    ad2a:	20 81       	ld	r18, Z
    ad2c:	62 2f       	mov	r22, r18
    ad2e:	2c 81       	ldd	r18, Y+4	; 0x04
    ad30:	3d 81       	ldd	r19, Y+5	; 0x05
    ad32:	f9 01       	movw	r30, r18
    ad34:	25 8d       	ldd	r18, Z+29	; 0x1d
    ad36:	42 2f       	mov	r20, r18
    ad38:	50 e0       	ldi	r21, 0x00	; 0
    ad3a:	21 e0       	ldi	r18, 0x01	; 1
    ad3c:	30 e0       	ldi	r19, 0x00	; 0
    ad3e:	02 c0       	rjmp	.+4      	; 0xad44 <_ZN14HardwareSerial5beginEmh+0x18c>
    ad40:	22 0f       	add	r18, r18
    ad42:	33 1f       	adc	r19, r19
    ad44:	4a 95       	dec	r20
    ad46:	e2 f7       	brpl	.-8      	; 0xad40 <_ZN14HardwareSerial5beginEmh+0x188>
    ad48:	26 2b       	or	r18, r22
    ad4a:	fc 01       	movw	r30, r24
    ad4c:	20 83       	st	Z, r18
  sbi(*_ucsrb, _rxcie);
    ad4e:	8c 81       	ldd	r24, Y+4	; 0x04
    ad50:	9d 81       	ldd	r25, Y+5	; 0x05
    ad52:	fc 01       	movw	r30, r24
    ad54:	86 89       	ldd	r24, Z+22	; 0x16
    ad56:	97 89       	ldd	r25, Z+23	; 0x17
    ad58:	2c 81       	ldd	r18, Y+4	; 0x04
    ad5a:	3d 81       	ldd	r19, Y+5	; 0x05
    ad5c:	f9 01       	movw	r30, r18
    ad5e:	26 89       	ldd	r18, Z+22	; 0x16
    ad60:	37 89       	ldd	r19, Z+23	; 0x17
    ad62:	f9 01       	movw	r30, r18
    ad64:	20 81       	ld	r18, Z
    ad66:	62 2f       	mov	r22, r18
    ad68:	2c 81       	ldd	r18, Y+4	; 0x04
    ad6a:	3d 81       	ldd	r19, Y+5	; 0x05
    ad6c:	f9 01       	movw	r30, r18
    ad6e:	26 8d       	ldd	r18, Z+30	; 0x1e
    ad70:	42 2f       	mov	r20, r18
    ad72:	50 e0       	ldi	r21, 0x00	; 0
    ad74:	21 e0       	ldi	r18, 0x01	; 1
    ad76:	30 e0       	ldi	r19, 0x00	; 0
    ad78:	02 c0       	rjmp	.+4      	; 0xad7e <_ZN14HardwareSerial5beginEmh+0x1c6>
    ad7a:	22 0f       	add	r18, r18
    ad7c:	33 1f       	adc	r19, r19
    ad7e:	4a 95       	dec	r20
    ad80:	e2 f7       	brpl	.-8      	; 0xad7a <_ZN14HardwareSerial5beginEmh+0x1c2>
    ad82:	26 2b       	or	r18, r22
    ad84:	fc 01       	movw	r30, r24
    ad86:	20 83       	st	Z, r18
  cbi(*_ucsrb, _udrie);
    ad88:	8c 81       	ldd	r24, Y+4	; 0x04
    ad8a:	9d 81       	ldd	r25, Y+5	; 0x05
    ad8c:	fc 01       	movw	r30, r24
    ad8e:	86 89       	ldd	r24, Z+22	; 0x16
    ad90:	97 89       	ldd	r25, Z+23	; 0x17
    ad92:	2c 81       	ldd	r18, Y+4	; 0x04
    ad94:	3d 81       	ldd	r19, Y+5	; 0x05
    ad96:	f9 01       	movw	r30, r18
    ad98:	26 89       	ldd	r18, Z+22	; 0x16
    ad9a:	37 89       	ldd	r19, Z+23	; 0x17
    ad9c:	f9 01       	movw	r30, r18
    ad9e:	20 81       	ld	r18, Z
    ada0:	62 2f       	mov	r22, r18
    ada2:	2c 81       	ldd	r18, Y+4	; 0x04
    ada4:	3d 81       	ldd	r19, Y+5	; 0x05
    ada6:	f9 01       	movw	r30, r18
    ada8:	27 8d       	ldd	r18, Z+31	; 0x1f
    adaa:	42 2f       	mov	r20, r18
    adac:	50 e0       	ldi	r21, 0x00	; 0
    adae:	21 e0       	ldi	r18, 0x01	; 1
    adb0:	30 e0       	ldi	r19, 0x00	; 0
    adb2:	04 2e       	mov	r0, r20
    adb4:	02 c0       	rjmp	.+4      	; 0xadba <_ZN14HardwareSerial5beginEmh+0x202>
    adb6:	22 0f       	add	r18, r18
    adb8:	33 1f       	adc	r19, r19
    adba:	0a 94       	dec	r0
    adbc:	e2 f7       	brpl	.-8      	; 0xadb6 <_ZN14HardwareSerial5beginEmh+0x1fe>
    adbe:	20 95       	com	r18
    adc0:	26 23       	and	r18, r22
    adc2:	fc 01       	movw	r30, r24
    adc4:	20 83       	st	Z, r18
}
    adc6:	2a 96       	adiw	r28, 0x0a	; 10
    adc8:	0f b6       	in	r0, 0x3f	; 63
    adca:	f8 94       	cli
    adcc:	de bf       	out	0x3e, r29	; 62
    adce:	0f be       	out	0x3f, r0	; 63
    add0:	cd bf       	out	0x3d, r28	; 61
    add2:	df 91       	pop	r29
    add4:	cf 91       	pop	r28
    add6:	08 95       	ret

0000add8 <_ZN14HardwareSerial3endEv>:

void HardwareSerial::end()
{
    add8:	cf 93       	push	r28
    adda:	df 93       	push	r29
    addc:	00 d0       	rcall	.+0      	; 0xadde <_ZN14HardwareSerial3endEv+0x6>
    adde:	cd b7       	in	r28, 0x3d	; 61
    ade0:	de b7       	in	r29, 0x3e	; 62
    ade2:	9a 83       	std	Y+2, r25	; 0x02
    ade4:	89 83       	std	Y+1, r24	; 0x01
  // wait for transmission of outgoing data
  while (_tx_buffer->head != _tx_buffer->tail)
    ade6:	89 81       	ldd	r24, Y+1	; 0x01
    ade8:	9a 81       	ldd	r25, Y+2	; 0x02
    adea:	fc 01       	movw	r30, r24
    adec:	86 85       	ldd	r24, Z+14	; 0x0e
    adee:	97 85       	ldd	r25, Z+15	; 0x0f
    adf0:	80 5c       	subi	r24, 0xC0	; 192
    adf2:	9f 4f       	sbci	r25, 0xFF	; 255
    adf4:	fc 01       	movw	r30, r24
    adf6:	20 81       	ld	r18, Z
    adf8:	31 81       	ldd	r19, Z+1	; 0x01
    adfa:	89 81       	ldd	r24, Y+1	; 0x01
    adfc:	9a 81       	ldd	r25, Y+2	; 0x02
    adfe:	fc 01       	movw	r30, r24
    ae00:	86 85       	ldd	r24, Z+14	; 0x0e
    ae02:	97 85       	ldd	r25, Z+15	; 0x0f
    ae04:	8e 5b       	subi	r24, 0xBE	; 190
    ae06:	9f 4f       	sbci	r25, 0xFF	; 255
    ae08:	fc 01       	movw	r30, r24
    ae0a:	80 81       	ld	r24, Z
    ae0c:	91 81       	ldd	r25, Z+1	; 0x01
    ae0e:	41 e0       	ldi	r20, 0x01	; 1
    ae10:	28 17       	cp	r18, r24
    ae12:	39 07       	cpc	r19, r25
    ae14:	09 f4       	brne	.+2      	; 0xae18 <_ZN14HardwareSerial3endEv+0x40>
    ae16:	40 e0       	ldi	r20, 0x00	; 0
    ae18:	44 23       	and	r20, r20
    ae1a:	29 f7       	brne	.-54     	; 0xade6 <_ZN14HardwareSerial3endEv+0xe>
    ;

  cbi(*_ucsrb, _rxen);
    ae1c:	89 81       	ldd	r24, Y+1	; 0x01
    ae1e:	9a 81       	ldd	r25, Y+2	; 0x02
    ae20:	fc 01       	movw	r30, r24
    ae22:	86 89       	ldd	r24, Z+22	; 0x16
    ae24:	97 89       	ldd	r25, Z+23	; 0x17
    ae26:	29 81       	ldd	r18, Y+1	; 0x01
    ae28:	3a 81       	ldd	r19, Y+2	; 0x02
    ae2a:	f9 01       	movw	r30, r18
    ae2c:	26 89       	ldd	r18, Z+22	; 0x16
    ae2e:	37 89       	ldd	r19, Z+23	; 0x17
    ae30:	f9 01       	movw	r30, r18
    ae32:	20 81       	ld	r18, Z
    ae34:	62 2f       	mov	r22, r18
    ae36:	29 81       	ldd	r18, Y+1	; 0x01
    ae38:	3a 81       	ldd	r19, Y+2	; 0x02
    ae3a:	f9 01       	movw	r30, r18
    ae3c:	24 8d       	ldd	r18, Z+28	; 0x1c
    ae3e:	42 2f       	mov	r20, r18
    ae40:	50 e0       	ldi	r21, 0x00	; 0
    ae42:	21 e0       	ldi	r18, 0x01	; 1
    ae44:	30 e0       	ldi	r19, 0x00	; 0
    ae46:	02 c0       	rjmp	.+4      	; 0xae4c <_ZN14HardwareSerial3endEv+0x74>
    ae48:	22 0f       	add	r18, r18
    ae4a:	33 1f       	adc	r19, r19
    ae4c:	4a 95       	dec	r20
    ae4e:	e2 f7       	brpl	.-8      	; 0xae48 <_ZN14HardwareSerial3endEv+0x70>
    ae50:	20 95       	com	r18
    ae52:	26 23       	and	r18, r22
    ae54:	fc 01       	movw	r30, r24
    ae56:	20 83       	st	Z, r18
  cbi(*_ucsrb, _txen);
    ae58:	89 81       	ldd	r24, Y+1	; 0x01
    ae5a:	9a 81       	ldd	r25, Y+2	; 0x02
    ae5c:	fc 01       	movw	r30, r24
    ae5e:	86 89       	ldd	r24, Z+22	; 0x16
    ae60:	97 89       	ldd	r25, Z+23	; 0x17
    ae62:	29 81       	ldd	r18, Y+1	; 0x01
    ae64:	3a 81       	ldd	r19, Y+2	; 0x02
    ae66:	f9 01       	movw	r30, r18
    ae68:	26 89       	ldd	r18, Z+22	; 0x16
    ae6a:	37 89       	ldd	r19, Z+23	; 0x17
    ae6c:	f9 01       	movw	r30, r18
    ae6e:	20 81       	ld	r18, Z
    ae70:	62 2f       	mov	r22, r18
    ae72:	29 81       	ldd	r18, Y+1	; 0x01
    ae74:	3a 81       	ldd	r19, Y+2	; 0x02
    ae76:	f9 01       	movw	r30, r18
    ae78:	25 8d       	ldd	r18, Z+29	; 0x1d
    ae7a:	42 2f       	mov	r20, r18
    ae7c:	50 e0       	ldi	r21, 0x00	; 0
    ae7e:	21 e0       	ldi	r18, 0x01	; 1
    ae80:	30 e0       	ldi	r19, 0x00	; 0
    ae82:	02 c0       	rjmp	.+4      	; 0xae88 <_ZN14HardwareSerial3endEv+0xb0>
    ae84:	22 0f       	add	r18, r18
    ae86:	33 1f       	adc	r19, r19
    ae88:	4a 95       	dec	r20
    ae8a:	e2 f7       	brpl	.-8      	; 0xae84 <_ZN14HardwareSerial3endEv+0xac>
    ae8c:	20 95       	com	r18
    ae8e:	26 23       	and	r18, r22
    ae90:	fc 01       	movw	r30, r24
    ae92:	20 83       	st	Z, r18
  cbi(*_ucsrb, _rxcie);  
    ae94:	89 81       	ldd	r24, Y+1	; 0x01
    ae96:	9a 81       	ldd	r25, Y+2	; 0x02
    ae98:	fc 01       	movw	r30, r24
    ae9a:	86 89       	ldd	r24, Z+22	; 0x16
    ae9c:	97 89       	ldd	r25, Z+23	; 0x17
    ae9e:	29 81       	ldd	r18, Y+1	; 0x01
    aea0:	3a 81       	ldd	r19, Y+2	; 0x02
    aea2:	f9 01       	movw	r30, r18
    aea4:	26 89       	ldd	r18, Z+22	; 0x16
    aea6:	37 89       	ldd	r19, Z+23	; 0x17
    aea8:	f9 01       	movw	r30, r18
    aeaa:	20 81       	ld	r18, Z
    aeac:	62 2f       	mov	r22, r18
    aeae:	29 81       	ldd	r18, Y+1	; 0x01
    aeb0:	3a 81       	ldd	r19, Y+2	; 0x02
    aeb2:	f9 01       	movw	r30, r18
    aeb4:	26 8d       	ldd	r18, Z+30	; 0x1e
    aeb6:	42 2f       	mov	r20, r18
    aeb8:	50 e0       	ldi	r21, 0x00	; 0
    aeba:	21 e0       	ldi	r18, 0x01	; 1
    aebc:	30 e0       	ldi	r19, 0x00	; 0
    aebe:	02 c0       	rjmp	.+4      	; 0xaec4 <_ZN14HardwareSerial3endEv+0xec>
    aec0:	22 0f       	add	r18, r18
    aec2:	33 1f       	adc	r19, r19
    aec4:	4a 95       	dec	r20
    aec6:	e2 f7       	brpl	.-8      	; 0xaec0 <_ZN14HardwareSerial3endEv+0xe8>
    aec8:	20 95       	com	r18
    aeca:	26 23       	and	r18, r22
    aecc:	fc 01       	movw	r30, r24
    aece:	20 83       	st	Z, r18
  cbi(*_ucsrb, _udrie);
    aed0:	89 81       	ldd	r24, Y+1	; 0x01
    aed2:	9a 81       	ldd	r25, Y+2	; 0x02
    aed4:	fc 01       	movw	r30, r24
    aed6:	86 89       	ldd	r24, Z+22	; 0x16
    aed8:	97 89       	ldd	r25, Z+23	; 0x17
    aeda:	29 81       	ldd	r18, Y+1	; 0x01
    aedc:	3a 81       	ldd	r19, Y+2	; 0x02
    aede:	f9 01       	movw	r30, r18
    aee0:	26 89       	ldd	r18, Z+22	; 0x16
    aee2:	37 89       	ldd	r19, Z+23	; 0x17
    aee4:	f9 01       	movw	r30, r18
    aee6:	20 81       	ld	r18, Z
    aee8:	62 2f       	mov	r22, r18
    aeea:	29 81       	ldd	r18, Y+1	; 0x01
    aeec:	3a 81       	ldd	r19, Y+2	; 0x02
    aeee:	f9 01       	movw	r30, r18
    aef0:	27 8d       	ldd	r18, Z+31	; 0x1f
    aef2:	42 2f       	mov	r20, r18
    aef4:	50 e0       	ldi	r21, 0x00	; 0
    aef6:	21 e0       	ldi	r18, 0x01	; 1
    aef8:	30 e0       	ldi	r19, 0x00	; 0
    aefa:	04 2e       	mov	r0, r20
    aefc:	02 c0       	rjmp	.+4      	; 0xaf02 <_ZN14HardwareSerial3endEv+0x12a>
    aefe:	22 0f       	add	r18, r18
    af00:	33 1f       	adc	r19, r19
    af02:	0a 94       	dec	r0
    af04:	e2 f7       	brpl	.-8      	; 0xaefe <_ZN14HardwareSerial3endEv+0x126>
    af06:	20 95       	com	r18
    af08:	26 23       	and	r18, r22
    af0a:	fc 01       	movw	r30, r24
    af0c:	20 83       	st	Z, r18
  
  // clear any received data
  _rx_buffer->head = _rx_buffer->tail;
    af0e:	89 81       	ldd	r24, Y+1	; 0x01
    af10:	9a 81       	ldd	r25, Y+2	; 0x02
    af12:	fc 01       	movw	r30, r24
    af14:	84 85       	ldd	r24, Z+12	; 0x0c
    af16:	95 85       	ldd	r25, Z+13	; 0x0d
    af18:	29 81       	ldd	r18, Y+1	; 0x01
    af1a:	3a 81       	ldd	r19, Y+2	; 0x02
    af1c:	f9 01       	movw	r30, r18
    af1e:	24 85       	ldd	r18, Z+12	; 0x0c
    af20:	35 85       	ldd	r19, Z+13	; 0x0d
    af22:	2e 5b       	subi	r18, 0xBE	; 190
    af24:	3f 4f       	sbci	r19, 0xFF	; 255
    af26:	f9 01       	movw	r30, r18
    af28:	20 81       	ld	r18, Z
    af2a:	31 81       	ldd	r19, Z+1	; 0x01
    af2c:	80 5c       	subi	r24, 0xC0	; 192
    af2e:	9f 4f       	sbci	r25, 0xFF	; 255
    af30:	fc 01       	movw	r30, r24
    af32:	31 83       	std	Z+1, r19	; 0x01
    af34:	20 83       	st	Z, r18
}
    af36:	0f 90       	pop	r0
    af38:	0f 90       	pop	r0
    af3a:	df 91       	pop	r29
    af3c:	cf 91       	pop	r28
    af3e:	08 95       	ret

0000af40 <_ZN14HardwareSerial9availableEv>:

int HardwareSerial::available(void)
{
    af40:	cf 93       	push	r28
    af42:	df 93       	push	r29
    af44:	00 d0       	rcall	.+0      	; 0xaf46 <_ZN14HardwareSerial9availableEv+0x6>
    af46:	cd b7       	in	r28, 0x3d	; 61
    af48:	de b7       	in	r29, 0x3e	; 62
    af4a:	9a 83       	std	Y+2, r25	; 0x02
    af4c:	89 83       	std	Y+1, r24	; 0x01
  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
    af4e:	89 81       	ldd	r24, Y+1	; 0x01
    af50:	9a 81       	ldd	r25, Y+2	; 0x02
    af52:	fc 01       	movw	r30, r24
    af54:	84 85       	ldd	r24, Z+12	; 0x0c
    af56:	95 85       	ldd	r25, Z+13	; 0x0d
    af58:	80 5c       	subi	r24, 0xC0	; 192
    af5a:	9f 4f       	sbci	r25, 0xFF	; 255
    af5c:	fc 01       	movw	r30, r24
    af5e:	20 81       	ld	r18, Z
    af60:	31 81       	ldd	r19, Z+1	; 0x01
    af62:	89 81       	ldd	r24, Y+1	; 0x01
    af64:	9a 81       	ldd	r25, Y+2	; 0x02
    af66:	fc 01       	movw	r30, r24
    af68:	84 85       	ldd	r24, Z+12	; 0x0c
    af6a:	95 85       	ldd	r25, Z+13	; 0x0d
    af6c:	8e 5b       	subi	r24, 0xBE	; 190
    af6e:	9f 4f       	sbci	r25, 0xFF	; 255
    af70:	fc 01       	movw	r30, r24
    af72:	80 81       	ld	r24, Z
    af74:	91 81       	ldd	r25, Z+1	; 0x01
    af76:	a9 01       	movw	r20, r18
    af78:	48 1b       	sub	r20, r24
    af7a:	59 0b       	sbc	r21, r25
    af7c:	ca 01       	movw	r24, r20
    af7e:	8f 73       	andi	r24, 0x3F	; 63
    af80:	99 27       	eor	r25, r25
}
    af82:	0f 90       	pop	r0
    af84:	0f 90       	pop	r0
    af86:	df 91       	pop	r29
    af88:	cf 91       	pop	r28
    af8a:	08 95       	ret

0000af8c <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    af8c:	cf 93       	push	r28
    af8e:	df 93       	push	r29
    af90:	00 d0       	rcall	.+0      	; 0xaf92 <_ZN14HardwareSerial4peekEv+0x6>
    af92:	cd b7       	in	r28, 0x3d	; 61
    af94:	de b7       	in	r29, 0x3e	; 62
    af96:	9a 83       	std	Y+2, r25	; 0x02
    af98:	89 83       	std	Y+1, r24	; 0x01
  if (_rx_buffer->head == _rx_buffer->tail) {
    af9a:	89 81       	ldd	r24, Y+1	; 0x01
    af9c:	9a 81       	ldd	r25, Y+2	; 0x02
    af9e:	fc 01       	movw	r30, r24
    afa0:	84 85       	ldd	r24, Z+12	; 0x0c
    afa2:	95 85       	ldd	r25, Z+13	; 0x0d
    afa4:	80 5c       	subi	r24, 0xC0	; 192
    afa6:	9f 4f       	sbci	r25, 0xFF	; 255
    afa8:	fc 01       	movw	r30, r24
    afaa:	20 81       	ld	r18, Z
    afac:	31 81       	ldd	r19, Z+1	; 0x01
    afae:	89 81       	ldd	r24, Y+1	; 0x01
    afb0:	9a 81       	ldd	r25, Y+2	; 0x02
    afb2:	fc 01       	movw	r30, r24
    afb4:	84 85       	ldd	r24, Z+12	; 0x0c
    afb6:	95 85       	ldd	r25, Z+13	; 0x0d
    afb8:	8e 5b       	subi	r24, 0xBE	; 190
    afba:	9f 4f       	sbci	r25, 0xFF	; 255
    afbc:	fc 01       	movw	r30, r24
    afbe:	80 81       	ld	r24, Z
    afc0:	91 81       	ldd	r25, Z+1	; 0x01
    afc2:	41 e0       	ldi	r20, 0x01	; 1
    afc4:	28 17       	cp	r18, r24
    afc6:	39 07       	cpc	r19, r25
    afc8:	09 f0       	breq	.+2      	; 0xafcc <_ZN14HardwareSerial4peekEv+0x40>
    afca:	40 e0       	ldi	r20, 0x00	; 0
    afcc:	44 23       	and	r20, r20
    afce:	19 f0       	breq	.+6      	; 0xafd6 <_ZN14HardwareSerial4peekEv+0x4a>
    return -1;
    afd0:	8f ef       	ldi	r24, 0xFF	; 255
    afd2:	9f ef       	ldi	r25, 0xFF	; 255
    afd4:	15 c0       	rjmp	.+42     	; 0xb000 <_ZN14HardwareSerial4peekEv+0x74>
  } else {
    return _rx_buffer->buffer[_rx_buffer->tail];
    afd6:	89 81       	ldd	r24, Y+1	; 0x01
    afd8:	9a 81       	ldd	r25, Y+2	; 0x02
    afda:	fc 01       	movw	r30, r24
    afdc:	24 85       	ldd	r18, Z+12	; 0x0c
    afde:	35 85       	ldd	r19, Z+13	; 0x0d
    afe0:	89 81       	ldd	r24, Y+1	; 0x01
    afe2:	9a 81       	ldd	r25, Y+2	; 0x02
    afe4:	fc 01       	movw	r30, r24
    afe6:	84 85       	ldd	r24, Z+12	; 0x0c
    afe8:	95 85       	ldd	r25, Z+13	; 0x0d
    afea:	8e 5b       	subi	r24, 0xBE	; 190
    afec:	9f 4f       	sbci	r25, 0xFF	; 255
    afee:	fc 01       	movw	r30, r24
    aff0:	80 81       	ld	r24, Z
    aff2:	91 81       	ldd	r25, Z+1	; 0x01
    aff4:	82 0f       	add	r24, r18
    aff6:	93 1f       	adc	r25, r19
    aff8:	fc 01       	movw	r30, r24
    affa:	80 81       	ld	r24, Z
    affc:	88 2f       	mov	r24, r24
    affe:	90 e0       	ldi	r25, 0x00	; 0
  }
}
    b000:	0f 90       	pop	r0
    b002:	0f 90       	pop	r0
    b004:	df 91       	pop	r29
    b006:	cf 91       	pop	r28
    b008:	08 95       	ret

0000b00a <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    b00a:	cf 93       	push	r28
    b00c:	df 93       	push	r29
    b00e:	00 d0       	rcall	.+0      	; 0xb010 <_ZN14HardwareSerial4readEv+0x6>
    b010:	1f 92       	push	r1
    b012:	cd b7       	in	r28, 0x3d	; 61
    b014:	de b7       	in	r29, 0x3e	; 62
    b016:	9b 83       	std	Y+3, r25	; 0x03
    b018:	8a 83       	std	Y+2, r24	; 0x02
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer->head == _rx_buffer->tail) {
    b01a:	8a 81       	ldd	r24, Y+2	; 0x02
    b01c:	9b 81       	ldd	r25, Y+3	; 0x03
    b01e:	fc 01       	movw	r30, r24
    b020:	84 85       	ldd	r24, Z+12	; 0x0c
    b022:	95 85       	ldd	r25, Z+13	; 0x0d
    b024:	80 5c       	subi	r24, 0xC0	; 192
    b026:	9f 4f       	sbci	r25, 0xFF	; 255
    b028:	fc 01       	movw	r30, r24
    b02a:	20 81       	ld	r18, Z
    b02c:	31 81       	ldd	r19, Z+1	; 0x01
    b02e:	8a 81       	ldd	r24, Y+2	; 0x02
    b030:	9b 81       	ldd	r25, Y+3	; 0x03
    b032:	fc 01       	movw	r30, r24
    b034:	84 85       	ldd	r24, Z+12	; 0x0c
    b036:	95 85       	ldd	r25, Z+13	; 0x0d
    b038:	8e 5b       	subi	r24, 0xBE	; 190
    b03a:	9f 4f       	sbci	r25, 0xFF	; 255
    b03c:	fc 01       	movw	r30, r24
    b03e:	80 81       	ld	r24, Z
    b040:	91 81       	ldd	r25, Z+1	; 0x01
    b042:	41 e0       	ldi	r20, 0x01	; 1
    b044:	28 17       	cp	r18, r24
    b046:	39 07       	cpc	r19, r25
    b048:	09 f0       	breq	.+2      	; 0xb04c <_ZN14HardwareSerial4readEv+0x42>
    b04a:	40 e0       	ldi	r20, 0x00	; 0
    b04c:	44 23       	and	r20, r20
    b04e:	19 f0       	breq	.+6      	; 0xb056 <_ZN14HardwareSerial4readEv+0x4c>
    return -1;
    b050:	8f ef       	ldi	r24, 0xFF	; 255
    b052:	9f ef       	ldi	r25, 0xFF	; 255
    b054:	2f c0       	rjmp	.+94     	; 0xb0b4 <_ZN14HardwareSerial4readEv+0xaa>
  } else {
    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
    b056:	8a 81       	ldd	r24, Y+2	; 0x02
    b058:	9b 81       	ldd	r25, Y+3	; 0x03
    b05a:	fc 01       	movw	r30, r24
    b05c:	24 85       	ldd	r18, Z+12	; 0x0c
    b05e:	35 85       	ldd	r19, Z+13	; 0x0d
    b060:	8a 81       	ldd	r24, Y+2	; 0x02
    b062:	9b 81       	ldd	r25, Y+3	; 0x03
    b064:	fc 01       	movw	r30, r24
    b066:	84 85       	ldd	r24, Z+12	; 0x0c
    b068:	95 85       	ldd	r25, Z+13	; 0x0d
    b06a:	8e 5b       	subi	r24, 0xBE	; 190
    b06c:	9f 4f       	sbci	r25, 0xFF	; 255
    b06e:	fc 01       	movw	r30, r24
    b070:	80 81       	ld	r24, Z
    b072:	91 81       	ldd	r25, Z+1	; 0x01
    b074:	82 0f       	add	r24, r18
    b076:	93 1f       	adc	r25, r19
    b078:	fc 01       	movw	r30, r24
    b07a:	80 81       	ld	r24, Z
    b07c:	89 83       	std	Y+1, r24	; 0x01
    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
    b07e:	8a 81       	ldd	r24, Y+2	; 0x02
    b080:	9b 81       	ldd	r25, Y+3	; 0x03
    b082:	fc 01       	movw	r30, r24
    b084:	84 85       	ldd	r24, Z+12	; 0x0c
    b086:	95 85       	ldd	r25, Z+13	; 0x0d
    b088:	2a 81       	ldd	r18, Y+2	; 0x02
    b08a:	3b 81       	ldd	r19, Y+3	; 0x03
    b08c:	f9 01       	movw	r30, r18
    b08e:	24 85       	ldd	r18, Z+12	; 0x0c
    b090:	35 85       	ldd	r19, Z+13	; 0x0d
    b092:	2e 5b       	subi	r18, 0xBE	; 190
    b094:	3f 4f       	sbci	r19, 0xFF	; 255
    b096:	f9 01       	movw	r30, r18
    b098:	20 81       	ld	r18, Z
    b09a:	31 81       	ldd	r19, Z+1	; 0x01
    b09c:	2f 5f       	subi	r18, 0xFF	; 255
    b09e:	3f 4f       	sbci	r19, 0xFF	; 255
    b0a0:	2f 73       	andi	r18, 0x3F	; 63
    b0a2:	33 27       	eor	r19, r19
    b0a4:	8e 5b       	subi	r24, 0xBE	; 190
    b0a6:	9f 4f       	sbci	r25, 0xFF	; 255
    b0a8:	fc 01       	movw	r30, r24
    b0aa:	31 83       	std	Z+1, r19	; 0x01
    b0ac:	20 83       	st	Z, r18
    return c;
    b0ae:	89 81       	ldd	r24, Y+1	; 0x01
    b0b0:	88 2f       	mov	r24, r24
    b0b2:	90 e0       	ldi	r25, 0x00	; 0
  }
}
    b0b4:	0f 90       	pop	r0
    b0b6:	0f 90       	pop	r0
    b0b8:	0f 90       	pop	r0
    b0ba:	df 91       	pop	r29
    b0bc:	cf 91       	pop	r28
    b0be:	08 95       	ret

0000b0c0 <_ZN14HardwareSerial5flushEv>:

void HardwareSerial::flush()
{
    b0c0:	cf 93       	push	r28
    b0c2:	df 93       	push	r29
    b0c4:	00 d0       	rcall	.+0      	; 0xb0c6 <_ZN14HardwareSerial5flushEv+0x6>
    b0c6:	cd b7       	in	r28, 0x3d	; 61
    b0c8:	de b7       	in	r29, 0x3e	; 62
    b0ca:	9a 83       	std	Y+2, r25	; 0x02
    b0cc:	89 83       	std	Y+1, r24	; 0x01
  // UDR is kept full while the buffer is not empty, so TXC triggers when EMPTY && SENT
  while (transmitting && ! (*_ucsra & _BV(TXC0)));
    b0ce:	89 81       	ldd	r24, Y+1	; 0x01
    b0d0:	9a 81       	ldd	r25, Y+2	; 0x02
    b0d2:	fc 01       	movw	r30, r24
    b0d4:	81 a1       	ldd	r24, Z+33	; 0x21
    b0d6:	88 23       	and	r24, r24
    b0d8:	79 f0       	breq	.+30     	; 0xb0f8 <_ZN14HardwareSerial5flushEv+0x38>
    b0da:	89 81       	ldd	r24, Y+1	; 0x01
    b0dc:	9a 81       	ldd	r25, Y+2	; 0x02
    b0de:	fc 01       	movw	r30, r24
    b0e0:	84 89       	ldd	r24, Z+20	; 0x14
    b0e2:	95 89       	ldd	r25, Z+21	; 0x15
    b0e4:	fc 01       	movw	r30, r24
    b0e6:	80 81       	ld	r24, Z
    b0e8:	88 2f       	mov	r24, r24
    b0ea:	90 e0       	ldi	r25, 0x00	; 0
    b0ec:	80 74       	andi	r24, 0x40	; 64
    b0ee:	99 27       	eor	r25, r25
    b0f0:	00 97       	sbiw	r24, 0x00	; 0
    b0f2:	11 f4       	brne	.+4      	; 0xb0f8 <_ZN14HardwareSerial5flushEv+0x38>
    b0f4:	81 e0       	ldi	r24, 0x01	; 1
    b0f6:	01 c0       	rjmp	.+2      	; 0xb0fa <_ZN14HardwareSerial5flushEv+0x3a>
    b0f8:	80 e0       	ldi	r24, 0x00	; 0
    b0fa:	88 23       	and	r24, r24
    b0fc:	41 f7       	brne	.-48     	; 0xb0ce <_ZN14HardwareSerial5flushEv+0xe>
  transmitting = false;
    b0fe:	89 81       	ldd	r24, Y+1	; 0x01
    b100:	9a 81       	ldd	r25, Y+2	; 0x02
    b102:	fc 01       	movw	r30, r24
    b104:	11 a2       	std	Z+33, r1	; 0x21
}
    b106:	0f 90       	pop	r0
    b108:	0f 90       	pop	r0
    b10a:	df 91       	pop	r29
    b10c:	cf 91       	pop	r28
    b10e:	08 95       	ret

0000b110 <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    b110:	cf 93       	push	r28
    b112:	df 93       	push	r29
    b114:	00 d0       	rcall	.+0      	; 0xb116 <_ZN14HardwareSerial5writeEh+0x6>
    b116:	00 d0       	rcall	.+0      	; 0xb118 <_ZN14HardwareSerial5writeEh+0x8>
    b118:	1f 92       	push	r1
    b11a:	cd b7       	in	r28, 0x3d	; 61
    b11c:	de b7       	in	r29, 0x3e	; 62
    b11e:	9c 83       	std	Y+4, r25	; 0x04
    b120:	8b 83       	std	Y+3, r24	; 0x03
    b122:	6d 83       	std	Y+5, r22	; 0x05
  int i = (_tx_buffer->head + 1) % SERIAL_BUFFER_SIZE;
    b124:	8b 81       	ldd	r24, Y+3	; 0x03
    b126:	9c 81       	ldd	r25, Y+4	; 0x04
    b128:	fc 01       	movw	r30, r24
    b12a:	86 85       	ldd	r24, Z+14	; 0x0e
    b12c:	97 85       	ldd	r25, Z+15	; 0x0f
    b12e:	80 5c       	subi	r24, 0xC0	; 192
    b130:	9f 4f       	sbci	r25, 0xFF	; 255
    b132:	fc 01       	movw	r30, r24
    b134:	80 81       	ld	r24, Z
    b136:	91 81       	ldd	r25, Z+1	; 0x01
    b138:	01 96       	adiw	r24, 0x01	; 1
    b13a:	8f 73       	andi	r24, 0x3F	; 63
    b13c:	99 27       	eor	r25, r25
    b13e:	9a 83       	std	Y+2, r25	; 0x02
    b140:	89 83       	std	Y+1, r24	; 0x01
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  // ???: return 0 here instead?
  while (i == _tx_buffer->tail)
    b142:	29 81       	ldd	r18, Y+1	; 0x01
    b144:	3a 81       	ldd	r19, Y+2	; 0x02
    b146:	8b 81       	ldd	r24, Y+3	; 0x03
    b148:	9c 81       	ldd	r25, Y+4	; 0x04
    b14a:	fc 01       	movw	r30, r24
    b14c:	86 85       	ldd	r24, Z+14	; 0x0e
    b14e:	97 85       	ldd	r25, Z+15	; 0x0f
    b150:	8e 5b       	subi	r24, 0xBE	; 190
    b152:	9f 4f       	sbci	r25, 0xFF	; 255
    b154:	fc 01       	movw	r30, r24
    b156:	80 81       	ld	r24, Z
    b158:	91 81       	ldd	r25, Z+1	; 0x01
    b15a:	41 e0       	ldi	r20, 0x01	; 1
    b15c:	28 17       	cp	r18, r24
    b15e:	39 07       	cpc	r19, r25
    b160:	09 f0       	breq	.+2      	; 0xb164 <_ZN14HardwareSerial5writeEh+0x54>
    b162:	40 e0       	ldi	r20, 0x00	; 0
    b164:	44 23       	and	r20, r20
    b166:	69 f7       	brne	.-38     	; 0xb142 <_ZN14HardwareSerial5writeEh+0x32>
    ;
	
  _tx_buffer->buffer[_tx_buffer->head] = c;
    b168:	8b 81       	ldd	r24, Y+3	; 0x03
    b16a:	9c 81       	ldd	r25, Y+4	; 0x04
    b16c:	fc 01       	movw	r30, r24
    b16e:	26 85       	ldd	r18, Z+14	; 0x0e
    b170:	37 85       	ldd	r19, Z+15	; 0x0f
    b172:	8b 81       	ldd	r24, Y+3	; 0x03
    b174:	9c 81       	ldd	r25, Y+4	; 0x04
    b176:	fc 01       	movw	r30, r24
    b178:	86 85       	ldd	r24, Z+14	; 0x0e
    b17a:	97 85       	ldd	r25, Z+15	; 0x0f
    b17c:	80 5c       	subi	r24, 0xC0	; 192
    b17e:	9f 4f       	sbci	r25, 0xFF	; 255
    b180:	fc 01       	movw	r30, r24
    b182:	80 81       	ld	r24, Z
    b184:	91 81       	ldd	r25, Z+1	; 0x01
    b186:	82 0f       	add	r24, r18
    b188:	93 1f       	adc	r25, r19
    b18a:	2d 81       	ldd	r18, Y+5	; 0x05
    b18c:	fc 01       	movw	r30, r24
    b18e:	20 83       	st	Z, r18
  _tx_buffer->head = i;
    b190:	8b 81       	ldd	r24, Y+3	; 0x03
    b192:	9c 81       	ldd	r25, Y+4	; 0x04
    b194:	fc 01       	movw	r30, r24
    b196:	86 85       	ldd	r24, Z+14	; 0x0e
    b198:	97 85       	ldd	r25, Z+15	; 0x0f
    b19a:	29 81       	ldd	r18, Y+1	; 0x01
    b19c:	3a 81       	ldd	r19, Y+2	; 0x02
    b19e:	80 5c       	subi	r24, 0xC0	; 192
    b1a0:	9f 4f       	sbci	r25, 0xFF	; 255
    b1a2:	fc 01       	movw	r30, r24
    b1a4:	31 83       	std	Z+1, r19	; 0x01
    b1a6:	20 83       	st	Z, r18
	
  sbi(*_ucsrb, _udrie);
    b1a8:	8b 81       	ldd	r24, Y+3	; 0x03
    b1aa:	9c 81       	ldd	r25, Y+4	; 0x04
    b1ac:	fc 01       	movw	r30, r24
    b1ae:	86 89       	ldd	r24, Z+22	; 0x16
    b1b0:	97 89       	ldd	r25, Z+23	; 0x17
    b1b2:	2b 81       	ldd	r18, Y+3	; 0x03
    b1b4:	3c 81       	ldd	r19, Y+4	; 0x04
    b1b6:	f9 01       	movw	r30, r18
    b1b8:	26 89       	ldd	r18, Z+22	; 0x16
    b1ba:	37 89       	ldd	r19, Z+23	; 0x17
    b1bc:	f9 01       	movw	r30, r18
    b1be:	20 81       	ld	r18, Z
    b1c0:	62 2f       	mov	r22, r18
    b1c2:	2b 81       	ldd	r18, Y+3	; 0x03
    b1c4:	3c 81       	ldd	r19, Y+4	; 0x04
    b1c6:	f9 01       	movw	r30, r18
    b1c8:	27 8d       	ldd	r18, Z+31	; 0x1f
    b1ca:	42 2f       	mov	r20, r18
    b1cc:	50 e0       	ldi	r21, 0x00	; 0
    b1ce:	21 e0       	ldi	r18, 0x01	; 1
    b1d0:	30 e0       	ldi	r19, 0x00	; 0
    b1d2:	04 2e       	mov	r0, r20
    b1d4:	02 c0       	rjmp	.+4      	; 0xb1da <_ZN14HardwareSerial5writeEh+0xca>
    b1d6:	22 0f       	add	r18, r18
    b1d8:	33 1f       	adc	r19, r19
    b1da:	0a 94       	dec	r0
    b1dc:	e2 f7       	brpl	.-8      	; 0xb1d6 <_ZN14HardwareSerial5writeEh+0xc6>
    b1de:	26 2b       	or	r18, r22
    b1e0:	fc 01       	movw	r30, r24
    b1e2:	20 83       	st	Z, r18
  // clear the TXC bit -- "can be cleared by writing a one to its bit location"
  transmitting = true;
    b1e4:	8b 81       	ldd	r24, Y+3	; 0x03
    b1e6:	9c 81       	ldd	r25, Y+4	; 0x04
    b1e8:	21 e0       	ldi	r18, 0x01	; 1
    b1ea:	fc 01       	movw	r30, r24
    b1ec:	21 a3       	std	Z+33, r18	; 0x21
  sbi(*_ucsra, TXC0);
    b1ee:	8b 81       	ldd	r24, Y+3	; 0x03
    b1f0:	9c 81       	ldd	r25, Y+4	; 0x04
    b1f2:	fc 01       	movw	r30, r24
    b1f4:	84 89       	ldd	r24, Z+20	; 0x14
    b1f6:	95 89       	ldd	r25, Z+21	; 0x15
    b1f8:	2b 81       	ldd	r18, Y+3	; 0x03
    b1fa:	3c 81       	ldd	r19, Y+4	; 0x04
    b1fc:	f9 01       	movw	r30, r18
    b1fe:	24 89       	ldd	r18, Z+20	; 0x14
    b200:	35 89       	ldd	r19, Z+21	; 0x15
    b202:	f9 01       	movw	r30, r18
    b204:	20 81       	ld	r18, Z
    b206:	20 64       	ori	r18, 0x40	; 64
    b208:	fc 01       	movw	r30, r24
    b20a:	20 83       	st	Z, r18
  
  return 1;
    b20c:	81 e0       	ldi	r24, 0x01	; 1
    b20e:	90 e0       	ldi	r25, 0x00	; 0
}
    b210:	0f 90       	pop	r0
    b212:	0f 90       	pop	r0
    b214:	0f 90       	pop	r0
    b216:	0f 90       	pop	r0
    b218:	0f 90       	pop	r0
    b21a:	df 91       	pop	r29
    b21c:	cf 91       	pop	r28
    b21e:	08 95       	ret

0000b220 <_ZN14HardwareSerialcvbEv>:

HardwareSerial::operator bool() {
    b220:	cf 93       	push	r28
    b222:	df 93       	push	r29
    b224:	00 d0       	rcall	.+0      	; 0xb226 <_ZN14HardwareSerialcvbEv+0x6>
    b226:	cd b7       	in	r28, 0x3d	; 61
    b228:	de b7       	in	r29, 0x3e	; 62
    b22a:	9a 83       	std	Y+2, r25	; 0x02
    b22c:	89 83       	std	Y+1, r24	; 0x01
	return true;
    b22e:	81 e0       	ldi	r24, 0x01	; 1
}
    b230:	0f 90       	pop	r0
    b232:	0f 90       	pop	r0
    b234:	df 91       	pop	r29
    b236:	cf 91       	pop	r28
    b238:	08 95       	ret

0000b23a <_Z41__static_initialization_and_destruction_0ii>:
// Preinstantiate Objects //////////////////////////////////////////////////////

#if defined(UBRRH) && defined(UBRRL)
  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UCSRC, &UDR, RXEN, TXEN, RXCIE, UDRIE, U2X);
#elif defined(UBRR0H) && defined(UBRR0L)
  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UCSR0C, &UDR0, RXEN0, TXEN0, RXCIE0, UDRIE0, U2X0);
    b23a:	8f 92       	push	r8
    b23c:	9f 92       	push	r9
    b23e:	af 92       	push	r10
    b240:	bf 92       	push	r11
    b242:	cf 92       	push	r12
    b244:	df 92       	push	r13
    b246:	ef 92       	push	r14
    b248:	ff 92       	push	r15
    b24a:	0f 93       	push	r16
    b24c:	1f 93       	push	r17
    b24e:	cf 93       	push	r28
    b250:	df 93       	push	r29
    b252:	00 d0       	rcall	.+0      	; 0xb254 <_Z41__static_initialization_and_destruction_0ii+0x1a>
    b254:	00 d0       	rcall	.+0      	; 0xb256 <_Z41__static_initialization_and_destruction_0ii+0x1c>
    b256:	cd b7       	in	r28, 0x3d	; 61
    b258:	de b7       	in	r29, 0x3e	; 62
    b25a:	9a 83       	std	Y+2, r25	; 0x02
    b25c:	89 83       	std	Y+1, r24	; 0x01
    b25e:	7c 83       	std	Y+4, r23	; 0x04
    b260:	6b 83       	std	Y+3, r22	; 0x03
    b262:	89 81       	ldd	r24, Y+1	; 0x01
    b264:	9a 81       	ldd	r25, Y+2	; 0x02
    b266:	81 30       	cpi	r24, 0x01	; 1
    b268:	91 05       	cpc	r25, r1
    b26a:	a9 f5       	brne	.+106    	; 0xb2d6 <_Z41__static_initialization_and_destruction_0ii+0x9c>
    b26c:	8b 81       	ldd	r24, Y+3	; 0x03
    b26e:	9c 81       	ldd	r25, Y+4	; 0x04
    b270:	8f 3f       	cpi	r24, 0xFF	; 255
    b272:	2f ef       	ldi	r18, 0xFF	; 255
    b274:	92 07       	cpc	r25, r18
    b276:	79 f5       	brne	.+94     	; 0xb2d6 <_Z41__static_initialization_and_destruction_0ii+0x9c>
    b278:	81 e0       	ldi	r24, 0x01	; 1
    b27a:	8f 93       	push	r24
    b27c:	85 e0       	ldi	r24, 0x05	; 5
    b27e:	8f 93       	push	r24
    b280:	87 e0       	ldi	r24, 0x07	; 7
    b282:	8f 93       	push	r24
    b284:	83 e0       	ldi	r24, 0x03	; 3
    b286:	8f 93       	push	r24
    b288:	84 e0       	ldi	r24, 0x04	; 4
    b28a:	8f 93       	push	r24
    b28c:	0f 2e       	mov	r0, r31
    b28e:	f6 ec       	ldi	r31, 0xC6	; 198
    b290:	8f 2e       	mov	r8, r31
    b292:	91 2c       	mov	r9, r1
    b294:	f0 2d       	mov	r31, r0
    b296:	0f 2e       	mov	r0, r31
    b298:	f2 ec       	ldi	r31, 0xC2	; 194
    b29a:	af 2e       	mov	r10, r31
    b29c:	b1 2c       	mov	r11, r1
    b29e:	f0 2d       	mov	r31, r0
    b2a0:	0f 2e       	mov	r0, r31
    b2a2:	f1 ec       	ldi	r31, 0xC1	; 193
    b2a4:	cf 2e       	mov	r12, r31
    b2a6:	d1 2c       	mov	r13, r1
    b2a8:	f0 2d       	mov	r31, r0
    b2aa:	0f 2e       	mov	r0, r31
    b2ac:	f0 ec       	ldi	r31, 0xC0	; 192
    b2ae:	ef 2e       	mov	r14, r31
    b2b0:	f1 2c       	mov	r15, r1
    b2b2:	f0 2d       	mov	r31, r0
    b2b4:	04 ec       	ldi	r16, 0xC4	; 196
    b2b6:	10 e0       	ldi	r17, 0x00	; 0
    b2b8:	25 ec       	ldi	r18, 0xC5	; 197
    b2ba:	30 e0       	ldi	r19, 0x00	; 0
    b2bc:	43 e8       	ldi	r20, 0x83	; 131
    b2be:	58 e0       	ldi	r21, 0x08	; 8
    b2c0:	6f e3       	ldi	r22, 0x3F	; 63
    b2c2:	78 e0       	ldi	r23, 0x08	; 8
    b2c4:	87 ec       	ldi	r24, 0xC7	; 199
    b2c6:	98 e0       	ldi	r25, 0x08	; 8
    b2c8:	0e 94 3c 54 	call	0xa878	; 0xa878 <_ZN14HardwareSerialC1EP11ring_bufferS1_PVhS3_S3_S3_S3_S3_hhhhh>
    b2cc:	0f 90       	pop	r0
    b2ce:	0f 90       	pop	r0
    b2d0:	0f 90       	pop	r0
    b2d2:	0f 90       	pop	r0
    b2d4:	0f 90       	pop	r0
    b2d6:	0f 90       	pop	r0
    b2d8:	0f 90       	pop	r0
    b2da:	0f 90       	pop	r0
    b2dc:	0f 90       	pop	r0
    b2de:	df 91       	pop	r29
    b2e0:	cf 91       	pop	r28
    b2e2:	1f 91       	pop	r17
    b2e4:	0f 91       	pop	r16
    b2e6:	ff 90       	pop	r15
    b2e8:	ef 90       	pop	r14
    b2ea:	df 90       	pop	r13
    b2ec:	cf 90       	pop	r12
    b2ee:	bf 90       	pop	r11
    b2f0:	af 90       	pop	r10
    b2f2:	9f 90       	pop	r9
    b2f4:	8f 90       	pop	r8
    b2f6:	08 95       	ret

0000b2f8 <_GLOBAL__sub_I_rx_buffer>:
    b2f8:	cf 93       	push	r28
    b2fa:	df 93       	push	r29
    b2fc:	cd b7       	in	r28, 0x3d	; 61
    b2fe:	de b7       	in	r29, 0x3e	; 62
    b300:	6f ef       	ldi	r22, 0xFF	; 255
    b302:	7f ef       	ldi	r23, 0xFF	; 255
    b304:	81 e0       	ldi	r24, 0x01	; 1
    b306:	90 e0       	ldi	r25, 0x00	; 0
    b308:	0e 94 1d 59 	call	0xb23a	; 0xb23a <_Z41__static_initialization_and_destruction_0ii>
    b30c:	df 91       	pop	r29
    b30e:	cf 91       	pop	r28
    b310:	08 95       	ret

0000b312 <_ZN9IPAddressC1Ev>:

#include <Arduino.h>
#include <IPAddress.h>

IPAddress::IPAddress()
    b312:	cf 93       	push	r28
    b314:	df 93       	push	r29
    b316:	00 d0       	rcall	.+0      	; 0xb318 <_ZN9IPAddressC1Ev+0x6>
    b318:	cd b7       	in	r28, 0x3d	; 61
    b31a:	de b7       	in	r29, 0x3e	; 62
    b31c:	9a 83       	std	Y+2, r25	; 0x02
    b31e:	89 83       	std	Y+1, r24	; 0x01
    b320:	89 81       	ldd	r24, Y+1	; 0x01
    b322:	9a 81       	ldd	r25, Y+2	; 0x02
    b324:	0e 94 f4 ac 	call	0x159e8	; 0x159e8 <_ZN9PrintableC1Ev>
    b328:	89 81       	ldd	r24, Y+1	; 0x01
    b32a:	9a 81       	ldd	r25, Y+2	; 0x02
    b32c:	2b eb       	ldi	r18, 0xBB	; 187
    b32e:	35 e0       	ldi	r19, 0x05	; 5
    b330:	fc 01       	movw	r30, r24
    b332:	31 83       	std	Z+1, r19	; 0x01
    b334:	20 83       	st	Z, r18
{
    memset(_address, 0, sizeof(_address));
    b336:	89 81       	ldd	r24, Y+1	; 0x01
    b338:	9a 81       	ldd	r25, Y+2	; 0x02
    b33a:	02 96       	adiw	r24, 0x02	; 2
    b33c:	44 e0       	ldi	r20, 0x04	; 4
    b33e:	50 e0       	ldi	r21, 0x00	; 0
    b340:	60 e0       	ldi	r22, 0x00	; 0
    b342:	70 e0       	ldi	r23, 0x00	; 0
    b344:	0e 94 19 b1 	call	0x16232	; 0x16232 <memset>
}
    b348:	0f 90       	pop	r0
    b34a:	0f 90       	pop	r0
    b34c:	df 91       	pop	r29
    b34e:	cf 91       	pop	r28
    b350:	08 95       	ret

0000b352 <_ZN9IPAddressC1Ehhhh>:

IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
    b352:	0f 93       	push	r16
    b354:	cf 93       	push	r28
    b356:	df 93       	push	r29
    b358:	00 d0       	rcall	.+0      	; 0xb35a <_ZN9IPAddressC1Ehhhh+0x8>
    b35a:	00 d0       	rcall	.+0      	; 0xb35c <_ZN9IPAddressC1Ehhhh+0xa>
    b35c:	00 d0       	rcall	.+0      	; 0xb35e <_ZN9IPAddressC1Ehhhh+0xc>
    b35e:	cd b7       	in	r28, 0x3d	; 61
    b360:	de b7       	in	r29, 0x3e	; 62
    b362:	9a 83       	std	Y+2, r25	; 0x02
    b364:	89 83       	std	Y+1, r24	; 0x01
    b366:	6b 83       	std	Y+3, r22	; 0x03
    b368:	4c 83       	std	Y+4, r20	; 0x04
    b36a:	2d 83       	std	Y+5, r18	; 0x05
    b36c:	0e 83       	std	Y+6, r16	; 0x06
    b36e:	89 81       	ldd	r24, Y+1	; 0x01
    b370:	9a 81       	ldd	r25, Y+2	; 0x02
    b372:	0e 94 f4 ac 	call	0x159e8	; 0x159e8 <_ZN9PrintableC1Ev>
    b376:	89 81       	ldd	r24, Y+1	; 0x01
    b378:	9a 81       	ldd	r25, Y+2	; 0x02
    b37a:	2b eb       	ldi	r18, 0xBB	; 187
    b37c:	35 e0       	ldi	r19, 0x05	; 5
    b37e:	fc 01       	movw	r30, r24
    b380:	31 83       	std	Z+1, r19	; 0x01
    b382:	20 83       	st	Z, r18
{
    _address[0] = first_octet;
    b384:	89 81       	ldd	r24, Y+1	; 0x01
    b386:	9a 81       	ldd	r25, Y+2	; 0x02
    b388:	2b 81       	ldd	r18, Y+3	; 0x03
    b38a:	fc 01       	movw	r30, r24
    b38c:	22 83       	std	Z+2, r18	; 0x02
    _address[1] = second_octet;
    b38e:	89 81       	ldd	r24, Y+1	; 0x01
    b390:	9a 81       	ldd	r25, Y+2	; 0x02
    b392:	2c 81       	ldd	r18, Y+4	; 0x04
    b394:	fc 01       	movw	r30, r24
    b396:	23 83       	std	Z+3, r18	; 0x03
    _address[2] = third_octet;
    b398:	89 81       	ldd	r24, Y+1	; 0x01
    b39a:	9a 81       	ldd	r25, Y+2	; 0x02
    b39c:	2d 81       	ldd	r18, Y+5	; 0x05
    b39e:	fc 01       	movw	r30, r24
    b3a0:	24 83       	std	Z+4, r18	; 0x04
    _address[3] = fourth_octet;
    b3a2:	89 81       	ldd	r24, Y+1	; 0x01
    b3a4:	9a 81       	ldd	r25, Y+2	; 0x02
    b3a6:	2e 81       	ldd	r18, Y+6	; 0x06
    b3a8:	fc 01       	movw	r30, r24
    b3aa:	25 83       	std	Z+5, r18	; 0x05
}
    b3ac:	26 96       	adiw	r28, 0x06	; 6
    b3ae:	0f b6       	in	r0, 0x3f	; 63
    b3b0:	f8 94       	cli
    b3b2:	de bf       	out	0x3e, r29	; 62
    b3b4:	0f be       	out	0x3f, r0	; 63
    b3b6:	cd bf       	out	0x3d, r28	; 61
    b3b8:	df 91       	pop	r29
    b3ba:	cf 91       	pop	r28
    b3bc:	0f 91       	pop	r16
    b3be:	08 95       	ret

0000b3c0 <_ZN9IPAddressC1Em>:

IPAddress::IPAddress(uint32_t address)
    b3c0:	cf 93       	push	r28
    b3c2:	df 93       	push	r29
    b3c4:	00 d0       	rcall	.+0      	; 0xb3c6 <_ZN9IPAddressC1Em+0x6>
    b3c6:	00 d0       	rcall	.+0      	; 0xb3c8 <_ZN9IPAddressC1Em+0x8>
    b3c8:	00 d0       	rcall	.+0      	; 0xb3ca <_ZN9IPAddressC1Em+0xa>
    b3ca:	cd b7       	in	r28, 0x3d	; 61
    b3cc:	de b7       	in	r29, 0x3e	; 62
    b3ce:	9a 83       	std	Y+2, r25	; 0x02
    b3d0:	89 83       	std	Y+1, r24	; 0x01
    b3d2:	4b 83       	std	Y+3, r20	; 0x03
    b3d4:	5c 83       	std	Y+4, r21	; 0x04
    b3d6:	6d 83       	std	Y+5, r22	; 0x05
    b3d8:	7e 83       	std	Y+6, r23	; 0x06
    b3da:	89 81       	ldd	r24, Y+1	; 0x01
    b3dc:	9a 81       	ldd	r25, Y+2	; 0x02
    b3de:	0e 94 f4 ac 	call	0x159e8	; 0x159e8 <_ZN9PrintableC1Ev>
    b3e2:	89 81       	ldd	r24, Y+1	; 0x01
    b3e4:	9a 81       	ldd	r25, Y+2	; 0x02
    b3e6:	2b eb       	ldi	r18, 0xBB	; 187
    b3e8:	35 e0       	ldi	r19, 0x05	; 5
    b3ea:	fc 01       	movw	r30, r24
    b3ec:	31 83       	std	Z+1, r19	; 0x01
    b3ee:	20 83       	st	Z, r18
{
    memcpy(_address, &address, sizeof(_address));
    b3f0:	89 81       	ldd	r24, Y+1	; 0x01
    b3f2:	9a 81       	ldd	r25, Y+2	; 0x02
    b3f4:	9c 01       	movw	r18, r24
    b3f6:	2e 5f       	subi	r18, 0xFE	; 254
    b3f8:	3f 4f       	sbci	r19, 0xFF	; 255
    b3fa:	8b 81       	ldd	r24, Y+3	; 0x03
    b3fc:	9c 81       	ldd	r25, Y+4	; 0x04
    b3fe:	ad 81       	ldd	r26, Y+5	; 0x05
    b400:	be 81       	ldd	r27, Y+6	; 0x06
    b402:	f9 01       	movw	r30, r18
    b404:	80 83       	st	Z, r24
    b406:	91 83       	std	Z+1, r25	; 0x01
    b408:	a2 83       	std	Z+2, r26	; 0x02
    b40a:	b3 83       	std	Z+3, r27	; 0x03
}
    b40c:	26 96       	adiw	r28, 0x06	; 6
    b40e:	0f b6       	in	r0, 0x3f	; 63
    b410:	f8 94       	cli
    b412:	de bf       	out	0x3e, r29	; 62
    b414:	0f be       	out	0x3f, r0	; 63
    b416:	cd bf       	out	0x3d, r28	; 61
    b418:	df 91       	pop	r29
    b41a:	cf 91       	pop	r28
    b41c:	08 95       	ret

0000b41e <_ZN9IPAddressC1EPKh>:

IPAddress::IPAddress(const uint8_t *address)
    b41e:	cf 93       	push	r28
    b420:	df 93       	push	r29
    b422:	00 d0       	rcall	.+0      	; 0xb424 <_ZN9IPAddressC1EPKh+0x6>
    b424:	00 d0       	rcall	.+0      	; 0xb426 <_ZN9IPAddressC1EPKh+0x8>
    b426:	cd b7       	in	r28, 0x3d	; 61
    b428:	de b7       	in	r29, 0x3e	; 62
    b42a:	9a 83       	std	Y+2, r25	; 0x02
    b42c:	89 83       	std	Y+1, r24	; 0x01
    b42e:	7c 83       	std	Y+4, r23	; 0x04
    b430:	6b 83       	std	Y+3, r22	; 0x03
    b432:	89 81       	ldd	r24, Y+1	; 0x01
    b434:	9a 81       	ldd	r25, Y+2	; 0x02
    b436:	0e 94 f4 ac 	call	0x159e8	; 0x159e8 <_ZN9PrintableC1Ev>
    b43a:	89 81       	ldd	r24, Y+1	; 0x01
    b43c:	9a 81       	ldd	r25, Y+2	; 0x02
    b43e:	2b eb       	ldi	r18, 0xBB	; 187
    b440:	35 e0       	ldi	r19, 0x05	; 5
    b442:	fc 01       	movw	r30, r24
    b444:	31 83       	std	Z+1, r19	; 0x01
    b446:	20 83       	st	Z, r18
{
    memcpy(_address, address, sizeof(_address));
    b448:	89 81       	ldd	r24, Y+1	; 0x01
    b44a:	9a 81       	ldd	r25, Y+2	; 0x02
    b44c:	02 96       	adiw	r24, 0x02	; 2
    b44e:	2b 81       	ldd	r18, Y+3	; 0x03
    b450:	3c 81       	ldd	r19, Y+4	; 0x04
    b452:	44 e0       	ldi	r20, 0x04	; 4
    b454:	50 e0       	ldi	r21, 0x00	; 0
    b456:	b9 01       	movw	r22, r18
    b458:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
}
    b45c:	0f 90       	pop	r0
    b45e:	0f 90       	pop	r0
    b460:	0f 90       	pop	r0
    b462:	0f 90       	pop	r0
    b464:	df 91       	pop	r29
    b466:	cf 91       	pop	r28
    b468:	08 95       	ret

0000b46a <_ZN9IPAddressaSEPKh>:

IPAddress& IPAddress::operator=(const uint8_t *address)
{
    b46a:	cf 93       	push	r28
    b46c:	df 93       	push	r29
    b46e:	00 d0       	rcall	.+0      	; 0xb470 <_ZN9IPAddressaSEPKh+0x6>
    b470:	00 d0       	rcall	.+0      	; 0xb472 <_ZN9IPAddressaSEPKh+0x8>
    b472:	cd b7       	in	r28, 0x3d	; 61
    b474:	de b7       	in	r29, 0x3e	; 62
    b476:	9a 83       	std	Y+2, r25	; 0x02
    b478:	89 83       	std	Y+1, r24	; 0x01
    b47a:	7c 83       	std	Y+4, r23	; 0x04
    b47c:	6b 83       	std	Y+3, r22	; 0x03
    memcpy(_address, address, sizeof(_address));
    b47e:	89 81       	ldd	r24, Y+1	; 0x01
    b480:	9a 81       	ldd	r25, Y+2	; 0x02
    b482:	02 96       	adiw	r24, 0x02	; 2
    b484:	2b 81       	ldd	r18, Y+3	; 0x03
    b486:	3c 81       	ldd	r19, Y+4	; 0x04
    b488:	44 e0       	ldi	r20, 0x04	; 4
    b48a:	50 e0       	ldi	r21, 0x00	; 0
    b48c:	b9 01       	movw	r22, r18
    b48e:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
    return *this;
    b492:	89 81       	ldd	r24, Y+1	; 0x01
    b494:	9a 81       	ldd	r25, Y+2	; 0x02
}
    b496:	0f 90       	pop	r0
    b498:	0f 90       	pop	r0
    b49a:	0f 90       	pop	r0
    b49c:	0f 90       	pop	r0
    b49e:	df 91       	pop	r29
    b4a0:	cf 91       	pop	r28
    b4a2:	08 95       	ret

0000b4a4 <_ZN9IPAddressaSEm>:

IPAddress& IPAddress::operator=(uint32_t address)
{
    b4a4:	cf 93       	push	r28
    b4a6:	df 93       	push	r29
    b4a8:	00 d0       	rcall	.+0      	; 0xb4aa <_ZN9IPAddressaSEm+0x6>
    b4aa:	00 d0       	rcall	.+0      	; 0xb4ac <_ZN9IPAddressaSEm+0x8>
    b4ac:	00 d0       	rcall	.+0      	; 0xb4ae <_ZN9IPAddressaSEm+0xa>
    b4ae:	cd b7       	in	r28, 0x3d	; 61
    b4b0:	de b7       	in	r29, 0x3e	; 62
    b4b2:	9a 83       	std	Y+2, r25	; 0x02
    b4b4:	89 83       	std	Y+1, r24	; 0x01
    b4b6:	4b 83       	std	Y+3, r20	; 0x03
    b4b8:	5c 83       	std	Y+4, r21	; 0x04
    b4ba:	6d 83       	std	Y+5, r22	; 0x05
    b4bc:	7e 83       	std	Y+6, r23	; 0x06
    memcpy(_address, (const uint8_t *)&address, sizeof(_address));
    b4be:	89 81       	ldd	r24, Y+1	; 0x01
    b4c0:	9a 81       	ldd	r25, Y+2	; 0x02
    b4c2:	9c 01       	movw	r18, r24
    b4c4:	2e 5f       	subi	r18, 0xFE	; 254
    b4c6:	3f 4f       	sbci	r19, 0xFF	; 255
    b4c8:	8b 81       	ldd	r24, Y+3	; 0x03
    b4ca:	9c 81       	ldd	r25, Y+4	; 0x04
    b4cc:	ad 81       	ldd	r26, Y+5	; 0x05
    b4ce:	be 81       	ldd	r27, Y+6	; 0x06
    b4d0:	f9 01       	movw	r30, r18
    b4d2:	80 83       	st	Z, r24
    b4d4:	91 83       	std	Z+1, r25	; 0x01
    b4d6:	a2 83       	std	Z+2, r26	; 0x02
    b4d8:	b3 83       	std	Z+3, r27	; 0x03
    return *this;
    b4da:	89 81       	ldd	r24, Y+1	; 0x01
    b4dc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    b4de:	26 96       	adiw	r28, 0x06	; 6
    b4e0:	0f b6       	in	r0, 0x3f	; 63
    b4e2:	f8 94       	cli
    b4e4:	de bf       	out	0x3e, r29	; 62
    b4e6:	0f be       	out	0x3f, r0	; 63
    b4e8:	cd bf       	out	0x3d, r28	; 61
    b4ea:	df 91       	pop	r29
    b4ec:	cf 91       	pop	r28
    b4ee:	08 95       	ret

0000b4f0 <_ZN9IPAddresseqEPKh>:

bool IPAddress::operator==(const uint8_t* addr)
{
    b4f0:	cf 93       	push	r28
    b4f2:	df 93       	push	r29
    b4f4:	00 d0       	rcall	.+0      	; 0xb4f6 <_ZN9IPAddresseqEPKh+0x6>
    b4f6:	00 d0       	rcall	.+0      	; 0xb4f8 <_ZN9IPAddresseqEPKh+0x8>
    b4f8:	cd b7       	in	r28, 0x3d	; 61
    b4fa:	de b7       	in	r29, 0x3e	; 62
    b4fc:	9a 83       	std	Y+2, r25	; 0x02
    b4fe:	89 83       	std	Y+1, r24	; 0x01
    b500:	7c 83       	std	Y+4, r23	; 0x04
    b502:	6b 83       	std	Y+3, r22	; 0x03
    return memcmp(addr, _address, sizeof(_address)) == 0;
    b504:	89 81       	ldd	r24, Y+1	; 0x01
    b506:	9a 81       	ldd	r25, Y+2	; 0x02
    b508:	9c 01       	movw	r18, r24
    b50a:	2e 5f       	subi	r18, 0xFE	; 254
    b50c:	3f 4f       	sbci	r19, 0xFF	; 255
    b50e:	8b 81       	ldd	r24, Y+3	; 0x03
    b510:	9c 81       	ldd	r25, Y+4	; 0x04
    b512:	44 e0       	ldi	r20, 0x04	; 4
    b514:	50 e0       	ldi	r21, 0x00	; 0
    b516:	b9 01       	movw	r22, r18
    b518:	0e 94 f1 b0 	call	0x161e2	; 0x161e2 <memcmp>
    b51c:	21 e0       	ldi	r18, 0x01	; 1
    b51e:	00 97       	sbiw	r24, 0x00	; 0
    b520:	09 f0       	breq	.+2      	; 0xb524 <_ZN9IPAddresseqEPKh+0x34>
    b522:	20 e0       	ldi	r18, 0x00	; 0
    b524:	82 2f       	mov	r24, r18
}
    b526:	0f 90       	pop	r0
    b528:	0f 90       	pop	r0
    b52a:	0f 90       	pop	r0
    b52c:	0f 90       	pop	r0
    b52e:	df 91       	pop	r29
    b530:	cf 91       	pop	r28
    b532:	08 95       	ret

0000b534 <_ZNK9IPAddress7printToER5Print>:

size_t IPAddress::printTo(Print& p) const
{
    b534:	cf 93       	push	r28
    b536:	df 93       	push	r29
    b538:	cd b7       	in	r28, 0x3d	; 61
    b53a:	de b7       	in	r29, 0x3e	; 62
    b53c:	28 97       	sbiw	r28, 0x08	; 8
    b53e:	0f b6       	in	r0, 0x3f	; 63
    b540:	f8 94       	cli
    b542:	de bf       	out	0x3e, r29	; 62
    b544:	0f be       	out	0x3f, r0	; 63
    b546:	cd bf       	out	0x3d, r28	; 61
    b548:	9e 83       	std	Y+6, r25	; 0x06
    b54a:	8d 83       	std	Y+5, r24	; 0x05
    b54c:	78 87       	std	Y+8, r23	; 0x08
    b54e:	6f 83       	std	Y+7, r22	; 0x07
    size_t n = 0;
    b550:	1a 82       	std	Y+2, r1	; 0x02
    b552:	19 82       	std	Y+1, r1	; 0x01
    for (int i =0; i < 3; i++)
    b554:	1c 82       	std	Y+4, r1	; 0x04
    b556:	1b 82       	std	Y+3, r1	; 0x03
    b558:	26 c0       	rjmp	.+76     	; 0xb5a6 <_ZNK9IPAddress7printToER5Print+0x72>
    {
        n += p.print(_address[i], DEC);
    b55a:	2d 81       	ldd	r18, Y+5	; 0x05
    b55c:	3e 81       	ldd	r19, Y+6	; 0x06
    b55e:	8b 81       	ldd	r24, Y+3	; 0x03
    b560:	9c 81       	ldd	r25, Y+4	; 0x04
    b562:	82 0f       	add	r24, r18
    b564:	93 1f       	adc	r25, r19
    b566:	02 96       	adiw	r24, 0x02	; 2
    b568:	fc 01       	movw	r30, r24
    b56a:	20 81       	ld	r18, Z
    b56c:	8f 81       	ldd	r24, Y+7	; 0x07
    b56e:	98 85       	ldd	r25, Y+8	; 0x08
    b570:	4a e0       	ldi	r20, 0x0A	; 10
    b572:	50 e0       	ldi	r21, 0x00	; 0
    b574:	62 2f       	mov	r22, r18
    b576:	0e 94 3f 5c 	call	0xb87e	; 0xb87e <_ZN5Print5printEhi>
    b57a:	29 81       	ldd	r18, Y+1	; 0x01
    b57c:	3a 81       	ldd	r19, Y+2	; 0x02
    b57e:	82 0f       	add	r24, r18
    b580:	93 1f       	adc	r25, r19
    b582:	9a 83       	std	Y+2, r25	; 0x02
    b584:	89 83       	std	Y+1, r24	; 0x01
        n += p.print('.');
    b586:	8f 81       	ldd	r24, Y+7	; 0x07
    b588:	98 85       	ldd	r25, Y+8	; 0x08
    b58a:	6e e2       	ldi	r22, 0x2E	; 46
    b58c:	0e 94 23 5c 	call	0xb846	; 0xb846 <_ZN5Print5printEc>
    b590:	29 81       	ldd	r18, Y+1	; 0x01
    b592:	3a 81       	ldd	r19, Y+2	; 0x02
    b594:	82 0f       	add	r24, r18
    b596:	93 1f       	adc	r25, r19
    b598:	9a 83       	std	Y+2, r25	; 0x02
    b59a:	89 83       	std	Y+1, r24	; 0x01
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i =0; i < 3; i++)
    b59c:	8b 81       	ldd	r24, Y+3	; 0x03
    b59e:	9c 81       	ldd	r25, Y+4	; 0x04
    b5a0:	01 96       	adiw	r24, 0x01	; 1
    b5a2:	9c 83       	std	Y+4, r25	; 0x04
    b5a4:	8b 83       	std	Y+3, r24	; 0x03
    b5a6:	21 e0       	ldi	r18, 0x01	; 1
    b5a8:	8b 81       	ldd	r24, Y+3	; 0x03
    b5aa:	9c 81       	ldd	r25, Y+4	; 0x04
    b5ac:	83 30       	cpi	r24, 0x03	; 3
    b5ae:	91 05       	cpc	r25, r1
    b5b0:	0c f0       	brlt	.+2      	; 0xb5b4 <_ZNK9IPAddress7printToER5Print+0x80>
    b5b2:	20 e0       	ldi	r18, 0x00	; 0
    b5b4:	22 23       	and	r18, r18
    b5b6:	89 f6       	brne	.-94     	; 0xb55a <_ZNK9IPAddress7printToER5Print+0x26>
    {
        n += p.print(_address[i], DEC);
        n += p.print('.');
    }
    n += p.print(_address[3], DEC);
    b5b8:	8d 81       	ldd	r24, Y+5	; 0x05
    b5ba:	9e 81       	ldd	r25, Y+6	; 0x06
    b5bc:	fc 01       	movw	r30, r24
    b5be:	25 81       	ldd	r18, Z+5	; 0x05
    b5c0:	8f 81       	ldd	r24, Y+7	; 0x07
    b5c2:	98 85       	ldd	r25, Y+8	; 0x08
    b5c4:	4a e0       	ldi	r20, 0x0A	; 10
    b5c6:	50 e0       	ldi	r21, 0x00	; 0
    b5c8:	62 2f       	mov	r22, r18
    b5ca:	0e 94 3f 5c 	call	0xb87e	; 0xb87e <_ZN5Print5printEhi>
    b5ce:	29 81       	ldd	r18, Y+1	; 0x01
    b5d0:	3a 81       	ldd	r19, Y+2	; 0x02
    b5d2:	82 0f       	add	r24, r18
    b5d4:	93 1f       	adc	r25, r19
    b5d6:	9a 83       	std	Y+2, r25	; 0x02
    b5d8:	89 83       	std	Y+1, r24	; 0x01
    return n;
    b5da:	89 81       	ldd	r24, Y+1	; 0x01
    b5dc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    b5de:	28 96       	adiw	r28, 0x08	; 8
    b5e0:	0f b6       	in	r0, 0x3f	; 63
    b5e2:	f8 94       	cli
    b5e4:	de bf       	out	0x3e, r29	; 62
    b5e6:	0f be       	out	0x3f, r0	; 63
    b5e8:	cd bf       	out	0x3d, r28	; 61
    b5ea:	df 91       	pop	r29
    b5ec:	cf 91       	pop	r28
    b5ee:	08 95       	ret

0000b5f0 <_Z41__static_initialization_and_destruction_0ii>:
    b5f0:	0f 93       	push	r16
    b5f2:	cf 93       	push	r28
    b5f4:	df 93       	push	r29
    b5f6:	00 d0       	rcall	.+0      	; 0xb5f8 <_Z41__static_initialization_and_destruction_0ii+0x8>
    b5f8:	00 d0       	rcall	.+0      	; 0xb5fa <_Z41__static_initialization_and_destruction_0ii+0xa>
    b5fa:	cd b7       	in	r28, 0x3d	; 61
    b5fc:	de b7       	in	r29, 0x3e	; 62
    b5fe:	9a 83       	std	Y+2, r25	; 0x02
    b600:	89 83       	std	Y+1, r24	; 0x01
    b602:	7c 83       	std	Y+4, r23	; 0x04
    b604:	6b 83       	std	Y+3, r22	; 0x03
    b606:	89 81       	ldd	r24, Y+1	; 0x01
    b608:	9a 81       	ldd	r25, Y+2	; 0x02
    b60a:	81 30       	cpi	r24, 0x01	; 1
    b60c:	91 05       	cpc	r25, r1
    b60e:	71 f4       	brne	.+28     	; 0xb62c <_Z41__static_initialization_and_destruction_0ii+0x3c>
    b610:	8b 81       	ldd	r24, Y+3	; 0x03
    b612:	9c 81       	ldd	r25, Y+4	; 0x04
    b614:	8f 3f       	cpi	r24, 0xFF	; 255
    b616:	2f ef       	ldi	r18, 0xFF	; 255
    b618:	92 07       	cpc	r25, r18
    b61a:	41 f4       	brne	.+16     	; 0xb62c <_Z41__static_initialization_and_destruction_0ii+0x3c>
    b61c:	00 e0       	ldi	r16, 0x00	; 0
    b61e:	20 e0       	ldi	r18, 0x00	; 0
    b620:	40 e0       	ldi	r20, 0x00	; 0
    b622:	60 e0       	ldi	r22, 0x00	; 0
    b624:	89 ee       	ldi	r24, 0xE9	; 233
    b626:	98 e0       	ldi	r25, 0x08	; 8
    b628:	0e 94 a9 59 	call	0xb352	; 0xb352 <_ZN9IPAddressC1Ehhhh>
    b62c:	0f 90       	pop	r0
    b62e:	0f 90       	pop	r0
    b630:	0f 90       	pop	r0
    b632:	0f 90       	pop	r0
    b634:	df 91       	pop	r29
    b636:	cf 91       	pop	r28
    b638:	0f 91       	pop	r16
    b63a:	08 95       	ret

0000b63c <_GLOBAL__sub_I__ZN9IPAddressC2Ev>:
    b63c:	cf 93       	push	r28
    b63e:	df 93       	push	r29
    b640:	cd b7       	in	r28, 0x3d	; 61
    b642:	de b7       	in	r29, 0x3e	; 62
    b644:	6f ef       	ldi	r22, 0xFF	; 255
    b646:	7f ef       	ldi	r23, 0xFF	; 255
    b648:	81 e0       	ldi	r24, 0x01	; 1
    b64a:	90 e0       	ldi	r25, 0x00	; 0
    b64c:	0e 94 f8 5a 	call	0xb5f0	; 0xb5f0 <_Z41__static_initialization_and_destruction_0ii>
    b650:	df 91       	pop	r29
    b652:	cf 91       	pop	r28
    b654:	08 95       	ret

0000b656 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
    b656:	cf 93       	push	r28
    b658:	df 93       	push	r29
    b65a:	cd b7       	in	r28, 0x3d	; 61
    b65c:	de b7       	in	r29, 0x3e	; 62
    b65e:	28 97       	sbiw	r28, 0x08	; 8
    b660:	0f b6       	in	r0, 0x3f	; 63
    b662:	f8 94       	cli
    b664:	de bf       	out	0x3e, r29	; 62
    b666:	0f be       	out	0x3f, r0	; 63
    b668:	cd bf       	out	0x3d, r28	; 61
    b66a:	9c 83       	std	Y+4, r25	; 0x04
    b66c:	8b 83       	std	Y+3, r24	; 0x03
    b66e:	7e 83       	std	Y+6, r23	; 0x06
    b670:	6d 83       	std	Y+5, r22	; 0x05
    b672:	58 87       	std	Y+8, r21	; 0x08
    b674:	4f 83       	std	Y+7, r20	; 0x07
  size_t n = 0;
    b676:	1a 82       	std	Y+2, r1	; 0x02
    b678:	19 82       	std	Y+1, r1	; 0x01
  while (size--) {
    b67a:	1c c0       	rjmp	.+56     	; 0xb6b4 <_ZN5Print5writeEPKhj+0x5e>
    n += write(*buffer++);
    b67c:	8b 81       	ldd	r24, Y+3	; 0x03
    b67e:	9c 81       	ldd	r25, Y+4	; 0x04
    b680:	fc 01       	movw	r30, r24
    b682:	80 81       	ld	r24, Z
    b684:	91 81       	ldd	r25, Z+1	; 0x01
    b686:	fc 01       	movw	r30, r24
    b688:	20 81       	ld	r18, Z
    b68a:	31 81       	ldd	r19, Z+1	; 0x01
    b68c:	8d 81       	ldd	r24, Y+5	; 0x05
    b68e:	9e 81       	ldd	r25, Y+6	; 0x06
    b690:	fc 01       	movw	r30, r24
    b692:	40 81       	ld	r20, Z
    b694:	8d 81       	ldd	r24, Y+5	; 0x05
    b696:	9e 81       	ldd	r25, Y+6	; 0x06
    b698:	01 96       	adiw	r24, 0x01	; 1
    b69a:	9e 83       	std	Y+6, r25	; 0x06
    b69c:	8d 83       	std	Y+5, r24	; 0x05
    b69e:	8b 81       	ldd	r24, Y+3	; 0x03
    b6a0:	9c 81       	ldd	r25, Y+4	; 0x04
    b6a2:	64 2f       	mov	r22, r20
    b6a4:	f9 01       	movw	r30, r18
    b6a6:	09 95       	icall
    b6a8:	29 81       	ldd	r18, Y+1	; 0x01
    b6aa:	3a 81       	ldd	r19, Y+2	; 0x02
    b6ac:	82 0f       	add	r24, r18
    b6ae:	93 1f       	adc	r25, r19
    b6b0:	9a 83       	std	Y+2, r25	; 0x02
    b6b2:	89 83       	std	Y+1, r24	; 0x01

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
    b6b4:	21 e0       	ldi	r18, 0x01	; 1
    b6b6:	8f 81       	ldd	r24, Y+7	; 0x07
    b6b8:	98 85       	ldd	r25, Y+8	; 0x08
    b6ba:	00 97       	sbiw	r24, 0x00	; 0
    b6bc:	09 f4       	brne	.+2      	; 0xb6c0 <_ZN5Print5writeEPKhj+0x6a>
    b6be:	20 e0       	ldi	r18, 0x00	; 0
    b6c0:	8f 81       	ldd	r24, Y+7	; 0x07
    b6c2:	98 85       	ldd	r25, Y+8	; 0x08
    b6c4:	01 97       	sbiw	r24, 0x01	; 1
    b6c6:	98 87       	std	Y+8, r25	; 0x08
    b6c8:	8f 83       	std	Y+7, r24	; 0x07
    b6ca:	22 23       	and	r18, r18
    b6cc:	b9 f6       	brne	.-82     	; 0xb67c <_ZN5Print5writeEPKhj+0x26>
    n += write(*buffer++);
  }
  return n;
    b6ce:	89 81       	ldd	r24, Y+1	; 0x01
    b6d0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    b6d2:	28 96       	adiw	r28, 0x08	; 8
    b6d4:	0f b6       	in	r0, 0x3f	; 63
    b6d6:	f8 94       	cli
    b6d8:	de bf       	out	0x3e, r29	; 62
    b6da:	0f be       	out	0x3f, r0	; 63
    b6dc:	cd bf       	out	0x3d, r28	; 61
    b6de:	df 91       	pop	r29
    b6e0:	cf 91       	pop	r28
    b6e2:	08 95       	ret

0000b6e4 <_ZN5Print5printEPK19__FlashStringHelper>:

size_t Print::print(const __FlashStringHelper *ifsh)
{
    b6e4:	1f 93       	push	r17
    b6e6:	cf 93       	push	r28
    b6e8:	df 93       	push	r29
    b6ea:	cd b7       	in	r28, 0x3d	; 61
    b6ec:	de b7       	in	r29, 0x3e	; 62
    b6ee:	2c 97       	sbiw	r28, 0x0c	; 12
    b6f0:	0f b6       	in	r0, 0x3f	; 63
    b6f2:	f8 94       	cli
    b6f4:	de bf       	out	0x3e, r29	; 62
    b6f6:	0f be       	out	0x3f, r0	; 63
    b6f8:	cd bf       	out	0x3d, r28	; 61
    b6fa:	9a 87       	std	Y+10, r25	; 0x0a
    b6fc:	89 87       	std	Y+9, r24	; 0x09
    b6fe:	7c 87       	std	Y+12, r23	; 0x0c
    b700:	6b 87       	std	Y+11, r22	; 0x0b
  const char PROGMEM *p = (const char PROGMEM *)ifsh;
    b702:	8b 85       	ldd	r24, Y+11	; 0x0b
    b704:	9c 85       	ldd	r25, Y+12	; 0x0c
    b706:	9a 83       	std	Y+2, r25	; 0x02
    b708:	89 83       	std	Y+1, r24	; 0x01
  size_t n = 0;
    b70a:	1c 82       	std	Y+4, r1	; 0x04
    b70c:	1b 82       	std	Y+3, r1	; 0x03
  while (1) {
    unsigned char c = pgm_read_byte(p++);
    b70e:	89 81       	ldd	r24, Y+1	; 0x01
    b710:	9a 81       	ldd	r25, Y+2	; 0x02
    b712:	9e 83       	std	Y+6, r25	; 0x06
    b714:	8d 83       	std	Y+5, r24	; 0x05
    b716:	89 81       	ldd	r24, Y+1	; 0x01
    b718:	9a 81       	ldd	r25, Y+2	; 0x02
    b71a:	01 96       	adiw	r24, 0x01	; 1
    b71c:	9a 83       	std	Y+2, r25	; 0x02
    b71e:	89 83       	std	Y+1, r24	; 0x01
    b720:	8d 81       	ldd	r24, Y+5	; 0x05
    b722:	9e 81       	ldd	r25, Y+6	; 0x06
    b724:	fc 01       	movw	r30, r24
    b726:	14 91       	lpm	r17, Z
    b728:	1f 83       	std	Y+7, r17	; 0x07
    b72a:	8f 81       	ldd	r24, Y+7	; 0x07
    b72c:	88 87       	std	Y+8, r24	; 0x08
    if (c == 0) break;
    b72e:	88 85       	ldd	r24, Y+8	; 0x08
    b730:	88 23       	and	r24, r24
    b732:	a1 f0       	breq	.+40     	; 0xb75c <_ZN5Print5printEPK19__FlashStringHelper+0x78>
    n += write(c);
    b734:	89 85       	ldd	r24, Y+9	; 0x09
    b736:	9a 85       	ldd	r25, Y+10	; 0x0a
    b738:	fc 01       	movw	r30, r24
    b73a:	80 81       	ld	r24, Z
    b73c:	91 81       	ldd	r25, Z+1	; 0x01
    b73e:	fc 01       	movw	r30, r24
    b740:	20 81       	ld	r18, Z
    b742:	31 81       	ldd	r19, Z+1	; 0x01
    b744:	89 85       	ldd	r24, Y+9	; 0x09
    b746:	9a 85       	ldd	r25, Y+10	; 0x0a
    b748:	68 85       	ldd	r22, Y+8	; 0x08
    b74a:	f9 01       	movw	r30, r18
    b74c:	09 95       	icall
    b74e:	2b 81       	ldd	r18, Y+3	; 0x03
    b750:	3c 81       	ldd	r19, Y+4	; 0x04
    b752:	82 0f       	add	r24, r18
    b754:	93 1f       	adc	r25, r19
    b756:	9c 83       	std	Y+4, r25	; 0x04
    b758:	8b 83       	std	Y+3, r24	; 0x03

size_t Print::print(const __FlashStringHelper *ifsh)
{
  const char PROGMEM *p = (const char PROGMEM *)ifsh;
  size_t n = 0;
  while (1) {
    b75a:	d9 cf       	rjmp	.-78     	; 0xb70e <_ZN5Print5printEPK19__FlashStringHelper+0x2a>
    unsigned char c = pgm_read_byte(p++);
    if (c == 0) break;
    b75c:	00 00       	nop
    n += write(c);
  }
  return n;
    b75e:	8b 81       	ldd	r24, Y+3	; 0x03
    b760:	9c 81       	ldd	r25, Y+4	; 0x04
}
    b762:	2c 96       	adiw	r28, 0x0c	; 12
    b764:	0f b6       	in	r0, 0x3f	; 63
    b766:	f8 94       	cli
    b768:	de bf       	out	0x3e, r29	; 62
    b76a:	0f be       	out	0x3f, r0	; 63
    b76c:	cd bf       	out	0x3d, r28	; 61
    b76e:	df 91       	pop	r29
    b770:	cf 91       	pop	r28
    b772:	1f 91       	pop	r17
    b774:	08 95       	ret

0000b776 <_ZN5Print5printERK6String>:

size_t Print::print(const String &s)
{
    b776:	0f 93       	push	r16
    b778:	1f 93       	push	r17
    b77a:	cf 93       	push	r28
    b77c:	df 93       	push	r29
    b77e:	cd b7       	in	r28, 0x3d	; 61
    b780:	de b7       	in	r29, 0x3e	; 62
    b782:	28 97       	sbiw	r28, 0x08	; 8
    b784:	0f b6       	in	r0, 0x3f	; 63
    b786:	f8 94       	cli
    b788:	de bf       	out	0x3e, r29	; 62
    b78a:	0f be       	out	0x3f, r0	; 63
    b78c:	cd bf       	out	0x3d, r28	; 61
    b78e:	9e 83       	std	Y+6, r25	; 0x06
    b790:	8d 83       	std	Y+5, r24	; 0x05
    b792:	78 87       	std	Y+8, r23	; 0x08
    b794:	6f 83       	std	Y+7, r22	; 0x07
  size_t n = 0;
    b796:	1a 82       	std	Y+2, r1	; 0x02
    b798:	19 82       	std	Y+1, r1	; 0x01
  for (uint16_t i = 0; i < s.length(); i++) {
    b79a:	1c 82       	std	Y+4, r1	; 0x04
    b79c:	1b 82       	std	Y+3, r1	; 0x03
    b79e:	20 c0       	rjmp	.+64     	; 0xb7e0 <_ZN5Print5printERK6String+0x6a>
    n += write(s[i]);
    b7a0:	8d 81       	ldd	r24, Y+5	; 0x05
    b7a2:	9e 81       	ldd	r25, Y+6	; 0x06
    b7a4:	fc 01       	movw	r30, r24
    b7a6:	80 81       	ld	r24, Z
    b7a8:	91 81       	ldd	r25, Z+1	; 0x01
    b7aa:	fc 01       	movw	r30, r24
    b7ac:	00 81       	ld	r16, Z
    b7ae:	11 81       	ldd	r17, Z+1	; 0x01
    b7b0:	2b 81       	ldd	r18, Y+3	; 0x03
    b7b2:	3c 81       	ldd	r19, Y+4	; 0x04
    b7b4:	8f 81       	ldd	r24, Y+7	; 0x07
    b7b6:	98 85       	ldd	r25, Y+8	; 0x08
    b7b8:	b9 01       	movw	r22, r18
    b7ba:	0e 94 18 76 	call	0xec30	; 0xec30 <_ZNK6StringixEj>
    b7be:	28 2f       	mov	r18, r24
    b7c0:	8d 81       	ldd	r24, Y+5	; 0x05
    b7c2:	9e 81       	ldd	r25, Y+6	; 0x06
    b7c4:	62 2f       	mov	r22, r18
    b7c6:	f8 01       	movw	r30, r16
    b7c8:	09 95       	icall
    b7ca:	29 81       	ldd	r18, Y+1	; 0x01
    b7cc:	3a 81       	ldd	r19, Y+2	; 0x02
    b7ce:	82 0f       	add	r24, r18
    b7d0:	93 1f       	adc	r25, r19
    b7d2:	9a 83       	std	Y+2, r25	; 0x02
    b7d4:	89 83       	std	Y+1, r24	; 0x01
}

size_t Print::print(const String &s)
{
  size_t n = 0;
  for (uint16_t i = 0; i < s.length(); i++) {
    b7d6:	8b 81       	ldd	r24, Y+3	; 0x03
    b7d8:	9c 81       	ldd	r25, Y+4	; 0x04
    b7da:	01 96       	adiw	r24, 0x01	; 1
    b7dc:	9c 83       	std	Y+4, r25	; 0x04
    b7de:	8b 83       	std	Y+3, r24	; 0x03
    b7e0:	8f 81       	ldd	r24, Y+7	; 0x07
    b7e2:	98 85       	ldd	r25, Y+8	; 0x08
    b7e4:	0e 94 07 ad 	call	0x15a0e	; 0x15a0e <_ZNK6String6lengthEv>
    b7e8:	9c 01       	movw	r18, r24
    b7ea:	41 e0       	ldi	r20, 0x01	; 1
    b7ec:	8b 81       	ldd	r24, Y+3	; 0x03
    b7ee:	9c 81       	ldd	r25, Y+4	; 0x04
    b7f0:	82 17       	cp	r24, r18
    b7f2:	93 07       	cpc	r25, r19
    b7f4:	08 f0       	brcs	.+2      	; 0xb7f8 <_ZN5Print5printERK6String+0x82>
    b7f6:	40 e0       	ldi	r20, 0x00	; 0
    b7f8:	44 23       	and	r20, r20
    b7fa:	91 f6       	brne	.-92     	; 0xb7a0 <_ZN5Print5printERK6String+0x2a>
    n += write(s[i]);
  }
  return n;
    b7fc:	89 81       	ldd	r24, Y+1	; 0x01
    b7fe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    b800:	28 96       	adiw	r28, 0x08	; 8
    b802:	0f b6       	in	r0, 0x3f	; 63
    b804:	f8 94       	cli
    b806:	de bf       	out	0x3e, r29	; 62
    b808:	0f be       	out	0x3f, r0	; 63
    b80a:	cd bf       	out	0x3d, r28	; 61
    b80c:	df 91       	pop	r29
    b80e:	cf 91       	pop	r28
    b810:	1f 91       	pop	r17
    b812:	0f 91       	pop	r16
    b814:	08 95       	ret

0000b816 <_ZN5Print5printEPKc>:

size_t Print::print(const char str[])
{
    b816:	cf 93       	push	r28
    b818:	df 93       	push	r29
    b81a:	00 d0       	rcall	.+0      	; 0xb81c <_ZN5Print5printEPKc+0x6>
    b81c:	00 d0       	rcall	.+0      	; 0xb81e <_ZN5Print5printEPKc+0x8>
    b81e:	cd b7       	in	r28, 0x3d	; 61
    b820:	de b7       	in	r29, 0x3e	; 62
    b822:	9a 83       	std	Y+2, r25	; 0x02
    b824:	89 83       	std	Y+1, r24	; 0x01
    b826:	7c 83       	std	Y+4, r23	; 0x04
    b828:	6b 83       	std	Y+3, r22	; 0x03
  return write(str);
    b82a:	2b 81       	ldd	r18, Y+3	; 0x03
    b82c:	3c 81       	ldd	r19, Y+4	; 0x04
    b82e:	89 81       	ldd	r24, Y+1	; 0x01
    b830:	9a 81       	ldd	r25, Y+2	; 0x02
    b832:	b9 01       	movw	r22, r18
    b834:	0e 94 18 ad 	call	0x15a30	; 0x15a30 <_ZN5Print5writeEPKc>
}
    b838:	0f 90       	pop	r0
    b83a:	0f 90       	pop	r0
    b83c:	0f 90       	pop	r0
    b83e:	0f 90       	pop	r0
    b840:	df 91       	pop	r29
    b842:	cf 91       	pop	r28
    b844:	08 95       	ret

0000b846 <_ZN5Print5printEc>:

size_t Print::print(char c)
{
    b846:	cf 93       	push	r28
    b848:	df 93       	push	r29
    b84a:	00 d0       	rcall	.+0      	; 0xb84c <_ZN5Print5printEc+0x6>
    b84c:	1f 92       	push	r1
    b84e:	cd b7       	in	r28, 0x3d	; 61
    b850:	de b7       	in	r29, 0x3e	; 62
    b852:	9a 83       	std	Y+2, r25	; 0x02
    b854:	89 83       	std	Y+1, r24	; 0x01
    b856:	6b 83       	std	Y+3, r22	; 0x03
  return write(c);
    b858:	89 81       	ldd	r24, Y+1	; 0x01
    b85a:	9a 81       	ldd	r25, Y+2	; 0x02
    b85c:	fc 01       	movw	r30, r24
    b85e:	80 81       	ld	r24, Z
    b860:	91 81       	ldd	r25, Z+1	; 0x01
    b862:	fc 01       	movw	r30, r24
    b864:	20 81       	ld	r18, Z
    b866:	31 81       	ldd	r19, Z+1	; 0x01
    b868:	89 81       	ldd	r24, Y+1	; 0x01
    b86a:	9a 81       	ldd	r25, Y+2	; 0x02
    b86c:	6b 81       	ldd	r22, Y+3	; 0x03
    b86e:	f9 01       	movw	r30, r18
    b870:	09 95       	icall
}
    b872:	0f 90       	pop	r0
    b874:	0f 90       	pop	r0
    b876:	0f 90       	pop	r0
    b878:	df 91       	pop	r29
    b87a:	cf 91       	pop	r28
    b87c:	08 95       	ret

0000b87e <_ZN5Print5printEhi>:

size_t Print::print(unsigned char b, int base)
{
    b87e:	cf 93       	push	r28
    b880:	df 93       	push	r29
    b882:	00 d0       	rcall	.+0      	; 0xb884 <_ZN5Print5printEhi+0x6>
    b884:	00 d0       	rcall	.+0      	; 0xb886 <_ZN5Print5printEhi+0x8>
    b886:	1f 92       	push	r1
    b888:	cd b7       	in	r28, 0x3d	; 61
    b88a:	de b7       	in	r29, 0x3e	; 62
    b88c:	9a 83       	std	Y+2, r25	; 0x02
    b88e:	89 83       	std	Y+1, r24	; 0x01
    b890:	6b 83       	std	Y+3, r22	; 0x03
    b892:	5d 83       	std	Y+5, r21	; 0x05
    b894:	4c 83       	std	Y+4, r20	; 0x04
  return print((unsigned long) b, base);
    b896:	8b 81       	ldd	r24, Y+3	; 0x03
    b898:	88 2f       	mov	r24, r24
    b89a:	90 e0       	ldi	r25, 0x00	; 0
    b89c:	a0 e0       	ldi	r26, 0x00	; 0
    b89e:	b0 e0       	ldi	r27, 0x00	; 0
    b8a0:	2c 81       	ldd	r18, Y+4	; 0x04
    b8a2:	3d 81       	ldd	r19, Y+5	; 0x05
    b8a4:	e9 81       	ldd	r30, Y+1	; 0x01
    b8a6:	fa 81       	ldd	r31, Y+2	; 0x02
    b8a8:	ac 01       	movw	r20, r24
    b8aa:	bd 01       	movw	r22, r26
    b8ac:	cf 01       	movw	r24, r30
    b8ae:	0e 94 24 5d 	call	0xba48	; 0xba48 <_ZN5Print5printEmi>
}
    b8b2:	0f 90       	pop	r0
    b8b4:	0f 90       	pop	r0
    b8b6:	0f 90       	pop	r0
    b8b8:	0f 90       	pop	r0
    b8ba:	0f 90       	pop	r0
    b8bc:	df 91       	pop	r29
    b8be:	cf 91       	pop	r28
    b8c0:	08 95       	ret

0000b8c2 <_ZN5Print5printEii>:

size_t Print::print(int n, int base)
{
    b8c2:	cf 93       	push	r28
    b8c4:	df 93       	push	r29
    b8c6:	00 d0       	rcall	.+0      	; 0xb8c8 <_ZN5Print5printEii+0x6>
    b8c8:	00 d0       	rcall	.+0      	; 0xb8ca <_ZN5Print5printEii+0x8>
    b8ca:	00 d0       	rcall	.+0      	; 0xb8cc <_ZN5Print5printEii+0xa>
    b8cc:	cd b7       	in	r28, 0x3d	; 61
    b8ce:	de b7       	in	r29, 0x3e	; 62
    b8d0:	9a 83       	std	Y+2, r25	; 0x02
    b8d2:	89 83       	std	Y+1, r24	; 0x01
    b8d4:	7c 83       	std	Y+4, r23	; 0x04
    b8d6:	6b 83       	std	Y+3, r22	; 0x03
    b8d8:	5e 83       	std	Y+6, r21	; 0x06
    b8da:	4d 83       	std	Y+5, r20	; 0x05
  return print((long) n, base);
    b8dc:	8b 81       	ldd	r24, Y+3	; 0x03
    b8de:	9c 81       	ldd	r25, Y+4	; 0x04
    b8e0:	aa 27       	eor	r26, r26
    b8e2:	97 fd       	sbrc	r25, 7
    b8e4:	a0 95       	com	r26
    b8e6:	ba 2f       	mov	r27, r26
    b8e8:	2d 81       	ldd	r18, Y+5	; 0x05
    b8ea:	3e 81       	ldd	r19, Y+6	; 0x06
    b8ec:	e9 81       	ldd	r30, Y+1	; 0x01
    b8ee:	fa 81       	ldd	r31, Y+2	; 0x02
    b8f0:	ac 01       	movw	r20, r24
    b8f2:	bd 01       	movw	r22, r26
    b8f4:	cf 01       	movw	r24, r30
    b8f6:	0e 94 aa 5c 	call	0xb954	; 0xb954 <_ZN5Print5printEli>
}
    b8fa:	26 96       	adiw	r28, 0x06	; 6
    b8fc:	0f b6       	in	r0, 0x3f	; 63
    b8fe:	f8 94       	cli
    b900:	de bf       	out	0x3e, r29	; 62
    b902:	0f be       	out	0x3f, r0	; 63
    b904:	cd bf       	out	0x3d, r28	; 61
    b906:	df 91       	pop	r29
    b908:	cf 91       	pop	r28
    b90a:	08 95       	ret

0000b90c <_ZN5Print5printEji>:

size_t Print::print(unsigned int n, int base)
{
    b90c:	cf 93       	push	r28
    b90e:	df 93       	push	r29
    b910:	00 d0       	rcall	.+0      	; 0xb912 <_ZN5Print5printEji+0x6>
    b912:	00 d0       	rcall	.+0      	; 0xb914 <_ZN5Print5printEji+0x8>
    b914:	00 d0       	rcall	.+0      	; 0xb916 <_ZN5Print5printEji+0xa>
    b916:	cd b7       	in	r28, 0x3d	; 61
    b918:	de b7       	in	r29, 0x3e	; 62
    b91a:	9a 83       	std	Y+2, r25	; 0x02
    b91c:	89 83       	std	Y+1, r24	; 0x01
    b91e:	7c 83       	std	Y+4, r23	; 0x04
    b920:	6b 83       	std	Y+3, r22	; 0x03
    b922:	5e 83       	std	Y+6, r21	; 0x06
    b924:	4d 83       	std	Y+5, r20	; 0x05
  return print((unsigned long) n, base);
    b926:	8b 81       	ldd	r24, Y+3	; 0x03
    b928:	9c 81       	ldd	r25, Y+4	; 0x04
    b92a:	cc 01       	movw	r24, r24
    b92c:	a0 e0       	ldi	r26, 0x00	; 0
    b92e:	b0 e0       	ldi	r27, 0x00	; 0
    b930:	2d 81       	ldd	r18, Y+5	; 0x05
    b932:	3e 81       	ldd	r19, Y+6	; 0x06
    b934:	e9 81       	ldd	r30, Y+1	; 0x01
    b936:	fa 81       	ldd	r31, Y+2	; 0x02
    b938:	ac 01       	movw	r20, r24
    b93a:	bd 01       	movw	r22, r26
    b93c:	cf 01       	movw	r24, r30
    b93e:	0e 94 24 5d 	call	0xba48	; 0xba48 <_ZN5Print5printEmi>
}
    b942:	26 96       	adiw	r28, 0x06	; 6
    b944:	0f b6       	in	r0, 0x3f	; 63
    b946:	f8 94       	cli
    b948:	de bf       	out	0x3e, r29	; 62
    b94a:	0f be       	out	0x3f, r0	; 63
    b94c:	cd bf       	out	0x3d, r28	; 61
    b94e:	df 91       	pop	r29
    b950:	cf 91       	pop	r28
    b952:	08 95       	ret

0000b954 <_ZN5Print5printEli>:

size_t Print::print(long n, int base)
{
    b954:	cf 93       	push	r28
    b956:	df 93       	push	r29
    b958:	cd b7       	in	r28, 0x3d	; 61
    b95a:	de b7       	in	r29, 0x3e	; 62
    b95c:	2a 97       	sbiw	r28, 0x0a	; 10
    b95e:	0f b6       	in	r0, 0x3f	; 63
    b960:	f8 94       	cli
    b962:	de bf       	out	0x3e, r29	; 62
    b964:	0f be       	out	0x3f, r0	; 63
    b966:	cd bf       	out	0x3d, r28	; 61
    b968:	9c 83       	std	Y+4, r25	; 0x04
    b96a:	8b 83       	std	Y+3, r24	; 0x03
    b96c:	4d 83       	std	Y+5, r20	; 0x05
    b96e:	5e 83       	std	Y+6, r21	; 0x06
    b970:	6f 83       	std	Y+7, r22	; 0x07
    b972:	78 87       	std	Y+8, r23	; 0x08
    b974:	3a 87       	std	Y+10, r19	; 0x0a
    b976:	29 87       	std	Y+9, r18	; 0x09
  if (base == 0) {
    b978:	89 85       	ldd	r24, Y+9	; 0x09
    b97a:	9a 85       	ldd	r25, Y+10	; 0x0a
    b97c:	00 97       	sbiw	r24, 0x00	; 0
    b97e:	79 f4       	brne	.+30     	; 0xb99e <_ZN5Print5printEli+0x4a>
    return write(n);
    b980:	8b 81       	ldd	r24, Y+3	; 0x03
    b982:	9c 81       	ldd	r25, Y+4	; 0x04
    b984:	fc 01       	movw	r30, r24
    b986:	80 81       	ld	r24, Z
    b988:	91 81       	ldd	r25, Z+1	; 0x01
    b98a:	fc 01       	movw	r30, r24
    b98c:	20 81       	ld	r18, Z
    b98e:	31 81       	ldd	r19, Z+1	; 0x01
    b990:	4d 81       	ldd	r20, Y+5	; 0x05
    b992:	8b 81       	ldd	r24, Y+3	; 0x03
    b994:	9c 81       	ldd	r25, Y+4	; 0x04
    b996:	64 2f       	mov	r22, r20
    b998:	f9 01       	movw	r30, r18
    b99a:	09 95       	icall
    b99c:	4c c0       	rjmp	.+152    	; 0xba36 <_ZN5Print5printEli+0xe2>
  } else if (base == 10) {
    b99e:	89 85       	ldd	r24, Y+9	; 0x09
    b9a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    b9a2:	8a 30       	cpi	r24, 0x0A	; 10
    b9a4:	91 05       	cpc	r25, r1
    b9a6:	d9 f5       	brne	.+118    	; 0xba1e <_ZN5Print5printEli+0xca>
    if (n < 0) {
    b9a8:	8d 81       	ldd	r24, Y+5	; 0x05
    b9aa:	9e 81       	ldd	r25, Y+6	; 0x06
    b9ac:	af 81       	ldd	r26, Y+7	; 0x07
    b9ae:	b8 85       	ldd	r27, Y+8	; 0x08
    b9b0:	bb 23       	and	r27, r27
    b9b2:	44 f5       	brge	.+80     	; 0xba04 <_ZN5Print5printEli+0xb0>
      int t = print('-');
    b9b4:	8b 81       	ldd	r24, Y+3	; 0x03
    b9b6:	9c 81       	ldd	r25, Y+4	; 0x04
    b9b8:	6d e2       	ldi	r22, 0x2D	; 45
    b9ba:	0e 94 23 5c 	call	0xb846	; 0xb846 <_ZN5Print5printEc>
    b9be:	9a 83       	std	Y+2, r25	; 0x02
    b9c0:	89 83       	std	Y+1, r24	; 0x01
      n = -n;
    b9c2:	8d 81       	ldd	r24, Y+5	; 0x05
    b9c4:	9e 81       	ldd	r25, Y+6	; 0x06
    b9c6:	af 81       	ldd	r26, Y+7	; 0x07
    b9c8:	b8 85       	ldd	r27, Y+8	; 0x08
    b9ca:	b0 95       	com	r27
    b9cc:	a0 95       	com	r26
    b9ce:	90 95       	com	r25
    b9d0:	81 95       	neg	r24
    b9d2:	9f 4f       	sbci	r25, 0xFF	; 255
    b9d4:	af 4f       	sbci	r26, 0xFF	; 255
    b9d6:	bf 4f       	sbci	r27, 0xFF	; 255
    b9d8:	8d 83       	std	Y+5, r24	; 0x05
    b9da:	9e 83       	std	Y+6, r25	; 0x06
    b9dc:	af 83       	std	Y+7, r26	; 0x07
    b9de:	b8 87       	std	Y+8, r27	; 0x08
      return printNumber(n, 10) + t;
    b9e0:	8d 81       	ldd	r24, Y+5	; 0x05
    b9e2:	9e 81       	ldd	r25, Y+6	; 0x06
    b9e4:	af 81       	ldd	r26, Y+7	; 0x07
    b9e6:	b8 85       	ldd	r27, Y+8	; 0x08
    b9e8:	eb 81       	ldd	r30, Y+3	; 0x03
    b9ea:	fc 81       	ldd	r31, Y+4	; 0x04
    b9ec:	2a e0       	ldi	r18, 0x0A	; 10
    b9ee:	ac 01       	movw	r20, r24
    b9f0:	bd 01       	movw	r22, r26
    b9f2:	cf 01       	movw	r24, r30
    b9f4:	0e 94 c1 5f 	call	0xbf82	; 0xbf82 <_ZN5Print11printNumberEmh>
    b9f8:	9c 01       	movw	r18, r24
    b9fa:	89 81       	ldd	r24, Y+1	; 0x01
    b9fc:	9a 81       	ldd	r25, Y+2	; 0x02
    b9fe:	82 0f       	add	r24, r18
    ba00:	93 1f       	adc	r25, r19
    ba02:	19 c0       	rjmp	.+50     	; 0xba36 <_ZN5Print5printEli+0xe2>
    }
    return printNumber(n, 10);
    ba04:	8d 81       	ldd	r24, Y+5	; 0x05
    ba06:	9e 81       	ldd	r25, Y+6	; 0x06
    ba08:	af 81       	ldd	r26, Y+7	; 0x07
    ba0a:	b8 85       	ldd	r27, Y+8	; 0x08
    ba0c:	eb 81       	ldd	r30, Y+3	; 0x03
    ba0e:	fc 81       	ldd	r31, Y+4	; 0x04
    ba10:	2a e0       	ldi	r18, 0x0A	; 10
    ba12:	ac 01       	movw	r20, r24
    ba14:	bd 01       	movw	r22, r26
    ba16:	cf 01       	movw	r24, r30
    ba18:	0e 94 c1 5f 	call	0xbf82	; 0xbf82 <_ZN5Print11printNumberEmh>
    ba1c:	0c c0       	rjmp	.+24     	; 0xba36 <_ZN5Print5printEli+0xe2>
  } else {
    return printNumber(n, base);
    ba1e:	29 85       	ldd	r18, Y+9	; 0x09
    ba20:	8d 81       	ldd	r24, Y+5	; 0x05
    ba22:	9e 81       	ldd	r25, Y+6	; 0x06
    ba24:	af 81       	ldd	r26, Y+7	; 0x07
    ba26:	b8 85       	ldd	r27, Y+8	; 0x08
    ba28:	eb 81       	ldd	r30, Y+3	; 0x03
    ba2a:	fc 81       	ldd	r31, Y+4	; 0x04
    ba2c:	ac 01       	movw	r20, r24
    ba2e:	bd 01       	movw	r22, r26
    ba30:	cf 01       	movw	r24, r30
    ba32:	0e 94 c1 5f 	call	0xbf82	; 0xbf82 <_ZN5Print11printNumberEmh>
  }
}
    ba36:	2a 96       	adiw	r28, 0x0a	; 10
    ba38:	0f b6       	in	r0, 0x3f	; 63
    ba3a:	f8 94       	cli
    ba3c:	de bf       	out	0x3e, r29	; 62
    ba3e:	0f be       	out	0x3f, r0	; 63
    ba40:	cd bf       	out	0x3d, r28	; 61
    ba42:	df 91       	pop	r29
    ba44:	cf 91       	pop	r28
    ba46:	08 95       	ret

0000ba48 <_ZN5Print5printEmi>:

size_t Print::print(unsigned long n, int base)
{
    ba48:	cf 93       	push	r28
    ba4a:	df 93       	push	r29
    ba4c:	cd b7       	in	r28, 0x3d	; 61
    ba4e:	de b7       	in	r29, 0x3e	; 62
    ba50:	28 97       	sbiw	r28, 0x08	; 8
    ba52:	0f b6       	in	r0, 0x3f	; 63
    ba54:	f8 94       	cli
    ba56:	de bf       	out	0x3e, r29	; 62
    ba58:	0f be       	out	0x3f, r0	; 63
    ba5a:	cd bf       	out	0x3d, r28	; 61
    ba5c:	9a 83       	std	Y+2, r25	; 0x02
    ba5e:	89 83       	std	Y+1, r24	; 0x01
    ba60:	4b 83       	std	Y+3, r20	; 0x03
    ba62:	5c 83       	std	Y+4, r21	; 0x04
    ba64:	6d 83       	std	Y+5, r22	; 0x05
    ba66:	7e 83       	std	Y+6, r23	; 0x06
    ba68:	38 87       	std	Y+8, r19	; 0x08
    ba6a:	2f 83       	std	Y+7, r18	; 0x07
  if (base == 0) return write(n);
    ba6c:	8f 81       	ldd	r24, Y+7	; 0x07
    ba6e:	98 85       	ldd	r25, Y+8	; 0x08
    ba70:	00 97       	sbiw	r24, 0x00	; 0
    ba72:	79 f4       	brne	.+30     	; 0xba92 <_ZN5Print5printEmi+0x4a>
    ba74:	89 81       	ldd	r24, Y+1	; 0x01
    ba76:	9a 81       	ldd	r25, Y+2	; 0x02
    ba78:	fc 01       	movw	r30, r24
    ba7a:	80 81       	ld	r24, Z
    ba7c:	91 81       	ldd	r25, Z+1	; 0x01
    ba7e:	fc 01       	movw	r30, r24
    ba80:	20 81       	ld	r18, Z
    ba82:	31 81       	ldd	r19, Z+1	; 0x01
    ba84:	4b 81       	ldd	r20, Y+3	; 0x03
    ba86:	89 81       	ldd	r24, Y+1	; 0x01
    ba88:	9a 81       	ldd	r25, Y+2	; 0x02
    ba8a:	64 2f       	mov	r22, r20
    ba8c:	f9 01       	movw	r30, r18
    ba8e:	09 95       	icall
    ba90:	0c c0       	rjmp	.+24     	; 0xbaaa <_ZN5Print5printEmi+0x62>
  else return printNumber(n, base);
    ba92:	2f 81       	ldd	r18, Y+7	; 0x07
    ba94:	8b 81       	ldd	r24, Y+3	; 0x03
    ba96:	9c 81       	ldd	r25, Y+4	; 0x04
    ba98:	ad 81       	ldd	r26, Y+5	; 0x05
    ba9a:	be 81       	ldd	r27, Y+6	; 0x06
    ba9c:	e9 81       	ldd	r30, Y+1	; 0x01
    ba9e:	fa 81       	ldd	r31, Y+2	; 0x02
    baa0:	ac 01       	movw	r20, r24
    baa2:	bd 01       	movw	r22, r26
    baa4:	cf 01       	movw	r24, r30
    baa6:	0e 94 c1 5f 	call	0xbf82	; 0xbf82 <_ZN5Print11printNumberEmh>
}
    baaa:	28 96       	adiw	r28, 0x08	; 8
    baac:	0f b6       	in	r0, 0x3f	; 63
    baae:	f8 94       	cli
    bab0:	de bf       	out	0x3e, r29	; 62
    bab2:	0f be       	out	0x3f, r0	; 63
    bab4:	cd bf       	out	0x3d, r28	; 61
    bab6:	df 91       	pop	r29
    bab8:	cf 91       	pop	r28
    baba:	08 95       	ret

0000babc <_ZN5Print5printEdi>:

size_t Print::print(double n, int digits)
{
    babc:	cf 93       	push	r28
    babe:	df 93       	push	r29
    bac0:	cd b7       	in	r28, 0x3d	; 61
    bac2:	de b7       	in	r29, 0x3e	; 62
    bac4:	28 97       	sbiw	r28, 0x08	; 8
    bac6:	0f b6       	in	r0, 0x3f	; 63
    bac8:	f8 94       	cli
    baca:	de bf       	out	0x3e, r29	; 62
    bacc:	0f be       	out	0x3f, r0	; 63
    bace:	cd bf       	out	0x3d, r28	; 61
    bad0:	9a 83       	std	Y+2, r25	; 0x02
    bad2:	89 83       	std	Y+1, r24	; 0x01
    bad4:	4b 83       	std	Y+3, r20	; 0x03
    bad6:	5c 83       	std	Y+4, r21	; 0x04
    bad8:	6d 83       	std	Y+5, r22	; 0x05
    bada:	7e 83       	std	Y+6, r23	; 0x06
    badc:	38 87       	std	Y+8, r19	; 0x08
    bade:	2f 83       	std	Y+7, r18	; 0x07
  return printFloat(n, digits);
    bae0:	2f 81       	ldd	r18, Y+7	; 0x07
    bae2:	8b 81       	ldd	r24, Y+3	; 0x03
    bae4:	9c 81       	ldd	r25, Y+4	; 0x04
    bae6:	ad 81       	ldd	r26, Y+5	; 0x05
    bae8:	be 81       	ldd	r27, Y+6	; 0x06
    baea:	e9 81       	ldd	r30, Y+1	; 0x01
    baec:	fa 81       	ldd	r31, Y+2	; 0x02
    baee:	ac 01       	movw	r20, r24
    baf0:	bd 01       	movw	r22, r26
    baf2:	cf 01       	movw	r24, r30
    baf4:	0e 94 33 60 	call	0xc066	; 0xc066 <_ZN5Print10printFloatEdh>
}
    baf8:	28 96       	adiw	r28, 0x08	; 8
    bafa:	0f b6       	in	r0, 0x3f	; 63
    bafc:	f8 94       	cli
    bafe:	de bf       	out	0x3e, r29	; 62
    bb00:	0f be       	out	0x3f, r0	; 63
    bb02:	cd bf       	out	0x3d, r28	; 61
    bb04:	df 91       	pop	r29
    bb06:	cf 91       	pop	r28
    bb08:	08 95       	ret

0000bb0a <_ZN5Print7printlnEPK19__FlashStringHelper>:

size_t Print::println(const __FlashStringHelper *ifsh)
{
    bb0a:	cf 93       	push	r28
    bb0c:	df 93       	push	r29
    bb0e:	00 d0       	rcall	.+0      	; 0xbb10 <_ZN5Print7printlnEPK19__FlashStringHelper+0x6>
    bb10:	00 d0       	rcall	.+0      	; 0xbb12 <_ZN5Print7printlnEPK19__FlashStringHelper+0x8>
    bb12:	00 d0       	rcall	.+0      	; 0xbb14 <_ZN5Print7printlnEPK19__FlashStringHelper+0xa>
    bb14:	cd b7       	in	r28, 0x3d	; 61
    bb16:	de b7       	in	r29, 0x3e	; 62
    bb18:	9c 83       	std	Y+4, r25	; 0x04
    bb1a:	8b 83       	std	Y+3, r24	; 0x03
    bb1c:	7e 83       	std	Y+6, r23	; 0x06
    bb1e:	6d 83       	std	Y+5, r22	; 0x05
  size_t n = print(ifsh);
    bb20:	2d 81       	ldd	r18, Y+5	; 0x05
    bb22:	3e 81       	ldd	r19, Y+6	; 0x06
    bb24:	8b 81       	ldd	r24, Y+3	; 0x03
    bb26:	9c 81       	ldd	r25, Y+4	; 0x04
    bb28:	b9 01       	movw	r22, r18
    bb2a:	0e 94 72 5b 	call	0xb6e4	; 0xb6e4 <_ZN5Print5printEPK19__FlashStringHelper>
    bb2e:	9a 83       	std	Y+2, r25	; 0x02
    bb30:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    bb32:	8b 81       	ldd	r24, Y+3	; 0x03
    bb34:	9c 81       	ldd	r25, Y+4	; 0x04
    bb36:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    bb3a:	29 81       	ldd	r18, Y+1	; 0x01
    bb3c:	3a 81       	ldd	r19, Y+2	; 0x02
    bb3e:	82 0f       	add	r24, r18
    bb40:	93 1f       	adc	r25, r19
    bb42:	9a 83       	std	Y+2, r25	; 0x02
    bb44:	89 83       	std	Y+1, r24	; 0x01
  return n;
    bb46:	89 81       	ldd	r24, Y+1	; 0x01
    bb48:	9a 81       	ldd	r25, Y+2	; 0x02
}
    bb4a:	26 96       	adiw	r28, 0x06	; 6
    bb4c:	0f b6       	in	r0, 0x3f	; 63
    bb4e:	f8 94       	cli
    bb50:	de bf       	out	0x3e, r29	; 62
    bb52:	0f be       	out	0x3f, r0	; 63
    bb54:	cd bf       	out	0x3d, r28	; 61
    bb56:	df 91       	pop	r29
    bb58:	cf 91       	pop	r28
    bb5a:	08 95       	ret

0000bb5c <_ZN5Print5printERK9Printable>:

size_t Print::print(const Printable& x)
{
    bb5c:	cf 93       	push	r28
    bb5e:	df 93       	push	r29
    bb60:	00 d0       	rcall	.+0      	; 0xbb62 <_ZN5Print5printERK9Printable+0x6>
    bb62:	00 d0       	rcall	.+0      	; 0xbb64 <_ZN5Print5printERK9Printable+0x8>
    bb64:	cd b7       	in	r28, 0x3d	; 61
    bb66:	de b7       	in	r29, 0x3e	; 62
    bb68:	9a 83       	std	Y+2, r25	; 0x02
    bb6a:	89 83       	std	Y+1, r24	; 0x01
    bb6c:	7c 83       	std	Y+4, r23	; 0x04
    bb6e:	6b 83       	std	Y+3, r22	; 0x03
  return x.printTo(*this);
    bb70:	8b 81       	ldd	r24, Y+3	; 0x03
    bb72:	9c 81       	ldd	r25, Y+4	; 0x04
    bb74:	fc 01       	movw	r30, r24
    bb76:	80 81       	ld	r24, Z
    bb78:	91 81       	ldd	r25, Z+1	; 0x01
    bb7a:	fc 01       	movw	r30, r24
    bb7c:	20 81       	ld	r18, Z
    bb7e:	31 81       	ldd	r19, Z+1	; 0x01
    bb80:	49 81       	ldd	r20, Y+1	; 0x01
    bb82:	5a 81       	ldd	r21, Y+2	; 0x02
    bb84:	8b 81       	ldd	r24, Y+3	; 0x03
    bb86:	9c 81       	ldd	r25, Y+4	; 0x04
    bb88:	ba 01       	movw	r22, r20
    bb8a:	f9 01       	movw	r30, r18
    bb8c:	09 95       	icall
}
    bb8e:	0f 90       	pop	r0
    bb90:	0f 90       	pop	r0
    bb92:	0f 90       	pop	r0
    bb94:	0f 90       	pop	r0
    bb96:	df 91       	pop	r29
    bb98:	cf 91       	pop	r28
    bb9a:	08 95       	ret

0000bb9c <_ZN5Print7printlnEv>:

size_t Print::println(void)
{
    bb9c:	cf 93       	push	r28
    bb9e:	df 93       	push	r29
    bba0:	00 d0       	rcall	.+0      	; 0xbba2 <_ZN5Print7printlnEv+0x6>
    bba2:	00 d0       	rcall	.+0      	; 0xbba4 <_ZN5Print7printlnEv+0x8>
    bba4:	cd b7       	in	r28, 0x3d	; 61
    bba6:	de b7       	in	r29, 0x3e	; 62
    bba8:	9c 83       	std	Y+4, r25	; 0x04
    bbaa:	8b 83       	std	Y+3, r24	; 0x03
  size_t n = print('\r');
    bbac:	8b 81       	ldd	r24, Y+3	; 0x03
    bbae:	9c 81       	ldd	r25, Y+4	; 0x04
    bbb0:	6d e0       	ldi	r22, 0x0D	; 13
    bbb2:	0e 94 23 5c 	call	0xb846	; 0xb846 <_ZN5Print5printEc>
    bbb6:	9a 83       	std	Y+2, r25	; 0x02
    bbb8:	89 83       	std	Y+1, r24	; 0x01
  n += print('\n');
    bbba:	8b 81       	ldd	r24, Y+3	; 0x03
    bbbc:	9c 81       	ldd	r25, Y+4	; 0x04
    bbbe:	6a e0       	ldi	r22, 0x0A	; 10
    bbc0:	0e 94 23 5c 	call	0xb846	; 0xb846 <_ZN5Print5printEc>
    bbc4:	29 81       	ldd	r18, Y+1	; 0x01
    bbc6:	3a 81       	ldd	r19, Y+2	; 0x02
    bbc8:	82 0f       	add	r24, r18
    bbca:	93 1f       	adc	r25, r19
    bbcc:	9a 83       	std	Y+2, r25	; 0x02
    bbce:	89 83       	std	Y+1, r24	; 0x01
  return n;
    bbd0:	89 81       	ldd	r24, Y+1	; 0x01
    bbd2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    bbd4:	0f 90       	pop	r0
    bbd6:	0f 90       	pop	r0
    bbd8:	0f 90       	pop	r0
    bbda:	0f 90       	pop	r0
    bbdc:	df 91       	pop	r29
    bbde:	cf 91       	pop	r28
    bbe0:	08 95       	ret

0000bbe2 <_ZN5Print7printlnERK6String>:

size_t Print::println(const String &s)
{
    bbe2:	cf 93       	push	r28
    bbe4:	df 93       	push	r29
    bbe6:	00 d0       	rcall	.+0      	; 0xbbe8 <_ZN5Print7printlnERK6String+0x6>
    bbe8:	00 d0       	rcall	.+0      	; 0xbbea <_ZN5Print7printlnERK6String+0x8>
    bbea:	00 d0       	rcall	.+0      	; 0xbbec <_ZN5Print7printlnERK6String+0xa>
    bbec:	cd b7       	in	r28, 0x3d	; 61
    bbee:	de b7       	in	r29, 0x3e	; 62
    bbf0:	9c 83       	std	Y+4, r25	; 0x04
    bbf2:	8b 83       	std	Y+3, r24	; 0x03
    bbf4:	7e 83       	std	Y+6, r23	; 0x06
    bbf6:	6d 83       	std	Y+5, r22	; 0x05
  size_t n = print(s);
    bbf8:	2d 81       	ldd	r18, Y+5	; 0x05
    bbfa:	3e 81       	ldd	r19, Y+6	; 0x06
    bbfc:	8b 81       	ldd	r24, Y+3	; 0x03
    bbfe:	9c 81       	ldd	r25, Y+4	; 0x04
    bc00:	b9 01       	movw	r22, r18
    bc02:	0e 94 bb 5b 	call	0xb776	; 0xb776 <_ZN5Print5printERK6String>
    bc06:	9a 83       	std	Y+2, r25	; 0x02
    bc08:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    bc0a:	8b 81       	ldd	r24, Y+3	; 0x03
    bc0c:	9c 81       	ldd	r25, Y+4	; 0x04
    bc0e:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    bc12:	29 81       	ldd	r18, Y+1	; 0x01
    bc14:	3a 81       	ldd	r19, Y+2	; 0x02
    bc16:	82 0f       	add	r24, r18
    bc18:	93 1f       	adc	r25, r19
    bc1a:	9a 83       	std	Y+2, r25	; 0x02
    bc1c:	89 83       	std	Y+1, r24	; 0x01
  return n;
    bc1e:	89 81       	ldd	r24, Y+1	; 0x01
    bc20:	9a 81       	ldd	r25, Y+2	; 0x02
}
    bc22:	26 96       	adiw	r28, 0x06	; 6
    bc24:	0f b6       	in	r0, 0x3f	; 63
    bc26:	f8 94       	cli
    bc28:	de bf       	out	0x3e, r29	; 62
    bc2a:	0f be       	out	0x3f, r0	; 63
    bc2c:	cd bf       	out	0x3d, r28	; 61
    bc2e:	df 91       	pop	r29
    bc30:	cf 91       	pop	r28
    bc32:	08 95       	ret

0000bc34 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
    bc34:	cf 93       	push	r28
    bc36:	df 93       	push	r29
    bc38:	00 d0       	rcall	.+0      	; 0xbc3a <_ZN5Print7printlnEPKc+0x6>
    bc3a:	00 d0       	rcall	.+0      	; 0xbc3c <_ZN5Print7printlnEPKc+0x8>
    bc3c:	00 d0       	rcall	.+0      	; 0xbc3e <_ZN5Print7printlnEPKc+0xa>
    bc3e:	cd b7       	in	r28, 0x3d	; 61
    bc40:	de b7       	in	r29, 0x3e	; 62
    bc42:	9c 83       	std	Y+4, r25	; 0x04
    bc44:	8b 83       	std	Y+3, r24	; 0x03
    bc46:	7e 83       	std	Y+6, r23	; 0x06
    bc48:	6d 83       	std	Y+5, r22	; 0x05
  size_t n = print(c);
    bc4a:	2d 81       	ldd	r18, Y+5	; 0x05
    bc4c:	3e 81       	ldd	r19, Y+6	; 0x06
    bc4e:	8b 81       	ldd	r24, Y+3	; 0x03
    bc50:	9c 81       	ldd	r25, Y+4	; 0x04
    bc52:	b9 01       	movw	r22, r18
    bc54:	0e 94 0b 5c 	call	0xb816	; 0xb816 <_ZN5Print5printEPKc>
    bc58:	9a 83       	std	Y+2, r25	; 0x02
    bc5a:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    bc5c:	8b 81       	ldd	r24, Y+3	; 0x03
    bc5e:	9c 81       	ldd	r25, Y+4	; 0x04
    bc60:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    bc64:	29 81       	ldd	r18, Y+1	; 0x01
    bc66:	3a 81       	ldd	r19, Y+2	; 0x02
    bc68:	82 0f       	add	r24, r18
    bc6a:	93 1f       	adc	r25, r19
    bc6c:	9a 83       	std	Y+2, r25	; 0x02
    bc6e:	89 83       	std	Y+1, r24	; 0x01
  return n;
    bc70:	89 81       	ldd	r24, Y+1	; 0x01
    bc72:	9a 81       	ldd	r25, Y+2	; 0x02
}
    bc74:	26 96       	adiw	r28, 0x06	; 6
    bc76:	0f b6       	in	r0, 0x3f	; 63
    bc78:	f8 94       	cli
    bc7a:	de bf       	out	0x3e, r29	; 62
    bc7c:	0f be       	out	0x3f, r0	; 63
    bc7e:	cd bf       	out	0x3d, r28	; 61
    bc80:	df 91       	pop	r29
    bc82:	cf 91       	pop	r28
    bc84:	08 95       	ret

0000bc86 <_ZN5Print7printlnEc>:

size_t Print::println(char c)
{
    bc86:	cf 93       	push	r28
    bc88:	df 93       	push	r29
    bc8a:	00 d0       	rcall	.+0      	; 0xbc8c <_ZN5Print7printlnEc+0x6>
    bc8c:	00 d0       	rcall	.+0      	; 0xbc8e <_ZN5Print7printlnEc+0x8>
    bc8e:	1f 92       	push	r1
    bc90:	cd b7       	in	r28, 0x3d	; 61
    bc92:	de b7       	in	r29, 0x3e	; 62
    bc94:	9c 83       	std	Y+4, r25	; 0x04
    bc96:	8b 83       	std	Y+3, r24	; 0x03
    bc98:	6d 83       	std	Y+5, r22	; 0x05
  size_t n = print(c);
    bc9a:	8b 81       	ldd	r24, Y+3	; 0x03
    bc9c:	9c 81       	ldd	r25, Y+4	; 0x04
    bc9e:	6d 81       	ldd	r22, Y+5	; 0x05
    bca0:	0e 94 23 5c 	call	0xb846	; 0xb846 <_ZN5Print5printEc>
    bca4:	9a 83       	std	Y+2, r25	; 0x02
    bca6:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    bca8:	8b 81       	ldd	r24, Y+3	; 0x03
    bcaa:	9c 81       	ldd	r25, Y+4	; 0x04
    bcac:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    bcb0:	29 81       	ldd	r18, Y+1	; 0x01
    bcb2:	3a 81       	ldd	r19, Y+2	; 0x02
    bcb4:	82 0f       	add	r24, r18
    bcb6:	93 1f       	adc	r25, r19
    bcb8:	9a 83       	std	Y+2, r25	; 0x02
    bcba:	89 83       	std	Y+1, r24	; 0x01
  return n;
    bcbc:	89 81       	ldd	r24, Y+1	; 0x01
    bcbe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    bcc0:	0f 90       	pop	r0
    bcc2:	0f 90       	pop	r0
    bcc4:	0f 90       	pop	r0
    bcc6:	0f 90       	pop	r0
    bcc8:	0f 90       	pop	r0
    bcca:	df 91       	pop	r29
    bccc:	cf 91       	pop	r28
    bcce:	08 95       	ret

0000bcd0 <_ZN5Print7printlnEhi>:

size_t Print::println(unsigned char b, int base)
{
    bcd0:	cf 93       	push	r28
    bcd2:	df 93       	push	r29
    bcd4:	cd b7       	in	r28, 0x3d	; 61
    bcd6:	de b7       	in	r29, 0x3e	; 62
    bcd8:	27 97       	sbiw	r28, 0x07	; 7
    bcda:	0f b6       	in	r0, 0x3f	; 63
    bcdc:	f8 94       	cli
    bcde:	de bf       	out	0x3e, r29	; 62
    bce0:	0f be       	out	0x3f, r0	; 63
    bce2:	cd bf       	out	0x3d, r28	; 61
    bce4:	9c 83       	std	Y+4, r25	; 0x04
    bce6:	8b 83       	std	Y+3, r24	; 0x03
    bce8:	6d 83       	std	Y+5, r22	; 0x05
    bcea:	5f 83       	std	Y+7, r21	; 0x07
    bcec:	4e 83       	std	Y+6, r20	; 0x06
  size_t n = print(b, base);
    bcee:	2e 81       	ldd	r18, Y+6	; 0x06
    bcf0:	3f 81       	ldd	r19, Y+7	; 0x07
    bcf2:	8b 81       	ldd	r24, Y+3	; 0x03
    bcf4:	9c 81       	ldd	r25, Y+4	; 0x04
    bcf6:	a9 01       	movw	r20, r18
    bcf8:	6d 81       	ldd	r22, Y+5	; 0x05
    bcfa:	0e 94 3f 5c 	call	0xb87e	; 0xb87e <_ZN5Print5printEhi>
    bcfe:	9a 83       	std	Y+2, r25	; 0x02
    bd00:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    bd02:	8b 81       	ldd	r24, Y+3	; 0x03
    bd04:	9c 81       	ldd	r25, Y+4	; 0x04
    bd06:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    bd0a:	29 81       	ldd	r18, Y+1	; 0x01
    bd0c:	3a 81       	ldd	r19, Y+2	; 0x02
    bd0e:	82 0f       	add	r24, r18
    bd10:	93 1f       	adc	r25, r19
    bd12:	9a 83       	std	Y+2, r25	; 0x02
    bd14:	89 83       	std	Y+1, r24	; 0x01
  return n;
    bd16:	89 81       	ldd	r24, Y+1	; 0x01
    bd18:	9a 81       	ldd	r25, Y+2	; 0x02
}
    bd1a:	27 96       	adiw	r28, 0x07	; 7
    bd1c:	0f b6       	in	r0, 0x3f	; 63
    bd1e:	f8 94       	cli
    bd20:	de bf       	out	0x3e, r29	; 62
    bd22:	0f be       	out	0x3f, r0	; 63
    bd24:	cd bf       	out	0x3d, r28	; 61
    bd26:	df 91       	pop	r29
    bd28:	cf 91       	pop	r28
    bd2a:	08 95       	ret

0000bd2c <_ZN5Print7printlnEii>:

size_t Print::println(int num, int base)
{
    bd2c:	cf 93       	push	r28
    bd2e:	df 93       	push	r29
    bd30:	cd b7       	in	r28, 0x3d	; 61
    bd32:	de b7       	in	r29, 0x3e	; 62
    bd34:	28 97       	sbiw	r28, 0x08	; 8
    bd36:	0f b6       	in	r0, 0x3f	; 63
    bd38:	f8 94       	cli
    bd3a:	de bf       	out	0x3e, r29	; 62
    bd3c:	0f be       	out	0x3f, r0	; 63
    bd3e:	cd bf       	out	0x3d, r28	; 61
    bd40:	9c 83       	std	Y+4, r25	; 0x04
    bd42:	8b 83       	std	Y+3, r24	; 0x03
    bd44:	7e 83       	std	Y+6, r23	; 0x06
    bd46:	6d 83       	std	Y+5, r22	; 0x05
    bd48:	58 87       	std	Y+8, r21	; 0x08
    bd4a:	4f 83       	std	Y+7, r20	; 0x07
  size_t n = print(num, base);
    bd4c:	4f 81       	ldd	r20, Y+7	; 0x07
    bd4e:	58 85       	ldd	r21, Y+8	; 0x08
    bd50:	2d 81       	ldd	r18, Y+5	; 0x05
    bd52:	3e 81       	ldd	r19, Y+6	; 0x06
    bd54:	8b 81       	ldd	r24, Y+3	; 0x03
    bd56:	9c 81       	ldd	r25, Y+4	; 0x04
    bd58:	b9 01       	movw	r22, r18
    bd5a:	0e 94 61 5c 	call	0xb8c2	; 0xb8c2 <_ZN5Print5printEii>
    bd5e:	9a 83       	std	Y+2, r25	; 0x02
    bd60:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    bd62:	8b 81       	ldd	r24, Y+3	; 0x03
    bd64:	9c 81       	ldd	r25, Y+4	; 0x04
    bd66:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    bd6a:	29 81       	ldd	r18, Y+1	; 0x01
    bd6c:	3a 81       	ldd	r19, Y+2	; 0x02
    bd6e:	82 0f       	add	r24, r18
    bd70:	93 1f       	adc	r25, r19
    bd72:	9a 83       	std	Y+2, r25	; 0x02
    bd74:	89 83       	std	Y+1, r24	; 0x01
  return n;
    bd76:	89 81       	ldd	r24, Y+1	; 0x01
    bd78:	9a 81       	ldd	r25, Y+2	; 0x02
}
    bd7a:	28 96       	adiw	r28, 0x08	; 8
    bd7c:	0f b6       	in	r0, 0x3f	; 63
    bd7e:	f8 94       	cli
    bd80:	de bf       	out	0x3e, r29	; 62
    bd82:	0f be       	out	0x3f, r0	; 63
    bd84:	cd bf       	out	0x3d, r28	; 61
    bd86:	df 91       	pop	r29
    bd88:	cf 91       	pop	r28
    bd8a:	08 95       	ret

0000bd8c <_ZN5Print7printlnEji>:

size_t Print::println(unsigned int num, int base)
{
    bd8c:	cf 93       	push	r28
    bd8e:	df 93       	push	r29
    bd90:	cd b7       	in	r28, 0x3d	; 61
    bd92:	de b7       	in	r29, 0x3e	; 62
    bd94:	28 97       	sbiw	r28, 0x08	; 8
    bd96:	0f b6       	in	r0, 0x3f	; 63
    bd98:	f8 94       	cli
    bd9a:	de bf       	out	0x3e, r29	; 62
    bd9c:	0f be       	out	0x3f, r0	; 63
    bd9e:	cd bf       	out	0x3d, r28	; 61
    bda0:	9c 83       	std	Y+4, r25	; 0x04
    bda2:	8b 83       	std	Y+3, r24	; 0x03
    bda4:	7e 83       	std	Y+6, r23	; 0x06
    bda6:	6d 83       	std	Y+5, r22	; 0x05
    bda8:	58 87       	std	Y+8, r21	; 0x08
    bdaa:	4f 83       	std	Y+7, r20	; 0x07
  size_t n = print(num, base);
    bdac:	4f 81       	ldd	r20, Y+7	; 0x07
    bdae:	58 85       	ldd	r21, Y+8	; 0x08
    bdb0:	2d 81       	ldd	r18, Y+5	; 0x05
    bdb2:	3e 81       	ldd	r19, Y+6	; 0x06
    bdb4:	8b 81       	ldd	r24, Y+3	; 0x03
    bdb6:	9c 81       	ldd	r25, Y+4	; 0x04
    bdb8:	b9 01       	movw	r22, r18
    bdba:	0e 94 86 5c 	call	0xb90c	; 0xb90c <_ZN5Print5printEji>
    bdbe:	9a 83       	std	Y+2, r25	; 0x02
    bdc0:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    bdc2:	8b 81       	ldd	r24, Y+3	; 0x03
    bdc4:	9c 81       	ldd	r25, Y+4	; 0x04
    bdc6:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    bdca:	29 81       	ldd	r18, Y+1	; 0x01
    bdcc:	3a 81       	ldd	r19, Y+2	; 0x02
    bdce:	82 0f       	add	r24, r18
    bdd0:	93 1f       	adc	r25, r19
    bdd2:	9a 83       	std	Y+2, r25	; 0x02
    bdd4:	89 83       	std	Y+1, r24	; 0x01
  return n;
    bdd6:	89 81       	ldd	r24, Y+1	; 0x01
    bdd8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    bdda:	28 96       	adiw	r28, 0x08	; 8
    bddc:	0f b6       	in	r0, 0x3f	; 63
    bdde:	f8 94       	cli
    bde0:	de bf       	out	0x3e, r29	; 62
    bde2:	0f be       	out	0x3f, r0	; 63
    bde4:	cd bf       	out	0x3d, r28	; 61
    bde6:	df 91       	pop	r29
    bde8:	cf 91       	pop	r28
    bdea:	08 95       	ret

0000bdec <_ZN5Print7printlnEli>:

size_t Print::println(long num, int base)
{
    bdec:	cf 93       	push	r28
    bdee:	df 93       	push	r29
    bdf0:	cd b7       	in	r28, 0x3d	; 61
    bdf2:	de b7       	in	r29, 0x3e	; 62
    bdf4:	2a 97       	sbiw	r28, 0x0a	; 10
    bdf6:	0f b6       	in	r0, 0x3f	; 63
    bdf8:	f8 94       	cli
    bdfa:	de bf       	out	0x3e, r29	; 62
    bdfc:	0f be       	out	0x3f, r0	; 63
    bdfe:	cd bf       	out	0x3d, r28	; 61
    be00:	9c 83       	std	Y+4, r25	; 0x04
    be02:	8b 83       	std	Y+3, r24	; 0x03
    be04:	4d 83       	std	Y+5, r20	; 0x05
    be06:	5e 83       	std	Y+6, r21	; 0x06
    be08:	6f 83       	std	Y+7, r22	; 0x07
    be0a:	78 87       	std	Y+8, r23	; 0x08
    be0c:	3a 87       	std	Y+10, r19	; 0x0a
    be0e:	29 87       	std	Y+9, r18	; 0x09
  size_t n = print(num, base);
    be10:	29 85       	ldd	r18, Y+9	; 0x09
    be12:	3a 85       	ldd	r19, Y+10	; 0x0a
    be14:	8d 81       	ldd	r24, Y+5	; 0x05
    be16:	9e 81       	ldd	r25, Y+6	; 0x06
    be18:	af 81       	ldd	r26, Y+7	; 0x07
    be1a:	b8 85       	ldd	r27, Y+8	; 0x08
    be1c:	eb 81       	ldd	r30, Y+3	; 0x03
    be1e:	fc 81       	ldd	r31, Y+4	; 0x04
    be20:	ac 01       	movw	r20, r24
    be22:	bd 01       	movw	r22, r26
    be24:	cf 01       	movw	r24, r30
    be26:	0e 94 aa 5c 	call	0xb954	; 0xb954 <_ZN5Print5printEli>
    be2a:	9a 83       	std	Y+2, r25	; 0x02
    be2c:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    be2e:	8b 81       	ldd	r24, Y+3	; 0x03
    be30:	9c 81       	ldd	r25, Y+4	; 0x04
    be32:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    be36:	29 81       	ldd	r18, Y+1	; 0x01
    be38:	3a 81       	ldd	r19, Y+2	; 0x02
    be3a:	82 0f       	add	r24, r18
    be3c:	93 1f       	adc	r25, r19
    be3e:	9a 83       	std	Y+2, r25	; 0x02
    be40:	89 83       	std	Y+1, r24	; 0x01
  return n;
    be42:	89 81       	ldd	r24, Y+1	; 0x01
    be44:	9a 81       	ldd	r25, Y+2	; 0x02
}
    be46:	2a 96       	adiw	r28, 0x0a	; 10
    be48:	0f b6       	in	r0, 0x3f	; 63
    be4a:	f8 94       	cli
    be4c:	de bf       	out	0x3e, r29	; 62
    be4e:	0f be       	out	0x3f, r0	; 63
    be50:	cd bf       	out	0x3d, r28	; 61
    be52:	df 91       	pop	r29
    be54:	cf 91       	pop	r28
    be56:	08 95       	ret

0000be58 <_ZN5Print7printlnEmi>:

size_t Print::println(unsigned long num, int base)
{
    be58:	cf 93       	push	r28
    be5a:	df 93       	push	r29
    be5c:	cd b7       	in	r28, 0x3d	; 61
    be5e:	de b7       	in	r29, 0x3e	; 62
    be60:	2a 97       	sbiw	r28, 0x0a	; 10
    be62:	0f b6       	in	r0, 0x3f	; 63
    be64:	f8 94       	cli
    be66:	de bf       	out	0x3e, r29	; 62
    be68:	0f be       	out	0x3f, r0	; 63
    be6a:	cd bf       	out	0x3d, r28	; 61
    be6c:	9c 83       	std	Y+4, r25	; 0x04
    be6e:	8b 83       	std	Y+3, r24	; 0x03
    be70:	4d 83       	std	Y+5, r20	; 0x05
    be72:	5e 83       	std	Y+6, r21	; 0x06
    be74:	6f 83       	std	Y+7, r22	; 0x07
    be76:	78 87       	std	Y+8, r23	; 0x08
    be78:	3a 87       	std	Y+10, r19	; 0x0a
    be7a:	29 87       	std	Y+9, r18	; 0x09
  size_t n = print(num, base);
    be7c:	29 85       	ldd	r18, Y+9	; 0x09
    be7e:	3a 85       	ldd	r19, Y+10	; 0x0a
    be80:	8d 81       	ldd	r24, Y+5	; 0x05
    be82:	9e 81       	ldd	r25, Y+6	; 0x06
    be84:	af 81       	ldd	r26, Y+7	; 0x07
    be86:	b8 85       	ldd	r27, Y+8	; 0x08
    be88:	eb 81       	ldd	r30, Y+3	; 0x03
    be8a:	fc 81       	ldd	r31, Y+4	; 0x04
    be8c:	ac 01       	movw	r20, r24
    be8e:	bd 01       	movw	r22, r26
    be90:	cf 01       	movw	r24, r30
    be92:	0e 94 24 5d 	call	0xba48	; 0xba48 <_ZN5Print5printEmi>
    be96:	9a 83       	std	Y+2, r25	; 0x02
    be98:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    be9a:	8b 81       	ldd	r24, Y+3	; 0x03
    be9c:	9c 81       	ldd	r25, Y+4	; 0x04
    be9e:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    bea2:	29 81       	ldd	r18, Y+1	; 0x01
    bea4:	3a 81       	ldd	r19, Y+2	; 0x02
    bea6:	82 0f       	add	r24, r18
    bea8:	93 1f       	adc	r25, r19
    beaa:	9a 83       	std	Y+2, r25	; 0x02
    beac:	89 83       	std	Y+1, r24	; 0x01
  return n;
    beae:	89 81       	ldd	r24, Y+1	; 0x01
    beb0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    beb2:	2a 96       	adiw	r28, 0x0a	; 10
    beb4:	0f b6       	in	r0, 0x3f	; 63
    beb6:	f8 94       	cli
    beb8:	de bf       	out	0x3e, r29	; 62
    beba:	0f be       	out	0x3f, r0	; 63
    bebc:	cd bf       	out	0x3d, r28	; 61
    bebe:	df 91       	pop	r29
    bec0:	cf 91       	pop	r28
    bec2:	08 95       	ret

0000bec4 <_ZN5Print7printlnEdi>:

size_t Print::println(double num, int digits)
{
    bec4:	cf 93       	push	r28
    bec6:	df 93       	push	r29
    bec8:	cd b7       	in	r28, 0x3d	; 61
    beca:	de b7       	in	r29, 0x3e	; 62
    becc:	2a 97       	sbiw	r28, 0x0a	; 10
    bece:	0f b6       	in	r0, 0x3f	; 63
    bed0:	f8 94       	cli
    bed2:	de bf       	out	0x3e, r29	; 62
    bed4:	0f be       	out	0x3f, r0	; 63
    bed6:	cd bf       	out	0x3d, r28	; 61
    bed8:	9c 83       	std	Y+4, r25	; 0x04
    beda:	8b 83       	std	Y+3, r24	; 0x03
    bedc:	4d 83       	std	Y+5, r20	; 0x05
    bede:	5e 83       	std	Y+6, r21	; 0x06
    bee0:	6f 83       	std	Y+7, r22	; 0x07
    bee2:	78 87       	std	Y+8, r23	; 0x08
    bee4:	3a 87       	std	Y+10, r19	; 0x0a
    bee6:	29 87       	std	Y+9, r18	; 0x09
  size_t n = print(num, digits);
    bee8:	29 85       	ldd	r18, Y+9	; 0x09
    beea:	3a 85       	ldd	r19, Y+10	; 0x0a
    beec:	8d 81       	ldd	r24, Y+5	; 0x05
    beee:	9e 81       	ldd	r25, Y+6	; 0x06
    bef0:	af 81       	ldd	r26, Y+7	; 0x07
    bef2:	b8 85       	ldd	r27, Y+8	; 0x08
    bef4:	eb 81       	ldd	r30, Y+3	; 0x03
    bef6:	fc 81       	ldd	r31, Y+4	; 0x04
    bef8:	ac 01       	movw	r20, r24
    befa:	bd 01       	movw	r22, r26
    befc:	cf 01       	movw	r24, r30
    befe:	0e 94 5e 5d 	call	0xbabc	; 0xbabc <_ZN5Print5printEdi>
    bf02:	9a 83       	std	Y+2, r25	; 0x02
    bf04:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    bf06:	8b 81       	ldd	r24, Y+3	; 0x03
    bf08:	9c 81       	ldd	r25, Y+4	; 0x04
    bf0a:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    bf0e:	29 81       	ldd	r18, Y+1	; 0x01
    bf10:	3a 81       	ldd	r19, Y+2	; 0x02
    bf12:	82 0f       	add	r24, r18
    bf14:	93 1f       	adc	r25, r19
    bf16:	9a 83       	std	Y+2, r25	; 0x02
    bf18:	89 83       	std	Y+1, r24	; 0x01
  return n;
    bf1a:	89 81       	ldd	r24, Y+1	; 0x01
    bf1c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    bf1e:	2a 96       	adiw	r28, 0x0a	; 10
    bf20:	0f b6       	in	r0, 0x3f	; 63
    bf22:	f8 94       	cli
    bf24:	de bf       	out	0x3e, r29	; 62
    bf26:	0f be       	out	0x3f, r0	; 63
    bf28:	cd bf       	out	0x3d, r28	; 61
    bf2a:	df 91       	pop	r29
    bf2c:	cf 91       	pop	r28
    bf2e:	08 95       	ret

0000bf30 <_ZN5Print7printlnERK9Printable>:

size_t Print::println(const Printable& x)
{
    bf30:	cf 93       	push	r28
    bf32:	df 93       	push	r29
    bf34:	00 d0       	rcall	.+0      	; 0xbf36 <_ZN5Print7printlnERK9Printable+0x6>
    bf36:	00 d0       	rcall	.+0      	; 0xbf38 <_ZN5Print7printlnERK9Printable+0x8>
    bf38:	00 d0       	rcall	.+0      	; 0xbf3a <_ZN5Print7printlnERK9Printable+0xa>
    bf3a:	cd b7       	in	r28, 0x3d	; 61
    bf3c:	de b7       	in	r29, 0x3e	; 62
    bf3e:	9c 83       	std	Y+4, r25	; 0x04
    bf40:	8b 83       	std	Y+3, r24	; 0x03
    bf42:	7e 83       	std	Y+6, r23	; 0x06
    bf44:	6d 83       	std	Y+5, r22	; 0x05
  size_t n = print(x);
    bf46:	2d 81       	ldd	r18, Y+5	; 0x05
    bf48:	3e 81       	ldd	r19, Y+6	; 0x06
    bf4a:	8b 81       	ldd	r24, Y+3	; 0x03
    bf4c:	9c 81       	ldd	r25, Y+4	; 0x04
    bf4e:	b9 01       	movw	r22, r18
    bf50:	0e 94 ae 5d 	call	0xbb5c	; 0xbb5c <_ZN5Print5printERK9Printable>
    bf54:	9a 83       	std	Y+2, r25	; 0x02
    bf56:	89 83       	std	Y+1, r24	; 0x01
  n += println();
    bf58:	8b 81       	ldd	r24, Y+3	; 0x03
    bf5a:	9c 81       	ldd	r25, Y+4	; 0x04
    bf5c:	0e 94 ce 5d 	call	0xbb9c	; 0xbb9c <_ZN5Print7printlnEv>
    bf60:	29 81       	ldd	r18, Y+1	; 0x01
    bf62:	3a 81       	ldd	r19, Y+2	; 0x02
    bf64:	82 0f       	add	r24, r18
    bf66:	93 1f       	adc	r25, r19
    bf68:	9a 83       	std	Y+2, r25	; 0x02
    bf6a:	89 83       	std	Y+1, r24	; 0x01
  return n;
    bf6c:	89 81       	ldd	r24, Y+1	; 0x01
    bf6e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    bf70:	26 96       	adiw	r28, 0x06	; 6
    bf72:	0f b6       	in	r0, 0x3f	; 63
    bf74:	f8 94       	cli
    bf76:	de bf       	out	0x3e, r29	; 62
    bf78:	0f be       	out	0x3f, r0	; 63
    bf7a:	cd bf       	out	0x3d, r28	; 61
    bf7c:	df 91       	pop	r29
    bf7e:	cf 91       	pop	r28
    bf80:	08 95       	ret

0000bf82 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
    bf82:	cf 93       	push	r28
    bf84:	df 93       	push	r29
    bf86:	cd b7       	in	r28, 0x3d	; 61
    bf88:	de b7       	in	r29, 0x3e	; 62
    bf8a:	af 97       	sbiw	r28, 0x2f	; 47
    bf8c:	0f b6       	in	r0, 0x3f	; 63
    bf8e:	f8 94       	cli
    bf90:	de bf       	out	0x3e, r29	; 62
    bf92:	0f be       	out	0x3f, r0	; 63
    bf94:	cd bf       	out	0x3d, r28	; 61
    bf96:	9a a7       	std	Y+42, r25	; 0x2a
    bf98:	89 a7       	std	Y+41, r24	; 0x29
    bf9a:	4b a7       	std	Y+43, r20	; 0x2b
    bf9c:	5c a7       	std	Y+44, r21	; 0x2c
    bf9e:	6d a7       	std	Y+45, r22	; 0x2d
    bfa0:	7e a7       	std	Y+46, r23	; 0x2e
    bfa2:	2f a7       	std	Y+47, r18	; 0x2f
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];
    bfa4:	ce 01       	movw	r24, r28
    bfa6:	08 96       	adiw	r24, 0x08	; 8
    bfa8:	80 96       	adiw	r24, 0x20	; 32
    bfaa:	9a 83       	std	Y+2, r25	; 0x02
    bfac:	89 83       	std	Y+1, r24	; 0x01

  *str = '\0';
    bfae:	89 81       	ldd	r24, Y+1	; 0x01
    bfb0:	9a 81       	ldd	r25, Y+2	; 0x02
    bfb2:	fc 01       	movw	r30, r24
    bfb4:	10 82       	st	Z, r1

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    bfb6:	8f a5       	ldd	r24, Y+47	; 0x2f
    bfb8:	82 30       	cpi	r24, 0x02	; 2
    bfba:	10 f4       	brcc	.+4      	; 0xbfc0 <_ZN5Print11printNumberEmh+0x3e>
    bfbc:	8a e0       	ldi	r24, 0x0A	; 10
    bfbe:	8f a7       	std	Y+47, r24	; 0x2f

  do {
    unsigned long m = n;
    bfc0:	8b a5       	ldd	r24, Y+43	; 0x2b
    bfc2:	9c a5       	ldd	r25, Y+44	; 0x2c
    bfc4:	ad a5       	ldd	r26, Y+45	; 0x2d
    bfc6:	be a5       	ldd	r27, Y+46	; 0x2e
    bfc8:	8b 83       	std	Y+3, r24	; 0x03
    bfca:	9c 83       	std	Y+4, r25	; 0x04
    bfcc:	ad 83       	std	Y+5, r26	; 0x05
    bfce:	be 83       	std	Y+6, r27	; 0x06
    n /= base;
    bfd0:	8f a5       	ldd	r24, Y+47	; 0x2f
    bfd2:	28 2f       	mov	r18, r24
    bfd4:	30 e0       	ldi	r19, 0x00	; 0
    bfd6:	40 e0       	ldi	r20, 0x00	; 0
    bfd8:	50 e0       	ldi	r21, 0x00	; 0
    bfda:	8b a5       	ldd	r24, Y+43	; 0x2b
    bfdc:	9c a5       	ldd	r25, Y+44	; 0x2c
    bfde:	ad a5       	ldd	r26, Y+45	; 0x2d
    bfe0:	be a5       	ldd	r27, Y+46	; 0x2e
    bfe2:	bc 01       	movw	r22, r24
    bfe4:	cd 01       	movw	r24, r26
    bfe6:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    bfea:	2b a7       	std	Y+43, r18	; 0x2b
    bfec:	3c a7       	std	Y+44, r19	; 0x2c
    bfee:	4d a7       	std	Y+45, r20	; 0x2d
    bff0:	5e a7       	std	Y+46, r21	; 0x2e
    char c = m - base * n;
    bff2:	9b 81       	ldd	r25, Y+3	; 0x03
    bff4:	2b a5       	ldd	r18, Y+43	; 0x2b
    bff6:	8f a5       	ldd	r24, Y+47	; 0x2f
    bff8:	28 9f       	mul	r18, r24
    bffa:	80 2d       	mov	r24, r0
    bffc:	11 24       	eor	r1, r1
    bffe:	f9 2f       	mov	r31, r25
    c000:	f8 1b       	sub	r31, r24
    c002:	8f 2f       	mov	r24, r31
    c004:	8f 83       	std	Y+7, r24	; 0x07
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    c006:	89 81       	ldd	r24, Y+1	; 0x01
    c008:	9a 81       	ldd	r25, Y+2	; 0x02
    c00a:	01 97       	sbiw	r24, 0x01	; 1
    c00c:	9a 83       	std	Y+2, r25	; 0x02
    c00e:	89 83       	std	Y+1, r24	; 0x01
    c010:	8f 81       	ldd	r24, Y+7	; 0x07
    c012:	8a 30       	cpi	r24, 0x0A	; 10
    c014:	20 f4       	brcc	.+8      	; 0xc01e <_ZN5Print11printNumberEmh+0x9c>
    c016:	8f 81       	ldd	r24, Y+7	; 0x07
    c018:	28 2f       	mov	r18, r24
    c01a:	20 5d       	subi	r18, 0xD0	; 208
    c01c:	03 c0       	rjmp	.+6      	; 0xc024 <_ZN5Print11printNumberEmh+0xa2>
    c01e:	8f 81       	ldd	r24, Y+7	; 0x07
    c020:	28 2f       	mov	r18, r24
    c022:	29 5c       	subi	r18, 0xC9	; 201
    c024:	89 81       	ldd	r24, Y+1	; 0x01
    c026:	9a 81       	ldd	r25, Y+2	; 0x02
    c028:	fc 01       	movw	r30, r24
    c02a:	20 83       	st	Z, r18
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    c02c:	21 e0       	ldi	r18, 0x01	; 1
    c02e:	8b a5       	ldd	r24, Y+43	; 0x2b
    c030:	9c a5       	ldd	r25, Y+44	; 0x2c
    c032:	ad a5       	ldd	r26, Y+45	; 0x2d
    c034:	be a5       	ldd	r27, Y+46	; 0x2e
    c036:	00 97       	sbiw	r24, 0x00	; 0
    c038:	a1 05       	cpc	r26, r1
    c03a:	b1 05       	cpc	r27, r1
    c03c:	09 f4       	brne	.+2      	; 0xc040 <_ZN5Print11printNumberEmh+0xbe>
    c03e:	20 e0       	ldi	r18, 0x00	; 0
    c040:	22 23       	and	r18, r18
    c042:	09 f0       	breq	.+2      	; 0xc046 <_ZN5Print11printNumberEmh+0xc4>
    c044:	bd cf       	rjmp	.-134    	; 0xbfc0 <_ZN5Print11printNumberEmh+0x3e>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
    c046:	29 81       	ldd	r18, Y+1	; 0x01
    c048:	3a 81       	ldd	r19, Y+2	; 0x02
    c04a:	89 a5       	ldd	r24, Y+41	; 0x29
    c04c:	9a a5       	ldd	r25, Y+42	; 0x2a
    c04e:	b9 01       	movw	r22, r18
    c050:	0e 94 18 ad 	call	0x15a30	; 0x15a30 <_ZN5Print5writeEPKc>
}
    c054:	af 96       	adiw	r28, 0x2f	; 47
    c056:	0f b6       	in	r0, 0x3f	; 63
    c058:	f8 94       	cli
    c05a:	de bf       	out	0x3e, r29	; 62
    c05c:	0f be       	out	0x3f, r0	; 63
    c05e:	cd bf       	out	0x3d, r28	; 61
    c060:	df 91       	pop	r29
    c062:	cf 91       	pop	r28
    c064:	08 95       	ret

0000c066 <_ZN5Print10printFloatEdh>:

size_t Print::printFloat(double number, uint8_t digits) 
{ 
    c066:	cf 92       	push	r12
    c068:	df 92       	push	r13
    c06a:	ef 92       	push	r14
    c06c:	ff 92       	push	r15
    c06e:	1f 93       	push	r17
    c070:	cf 93       	push	r28
    c072:	df 93       	push	r29
    c074:	cd b7       	in	r28, 0x3d	; 61
    c076:	de b7       	in	r29, 0x3e	; 62
    c078:	68 97       	sbiw	r28, 0x18	; 24
    c07a:	0f b6       	in	r0, 0x3f	; 63
    c07c:	f8 94       	cli
    c07e:	de bf       	out	0x3e, r29	; 62
    c080:	0f be       	out	0x3f, r0	; 63
    c082:	cd bf       	out	0x3d, r28	; 61
    c084:	9b 8b       	std	Y+19, r25	; 0x13
    c086:	8a 8b       	std	Y+18, r24	; 0x12
    c088:	4c 8b       	std	Y+20, r20	; 0x14
    c08a:	5d 8b       	std	Y+21, r21	; 0x15
    c08c:	6e 8b       	std	Y+22, r22	; 0x16
    c08e:	7f 8b       	std	Y+23, r23	; 0x17
    c090:	28 8f       	std	Y+24, r18	; 0x18
  size_t n = 0;
    c092:	1a 82       	std	Y+2, r1	; 0x02
    c094:	19 82       	std	Y+1, r1	; 0x01
  
  if (isnan(number)) return print("nan");
    c096:	2c 89       	ldd	r18, Y+20	; 0x14
    c098:	3d 89       	ldd	r19, Y+21	; 0x15
    c09a:	4e 89       	ldd	r20, Y+22	; 0x16
    c09c:	5f 89       	ldd	r21, Y+23	; 0x17
    c09e:	6c 89       	ldd	r22, Y+20	; 0x14
    c0a0:	7d 89       	ldd	r23, Y+21	; 0x15
    c0a2:	8e 89       	ldd	r24, Y+22	; 0x16
    c0a4:	9f 89       	ldd	r25, Y+23	; 0x17
    c0a6:	0e 94 81 a2 	call	0x14502	; 0x14502 <__unordsf2>
    c0aa:	88 23       	and	r24, r24
    c0ac:	39 f0       	breq	.+14     	; 0xc0bc <_ZN5Print10printFloatEdh+0x56>
    c0ae:	8a 89       	ldd	r24, Y+18	; 0x12
    c0b0:	9b 89       	ldd	r25, Y+19	; 0x13
    c0b2:	6a ed       	ldi	r22, 0xDA	; 218
    c0b4:	73 e0       	ldi	r23, 0x03	; 3
    c0b6:	0e 94 0b 5c 	call	0xb816	; 0xb816 <_ZN5Print5printEPKc>
    c0ba:	39 c1       	rjmp	.+626    	; 0xc32e <_ZN5Print10printFloatEdh+0x2c8>
  if (isinf(number)) return print("inf");
    c0bc:	8c 89       	ldd	r24, Y+20	; 0x14
    c0be:	9d 89       	ldd	r25, Y+21	; 0x15
    c0c0:	ae 89       	ldd	r26, Y+22	; 0x16
    c0c2:	bf 89       	ldd	r27, Y+23	; 0x17
    c0c4:	6c 01       	movw	r12, r24
    c0c6:	7d 01       	movw	r14, r26
    c0c8:	e8 94       	clt
    c0ca:	f7 f8       	bld	r15, 7
    c0cc:	11 e0       	ldi	r17, 0x01	; 1
    c0ce:	2f ef       	ldi	r18, 0xFF	; 255
    c0d0:	3f ef       	ldi	r19, 0xFF	; 255
    c0d2:	4f e7       	ldi	r20, 0x7F	; 127
    c0d4:	5f e7       	ldi	r21, 0x7F	; 127
    c0d6:	c7 01       	movw	r24, r14
    c0d8:	b6 01       	movw	r22, r12
    c0da:	0e 94 81 a2 	call	0x14502	; 0x14502 <__unordsf2>
    c0de:	88 23       	and	r24, r24
    c0e0:	59 f4       	brne	.+22     	; 0xc0f8 <_ZN5Print10printFloatEdh+0x92>
    c0e2:	2f ef       	ldi	r18, 0xFF	; 255
    c0e4:	3f ef       	ldi	r19, 0xFF	; 255
    c0e6:	4f e7       	ldi	r20, 0x7F	; 127
    c0e8:	5f e7       	ldi	r21, 0x7F	; 127
    c0ea:	c7 01       	movw	r24, r14
    c0ec:	b6 01       	movw	r22, r12
    c0ee:	0e 94 52 a2 	call	0x144a4	; 0x144a4 <__lesf2>
    c0f2:	18 16       	cp	r1, r24
    c0f4:	0c f4       	brge	.+2      	; 0xc0f8 <_ZN5Print10printFloatEdh+0x92>
    c0f6:	10 e0       	ldi	r17, 0x00	; 0
    c0f8:	81 e0       	ldi	r24, 0x01	; 1
    c0fa:	81 27       	eor	r24, r17
    c0fc:	88 23       	and	r24, r24
    c0fe:	39 f0       	breq	.+14     	; 0xc10e <_ZN5Print10printFloatEdh+0xa8>
    c100:	8a 89       	ldd	r24, Y+18	; 0x12
    c102:	9b 89       	ldd	r25, Y+19	; 0x13
    c104:	6e ed       	ldi	r22, 0xDE	; 222
    c106:	73 e0       	ldi	r23, 0x03	; 3
    c108:	0e 94 0b 5c 	call	0xb816	; 0xb816 <_ZN5Print5printEPKc>
    c10c:	10 c1       	rjmp	.+544    	; 0xc32e <_ZN5Print10printFloatEdh+0x2c8>
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
    c10e:	2f ef       	ldi	r18, 0xFF	; 255
    c110:	3f ef       	ldi	r19, 0xFF	; 255
    c112:	4f e7       	ldi	r20, 0x7F	; 127
    c114:	5f e4       	ldi	r21, 0x4F	; 79
    c116:	6c 89       	ldd	r22, Y+20	; 0x14
    c118:	7d 89       	ldd	r23, Y+21	; 0x15
    c11a:	8e 89       	ldd	r24, Y+22	; 0x16
    c11c:	9f 89       	ldd	r25, Y+23	; 0x17
    c11e:	0e 94 c5 a1 	call	0x1438a	; 0x1438a <__gtsf2>
    c122:	18 16       	cp	r1, r24
    c124:	3c f4       	brge	.+14     	; 0xc134 <_ZN5Print10printFloatEdh+0xce>
    c126:	8a 89       	ldd	r24, Y+18	; 0x12
    c128:	9b 89       	ldd	r25, Y+19	; 0x13
    c12a:	62 ee       	ldi	r22, 0xE2	; 226
    c12c:	73 e0       	ldi	r23, 0x03	; 3
    c12e:	0e 94 0b 5c 	call	0xb816	; 0xb816 <_ZN5Print5printEPKc>
    c132:	fd c0       	rjmp	.+506    	; 0xc32e <_ZN5Print10printFloatEdh+0x2c8>
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
    c134:	2f ef       	ldi	r18, 0xFF	; 255
    c136:	3f ef       	ldi	r19, 0xFF	; 255
    c138:	4f e7       	ldi	r20, 0x7F	; 127
    c13a:	5f ec       	ldi	r21, 0xCF	; 207
    c13c:	6c 89       	ldd	r22, Y+20	; 0x14
    c13e:	7d 89       	ldd	r23, Y+21	; 0x15
    c140:	8e 89       	ldd	r24, Y+22	; 0x16
    c142:	9f 89       	ldd	r25, Y+23	; 0x17
    c144:	0e 94 23 a2 	call	0x14446	; 0x14446 <__ltsf2>
    c148:	88 23       	and	r24, r24
    c14a:	3c f4       	brge	.+14     	; 0xc15a <_ZN5Print10printFloatEdh+0xf4>
    c14c:	8a 89       	ldd	r24, Y+18	; 0x12
    c14e:	9b 89       	ldd	r25, Y+19	; 0x13
    c150:	62 ee       	ldi	r22, 0xE2	; 226
    c152:	73 e0       	ldi	r23, 0x03	; 3
    c154:	0e 94 0b 5c 	call	0xb816	; 0xb816 <_ZN5Print5printEPKc>
    c158:	ea c0       	rjmp	.+468    	; 0xc32e <_ZN5Print10printFloatEdh+0x2c8>
  
  // Handle negative numbers
  if (number < 0.0)
    c15a:	20 e0       	ldi	r18, 0x00	; 0
    c15c:	30 e0       	ldi	r19, 0x00	; 0
    c15e:	a9 01       	movw	r20, r18
    c160:	6c 89       	ldd	r22, Y+20	; 0x14
    c162:	7d 89       	ldd	r23, Y+21	; 0x15
    c164:	8e 89       	ldd	r24, Y+22	; 0x16
    c166:	9f 89       	ldd	r25, Y+23	; 0x17
    c168:	0e 94 23 a2 	call	0x14446	; 0x14446 <__ltsf2>
    c16c:	88 23       	and	r24, r24
    c16e:	a4 f4       	brge	.+40     	; 0xc198 <_ZN5Print10printFloatEdh+0x132>
  {
     n += print('-');
    c170:	8a 89       	ldd	r24, Y+18	; 0x12
    c172:	9b 89       	ldd	r25, Y+19	; 0x13
    c174:	6d e2       	ldi	r22, 0x2D	; 45
    c176:	0e 94 23 5c 	call	0xb846	; 0xb846 <_ZN5Print5printEc>
    c17a:	29 81       	ldd	r18, Y+1	; 0x01
    c17c:	3a 81       	ldd	r19, Y+2	; 0x02
    c17e:	82 0f       	add	r24, r18
    c180:	93 1f       	adc	r25, r19
    c182:	9a 83       	std	Y+2, r25	; 0x02
    c184:	89 83       	std	Y+1, r24	; 0x01
     number = -number;
    c186:	8c 89       	ldd	r24, Y+20	; 0x14
    c188:	9d 89       	ldd	r25, Y+21	; 0x15
    c18a:	ae 89       	ldd	r26, Y+22	; 0x16
    c18c:	bf 89       	ldd	r27, Y+23	; 0x17
    c18e:	b0 58       	subi	r27, 0x80	; 128
    c190:	8c 8b       	std	Y+20, r24	; 0x14
    c192:	9d 8b       	std	Y+21, r25	; 0x15
    c194:	ae 8b       	std	Y+22, r26	; 0x16
    c196:	bf 8b       	std	Y+23, r27	; 0x17
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
    c198:	80 e0       	ldi	r24, 0x00	; 0
    c19a:	90 e0       	ldi	r25, 0x00	; 0
    c19c:	a0 e0       	ldi	r26, 0x00	; 0
    c19e:	bf e3       	ldi	r27, 0x3F	; 63
    c1a0:	8b 83       	std	Y+3, r24	; 0x03
    c1a2:	9c 83       	std	Y+4, r25	; 0x04
    c1a4:	ad 83       	std	Y+5, r26	; 0x05
    c1a6:	be 83       	std	Y+6, r27	; 0x06
  for (uint8_t i=0; i<digits; ++i)
    c1a8:	1f 82       	std	Y+7, r1	; 0x07
    c1aa:	13 c0       	rjmp	.+38     	; 0xc1d2 <_ZN5Print10printFloatEdh+0x16c>
    rounding /= 10.0;
    c1ac:	20 e0       	ldi	r18, 0x00	; 0
    c1ae:	30 e0       	ldi	r19, 0x00	; 0
    c1b0:	40 e2       	ldi	r20, 0x20	; 32
    c1b2:	51 e4       	ldi	r21, 0x41	; 65
    c1b4:	6b 81       	ldd	r22, Y+3	; 0x03
    c1b6:	7c 81       	ldd	r23, Y+4	; 0x04
    c1b8:	8d 81       	ldd	r24, Y+5	; 0x05
    c1ba:	9e 81       	ldd	r25, Y+6	; 0x06
    c1bc:	0e 94 22 a1 	call	0x14244	; 0x14244 <__divsf3>
    c1c0:	dc 01       	movw	r26, r24
    c1c2:	cb 01       	movw	r24, r22
    c1c4:	8b 83       	std	Y+3, r24	; 0x03
    c1c6:	9c 83       	std	Y+4, r25	; 0x04
    c1c8:	ad 83       	std	Y+5, r26	; 0x05
    c1ca:	be 83       	std	Y+6, r27	; 0x06
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    c1cc:	8f 81       	ldd	r24, Y+7	; 0x07
    c1ce:	8f 5f       	subi	r24, 0xFF	; 255
    c1d0:	8f 83       	std	Y+7, r24	; 0x07
    c1d2:	81 e0       	ldi	r24, 0x01	; 1
    c1d4:	2f 81       	ldd	r18, Y+7	; 0x07
    c1d6:	98 8d       	ldd	r25, Y+24	; 0x18
    c1d8:	29 17       	cp	r18, r25
    c1da:	08 f0       	brcs	.+2      	; 0xc1de <_ZN5Print10printFloatEdh+0x178>
    c1dc:	80 e0       	ldi	r24, 0x00	; 0
    c1de:	88 23       	and	r24, r24
    c1e0:	29 f7       	brne	.-54     	; 0xc1ac <_ZN5Print10printFloatEdh+0x146>
    rounding /= 10.0;
  
  number += rounding;
    c1e2:	2b 81       	ldd	r18, Y+3	; 0x03
    c1e4:	3c 81       	ldd	r19, Y+4	; 0x04
    c1e6:	4d 81       	ldd	r20, Y+5	; 0x05
    c1e8:	5e 81       	ldd	r21, Y+6	; 0x06
    c1ea:	6c 89       	ldd	r22, Y+20	; 0x14
    c1ec:	7d 89       	ldd	r23, Y+21	; 0x15
    c1ee:	8e 89       	ldd	r24, Y+22	; 0x16
    c1f0:	9f 89       	ldd	r25, Y+23	; 0x17
    c1f2:	0e 94 e1 9f 	call	0x13fc2	; 0x13fc2 <__addsf3>
    c1f6:	dc 01       	movw	r26, r24
    c1f8:	cb 01       	movw	r24, r22
    c1fa:	8c 8b       	std	Y+20, r24	; 0x14
    c1fc:	9d 8b       	std	Y+21, r25	; 0x15
    c1fe:	ae 8b       	std	Y+22, r26	; 0x16
    c200:	bf 8b       	std	Y+23, r27	; 0x17

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
    c202:	6c 89       	ldd	r22, Y+20	; 0x14
    c204:	7d 89       	ldd	r23, Y+21	; 0x15
    c206:	8e 89       	ldd	r24, Y+22	; 0x16
    c208:	9f 89       	ldd	r25, Y+23	; 0x17
    c20a:	0e 94 58 9e 	call	0x13cb0	; 0x13cb0 <__fixunssfsi>
    c20e:	dc 01       	movw	r26, r24
    c210:	cb 01       	movw	r24, r22
    c212:	8c 87       	std	Y+12, r24	; 0x0c
    c214:	9d 87       	std	Y+13, r25	; 0x0d
    c216:	ae 87       	std	Y+14, r26	; 0x0e
    c218:	bf 87       	std	Y+15, r27	; 0x0f
  double remainder = number - (double)int_part;
    c21a:	6c 85       	ldd	r22, Y+12	; 0x0c
    c21c:	7d 85       	ldd	r23, Y+13	; 0x0d
    c21e:	8e 85       	ldd	r24, Y+14	; 0x0e
    c220:	9f 85       	ldd	r25, Y+15	; 0x0f
    c222:	0e 94 59 a3 	call	0x146b2	; 0x146b2 <__floatunsisf>
    c226:	dc 01       	movw	r26, r24
    c228:	cb 01       	movw	r24, r22
    c22a:	9c 01       	movw	r18, r24
    c22c:	ad 01       	movw	r20, r26
    c22e:	6c 89       	ldd	r22, Y+20	; 0x14
    c230:	7d 89       	ldd	r23, Y+21	; 0x15
    c232:	8e 89       	ldd	r24, Y+22	; 0x16
    c234:	9f 89       	ldd	r25, Y+23	; 0x17
    c236:	0e 94 0d a0 	call	0x1401a	; 0x1401a <__subsf3>
    c23a:	dc 01       	movw	r26, r24
    c23c:	cb 01       	movw	r24, r22
    c23e:	88 87       	std	Y+8, r24	; 0x08
    c240:	99 87       	std	Y+9, r25	; 0x09
    c242:	aa 87       	std	Y+10, r26	; 0x0a
    c244:	bb 87       	std	Y+11, r27	; 0x0b
  n += print(int_part);
    c246:	8c 85       	ldd	r24, Y+12	; 0x0c
    c248:	9d 85       	ldd	r25, Y+13	; 0x0d
    c24a:	ae 85       	ldd	r26, Y+14	; 0x0e
    c24c:	bf 85       	ldd	r27, Y+15	; 0x0f
    c24e:	ea 89       	ldd	r30, Y+18	; 0x12
    c250:	fb 89       	ldd	r31, Y+19	; 0x13
    c252:	2a e0       	ldi	r18, 0x0A	; 10
    c254:	30 e0       	ldi	r19, 0x00	; 0
    c256:	ac 01       	movw	r20, r24
    c258:	bd 01       	movw	r22, r26
    c25a:	cf 01       	movw	r24, r30
    c25c:	0e 94 24 5d 	call	0xba48	; 0xba48 <_ZN5Print5printEmi>
    c260:	29 81       	ldd	r18, Y+1	; 0x01
    c262:	3a 81       	ldd	r19, Y+2	; 0x02
    c264:	82 0f       	add	r24, r18
    c266:	93 1f       	adc	r25, r19
    c268:	9a 83       	std	Y+2, r25	; 0x02
    c26a:	89 83       	std	Y+1, r24	; 0x01

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    c26c:	88 8d       	ldd	r24, Y+24	; 0x18
    c26e:	88 23       	and	r24, r24
    c270:	09 f4       	brne	.+2      	; 0xc274 <_ZN5Print10printFloatEdh+0x20e>
    c272:	50 c0       	rjmp	.+160    	; 0xc314 <_ZN5Print10printFloatEdh+0x2ae>
    n += print("."); 
    c274:	8a 89       	ldd	r24, Y+18	; 0x12
    c276:	9b 89       	ldd	r25, Y+19	; 0x13
    c278:	66 ee       	ldi	r22, 0xE6	; 230
    c27a:	73 e0       	ldi	r23, 0x03	; 3
    c27c:	0e 94 0b 5c 	call	0xb816	; 0xb816 <_ZN5Print5printEPKc>
    c280:	29 81       	ldd	r18, Y+1	; 0x01
    c282:	3a 81       	ldd	r19, Y+2	; 0x02
    c284:	82 0f       	add	r24, r18
    c286:	93 1f       	adc	r25, r19
    c288:	9a 83       	std	Y+2, r25	; 0x02
    c28a:	89 83       	std	Y+1, r24	; 0x01
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
    c28c:	43 c0       	rjmp	.+134    	; 0xc314 <_ZN5Print10printFloatEdh+0x2ae>
  {
    remainder *= 10.0;
    c28e:	20 e0       	ldi	r18, 0x00	; 0
    c290:	30 e0       	ldi	r19, 0x00	; 0
    c292:	40 e2       	ldi	r20, 0x20	; 32
    c294:	51 e4       	ldi	r21, 0x41	; 65
    c296:	68 85       	ldd	r22, Y+8	; 0x08
    c298:	79 85       	ldd	r23, Y+9	; 0x09
    c29a:	8a 85       	ldd	r24, Y+10	; 0x0a
    c29c:	9b 85       	ldd	r25, Y+11	; 0x0b
    c29e:	0e 94 3d a0 	call	0x1407a	; 0x1407a <__mulsf3>
    c2a2:	dc 01       	movw	r26, r24
    c2a4:	cb 01       	movw	r24, r22
    c2a6:	88 87       	std	Y+8, r24	; 0x08
    c2a8:	99 87       	std	Y+9, r25	; 0x09
    c2aa:	aa 87       	std	Y+10, r26	; 0x0a
    c2ac:	bb 87       	std	Y+11, r27	; 0x0b
    int toPrint = int(remainder);
    c2ae:	68 85       	ldd	r22, Y+8	; 0x08
    c2b0:	79 85       	ldd	r23, Y+9	; 0x09
    c2b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    c2b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    c2b6:	0e 94 0a a3 	call	0x14614	; 0x14614 <__fixsfsi>
    c2ba:	dc 01       	movw	r26, r24
    c2bc:	cb 01       	movw	r24, r22
    c2be:	99 8b       	std	Y+17, r25	; 0x11
    c2c0:	88 8b       	std	Y+16, r24	; 0x10
    n += print(toPrint);
    c2c2:	28 89       	ldd	r18, Y+16	; 0x10
    c2c4:	39 89       	ldd	r19, Y+17	; 0x11
    c2c6:	8a 89       	ldd	r24, Y+18	; 0x12
    c2c8:	9b 89       	ldd	r25, Y+19	; 0x13
    c2ca:	4a e0       	ldi	r20, 0x0A	; 10
    c2cc:	50 e0       	ldi	r21, 0x00	; 0
    c2ce:	b9 01       	movw	r22, r18
    c2d0:	0e 94 61 5c 	call	0xb8c2	; 0xb8c2 <_ZN5Print5printEii>
    c2d4:	29 81       	ldd	r18, Y+1	; 0x01
    c2d6:	3a 81       	ldd	r19, Y+2	; 0x02
    c2d8:	82 0f       	add	r24, r18
    c2da:	93 1f       	adc	r25, r19
    c2dc:	9a 83       	std	Y+2, r25	; 0x02
    c2de:	89 83       	std	Y+1, r24	; 0x01
    remainder -= toPrint; 
    c2e0:	88 89       	ldd	r24, Y+16	; 0x10
    c2e2:	99 89       	ldd	r25, Y+17	; 0x11
    c2e4:	aa 27       	eor	r26, r26
    c2e6:	97 fd       	sbrc	r25, 7
    c2e8:	a0 95       	com	r26
    c2ea:	ba 2f       	mov	r27, r26
    c2ec:	bc 01       	movw	r22, r24
    c2ee:	cd 01       	movw	r24, r26
    c2f0:	0e 94 ae a2 	call	0x1455c	; 0x1455c <__floatsisf>
    c2f4:	dc 01       	movw	r26, r24
    c2f6:	cb 01       	movw	r24, r22
    c2f8:	9c 01       	movw	r18, r24
    c2fa:	ad 01       	movw	r20, r26
    c2fc:	68 85       	ldd	r22, Y+8	; 0x08
    c2fe:	79 85       	ldd	r23, Y+9	; 0x09
    c300:	8a 85       	ldd	r24, Y+10	; 0x0a
    c302:	9b 85       	ldd	r25, Y+11	; 0x0b
    c304:	0e 94 0d a0 	call	0x1401a	; 0x1401a <__subsf3>
    c308:	dc 01       	movw	r26, r24
    c30a:	cb 01       	movw	r24, r22
    c30c:	88 87       	std	Y+8, r24	; 0x08
    c30e:	99 87       	std	Y+9, r25	; 0x09
    c310:	aa 87       	std	Y+10, r26	; 0x0a
    c312:	bb 87       	std	Y+11, r27	; 0x0b
  if (digits > 0) {
    n += print("."); 
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
    c314:	81 e0       	ldi	r24, 0x01	; 1
    c316:	98 8d       	ldd	r25, Y+24	; 0x18
    c318:	99 23       	and	r25, r25
    c31a:	09 f4       	brne	.+2      	; 0xc31e <_ZN5Print10printFloatEdh+0x2b8>
    c31c:	80 e0       	ldi	r24, 0x00	; 0
    c31e:	98 8d       	ldd	r25, Y+24	; 0x18
    c320:	91 50       	subi	r25, 0x01	; 1
    c322:	98 8f       	std	Y+24, r25	; 0x18
    c324:	88 23       	and	r24, r24
    c326:	09 f0       	breq	.+2      	; 0xc32a <_ZN5Print10printFloatEdh+0x2c4>
    c328:	b2 cf       	rjmp	.-156    	; 0xc28e <_ZN5Print10printFloatEdh+0x228>
    int toPrint = int(remainder);
    n += print(toPrint);
    remainder -= toPrint; 
  } 
  
  return n;
    c32a:	89 81       	ldd	r24, Y+1	; 0x01
    c32c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    c32e:	68 96       	adiw	r28, 0x18	; 24
    c330:	0f b6       	in	r0, 0x3f	; 63
    c332:	f8 94       	cli
    c334:	de bf       	out	0x3e, r29	; 62
    c336:	0f be       	out	0x3f, r0	; 63
    c338:	cd bf       	out	0x3d, r28	; 61
    c33a:	df 91       	pop	r29
    c33c:	cf 91       	pop	r28
    c33e:	1f 91       	pop	r17
    c340:	ff 90       	pop	r15
    c342:	ef 90       	pop	r14
    c344:	df 90       	pop	r13
    c346:	cf 90       	pop	r12
    c348:	08 95       	ret

0000c34a <_ZN6Stream9timedReadEv>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
    c34a:	cf 93       	push	r28
    c34c:	df 93       	push	r29
    c34e:	00 d0       	rcall	.+0      	; 0xc350 <_ZN6Stream9timedReadEv+0x6>
    c350:	00 d0       	rcall	.+0      	; 0xc352 <_ZN6Stream9timedReadEv+0x8>
    c352:	cd b7       	in	r28, 0x3d	; 61
    c354:	de b7       	in	r29, 0x3e	; 62
    c356:	9c 83       	std	Y+4, r25	; 0x04
    c358:	8b 83       	std	Y+3, r24	; 0x03
  int c;
  _startMillis = millis();
    c35a:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    c35e:	dc 01       	movw	r26, r24
    c360:	cb 01       	movw	r24, r22
    c362:	2b 81       	ldd	r18, Y+3	; 0x03
    c364:	3c 81       	ldd	r19, Y+4	; 0x04
    c366:	f9 01       	movw	r30, r18
    c368:	80 87       	std	Z+8, r24	; 0x08
    c36a:	91 87       	std	Z+9, r25	; 0x09
    c36c:	a2 87       	std	Z+10, r26	; 0x0a
    c36e:	b3 87       	std	Z+11, r27	; 0x0b
  do {
    c = read();
    c370:	8b 81       	ldd	r24, Y+3	; 0x03
    c372:	9c 81       	ldd	r25, Y+4	; 0x04
    c374:	fc 01       	movw	r30, r24
    c376:	80 81       	ld	r24, Z
    c378:	91 81       	ldd	r25, Z+1	; 0x01
    c37a:	06 96       	adiw	r24, 0x06	; 6
    c37c:	fc 01       	movw	r30, r24
    c37e:	20 81       	ld	r18, Z
    c380:	31 81       	ldd	r19, Z+1	; 0x01
    c382:	8b 81       	ldd	r24, Y+3	; 0x03
    c384:	9c 81       	ldd	r25, Y+4	; 0x04
    c386:	f9 01       	movw	r30, r18
    c388:	09 95       	icall
    c38a:	9a 83       	std	Y+2, r25	; 0x02
    c38c:	89 83       	std	Y+1, r24	; 0x01
    if (c >= 0) return c;
    c38e:	89 81       	ldd	r24, Y+1	; 0x01
    c390:	9a 81       	ldd	r25, Y+2	; 0x02
    c392:	99 23       	and	r25, r25
    c394:	1c f0       	brlt	.+6      	; 0xc39c <_ZN6Stream9timedReadEv+0x52>
    c396:	89 81       	ldd	r24, Y+1	; 0x01
    c398:	9a 81       	ldd	r25, Y+2	; 0x02
    c39a:	21 c0       	rjmp	.+66     	; 0xc3de <_ZN6Stream9timedReadEv+0x94>
  } while(millis() - _startMillis < _timeout);
    c39c:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    c3a0:	9b 01       	movw	r18, r22
    c3a2:	ac 01       	movw	r20, r24
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  _startMillis = millis();
  do {
    c3a4:	8b 81       	ldd	r24, Y+3	; 0x03
    c3a6:	9c 81       	ldd	r25, Y+4	; 0x04
    c3a8:	fc 01       	movw	r30, r24
    c3aa:	80 85       	ldd	r24, Z+8	; 0x08
    c3ac:	91 85       	ldd	r25, Z+9	; 0x09
    c3ae:	a2 85       	ldd	r26, Z+10	; 0x0a
    c3b0:	b3 85       	ldd	r27, Z+11	; 0x0b
    c3b2:	28 1b       	sub	r18, r24
    c3b4:	39 0b       	sbc	r19, r25
    c3b6:	4a 0b       	sbc	r20, r26
    c3b8:	5b 0b       	sbc	r21, r27
    c3ba:	8b 81       	ldd	r24, Y+3	; 0x03
    c3bc:	9c 81       	ldd	r25, Y+4	; 0x04
    c3be:	fc 01       	movw	r30, r24
    c3c0:	84 81       	ldd	r24, Z+4	; 0x04
    c3c2:	95 81       	ldd	r25, Z+5	; 0x05
    c3c4:	a6 81       	ldd	r26, Z+6	; 0x06
    c3c6:	b7 81       	ldd	r27, Z+7	; 0x07
    c3c8:	61 e0       	ldi	r22, 0x01	; 1
    c3ca:	28 17       	cp	r18, r24
    c3cc:	39 07       	cpc	r19, r25
    c3ce:	4a 07       	cpc	r20, r26
    c3d0:	5b 07       	cpc	r21, r27
    c3d2:	08 f0       	brcs	.+2      	; 0xc3d6 <_ZN6Stream9timedReadEv+0x8c>
    c3d4:	60 e0       	ldi	r22, 0x00	; 0
    c3d6:	66 23       	and	r22, r22
    c3d8:	59 f6       	brne	.-106    	; 0xc370 <_ZN6Stream9timedReadEv+0x26>
    c = read();
    if (c >= 0) return c;
  } while(millis() - _startMillis < _timeout);
  return -1;     // -1 indicates timeout
    c3da:	8f ef       	ldi	r24, 0xFF	; 255
    c3dc:	9f ef       	ldi	r25, 0xFF	; 255
}
    c3de:	0f 90       	pop	r0
    c3e0:	0f 90       	pop	r0
    c3e2:	0f 90       	pop	r0
    c3e4:	0f 90       	pop	r0
    c3e6:	df 91       	pop	r29
    c3e8:	cf 91       	pop	r28
    c3ea:	08 95       	ret

0000c3ec <_ZN6Stream9timedPeekEv>:

// private method to peek stream with timeout
int Stream::timedPeek()
{
    c3ec:	cf 93       	push	r28
    c3ee:	df 93       	push	r29
    c3f0:	00 d0       	rcall	.+0      	; 0xc3f2 <_ZN6Stream9timedPeekEv+0x6>
    c3f2:	00 d0       	rcall	.+0      	; 0xc3f4 <_ZN6Stream9timedPeekEv+0x8>
    c3f4:	cd b7       	in	r28, 0x3d	; 61
    c3f6:	de b7       	in	r29, 0x3e	; 62
    c3f8:	9c 83       	std	Y+4, r25	; 0x04
    c3fa:	8b 83       	std	Y+3, r24	; 0x03
  int c;
  _startMillis = millis();
    c3fc:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    c400:	dc 01       	movw	r26, r24
    c402:	cb 01       	movw	r24, r22
    c404:	2b 81       	ldd	r18, Y+3	; 0x03
    c406:	3c 81       	ldd	r19, Y+4	; 0x04
    c408:	f9 01       	movw	r30, r18
    c40a:	80 87       	std	Z+8, r24	; 0x08
    c40c:	91 87       	std	Z+9, r25	; 0x09
    c40e:	a2 87       	std	Z+10, r26	; 0x0a
    c410:	b3 87       	std	Z+11, r27	; 0x0b
  do {
    c = peek();
    c412:	8b 81       	ldd	r24, Y+3	; 0x03
    c414:	9c 81       	ldd	r25, Y+4	; 0x04
    c416:	fc 01       	movw	r30, r24
    c418:	80 81       	ld	r24, Z
    c41a:	91 81       	ldd	r25, Z+1	; 0x01
    c41c:	08 96       	adiw	r24, 0x08	; 8
    c41e:	fc 01       	movw	r30, r24
    c420:	20 81       	ld	r18, Z
    c422:	31 81       	ldd	r19, Z+1	; 0x01
    c424:	8b 81       	ldd	r24, Y+3	; 0x03
    c426:	9c 81       	ldd	r25, Y+4	; 0x04
    c428:	f9 01       	movw	r30, r18
    c42a:	09 95       	icall
    c42c:	9a 83       	std	Y+2, r25	; 0x02
    c42e:	89 83       	std	Y+1, r24	; 0x01
    if (c >= 0) return c;
    c430:	89 81       	ldd	r24, Y+1	; 0x01
    c432:	9a 81       	ldd	r25, Y+2	; 0x02
    c434:	99 23       	and	r25, r25
    c436:	1c f0       	brlt	.+6      	; 0xc43e <_ZN6Stream9timedPeekEv+0x52>
    c438:	89 81       	ldd	r24, Y+1	; 0x01
    c43a:	9a 81       	ldd	r25, Y+2	; 0x02
    c43c:	21 c0       	rjmp	.+66     	; 0xc480 <_ZN6Stream9timedPeekEv+0x94>
  } while(millis() - _startMillis < _timeout);
    c43e:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <millis>
    c442:	9b 01       	movw	r18, r22
    c444:	ac 01       	movw	r20, r24
// private method to peek stream with timeout
int Stream::timedPeek()
{
  int c;
  _startMillis = millis();
  do {
    c446:	8b 81       	ldd	r24, Y+3	; 0x03
    c448:	9c 81       	ldd	r25, Y+4	; 0x04
    c44a:	fc 01       	movw	r30, r24
    c44c:	80 85       	ldd	r24, Z+8	; 0x08
    c44e:	91 85       	ldd	r25, Z+9	; 0x09
    c450:	a2 85       	ldd	r26, Z+10	; 0x0a
    c452:	b3 85       	ldd	r27, Z+11	; 0x0b
    c454:	28 1b       	sub	r18, r24
    c456:	39 0b       	sbc	r19, r25
    c458:	4a 0b       	sbc	r20, r26
    c45a:	5b 0b       	sbc	r21, r27
    c45c:	8b 81       	ldd	r24, Y+3	; 0x03
    c45e:	9c 81       	ldd	r25, Y+4	; 0x04
    c460:	fc 01       	movw	r30, r24
    c462:	84 81       	ldd	r24, Z+4	; 0x04
    c464:	95 81       	ldd	r25, Z+5	; 0x05
    c466:	a6 81       	ldd	r26, Z+6	; 0x06
    c468:	b7 81       	ldd	r27, Z+7	; 0x07
    c46a:	61 e0       	ldi	r22, 0x01	; 1
    c46c:	28 17       	cp	r18, r24
    c46e:	39 07       	cpc	r19, r25
    c470:	4a 07       	cpc	r20, r26
    c472:	5b 07       	cpc	r21, r27
    c474:	08 f0       	brcs	.+2      	; 0xc478 <_ZN6Stream9timedPeekEv+0x8c>
    c476:	60 e0       	ldi	r22, 0x00	; 0
    c478:	66 23       	and	r22, r22
    c47a:	59 f6       	brne	.-106    	; 0xc412 <_ZN6Stream9timedPeekEv+0x26>
    c = peek();
    if (c >= 0) return c;
  } while(millis() - _startMillis < _timeout);
  return -1;     // -1 indicates timeout
    c47c:	8f ef       	ldi	r24, 0xFF	; 255
    c47e:	9f ef       	ldi	r25, 0xFF	; 255
}
    c480:	0f 90       	pop	r0
    c482:	0f 90       	pop	r0
    c484:	0f 90       	pop	r0
    c486:	0f 90       	pop	r0
    c488:	df 91       	pop	r29
    c48a:	cf 91       	pop	r28
    c48c:	08 95       	ret

0000c48e <_ZN6Stream13peekNextDigitEv>:

// returns peek of the next digit in the stream or -1 if timeout
// discards non-numeric characters
int Stream::peekNextDigit()
{
    c48e:	cf 93       	push	r28
    c490:	df 93       	push	r29
    c492:	00 d0       	rcall	.+0      	; 0xc494 <_ZN6Stream13peekNextDigitEv+0x6>
    c494:	00 d0       	rcall	.+0      	; 0xc496 <_ZN6Stream13peekNextDigitEv+0x8>
    c496:	cd b7       	in	r28, 0x3d	; 61
    c498:	de b7       	in	r29, 0x3e	; 62
    c49a:	9c 83       	std	Y+4, r25	; 0x04
    c49c:	8b 83       	std	Y+3, r24	; 0x03
  int c;
  while (1) {
    c = timedPeek();
    c49e:	8b 81       	ldd	r24, Y+3	; 0x03
    c4a0:	9c 81       	ldd	r25, Y+4	; 0x04
    c4a2:	0e 94 f6 61 	call	0xc3ec	; 0xc3ec <_ZN6Stream9timedPeekEv>
    c4a6:	9a 83       	std	Y+2, r25	; 0x02
    c4a8:	89 83       	std	Y+1, r24	; 0x01
    if (c < 0) return c;  // timeout
    c4aa:	89 81       	ldd	r24, Y+1	; 0x01
    c4ac:	9a 81       	ldd	r25, Y+2	; 0x02
    c4ae:	99 23       	and	r25, r25
    c4b0:	1c f4       	brge	.+6      	; 0xc4b8 <_ZN6Stream13peekNextDigitEv+0x2a>
    c4b2:	89 81       	ldd	r24, Y+1	; 0x01
    c4b4:	9a 81       	ldd	r25, Y+2	; 0x02
    c4b6:	23 c0       	rjmp	.+70     	; 0xc4fe <_ZN6Stream13peekNextDigitEv+0x70>
    if (c == '-') return c;
    c4b8:	89 81       	ldd	r24, Y+1	; 0x01
    c4ba:	9a 81       	ldd	r25, Y+2	; 0x02
    c4bc:	8d 32       	cpi	r24, 0x2D	; 45
    c4be:	91 05       	cpc	r25, r1
    c4c0:	19 f4       	brne	.+6      	; 0xc4c8 <_ZN6Stream13peekNextDigitEv+0x3a>
    c4c2:	89 81       	ldd	r24, Y+1	; 0x01
    c4c4:	9a 81       	ldd	r25, Y+2	; 0x02
    c4c6:	1b c0       	rjmp	.+54     	; 0xc4fe <_ZN6Stream13peekNextDigitEv+0x70>
    if (c >= '0' && c <= '9') return c;
    c4c8:	89 81       	ldd	r24, Y+1	; 0x01
    c4ca:	9a 81       	ldd	r25, Y+2	; 0x02
    c4cc:	80 33       	cpi	r24, 0x30	; 48
    c4ce:	91 05       	cpc	r25, r1
    c4d0:	44 f0       	brlt	.+16     	; 0xc4e2 <_ZN6Stream13peekNextDigitEv+0x54>
    c4d2:	89 81       	ldd	r24, Y+1	; 0x01
    c4d4:	9a 81       	ldd	r25, Y+2	; 0x02
    c4d6:	8a 33       	cpi	r24, 0x3A	; 58
    c4d8:	91 05       	cpc	r25, r1
    c4da:	1c f4       	brge	.+6      	; 0xc4e2 <_ZN6Stream13peekNextDigitEv+0x54>
    c4dc:	89 81       	ldd	r24, Y+1	; 0x01
    c4de:	9a 81       	ldd	r25, Y+2	; 0x02
    c4e0:	0e c0       	rjmp	.+28     	; 0xc4fe <_ZN6Stream13peekNextDigitEv+0x70>
    read();  // discard non-numeric
    c4e2:	8b 81       	ldd	r24, Y+3	; 0x03
    c4e4:	9c 81       	ldd	r25, Y+4	; 0x04
    c4e6:	fc 01       	movw	r30, r24
    c4e8:	80 81       	ld	r24, Z
    c4ea:	91 81       	ldd	r25, Z+1	; 0x01
    c4ec:	06 96       	adiw	r24, 0x06	; 6
    c4ee:	fc 01       	movw	r30, r24
    c4f0:	20 81       	ld	r18, Z
    c4f2:	31 81       	ldd	r19, Z+1	; 0x01
    c4f4:	8b 81       	ldd	r24, Y+3	; 0x03
    c4f6:	9c 81       	ldd	r25, Y+4	; 0x04
    c4f8:	f9 01       	movw	r30, r18
    c4fa:	09 95       	icall
// returns peek of the next digit in the stream or -1 if timeout
// discards non-numeric characters
int Stream::peekNextDigit()
{
  int c;
  while (1) {
    c4fc:	d0 cf       	rjmp	.-96     	; 0xc49e <_ZN6Stream13peekNextDigitEv+0x10>
    if (c < 0) return c;  // timeout
    if (c == '-') return c;
    if (c >= '0' && c <= '9') return c;
    read();  // discard non-numeric
  }
}
    c4fe:	0f 90       	pop	r0
    c500:	0f 90       	pop	r0
    c502:	0f 90       	pop	r0
    c504:	0f 90       	pop	r0
    c506:	df 91       	pop	r29
    c508:	cf 91       	pop	r28
    c50a:	08 95       	ret

0000c50c <_ZN6Stream10setTimeoutEm>:

// Public Methods
//////////////////////////////////////////////////////////////

void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
{
    c50c:	cf 93       	push	r28
    c50e:	df 93       	push	r29
    c510:	00 d0       	rcall	.+0      	; 0xc512 <_ZN6Stream10setTimeoutEm+0x6>
    c512:	00 d0       	rcall	.+0      	; 0xc514 <_ZN6Stream10setTimeoutEm+0x8>
    c514:	00 d0       	rcall	.+0      	; 0xc516 <_ZN6Stream10setTimeoutEm+0xa>
    c516:	cd b7       	in	r28, 0x3d	; 61
    c518:	de b7       	in	r29, 0x3e	; 62
    c51a:	9a 83       	std	Y+2, r25	; 0x02
    c51c:	89 83       	std	Y+1, r24	; 0x01
    c51e:	4b 83       	std	Y+3, r20	; 0x03
    c520:	5c 83       	std	Y+4, r21	; 0x04
    c522:	6d 83       	std	Y+5, r22	; 0x05
    c524:	7e 83       	std	Y+6, r23	; 0x06
  _timeout = timeout;
    c526:	29 81       	ldd	r18, Y+1	; 0x01
    c528:	3a 81       	ldd	r19, Y+2	; 0x02
    c52a:	8b 81       	ldd	r24, Y+3	; 0x03
    c52c:	9c 81       	ldd	r25, Y+4	; 0x04
    c52e:	ad 81       	ldd	r26, Y+5	; 0x05
    c530:	be 81       	ldd	r27, Y+6	; 0x06
    c532:	f9 01       	movw	r30, r18
    c534:	84 83       	std	Z+4, r24	; 0x04
    c536:	95 83       	std	Z+5, r25	; 0x05
    c538:	a6 83       	std	Z+6, r26	; 0x06
    c53a:	b7 83       	std	Z+7, r27	; 0x07
}
    c53c:	26 96       	adiw	r28, 0x06	; 6
    c53e:	0f b6       	in	r0, 0x3f	; 63
    c540:	f8 94       	cli
    c542:	de bf       	out	0x3e, r29	; 62
    c544:	0f be       	out	0x3f, r0	; 63
    c546:	cd bf       	out	0x3d, r28	; 61
    c548:	df 91       	pop	r29
    c54a:	cf 91       	pop	r28
    c54c:	08 95       	ret

0000c54e <_ZN6Stream4findEPc>:

 // find returns true if the target string is found
bool  Stream::find(char *target)
{
    c54e:	cf 93       	push	r28
    c550:	df 93       	push	r29
    c552:	00 d0       	rcall	.+0      	; 0xc554 <_ZN6Stream4findEPc+0x6>
    c554:	00 d0       	rcall	.+0      	; 0xc556 <_ZN6Stream4findEPc+0x8>
    c556:	cd b7       	in	r28, 0x3d	; 61
    c558:	de b7       	in	r29, 0x3e	; 62
    c55a:	9a 83       	std	Y+2, r25	; 0x02
    c55c:	89 83       	std	Y+1, r24	; 0x01
    c55e:	7c 83       	std	Y+4, r23	; 0x04
    c560:	6b 83       	std	Y+3, r22	; 0x03
  return findUntil(target, NULL);
    c562:	2b 81       	ldd	r18, Y+3	; 0x03
    c564:	3c 81       	ldd	r19, Y+4	; 0x04
    c566:	89 81       	ldd	r24, Y+1	; 0x01
    c568:	9a 81       	ldd	r25, Y+2	; 0x02
    c56a:	40 e0       	ldi	r20, 0x00	; 0
    c56c:	50 e0       	ldi	r21, 0x00	; 0
    c56e:	b9 01       	movw	r22, r18
    c570:	0e 94 e7 62 	call	0xc5ce	; 0xc5ce <_ZN6Stream9findUntilEPcS0_>
}
    c574:	0f 90       	pop	r0
    c576:	0f 90       	pop	r0
    c578:	0f 90       	pop	r0
    c57a:	0f 90       	pop	r0
    c57c:	df 91       	pop	r29
    c57e:	cf 91       	pop	r28
    c580:	08 95       	ret

0000c582 <_ZN6Stream4findEPcj>:

// reads data from the stream until the target string of given length is found
// returns true if target string is found, false if timed out
bool Stream::find(char *target, size_t length)
{
    c582:	0f 93       	push	r16
    c584:	1f 93       	push	r17
    c586:	cf 93       	push	r28
    c588:	df 93       	push	r29
    c58a:	00 d0       	rcall	.+0      	; 0xc58c <_ZN6Stream4findEPcj+0xa>
    c58c:	00 d0       	rcall	.+0      	; 0xc58e <_ZN6Stream4findEPcj+0xc>
    c58e:	00 d0       	rcall	.+0      	; 0xc590 <_ZN6Stream4findEPcj+0xe>
    c590:	cd b7       	in	r28, 0x3d	; 61
    c592:	de b7       	in	r29, 0x3e	; 62
    c594:	9a 83       	std	Y+2, r25	; 0x02
    c596:	89 83       	std	Y+1, r24	; 0x01
    c598:	7c 83       	std	Y+4, r23	; 0x04
    c59a:	6b 83       	std	Y+3, r22	; 0x03
    c59c:	5e 83       	std	Y+6, r21	; 0x06
    c59e:	4d 83       	std	Y+5, r20	; 0x05
  return findUntil(target, length, NULL, 0);
    c5a0:	4d 81       	ldd	r20, Y+5	; 0x05
    c5a2:	5e 81       	ldd	r21, Y+6	; 0x06
    c5a4:	6b 81       	ldd	r22, Y+3	; 0x03
    c5a6:	7c 81       	ldd	r23, Y+4	; 0x04
    c5a8:	89 81       	ldd	r24, Y+1	; 0x01
    c5aa:	9a 81       	ldd	r25, Y+2	; 0x02
    c5ac:	00 e0       	ldi	r16, 0x00	; 0
    c5ae:	10 e0       	ldi	r17, 0x00	; 0
    c5b0:	20 e0       	ldi	r18, 0x00	; 0
    c5b2:	30 e0       	ldi	r19, 0x00	; 0
    c5b4:	0e 94 13 63 	call	0xc626	; 0xc626 <_ZN6Stream9findUntilEPcjS0_j>
}
    c5b8:	26 96       	adiw	r28, 0x06	; 6
    c5ba:	0f b6       	in	r0, 0x3f	; 63
    c5bc:	f8 94       	cli
    c5be:	de bf       	out	0x3e, r29	; 62
    c5c0:	0f be       	out	0x3f, r0	; 63
    c5c2:	cd bf       	out	0x3d, r28	; 61
    c5c4:	df 91       	pop	r29
    c5c6:	cf 91       	pop	r28
    c5c8:	1f 91       	pop	r17
    c5ca:	0f 91       	pop	r16
    c5cc:	08 95       	ret

0000c5ce <_ZN6Stream9findUntilEPcS0_>:

// as find but search ends if the terminator string is found
bool  Stream::findUntil(char *target, char *terminator)
{
    c5ce:	0f 93       	push	r16
    c5d0:	1f 93       	push	r17
    c5d2:	cf 93       	push	r28
    c5d4:	df 93       	push	r29
    c5d6:	00 d0       	rcall	.+0      	; 0xc5d8 <_ZN6Stream9findUntilEPcS0_+0xa>
    c5d8:	00 d0       	rcall	.+0      	; 0xc5da <_ZN6Stream9findUntilEPcS0_+0xc>
    c5da:	00 d0       	rcall	.+0      	; 0xc5dc <_ZN6Stream9findUntilEPcS0_+0xe>
    c5dc:	cd b7       	in	r28, 0x3d	; 61
    c5de:	de b7       	in	r29, 0x3e	; 62
    c5e0:	9a 83       	std	Y+2, r25	; 0x02
    c5e2:	89 83       	std	Y+1, r24	; 0x01
    c5e4:	7c 83       	std	Y+4, r23	; 0x04
    c5e6:	6b 83       	std	Y+3, r22	; 0x03
    c5e8:	5e 83       	std	Y+6, r21	; 0x06
    c5ea:	4d 83       	std	Y+5, r20	; 0x05
  return findUntil(target, strlen(target), terminator, strlen(terminator));
    c5ec:	8d 81       	ldd	r24, Y+5	; 0x05
    c5ee:	9e 81       	ldd	r25, Y+6	; 0x06
    c5f0:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    c5f4:	8c 01       	movw	r16, r24
    c5f6:	8b 81       	ldd	r24, Y+3	; 0x03
    c5f8:	9c 81       	ldd	r25, Y+4	; 0x04
    c5fa:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    c5fe:	ac 01       	movw	r20, r24
    c600:	2d 81       	ldd	r18, Y+5	; 0x05
    c602:	3e 81       	ldd	r19, Y+6	; 0x06
    c604:	6b 81       	ldd	r22, Y+3	; 0x03
    c606:	7c 81       	ldd	r23, Y+4	; 0x04
    c608:	89 81       	ldd	r24, Y+1	; 0x01
    c60a:	9a 81       	ldd	r25, Y+2	; 0x02
    c60c:	0e 94 13 63 	call	0xc626	; 0xc626 <_ZN6Stream9findUntilEPcjS0_j>
}
    c610:	26 96       	adiw	r28, 0x06	; 6
    c612:	0f b6       	in	r0, 0x3f	; 63
    c614:	f8 94       	cli
    c616:	de bf       	out	0x3e, r29	; 62
    c618:	0f be       	out	0x3f, r0	; 63
    c61a:	cd bf       	out	0x3d, r28	; 61
    c61c:	df 91       	pop	r29
    c61e:	cf 91       	pop	r28
    c620:	1f 91       	pop	r17
    c622:	0f 91       	pop	r16
    c624:	08 95       	ret

0000c626 <_ZN6Stream9findUntilEPcjS0_j>:

// reads data from the stream until the target string of the given length is found
// search terminated if the terminator string is found
// returns true if target string is found, false if terminated or timed out
bool Stream::findUntil(char *target, size_t targetLen, char *terminator, size_t termLen)
{
    c626:	0f 93       	push	r16
    c628:	1f 93       	push	r17
    c62a:	cf 93       	push	r28
    c62c:	df 93       	push	r29
    c62e:	cd b7       	in	r28, 0x3d	; 61
    c630:	de b7       	in	r29, 0x3e	; 62
    c632:	60 97       	sbiw	r28, 0x10	; 16
    c634:	0f b6       	in	r0, 0x3f	; 63
    c636:	f8 94       	cli
    c638:	de bf       	out	0x3e, r29	; 62
    c63a:	0f be       	out	0x3f, r0	; 63
    c63c:	cd bf       	out	0x3d, r28	; 61
    c63e:	98 87       	std	Y+8, r25	; 0x08
    c640:	8f 83       	std	Y+7, r24	; 0x07
    c642:	7a 87       	std	Y+10, r23	; 0x0a
    c644:	69 87       	std	Y+9, r22	; 0x09
    c646:	5c 87       	std	Y+12, r21	; 0x0c
    c648:	4b 87       	std	Y+11, r20	; 0x0b
    c64a:	3e 87       	std	Y+14, r19	; 0x0e
    c64c:	2d 87       	std	Y+13, r18	; 0x0d
    c64e:	18 8b       	std	Y+16, r17	; 0x10
    c650:	0f 87       	std	Y+15, r16	; 0x0f
  size_t index = 0;  // maximum target string length is 64k bytes!
    c652:	1a 82       	std	Y+2, r1	; 0x02
    c654:	19 82       	std	Y+1, r1	; 0x01
  size_t termIndex = 0;
    c656:	1c 82       	std	Y+4, r1	; 0x04
    c658:	1b 82       	std	Y+3, r1	; 0x03
  int c;
  
  if( *target == 0)
    c65a:	89 85       	ldd	r24, Y+9	; 0x09
    c65c:	9a 85       	ldd	r25, Y+10	; 0x0a
    c65e:	fc 01       	movw	r30, r24
    c660:	80 81       	ld	r24, Z
    c662:	88 23       	and	r24, r24
    c664:	09 f0       	breq	.+2      	; 0xc668 <_ZN6Stream9findUntilEPcjS0_j+0x42>
    c666:	5b c0       	rjmp	.+182    	; 0xc71e <_ZN6Stream9findUntilEPcjS0_j+0xf8>
    return true;   // return true if target is a null string
    c668:	81 e0       	ldi	r24, 0x01	; 1
    c66a:	6a c0       	rjmp	.+212    	; 0xc740 <_ZN6Stream9findUntilEPcjS0_j+0x11a>
  while( (c = timedRead()) > 0){
    
    if(c != target[index])
    c66c:	29 85       	ldd	r18, Y+9	; 0x09
    c66e:	3a 85       	ldd	r19, Y+10	; 0x0a
    c670:	89 81       	ldd	r24, Y+1	; 0x01
    c672:	9a 81       	ldd	r25, Y+2	; 0x02
    c674:	82 0f       	add	r24, r18
    c676:	93 1f       	adc	r25, r19
    c678:	fc 01       	movw	r30, r24
    c67a:	80 81       	ld	r24, Z
    c67c:	28 2f       	mov	r18, r24
    c67e:	30 e0       	ldi	r19, 0x00	; 0
    c680:	8d 81       	ldd	r24, Y+5	; 0x05
    c682:	9e 81       	ldd	r25, Y+6	; 0x06
    c684:	28 17       	cp	r18, r24
    c686:	39 07       	cpc	r19, r25
    c688:	11 f0       	breq	.+4      	; 0xc68e <_ZN6Stream9findUntilEPcjS0_j+0x68>
      index = 0; // reset index if any char does not match
    c68a:	1a 82       	std	Y+2, r1	; 0x02
    c68c:	19 82       	std	Y+1, r1	; 0x01
    
    if( c == target[index]){
    c68e:	29 85       	ldd	r18, Y+9	; 0x09
    c690:	3a 85       	ldd	r19, Y+10	; 0x0a
    c692:	89 81       	ldd	r24, Y+1	; 0x01
    c694:	9a 81       	ldd	r25, Y+2	; 0x02
    c696:	82 0f       	add	r24, r18
    c698:	93 1f       	adc	r25, r19
    c69a:	fc 01       	movw	r30, r24
    c69c:	80 81       	ld	r24, Z
    c69e:	28 2f       	mov	r18, r24
    c6a0:	30 e0       	ldi	r19, 0x00	; 0
    c6a2:	8d 81       	ldd	r24, Y+5	; 0x05
    c6a4:	9e 81       	ldd	r25, Y+6	; 0x06
    c6a6:	28 17       	cp	r18, r24
    c6a8:	39 07       	cpc	r19, r25
    c6aa:	91 f4       	brne	.+36     	; 0xc6d0 <_ZN6Stream9findUntilEPcjS0_j+0xaa>
      //////Serial.print("found "); Serial.write(c); Serial.print("index now"); Serial.println(index+1);
      if(++index >= targetLen){ // return true if all chars in the target match
    c6ac:	89 81       	ldd	r24, Y+1	; 0x01
    c6ae:	9a 81       	ldd	r25, Y+2	; 0x02
    c6b0:	01 96       	adiw	r24, 0x01	; 1
    c6b2:	9a 83       	std	Y+2, r25	; 0x02
    c6b4:	89 83       	std	Y+1, r24	; 0x01
    c6b6:	41 e0       	ldi	r20, 0x01	; 1
    c6b8:	29 81       	ldd	r18, Y+1	; 0x01
    c6ba:	3a 81       	ldd	r19, Y+2	; 0x02
    c6bc:	8b 85       	ldd	r24, Y+11	; 0x0b
    c6be:	9c 85       	ldd	r25, Y+12	; 0x0c
    c6c0:	28 17       	cp	r18, r24
    c6c2:	39 07       	cpc	r19, r25
    c6c4:	08 f4       	brcc	.+2      	; 0xc6c8 <_ZN6Stream9findUntilEPcjS0_j+0xa2>
    c6c6:	40 e0       	ldi	r20, 0x00	; 0
    c6c8:	44 23       	and	r20, r20
    c6ca:	11 f0       	breq	.+4      	; 0xc6d0 <_ZN6Stream9findUntilEPcjS0_j+0xaa>
        return true;
    c6cc:	81 e0       	ldi	r24, 0x01	; 1
    c6ce:	38 c0       	rjmp	.+112    	; 0xc740 <_ZN6Stream9findUntilEPcjS0_j+0x11a>
      }
    }
    
    if(termLen > 0 && c == terminator[termIndex]){
    c6d0:	8f 85       	ldd	r24, Y+15	; 0x0f
    c6d2:	98 89       	ldd	r25, Y+16	; 0x10
    c6d4:	00 97       	sbiw	r24, 0x00	; 0
    c6d6:	09 f1       	breq	.+66     	; 0xc71a <_ZN6Stream9findUntilEPcjS0_j+0xf4>
    c6d8:	2d 85       	ldd	r18, Y+13	; 0x0d
    c6da:	3e 85       	ldd	r19, Y+14	; 0x0e
    c6dc:	8b 81       	ldd	r24, Y+3	; 0x03
    c6de:	9c 81       	ldd	r25, Y+4	; 0x04
    c6e0:	82 0f       	add	r24, r18
    c6e2:	93 1f       	adc	r25, r19
    c6e4:	fc 01       	movw	r30, r24
    c6e6:	80 81       	ld	r24, Z
    c6e8:	28 2f       	mov	r18, r24
    c6ea:	30 e0       	ldi	r19, 0x00	; 0
    c6ec:	8d 81       	ldd	r24, Y+5	; 0x05
    c6ee:	9e 81       	ldd	r25, Y+6	; 0x06
    c6f0:	28 17       	cp	r18, r24
    c6f2:	39 07       	cpc	r19, r25
    c6f4:	91 f4       	brne	.+36     	; 0xc71a <_ZN6Stream9findUntilEPcjS0_j+0xf4>
      if(++termIndex >= termLen)
    c6f6:	8b 81       	ldd	r24, Y+3	; 0x03
    c6f8:	9c 81       	ldd	r25, Y+4	; 0x04
    c6fa:	01 96       	adiw	r24, 0x01	; 1
    c6fc:	9c 83       	std	Y+4, r25	; 0x04
    c6fe:	8b 83       	std	Y+3, r24	; 0x03
    c700:	41 e0       	ldi	r20, 0x01	; 1
    c702:	2b 81       	ldd	r18, Y+3	; 0x03
    c704:	3c 81       	ldd	r19, Y+4	; 0x04
    c706:	8f 85       	ldd	r24, Y+15	; 0x0f
    c708:	98 89       	ldd	r25, Y+16	; 0x10
    c70a:	28 17       	cp	r18, r24
    c70c:	39 07       	cpc	r19, r25
    c70e:	08 f4       	brcc	.+2      	; 0xc712 <_ZN6Stream9findUntilEPcjS0_j+0xec>
    c710:	40 e0       	ldi	r20, 0x00	; 0
    c712:	44 23       	and	r20, r20
    c714:	21 f0       	breq	.+8      	; 0xc71e <_ZN6Stream9findUntilEPcjS0_j+0xf8>
        return false;       // return false if terminate string found before target string
    c716:	80 e0       	ldi	r24, 0x00	; 0
    c718:	13 c0       	rjmp	.+38     	; 0xc740 <_ZN6Stream9findUntilEPcjS0_j+0x11a>
    }
    else
      termIndex = 0;
    c71a:	1c 82       	std	Y+4, r1	; 0x04
    c71c:	1b 82       	std	Y+3, r1	; 0x03
  size_t termIndex = 0;
  int c;
  
  if( *target == 0)
    return true;   // return true if target is a null string
  while( (c = timedRead()) > 0){
    c71e:	8f 81       	ldd	r24, Y+7	; 0x07
    c720:	98 85       	ldd	r25, Y+8	; 0x08
    c722:	0e 94 a5 61 	call	0xc34a	; 0xc34a <_ZN6Stream9timedReadEv>
    c726:	9e 83       	std	Y+6, r25	; 0x06
    c728:	8d 83       	std	Y+5, r24	; 0x05
    c72a:	21 e0       	ldi	r18, 0x01	; 1
    c72c:	8d 81       	ldd	r24, Y+5	; 0x05
    c72e:	9e 81       	ldd	r25, Y+6	; 0x06
    c730:	18 16       	cp	r1, r24
    c732:	19 06       	cpc	r1, r25
    c734:	0c f0       	brlt	.+2      	; 0xc738 <_ZN6Stream9findUntilEPcjS0_j+0x112>
    c736:	20 e0       	ldi	r18, 0x00	; 0
    c738:	22 23       	and	r18, r18
    c73a:	09 f0       	breq	.+2      	; 0xc73e <_ZN6Stream9findUntilEPcjS0_j+0x118>
    c73c:	97 cf       	rjmp	.-210    	; 0xc66c <_ZN6Stream9findUntilEPcjS0_j+0x46>
        return false;       // return false if terminate string found before target string
    }
    else
      termIndex = 0;
  }
  return false;
    c73e:	80 e0       	ldi	r24, 0x00	; 0
}
    c740:	60 96       	adiw	r28, 0x10	; 16
    c742:	0f b6       	in	r0, 0x3f	; 63
    c744:	f8 94       	cli
    c746:	de bf       	out	0x3e, r29	; 62
    c748:	0f be       	out	0x3f, r0	; 63
    c74a:	cd bf       	out	0x3d, r28	; 61
    c74c:	df 91       	pop	r29
    c74e:	cf 91       	pop	r28
    c750:	1f 91       	pop	r17
    c752:	0f 91       	pop	r16
    c754:	08 95       	ret

0000c756 <_ZN6Stream8parseIntEv>:

// returns the first valid (long) integer value from the current position.
// initial characters that are not digits (or the minus sign) are skipped
// function is terminated by the first character that is not a digit.
long Stream::parseInt()
{
    c756:	cf 93       	push	r28
    c758:	df 93       	push	r29
    c75a:	00 d0       	rcall	.+0      	; 0xc75c <_ZN6Stream8parseIntEv+0x6>
    c75c:	cd b7       	in	r28, 0x3d	; 61
    c75e:	de b7       	in	r29, 0x3e	; 62
    c760:	9a 83       	std	Y+2, r25	; 0x02
    c762:	89 83       	std	Y+1, r24	; 0x01
  return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
    c764:	89 81       	ldd	r24, Y+1	; 0x01
    c766:	9a 81       	ldd	r25, Y+2	; 0x02
    c768:	61 e0       	ldi	r22, 0x01	; 1
    c76a:	0e 94 c0 63 	call	0xc780	; 0xc780 <_ZN6Stream8parseIntEc>
    c76e:	dc 01       	movw	r26, r24
    c770:	cb 01       	movw	r24, r22
}
    c772:	bc 01       	movw	r22, r24
    c774:	cd 01       	movw	r24, r26
    c776:	0f 90       	pop	r0
    c778:	0f 90       	pop	r0
    c77a:	df 91       	pop	r29
    c77c:	cf 91       	pop	r28
    c77e:	08 95       	ret

0000c780 <_ZN6Stream8parseIntEc>:

// as above but a given skipChar is ignored
// this allows format characters (typically commas) in values to be ignored
long Stream::parseInt(char skipChar)
{
    c780:	cf 93       	push	r28
    c782:	df 93       	push	r29
    c784:	cd b7       	in	r28, 0x3d	; 61
    c786:	de b7       	in	r29, 0x3e	; 62
    c788:	2a 97       	sbiw	r28, 0x0a	; 10
    c78a:	0f b6       	in	r0, 0x3f	; 63
    c78c:	f8 94       	cli
    c78e:	de bf       	out	0x3e, r29	; 62
    c790:	0f be       	out	0x3f, r0	; 63
    c792:	cd bf       	out	0x3d, r28	; 61
    c794:	99 87       	std	Y+9, r25	; 0x09
    c796:	88 87       	std	Y+8, r24	; 0x08
    c798:	6a 87       	std	Y+10, r22	; 0x0a
  boolean isNegative = false;
    c79a:	19 82       	std	Y+1, r1	; 0x01
  long value = 0;
    c79c:	1a 82       	std	Y+2, r1	; 0x02
    c79e:	1b 82       	std	Y+3, r1	; 0x03
    c7a0:	1c 82       	std	Y+4, r1	; 0x04
    c7a2:	1d 82       	std	Y+5, r1	; 0x05
  int c;

  c = peekNextDigit();
    c7a4:	88 85       	ldd	r24, Y+8	; 0x08
    c7a6:	99 85       	ldd	r25, Y+9	; 0x09
    c7a8:	0e 94 47 62 	call	0xc48e	; 0xc48e <_ZN6Stream13peekNextDigitEv>
    c7ac:	9f 83       	std	Y+7, r25	; 0x07
    c7ae:	8e 83       	std	Y+6, r24	; 0x06
  // ignore non numeric leading characters
  if(c < 0)
    c7b0:	8e 81       	ldd	r24, Y+6	; 0x06
    c7b2:	9f 81       	ldd	r25, Y+7	; 0x07
    c7b4:	99 23       	and	r25, r25
    c7b6:	24 f4       	brge	.+8      	; 0xc7c0 <_ZN6Stream8parseIntEc+0x40>
    return 0; // zero returned if timeout
    c7b8:	80 e0       	ldi	r24, 0x00	; 0
    c7ba:	90 e0       	ldi	r25, 0x00	; 0
    c7bc:	dc 01       	movw	r26, r24
    c7be:	82 c0       	rjmp	.+260    	; 0xc8c4 <_ZN6Stream8parseIntEc+0x144>

  do{
    if(c == skipChar)
    c7c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    c7c2:	28 2f       	mov	r18, r24
    c7c4:	30 e0       	ldi	r19, 0x00	; 0
    c7c6:	8e 81       	ldd	r24, Y+6	; 0x06
    c7c8:	9f 81       	ldd	r25, Y+7	; 0x07
    c7ca:	28 17       	cp	r18, r24
    c7cc:	39 07       	cpc	r19, r25
    c7ce:	c9 f1       	breq	.+114    	; 0xc842 <_ZN6Stream8parseIntEc+0xc2>
      ; // ignore this charactor
    else if(c == '-')
    c7d0:	8e 81       	ldd	r24, Y+6	; 0x06
    c7d2:	9f 81       	ldd	r25, Y+7	; 0x07
    c7d4:	8d 32       	cpi	r24, 0x2D	; 45
    c7d6:	91 05       	cpc	r25, r1
    c7d8:	19 f4       	brne	.+6      	; 0xc7e0 <_ZN6Stream8parseIntEc+0x60>
      isNegative = true;
    c7da:	81 e0       	ldi	r24, 0x01	; 1
    c7dc:	89 83       	std	Y+1, r24	; 0x01
    c7de:	31 c0       	rjmp	.+98     	; 0xc842 <_ZN6Stream8parseIntEc+0xc2>
    else if(c >= '0' && c <= '9')        // is c a digit?
    c7e0:	8e 81       	ldd	r24, Y+6	; 0x06
    c7e2:	9f 81       	ldd	r25, Y+7	; 0x07
    c7e4:	80 33       	cpi	r24, 0x30	; 48
    c7e6:	91 05       	cpc	r25, r1
    c7e8:	64 f1       	brlt	.+88     	; 0xc842 <_ZN6Stream8parseIntEc+0xc2>
    c7ea:	8e 81       	ldd	r24, Y+6	; 0x06
    c7ec:	9f 81       	ldd	r25, Y+7	; 0x07
    c7ee:	8a 33       	cpi	r24, 0x3A	; 58
    c7f0:	91 05       	cpc	r25, r1
    c7f2:	3c f5       	brge	.+78     	; 0xc842 <_ZN6Stream8parseIntEc+0xc2>
      value = value * 10 + c - '0';
    c7f4:	8a 81       	ldd	r24, Y+2	; 0x02
    c7f6:	9b 81       	ldd	r25, Y+3	; 0x03
    c7f8:	ac 81       	ldd	r26, Y+4	; 0x04
    c7fa:	bd 81       	ldd	r27, Y+5	; 0x05
    c7fc:	88 0f       	add	r24, r24
    c7fe:	99 1f       	adc	r25, r25
    c800:	aa 1f       	adc	r26, r26
    c802:	bb 1f       	adc	r27, r27
    c804:	9c 01       	movw	r18, r24
    c806:	ad 01       	movw	r20, r26
    c808:	22 0f       	add	r18, r18
    c80a:	33 1f       	adc	r19, r19
    c80c:	44 1f       	adc	r20, r20
    c80e:	55 1f       	adc	r21, r21
    c810:	22 0f       	add	r18, r18
    c812:	33 1f       	adc	r19, r19
    c814:	44 1f       	adc	r20, r20
    c816:	55 1f       	adc	r21, r21
    c818:	28 0f       	add	r18, r24
    c81a:	39 1f       	adc	r19, r25
    c81c:	4a 1f       	adc	r20, r26
    c81e:	5b 1f       	adc	r21, r27
    c820:	8e 81       	ldd	r24, Y+6	; 0x06
    c822:	9f 81       	ldd	r25, Y+7	; 0x07
    c824:	aa 27       	eor	r26, r26
    c826:	97 fd       	sbrc	r25, 7
    c828:	a0 95       	com	r26
    c82a:	ba 2f       	mov	r27, r26
    c82c:	82 0f       	add	r24, r18
    c82e:	93 1f       	adc	r25, r19
    c830:	a4 1f       	adc	r26, r20
    c832:	b5 1f       	adc	r27, r21
    c834:	c0 97       	sbiw	r24, 0x30	; 48
    c836:	a1 09       	sbc	r26, r1
    c838:	b1 09       	sbc	r27, r1
    c83a:	8a 83       	std	Y+2, r24	; 0x02
    c83c:	9b 83       	std	Y+3, r25	; 0x03
    c83e:	ac 83       	std	Y+4, r26	; 0x04
    c840:	bd 83       	std	Y+5, r27	; 0x05
    read();  // consume the character we got with peek
    c842:	88 85       	ldd	r24, Y+8	; 0x08
    c844:	99 85       	ldd	r25, Y+9	; 0x09
    c846:	fc 01       	movw	r30, r24
    c848:	80 81       	ld	r24, Z
    c84a:	91 81       	ldd	r25, Z+1	; 0x01
    c84c:	06 96       	adiw	r24, 0x06	; 6
    c84e:	fc 01       	movw	r30, r24
    c850:	20 81       	ld	r18, Z
    c852:	31 81       	ldd	r19, Z+1	; 0x01
    c854:	88 85       	ldd	r24, Y+8	; 0x08
    c856:	99 85       	ldd	r25, Y+9	; 0x09
    c858:	f9 01       	movw	r30, r18
    c85a:	09 95       	icall
    c = timedPeek();
    c85c:	88 85       	ldd	r24, Y+8	; 0x08
    c85e:	99 85       	ldd	r25, Y+9	; 0x09
    c860:	0e 94 f6 61 	call	0xc3ec	; 0xc3ec <_ZN6Stream9timedPeekEv>
    c864:	9f 83       	std	Y+7, r25	; 0x07
    c866:	8e 83       	std	Y+6, r24	; 0x06
  c = peekNextDigit();
  // ignore non numeric leading characters
  if(c < 0)
    return 0; // zero returned if timeout

  do{
    c868:	8e 81       	ldd	r24, Y+6	; 0x06
    c86a:	9f 81       	ldd	r25, Y+7	; 0x07
    c86c:	80 33       	cpi	r24, 0x30	; 48
    c86e:	91 05       	cpc	r25, r1
    c870:	2c f0       	brlt	.+10     	; 0xc87c <_ZN6Stream8parseIntEc+0xfc>
    c872:	8e 81       	ldd	r24, Y+6	; 0x06
    c874:	9f 81       	ldd	r25, Y+7	; 0x07
    c876:	8a 33       	cpi	r24, 0x3A	; 58
    c878:	91 05       	cpc	r25, r1
    c87a:	44 f0       	brlt	.+16     	; 0xc88c <_ZN6Stream8parseIntEc+0x10c>
    c87c:	8a 85       	ldd	r24, Y+10	; 0x0a
    c87e:	28 2f       	mov	r18, r24
    c880:	30 e0       	ldi	r19, 0x00	; 0
    c882:	8e 81       	ldd	r24, Y+6	; 0x06
    c884:	9f 81       	ldd	r25, Y+7	; 0x07
    c886:	28 17       	cp	r18, r24
    c888:	39 07       	cpc	r19, r25
    c88a:	11 f4       	brne	.+4      	; 0xc890 <_ZN6Stream8parseIntEc+0x110>
    c88c:	81 e0       	ldi	r24, 0x01	; 1
    c88e:	01 c0       	rjmp	.+2      	; 0xc892 <_ZN6Stream8parseIntEc+0x112>
    c890:	80 e0       	ldi	r24, 0x00	; 0
    c892:	88 23       	and	r24, r24
    c894:	09 f0       	breq	.+2      	; 0xc898 <_ZN6Stream8parseIntEc+0x118>
    c896:	94 cf       	rjmp	.-216    	; 0xc7c0 <_ZN6Stream8parseIntEc+0x40>
    read();  // consume the character we got with peek
    c = timedPeek();
  }
  while( (c >= '0' && c <= '9') || c == skipChar );

  if(isNegative)
    c898:	89 81       	ldd	r24, Y+1	; 0x01
    c89a:	88 23       	and	r24, r24
    c89c:	79 f0       	breq	.+30     	; 0xc8bc <_ZN6Stream8parseIntEc+0x13c>
    value = -value;
    c89e:	8a 81       	ldd	r24, Y+2	; 0x02
    c8a0:	9b 81       	ldd	r25, Y+3	; 0x03
    c8a2:	ac 81       	ldd	r26, Y+4	; 0x04
    c8a4:	bd 81       	ldd	r27, Y+5	; 0x05
    c8a6:	b0 95       	com	r27
    c8a8:	a0 95       	com	r26
    c8aa:	90 95       	com	r25
    c8ac:	81 95       	neg	r24
    c8ae:	9f 4f       	sbci	r25, 0xFF	; 255
    c8b0:	af 4f       	sbci	r26, 0xFF	; 255
    c8b2:	bf 4f       	sbci	r27, 0xFF	; 255
    c8b4:	8a 83       	std	Y+2, r24	; 0x02
    c8b6:	9b 83       	std	Y+3, r25	; 0x03
    c8b8:	ac 83       	std	Y+4, r26	; 0x04
    c8ba:	bd 83       	std	Y+5, r27	; 0x05
  return value;
    c8bc:	8a 81       	ldd	r24, Y+2	; 0x02
    c8be:	9b 81       	ldd	r25, Y+3	; 0x03
    c8c0:	ac 81       	ldd	r26, Y+4	; 0x04
    c8c2:	bd 81       	ldd	r27, Y+5	; 0x05
}
    c8c4:	bc 01       	movw	r22, r24
    c8c6:	cd 01       	movw	r24, r26
    c8c8:	2a 96       	adiw	r28, 0x0a	; 10
    c8ca:	0f b6       	in	r0, 0x3f	; 63
    c8cc:	f8 94       	cli
    c8ce:	de bf       	out	0x3e, r29	; 62
    c8d0:	0f be       	out	0x3f, r0	; 63
    c8d2:	cd bf       	out	0x3d, r28	; 61
    c8d4:	df 91       	pop	r29
    c8d6:	cf 91       	pop	r28
    c8d8:	08 95       	ret

0000c8da <_ZN6Stream10parseFloatEv>:


// as parseInt but returns a floating point value
float Stream::parseFloat()
{
    c8da:	cf 93       	push	r28
    c8dc:	df 93       	push	r29
    c8de:	00 d0       	rcall	.+0      	; 0xc8e0 <_ZN6Stream10parseFloatEv+0x6>
    c8e0:	cd b7       	in	r28, 0x3d	; 61
    c8e2:	de b7       	in	r29, 0x3e	; 62
    c8e4:	9a 83       	std	Y+2, r25	; 0x02
    c8e6:	89 83       	std	Y+1, r24	; 0x01
  return parseFloat(NO_SKIP_CHAR);
    c8e8:	89 81       	ldd	r24, Y+1	; 0x01
    c8ea:	9a 81       	ldd	r25, Y+2	; 0x02
    c8ec:	61 e0       	ldi	r22, 0x01	; 1
    c8ee:	0e 94 82 64 	call	0xc904	; 0xc904 <_ZN6Stream10parseFloatEc>
    c8f2:	dc 01       	movw	r26, r24
    c8f4:	cb 01       	movw	r24, r22
}
    c8f6:	bc 01       	movw	r22, r24
    c8f8:	cd 01       	movw	r24, r26
    c8fa:	0f 90       	pop	r0
    c8fc:	0f 90       	pop	r0
    c8fe:	df 91       	pop	r29
    c900:	cf 91       	pop	r28
    c902:	08 95       	ret

0000c904 <_ZN6Stream10parseFloatEc>:

// as above but the given skipChar is ignored
// this allows format characters (typically commas) in values to be ignored
float Stream::parseFloat(char skipChar){
    c904:	cf 93       	push	r28
    c906:	df 93       	push	r29
    c908:	cd b7       	in	r28, 0x3d	; 61
    c90a:	de b7       	in	r29, 0x3e	; 62
    c90c:	2e 97       	sbiw	r28, 0x0e	; 14
    c90e:	0f b6       	in	r0, 0x3f	; 63
    c910:	f8 94       	cli
    c912:	de bf       	out	0x3e, r29	; 62
    c914:	0f be       	out	0x3f, r0	; 63
    c916:	cd bf       	out	0x3d, r28	; 61
    c918:	9d 87       	std	Y+13, r25	; 0x0d
    c91a:	8c 87       	std	Y+12, r24	; 0x0c
    c91c:	6e 87       	std	Y+14, r22	; 0x0e
  boolean isNegative = false;
    c91e:	19 82       	std	Y+1, r1	; 0x01
  boolean isFraction = false;
    c920:	1a 82       	std	Y+2, r1	; 0x02
  long value = 0;
    c922:	1b 82       	std	Y+3, r1	; 0x03
    c924:	1c 82       	std	Y+4, r1	; 0x04
    c926:	1d 82       	std	Y+5, r1	; 0x05
    c928:	1e 82       	std	Y+6, r1	; 0x06
  char c;
  float fraction = 1.0;
    c92a:	80 e0       	ldi	r24, 0x00	; 0
    c92c:	90 e0       	ldi	r25, 0x00	; 0
    c92e:	a0 e8       	ldi	r26, 0x80	; 128
    c930:	bf e3       	ldi	r27, 0x3F	; 63
    c932:	88 87       	std	Y+8, r24	; 0x08
    c934:	99 87       	std	Y+9, r25	; 0x09
    c936:	aa 87       	std	Y+10, r26	; 0x0a
    c938:	bb 87       	std	Y+11, r27	; 0x0b

  c = peekNextDigit();
    c93a:	8c 85       	ldd	r24, Y+12	; 0x0c
    c93c:	9d 85       	ldd	r25, Y+13	; 0x0d
    c93e:	0e 94 47 62 	call	0xc48e	; 0xc48e <_ZN6Stream13peekNextDigitEv>
    c942:	8f 83       	std	Y+7, r24	; 0x07
    // ignore non numeric leading characters
  if(c < 0)
    return 0; // zero returned if timeout

  do{
    if(c == skipChar)
    c944:	9f 81       	ldd	r25, Y+7	; 0x07
    c946:	8e 85       	ldd	r24, Y+14	; 0x0e
    c948:	98 17       	cp	r25, r24
    c94a:	09 f4       	brne	.+2      	; 0xc94e <_ZN6Stream10parseFloatEc+0x4a>
    c94c:	4b c0       	rjmp	.+150    	; 0xc9e4 <_ZN6Stream10parseFloatEc+0xe0>
      ; // ignore
    else if(c == '-')
    c94e:	8f 81       	ldd	r24, Y+7	; 0x07
    c950:	8d 32       	cpi	r24, 0x2D	; 45
    c952:	19 f4       	brne	.+6      	; 0xc95a <_ZN6Stream10parseFloatEc+0x56>
      isNegative = true;
    c954:	81 e0       	ldi	r24, 0x01	; 1
    c956:	89 83       	std	Y+1, r24	; 0x01
    c958:	45 c0       	rjmp	.+138    	; 0xc9e4 <_ZN6Stream10parseFloatEc+0xe0>
    else if (c == '.')
    c95a:	8f 81       	ldd	r24, Y+7	; 0x07
    c95c:	8e 32       	cpi	r24, 0x2E	; 46
    c95e:	19 f4       	brne	.+6      	; 0xc966 <_ZN6Stream10parseFloatEc+0x62>
      isFraction = true;
    c960:	81 e0       	ldi	r24, 0x01	; 1
    c962:	8a 83       	std	Y+2, r24	; 0x02
    c964:	3f c0       	rjmp	.+126    	; 0xc9e4 <_ZN6Stream10parseFloatEc+0xe0>
    else if(c >= '0' && c <= '9')  {      // is c a digit?
    c966:	8f 81       	ldd	r24, Y+7	; 0x07
    c968:	80 33       	cpi	r24, 0x30	; 48
    c96a:	e0 f1       	brcs	.+120    	; 0xc9e4 <_ZN6Stream10parseFloatEc+0xe0>
    c96c:	8f 81       	ldd	r24, Y+7	; 0x07
    c96e:	8a 33       	cpi	r24, 0x3A	; 58
    c970:	c8 f5       	brcc	.+114    	; 0xc9e4 <_ZN6Stream10parseFloatEc+0xe0>
      value = value * 10 + c - '0';
    c972:	8b 81       	ldd	r24, Y+3	; 0x03
    c974:	9c 81       	ldd	r25, Y+4	; 0x04
    c976:	ad 81       	ldd	r26, Y+5	; 0x05
    c978:	be 81       	ldd	r27, Y+6	; 0x06
    c97a:	88 0f       	add	r24, r24
    c97c:	99 1f       	adc	r25, r25
    c97e:	aa 1f       	adc	r26, r26
    c980:	bb 1f       	adc	r27, r27
    c982:	9c 01       	movw	r18, r24
    c984:	ad 01       	movw	r20, r26
    c986:	22 0f       	add	r18, r18
    c988:	33 1f       	adc	r19, r19
    c98a:	44 1f       	adc	r20, r20
    c98c:	55 1f       	adc	r21, r21
    c98e:	22 0f       	add	r18, r18
    c990:	33 1f       	adc	r19, r19
    c992:	44 1f       	adc	r20, r20
    c994:	55 1f       	adc	r21, r21
    c996:	28 0f       	add	r18, r24
    c998:	39 1f       	adc	r19, r25
    c99a:	4a 1f       	adc	r20, r26
    c99c:	5b 1f       	adc	r21, r27
    c99e:	8f 81       	ldd	r24, Y+7	; 0x07
    c9a0:	88 2f       	mov	r24, r24
    c9a2:	90 e0       	ldi	r25, 0x00	; 0
    c9a4:	a0 e0       	ldi	r26, 0x00	; 0
    c9a6:	b0 e0       	ldi	r27, 0x00	; 0
    c9a8:	82 0f       	add	r24, r18
    c9aa:	93 1f       	adc	r25, r19
    c9ac:	a4 1f       	adc	r26, r20
    c9ae:	b5 1f       	adc	r27, r21
    c9b0:	c0 97       	sbiw	r24, 0x30	; 48
    c9b2:	a1 09       	sbc	r26, r1
    c9b4:	b1 09       	sbc	r27, r1
    c9b6:	8b 83       	std	Y+3, r24	; 0x03
    c9b8:	9c 83       	std	Y+4, r25	; 0x04
    c9ba:	ad 83       	std	Y+5, r26	; 0x05
    c9bc:	be 83       	std	Y+6, r27	; 0x06
      if(isFraction)
    c9be:	8a 81       	ldd	r24, Y+2	; 0x02
    c9c0:	88 23       	and	r24, r24
    c9c2:	81 f0       	breq	.+32     	; 0xc9e4 <_ZN6Stream10parseFloatEc+0xe0>
         fraction *= 0.1;
    c9c4:	2d ec       	ldi	r18, 0xCD	; 205
    c9c6:	3c ec       	ldi	r19, 0xCC	; 204
    c9c8:	4c ec       	ldi	r20, 0xCC	; 204
    c9ca:	5d e3       	ldi	r21, 0x3D	; 61
    c9cc:	68 85       	ldd	r22, Y+8	; 0x08
    c9ce:	79 85       	ldd	r23, Y+9	; 0x09
    c9d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    c9d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    c9d4:	0e 94 3d a0 	call	0x1407a	; 0x1407a <__mulsf3>
    c9d8:	dc 01       	movw	r26, r24
    c9da:	cb 01       	movw	r24, r22
    c9dc:	88 87       	std	Y+8, r24	; 0x08
    c9de:	99 87       	std	Y+9, r25	; 0x09
    c9e0:	aa 87       	std	Y+10, r26	; 0x0a
    c9e2:	bb 87       	std	Y+11, r27	; 0x0b
    }
    read();  // consume the character we got with peek
    c9e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    c9e6:	9d 85       	ldd	r25, Y+13	; 0x0d
    c9e8:	fc 01       	movw	r30, r24
    c9ea:	80 81       	ld	r24, Z
    c9ec:	91 81       	ldd	r25, Z+1	; 0x01
    c9ee:	06 96       	adiw	r24, 0x06	; 6
    c9f0:	fc 01       	movw	r30, r24
    c9f2:	20 81       	ld	r18, Z
    c9f4:	31 81       	ldd	r19, Z+1	; 0x01
    c9f6:	8c 85       	ldd	r24, Y+12	; 0x0c
    c9f8:	9d 85       	ldd	r25, Y+13	; 0x0d
    c9fa:	f9 01       	movw	r30, r18
    c9fc:	09 95       	icall
    c = timedPeek();
    c9fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    ca00:	9d 85       	ldd	r25, Y+13	; 0x0d
    ca02:	0e 94 f6 61 	call	0xc3ec	; 0xc3ec <_ZN6Stream9timedPeekEv>
    ca06:	8f 83       	std	Y+7, r24	; 0x07
  c = peekNextDigit();
    // ignore non numeric leading characters
  if(c < 0)
    return 0; // zero returned if timeout

  do{
    ca08:	8f 81       	ldd	r24, Y+7	; 0x07
    ca0a:	80 33       	cpi	r24, 0x30	; 48
    ca0c:	18 f0       	brcs	.+6      	; 0xca14 <_ZN6Stream10parseFloatEc+0x110>
    ca0e:	8f 81       	ldd	r24, Y+7	; 0x07
    ca10:	8a 33       	cpi	r24, 0x3A	; 58
    ca12:	38 f0       	brcs	.+14     	; 0xca22 <_ZN6Stream10parseFloatEc+0x11e>
    ca14:	8f 81       	ldd	r24, Y+7	; 0x07
    ca16:	8e 32       	cpi	r24, 0x2E	; 46
    ca18:	21 f0       	breq	.+8      	; 0xca22 <_ZN6Stream10parseFloatEc+0x11e>
    ca1a:	9f 81       	ldd	r25, Y+7	; 0x07
    ca1c:	8e 85       	ldd	r24, Y+14	; 0x0e
    ca1e:	98 17       	cp	r25, r24
    ca20:	11 f4       	brne	.+4      	; 0xca26 <_ZN6Stream10parseFloatEc+0x122>
    ca22:	81 e0       	ldi	r24, 0x01	; 1
    ca24:	01 c0       	rjmp	.+2      	; 0xca28 <_ZN6Stream10parseFloatEc+0x124>
    ca26:	80 e0       	ldi	r24, 0x00	; 0
    ca28:	88 23       	and	r24, r24
    ca2a:	09 f0       	breq	.+2      	; 0xca2e <_ZN6Stream10parseFloatEc+0x12a>
    ca2c:	8b cf       	rjmp	.-234    	; 0xc944 <_ZN6Stream10parseFloatEc+0x40>
    read();  // consume the character we got with peek
    c = timedPeek();
  }
  while( (c >= '0' && c <= '9')  || c == '.' || c == skipChar );

  if(isNegative)
    ca2e:	89 81       	ldd	r24, Y+1	; 0x01
    ca30:	88 23       	and	r24, r24
    ca32:	79 f0       	breq	.+30     	; 0xca52 <_ZN6Stream10parseFloatEc+0x14e>
    value = -value;
    ca34:	8b 81       	ldd	r24, Y+3	; 0x03
    ca36:	9c 81       	ldd	r25, Y+4	; 0x04
    ca38:	ad 81       	ldd	r26, Y+5	; 0x05
    ca3a:	be 81       	ldd	r27, Y+6	; 0x06
    ca3c:	b0 95       	com	r27
    ca3e:	a0 95       	com	r26
    ca40:	90 95       	com	r25
    ca42:	81 95       	neg	r24
    ca44:	9f 4f       	sbci	r25, 0xFF	; 255
    ca46:	af 4f       	sbci	r26, 0xFF	; 255
    ca48:	bf 4f       	sbci	r27, 0xFF	; 255
    ca4a:	8b 83       	std	Y+3, r24	; 0x03
    ca4c:	9c 83       	std	Y+4, r25	; 0x04
    ca4e:	ad 83       	std	Y+5, r26	; 0x05
    ca50:	be 83       	std	Y+6, r27	; 0x06
  if(isFraction)
    ca52:	8a 81       	ldd	r24, Y+2	; 0x02
    ca54:	88 23       	and	r24, r24
    ca56:	99 f0       	breq	.+38     	; 0xca7e <_ZN6Stream10parseFloatEc+0x17a>
    return value * fraction;
    ca58:	6b 81       	ldd	r22, Y+3	; 0x03
    ca5a:	7c 81       	ldd	r23, Y+4	; 0x04
    ca5c:	8d 81       	ldd	r24, Y+5	; 0x05
    ca5e:	9e 81       	ldd	r25, Y+6	; 0x06
    ca60:	0e 94 ae a2 	call	0x1455c	; 0x1455c <__floatsisf>
    ca64:	dc 01       	movw	r26, r24
    ca66:	cb 01       	movw	r24, r22
    ca68:	28 85       	ldd	r18, Y+8	; 0x08
    ca6a:	39 85       	ldd	r19, Y+9	; 0x09
    ca6c:	4a 85       	ldd	r20, Y+10	; 0x0a
    ca6e:	5b 85       	ldd	r21, Y+11	; 0x0b
    ca70:	bc 01       	movw	r22, r24
    ca72:	cd 01       	movw	r24, r26
    ca74:	0e 94 3d a0 	call	0x1407a	; 0x1407a <__mulsf3>
    ca78:	dc 01       	movw	r26, r24
    ca7a:	cb 01       	movw	r24, r22
    ca7c:	08 c0       	rjmp	.+16     	; 0xca8e <_ZN6Stream10parseFloatEc+0x18a>
  else
    return value;
    ca7e:	6b 81       	ldd	r22, Y+3	; 0x03
    ca80:	7c 81       	ldd	r23, Y+4	; 0x04
    ca82:	8d 81       	ldd	r24, Y+5	; 0x05
    ca84:	9e 81       	ldd	r25, Y+6	; 0x06
    ca86:	0e 94 ae a2 	call	0x1455c	; 0x1455c <__floatsisf>
    ca8a:	dc 01       	movw	r26, r24
    ca8c:	cb 01       	movw	r24, r22
}
    ca8e:	bc 01       	movw	r22, r24
    ca90:	cd 01       	movw	r24, r26
    ca92:	2e 96       	adiw	r28, 0x0e	; 14
    ca94:	0f b6       	in	r0, 0x3f	; 63
    ca96:	f8 94       	cli
    ca98:	de bf       	out	0x3e, r29	; 62
    ca9a:	0f be       	out	0x3f, r0	; 63
    ca9c:	cd bf       	out	0x3d, r28	; 61
    ca9e:	df 91       	pop	r29
    caa0:	cf 91       	pop	r28
    caa2:	08 95       	ret

0000caa4 <_ZN6Stream9readBytesEPcj>:
// terminates if length characters have been read, or timeout (see setTimeout)
// returns the number of characters placed in the buffer
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
    caa4:	cf 93       	push	r28
    caa6:	df 93       	push	r29
    caa8:	cd b7       	in	r28, 0x3d	; 61
    caaa:	de b7       	in	r29, 0x3e	; 62
    caac:	2a 97       	sbiw	r28, 0x0a	; 10
    caae:	0f b6       	in	r0, 0x3f	; 63
    cab0:	f8 94       	cli
    cab2:	de bf       	out	0x3e, r29	; 62
    cab4:	0f be       	out	0x3f, r0	; 63
    cab6:	cd bf       	out	0x3d, r28	; 61
    cab8:	9e 83       	std	Y+6, r25	; 0x06
    caba:	8d 83       	std	Y+5, r24	; 0x05
    cabc:	78 87       	std	Y+8, r23	; 0x08
    cabe:	6f 83       	std	Y+7, r22	; 0x07
    cac0:	5a 87       	std	Y+10, r21	; 0x0a
    cac2:	49 87       	std	Y+9, r20	; 0x09
  size_t count = 0;
    cac4:	1a 82       	std	Y+2, r1	; 0x02
    cac6:	19 82       	std	Y+1, r1	; 0x01
  while (count < length) {
    cac8:	19 c0       	rjmp	.+50     	; 0xcafc <_ZN6Stream9readBytesEPcj+0x58>
    int c = timedRead();
    caca:	8d 81       	ldd	r24, Y+5	; 0x05
    cacc:	9e 81       	ldd	r25, Y+6	; 0x06
    cace:	0e 94 a5 61 	call	0xc34a	; 0xc34a <_ZN6Stream9timedReadEv>
    cad2:	9c 83       	std	Y+4, r25	; 0x04
    cad4:	8b 83       	std	Y+3, r24	; 0x03
    if (c < 0) break;
    cad6:	8b 81       	ldd	r24, Y+3	; 0x03
    cad8:	9c 81       	ldd	r25, Y+4	; 0x04
    cada:	99 23       	and	r25, r25
    cadc:	dc f0       	brlt	.+54     	; 0xcb14 <_ZN6Stream9readBytesEPcj+0x70>
    *buffer++ = (char)c;
    cade:	2b 81       	ldd	r18, Y+3	; 0x03
    cae0:	8f 81       	ldd	r24, Y+7	; 0x07
    cae2:	98 85       	ldd	r25, Y+8	; 0x08
    cae4:	fc 01       	movw	r30, r24
    cae6:	20 83       	st	Z, r18
    cae8:	8f 81       	ldd	r24, Y+7	; 0x07
    caea:	98 85       	ldd	r25, Y+8	; 0x08
    caec:	01 96       	adiw	r24, 0x01	; 1
    caee:	98 87       	std	Y+8, r25	; 0x08
    caf0:	8f 83       	std	Y+7, r24	; 0x07
    count++;
    caf2:	89 81       	ldd	r24, Y+1	; 0x01
    caf4:	9a 81       	ldd	r25, Y+2	; 0x02
    caf6:	01 96       	adiw	r24, 0x01	; 1
    caf8:	9a 83       	std	Y+2, r25	; 0x02
    cafa:	89 83       	std	Y+1, r24	; 0x01
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
  size_t count = 0;
  while (count < length) {
    cafc:	41 e0       	ldi	r20, 0x01	; 1
    cafe:	29 81       	ldd	r18, Y+1	; 0x01
    cb00:	3a 81       	ldd	r19, Y+2	; 0x02
    cb02:	89 85       	ldd	r24, Y+9	; 0x09
    cb04:	9a 85       	ldd	r25, Y+10	; 0x0a
    cb06:	28 17       	cp	r18, r24
    cb08:	39 07       	cpc	r19, r25
    cb0a:	08 f0       	brcs	.+2      	; 0xcb0e <_ZN6Stream9readBytesEPcj+0x6a>
    cb0c:	40 e0       	ldi	r20, 0x00	; 0
    cb0e:	44 23       	and	r20, r20
    cb10:	e1 f6       	brne	.-72     	; 0xcaca <_ZN6Stream9readBytesEPcj+0x26>
    cb12:	01 c0       	rjmp	.+2      	; 0xcb16 <_ZN6Stream9readBytesEPcj+0x72>
    int c = timedRead();
    if (c < 0) break;
    cb14:	00 00       	nop
    *buffer++ = (char)c;
    count++;
  }
  return count;
    cb16:	89 81       	ldd	r24, Y+1	; 0x01
    cb18:	9a 81       	ldd	r25, Y+2	; 0x02
}
    cb1a:	2a 96       	adiw	r28, 0x0a	; 10
    cb1c:	0f b6       	in	r0, 0x3f	; 63
    cb1e:	f8 94       	cli
    cb20:	de bf       	out	0x3e, r29	; 62
    cb22:	0f be       	out	0x3f, r0	; 63
    cb24:	cd bf       	out	0x3d, r28	; 61
    cb26:	df 91       	pop	r29
    cb28:	cf 91       	pop	r28
    cb2a:	08 95       	ret

0000cb2c <_ZN6Stream14readBytesUntilEcPcj>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    cb2c:	cf 93       	push	r28
    cb2e:	df 93       	push	r29
    cb30:	cd b7       	in	r28, 0x3d	; 61
    cb32:	de b7       	in	r29, 0x3e	; 62
    cb34:	2b 97       	sbiw	r28, 0x0b	; 11
    cb36:	0f b6       	in	r0, 0x3f	; 63
    cb38:	f8 94       	cli
    cb3a:	de bf       	out	0x3e, r29	; 62
    cb3c:	0f be       	out	0x3f, r0	; 63
    cb3e:	cd bf       	out	0x3d, r28	; 61
    cb40:	9e 83       	std	Y+6, r25	; 0x06
    cb42:	8d 83       	std	Y+5, r24	; 0x05
    cb44:	6f 83       	std	Y+7, r22	; 0x07
    cb46:	59 87       	std	Y+9, r21	; 0x09
    cb48:	48 87       	std	Y+8, r20	; 0x08
    cb4a:	3b 87       	std	Y+11, r19	; 0x0b
    cb4c:	2a 87       	std	Y+10, r18	; 0x0a
  if (length < 1) return 0;
    cb4e:	8a 85       	ldd	r24, Y+10	; 0x0a
    cb50:	9b 85       	ldd	r25, Y+11	; 0x0b
    cb52:	00 97       	sbiw	r24, 0x00	; 0
    cb54:	19 f4       	brne	.+6      	; 0xcb5c <_ZN6Stream14readBytesUntilEcPcj+0x30>
    cb56:	80 e0       	ldi	r24, 0x00	; 0
    cb58:	90 e0       	ldi	r25, 0x00	; 0
    cb5a:	33 c0       	rjmp	.+102    	; 0xcbc2 <_ZN6Stream14readBytesUntilEcPcj+0x96>
  size_t index = 0;
    cb5c:	1a 82       	std	Y+2, r1	; 0x02
    cb5e:	19 82       	std	Y+1, r1	; 0x01
  while (index < length) {
    cb60:	21 c0       	rjmp	.+66     	; 0xcba4 <_ZN6Stream14readBytesUntilEcPcj+0x78>
    int c = timedRead();
    cb62:	8d 81       	ldd	r24, Y+5	; 0x05
    cb64:	9e 81       	ldd	r25, Y+6	; 0x06
    cb66:	0e 94 a5 61 	call	0xc34a	; 0xc34a <_ZN6Stream9timedReadEv>
    cb6a:	9c 83       	std	Y+4, r25	; 0x04
    cb6c:	8b 83       	std	Y+3, r24	; 0x03
    if (c < 0 || c == terminator) break;
    cb6e:	8b 81       	ldd	r24, Y+3	; 0x03
    cb70:	9c 81       	ldd	r25, Y+4	; 0x04
    cb72:	99 23       	and	r25, r25
    cb74:	1c f1       	brlt	.+70     	; 0xcbbc <_ZN6Stream14readBytesUntilEcPcj+0x90>
    cb76:	8f 81       	ldd	r24, Y+7	; 0x07
    cb78:	28 2f       	mov	r18, r24
    cb7a:	30 e0       	ldi	r19, 0x00	; 0
    cb7c:	8b 81       	ldd	r24, Y+3	; 0x03
    cb7e:	9c 81       	ldd	r25, Y+4	; 0x04
    cb80:	28 17       	cp	r18, r24
    cb82:	39 07       	cpc	r19, r25
    cb84:	d9 f0       	breq	.+54     	; 0xcbbc <_ZN6Stream14readBytesUntilEcPcj+0x90>
    *buffer++ = (char)c;
    cb86:	2b 81       	ldd	r18, Y+3	; 0x03
    cb88:	88 85       	ldd	r24, Y+8	; 0x08
    cb8a:	99 85       	ldd	r25, Y+9	; 0x09
    cb8c:	fc 01       	movw	r30, r24
    cb8e:	20 83       	st	Z, r18
    cb90:	88 85       	ldd	r24, Y+8	; 0x08
    cb92:	99 85       	ldd	r25, Y+9	; 0x09
    cb94:	01 96       	adiw	r24, 0x01	; 1
    cb96:	99 87       	std	Y+9, r25	; 0x09
    cb98:	88 87       	std	Y+8, r24	; 0x08
    index++;
    cb9a:	89 81       	ldd	r24, Y+1	; 0x01
    cb9c:	9a 81       	ldd	r25, Y+2	; 0x02
    cb9e:	01 96       	adiw	r24, 0x01	; 1
    cba0:	9a 83       	std	Y+2, r25	; 0x02
    cba2:	89 83       	std	Y+1, r24	; 0x01

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
  if (length < 1) return 0;
  size_t index = 0;
  while (index < length) {
    cba4:	41 e0       	ldi	r20, 0x01	; 1
    cba6:	29 81       	ldd	r18, Y+1	; 0x01
    cba8:	3a 81       	ldd	r19, Y+2	; 0x02
    cbaa:	8a 85       	ldd	r24, Y+10	; 0x0a
    cbac:	9b 85       	ldd	r25, Y+11	; 0x0b
    cbae:	28 17       	cp	r18, r24
    cbb0:	39 07       	cpc	r19, r25
    cbb2:	08 f0       	brcs	.+2      	; 0xcbb6 <_ZN6Stream14readBytesUntilEcPcj+0x8a>
    cbb4:	40 e0       	ldi	r20, 0x00	; 0
    cbb6:	44 23       	and	r20, r20
    cbb8:	a1 f6       	brne	.-88     	; 0xcb62 <_ZN6Stream14readBytesUntilEcPcj+0x36>
    cbba:	01 c0       	rjmp	.+2      	; 0xcbbe <_ZN6Stream14readBytesUntilEcPcj+0x92>
    int c = timedRead();
    if (c < 0 || c == terminator) break;
    cbbc:	00 00       	nop
    *buffer++ = (char)c;
    index++;
  }
  return index; // return number of characters, not including null terminator
    cbbe:	89 81       	ldd	r24, Y+1	; 0x01
    cbc0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    cbc2:	2b 96       	adiw	r28, 0x0b	; 11
    cbc4:	0f b6       	in	r0, 0x3f	; 63
    cbc6:	f8 94       	cli
    cbc8:	de bf       	out	0x3e, r29	; 62
    cbca:	0f be       	out	0x3f, r0	; 63
    cbcc:	cd bf       	out	0x3d, r28	; 61
    cbce:	df 91       	pop	r29
    cbd0:	cf 91       	pop	r28
    cbd2:	08 95       	ret

0000cbd4 <_ZN6Stream10readStringEv>:

String Stream::readString()
{
    cbd4:	cf 93       	push	r28
    cbd6:	df 93       	push	r29
    cbd8:	00 d0       	rcall	.+0      	; 0xcbda <_ZN6Stream10readStringEv+0x6>
    cbda:	00 d0       	rcall	.+0      	; 0xcbdc <_ZN6Stream10readStringEv+0x8>
    cbdc:	00 d0       	rcall	.+0      	; 0xcbde <_ZN6Stream10readStringEv+0xa>
    cbde:	cd b7       	in	r28, 0x3d	; 61
    cbe0:	de b7       	in	r29, 0x3e	; 62
    cbe2:	9c 83       	std	Y+4, r25	; 0x04
    cbe4:	8b 83       	std	Y+3, r24	; 0x03
    cbe6:	7e 83       	std	Y+6, r23	; 0x06
    cbe8:	6d 83       	std	Y+5, r22	; 0x05
  String ret;
    cbea:	8b 81       	ldd	r24, Y+3	; 0x03
    cbec:	9c 81       	ldd	r25, Y+4	; 0x04
    cbee:	67 ef       	ldi	r22, 0xF7	; 247
    cbf0:	73 e0       	ldi	r23, 0x03	; 3
    cbf2:	0e 94 3a 6d 	call	0xda74	; 0xda74 <_ZN6StringC1EPKc>
  int c = timedRead();
    cbf6:	8d 81       	ldd	r24, Y+5	; 0x05
    cbf8:	9e 81       	ldd	r25, Y+6	; 0x06
    cbfa:	0e 94 a5 61 	call	0xc34a	; 0xc34a <_ZN6Stream9timedReadEv>
    cbfe:	9a 83       	std	Y+2, r25	; 0x02
    cc00:	89 83       	std	Y+1, r24	; 0x01
  while (c >= 0)
    cc02:	0c c0       	rjmp	.+24     	; 0xcc1c <_ZN6Stream10readStringEv+0x48>
  {
    ret += (char)c;
    cc04:	29 81       	ldd	r18, Y+1	; 0x01
    cc06:	8b 81       	ldd	r24, Y+3	; 0x03
    cc08:	9c 81       	ldd	r25, Y+4	; 0x04
    cc0a:	62 2f       	mov	r22, r18
    cc0c:	0e 94 49 ad 	call	0x15a92	; 0x15a92 <_ZN6StringpLEc>
    c = timedRead();
    cc10:	8d 81       	ldd	r24, Y+5	; 0x05
    cc12:	9e 81       	ldd	r25, Y+6	; 0x06
    cc14:	0e 94 a5 61 	call	0xc34a	; 0xc34a <_ZN6Stream9timedReadEv>
    cc18:	9a 83       	std	Y+2, r25	; 0x02
    cc1a:	89 83       	std	Y+1, r24	; 0x01

String Stream::readString()
{
  String ret;
  int c = timedRead();
  while (c >= 0)
    cc1c:	8a 81       	ldd	r24, Y+2	; 0x02
    cc1e:	80 95       	com	r24
    cc20:	88 1f       	adc	r24, r24
    cc22:	88 27       	eor	r24, r24
    cc24:	88 1f       	adc	r24, r24
    cc26:	88 23       	and	r24, r24
    cc28:	69 f7       	brne	.-38     	; 0xcc04 <_ZN6Stream10readStringEv+0x30>
  {
    ret += (char)c;
    c = timedRead();
  }
  return ret;
    cc2a:	00 00       	nop
}
    cc2c:	8b 81       	ldd	r24, Y+3	; 0x03
    cc2e:	9c 81       	ldd	r25, Y+4	; 0x04
    cc30:	26 96       	adiw	r28, 0x06	; 6
    cc32:	0f b6       	in	r0, 0x3f	; 63
    cc34:	f8 94       	cli
    cc36:	de bf       	out	0x3e, r29	; 62
    cc38:	0f be       	out	0x3f, r0	; 63
    cc3a:	cd bf       	out	0x3d, r28	; 61
    cc3c:	df 91       	pop	r29
    cc3e:	cf 91       	pop	r28
    cc40:	08 95       	ret

0000cc42 <_ZN6Stream15readStringUntilEc>:

String Stream::readStringUntil(char terminator)
{
    cc42:	cf 93       	push	r28
    cc44:	df 93       	push	r29
    cc46:	cd b7       	in	r28, 0x3d	; 61
    cc48:	de b7       	in	r29, 0x3e	; 62
    cc4a:	27 97       	sbiw	r28, 0x07	; 7
    cc4c:	0f b6       	in	r0, 0x3f	; 63
    cc4e:	f8 94       	cli
    cc50:	de bf       	out	0x3e, r29	; 62
    cc52:	0f be       	out	0x3f, r0	; 63
    cc54:	cd bf       	out	0x3d, r28	; 61
    cc56:	9c 83       	std	Y+4, r25	; 0x04
    cc58:	8b 83       	std	Y+3, r24	; 0x03
    cc5a:	7e 83       	std	Y+6, r23	; 0x06
    cc5c:	6d 83       	std	Y+5, r22	; 0x05
    cc5e:	4f 83       	std	Y+7, r20	; 0x07
  String ret;
    cc60:	8b 81       	ldd	r24, Y+3	; 0x03
    cc62:	9c 81       	ldd	r25, Y+4	; 0x04
    cc64:	67 ef       	ldi	r22, 0xF7	; 247
    cc66:	73 e0       	ldi	r23, 0x03	; 3
    cc68:	0e 94 3a 6d 	call	0xda74	; 0xda74 <_ZN6StringC1EPKc>
  int c = timedRead();
    cc6c:	8d 81       	ldd	r24, Y+5	; 0x05
    cc6e:	9e 81       	ldd	r25, Y+6	; 0x06
    cc70:	0e 94 a5 61 	call	0xc34a	; 0xc34a <_ZN6Stream9timedReadEv>
    cc74:	9a 83       	std	Y+2, r25	; 0x02
    cc76:	89 83       	std	Y+1, r24	; 0x01
  while (c >= 0 && c != terminator)
    cc78:	0c c0       	rjmp	.+24     	; 0xcc92 <_ZN6Stream15readStringUntilEc+0x50>
  {
    ret += (char)c;
    cc7a:	29 81       	ldd	r18, Y+1	; 0x01
    cc7c:	8b 81       	ldd	r24, Y+3	; 0x03
    cc7e:	9c 81       	ldd	r25, Y+4	; 0x04
    cc80:	62 2f       	mov	r22, r18
    cc82:	0e 94 49 ad 	call	0x15a92	; 0x15a92 <_ZN6StringpLEc>
    c = timedRead();
    cc86:	8d 81       	ldd	r24, Y+5	; 0x05
    cc88:	9e 81       	ldd	r25, Y+6	; 0x06
    cc8a:	0e 94 a5 61 	call	0xc34a	; 0xc34a <_ZN6Stream9timedReadEv>
    cc8e:	9a 83       	std	Y+2, r25	; 0x02
    cc90:	89 83       	std	Y+1, r24	; 0x01

String Stream::readStringUntil(char terminator)
{
  String ret;
  int c = timedRead();
  while (c >= 0 && c != terminator)
    cc92:	89 81       	ldd	r24, Y+1	; 0x01
    cc94:	9a 81       	ldd	r25, Y+2	; 0x02
    cc96:	99 23       	and	r25, r25
    cc98:	54 f0       	brlt	.+20     	; 0xccae <_ZN6Stream15readStringUntilEc+0x6c>
    cc9a:	8f 81       	ldd	r24, Y+7	; 0x07
    cc9c:	28 2f       	mov	r18, r24
    cc9e:	30 e0       	ldi	r19, 0x00	; 0
    cca0:	89 81       	ldd	r24, Y+1	; 0x01
    cca2:	9a 81       	ldd	r25, Y+2	; 0x02
    cca4:	28 17       	cp	r18, r24
    cca6:	39 07       	cpc	r19, r25
    cca8:	11 f0       	breq	.+4      	; 0xccae <_ZN6Stream15readStringUntilEc+0x6c>
    ccaa:	81 e0       	ldi	r24, 0x01	; 1
    ccac:	01 c0       	rjmp	.+2      	; 0xccb0 <_ZN6Stream15readStringUntilEc+0x6e>
    ccae:	80 e0       	ldi	r24, 0x00	; 0
    ccb0:	88 23       	and	r24, r24
    ccb2:	19 f7       	brne	.-58     	; 0xcc7a <_ZN6Stream15readStringUntilEc+0x38>
  {
    ret += (char)c;
    c = timedRead();
  }
  return ret;
    ccb4:	00 00       	nop
}
    ccb6:	8b 81       	ldd	r24, Y+3	; 0x03
    ccb8:	9c 81       	ldd	r25, Y+4	; 0x04
    ccba:	27 96       	adiw	r28, 0x07	; 7
    ccbc:	0f b6       	in	r0, 0x3f	; 63
    ccbe:	f8 94       	cli
    ccc0:	de bf       	out	0x3e, r29	; 62
    ccc2:	0f be       	out	0x3f, r0	; 63
    ccc4:	cd bf       	out	0x3d, r28	; 61
    ccc6:	df 91       	pop	r29
    ccc8:	cf 91       	pop	r28
    ccca:	08 95       	ret

0000cccc <_ZL9toneBeginh>:
#endif



static int8_t toneBegin(uint8_t _pin)
{
    cccc:	ef 92       	push	r14
    ccce:	ff 92       	push	r15
    ccd0:	0f 93       	push	r16
    ccd2:	1f 93       	push	r17
    ccd4:	cf 93       	push	r28
    ccd6:	df 93       	push	r29
    ccd8:	cd b7       	in	r28, 0x3d	; 61
    ccda:	de b7       	in	r29, 0x3e	; 62
    ccdc:	aa 97       	sbiw	r28, 0x2a	; 42
    ccde:	0f b6       	in	r0, 0x3f	; 63
    cce0:	f8 94       	cli
    cce2:	de bf       	out	0x3e, r29	; 62
    cce4:	0f be       	out	0x3f, r0	; 63
    cce6:	cd bf       	out	0x3d, r28	; 61
    cce8:	8a a7       	std	Y+42, r24	; 0x2a
  int8_t _timer = -1;
    ccea:	8f ef       	ldi	r24, 0xFF	; 255
    ccec:	89 83       	std	Y+1, r24	; 0x01

  // if we're already using the pin, the timer should be configured.  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    ccee:	1b 82       	std	Y+3, r1	; 0x03
    ccf0:	1a 82       	std	Y+2, r1	; 0x02
    ccf2:	1b c0       	rjmp	.+54     	; 0xcd2a <_ZL9toneBeginh+0x5e>
    if (tone_pins[i] == _pin) {
    ccf4:	8a 81       	ldd	r24, Y+2	; 0x02
    ccf6:	9b 81       	ldd	r25, Y+3	; 0x03
    ccf8:	8c 5b       	subi	r24, 0xBC	; 188
    ccfa:	9d 4f       	sbci	r25, 0xFD	; 253
    ccfc:	fc 01       	movw	r30, r24
    ccfe:	90 81       	ld	r25, Z
    cd00:	8a a5       	ldd	r24, Y+42	; 0x2a
    cd02:	98 17       	cp	r25, r24
    cd04:	69 f4       	brne	.+26     	; 0xcd20 <_ZL9toneBeginh+0x54>
      return pgm_read_byte(tone_pin_to_timer_PGM + i);
    cd06:	8a 81       	ldd	r24, Y+2	; 0x02
    cd08:	9b 81       	ldd	r25, Y+3	; 0x03
    cd0a:	86 5a       	subi	r24, 0xA6	; 166
    cd0c:	9d 4f       	sbci	r25, 0xFD	; 253
    cd0e:	9f 83       	std	Y+7, r25	; 0x07
    cd10:	8e 83       	std	Y+6, r24	; 0x06
    cd12:	8e 81       	ldd	r24, Y+6	; 0x06
    cd14:	9f 81       	ldd	r25, Y+7	; 0x07
    cd16:	fc 01       	movw	r30, r24
    cd18:	14 91       	lpm	r17, Z
    cd1a:	18 87       	std	Y+8, r17	; 0x08
    cd1c:	88 85       	ldd	r24, Y+8	; 0x08
    cd1e:	40 c1       	rjmp	.+640    	; 0xcfa0 <_ZL9toneBeginh+0x2d4>
static int8_t toneBegin(uint8_t _pin)
{
  int8_t _timer = -1;

  // if we're already using the pin, the timer should be configured.  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    cd20:	8a 81       	ldd	r24, Y+2	; 0x02
    cd22:	9b 81       	ldd	r25, Y+3	; 0x03
    cd24:	01 96       	adiw	r24, 0x01	; 1
    cd26:	9b 83       	std	Y+3, r25	; 0x03
    cd28:	8a 83       	std	Y+2, r24	; 0x02
    cd2a:	21 e0       	ldi	r18, 0x01	; 1
    cd2c:	8a 81       	ldd	r24, Y+2	; 0x02
    cd2e:	9b 81       	ldd	r25, Y+3	; 0x03
    cd30:	18 16       	cp	r1, r24
    cd32:	19 06       	cpc	r1, r25
    cd34:	0c f4       	brge	.+2      	; 0xcd38 <_ZL9toneBeginh+0x6c>
    cd36:	20 e0       	ldi	r18, 0x00	; 0
    cd38:	22 23       	and	r18, r18
    cd3a:	e1 f6       	brne	.-72     	; 0xccf4 <_ZL9toneBeginh+0x28>
      return pgm_read_byte(tone_pin_to_timer_PGM + i);
    }
  }
  
  // search for an unused timer.
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    cd3c:	1d 82       	std	Y+5, r1	; 0x05
    cd3e:	1c 82       	std	Y+4, r1	; 0x04
    cd40:	22 c0       	rjmp	.+68     	; 0xcd86 <_ZL9toneBeginh+0xba>
    if (tone_pins[i] == 255) {
    cd42:	8c 81       	ldd	r24, Y+4	; 0x04
    cd44:	9d 81       	ldd	r25, Y+5	; 0x05
    cd46:	8c 5b       	subi	r24, 0xBC	; 188
    cd48:	9d 4f       	sbci	r25, 0xFD	; 253
    cd4a:	fc 01       	movw	r30, r24
    cd4c:	80 81       	ld	r24, Z
    cd4e:	8f 3f       	cpi	r24, 0xFF	; 255
    cd50:	a9 f4       	brne	.+42     	; 0xcd7c <_ZL9toneBeginh+0xb0>
      tone_pins[i] = _pin;
    cd52:	8c 81       	ldd	r24, Y+4	; 0x04
    cd54:	9d 81       	ldd	r25, Y+5	; 0x05
    cd56:	8c 5b       	subi	r24, 0xBC	; 188
    cd58:	9d 4f       	sbci	r25, 0xFD	; 253
    cd5a:	2a a5       	ldd	r18, Y+42	; 0x2a
    cd5c:	fc 01       	movw	r30, r24
    cd5e:	20 83       	st	Z, r18
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
    cd60:	8c 81       	ldd	r24, Y+4	; 0x04
    cd62:	9d 81       	ldd	r25, Y+5	; 0x05
    cd64:	86 5a       	subi	r24, 0xA6	; 166
    cd66:	9d 4f       	sbci	r25, 0xFD	; 253
    cd68:	9a 87       	std	Y+10, r25	; 0x0a
    cd6a:	89 87       	std	Y+9, r24	; 0x09
    cd6c:	89 85       	ldd	r24, Y+9	; 0x09
    cd6e:	9a 85       	ldd	r25, Y+10	; 0x0a
    cd70:	fc 01       	movw	r30, r24
    cd72:	14 91       	lpm	r17, Z
    cd74:	1b 87       	std	Y+11, r17	; 0x0b
    cd76:	8b 85       	ldd	r24, Y+11	; 0x0b
    cd78:	89 83       	std	Y+1, r24	; 0x01
      break;
    cd7a:	0e c0       	rjmp	.+28     	; 0xcd98 <_ZL9toneBeginh+0xcc>
      return pgm_read_byte(tone_pin_to_timer_PGM + i);
    }
  }
  
  // search for an unused timer.
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    cd7c:	8c 81       	ldd	r24, Y+4	; 0x04
    cd7e:	9d 81       	ldd	r25, Y+5	; 0x05
    cd80:	01 96       	adiw	r24, 0x01	; 1
    cd82:	9d 83       	std	Y+5, r25	; 0x05
    cd84:	8c 83       	std	Y+4, r24	; 0x04
    cd86:	21 e0       	ldi	r18, 0x01	; 1
    cd88:	8c 81       	ldd	r24, Y+4	; 0x04
    cd8a:	9d 81       	ldd	r25, Y+5	; 0x05
    cd8c:	18 16       	cp	r1, r24
    cd8e:	19 06       	cpc	r1, r25
    cd90:	0c f4       	brge	.+2      	; 0xcd94 <_ZL9toneBeginh+0xc8>
    cd92:	20 e0       	ldi	r18, 0x00	; 0
    cd94:	22 23       	and	r18, r18
    cd96:	a9 f6       	brne	.-86     	; 0xcd42 <_ZL9toneBeginh+0x76>
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
      break;
    }
  }
  
  if (_timer != -1)
    cd98:	89 81       	ldd	r24, Y+1	; 0x01
    cd9a:	8f 3f       	cpi	r24, 0xFF	; 255
    cd9c:	09 f4       	brne	.+2      	; 0xcda0 <_ZL9toneBeginh+0xd4>
    cd9e:	ff c0       	rjmp	.+510    	; 0xcf9e <_ZL9toneBeginh+0x2d2>
  {
    // Set timer specific stuff
    // All timers in CTC mode
    // 8 bit timers will require changing prescalar values,
    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
    switch (_timer)
    cda0:	89 81       	ldd	r24, Y+1	; 0x01
    cda2:	99 27       	eor	r25, r25
    cda4:	87 fd       	sbrc	r24, 7
    cda6:	90 95       	com	r25
    cda8:	81 30       	cpi	r24, 0x01	; 1
    cdaa:	91 05       	cpc	r25, r1
    cdac:	09 f4       	brne	.+2      	; 0xcdb0 <_ZL9toneBeginh+0xe4>
    cdae:	57 c0       	rjmp	.+174    	; 0xce5e <_ZL9toneBeginh+0x192>
    cdb0:	82 30       	cpi	r24, 0x02	; 2
    cdb2:	91 05       	cpc	r25, r1
    cdb4:	09 f4       	brne	.+2      	; 0xcdb8 <_ZL9toneBeginh+0xec>
    cdb6:	a3 c0       	rjmp	.+326    	; 0xcefe <_ZL9toneBeginh+0x232>
    cdb8:	00 97       	sbiw	r24, 0x00	; 0
    cdba:	09 f0       	breq	.+2      	; 0xcdbe <_ZL9toneBeginh+0xf2>
    cdbc:	f0 c0       	rjmp	.+480    	; 0xcf9e <_ZL9toneBeginh+0x2d2>
    {
      #if defined(TCCR0A) && defined(TCCR0B)
      case 0:
        // 8 bit timer
        TCCR0A = 0;
    cdbe:	84 e4       	ldi	r24, 0x44	; 68
    cdc0:	90 e0       	ldi	r25, 0x00	; 0
    cdc2:	fc 01       	movw	r30, r24
    cdc4:	10 82       	st	Z, r1
        TCCR0B = 0;
    cdc6:	85 e4       	ldi	r24, 0x45	; 69
    cdc8:	90 e0       	ldi	r25, 0x00	; 0
    cdca:	fc 01       	movw	r30, r24
    cdcc:	10 82       	st	Z, r1
        bitWrite(TCCR0A, WGM01, 1);
    cdce:	84 e4       	ldi	r24, 0x44	; 68
    cdd0:	90 e0       	ldi	r25, 0x00	; 0
    cdd2:	24 e4       	ldi	r18, 0x44	; 68
    cdd4:	30 e0       	ldi	r19, 0x00	; 0
    cdd6:	f9 01       	movw	r30, r18
    cdd8:	20 81       	ld	r18, Z
    cdda:	22 60       	ori	r18, 0x02	; 2
    cddc:	fc 01       	movw	r30, r24
    cdde:	20 83       	st	Z, r18
        bitWrite(TCCR0B, CS00, 1);
    cde0:	85 e4       	ldi	r24, 0x45	; 69
    cde2:	90 e0       	ldi	r25, 0x00	; 0
    cde4:	25 e4       	ldi	r18, 0x45	; 69
    cde6:	30 e0       	ldi	r19, 0x00	; 0
    cde8:	f9 01       	movw	r30, r18
    cdea:	20 81       	ld	r18, Z
    cdec:	21 60       	ori	r18, 0x01	; 1
    cdee:	fc 01       	movw	r30, r24
    cdf0:	20 83       	st	Z, r18
        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
    cdf2:	8a a5       	ldd	r24, Y+42	; 0x2a
    cdf4:	88 2f       	mov	r24, r24
    cdf6:	90 e0       	ldi	r25, 0x00	; 0
    cdf8:	87 58       	subi	r24, 0x87	; 135
    cdfa:	9d 4f       	sbci	r25, 0xFD	; 253
    cdfc:	9d 87       	std	Y+13, r25	; 0x0d
    cdfe:	8c 87       	std	Y+12, r24	; 0x0c
    ce00:	8c 85       	ldd	r24, Y+12	; 0x0c
    ce02:	9d 85       	ldd	r25, Y+13	; 0x0d
    ce04:	fc 01       	movw	r30, r24
    ce06:	14 91       	lpm	r17, Z
    ce08:	1e 87       	std	Y+14, r17	; 0x0e
    ce0a:	8e 85       	ldd	r24, Y+14	; 0x0e
    ce0c:	88 2f       	mov	r24, r24
    ce0e:	90 e0       	ldi	r25, 0x00	; 0
    ce10:	88 0f       	add	r24, r24
    ce12:	99 1f       	adc	r25, r25
    ce14:	8b 59       	subi	r24, 0x9B	; 155
    ce16:	9d 4f       	sbci	r25, 0xFD	; 253
    ce18:	98 8b       	std	Y+16, r25	; 0x10
    ce1a:	8f 87       	std	Y+15, r24	; 0x0f
    ce1c:	8f 85       	ldd	r24, Y+15	; 0x0f
    ce1e:	98 89       	ldd	r25, Y+16	; 0x10
    ce20:	8c 01       	movw	r16, r24
    ce22:	f8 01       	movw	r30, r16
    ce24:	e5 90       	lpm	r14, Z+
    ce26:	f4 90       	lpm	r15, Z
    ce28:	8f 01       	movw	r16, r30
    ce2a:	fa 8a       	std	Y+18, r15	; 0x12
    ce2c:	e9 8a       	std	Y+17, r14	; 0x11
    ce2e:	18 8b       	std	Y+16, r17	; 0x10
    ce30:	0f 87       	std	Y+15, r16	; 0x0f
    ce32:	89 89       	ldd	r24, Y+17	; 0x11
    ce34:	9a 89       	ldd	r25, Y+18	; 0x12
    ce36:	90 93 f4 08 	sts	0x08F4, r25
    ce3a:	80 93 f3 08 	sts	0x08F3, r24
        timer0_pin_mask = digitalPinToBitMask(_pin);
    ce3e:	8a a5       	ldd	r24, Y+42	; 0x2a
    ce40:	88 2f       	mov	r24, r24
    ce42:	90 e0       	ldi	r25, 0x00	; 0
    ce44:	83 57       	subi	r24, 0x73	; 115
    ce46:	9d 4f       	sbci	r25, 0xFD	; 253
    ce48:	9c 8b       	std	Y+20, r25	; 0x14
    ce4a:	8b 8b       	std	Y+19, r24	; 0x13
    ce4c:	8b 89       	ldd	r24, Y+19	; 0x13
    ce4e:	9c 89       	ldd	r25, Y+20	; 0x14
    ce50:	fc 01       	movw	r30, r24
    ce52:	14 91       	lpm	r17, Z
    ce54:	1d 8b       	std	Y+21, r17	; 0x15
    ce56:	8d 89       	ldd	r24, Y+21	; 0x15
    ce58:	80 93 f5 08 	sts	0x08F5, r24
        break;
    ce5c:	a0 c0       	rjmp	.+320    	; 0xcf9e <_ZL9toneBeginh+0x2d2>
      #endif

      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
      case 1:
        // 16 bit timer
        TCCR1A = 0;
    ce5e:	80 e8       	ldi	r24, 0x80	; 128
    ce60:	90 e0       	ldi	r25, 0x00	; 0
    ce62:	fc 01       	movw	r30, r24
    ce64:	10 82       	st	Z, r1
        TCCR1B = 0;
    ce66:	81 e8       	ldi	r24, 0x81	; 129
    ce68:	90 e0       	ldi	r25, 0x00	; 0
    ce6a:	fc 01       	movw	r30, r24
    ce6c:	10 82       	st	Z, r1
        bitWrite(TCCR1B, WGM12, 1);
    ce6e:	81 e8       	ldi	r24, 0x81	; 129
    ce70:	90 e0       	ldi	r25, 0x00	; 0
    ce72:	21 e8       	ldi	r18, 0x81	; 129
    ce74:	30 e0       	ldi	r19, 0x00	; 0
    ce76:	f9 01       	movw	r30, r18
    ce78:	20 81       	ld	r18, Z
    ce7a:	28 60       	ori	r18, 0x08	; 8
    ce7c:	fc 01       	movw	r30, r24
    ce7e:	20 83       	st	Z, r18
        bitWrite(TCCR1B, CS10, 1);
    ce80:	81 e8       	ldi	r24, 0x81	; 129
    ce82:	90 e0       	ldi	r25, 0x00	; 0
    ce84:	21 e8       	ldi	r18, 0x81	; 129
    ce86:	30 e0       	ldi	r19, 0x00	; 0
    ce88:	f9 01       	movw	r30, r18
    ce8a:	20 81       	ld	r18, Z
    ce8c:	21 60       	ori	r18, 0x01	; 1
    ce8e:	fc 01       	movw	r30, r24
    ce90:	20 83       	st	Z, r18
        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
    ce92:	8a a5       	ldd	r24, Y+42	; 0x2a
    ce94:	88 2f       	mov	r24, r24
    ce96:	90 e0       	ldi	r25, 0x00	; 0
    ce98:	87 58       	subi	r24, 0x87	; 135
    ce9a:	9d 4f       	sbci	r25, 0xFD	; 253
    ce9c:	9f 8b       	std	Y+23, r25	; 0x17
    ce9e:	8e 8b       	std	Y+22, r24	; 0x16
    cea0:	8e 89       	ldd	r24, Y+22	; 0x16
    cea2:	9f 89       	ldd	r25, Y+23	; 0x17
    cea4:	fc 01       	movw	r30, r24
    cea6:	14 91       	lpm	r17, Z
    cea8:	18 8f       	std	Y+24, r17	; 0x18
    ceaa:	88 8d       	ldd	r24, Y+24	; 0x18
    ceac:	88 2f       	mov	r24, r24
    ceae:	90 e0       	ldi	r25, 0x00	; 0
    ceb0:	88 0f       	add	r24, r24
    ceb2:	99 1f       	adc	r25, r25
    ceb4:	8b 59       	subi	r24, 0x9B	; 155
    ceb6:	9d 4f       	sbci	r25, 0xFD	; 253
    ceb8:	9a 8f       	std	Y+26, r25	; 0x1a
    ceba:	89 8f       	std	Y+25, r24	; 0x19
    cebc:	89 8d       	ldd	r24, Y+25	; 0x19
    cebe:	9a 8d       	ldd	r25, Y+26	; 0x1a
    cec0:	8c 01       	movw	r16, r24
    cec2:	f8 01       	movw	r30, r16
    cec4:	e5 90       	lpm	r14, Z+
    cec6:	f4 90       	lpm	r15, Z
    cec8:	8f 01       	movw	r16, r30
    ceca:	fc 8e       	std	Y+28, r15	; 0x1c
    cecc:	eb 8e       	std	Y+27, r14	; 0x1b
    cece:	1a 8f       	std	Y+26, r17	; 0x1a
    ced0:	09 8f       	std	Y+25, r16	; 0x19
    ced2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    ced4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    ced6:	90 93 fb 08 	sts	0x08FB, r25
    ceda:	80 93 fa 08 	sts	0x08FA, r24
        timer1_pin_mask = digitalPinToBitMask(_pin);
    cede:	8a a5       	ldd	r24, Y+42	; 0x2a
    cee0:	88 2f       	mov	r24, r24
    cee2:	90 e0       	ldi	r25, 0x00	; 0
    cee4:	83 57       	subi	r24, 0x73	; 115
    cee6:	9d 4f       	sbci	r25, 0xFD	; 253
    cee8:	9e 8f       	std	Y+30, r25	; 0x1e
    ceea:	8d 8f       	std	Y+29, r24	; 0x1d
    ceec:	8d 8d       	ldd	r24, Y+29	; 0x1d
    ceee:	9e 8d       	ldd	r25, Y+30	; 0x1e
    cef0:	fc 01       	movw	r30, r24
    cef2:	14 91       	lpm	r17, Z
    cef4:	1f 8f       	std	Y+31, r17	; 0x1f
    cef6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    cef8:	80 93 fc 08 	sts	0x08FC, r24
        break;
    cefc:	50 c0       	rjmp	.+160    	; 0xcf9e <_ZL9toneBeginh+0x2d2>
      #endif

      #if defined(TCCR2A) && defined(TCCR2B)
      case 2:
        // 8 bit timer
        TCCR2A = 0;
    cefe:	80 eb       	ldi	r24, 0xB0	; 176
    cf00:	90 e0       	ldi	r25, 0x00	; 0
    cf02:	fc 01       	movw	r30, r24
    cf04:	10 82       	st	Z, r1
        TCCR2B = 0;
    cf06:	81 eb       	ldi	r24, 0xB1	; 177
    cf08:	90 e0       	ldi	r25, 0x00	; 0
    cf0a:	fc 01       	movw	r30, r24
    cf0c:	10 82       	st	Z, r1
        bitWrite(TCCR2A, WGM21, 1);
    cf0e:	80 eb       	ldi	r24, 0xB0	; 176
    cf10:	90 e0       	ldi	r25, 0x00	; 0
    cf12:	20 eb       	ldi	r18, 0xB0	; 176
    cf14:	30 e0       	ldi	r19, 0x00	; 0
    cf16:	f9 01       	movw	r30, r18
    cf18:	20 81       	ld	r18, Z
    cf1a:	22 60       	ori	r18, 0x02	; 2
    cf1c:	fc 01       	movw	r30, r24
    cf1e:	20 83       	st	Z, r18
        bitWrite(TCCR2B, CS20, 1);
    cf20:	81 eb       	ldi	r24, 0xB1	; 177
    cf22:	90 e0       	ldi	r25, 0x00	; 0
    cf24:	21 eb       	ldi	r18, 0xB1	; 177
    cf26:	30 e0       	ldi	r19, 0x00	; 0
    cf28:	f9 01       	movw	r30, r18
    cf2a:	20 81       	ld	r18, Z
    cf2c:	21 60       	ori	r18, 0x01	; 1
    cf2e:	fc 01       	movw	r30, r24
    cf30:	20 83       	st	Z, r18
        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
    cf32:	8a a5       	ldd	r24, Y+42	; 0x2a
    cf34:	88 2f       	mov	r24, r24
    cf36:	90 e0       	ldi	r25, 0x00	; 0
    cf38:	87 58       	subi	r24, 0x87	; 135
    cf3a:	9d 4f       	sbci	r25, 0xFD	; 253
    cf3c:	99 a3       	std	Y+33, r25	; 0x21
    cf3e:	88 a3       	std	Y+32, r24	; 0x20
    cf40:	88 a1       	ldd	r24, Y+32	; 0x20
    cf42:	99 a1       	ldd	r25, Y+33	; 0x21
    cf44:	fc 01       	movw	r30, r24
    cf46:	14 91       	lpm	r17, Z
    cf48:	1a a3       	std	Y+34, r17	; 0x22
    cf4a:	8a a1       	ldd	r24, Y+34	; 0x22
    cf4c:	88 2f       	mov	r24, r24
    cf4e:	90 e0       	ldi	r25, 0x00	; 0
    cf50:	88 0f       	add	r24, r24
    cf52:	99 1f       	adc	r25, r25
    cf54:	8b 59       	subi	r24, 0x9B	; 155
    cf56:	9d 4f       	sbci	r25, 0xFD	; 253
    cf58:	9c a3       	std	Y+36, r25	; 0x24
    cf5a:	8b a3       	std	Y+35, r24	; 0x23
    cf5c:	8b a1       	ldd	r24, Y+35	; 0x23
    cf5e:	9c a1       	ldd	r25, Y+36	; 0x24
    cf60:	8c 01       	movw	r16, r24
    cf62:	f8 01       	movw	r30, r16
    cf64:	e5 90       	lpm	r14, Z+
    cf66:	f4 90       	lpm	r15, Z
    cf68:	8f 01       	movw	r16, r30
    cf6a:	fe a2       	std	Y+38, r15	; 0x26
    cf6c:	ed a2       	std	Y+37, r14	; 0x25
    cf6e:	1c a3       	std	Y+36, r17	; 0x24
    cf70:	0b a3       	std	Y+35, r16	; 0x23
    cf72:	8d a1       	ldd	r24, Y+37	; 0x25
    cf74:	9e a1       	ldd	r25, Y+38	; 0x26
    cf76:	90 93 02 09 	sts	0x0902, r25
    cf7a:	80 93 01 09 	sts	0x0901, r24
        timer2_pin_mask = digitalPinToBitMask(_pin);
    cf7e:	8a a5       	ldd	r24, Y+42	; 0x2a
    cf80:	88 2f       	mov	r24, r24
    cf82:	90 e0       	ldi	r25, 0x00	; 0
    cf84:	83 57       	subi	r24, 0x73	; 115
    cf86:	9d 4f       	sbci	r25, 0xFD	; 253
    cf88:	98 a7       	std	Y+40, r25	; 0x28
    cf8a:	8f a3       	std	Y+39, r24	; 0x27
    cf8c:	8f a1       	ldd	r24, Y+39	; 0x27
    cf8e:	98 a5       	ldd	r25, Y+40	; 0x28
    cf90:	fc 01       	movw	r30, r24
    cf92:	14 91       	lpm	r17, Z
    cf94:	19 a7       	std	Y+41, r17	; 0x29
    cf96:	89 a5       	ldd	r24, Y+41	; 0x29
    cf98:	80 93 03 09 	sts	0x0903, r24
        break;
    cf9c:	00 00       	nop
        break;
      #endif
    }
  }

  return _timer;
    cf9e:	89 81       	ldd	r24, Y+1	; 0x01
}
    cfa0:	aa 96       	adiw	r28, 0x2a	; 42
    cfa2:	0f b6       	in	r0, 0x3f	; 63
    cfa4:	f8 94       	cli
    cfa6:	de bf       	out	0x3e, r29	; 62
    cfa8:	0f be       	out	0x3f, r0	; 63
    cfaa:	cd bf       	out	0x3d, r28	; 61
    cfac:	df 91       	pop	r29
    cfae:	cf 91       	pop	r28
    cfb0:	1f 91       	pop	r17
    cfb2:	0f 91       	pop	r16
    cfb4:	ff 90       	pop	r15
    cfb6:	ef 90       	pop	r14
    cfb8:	08 95       	ret

0000cfba <_Z4tonehjm>:


// frequency (in hertz) and duration (in milliseconds).

void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
{
    cfba:	cf 93       	push	r28
    cfbc:	df 93       	push	r29
    cfbe:	cd b7       	in	r28, 0x3d	; 61
    cfc0:	de b7       	in	r29, 0x3e	; 62
    cfc2:	61 97       	sbiw	r28, 0x11	; 17
    cfc4:	0f b6       	in	r0, 0x3f	; 63
    cfc6:	f8 94       	cli
    cfc8:	de bf       	out	0x3e, r29	; 62
    cfca:	0f be       	out	0x3f, r0	; 63
    cfcc:	cd bf       	out	0x3d, r28	; 61
    cfce:	8b 87       	std	Y+11, r24	; 0x0b
    cfd0:	7d 87       	std	Y+13, r23	; 0x0d
    cfd2:	6c 87       	std	Y+12, r22	; 0x0c
    cfd4:	2e 87       	std	Y+14, r18	; 0x0e
    cfd6:	3f 87       	std	Y+15, r19	; 0x0f
    cfd8:	48 8b       	std	Y+16, r20	; 0x10
    cfda:	59 8b       	std	Y+17, r21	; 0x11
  uint8_t prescalarbits = 0b001;
    cfdc:	81 e0       	ldi	r24, 0x01	; 1
    cfde:	89 83       	std	Y+1, r24	; 0x01
  long toggle_count = 0;
    cfe0:	1a 82       	std	Y+2, r1	; 0x02
    cfe2:	1b 82       	std	Y+3, r1	; 0x03
    cfe4:	1c 82       	std	Y+4, r1	; 0x04
    cfe6:	1d 82       	std	Y+5, r1	; 0x05
  uint32_t ocr = 0;
    cfe8:	1e 82       	std	Y+6, r1	; 0x06
    cfea:	1f 82       	std	Y+7, r1	; 0x07
    cfec:	18 86       	std	Y+8, r1	; 0x08
    cfee:	19 86       	std	Y+9, r1	; 0x09
  int8_t _timer;

  _timer = toneBegin(_pin);
    cff0:	8b 85       	ldd	r24, Y+11	; 0x0b
    cff2:	0e 94 66 66 	call	0xcccc	; 0xcccc <_ZL9toneBeginh>
    cff6:	8a 87       	std	Y+10, r24	; 0x0a

  if (_timer >= 0)
    cff8:	8a 85       	ldd	r24, Y+10	; 0x0a
    cffa:	88 23       	and	r24, r24
    cffc:	0c f4       	brge	.+2      	; 0xd000 <_Z4tonehjm+0x46>
    cffe:	f6 c1       	rjmp	.+1004   	; 0xd3ec <_Z4tonehjm+0x432>
  {
    // Set the pinMode as OUTPUT
    pinMode(_pin, OUTPUT);
    d000:	61 e0       	ldi	r22, 0x01	; 1
    d002:	8b 85       	ldd	r24, Y+11	; 0x0b
    d004:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
    
    // if we are using an 8 bit timer, scan through prescalars to find the best fit
    if (_timer == 0 || _timer == 2)
    d008:	8a 85       	ldd	r24, Y+10	; 0x0a
    d00a:	88 23       	and	r24, r24
    d00c:	21 f0       	breq	.+8      	; 0xd016 <_Z4tonehjm+0x5c>
    d00e:	8a 85       	ldd	r24, Y+10	; 0x0a
    d010:	82 30       	cpi	r24, 0x02	; 2
    d012:	09 f0       	breq	.+2      	; 0xd016 <_Z4tonehjm+0x5c>
    d014:	14 c1       	rjmp	.+552    	; 0xd23e <_Z4tonehjm+0x284>
    {
      ocr = F_CPU / frequency / 2 - 1;
    d016:	8c 85       	ldd	r24, Y+12	; 0x0c
    d018:	9d 85       	ldd	r25, Y+13	; 0x0d
    d01a:	9c 01       	movw	r18, r24
    d01c:	40 e0       	ldi	r20, 0x00	; 0
    d01e:	50 e0       	ldi	r21, 0x00	; 0
    d020:	80 e0       	ldi	r24, 0x00	; 0
    d022:	92 e1       	ldi	r25, 0x12	; 18
    d024:	aa e7       	ldi	r26, 0x7A	; 122
    d026:	b0 e0       	ldi	r27, 0x00	; 0
    d028:	bc 01       	movw	r22, r24
    d02a:	cd 01       	movw	r24, r26
    d02c:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    d030:	da 01       	movw	r26, r20
    d032:	c9 01       	movw	r24, r18
    d034:	01 97       	sbiw	r24, 0x01	; 1
    d036:	a1 09       	sbc	r26, r1
    d038:	b1 09       	sbc	r27, r1
    d03a:	8e 83       	std	Y+6, r24	; 0x06
    d03c:	9f 83       	std	Y+7, r25	; 0x07
    d03e:	a8 87       	std	Y+8, r26	; 0x08
    d040:	b9 87       	std	Y+9, r27	; 0x09
      prescalarbits = 0b001;  // ck/1: same for both timers
    d042:	81 e0       	ldi	r24, 0x01	; 1
    d044:	89 83       	std	Y+1, r24	; 0x01
      if (ocr > 255)
    d046:	8e 81       	ldd	r24, Y+6	; 0x06
    d048:	9f 81       	ldd	r25, Y+7	; 0x07
    d04a:	a8 85       	ldd	r26, Y+8	; 0x08
    d04c:	b9 85       	ldd	r27, Y+9	; 0x09
    d04e:	8f 3f       	cpi	r24, 0xFF	; 255
    d050:	91 05       	cpc	r25, r1
    d052:	a1 05       	cpc	r26, r1
    d054:	b1 05       	cpc	r27, r1
    d056:	09 f0       	breq	.+2      	; 0xd05a <_Z4tonehjm+0xa0>
    d058:	08 f4       	brcc	.+2      	; 0xd05c <_Z4tonehjm+0xa2>
    d05a:	e2 c0       	rjmp	.+452    	; 0xd220 <_Z4tonehjm+0x266>
      {
        ocr = F_CPU / frequency / 2 / 8 - 1;
    d05c:	8c 85       	ldd	r24, Y+12	; 0x0c
    d05e:	9d 85       	ldd	r25, Y+13	; 0x0d
    d060:	9c 01       	movw	r18, r24
    d062:	40 e0       	ldi	r20, 0x00	; 0
    d064:	50 e0       	ldi	r21, 0x00	; 0
    d066:	80 e4       	ldi	r24, 0x40	; 64
    d068:	92 e4       	ldi	r25, 0x42	; 66
    d06a:	af e0       	ldi	r26, 0x0F	; 15
    d06c:	b0 e0       	ldi	r27, 0x00	; 0
    d06e:	bc 01       	movw	r22, r24
    d070:	cd 01       	movw	r24, r26
    d072:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    d076:	da 01       	movw	r26, r20
    d078:	c9 01       	movw	r24, r18
    d07a:	01 97       	sbiw	r24, 0x01	; 1
    d07c:	a1 09       	sbc	r26, r1
    d07e:	b1 09       	sbc	r27, r1
    d080:	8e 83       	std	Y+6, r24	; 0x06
    d082:	9f 83       	std	Y+7, r25	; 0x07
    d084:	a8 87       	std	Y+8, r26	; 0x08
    d086:	b9 87       	std	Y+9, r27	; 0x09
        prescalarbits = 0b010;  // ck/8: same for both timers
    d088:	82 e0       	ldi	r24, 0x02	; 2
    d08a:	89 83       	std	Y+1, r24	; 0x01

        if (_timer == 2 && ocr > 255)
    d08c:	8a 85       	ldd	r24, Y+10	; 0x0a
    d08e:	82 30       	cpi	r24, 0x02	; 2
    d090:	11 f5       	brne	.+68     	; 0xd0d6 <_Z4tonehjm+0x11c>
    d092:	8e 81       	ldd	r24, Y+6	; 0x06
    d094:	9f 81       	ldd	r25, Y+7	; 0x07
    d096:	a8 85       	ldd	r26, Y+8	; 0x08
    d098:	b9 85       	ldd	r27, Y+9	; 0x09
    d09a:	8f 3f       	cpi	r24, 0xFF	; 255
    d09c:	91 05       	cpc	r25, r1
    d09e:	a1 05       	cpc	r26, r1
    d0a0:	b1 05       	cpc	r27, r1
    d0a2:	c9 f0       	breq	.+50     	; 0xd0d6 <_Z4tonehjm+0x11c>
    d0a4:	c0 f0       	brcs	.+48     	; 0xd0d6 <_Z4tonehjm+0x11c>
        {
          ocr = F_CPU / frequency / 2 / 32 - 1;
    d0a6:	8c 85       	ldd	r24, Y+12	; 0x0c
    d0a8:	9d 85       	ldd	r25, Y+13	; 0x0d
    d0aa:	9c 01       	movw	r18, r24
    d0ac:	40 e0       	ldi	r20, 0x00	; 0
    d0ae:	50 e0       	ldi	r21, 0x00	; 0
    d0b0:	80 e9       	ldi	r24, 0x90	; 144
    d0b2:	90 ed       	ldi	r25, 0xD0	; 208
    d0b4:	a3 e0       	ldi	r26, 0x03	; 3
    d0b6:	b0 e0       	ldi	r27, 0x00	; 0
    d0b8:	bc 01       	movw	r22, r24
    d0ba:	cd 01       	movw	r24, r26
    d0bc:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    d0c0:	da 01       	movw	r26, r20
    d0c2:	c9 01       	movw	r24, r18
    d0c4:	01 97       	sbiw	r24, 0x01	; 1
    d0c6:	a1 09       	sbc	r26, r1
    d0c8:	b1 09       	sbc	r27, r1
    d0ca:	8e 83       	std	Y+6, r24	; 0x06
    d0cc:	9f 83       	std	Y+7, r25	; 0x07
    d0ce:	a8 87       	std	Y+8, r26	; 0x08
    d0d0:	b9 87       	std	Y+9, r27	; 0x09
          prescalarbits = 0b011;
    d0d2:	83 e0       	ldi	r24, 0x03	; 3
    d0d4:	89 83       	std	Y+1, r24	; 0x01
        }

        if (ocr > 255)
    d0d6:	8e 81       	ldd	r24, Y+6	; 0x06
    d0d8:	9f 81       	ldd	r25, Y+7	; 0x07
    d0da:	a8 85       	ldd	r26, Y+8	; 0x08
    d0dc:	b9 85       	ldd	r27, Y+9	; 0x09
    d0de:	8f 3f       	cpi	r24, 0xFF	; 255
    d0e0:	91 05       	cpc	r25, r1
    d0e2:	a1 05       	cpc	r26, r1
    d0e4:	b1 05       	cpc	r27, r1
    d0e6:	09 f0       	breq	.+2      	; 0xd0ea <_Z4tonehjm+0x130>
    d0e8:	08 f4       	brcc	.+2      	; 0xd0ec <_Z4tonehjm+0x132>
    d0ea:	9a c0       	rjmp	.+308    	; 0xd220 <_Z4tonehjm+0x266>
        {
          ocr = F_CPU / frequency / 2 / 64 - 1;
    d0ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    d0ee:	9d 85       	ldd	r25, Y+13	; 0x0d
    d0f0:	9c 01       	movw	r18, r24
    d0f2:	40 e0       	ldi	r20, 0x00	; 0
    d0f4:	50 e0       	ldi	r21, 0x00	; 0
    d0f6:	88 e4       	ldi	r24, 0x48	; 72
    d0f8:	98 ee       	ldi	r25, 0xE8	; 232
    d0fa:	a1 e0       	ldi	r26, 0x01	; 1
    d0fc:	b0 e0       	ldi	r27, 0x00	; 0
    d0fe:	bc 01       	movw	r22, r24
    d100:	cd 01       	movw	r24, r26
    d102:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    d106:	da 01       	movw	r26, r20
    d108:	c9 01       	movw	r24, r18
    d10a:	01 97       	sbiw	r24, 0x01	; 1
    d10c:	a1 09       	sbc	r26, r1
    d10e:	b1 09       	sbc	r27, r1
    d110:	8e 83       	std	Y+6, r24	; 0x06
    d112:	9f 83       	std	Y+7, r25	; 0x07
    d114:	a8 87       	std	Y+8, r26	; 0x08
    d116:	b9 87       	std	Y+9, r27	; 0x09
          prescalarbits = _timer == 0 ? 0b011 : 0b100;
    d118:	8a 85       	ldd	r24, Y+10	; 0x0a
    d11a:	88 23       	and	r24, r24
    d11c:	11 f4       	brne	.+4      	; 0xd122 <_Z4tonehjm+0x168>
    d11e:	83 e0       	ldi	r24, 0x03	; 3
    d120:	01 c0       	rjmp	.+2      	; 0xd124 <_Z4tonehjm+0x16a>
    d122:	84 e0       	ldi	r24, 0x04	; 4
    d124:	89 83       	std	Y+1, r24	; 0x01

          if (_timer == 2 && ocr > 255)
    d126:	8a 85       	ldd	r24, Y+10	; 0x0a
    d128:	82 30       	cpi	r24, 0x02	; 2
    d12a:	11 f5       	brne	.+68     	; 0xd170 <_Z4tonehjm+0x1b6>
    d12c:	8e 81       	ldd	r24, Y+6	; 0x06
    d12e:	9f 81       	ldd	r25, Y+7	; 0x07
    d130:	a8 85       	ldd	r26, Y+8	; 0x08
    d132:	b9 85       	ldd	r27, Y+9	; 0x09
    d134:	8f 3f       	cpi	r24, 0xFF	; 255
    d136:	91 05       	cpc	r25, r1
    d138:	a1 05       	cpc	r26, r1
    d13a:	b1 05       	cpc	r27, r1
    d13c:	c9 f0       	breq	.+50     	; 0xd170 <_Z4tonehjm+0x1b6>
    d13e:	c0 f0       	brcs	.+48     	; 0xd170 <_Z4tonehjm+0x1b6>
          {
            ocr = F_CPU / frequency / 2 / 128 - 1;
    d140:	8c 85       	ldd	r24, Y+12	; 0x0c
    d142:	9d 85       	ldd	r25, Y+13	; 0x0d
    d144:	9c 01       	movw	r18, r24
    d146:	40 e0       	ldi	r20, 0x00	; 0
    d148:	50 e0       	ldi	r21, 0x00	; 0
    d14a:	84 e2       	ldi	r24, 0x24	; 36
    d14c:	94 ef       	ldi	r25, 0xF4	; 244
    d14e:	a0 e0       	ldi	r26, 0x00	; 0
    d150:	b0 e0       	ldi	r27, 0x00	; 0
    d152:	bc 01       	movw	r22, r24
    d154:	cd 01       	movw	r24, r26
    d156:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    d15a:	da 01       	movw	r26, r20
    d15c:	c9 01       	movw	r24, r18
    d15e:	01 97       	sbiw	r24, 0x01	; 1
    d160:	a1 09       	sbc	r26, r1
    d162:	b1 09       	sbc	r27, r1
    d164:	8e 83       	std	Y+6, r24	; 0x06
    d166:	9f 83       	std	Y+7, r25	; 0x07
    d168:	a8 87       	std	Y+8, r26	; 0x08
    d16a:	b9 87       	std	Y+9, r27	; 0x09
            prescalarbits = 0b101;
    d16c:	85 e0       	ldi	r24, 0x05	; 5
    d16e:	89 83       	std	Y+1, r24	; 0x01
          }

          if (ocr > 255)
    d170:	8e 81       	ldd	r24, Y+6	; 0x06
    d172:	9f 81       	ldd	r25, Y+7	; 0x07
    d174:	a8 85       	ldd	r26, Y+8	; 0x08
    d176:	b9 85       	ldd	r27, Y+9	; 0x09
    d178:	8f 3f       	cpi	r24, 0xFF	; 255
    d17a:	91 05       	cpc	r25, r1
    d17c:	a1 05       	cpc	r26, r1
    d17e:	b1 05       	cpc	r27, r1
    d180:	09 f0       	breq	.+2      	; 0xd184 <_Z4tonehjm+0x1ca>
    d182:	08 f4       	brcc	.+2      	; 0xd186 <_Z4tonehjm+0x1cc>
    d184:	4d c0       	rjmp	.+154    	; 0xd220 <_Z4tonehjm+0x266>
          {
            ocr = F_CPU / frequency / 2 / 256 - 1;
    d186:	8c 85       	ldd	r24, Y+12	; 0x0c
    d188:	9d 85       	ldd	r25, Y+13	; 0x0d
    d18a:	9c 01       	movw	r18, r24
    d18c:	40 e0       	ldi	r20, 0x00	; 0
    d18e:	50 e0       	ldi	r21, 0x00	; 0
    d190:	82 e1       	ldi	r24, 0x12	; 18
    d192:	9a e7       	ldi	r25, 0x7A	; 122
    d194:	a0 e0       	ldi	r26, 0x00	; 0
    d196:	b0 e0       	ldi	r27, 0x00	; 0
    d198:	bc 01       	movw	r22, r24
    d19a:	cd 01       	movw	r24, r26
    d19c:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    d1a0:	da 01       	movw	r26, r20
    d1a2:	c9 01       	movw	r24, r18
    d1a4:	01 97       	sbiw	r24, 0x01	; 1
    d1a6:	a1 09       	sbc	r26, r1
    d1a8:	b1 09       	sbc	r27, r1
    d1aa:	8e 83       	std	Y+6, r24	; 0x06
    d1ac:	9f 83       	std	Y+7, r25	; 0x07
    d1ae:	a8 87       	std	Y+8, r26	; 0x08
    d1b0:	b9 87       	std	Y+9, r27	; 0x09
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
    d1b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    d1b4:	88 23       	and	r24, r24
    d1b6:	11 f4       	brne	.+4      	; 0xd1bc <_Z4tonehjm+0x202>
    d1b8:	84 e0       	ldi	r24, 0x04	; 4
    d1ba:	01 c0       	rjmp	.+2      	; 0xd1be <_Z4tonehjm+0x204>
    d1bc:	86 e0       	ldi	r24, 0x06	; 6
    d1be:	89 83       	std	Y+1, r24	; 0x01
            if (ocr > 255)
    d1c0:	8e 81       	ldd	r24, Y+6	; 0x06
    d1c2:	9f 81       	ldd	r25, Y+7	; 0x07
    d1c4:	a8 85       	ldd	r26, Y+8	; 0x08
    d1c6:	b9 85       	ldd	r27, Y+9	; 0x09
    d1c8:	8f 3f       	cpi	r24, 0xFF	; 255
    d1ca:	91 05       	cpc	r25, r1
    d1cc:	a1 05       	cpc	r26, r1
    d1ce:	b1 05       	cpc	r27, r1
    d1d0:	39 f1       	breq	.+78     	; 0xd220 <_Z4tonehjm+0x266>
    d1d2:	30 f1       	brcs	.+76     	; 0xd220 <_Z4tonehjm+0x266>
            {
              // can't do any better than /1024
              ocr = F_CPU / frequency / 2 / 1024 - 1;
    d1d4:	8c 85       	ldd	r24, Y+12	; 0x0c
    d1d6:	9d 85       	ldd	r25, Y+13	; 0x0d
    d1d8:	9c 01       	movw	r18, r24
    d1da:	40 e0       	ldi	r20, 0x00	; 0
    d1dc:	50 e0       	ldi	r21, 0x00	; 0
    d1de:	80 e0       	ldi	r24, 0x00	; 0
    d1e0:	92 e1       	ldi	r25, 0x12	; 18
    d1e2:	aa e7       	ldi	r26, 0x7A	; 122
    d1e4:	b0 e0       	ldi	r27, 0x00	; 0
    d1e6:	bc 01       	movw	r22, r24
    d1e8:	cd 01       	movw	r24, r26
    d1ea:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    d1ee:	da 01       	movw	r26, r20
    d1f0:	c9 01       	movw	r24, r18
    d1f2:	07 2e       	mov	r0, r23
    d1f4:	7a e0       	ldi	r23, 0x0A	; 10
    d1f6:	b6 95       	lsr	r27
    d1f8:	a7 95       	ror	r26
    d1fa:	97 95       	ror	r25
    d1fc:	87 95       	ror	r24
    d1fe:	7a 95       	dec	r23
    d200:	d1 f7       	brne	.-12     	; 0xd1f6 <_Z4tonehjm+0x23c>
    d202:	70 2d       	mov	r23, r0
    d204:	01 97       	sbiw	r24, 0x01	; 1
    d206:	a1 09       	sbc	r26, r1
    d208:	b1 09       	sbc	r27, r1
    d20a:	8e 83       	std	Y+6, r24	; 0x06
    d20c:	9f 83       	std	Y+7, r25	; 0x07
    d20e:	a8 87       	std	Y+8, r26	; 0x08
    d210:	b9 87       	std	Y+9, r27	; 0x09
              prescalarbits = _timer == 0 ? 0b101 : 0b111;
    d212:	8a 85       	ldd	r24, Y+10	; 0x0a
    d214:	88 23       	and	r24, r24
    d216:	11 f4       	brne	.+4      	; 0xd21c <_Z4tonehjm+0x262>
    d218:	85 e0       	ldi	r24, 0x05	; 5
    d21a:	01 c0       	rjmp	.+2      	; 0xd21e <_Z4tonehjm+0x264>
    d21c:	87 e0       	ldi	r24, 0x07	; 7
    d21e:	89 83       	std	Y+1, r24	; 0x01
          }
        }
      }

#if defined(TCCR0B)
      if (_timer == 0)
    d220:	8a 85       	ldd	r24, Y+10	; 0x0a
    d222:	88 23       	and	r24, r24
    d224:	31 f4       	brne	.+12     	; 0xd232 <_Z4tonehjm+0x278>
      {
        TCCR0B = prescalarbits;
    d226:	85 e4       	ldi	r24, 0x45	; 69
    d228:	90 e0       	ldi	r25, 0x00	; 0
    d22a:	29 81       	ldd	r18, Y+1	; 0x01
    d22c:	fc 01       	movw	r30, r24
    d22e:	20 83       	st	Z, r18
          }
        }
      }

#if defined(TCCR0B)
      if (_timer == 0)
    d230:	4e c0       	rjmp	.+156    	; 0xd2ce <_Z4tonehjm+0x314>
      }
      else
#endif
#if defined(TCCR2B)
      {
        TCCR2B = prescalarbits;
    d232:	81 eb       	ldi	r24, 0xB1	; 177
    d234:	90 e0       	ldi	r25, 0x00	; 0
    d236:	29 81       	ldd	r18, Y+1	; 0x01
    d238:	fc 01       	movw	r30, r24
    d23a:	20 83       	st	Z, r18
          }
        }
      }

#if defined(TCCR0B)
      if (_timer == 0)
    d23c:	48 c0       	rjmp	.+144    	; 0xd2ce <_Z4tonehjm+0x314>
#endif
    }
    else
    {
      // two choices for the 16 bit timers: ck/1 or ck/64
      ocr = F_CPU / frequency / 2 - 1;
    d23e:	8c 85       	ldd	r24, Y+12	; 0x0c
    d240:	9d 85       	ldd	r25, Y+13	; 0x0d
    d242:	9c 01       	movw	r18, r24
    d244:	40 e0       	ldi	r20, 0x00	; 0
    d246:	50 e0       	ldi	r21, 0x00	; 0
    d248:	80 e0       	ldi	r24, 0x00	; 0
    d24a:	92 e1       	ldi	r25, 0x12	; 18
    d24c:	aa e7       	ldi	r26, 0x7A	; 122
    d24e:	b0 e0       	ldi	r27, 0x00	; 0
    d250:	bc 01       	movw	r22, r24
    d252:	cd 01       	movw	r24, r26
    d254:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    d258:	da 01       	movw	r26, r20
    d25a:	c9 01       	movw	r24, r18
    d25c:	01 97       	sbiw	r24, 0x01	; 1
    d25e:	a1 09       	sbc	r26, r1
    d260:	b1 09       	sbc	r27, r1
    d262:	8e 83       	std	Y+6, r24	; 0x06
    d264:	9f 83       	std	Y+7, r25	; 0x07
    d266:	a8 87       	std	Y+8, r26	; 0x08
    d268:	b9 87       	std	Y+9, r27	; 0x09

      prescalarbits = 0b001;
    d26a:	81 e0       	ldi	r24, 0x01	; 1
    d26c:	89 83       	std	Y+1, r24	; 0x01
      if (ocr > 0xffff)
    d26e:	8e 81       	ldd	r24, Y+6	; 0x06
    d270:	9f 81       	ldd	r25, Y+7	; 0x07
    d272:	a8 85       	ldd	r26, Y+8	; 0x08
    d274:	b9 85       	ldd	r27, Y+9	; 0x09
    d276:	00 97       	sbiw	r24, 0x00	; 0
    d278:	f1 e0       	ldi	r31, 0x01	; 1
    d27a:	af 07       	cpc	r26, r31
    d27c:	b1 05       	cpc	r27, r1
    d27e:	c0 f0       	brcs	.+48     	; 0xd2b0 <_Z4tonehjm+0x2f6>
      {
        ocr = F_CPU / frequency / 2 / 64 - 1;
    d280:	8c 85       	ldd	r24, Y+12	; 0x0c
    d282:	9d 85       	ldd	r25, Y+13	; 0x0d
    d284:	9c 01       	movw	r18, r24
    d286:	40 e0       	ldi	r20, 0x00	; 0
    d288:	50 e0       	ldi	r21, 0x00	; 0
    d28a:	88 e4       	ldi	r24, 0x48	; 72
    d28c:	98 ee       	ldi	r25, 0xE8	; 232
    d28e:	a1 e0       	ldi	r26, 0x01	; 1
    d290:	b0 e0       	ldi	r27, 0x00	; 0
    d292:	bc 01       	movw	r22, r24
    d294:	cd 01       	movw	r24, r26
    d296:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    d29a:	da 01       	movw	r26, r20
    d29c:	c9 01       	movw	r24, r18
    d29e:	01 97       	sbiw	r24, 0x01	; 1
    d2a0:	a1 09       	sbc	r26, r1
    d2a2:	b1 09       	sbc	r27, r1
    d2a4:	8e 83       	std	Y+6, r24	; 0x06
    d2a6:	9f 83       	std	Y+7, r25	; 0x07
    d2a8:	a8 87       	std	Y+8, r26	; 0x08
    d2aa:	b9 87       	std	Y+9, r27	; 0x09
        prescalarbits = 0b011;
    d2ac:	83 e0       	ldi	r24, 0x03	; 3
    d2ae:	89 83       	std	Y+1, r24	; 0x01
      }

      if (_timer == 1)
    d2b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    d2b2:	81 30       	cpi	r24, 0x01	; 1
    d2b4:	61 f4       	brne	.+24     	; 0xd2ce <_Z4tonehjm+0x314>
      {
#if defined(TCCR1B)
        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
    d2b6:	81 e8       	ldi	r24, 0x81	; 129
    d2b8:	90 e0       	ldi	r25, 0x00	; 0
    d2ba:	21 e8       	ldi	r18, 0x81	; 129
    d2bc:	30 e0       	ldi	r19, 0x00	; 0
    d2be:	f9 01       	movw	r30, r18
    d2c0:	20 81       	ld	r18, Z
    d2c2:	32 2f       	mov	r19, r18
    d2c4:	38 7f       	andi	r19, 0xF8	; 248
    d2c6:	29 81       	ldd	r18, Y+1	; 0x01
    d2c8:	23 2b       	or	r18, r19
    d2ca:	fc 01       	movw	r30, r24
    d2cc:	20 83       	st	Z, r18

    }
    

    // Calculate the toggle count
    if (duration > 0)
    d2ce:	8e 85       	ldd	r24, Y+14	; 0x0e
    d2d0:	9f 85       	ldd	r25, Y+15	; 0x0f
    d2d2:	a8 89       	ldd	r26, Y+16	; 0x10
    d2d4:	b9 89       	ldd	r27, Y+17	; 0x11
    d2d6:	00 97       	sbiw	r24, 0x00	; 0
    d2d8:	a1 05       	cpc	r26, r1
    d2da:	b1 05       	cpc	r27, r1
    d2dc:	01 f1       	breq	.+64     	; 0xd31e <_Z4tonehjm+0x364>
    {
      toggle_count = 2 * frequency * duration / 1000;
    d2de:	8c 85       	ldd	r24, Y+12	; 0x0c
    d2e0:	9d 85       	ldd	r25, Y+13	; 0x0d
    d2e2:	88 0f       	add	r24, r24
    d2e4:	99 1f       	adc	r25, r25
    d2e6:	9c 01       	movw	r18, r24
    d2e8:	40 e0       	ldi	r20, 0x00	; 0
    d2ea:	50 e0       	ldi	r21, 0x00	; 0
    d2ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    d2ee:	9f 85       	ldd	r25, Y+15	; 0x0f
    d2f0:	a8 89       	ldd	r26, Y+16	; 0x10
    d2f2:	b9 89       	ldd	r27, Y+17	; 0x11
    d2f4:	bc 01       	movw	r22, r24
    d2f6:	cd 01       	movw	r24, r26
    d2f8:	0e 94 9d ad 	call	0x15b3a	; 0x15b3a <__mulsi3>
    d2fc:	dc 01       	movw	r26, r24
    d2fe:	cb 01       	movw	r24, r22
    d300:	28 ee       	ldi	r18, 0xE8	; 232
    d302:	33 e0       	ldi	r19, 0x03	; 3
    d304:	40 e0       	ldi	r20, 0x00	; 0
    d306:	50 e0       	ldi	r21, 0x00	; 0
    d308:	bc 01       	movw	r22, r24
    d30a:	cd 01       	movw	r24, r26
    d30c:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
    d310:	da 01       	movw	r26, r20
    d312:	c9 01       	movw	r24, r18
    d314:	8a 83       	std	Y+2, r24	; 0x02
    d316:	9b 83       	std	Y+3, r25	; 0x03
    d318:	ac 83       	std	Y+4, r26	; 0x04
    d31a:	bd 83       	std	Y+5, r27	; 0x05
    d31c:	07 c0       	rjmp	.+14     	; 0xd32c <_Z4tonehjm+0x372>
    }
    else
    {
      toggle_count = -1;
    d31e:	8f ef       	ldi	r24, 0xFF	; 255
    d320:	9f ef       	ldi	r25, 0xFF	; 255
    d322:	dc 01       	movw	r26, r24
    d324:	8a 83       	std	Y+2, r24	; 0x02
    d326:	9b 83       	std	Y+3, r25	; 0x03
    d328:	ac 83       	std	Y+4, r26	; 0x04
    d32a:	bd 83       	std	Y+5, r27	; 0x05
    }

    // Set the OCR for the given timer,
    // set the toggle count,
    // then turn on the interrupts
    switch (_timer)
    d32c:	8a 85       	ldd	r24, Y+10	; 0x0a
    d32e:	99 27       	eor	r25, r25
    d330:	87 fd       	sbrc	r24, 7
    d332:	90 95       	com	r25
    d334:	81 30       	cpi	r24, 0x01	; 1
    d336:	91 05       	cpc	r25, r1
    d338:	09 f1       	breq	.+66     	; 0xd37c <_Z4tonehjm+0x3c2>
    d33a:	82 30       	cpi	r24, 0x02	; 2
    d33c:	91 05       	cpc	r25, r1
    d33e:	d9 f1       	breq	.+118    	; 0xd3b6 <_Z4tonehjm+0x3fc>
    d340:	00 97       	sbiw	r24, 0x00	; 0
    d342:	09 f0       	breq	.+2      	; 0xd346 <_Z4tonehjm+0x38c>
    d344:	53 c0       	rjmp	.+166    	; 0xd3ec <_Z4tonehjm+0x432>
    {

#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
      case 0:
        OCR0A = ocr;
    d346:	87 e4       	ldi	r24, 0x47	; 71
    d348:	90 e0       	ldi	r25, 0x00	; 0
    d34a:	2e 81       	ldd	r18, Y+6	; 0x06
    d34c:	fc 01       	movw	r30, r24
    d34e:	20 83       	st	Z, r18
        timer0_toggle_count = toggle_count;
    d350:	8a 81       	ldd	r24, Y+2	; 0x02
    d352:	9b 81       	ldd	r25, Y+3	; 0x03
    d354:	ac 81       	ldd	r26, Y+4	; 0x04
    d356:	bd 81       	ldd	r27, Y+5	; 0x05
    d358:	80 93 ef 08 	sts	0x08EF, r24
    d35c:	90 93 f0 08 	sts	0x08F0, r25
    d360:	a0 93 f1 08 	sts	0x08F1, r26
    d364:	b0 93 f2 08 	sts	0x08F2, r27
        bitWrite(TIMSK0, OCIE0A, 1);
    d368:	8e e6       	ldi	r24, 0x6E	; 110
    d36a:	90 e0       	ldi	r25, 0x00	; 0
    d36c:	2e e6       	ldi	r18, 0x6E	; 110
    d36e:	30 e0       	ldi	r19, 0x00	; 0
    d370:	f9 01       	movw	r30, r18
    d372:	20 81       	ld	r18, Z
    d374:	22 60       	ori	r18, 0x02	; 2
    d376:	fc 01       	movw	r30, r24
    d378:	20 83       	st	Z, r18
        break;
    d37a:	38 c0       	rjmp	.+112    	; 0xd3ec <_Z4tonehjm+0x432>
#endif

      case 1:
#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
        OCR1A = ocr;
    d37c:	88 e8       	ldi	r24, 0x88	; 136
    d37e:	90 e0       	ldi	r25, 0x00	; 0
    d380:	2e 81       	ldd	r18, Y+6	; 0x06
    d382:	3f 81       	ldd	r19, Y+7	; 0x07
    d384:	fc 01       	movw	r30, r24
    d386:	31 83       	std	Z+1, r19	; 0x01
    d388:	20 83       	st	Z, r18
        timer1_toggle_count = toggle_count;
    d38a:	8a 81       	ldd	r24, Y+2	; 0x02
    d38c:	9b 81       	ldd	r25, Y+3	; 0x03
    d38e:	ac 81       	ldd	r26, Y+4	; 0x04
    d390:	bd 81       	ldd	r27, Y+5	; 0x05
    d392:	80 93 f6 08 	sts	0x08F6, r24
    d396:	90 93 f7 08 	sts	0x08F7, r25
    d39a:	a0 93 f8 08 	sts	0x08F8, r26
    d39e:	b0 93 f9 08 	sts	0x08F9, r27
        bitWrite(TIMSK1, OCIE1A, 1);
    d3a2:	8f e6       	ldi	r24, 0x6F	; 111
    d3a4:	90 e0       	ldi	r25, 0x00	; 0
    d3a6:	2f e6       	ldi	r18, 0x6F	; 111
    d3a8:	30 e0       	ldi	r19, 0x00	; 0
    d3aa:	f9 01       	movw	r30, r18
    d3ac:	20 81       	ld	r18, Z
    d3ae:	22 60       	ori	r18, 0x02	; 2
    d3b0:	fc 01       	movw	r30, r24
    d3b2:	20 83       	st	Z, r18
        // this combination is for at least the ATmega32
        OCR1A = ocr;
        timer1_toggle_count = toggle_count;
        bitWrite(TIMSK, OCIE1A, 1);
#endif
        break;
    d3b4:	1b c0       	rjmp	.+54     	; 0xd3ec <_Z4tonehjm+0x432>

#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
      case 2:
        OCR2A = ocr;
    d3b6:	83 eb       	ldi	r24, 0xB3	; 179
    d3b8:	90 e0       	ldi	r25, 0x00	; 0
    d3ba:	2e 81       	ldd	r18, Y+6	; 0x06
    d3bc:	fc 01       	movw	r30, r24
    d3be:	20 83       	st	Z, r18
        timer2_toggle_count = toggle_count;
    d3c0:	8a 81       	ldd	r24, Y+2	; 0x02
    d3c2:	9b 81       	ldd	r25, Y+3	; 0x03
    d3c4:	ac 81       	ldd	r26, Y+4	; 0x04
    d3c6:	bd 81       	ldd	r27, Y+5	; 0x05
    d3c8:	80 93 fd 08 	sts	0x08FD, r24
    d3cc:	90 93 fe 08 	sts	0x08FE, r25
    d3d0:	a0 93 ff 08 	sts	0x08FF, r26
    d3d4:	b0 93 00 09 	sts	0x0900, r27
        bitWrite(TIMSK2, OCIE2A, 1);
    d3d8:	80 e7       	ldi	r24, 0x70	; 112
    d3da:	90 e0       	ldi	r25, 0x00	; 0
    d3dc:	20 e7       	ldi	r18, 0x70	; 112
    d3de:	30 e0       	ldi	r19, 0x00	; 0
    d3e0:	f9 01       	movw	r30, r18
    d3e2:	20 81       	ld	r18, Z
    d3e4:	22 60       	ori	r18, 0x02	; 2
    d3e6:	fc 01       	movw	r30, r24
    d3e8:	20 83       	st	Z, r18
        break;
    d3ea:	00 00       	nop
        break;
#endif

    }
  }
}
    d3ec:	61 96       	adiw	r28, 0x11	; 17
    d3ee:	0f b6       	in	r0, 0x3f	; 63
    d3f0:	f8 94       	cli
    d3f2:	de bf       	out	0x3e, r29	; 62
    d3f4:	0f be       	out	0x3f, r0	; 63
    d3f6:	cd bf       	out	0x3d, r28	; 61
    d3f8:	df 91       	pop	r29
    d3fa:	cf 91       	pop	r28
    d3fc:	08 95       	ret

0000d3fe <_Z12disableTimerh>:

// XXX: this function only works properly for timer 2 (the only one we use
// currently).  for the others, it should end the tone, but won't restore
// proper PWM functionality for the timer.
void disableTimer(uint8_t _timer)
{
    d3fe:	cf 93       	push	r28
    d400:	df 93       	push	r29
    d402:	1f 92       	push	r1
    d404:	cd b7       	in	r28, 0x3d	; 61
    d406:	de b7       	in	r29, 0x3e	; 62
    d408:	89 83       	std	Y+1, r24	; 0x01
  switch (_timer)
    d40a:	89 81       	ldd	r24, Y+1	; 0x01
    d40c:	88 2f       	mov	r24, r24
    d40e:	90 e0       	ldi	r25, 0x00	; 0
    d410:	81 30       	cpi	r24, 0x01	; 1
    d412:	91 05       	cpc	r25, r1
    d414:	51 f0       	breq	.+20     	; 0xd42a <_Z12disableTimerh+0x2c>
    d416:	82 30       	cpi	r24, 0x02	; 2
    d418:	91 05       	cpc	r25, r1
    d41a:	89 f0       	breq	.+34     	; 0xd43e <_Z12disableTimerh+0x40>
    d41c:	00 97       	sbiw	r24, 0x00	; 0
    d41e:	61 f5       	brne	.+88     	; 0xd478 <_Z12disableTimerh+0x7a>
  {
    case 0:
      #if defined(TIMSK0)
        TIMSK0 = 0;
    d420:	8e e6       	ldi	r24, 0x6E	; 110
    d422:	90 e0       	ldi	r25, 0x00	; 0
    d424:	fc 01       	movw	r30, r24
    d426:	10 82       	st	Z, r1
      #elif defined(TIMSK)
        TIMSK = 0; // atmega32
      #endif
      break;
    d428:	27 c0       	rjmp	.+78     	; 0xd478 <_Z12disableTimerh+0x7a>

#if defined(TIMSK1) && defined(OCIE1A)
    case 1:
      bitWrite(TIMSK1, OCIE1A, 0);
    d42a:	8f e6       	ldi	r24, 0x6F	; 111
    d42c:	90 e0       	ldi	r25, 0x00	; 0
    d42e:	2f e6       	ldi	r18, 0x6F	; 111
    d430:	30 e0       	ldi	r19, 0x00	; 0
    d432:	f9 01       	movw	r30, r18
    d434:	20 81       	ld	r18, Z
    d436:	2d 7f       	andi	r18, 0xFD	; 253
    d438:	fc 01       	movw	r30, r24
    d43a:	20 83       	st	Z, r18
      break;
    d43c:	1d c0       	rjmp	.+58     	; 0xd478 <_Z12disableTimerh+0x7a>
#endif

    case 2:
      #if defined(TIMSK2) && defined(OCIE2A)
        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
    d43e:	80 e7       	ldi	r24, 0x70	; 112
    d440:	90 e0       	ldi	r25, 0x00	; 0
    d442:	20 e7       	ldi	r18, 0x70	; 112
    d444:	30 e0       	ldi	r19, 0x00	; 0
    d446:	f9 01       	movw	r30, r18
    d448:	20 81       	ld	r18, Z
    d44a:	2d 7f       	andi	r18, 0xFD	; 253
    d44c:	fc 01       	movw	r30, r24
    d44e:	20 83       	st	Z, r18
      #endif
      #if defined(TCCR2A) && defined(WGM20)
        TCCR2A = (1 << WGM20);
    d450:	80 eb       	ldi	r24, 0xB0	; 176
    d452:	90 e0       	ldi	r25, 0x00	; 0
    d454:	21 e0       	ldi	r18, 0x01	; 1
    d456:	fc 01       	movw	r30, r24
    d458:	20 83       	st	Z, r18
      #endif
      #if defined(TCCR2B) && defined(CS22)
        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
    d45a:	81 eb       	ldi	r24, 0xB1	; 177
    d45c:	90 e0       	ldi	r25, 0x00	; 0
    d45e:	21 eb       	ldi	r18, 0xB1	; 177
    d460:	30 e0       	ldi	r19, 0x00	; 0
    d462:	f9 01       	movw	r30, r18
    d464:	20 81       	ld	r18, Z
    d466:	28 7f       	andi	r18, 0xF8	; 248
    d468:	24 60       	ori	r18, 0x04	; 4
    d46a:	fc 01       	movw	r30, r24
    d46c:	20 83       	st	Z, r18
      #endif
      #if defined(OCR2A)
        OCR2A = 0;
    d46e:	83 eb       	ldi	r24, 0xB3	; 179
    d470:	90 e0       	ldi	r25, 0x00	; 0
    d472:	fc 01       	movw	r30, r24
    d474:	10 82       	st	Z, r1
      #endif
      break;
    d476:	00 00       	nop
    case 5:
      TIMSK5 = 0;
      break;
#endif
  }
}
    d478:	0f 90       	pop	r0
    d47a:	df 91       	pop	r29
    d47c:	cf 91       	pop	r28
    d47e:	08 95       	ret

0000d480 <_Z6noToneh>:


void noTone(uint8_t _pin)
{
    d480:	1f 93       	push	r17
    d482:	cf 93       	push	r28
    d484:	df 93       	push	r29
    d486:	cd b7       	in	r28, 0x3d	; 61
    d488:	de b7       	in	r29, 0x3e	; 62
    d48a:	27 97       	sbiw	r28, 0x07	; 7
    d48c:	0f b6       	in	r0, 0x3f	; 63
    d48e:	f8 94       	cli
    d490:	de bf       	out	0x3e, r29	; 62
    d492:	0f be       	out	0x3f, r0	; 63
    d494:	cd bf       	out	0x3d, r28	; 61
    d496:	8f 83       	std	Y+7, r24	; 0x07
  int8_t _timer = -1;
    d498:	8f ef       	ldi	r24, 0xFF	; 255
    d49a:	89 83       	std	Y+1, r24	; 0x01
  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    d49c:	1b 82       	std	Y+3, r1	; 0x03
    d49e:	1a 82       	std	Y+2, r1	; 0x02
    d4a0:	22 c0       	rjmp	.+68     	; 0xd4e6 <_Z6noToneh+0x66>
    if (tone_pins[i] == _pin) {
    d4a2:	8a 81       	ldd	r24, Y+2	; 0x02
    d4a4:	9b 81       	ldd	r25, Y+3	; 0x03
    d4a6:	8c 5b       	subi	r24, 0xBC	; 188
    d4a8:	9d 4f       	sbci	r25, 0xFD	; 253
    d4aa:	fc 01       	movw	r30, r24
    d4ac:	90 81       	ld	r25, Z
    d4ae:	8f 81       	ldd	r24, Y+7	; 0x07
    d4b0:	98 17       	cp	r25, r24
    d4b2:	a1 f4       	brne	.+40     	; 0xd4dc <_Z6noToneh+0x5c>
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
    d4b4:	8a 81       	ldd	r24, Y+2	; 0x02
    d4b6:	9b 81       	ldd	r25, Y+3	; 0x03
    d4b8:	86 5a       	subi	r24, 0xA6	; 166
    d4ba:	9d 4f       	sbci	r25, 0xFD	; 253
    d4bc:	9d 83       	std	Y+5, r25	; 0x05
    d4be:	8c 83       	std	Y+4, r24	; 0x04
    d4c0:	8c 81       	ldd	r24, Y+4	; 0x04
    d4c2:	9d 81       	ldd	r25, Y+5	; 0x05
    d4c4:	fc 01       	movw	r30, r24
    d4c6:	14 91       	lpm	r17, Z
    d4c8:	1e 83       	std	Y+6, r17	; 0x06
    d4ca:	8e 81       	ldd	r24, Y+6	; 0x06
    d4cc:	89 83       	std	Y+1, r24	; 0x01
      tone_pins[i] = 255;
    d4ce:	8a 81       	ldd	r24, Y+2	; 0x02
    d4d0:	9b 81       	ldd	r25, Y+3	; 0x03
    d4d2:	8c 5b       	subi	r24, 0xBC	; 188
    d4d4:	9d 4f       	sbci	r25, 0xFD	; 253
    d4d6:	2f ef       	ldi	r18, 0xFF	; 255
    d4d8:	fc 01       	movw	r30, r24
    d4da:	20 83       	st	Z, r18

void noTone(uint8_t _pin)
{
  int8_t _timer = -1;
  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    d4dc:	8a 81       	ldd	r24, Y+2	; 0x02
    d4de:	9b 81       	ldd	r25, Y+3	; 0x03
    d4e0:	01 96       	adiw	r24, 0x01	; 1
    d4e2:	9b 83       	std	Y+3, r25	; 0x03
    d4e4:	8a 83       	std	Y+2, r24	; 0x02
    d4e6:	21 e0       	ldi	r18, 0x01	; 1
    d4e8:	8a 81       	ldd	r24, Y+2	; 0x02
    d4ea:	9b 81       	ldd	r25, Y+3	; 0x03
    d4ec:	18 16       	cp	r1, r24
    d4ee:	19 06       	cpc	r1, r25
    d4f0:	0c f4       	brge	.+2      	; 0xd4f4 <_Z6noToneh+0x74>
    d4f2:	20 e0       	ldi	r18, 0x00	; 0
    d4f4:	22 23       	and	r18, r18
    d4f6:	a9 f6       	brne	.-86     	; 0xd4a2 <_Z6noToneh+0x22>
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
      tone_pins[i] = 255;
    }
  }
  
  disableTimer(_timer);
    d4f8:	89 81       	ldd	r24, Y+1	; 0x01
    d4fa:	0e 94 ff 69 	call	0xd3fe	; 0xd3fe <_Z12disableTimerh>

  digitalWrite(_pin, 0);
    d4fe:	60 e0       	ldi	r22, 0x00	; 0
    d500:	8f 81       	ldd	r24, Y+7	; 0x07
    d502:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
}
    d506:	27 96       	adiw	r28, 0x07	; 7
    d508:	0f b6       	in	r0, 0x3f	; 63
    d50a:	f8 94       	cli
    d50c:	de bf       	out	0x3e, r29	; 62
    d50e:	0f be       	out	0x3f, r0	; 63
    d510:	cd bf       	out	0x3d, r28	; 61
    d512:	df 91       	pop	r29
    d514:	cf 91       	pop	r28
    d516:	1f 91       	pop	r17
    d518:	08 95       	ret

0000d51a <__vector_7>:
#endif


#ifdef USE_TIMER2
ISR(TIMER2_COMPA_vect)
{
    d51a:	1f 92       	push	r1
    d51c:	0f 92       	push	r0
    d51e:	00 90 5f 00 	lds	r0, 0x005F
    d522:	0f 92       	push	r0
    d524:	11 24       	eor	r1, r1
    d526:	2f 93       	push	r18
    d528:	3f 93       	push	r19
    d52a:	4f 93       	push	r20
    d52c:	5f 93       	push	r21
    d52e:	6f 93       	push	r22
    d530:	7f 93       	push	r23
    d532:	8f 93       	push	r24
    d534:	9f 93       	push	r25
    d536:	af 93       	push	r26
    d538:	bf 93       	push	r27
    d53a:	ef 93       	push	r30
    d53c:	ff 93       	push	r31
    d53e:	cf 93       	push	r28
    d540:	df 93       	push	r29
    d542:	cd b7       	in	r28, 0x3d	; 61
    d544:	de b7       	in	r29, 0x3e	; 62

  if (timer2_toggle_count != 0)
    d546:	80 91 fd 08 	lds	r24, 0x08FD
    d54a:	90 91 fe 08 	lds	r25, 0x08FE
    d54e:	a0 91 ff 08 	lds	r26, 0x08FF
    d552:	b0 91 00 09 	lds	r27, 0x0900
    d556:	21 e0       	ldi	r18, 0x01	; 1
    d558:	00 97       	sbiw	r24, 0x00	; 0
    d55a:	a1 05       	cpc	r26, r1
    d55c:	b1 05       	cpc	r27, r1
    d55e:	09 f4       	brne	.+2      	; 0xd562 <__vector_7+0x48>
    d560:	20 e0       	ldi	r18, 0x00	; 0
    d562:	22 23       	and	r18, r18
    d564:	a1 f1       	breq	.+104    	; 0xd5ce <__vector_7+0xb4>
  {
    // toggle the pin
    *timer2_pin_port ^= timer2_pin_mask;
    d566:	40 91 03 09 	lds	r20, 0x0903
    d56a:	80 91 01 09 	lds	r24, 0x0901
    d56e:	90 91 02 09 	lds	r25, 0x0902
    d572:	20 91 01 09 	lds	r18, 0x0901
    d576:	30 91 02 09 	lds	r19, 0x0902
    d57a:	f9 01       	movw	r30, r18
    d57c:	20 81       	ld	r18, Z
    d57e:	24 27       	eor	r18, r20
    d580:	fc 01       	movw	r30, r24
    d582:	20 83       	st	Z, r18

    if (timer2_toggle_count > 0)
    d584:	80 91 fd 08 	lds	r24, 0x08FD
    d588:	90 91 fe 08 	lds	r25, 0x08FE
    d58c:	a0 91 ff 08 	lds	r26, 0x08FF
    d590:	b0 91 00 09 	lds	r27, 0x0900
    d594:	21 e0       	ldi	r18, 0x01	; 1
    d596:	18 16       	cp	r1, r24
    d598:	19 06       	cpc	r1, r25
    d59a:	1a 06       	cpc	r1, r26
    d59c:	1b 06       	cpc	r1, r27
    d59e:	0c f0       	brlt	.+2      	; 0xd5a2 <__vector_7+0x88>
    d5a0:	20 e0       	ldi	r18, 0x00	; 0
    d5a2:	22 23       	and	r18, r18
    d5a4:	c1 f0       	breq	.+48     	; 0xd5d6 <__vector_7+0xbc>
      timer2_toggle_count--;
    d5a6:	80 91 fd 08 	lds	r24, 0x08FD
    d5aa:	90 91 fe 08 	lds	r25, 0x08FE
    d5ae:	a0 91 ff 08 	lds	r26, 0x08FF
    d5b2:	b0 91 00 09 	lds	r27, 0x0900
    d5b6:	01 97       	sbiw	r24, 0x01	; 1
    d5b8:	a1 09       	sbc	r26, r1
    d5ba:	b1 09       	sbc	r27, r1
    d5bc:	80 93 fd 08 	sts	0x08FD, r24
    d5c0:	90 93 fe 08 	sts	0x08FE, r25
    d5c4:	a0 93 ff 08 	sts	0x08FF, r26
    d5c8:	b0 93 00 09 	sts	0x0900, r27
    d5cc:	04 c0       	rjmp	.+8      	; 0xd5d6 <__vector_7+0xbc>
  else
  {
    // need to call noTone() so that the tone_pins[] entry is reset, so the
    // timer gets initialized next time we call tone().
    // XXX: this assumes timer 2 is always the first one used.
    noTone(tone_pins[0]);
    d5ce:	80 91 44 02 	lds	r24, 0x0244
    d5d2:	0e 94 40 6a 	call	0xd480	; 0xd480 <_Z6noToneh>
//    disableTimer(2);
//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
  }
}
    d5d6:	df 91       	pop	r29
    d5d8:	cf 91       	pop	r28
    d5da:	ff 91       	pop	r31
    d5dc:	ef 91       	pop	r30
    d5de:	bf 91       	pop	r27
    d5e0:	af 91       	pop	r26
    d5e2:	9f 91       	pop	r25
    d5e4:	8f 91       	pop	r24
    d5e6:	7f 91       	pop	r23
    d5e8:	6f 91       	pop	r22
    d5ea:	5f 91       	pop	r21
    d5ec:	4f 91       	pop	r20
    d5ee:	3f 91       	pop	r19
    d5f0:	2f 91       	pop	r18
    d5f2:	0f 90       	pop	r0
    d5f4:	00 92 5f 00 	sts	0x005F, r0
    d5f8:	0f 90       	pop	r0
    d5fa:	1f 90       	pop	r1
    d5fc:	18 95       	reti

0000d5fe <attachInterrupt>:
    d5fe:	cf 93       	push	r28
    d600:	df 93       	push	r29
    d602:	00 d0       	rcall	.+0      	; 0xd604 <attachInterrupt+0x6>
    d604:	00 d0       	rcall	.+0      	; 0xd606 <attachInterrupt+0x8>
    d606:	1f 92       	push	r1
    d608:	cd b7       	in	r28, 0x3d	; 61
    d60a:	de b7       	in	r29, 0x3e	; 62
    d60c:	89 83       	std	Y+1, r24	; 0x01
    d60e:	7b 83       	std	Y+3, r23	; 0x03
    d610:	6a 83       	std	Y+2, r22	; 0x02
    d612:	5d 83       	std	Y+5, r21	; 0x05
    d614:	4c 83       	std	Y+4, r20	; 0x04
    d616:	89 81       	ldd	r24, Y+1	; 0x01
    d618:	82 30       	cpi	r24, 0x02	; 2
    d61a:	08 f0       	brcs	.+2      	; 0xd61e <attachInterrupt+0x20>
    d61c:	49 c0       	rjmp	.+146    	; 0xd6b0 <attachInterrupt+0xb2>
    d61e:	89 81       	ldd	r24, Y+1	; 0x01
    d620:	88 2f       	mov	r24, r24
    d622:	90 e0       	ldi	r25, 0x00	; 0
    d624:	88 0f       	add	r24, r24
    d626:	99 1f       	adc	r25, r25
    d628:	8c 5f       	subi	r24, 0xFC	; 252
    d62a:	96 4f       	sbci	r25, 0xF6	; 246
    d62c:	2a 81       	ldd	r18, Y+2	; 0x02
    d62e:	3b 81       	ldd	r19, Y+3	; 0x03
    d630:	fc 01       	movw	r30, r24
    d632:	31 83       	std	Z+1, r19	; 0x01
    d634:	20 83       	st	Z, r18
    d636:	89 81       	ldd	r24, Y+1	; 0x01
    d638:	88 2f       	mov	r24, r24
    d63a:	90 e0       	ldi	r25, 0x00	; 0
    d63c:	81 30       	cpi	r24, 0x01	; 1
    d63e:	91 05       	cpc	r25, r1
    d640:	d9 f0       	breq	.+54     	; 0xd678 <attachInterrupt+0x7a>
    d642:	82 30       	cpi	r24, 0x02	; 2
    d644:	91 05       	cpc	r25, r1
    d646:	99 f1       	breq	.+102    	; 0xd6ae <attachInterrupt+0xb0>
    d648:	00 97       	sbiw	r24, 0x00	; 0
    d64a:	91 f5       	brne	.+100    	; 0xd6b0 <attachInterrupt+0xb2>
    d64c:	89 e6       	ldi	r24, 0x69	; 105
    d64e:	90 e0       	ldi	r25, 0x00	; 0
    d650:	29 e6       	ldi	r18, 0x69	; 105
    d652:	30 e0       	ldi	r19, 0x00	; 0
    d654:	f9 01       	movw	r30, r18
    d656:	20 81       	ld	r18, Z
    d658:	32 2f       	mov	r19, r18
    d65a:	3c 7f       	andi	r19, 0xFC	; 252
    d65c:	2c 81       	ldd	r18, Y+4	; 0x04
    d65e:	23 2b       	or	r18, r19
    d660:	fc 01       	movw	r30, r24
    d662:	20 83       	st	Z, r18
    d664:	8d e3       	ldi	r24, 0x3D	; 61
    d666:	90 e0       	ldi	r25, 0x00	; 0
    d668:	2d e3       	ldi	r18, 0x3D	; 61
    d66a:	30 e0       	ldi	r19, 0x00	; 0
    d66c:	f9 01       	movw	r30, r18
    d66e:	20 81       	ld	r18, Z
    d670:	21 60       	ori	r18, 0x01	; 1
    d672:	fc 01       	movw	r30, r24
    d674:	20 83       	st	Z, r18
    d676:	1c c0       	rjmp	.+56     	; 0xd6b0 <attachInterrupt+0xb2>
    d678:	89 e6       	ldi	r24, 0x69	; 105
    d67a:	90 e0       	ldi	r25, 0x00	; 0
    d67c:	29 e6       	ldi	r18, 0x69	; 105
    d67e:	30 e0       	ldi	r19, 0x00	; 0
    d680:	f9 01       	movw	r30, r18
    d682:	20 81       	ld	r18, Z
    d684:	42 2f       	mov	r20, r18
    d686:	43 7f       	andi	r20, 0xF3	; 243
    d688:	2c 81       	ldd	r18, Y+4	; 0x04
    d68a:	3d 81       	ldd	r19, Y+5	; 0x05
    d68c:	22 0f       	add	r18, r18
    d68e:	33 1f       	adc	r19, r19
    d690:	22 0f       	add	r18, r18
    d692:	33 1f       	adc	r19, r19
    d694:	24 2b       	or	r18, r20
    d696:	fc 01       	movw	r30, r24
    d698:	20 83       	st	Z, r18
    d69a:	8d e3       	ldi	r24, 0x3D	; 61
    d69c:	90 e0       	ldi	r25, 0x00	; 0
    d69e:	2d e3       	ldi	r18, 0x3D	; 61
    d6a0:	30 e0       	ldi	r19, 0x00	; 0
    d6a2:	f9 01       	movw	r30, r18
    d6a4:	20 81       	ld	r18, Z
    d6a6:	22 60       	ori	r18, 0x02	; 2
    d6a8:	fc 01       	movw	r30, r24
    d6aa:	20 83       	st	Z, r18
    d6ac:	01 c0       	rjmp	.+2      	; 0xd6b0 <attachInterrupt+0xb2>
    d6ae:	00 00       	nop
    d6b0:	0f 90       	pop	r0
    d6b2:	0f 90       	pop	r0
    d6b4:	0f 90       	pop	r0
    d6b6:	0f 90       	pop	r0
    d6b8:	0f 90       	pop	r0
    d6ba:	df 91       	pop	r29
    d6bc:	cf 91       	pop	r28
    d6be:	08 95       	ret

0000d6c0 <detachInterrupt>:
#endif
    }
  }
}

void detachInterrupt(uint8_t interruptNum) {
    d6c0:	cf 93       	push	r28
    d6c2:	df 93       	push	r29
    d6c4:	1f 92       	push	r1
    d6c6:	cd b7       	in	r28, 0x3d	; 61
    d6c8:	de b7       	in	r29, 0x3e	; 62
    d6ca:	89 83       	std	Y+1, r24	; 0x01
  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
    d6cc:	89 81       	ldd	r24, Y+1	; 0x01
    d6ce:	82 30       	cpi	r24, 0x02	; 2
    d6d0:	38 f5       	brcc	.+78     	; 0xd720 <detachInterrupt+0x60>
    // Disable the interrupt.  (We can't assume that interruptNum is equal
    // to the number of the EIMSK bit to clear, as this isn't true on the 
    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
    switch (interruptNum) {
    d6d2:	89 81       	ldd	r24, Y+1	; 0x01
    d6d4:	88 2f       	mov	r24, r24
    d6d6:	90 e0       	ldi	r25, 0x00	; 0
    d6d8:	00 97       	sbiw	r24, 0x00	; 0
    d6da:	21 f0       	breq	.+8      	; 0xd6e4 <detachInterrupt+0x24>
    d6dc:	81 30       	cpi	r24, 0x01	; 1
    d6de:	91 05       	cpc	r25, r1
    d6e0:	59 f0       	breq	.+22     	; 0xd6f8 <detachInterrupt+0x38>
    d6e2:	14 c0       	rjmp	.+40     	; 0xd70c <detachInterrupt+0x4c>
      EIMSK &= ~(1 << INT7);
      break;
#else
    case 0:
    #if defined(EIMSK) && defined(INT0)
      EIMSK &= ~(1 << INT0);
    d6e4:	8d e3       	ldi	r24, 0x3D	; 61
    d6e6:	90 e0       	ldi	r25, 0x00	; 0
    d6e8:	2d e3       	ldi	r18, 0x3D	; 61
    d6ea:	30 e0       	ldi	r19, 0x00	; 0
    d6ec:	f9 01       	movw	r30, r18
    d6ee:	20 81       	ld	r18, Z
    d6f0:	2e 7f       	andi	r18, 0xFE	; 254
    d6f2:	fc 01       	movw	r30, r24
    d6f4:	20 83       	st	Z, r18
    #elif defined(GIMSK) && defined(INT0)
      GIMSK &= ~(1 << INT0);
    #else
      #error detachInterrupt not finished for this cpu
    #endif
      break;
    d6f6:	0a c0       	rjmp	.+20     	; 0xd70c <detachInterrupt+0x4c>

    case 1:
    #if defined(EIMSK) && defined(INT1)
      EIMSK &= ~(1 << INT1);
    d6f8:	8d e3       	ldi	r24, 0x3D	; 61
    d6fa:	90 e0       	ldi	r25, 0x00	; 0
    d6fc:	2d e3       	ldi	r18, 0x3D	; 61
    d6fe:	30 e0       	ldi	r19, 0x00	; 0
    d700:	f9 01       	movw	r30, r18
    d702:	20 81       	ld	r18, Z
    d704:	2d 7f       	andi	r18, 0xFD	; 253
    d706:	fc 01       	movw	r30, r24
    d708:	20 83       	st	Z, r18
    #elif defined(GIMSK) && defined(INT1)
      GIMSK &= ~(1 << INT1);
    #else
      #warning detachInterrupt may need some more work for this cpu (case 1)
    #endif
      break;
    d70a:	00 00       	nop
#endif
    }
      
    intFunc[interruptNum] = 0;
    d70c:	89 81       	ldd	r24, Y+1	; 0x01
    d70e:	88 2f       	mov	r24, r24
    d710:	90 e0       	ldi	r25, 0x00	; 0
    d712:	88 0f       	add	r24, r24
    d714:	99 1f       	adc	r25, r25
    d716:	8c 5f       	subi	r24, 0xFC	; 252
    d718:	96 4f       	sbci	r25, 0xF6	; 246
    d71a:	fc 01       	movw	r30, r24
    d71c:	11 82       	std	Z+1, r1	; 0x01
    d71e:	10 82       	st	Z, r1
  }
}
    d720:	0f 90       	pop	r0
    d722:	df 91       	pop	r29
    d724:	cf 91       	pop	r28
    d726:	08 95       	ret

0000d728 <__vector_1>:
    intFunc[EXTERNAL_INT_7]();
}

#else

SIGNAL(INT0_vect) {
    d728:	1f 92       	push	r1
    d72a:	0f 92       	push	r0
    d72c:	00 90 5f 00 	lds	r0, 0x005F
    d730:	0f 92       	push	r0
    d732:	11 24       	eor	r1, r1
    d734:	2f 93       	push	r18
    d736:	3f 93       	push	r19
    d738:	4f 93       	push	r20
    d73a:	5f 93       	push	r21
    d73c:	6f 93       	push	r22
    d73e:	7f 93       	push	r23
    d740:	8f 93       	push	r24
    d742:	9f 93       	push	r25
    d744:	af 93       	push	r26
    d746:	bf 93       	push	r27
    d748:	ef 93       	push	r30
    d74a:	ff 93       	push	r31
    d74c:	cf 93       	push	r28
    d74e:	df 93       	push	r29
    d750:	cd b7       	in	r28, 0x3d	; 61
    d752:	de b7       	in	r29, 0x3e	; 62
  if(intFunc[EXTERNAL_INT_0])
    d754:	80 91 04 09 	lds	r24, 0x0904
    d758:	90 91 05 09 	lds	r25, 0x0905
    d75c:	00 97       	sbiw	r24, 0x00	; 0
    d75e:	31 f0       	breq	.+12     	; 0xd76c <__vector_1+0x44>
    intFunc[EXTERNAL_INT_0]();
    d760:	80 91 04 09 	lds	r24, 0x0904
    d764:	90 91 05 09 	lds	r25, 0x0905
    d768:	fc 01       	movw	r30, r24
    d76a:	09 95       	icall
}
    d76c:	df 91       	pop	r29
    d76e:	cf 91       	pop	r28
    d770:	ff 91       	pop	r31
    d772:	ef 91       	pop	r30
    d774:	bf 91       	pop	r27
    d776:	af 91       	pop	r26
    d778:	9f 91       	pop	r25
    d77a:	8f 91       	pop	r24
    d77c:	7f 91       	pop	r23
    d77e:	6f 91       	pop	r22
    d780:	5f 91       	pop	r21
    d782:	4f 91       	pop	r20
    d784:	3f 91       	pop	r19
    d786:	2f 91       	pop	r18
    d788:	0f 90       	pop	r0
    d78a:	00 92 5f 00 	sts	0x005F, r0
    d78e:	0f 90       	pop	r0
    d790:	1f 90       	pop	r1
    d792:	18 95       	reti

0000d794 <__vector_2>:

SIGNAL(INT1_vect) {
    d794:	1f 92       	push	r1
    d796:	0f 92       	push	r0
    d798:	00 90 5f 00 	lds	r0, 0x005F
    d79c:	0f 92       	push	r0
    d79e:	11 24       	eor	r1, r1
    d7a0:	2f 93       	push	r18
    d7a2:	3f 93       	push	r19
    d7a4:	4f 93       	push	r20
    d7a6:	5f 93       	push	r21
    d7a8:	6f 93       	push	r22
    d7aa:	7f 93       	push	r23
    d7ac:	8f 93       	push	r24
    d7ae:	9f 93       	push	r25
    d7b0:	af 93       	push	r26
    d7b2:	bf 93       	push	r27
    d7b4:	ef 93       	push	r30
    d7b6:	ff 93       	push	r31
    d7b8:	cf 93       	push	r28
    d7ba:	df 93       	push	r29
    d7bc:	cd b7       	in	r28, 0x3d	; 61
    d7be:	de b7       	in	r29, 0x3e	; 62
  if(intFunc[EXTERNAL_INT_1])
    d7c0:	80 91 06 09 	lds	r24, 0x0906
    d7c4:	90 91 07 09 	lds	r25, 0x0907
    d7c8:	00 97       	sbiw	r24, 0x00	; 0
    d7ca:	31 f0       	breq	.+12     	; 0xd7d8 <__vector_2+0x44>
    intFunc[EXTERNAL_INT_1]();
    d7cc:	80 91 06 09 	lds	r24, 0x0906
    d7d0:	90 91 07 09 	lds	r25, 0x0907
    d7d4:	fc 01       	movw	r30, r24
    d7d6:	09 95       	icall
}
    d7d8:	df 91       	pop	r29
    d7da:	cf 91       	pop	r28
    d7dc:	ff 91       	pop	r31
    d7de:	ef 91       	pop	r30
    d7e0:	bf 91       	pop	r27
    d7e2:	af 91       	pop	r26
    d7e4:	9f 91       	pop	r25
    d7e6:	8f 91       	pop	r24
    d7e8:	7f 91       	pop	r23
    d7ea:	6f 91       	pop	r22
    d7ec:	5f 91       	pop	r21
    d7ee:	4f 91       	pop	r20
    d7f0:	3f 91       	pop	r19
    d7f2:	2f 91       	pop	r18
    d7f4:	0f 90       	pop	r0
    d7f6:	00 92 5f 00 	sts	0x005F, r0
    d7fa:	0f 90       	pop	r0
    d7fc:	1f 90       	pop	r1
    d7fe:	18 95       	reti

0000d800 <_Z10randomSeedj>:
extern "C" {
  #include "stdlib.h"
}

void randomSeed(unsigned int seed)
{
    d800:	cf 93       	push	r28
    d802:	df 93       	push	r29
    d804:	00 d0       	rcall	.+0      	; 0xd806 <_Z10randomSeedj+0x6>
    d806:	cd b7       	in	r28, 0x3d	; 61
    d808:	de b7       	in	r29, 0x3e	; 62
    d80a:	9a 83       	std	Y+2, r25	; 0x02
    d80c:	89 83       	std	Y+1, r24	; 0x01
  if (seed != 0) {
    d80e:	89 81       	ldd	r24, Y+1	; 0x01
    d810:	9a 81       	ldd	r25, Y+2	; 0x02
    d812:	00 97       	sbiw	r24, 0x00	; 0
    d814:	49 f0       	breq	.+18     	; 0xd828 <_Z10randomSeedj+0x28>
    srandom(seed);
    d816:	89 81       	ldd	r24, Y+1	; 0x01
    d818:	9a 81       	ldd	r25, Y+2	; 0x02
    d81a:	cc 01       	movw	r24, r24
    d81c:	a0 e0       	ldi	r26, 0x00	; 0
    d81e:	b0 e0       	ldi	r27, 0x00	; 0
    d820:	bc 01       	movw	r22, r24
    d822:	cd 01       	movw	r24, r26
    d824:	0e 94 dc af 	call	0x15fb8	; 0x15fb8 <srandom>
  }
}
    d828:	0f 90       	pop	r0
    d82a:	0f 90       	pop	r0
    d82c:	df 91       	pop	r29
    d82e:	cf 91       	pop	r28
    d830:	08 95       	ret

0000d832 <_Z6randoml>:

long random(long howbig)
{
    d832:	cf 93       	push	r28
    d834:	df 93       	push	r29
    d836:	00 d0       	rcall	.+0      	; 0xd838 <_Z6randoml+0x6>
    d838:	00 d0       	rcall	.+0      	; 0xd83a <_Z6randoml+0x8>
    d83a:	cd b7       	in	r28, 0x3d	; 61
    d83c:	de b7       	in	r29, 0x3e	; 62
    d83e:	69 83       	std	Y+1, r22	; 0x01
    d840:	7a 83       	std	Y+2, r23	; 0x02
    d842:	8b 83       	std	Y+3, r24	; 0x03
    d844:	9c 83       	std	Y+4, r25	; 0x04
  if (howbig == 0) {
    d846:	89 81       	ldd	r24, Y+1	; 0x01
    d848:	9a 81       	ldd	r25, Y+2	; 0x02
    d84a:	ab 81       	ldd	r26, Y+3	; 0x03
    d84c:	bc 81       	ldd	r27, Y+4	; 0x04
    d84e:	00 97       	sbiw	r24, 0x00	; 0
    d850:	a1 05       	cpc	r26, r1
    d852:	b1 05       	cpc	r27, r1
    d854:	21 f4       	brne	.+8      	; 0xd85e <_Z6randoml+0x2c>
    return 0;
    d856:	80 e0       	ldi	r24, 0x00	; 0
    d858:	90 e0       	ldi	r25, 0x00	; 0
    d85a:	dc 01       	movw	r26, r24
    d85c:	0e c0       	rjmp	.+28     	; 0xd87a <_Z6randoml+0x48>
  }
  return random() % howbig;
    d85e:	0e 94 d7 af 	call	0x15fae	; 0x15fae <random>
    d862:	dc 01       	movw	r26, r24
    d864:	cb 01       	movw	r24, r22
    d866:	29 81       	ldd	r18, Y+1	; 0x01
    d868:	3a 81       	ldd	r19, Y+2	; 0x02
    d86a:	4b 81       	ldd	r20, Y+3	; 0x03
    d86c:	5c 81       	ldd	r21, Y+4	; 0x04
    d86e:	bc 01       	movw	r22, r24
    d870:	cd 01       	movw	r24, r26
    d872:	0e 94 cf ad 	call	0x15b9e	; 0x15b9e <__divmodsi4>
    d876:	dc 01       	movw	r26, r24
    d878:	cb 01       	movw	r24, r22
}
    d87a:	bc 01       	movw	r22, r24
    d87c:	cd 01       	movw	r24, r26
    d87e:	0f 90       	pop	r0
    d880:	0f 90       	pop	r0
    d882:	0f 90       	pop	r0
    d884:	0f 90       	pop	r0
    d886:	df 91       	pop	r29
    d888:	cf 91       	pop	r28
    d88a:	08 95       	ret

0000d88c <_Z6randomll>:

long random(long howsmall, long howbig)
{
    d88c:	ef 92       	push	r14
    d88e:	ff 92       	push	r15
    d890:	0f 93       	push	r16
    d892:	1f 93       	push	r17
    d894:	cf 93       	push	r28
    d896:	df 93       	push	r29
    d898:	cd b7       	in	r28, 0x3d	; 61
    d89a:	de b7       	in	r29, 0x3e	; 62
    d89c:	2c 97       	sbiw	r28, 0x0c	; 12
    d89e:	0f b6       	in	r0, 0x3f	; 63
    d8a0:	f8 94       	cli
    d8a2:	de bf       	out	0x3e, r29	; 62
    d8a4:	0f be       	out	0x3f, r0	; 63
    d8a6:	cd bf       	out	0x3d, r28	; 61
    d8a8:	6d 83       	std	Y+5, r22	; 0x05
    d8aa:	7e 83       	std	Y+6, r23	; 0x06
    d8ac:	8f 83       	std	Y+7, r24	; 0x07
    d8ae:	98 87       	std	Y+8, r25	; 0x08
    d8b0:	29 87       	std	Y+9, r18	; 0x09
    d8b2:	3a 87       	std	Y+10, r19	; 0x0a
    d8b4:	4b 87       	std	Y+11, r20	; 0x0b
    d8b6:	5c 87       	std	Y+12, r21	; 0x0c
  if (howsmall >= howbig) {
    d8b8:	2d 81       	ldd	r18, Y+5	; 0x05
    d8ba:	3e 81       	ldd	r19, Y+6	; 0x06
    d8bc:	4f 81       	ldd	r20, Y+7	; 0x07
    d8be:	58 85       	ldd	r21, Y+8	; 0x08
    d8c0:	89 85       	ldd	r24, Y+9	; 0x09
    d8c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    d8c4:	ab 85       	ldd	r26, Y+11	; 0x0b
    d8c6:	bc 85       	ldd	r27, Y+12	; 0x0c
    d8c8:	28 17       	cp	r18, r24
    d8ca:	39 07       	cpc	r19, r25
    d8cc:	4a 07       	cpc	r20, r26
    d8ce:	5b 07       	cpc	r21, r27
    d8d0:	2c f0       	brlt	.+10     	; 0xd8dc <_Z6randomll+0x50>
    return howsmall;
    d8d2:	8d 81       	ldd	r24, Y+5	; 0x05
    d8d4:	9e 81       	ldd	r25, Y+6	; 0x06
    d8d6:	af 81       	ldd	r26, Y+7	; 0x07
    d8d8:	b8 85       	ldd	r27, Y+8	; 0x08
    d8da:	26 c0       	rjmp	.+76     	; 0xd928 <_Z6randomll+0x9c>
  }
  long diff = howbig - howsmall;
    d8dc:	29 85       	ldd	r18, Y+9	; 0x09
    d8de:	3a 85       	ldd	r19, Y+10	; 0x0a
    d8e0:	4b 85       	ldd	r20, Y+11	; 0x0b
    d8e2:	5c 85       	ldd	r21, Y+12	; 0x0c
    d8e4:	8d 81       	ldd	r24, Y+5	; 0x05
    d8e6:	9e 81       	ldd	r25, Y+6	; 0x06
    d8e8:	af 81       	ldd	r26, Y+7	; 0x07
    d8ea:	b8 85       	ldd	r27, Y+8	; 0x08
    d8ec:	79 01       	movw	r14, r18
    d8ee:	8a 01       	movw	r16, r20
    d8f0:	e8 1a       	sub	r14, r24
    d8f2:	f9 0a       	sbc	r15, r25
    d8f4:	0a 0b       	sbc	r16, r26
    d8f6:	1b 0b       	sbc	r17, r27
    d8f8:	d8 01       	movw	r26, r16
    d8fa:	c7 01       	movw	r24, r14
    d8fc:	89 83       	std	Y+1, r24	; 0x01
    d8fe:	9a 83       	std	Y+2, r25	; 0x02
    d900:	ab 83       	std	Y+3, r26	; 0x03
    d902:	bc 83       	std	Y+4, r27	; 0x04
  return random(diff) + howsmall;
    d904:	89 81       	ldd	r24, Y+1	; 0x01
    d906:	9a 81       	ldd	r25, Y+2	; 0x02
    d908:	ab 81       	ldd	r26, Y+3	; 0x03
    d90a:	bc 81       	ldd	r27, Y+4	; 0x04
    d90c:	bc 01       	movw	r22, r24
    d90e:	cd 01       	movw	r24, r26
    d910:	0e 94 19 6c 	call	0xd832	; 0xd832 <_Z6randoml>
    d914:	9b 01       	movw	r18, r22
    d916:	ac 01       	movw	r20, r24
    d918:	8d 81       	ldd	r24, Y+5	; 0x05
    d91a:	9e 81       	ldd	r25, Y+6	; 0x06
    d91c:	af 81       	ldd	r26, Y+7	; 0x07
    d91e:	b8 85       	ldd	r27, Y+8	; 0x08
    d920:	82 0f       	add	r24, r18
    d922:	93 1f       	adc	r25, r19
    d924:	a4 1f       	adc	r26, r20
    d926:	b5 1f       	adc	r27, r21
}
    d928:	bc 01       	movw	r22, r24
    d92a:	cd 01       	movw	r24, r26
    d92c:	2c 96       	adiw	r28, 0x0c	; 12
    d92e:	0f b6       	in	r0, 0x3f	; 63
    d930:	f8 94       	cli
    d932:	de bf       	out	0x3e, r29	; 62
    d934:	0f be       	out	0x3f, r0	; 63
    d936:	cd bf       	out	0x3d, r28	; 61
    d938:	df 91       	pop	r29
    d93a:	cf 91       	pop	r28
    d93c:	1f 91       	pop	r17
    d93e:	0f 91       	pop	r16
    d940:	ff 90       	pop	r15
    d942:	ef 90       	pop	r14
    d944:	08 95       	ret

0000d946 <_Z3maplllll>:

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
    d946:	af 92       	push	r10
    d948:	bf 92       	push	r11
    d94a:	cf 92       	push	r12
    d94c:	df 92       	push	r13
    d94e:	ef 92       	push	r14
    d950:	ff 92       	push	r15
    d952:	0f 93       	push	r16
    d954:	1f 93       	push	r17
    d956:	cf 93       	push	r28
    d958:	df 93       	push	r29
    d95a:	cd b7       	in	r28, 0x3d	; 61
    d95c:	de b7       	in	r29, 0x3e	; 62
    d95e:	60 97       	sbiw	r28, 0x10	; 16
    d960:	0f b6       	in	r0, 0x3f	; 63
    d962:	f8 94       	cli
    d964:	de bf       	out	0x3e, r29	; 62
    d966:	0f be       	out	0x3f, r0	; 63
    d968:	cd bf       	out	0x3d, r28	; 61
    d96a:	69 83       	std	Y+1, r22	; 0x01
    d96c:	7a 83       	std	Y+2, r23	; 0x02
    d96e:	8b 83       	std	Y+3, r24	; 0x03
    d970:	9c 83       	std	Y+4, r25	; 0x04
    d972:	2d 83       	std	Y+5, r18	; 0x05
    d974:	3e 83       	std	Y+6, r19	; 0x06
    d976:	4f 83       	std	Y+7, r20	; 0x07
    d978:	58 87       	std	Y+8, r21	; 0x08
    d97a:	e9 86       	std	Y+9, r14	; 0x09
    d97c:	fa 86       	std	Y+10, r15	; 0x0a
    d97e:	0b 87       	std	Y+11, r16	; 0x0b
    d980:	1c 87       	std	Y+12, r17	; 0x0c
    d982:	ad 86       	std	Y+13, r10	; 0x0d
    d984:	be 86       	std	Y+14, r11	; 0x0e
    d986:	cf 86       	std	Y+15, r12	; 0x0f
    d988:	d8 8a       	std	Y+16, r13	; 0x10
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    d98a:	29 81       	ldd	r18, Y+1	; 0x01
    d98c:	3a 81       	ldd	r19, Y+2	; 0x02
    d98e:	4b 81       	ldd	r20, Y+3	; 0x03
    d990:	5c 81       	ldd	r21, Y+4	; 0x04
    d992:	8d 81       	ldd	r24, Y+5	; 0x05
    d994:	9e 81       	ldd	r25, Y+6	; 0x06
    d996:	af 81       	ldd	r26, Y+7	; 0x07
    d998:	b8 85       	ldd	r27, Y+8	; 0x08
    d99a:	28 1b       	sub	r18, r24
    d99c:	39 0b       	sbc	r19, r25
    d99e:	4a 0b       	sbc	r20, r26
    d9a0:	5b 0b       	sbc	r21, r27
    d9a2:	ed 8c       	ldd	r14, Y+29	; 0x1d
    d9a4:	fe 8c       	ldd	r15, Y+30	; 0x1e
    d9a6:	0f 8d       	ldd	r16, Y+31	; 0x1f
    d9a8:	18 a1       	ldd	r17, Y+32	; 0x20
    d9aa:	8d 85       	ldd	r24, Y+13	; 0x0d
    d9ac:	9e 85       	ldd	r25, Y+14	; 0x0e
    d9ae:	af 85       	ldd	r26, Y+15	; 0x0f
    d9b0:	b8 89       	ldd	r27, Y+16	; 0x10
    d9b2:	57 01       	movw	r10, r14
    d9b4:	68 01       	movw	r12, r16
    d9b6:	a8 1a       	sub	r10, r24
    d9b8:	b9 0a       	sbc	r11, r25
    d9ba:	ca 0a       	sbc	r12, r26
    d9bc:	db 0a       	sbc	r13, r27
    d9be:	d6 01       	movw	r26, r12
    d9c0:	c5 01       	movw	r24, r10
    d9c2:	bc 01       	movw	r22, r24
    d9c4:	cd 01       	movw	r24, r26
    d9c6:	0e 94 9d ad 	call	0x15b3a	; 0x15b3a <__mulsi3>
    d9ca:	dc 01       	movw	r26, r24
    d9cc:	cb 01       	movw	r24, r22
    d9ce:	e9 84       	ldd	r14, Y+9	; 0x09
    d9d0:	fa 84       	ldd	r15, Y+10	; 0x0a
    d9d2:	0b 85       	ldd	r16, Y+11	; 0x0b
    d9d4:	1c 85       	ldd	r17, Y+12	; 0x0c
    d9d6:	2d 81       	ldd	r18, Y+5	; 0x05
    d9d8:	3e 81       	ldd	r19, Y+6	; 0x06
    d9da:	4f 81       	ldd	r20, Y+7	; 0x07
    d9dc:	58 85       	ldd	r21, Y+8	; 0x08
    d9de:	57 01       	movw	r10, r14
    d9e0:	68 01       	movw	r12, r16
    d9e2:	a2 1a       	sub	r10, r18
    d9e4:	b3 0a       	sbc	r11, r19
    d9e6:	c4 0a       	sbc	r12, r20
    d9e8:	d5 0a       	sbc	r13, r21
    d9ea:	a6 01       	movw	r20, r12
    d9ec:	95 01       	movw	r18, r10
    d9ee:	bc 01       	movw	r22, r24
    d9f0:	cd 01       	movw	r24, r26
    d9f2:	0e 94 cf ad 	call	0x15b9e	; 0x15b9e <__divmodsi4>
    d9f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    d9f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    d9fa:	af 85       	ldd	r26, Y+15	; 0x0f
    d9fc:	b8 89       	ldd	r27, Y+16	; 0x10
    d9fe:	82 0f       	add	r24, r18
    da00:	93 1f       	adc	r25, r19
    da02:	a4 1f       	adc	r26, r20
    da04:	b5 1f       	adc	r27, r21
}
    da06:	bc 01       	movw	r22, r24
    da08:	cd 01       	movw	r24, r26
    da0a:	60 96       	adiw	r28, 0x10	; 16
    da0c:	0f b6       	in	r0, 0x3f	; 63
    da0e:	f8 94       	cli
    da10:	de bf       	out	0x3e, r29	; 62
    da12:	0f be       	out	0x3f, r0	; 63
    da14:	cd bf       	out	0x3d, r28	; 61
    da16:	df 91       	pop	r29
    da18:	cf 91       	pop	r28
    da1a:	1f 91       	pop	r17
    da1c:	0f 91       	pop	r16
    da1e:	ff 90       	pop	r15
    da20:	ef 90       	pop	r14
    da22:	df 90       	pop	r13
    da24:	cf 90       	pop	r12
    da26:	bf 90       	pop	r11
    da28:	af 90       	pop	r10
    da2a:	08 95       	ret

0000da2c <_Z8makeWordj>:

unsigned int makeWord(unsigned int w) { return w; }
    da2c:	cf 93       	push	r28
    da2e:	df 93       	push	r29
    da30:	00 d0       	rcall	.+0      	; 0xda32 <_Z8makeWordj+0x6>
    da32:	cd b7       	in	r28, 0x3d	; 61
    da34:	de b7       	in	r29, 0x3e	; 62
    da36:	9a 83       	std	Y+2, r25	; 0x02
    da38:	89 83       	std	Y+1, r24	; 0x01
    da3a:	89 81       	ldd	r24, Y+1	; 0x01
    da3c:	9a 81       	ldd	r25, Y+2	; 0x02
    da3e:	0f 90       	pop	r0
    da40:	0f 90       	pop	r0
    da42:	df 91       	pop	r29
    da44:	cf 91       	pop	r28
    da46:	08 95       	ret

0000da48 <_Z8makeWordhh>:
    da48:	cf 93       	push	r28
    da4a:	df 93       	push	r29
    da4c:	00 d0       	rcall	.+0      	; 0xda4e <_Z8makeWordhh+0x6>
    da4e:	cd b7       	in	r28, 0x3d	; 61
    da50:	de b7       	in	r29, 0x3e	; 62
    da52:	89 83       	std	Y+1, r24	; 0x01
    da54:	6a 83       	std	Y+2, r22	; 0x02
    da56:	89 81       	ldd	r24, Y+1	; 0x01
    da58:	88 2f       	mov	r24, r24
    da5a:	90 e0       	ldi	r25, 0x00	; 0
    da5c:	38 2f       	mov	r19, r24
    da5e:	22 27       	eor	r18, r18
    da60:	8a 81       	ldd	r24, Y+2	; 0x02
    da62:	88 2f       	mov	r24, r24
    da64:	90 e0       	ldi	r25, 0x00	; 0
    da66:	82 2b       	or	r24, r18
    da68:	93 2b       	or	r25, r19
    da6a:	0f 90       	pop	r0
    da6c:	0f 90       	pop	r0
    da6e:	df 91       	pop	r29
    da70:	cf 91       	pop	r28
    da72:	08 95       	ret

0000da74 <_ZN6StringC1EPKc>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    da74:	cf 93       	push	r28
    da76:	df 93       	push	r29
    da78:	00 d0       	rcall	.+0      	; 0xda7a <_ZN6StringC1EPKc+0x6>
    da7a:	00 d0       	rcall	.+0      	; 0xda7c <_ZN6StringC1EPKc+0x8>
    da7c:	cd b7       	in	r28, 0x3d	; 61
    da7e:	de b7       	in	r29, 0x3e	; 62
    da80:	9a 83       	std	Y+2, r25	; 0x02
    da82:	89 83       	std	Y+1, r24	; 0x01
    da84:	7c 83       	std	Y+4, r23	; 0x04
    da86:	6b 83       	std	Y+3, r22	; 0x03
{
	init();
    da88:	89 81       	ldd	r24, Y+1	; 0x01
    da8a:	9a 81       	ldd	r25, Y+2	; 0x02
    da8c:	0e 94 5f ad 	call	0x15abe	; 0x15abe <_ZN6String4initEv>
	if (cstr) copy(cstr, strlen(cstr));
    da90:	8b 81       	ldd	r24, Y+3	; 0x03
    da92:	9c 81       	ldd	r25, Y+4	; 0x04
    da94:	00 97       	sbiw	r24, 0x00	; 0
    da96:	61 f0       	breq	.+24     	; 0xdab0 <_ZN6StringC1EPKc+0x3c>
    da98:	8b 81       	ldd	r24, Y+3	; 0x03
    da9a:	9c 81       	ldd	r25, Y+4	; 0x04
    da9c:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    daa0:	ac 01       	movw	r20, r24
    daa2:	2b 81       	ldd	r18, Y+3	; 0x03
    daa4:	3c 81       	ldd	r19, Y+4	; 0x04
    daa6:	89 81       	ldd	r24, Y+1	; 0x01
    daa8:	9a 81       	ldd	r25, Y+2	; 0x02
    daaa:	b9 01       	movw	r22, r18
    daac:	0e 94 50 6f 	call	0xdea0	; 0xdea0 <_ZN6String4copyEPKcj>
}
    dab0:	0f 90       	pop	r0
    dab2:	0f 90       	pop	r0
    dab4:	0f 90       	pop	r0
    dab6:	0f 90       	pop	r0
    dab8:	df 91       	pop	r29
    daba:	cf 91       	pop	r28
    dabc:	08 95       	ret

0000dabe <_ZN6StringC1ERKS_>:

String::String(const String &value)
    dabe:	cf 93       	push	r28
    dac0:	df 93       	push	r29
    dac2:	00 d0       	rcall	.+0      	; 0xdac4 <_ZN6StringC1ERKS_+0x6>
    dac4:	00 d0       	rcall	.+0      	; 0xdac6 <_ZN6StringC1ERKS_+0x8>
    dac6:	cd b7       	in	r28, 0x3d	; 61
    dac8:	de b7       	in	r29, 0x3e	; 62
    daca:	9a 83       	std	Y+2, r25	; 0x02
    dacc:	89 83       	std	Y+1, r24	; 0x01
    dace:	7c 83       	std	Y+4, r23	; 0x04
    dad0:	6b 83       	std	Y+3, r22	; 0x03
{
	init();
    dad2:	89 81       	ldd	r24, Y+1	; 0x01
    dad4:	9a 81       	ldd	r25, Y+2	; 0x02
    dad6:	0e 94 5f ad 	call	0x15abe	; 0x15abe <_ZN6String4initEv>
	*this = value;
    dada:	2b 81       	ldd	r18, Y+3	; 0x03
    dadc:	3c 81       	ldd	r19, Y+4	; 0x04
    dade:	89 81       	ldd	r24, Y+1	; 0x01
    dae0:	9a 81       	ldd	r25, Y+2	; 0x02
    dae2:	b9 01       	movw	r22, r18
    dae4:	0e 94 8e 6f 	call	0xdf1c	; 0xdf1c <_ZN6StringaSERKS_>
}
    dae8:	0f 90       	pop	r0
    daea:	0f 90       	pop	r0
    daec:	0f 90       	pop	r0
    daee:	0f 90       	pop	r0
    daf0:	df 91       	pop	r29
    daf2:	cf 91       	pop	r28
    daf4:	08 95       	ret

0000daf6 <_ZN6StringC1Ec>:
	init();
	move(rval);
}
#endif

String::String(char c)
    daf6:	cf 93       	push	r28
    daf8:	df 93       	push	r29
    dafa:	00 d0       	rcall	.+0      	; 0xdafc <_ZN6StringC1Ec+0x6>
    dafc:	00 d0       	rcall	.+0      	; 0xdafe <_ZN6StringC1Ec+0x8>
    dafe:	1f 92       	push	r1
    db00:	cd b7       	in	r28, 0x3d	; 61
    db02:	de b7       	in	r29, 0x3e	; 62
    db04:	9c 83       	std	Y+4, r25	; 0x04
    db06:	8b 83       	std	Y+3, r24	; 0x03
    db08:	6d 83       	std	Y+5, r22	; 0x05
{
	init();
    db0a:	8b 81       	ldd	r24, Y+3	; 0x03
    db0c:	9c 81       	ldd	r25, Y+4	; 0x04
    db0e:	0e 94 5f ad 	call	0x15abe	; 0x15abe <_ZN6String4initEv>
	char buf[2];
	buf[0] = c;
    db12:	8d 81       	ldd	r24, Y+5	; 0x05
    db14:	89 83       	std	Y+1, r24	; 0x01
	buf[1] = 0;
    db16:	1a 82       	std	Y+2, r1	; 0x02
	*this = buf;
    db18:	8b 81       	ldd	r24, Y+3	; 0x03
    db1a:	9c 81       	ldd	r25, Y+4	; 0x04
    db1c:	9e 01       	movw	r18, r28
    db1e:	2f 5f       	subi	r18, 0xFF	; 255
    db20:	3f 4f       	sbci	r19, 0xFF	; 255
    db22:	b9 01       	movw	r22, r18
    db24:	0e 94 c6 6f 	call	0xdf8c	; 0xdf8c <_ZN6StringaSEPKc>
}
    db28:	0f 90       	pop	r0
    db2a:	0f 90       	pop	r0
    db2c:	0f 90       	pop	r0
    db2e:	0f 90       	pop	r0
    db30:	0f 90       	pop	r0
    db32:	df 91       	pop	r29
    db34:	cf 91       	pop	r28
    db36:	08 95       	ret

0000db38 <_ZN6StringC1Ehh>:

String::String(unsigned char value, unsigned char base)
    db38:	cf 93       	push	r28
    db3a:	df 93       	push	r29
    db3c:	cd b7       	in	r28, 0x3d	; 61
    db3e:	de b7       	in	r29, 0x3e	; 62
    db40:	2d 97       	sbiw	r28, 0x0d	; 13
    db42:	0f b6       	in	r0, 0x3f	; 63
    db44:	f8 94       	cli
    db46:	de bf       	out	0x3e, r29	; 62
    db48:	0f be       	out	0x3f, r0	; 63
    db4a:	cd bf       	out	0x3d, r28	; 61
    db4c:	9b 87       	std	Y+11, r25	; 0x0b
    db4e:	8a 87       	std	Y+10, r24	; 0x0a
    db50:	6c 87       	std	Y+12, r22	; 0x0c
    db52:	4d 87       	std	Y+13, r20	; 0x0d
{
	init();
    db54:	8a 85       	ldd	r24, Y+10	; 0x0a
    db56:	9b 85       	ldd	r25, Y+11	; 0x0b
    db58:	0e 94 5f ad 	call	0x15abe	; 0x15abe <_ZN6String4initEv>
	char buf[9];
	utoa(value, buf, base);
    db5c:	8d 85       	ldd	r24, Y+13	; 0x0d
    db5e:	28 2f       	mov	r18, r24
    db60:	30 e0       	ldi	r19, 0x00	; 0
    db62:	8c 85       	ldd	r24, Y+12	; 0x0c
    db64:	88 2f       	mov	r24, r24
    db66:	90 e0       	ldi	r25, 0x00	; 0
    db68:	a9 01       	movw	r20, r18
    db6a:	9e 01       	movw	r18, r28
    db6c:	2f 5f       	subi	r18, 0xFF	; 255
    db6e:	3f 4f       	sbci	r19, 0xFF	; 255
    db70:	b9 01       	movw	r22, r18
    db72:	0e 94 15 b2 	call	0x1642a	; 0x1642a <utoa>
	*this = buf;
    db76:	8a 85       	ldd	r24, Y+10	; 0x0a
    db78:	9b 85       	ldd	r25, Y+11	; 0x0b
    db7a:	9e 01       	movw	r18, r28
    db7c:	2f 5f       	subi	r18, 0xFF	; 255
    db7e:	3f 4f       	sbci	r19, 0xFF	; 255
    db80:	b9 01       	movw	r22, r18
    db82:	0e 94 c6 6f 	call	0xdf8c	; 0xdf8c <_ZN6StringaSEPKc>
}
    db86:	2d 96       	adiw	r28, 0x0d	; 13
    db88:	0f b6       	in	r0, 0x3f	; 63
    db8a:	f8 94       	cli
    db8c:	de bf       	out	0x3e, r29	; 62
    db8e:	0f be       	out	0x3f, r0	; 63
    db90:	cd bf       	out	0x3d, r28	; 61
    db92:	df 91       	pop	r29
    db94:	cf 91       	pop	r28
    db96:	08 95       	ret

0000db98 <_ZN6StringC1Eih>:

String::String(int value, unsigned char base)
    db98:	cf 93       	push	r28
    db9a:	df 93       	push	r29
    db9c:	cd b7       	in	r28, 0x3d	; 61
    db9e:	de b7       	in	r29, 0x3e	; 62
    dba0:	67 97       	sbiw	r28, 0x17	; 23
    dba2:	0f b6       	in	r0, 0x3f	; 63
    dba4:	f8 94       	cli
    dba6:	de bf       	out	0x3e, r29	; 62
    dba8:	0f be       	out	0x3f, r0	; 63
    dbaa:	cd bf       	out	0x3d, r28	; 61
    dbac:	9c 8b       	std	Y+20, r25	; 0x14
    dbae:	8b 8b       	std	Y+19, r24	; 0x13
    dbb0:	7e 8b       	std	Y+22, r23	; 0x16
    dbb2:	6d 8b       	std	Y+21, r22	; 0x15
    dbb4:	4f 8b       	std	Y+23, r20	; 0x17
{
	init();
    dbb6:	8b 89       	ldd	r24, Y+19	; 0x13
    dbb8:	9c 89       	ldd	r25, Y+20	; 0x14
    dbba:	0e 94 5f ad 	call	0x15abe	; 0x15abe <_ZN6String4initEv>
	char buf[18];
	itoa(value, buf, base);
    dbbe:	8f 89       	ldd	r24, Y+23	; 0x17
    dbc0:	28 2f       	mov	r18, r24
    dbc2:	30 e0       	ldi	r19, 0x00	; 0
    dbc4:	8d 89       	ldd	r24, Y+21	; 0x15
    dbc6:	9e 89       	ldd	r25, Y+22	; 0x16
    dbc8:	a9 01       	movw	r20, r18
    dbca:	9e 01       	movw	r18, r28
    dbcc:	2f 5f       	subi	r18, 0xFF	; 255
    dbce:	3f 4f       	sbci	r19, 0xFF	; 255
    dbd0:	b9 01       	movw	r22, r18
    dbd2:	0e 94 86 b1 	call	0x1630c	; 0x1630c <itoa>
	*this = buf;
    dbd6:	8b 89       	ldd	r24, Y+19	; 0x13
    dbd8:	9c 89       	ldd	r25, Y+20	; 0x14
    dbda:	9e 01       	movw	r18, r28
    dbdc:	2f 5f       	subi	r18, 0xFF	; 255
    dbde:	3f 4f       	sbci	r19, 0xFF	; 255
    dbe0:	b9 01       	movw	r22, r18
    dbe2:	0e 94 c6 6f 	call	0xdf8c	; 0xdf8c <_ZN6StringaSEPKc>
}
    dbe6:	67 96       	adiw	r28, 0x17	; 23
    dbe8:	0f b6       	in	r0, 0x3f	; 63
    dbea:	f8 94       	cli
    dbec:	de bf       	out	0x3e, r29	; 62
    dbee:	0f be       	out	0x3f, r0	; 63
    dbf0:	cd bf       	out	0x3d, r28	; 61
    dbf2:	df 91       	pop	r29
    dbf4:	cf 91       	pop	r28
    dbf6:	08 95       	ret

0000dbf8 <_ZN6StringC1Ejh>:

String::String(unsigned int value, unsigned char base)
    dbf8:	cf 93       	push	r28
    dbfa:	df 93       	push	r29
    dbfc:	cd b7       	in	r28, 0x3d	; 61
    dbfe:	de b7       	in	r29, 0x3e	; 62
    dc00:	66 97       	sbiw	r28, 0x16	; 22
    dc02:	0f b6       	in	r0, 0x3f	; 63
    dc04:	f8 94       	cli
    dc06:	de bf       	out	0x3e, r29	; 62
    dc08:	0f be       	out	0x3f, r0	; 63
    dc0a:	cd bf       	out	0x3d, r28	; 61
    dc0c:	9b 8b       	std	Y+19, r25	; 0x13
    dc0e:	8a 8b       	std	Y+18, r24	; 0x12
    dc10:	7d 8b       	std	Y+21, r23	; 0x15
    dc12:	6c 8b       	std	Y+20, r22	; 0x14
    dc14:	4e 8b       	std	Y+22, r20	; 0x16
{
	init();
    dc16:	8a 89       	ldd	r24, Y+18	; 0x12
    dc18:	9b 89       	ldd	r25, Y+19	; 0x13
    dc1a:	0e 94 5f ad 	call	0x15abe	; 0x15abe <_ZN6String4initEv>
	char buf[17];
	utoa(value, buf, base);
    dc1e:	8e 89       	ldd	r24, Y+22	; 0x16
    dc20:	28 2f       	mov	r18, r24
    dc22:	30 e0       	ldi	r19, 0x00	; 0
    dc24:	8c 89       	ldd	r24, Y+20	; 0x14
    dc26:	9d 89       	ldd	r25, Y+21	; 0x15
    dc28:	a9 01       	movw	r20, r18
    dc2a:	9e 01       	movw	r18, r28
    dc2c:	2f 5f       	subi	r18, 0xFF	; 255
    dc2e:	3f 4f       	sbci	r19, 0xFF	; 255
    dc30:	b9 01       	movw	r22, r18
    dc32:	0e 94 15 b2 	call	0x1642a	; 0x1642a <utoa>
	*this = buf;
    dc36:	8a 89       	ldd	r24, Y+18	; 0x12
    dc38:	9b 89       	ldd	r25, Y+19	; 0x13
    dc3a:	9e 01       	movw	r18, r28
    dc3c:	2f 5f       	subi	r18, 0xFF	; 255
    dc3e:	3f 4f       	sbci	r19, 0xFF	; 255
    dc40:	b9 01       	movw	r22, r18
    dc42:	0e 94 c6 6f 	call	0xdf8c	; 0xdf8c <_ZN6StringaSEPKc>
}
    dc46:	66 96       	adiw	r28, 0x16	; 22
    dc48:	0f b6       	in	r0, 0x3f	; 63
    dc4a:	f8 94       	cli
    dc4c:	de bf       	out	0x3e, r29	; 62
    dc4e:	0f be       	out	0x3f, r0	; 63
    dc50:	cd bf       	out	0x3d, r28	; 61
    dc52:	df 91       	pop	r29
    dc54:	cf 91       	pop	r28
    dc56:	08 95       	ret

0000dc58 <_ZN6StringC1Elh>:

String::String(long value, unsigned char base)
    dc58:	cf 93       	push	r28
    dc5a:	df 93       	push	r29
    dc5c:	cd b7       	in	r28, 0x3d	; 61
    dc5e:	de b7       	in	r29, 0x3e	; 62
    dc60:	a9 97       	sbiw	r28, 0x29	; 41
    dc62:	0f b6       	in	r0, 0x3f	; 63
    dc64:	f8 94       	cli
    dc66:	de bf       	out	0x3e, r29	; 62
    dc68:	0f be       	out	0x3f, r0	; 63
    dc6a:	cd bf       	out	0x3d, r28	; 61
    dc6c:	9c a3       	std	Y+36, r25	; 0x24
    dc6e:	8b a3       	std	Y+35, r24	; 0x23
    dc70:	4d a3       	std	Y+37, r20	; 0x25
    dc72:	5e a3       	std	Y+38, r21	; 0x26
    dc74:	6f a3       	std	Y+39, r22	; 0x27
    dc76:	78 a7       	std	Y+40, r23	; 0x28
    dc78:	29 a7       	std	Y+41, r18	; 0x29
{
	init();
    dc7a:	8b a1       	ldd	r24, Y+35	; 0x23
    dc7c:	9c a1       	ldd	r25, Y+36	; 0x24
    dc7e:	0e 94 5f ad 	call	0x15abe	; 0x15abe <_ZN6String4initEv>
	char buf[34];
	ltoa(value, buf, base);
    dc82:	89 a5       	ldd	r24, Y+41	; 0x29
    dc84:	28 2f       	mov	r18, r24
    dc86:	30 e0       	ldi	r19, 0x00	; 0
    dc88:	8d a1       	ldd	r24, Y+37	; 0x25
    dc8a:	9e a1       	ldd	r25, Y+38	; 0x26
    dc8c:	af a1       	ldd	r26, Y+39	; 0x27
    dc8e:	b8 a5       	ldd	r27, Y+40	; 0x28
    dc90:	ae 01       	movw	r20, r28
    dc92:	4f 5f       	subi	r20, 0xFF	; 255
    dc94:	5f 4f       	sbci	r21, 0xFF	; 255
    dc96:	bc 01       	movw	r22, r24
    dc98:	cd 01       	movw	r24, r26
    dc9a:	0e 94 a7 b1 	call	0x1634e	; 0x1634e <ltoa>
	*this = buf;
    dc9e:	8b a1       	ldd	r24, Y+35	; 0x23
    dca0:	9c a1       	ldd	r25, Y+36	; 0x24
    dca2:	9e 01       	movw	r18, r28
    dca4:	2f 5f       	subi	r18, 0xFF	; 255
    dca6:	3f 4f       	sbci	r19, 0xFF	; 255
    dca8:	b9 01       	movw	r22, r18
    dcaa:	0e 94 c6 6f 	call	0xdf8c	; 0xdf8c <_ZN6StringaSEPKc>
}
    dcae:	a9 96       	adiw	r28, 0x29	; 41
    dcb0:	0f b6       	in	r0, 0x3f	; 63
    dcb2:	f8 94       	cli
    dcb4:	de bf       	out	0x3e, r29	; 62
    dcb6:	0f be       	out	0x3f, r0	; 63
    dcb8:	cd bf       	out	0x3d, r28	; 61
    dcba:	df 91       	pop	r29
    dcbc:	cf 91       	pop	r28
    dcbe:	08 95       	ret

0000dcc0 <_ZN6StringC1Emh>:

String::String(unsigned long value, unsigned char base)
    dcc0:	cf 93       	push	r28
    dcc2:	df 93       	push	r29
    dcc4:	cd b7       	in	r28, 0x3d	; 61
    dcc6:	de b7       	in	r29, 0x3e	; 62
    dcc8:	a8 97       	sbiw	r28, 0x28	; 40
    dcca:	0f b6       	in	r0, 0x3f	; 63
    dccc:	f8 94       	cli
    dcce:	de bf       	out	0x3e, r29	; 62
    dcd0:	0f be       	out	0x3f, r0	; 63
    dcd2:	cd bf       	out	0x3d, r28	; 61
    dcd4:	9b a3       	std	Y+35, r25	; 0x23
    dcd6:	8a a3       	std	Y+34, r24	; 0x22
    dcd8:	4c a3       	std	Y+36, r20	; 0x24
    dcda:	5d a3       	std	Y+37, r21	; 0x25
    dcdc:	6e a3       	std	Y+38, r22	; 0x26
    dcde:	7f a3       	std	Y+39, r23	; 0x27
    dce0:	28 a7       	std	Y+40, r18	; 0x28
{
	init();
    dce2:	8a a1       	ldd	r24, Y+34	; 0x22
    dce4:	9b a1       	ldd	r25, Y+35	; 0x23
    dce6:	0e 94 5f ad 	call	0x15abe	; 0x15abe <_ZN6String4initEv>
	char buf[33];
	ultoa(value, buf, base);
    dcea:	88 a5       	ldd	r24, Y+40	; 0x28
    dcec:	28 2f       	mov	r18, r24
    dcee:	30 e0       	ldi	r19, 0x00	; 0
    dcf0:	8c a1       	ldd	r24, Y+36	; 0x24
    dcf2:	9d a1       	ldd	r25, Y+37	; 0x25
    dcf4:	ae a1       	ldd	r26, Y+38	; 0x26
    dcf6:	bf a1       	ldd	r27, Y+39	; 0x27
    dcf8:	ae 01       	movw	r20, r28
    dcfa:	4f 5f       	subi	r20, 0xFF	; 255
    dcfc:	5f 4f       	sbci	r21, 0xFF	; 255
    dcfe:	bc 01       	movw	r22, r24
    dd00:	cd 01       	movw	r24, r26
    dd02:	0e 94 f0 b1 	call	0x163e0	; 0x163e0 <ultoa>
	*this = buf;
    dd06:	8a a1       	ldd	r24, Y+34	; 0x22
    dd08:	9b a1       	ldd	r25, Y+35	; 0x23
    dd0a:	9e 01       	movw	r18, r28
    dd0c:	2f 5f       	subi	r18, 0xFF	; 255
    dd0e:	3f 4f       	sbci	r19, 0xFF	; 255
    dd10:	b9 01       	movw	r22, r18
    dd12:	0e 94 c6 6f 	call	0xdf8c	; 0xdf8c <_ZN6StringaSEPKc>
}
    dd16:	a8 96       	adiw	r28, 0x28	; 40
    dd18:	0f b6       	in	r0, 0x3f	; 63
    dd1a:	f8 94       	cli
    dd1c:	de bf       	out	0x3e, r29	; 62
    dd1e:	0f be       	out	0x3f, r0	; 63
    dd20:	cd bf       	out	0x3d, r28	; 61
    dd22:	df 91       	pop	r29
    dd24:	cf 91       	pop	r28
    dd26:	08 95       	ret

0000dd28 <_ZN6StringD1Ev>:

String::~String()
    dd28:	cf 93       	push	r28
    dd2a:	df 93       	push	r29
    dd2c:	00 d0       	rcall	.+0      	; 0xdd2e <_ZN6StringD1Ev+0x6>
    dd2e:	cd b7       	in	r28, 0x3d	; 61
    dd30:	de b7       	in	r29, 0x3e	; 62
    dd32:	9a 83       	std	Y+2, r25	; 0x02
    dd34:	89 83       	std	Y+1, r24	; 0x01
{
	free(buffer);
    dd36:	89 81       	ldd	r24, Y+1	; 0x01
    dd38:	9a 81       	ldd	r25, Y+2	; 0x02
    dd3a:	fc 01       	movw	r30, r24
    dd3c:	80 81       	ld	r24, Z
    dd3e:	91 81       	ldd	r25, Z+1	; 0x01
    dd40:	0e 94 f0 ae 	call	0x15de0	; 0x15de0 <free>
}
    dd44:	0f 90       	pop	r0
    dd46:	0f 90       	pop	r0
    dd48:	df 91       	pop	r29
    dd4a:	cf 91       	pop	r28
    dd4c:	08 95       	ret

0000dd4e <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
    dd4e:	cf 93       	push	r28
    dd50:	df 93       	push	r29
    dd52:	00 d0       	rcall	.+0      	; 0xdd54 <_ZN6String10invalidateEv+0x6>
    dd54:	cd b7       	in	r28, 0x3d	; 61
    dd56:	de b7       	in	r29, 0x3e	; 62
    dd58:	9a 83       	std	Y+2, r25	; 0x02
    dd5a:	89 83       	std	Y+1, r24	; 0x01
	if (buffer) free(buffer);
    dd5c:	89 81       	ldd	r24, Y+1	; 0x01
    dd5e:	9a 81       	ldd	r25, Y+2	; 0x02
    dd60:	fc 01       	movw	r30, r24
    dd62:	80 81       	ld	r24, Z
    dd64:	91 81       	ldd	r25, Z+1	; 0x01
    dd66:	00 97       	sbiw	r24, 0x00	; 0
    dd68:	39 f0       	breq	.+14     	; 0xdd78 <_ZN6String10invalidateEv+0x2a>
    dd6a:	89 81       	ldd	r24, Y+1	; 0x01
    dd6c:	9a 81       	ldd	r25, Y+2	; 0x02
    dd6e:	fc 01       	movw	r30, r24
    dd70:	80 81       	ld	r24, Z
    dd72:	91 81       	ldd	r25, Z+1	; 0x01
    dd74:	0e 94 f0 ae 	call	0x15de0	; 0x15de0 <free>
	buffer = NULL;
    dd78:	89 81       	ldd	r24, Y+1	; 0x01
    dd7a:	9a 81       	ldd	r25, Y+2	; 0x02
    dd7c:	fc 01       	movw	r30, r24
    dd7e:	11 82       	std	Z+1, r1	; 0x01
    dd80:	10 82       	st	Z, r1
	capacity = len = 0;
    dd82:	89 81       	ldd	r24, Y+1	; 0x01
    dd84:	9a 81       	ldd	r25, Y+2	; 0x02
    dd86:	fc 01       	movw	r30, r24
    dd88:	15 82       	std	Z+5, r1	; 0x05
    dd8a:	14 82       	std	Z+4, r1	; 0x04
    dd8c:	89 81       	ldd	r24, Y+1	; 0x01
    dd8e:	9a 81       	ldd	r25, Y+2	; 0x02
    dd90:	fc 01       	movw	r30, r24
    dd92:	24 81       	ldd	r18, Z+4	; 0x04
    dd94:	35 81       	ldd	r19, Z+5	; 0x05
    dd96:	89 81       	ldd	r24, Y+1	; 0x01
    dd98:	9a 81       	ldd	r25, Y+2	; 0x02
    dd9a:	fc 01       	movw	r30, r24
    dd9c:	33 83       	std	Z+3, r19	; 0x03
    dd9e:	22 83       	std	Z+2, r18	; 0x02
}
    dda0:	0f 90       	pop	r0
    dda2:	0f 90       	pop	r0
    dda4:	df 91       	pop	r29
    dda6:	cf 91       	pop	r28
    dda8:	08 95       	ret

0000ddaa <_ZN6String7reserveEj>:

unsigned char String::reserve(unsigned int size)
{
    ddaa:	cf 93       	push	r28
    ddac:	df 93       	push	r29
    ddae:	00 d0       	rcall	.+0      	; 0xddb0 <_ZN6String7reserveEj+0x6>
    ddb0:	00 d0       	rcall	.+0      	; 0xddb2 <_ZN6String7reserveEj+0x8>
    ddb2:	cd b7       	in	r28, 0x3d	; 61
    ddb4:	de b7       	in	r29, 0x3e	; 62
    ddb6:	9a 83       	std	Y+2, r25	; 0x02
    ddb8:	89 83       	std	Y+1, r24	; 0x01
    ddba:	7c 83       	std	Y+4, r23	; 0x04
    ddbc:	6b 83       	std	Y+3, r22	; 0x03
	if (buffer && capacity >= size) return 1;
    ddbe:	89 81       	ldd	r24, Y+1	; 0x01
    ddc0:	9a 81       	ldd	r25, Y+2	; 0x02
    ddc2:	fc 01       	movw	r30, r24
    ddc4:	80 81       	ld	r24, Z
    ddc6:	91 81       	ldd	r25, Z+1	; 0x01
    ddc8:	00 97       	sbiw	r24, 0x00	; 0
    ddca:	61 f0       	breq	.+24     	; 0xdde4 <_ZN6String7reserveEj+0x3a>
    ddcc:	89 81       	ldd	r24, Y+1	; 0x01
    ddce:	9a 81       	ldd	r25, Y+2	; 0x02
    ddd0:	fc 01       	movw	r30, r24
    ddd2:	22 81       	ldd	r18, Z+2	; 0x02
    ddd4:	33 81       	ldd	r19, Z+3	; 0x03
    ddd6:	8b 81       	ldd	r24, Y+3	; 0x03
    ddd8:	9c 81       	ldd	r25, Y+4	; 0x04
    ddda:	28 17       	cp	r18, r24
    dddc:	39 07       	cpc	r19, r25
    ddde:	10 f0       	brcs	.+4      	; 0xdde4 <_ZN6String7reserveEj+0x3a>
    dde0:	81 e0       	ldi	r24, 0x01	; 1
    dde2:	1f c0       	rjmp	.+62     	; 0xde22 <_ZN6String7reserveEj+0x78>
	if (changeBuffer(size)) {
    dde4:	2b 81       	ldd	r18, Y+3	; 0x03
    dde6:	3c 81       	ldd	r19, Y+4	; 0x04
    dde8:	89 81       	ldd	r24, Y+1	; 0x01
    ddea:	9a 81       	ldd	r25, Y+2	; 0x02
    ddec:	b9 01       	movw	r22, r18
    ddee:	0e 94 18 6f 	call	0xde30	; 0xde30 <_ZN6String12changeBufferEj>
    ddf2:	98 2f       	mov	r25, r24
    ddf4:	81 e0       	ldi	r24, 0x01	; 1
    ddf6:	99 23       	and	r25, r25
    ddf8:	09 f4       	brne	.+2      	; 0xddfc <_ZN6String7reserveEj+0x52>
    ddfa:	80 e0       	ldi	r24, 0x00	; 0
    ddfc:	88 23       	and	r24, r24
    ddfe:	81 f0       	breq	.+32     	; 0xde20 <_ZN6String7reserveEj+0x76>
		if (len == 0) buffer[0] = 0;
    de00:	89 81       	ldd	r24, Y+1	; 0x01
    de02:	9a 81       	ldd	r25, Y+2	; 0x02
    de04:	fc 01       	movw	r30, r24
    de06:	84 81       	ldd	r24, Z+4	; 0x04
    de08:	95 81       	ldd	r25, Z+5	; 0x05
    de0a:	00 97       	sbiw	r24, 0x00	; 0
    de0c:	39 f4       	brne	.+14     	; 0xde1c <_ZN6String7reserveEj+0x72>
    de0e:	89 81       	ldd	r24, Y+1	; 0x01
    de10:	9a 81       	ldd	r25, Y+2	; 0x02
    de12:	fc 01       	movw	r30, r24
    de14:	80 81       	ld	r24, Z
    de16:	91 81       	ldd	r25, Z+1	; 0x01
    de18:	fc 01       	movw	r30, r24
    de1a:	10 82       	st	Z, r1
		return 1;
    de1c:	81 e0       	ldi	r24, 0x01	; 1
    de1e:	01 c0       	rjmp	.+2      	; 0xde22 <_ZN6String7reserveEj+0x78>
	}
	return 0;
    de20:	80 e0       	ldi	r24, 0x00	; 0
}
    de22:	0f 90       	pop	r0
    de24:	0f 90       	pop	r0
    de26:	0f 90       	pop	r0
    de28:	0f 90       	pop	r0
    de2a:	df 91       	pop	r29
    de2c:	cf 91       	pop	r28
    de2e:	08 95       	ret

0000de30 <_ZN6String12changeBufferEj>:

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
    de30:	cf 93       	push	r28
    de32:	df 93       	push	r29
    de34:	00 d0       	rcall	.+0      	; 0xde36 <_ZN6String12changeBufferEj+0x6>
    de36:	00 d0       	rcall	.+0      	; 0xde38 <_ZN6String12changeBufferEj+0x8>
    de38:	00 d0       	rcall	.+0      	; 0xde3a <_ZN6String12changeBufferEj+0xa>
    de3a:	cd b7       	in	r28, 0x3d	; 61
    de3c:	de b7       	in	r29, 0x3e	; 62
    de3e:	9c 83       	std	Y+4, r25	; 0x04
    de40:	8b 83       	std	Y+3, r24	; 0x03
    de42:	7e 83       	std	Y+6, r23	; 0x06
    de44:	6d 83       	std	Y+5, r22	; 0x05
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    de46:	8d 81       	ldd	r24, Y+5	; 0x05
    de48:	9e 81       	ldd	r25, Y+6	; 0x06
    de4a:	9c 01       	movw	r18, r24
    de4c:	2f 5f       	subi	r18, 0xFF	; 255
    de4e:	3f 4f       	sbci	r19, 0xFF	; 255
    de50:	8b 81       	ldd	r24, Y+3	; 0x03
    de52:	9c 81       	ldd	r25, Y+4	; 0x04
    de54:	fc 01       	movw	r30, r24
    de56:	80 81       	ld	r24, Z
    de58:	91 81       	ldd	r25, Z+1	; 0x01
    de5a:	b9 01       	movw	r22, r18
    de5c:	0e 94 e7 af 	call	0x15fce	; 0x15fce <realloc>
    de60:	9a 83       	std	Y+2, r25	; 0x02
    de62:	89 83       	std	Y+1, r24	; 0x01
	if (newbuffer) {
    de64:	89 81       	ldd	r24, Y+1	; 0x01
    de66:	9a 81       	ldd	r25, Y+2	; 0x02
    de68:	00 97       	sbiw	r24, 0x00	; 0
    de6a:	81 f0       	breq	.+32     	; 0xde8c <_ZN6String12changeBufferEj+0x5c>
		buffer = newbuffer;
    de6c:	8b 81       	ldd	r24, Y+3	; 0x03
    de6e:	9c 81       	ldd	r25, Y+4	; 0x04
    de70:	29 81       	ldd	r18, Y+1	; 0x01
    de72:	3a 81       	ldd	r19, Y+2	; 0x02
    de74:	fc 01       	movw	r30, r24
    de76:	31 83       	std	Z+1, r19	; 0x01
    de78:	20 83       	st	Z, r18
		capacity = maxStrLen;
    de7a:	8b 81       	ldd	r24, Y+3	; 0x03
    de7c:	9c 81       	ldd	r25, Y+4	; 0x04
    de7e:	2d 81       	ldd	r18, Y+5	; 0x05
    de80:	3e 81       	ldd	r19, Y+6	; 0x06
    de82:	fc 01       	movw	r30, r24
    de84:	33 83       	std	Z+3, r19	; 0x03
    de86:	22 83       	std	Z+2, r18	; 0x02
		return 1;
    de88:	81 e0       	ldi	r24, 0x01	; 1
    de8a:	01 c0       	rjmp	.+2      	; 0xde8e <_ZN6String12changeBufferEj+0x5e>
	}
	return 0;
    de8c:	80 e0       	ldi	r24, 0x00	; 0
}
    de8e:	26 96       	adiw	r28, 0x06	; 6
    de90:	0f b6       	in	r0, 0x3f	; 63
    de92:	f8 94       	cli
    de94:	de bf       	out	0x3e, r29	; 62
    de96:	0f be       	out	0x3f, r0	; 63
    de98:	cd bf       	out	0x3d, r28	; 61
    de9a:	df 91       	pop	r29
    de9c:	cf 91       	pop	r28
    de9e:	08 95       	ret

0000dea0 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    dea0:	cf 93       	push	r28
    dea2:	df 93       	push	r29
    dea4:	00 d0       	rcall	.+0      	; 0xdea6 <_ZN6String4copyEPKcj+0x6>
    dea6:	00 d0       	rcall	.+0      	; 0xdea8 <_ZN6String4copyEPKcj+0x8>
    dea8:	00 d0       	rcall	.+0      	; 0xdeaa <_ZN6String4copyEPKcj+0xa>
    deaa:	cd b7       	in	r28, 0x3d	; 61
    deac:	de b7       	in	r29, 0x3e	; 62
    deae:	9a 83       	std	Y+2, r25	; 0x02
    deb0:	89 83       	std	Y+1, r24	; 0x01
    deb2:	7c 83       	std	Y+4, r23	; 0x04
    deb4:	6b 83       	std	Y+3, r22	; 0x03
    deb6:	5e 83       	std	Y+6, r21	; 0x06
    deb8:	4d 83       	std	Y+5, r20	; 0x05
	if (!reserve(length)) {
    deba:	2d 81       	ldd	r18, Y+5	; 0x05
    debc:	3e 81       	ldd	r19, Y+6	; 0x06
    debe:	89 81       	ldd	r24, Y+1	; 0x01
    dec0:	9a 81       	ldd	r25, Y+2	; 0x02
    dec2:	b9 01       	movw	r22, r18
    dec4:	0e 94 d5 6e 	call	0xddaa	; 0xddaa <_ZN6String7reserveEj>
    dec8:	98 2f       	mov	r25, r24
    deca:	81 e0       	ldi	r24, 0x01	; 1
    decc:	99 23       	and	r25, r25
    dece:	09 f0       	breq	.+2      	; 0xded2 <_ZN6String4copyEPKcj+0x32>
    ded0:	80 e0       	ldi	r24, 0x00	; 0
    ded2:	88 23       	and	r24, r24
    ded4:	39 f0       	breq	.+14     	; 0xdee4 <_ZN6String4copyEPKcj+0x44>
		invalidate();
    ded6:	89 81       	ldd	r24, Y+1	; 0x01
    ded8:	9a 81       	ldd	r25, Y+2	; 0x02
    deda:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
		return *this;
    dede:	89 81       	ldd	r24, Y+1	; 0x01
    dee0:	9a 81       	ldd	r25, Y+2	; 0x02
    dee2:	13 c0       	rjmp	.+38     	; 0xdf0a <_ZN6String4copyEPKcj+0x6a>
	}
	len = length;
    dee4:	89 81       	ldd	r24, Y+1	; 0x01
    dee6:	9a 81       	ldd	r25, Y+2	; 0x02
    dee8:	2d 81       	ldd	r18, Y+5	; 0x05
    deea:	3e 81       	ldd	r19, Y+6	; 0x06
    deec:	fc 01       	movw	r30, r24
    deee:	35 83       	std	Z+5, r19	; 0x05
    def0:	24 83       	std	Z+4, r18	; 0x04
	strcpy(buffer, cstr);
    def2:	89 81       	ldd	r24, Y+1	; 0x01
    def4:	9a 81       	ldd	r25, Y+2	; 0x02
    def6:	fc 01       	movw	r30, r24
    def8:	80 81       	ld	r24, Z
    defa:	91 81       	ldd	r25, Z+1	; 0x01
    defc:	2b 81       	ldd	r18, Y+3	; 0x03
    defe:	3c 81       	ldd	r19, Y+4	; 0x04
    df00:	b9 01       	movw	r22, r18
    df02:	0e 94 34 b1 	call	0x16268	; 0x16268 <strcpy>
	return *this;
    df06:	89 81       	ldd	r24, Y+1	; 0x01
    df08:	9a 81       	ldd	r25, Y+2	; 0x02
}
    df0a:	26 96       	adiw	r28, 0x06	; 6
    df0c:	0f b6       	in	r0, 0x3f	; 63
    df0e:	f8 94       	cli
    df10:	de bf       	out	0x3e, r29	; 62
    df12:	0f be       	out	0x3f, r0	; 63
    df14:	cd bf       	out	0x3d, r28	; 61
    df16:	df 91       	pop	r29
    df18:	cf 91       	pop	r28
    df1a:	08 95       	ret

0000df1c <_ZN6StringaSERKS_>:
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
    df1c:	cf 93       	push	r28
    df1e:	df 93       	push	r29
    df20:	00 d0       	rcall	.+0      	; 0xdf22 <_ZN6StringaSERKS_+0x6>
    df22:	00 d0       	rcall	.+0      	; 0xdf24 <_ZN6StringaSERKS_+0x8>
    df24:	cd b7       	in	r28, 0x3d	; 61
    df26:	de b7       	in	r29, 0x3e	; 62
    df28:	9a 83       	std	Y+2, r25	; 0x02
    df2a:	89 83       	std	Y+1, r24	; 0x01
    df2c:	7c 83       	std	Y+4, r23	; 0x04
    df2e:	6b 83       	std	Y+3, r22	; 0x03
	if (this == &rhs) return *this;
    df30:	29 81       	ldd	r18, Y+1	; 0x01
    df32:	3a 81       	ldd	r19, Y+2	; 0x02
    df34:	8b 81       	ldd	r24, Y+3	; 0x03
    df36:	9c 81       	ldd	r25, Y+4	; 0x04
    df38:	28 17       	cp	r18, r24
    df3a:	39 07       	cpc	r19, r25
    df3c:	19 f4       	brne	.+6      	; 0xdf44 <_ZN6StringaSERKS_+0x28>
    df3e:	89 81       	ldd	r24, Y+1	; 0x01
    df40:	9a 81       	ldd	r25, Y+2	; 0x02
    df42:	1d c0       	rjmp	.+58     	; 0xdf7e <_ZN6StringaSERKS_+0x62>
	
	if (rhs.buffer) copy(rhs.buffer, rhs.len);
    df44:	8b 81       	ldd	r24, Y+3	; 0x03
    df46:	9c 81       	ldd	r25, Y+4	; 0x04
    df48:	fc 01       	movw	r30, r24
    df4a:	80 81       	ld	r24, Z
    df4c:	91 81       	ldd	r25, Z+1	; 0x01
    df4e:	00 97       	sbiw	r24, 0x00	; 0
    df50:	81 f0       	breq	.+32     	; 0xdf72 <_ZN6StringaSERKS_+0x56>
    df52:	8b 81       	ldd	r24, Y+3	; 0x03
    df54:	9c 81       	ldd	r25, Y+4	; 0x04
    df56:	fc 01       	movw	r30, r24
    df58:	44 81       	ldd	r20, Z+4	; 0x04
    df5a:	55 81       	ldd	r21, Z+5	; 0x05
    df5c:	8b 81       	ldd	r24, Y+3	; 0x03
    df5e:	9c 81       	ldd	r25, Y+4	; 0x04
    df60:	fc 01       	movw	r30, r24
    df62:	20 81       	ld	r18, Z
    df64:	31 81       	ldd	r19, Z+1	; 0x01
    df66:	89 81       	ldd	r24, Y+1	; 0x01
    df68:	9a 81       	ldd	r25, Y+2	; 0x02
    df6a:	b9 01       	movw	r22, r18
    df6c:	0e 94 50 6f 	call	0xdea0	; 0xdea0 <_ZN6String4copyEPKcj>
    df70:	04 c0       	rjmp	.+8      	; 0xdf7a <_ZN6StringaSERKS_+0x5e>
	else invalidate();
    df72:	89 81       	ldd	r24, Y+1	; 0x01
    df74:	9a 81       	ldd	r25, Y+2	; 0x02
    df76:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
	
	return *this;
    df7a:	89 81       	ldd	r24, Y+1	; 0x01
    df7c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    df7e:	0f 90       	pop	r0
    df80:	0f 90       	pop	r0
    df82:	0f 90       	pop	r0
    df84:	0f 90       	pop	r0
    df86:	df 91       	pop	r29
    df88:	cf 91       	pop	r28
    df8a:	08 95       	ret

0000df8c <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
    df8c:	cf 93       	push	r28
    df8e:	df 93       	push	r29
    df90:	00 d0       	rcall	.+0      	; 0xdf92 <_ZN6StringaSEPKc+0x6>
    df92:	00 d0       	rcall	.+0      	; 0xdf94 <_ZN6StringaSEPKc+0x8>
    df94:	cd b7       	in	r28, 0x3d	; 61
    df96:	de b7       	in	r29, 0x3e	; 62
    df98:	9a 83       	std	Y+2, r25	; 0x02
    df9a:	89 83       	std	Y+1, r24	; 0x01
    df9c:	7c 83       	std	Y+4, r23	; 0x04
    df9e:	6b 83       	std	Y+3, r22	; 0x03
	if (cstr) copy(cstr, strlen(cstr));
    dfa0:	8b 81       	ldd	r24, Y+3	; 0x03
    dfa2:	9c 81       	ldd	r25, Y+4	; 0x04
    dfa4:	00 97       	sbiw	r24, 0x00	; 0
    dfa6:	69 f0       	breq	.+26     	; 0xdfc2 <_ZN6StringaSEPKc+0x36>
    dfa8:	8b 81       	ldd	r24, Y+3	; 0x03
    dfaa:	9c 81       	ldd	r25, Y+4	; 0x04
    dfac:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    dfb0:	ac 01       	movw	r20, r24
    dfb2:	2b 81       	ldd	r18, Y+3	; 0x03
    dfb4:	3c 81       	ldd	r19, Y+4	; 0x04
    dfb6:	89 81       	ldd	r24, Y+1	; 0x01
    dfb8:	9a 81       	ldd	r25, Y+2	; 0x02
    dfba:	b9 01       	movw	r22, r18
    dfbc:	0e 94 50 6f 	call	0xdea0	; 0xdea0 <_ZN6String4copyEPKcj>
    dfc0:	04 c0       	rjmp	.+8      	; 0xdfca <_ZN6StringaSEPKc+0x3e>
	else invalidate();
    dfc2:	89 81       	ldd	r24, Y+1	; 0x01
    dfc4:	9a 81       	ldd	r25, Y+2	; 0x02
    dfc6:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
	
	return *this;
    dfca:	89 81       	ldd	r24, Y+1	; 0x01
    dfcc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    dfce:	0f 90       	pop	r0
    dfd0:	0f 90       	pop	r0
    dfd2:	0f 90       	pop	r0
    dfd4:	0f 90       	pop	r0
    dfd6:	df 91       	pop	r29
    dfd8:	cf 91       	pop	r28
    dfda:	08 95       	ret

0000dfdc <_ZN6String6concatERKS_>:
/*********************************************/
/*  concat                                   */
/*********************************************/

unsigned char String::concat(const String &s)
{
    dfdc:	cf 93       	push	r28
    dfde:	df 93       	push	r29
    dfe0:	00 d0       	rcall	.+0      	; 0xdfe2 <_ZN6String6concatERKS_+0x6>
    dfe2:	00 d0       	rcall	.+0      	; 0xdfe4 <_ZN6String6concatERKS_+0x8>
    dfe4:	cd b7       	in	r28, 0x3d	; 61
    dfe6:	de b7       	in	r29, 0x3e	; 62
    dfe8:	9a 83       	std	Y+2, r25	; 0x02
    dfea:	89 83       	std	Y+1, r24	; 0x01
    dfec:	7c 83       	std	Y+4, r23	; 0x04
    dfee:	6b 83       	std	Y+3, r22	; 0x03
	return concat(s.buffer, s.len);
    dff0:	8b 81       	ldd	r24, Y+3	; 0x03
    dff2:	9c 81       	ldd	r25, Y+4	; 0x04
    dff4:	fc 01       	movw	r30, r24
    dff6:	44 81       	ldd	r20, Z+4	; 0x04
    dff8:	55 81       	ldd	r21, Z+5	; 0x05
    dffa:	8b 81       	ldd	r24, Y+3	; 0x03
    dffc:	9c 81       	ldd	r25, Y+4	; 0x04
    dffe:	fc 01       	movw	r30, r24
    e000:	20 81       	ld	r18, Z
    e002:	31 81       	ldd	r19, Z+1	; 0x01
    e004:	89 81       	ldd	r24, Y+1	; 0x01
    e006:	9a 81       	ldd	r25, Y+2	; 0x02
    e008:	b9 01       	movw	r22, r18
    e00a:	0e 94 0e 70 	call	0xe01c	; 0xe01c <_ZN6String6concatEPKcj>
}
    e00e:	0f 90       	pop	r0
    e010:	0f 90       	pop	r0
    e012:	0f 90       	pop	r0
    e014:	0f 90       	pop	r0
    e016:	df 91       	pop	r29
    e018:	cf 91       	pop	r28
    e01a:	08 95       	ret

0000e01c <_ZN6String6concatEPKcj>:

unsigned char String::concat(const char *cstr, unsigned int length)
{
    e01c:	cf 93       	push	r28
    e01e:	df 93       	push	r29
    e020:	cd b7       	in	r28, 0x3d	; 61
    e022:	de b7       	in	r29, 0x3e	; 62
    e024:	28 97       	sbiw	r28, 0x08	; 8
    e026:	0f b6       	in	r0, 0x3f	; 63
    e028:	f8 94       	cli
    e02a:	de bf       	out	0x3e, r29	; 62
    e02c:	0f be       	out	0x3f, r0	; 63
    e02e:	cd bf       	out	0x3d, r28	; 61
    e030:	9c 83       	std	Y+4, r25	; 0x04
    e032:	8b 83       	std	Y+3, r24	; 0x03
    e034:	7e 83       	std	Y+6, r23	; 0x06
    e036:	6d 83       	std	Y+5, r22	; 0x05
    e038:	58 87       	std	Y+8, r21	; 0x08
    e03a:	4f 83       	std	Y+7, r20	; 0x07
	unsigned int newlen = len + length;
    e03c:	8b 81       	ldd	r24, Y+3	; 0x03
    e03e:	9c 81       	ldd	r25, Y+4	; 0x04
    e040:	fc 01       	movw	r30, r24
    e042:	24 81       	ldd	r18, Z+4	; 0x04
    e044:	35 81       	ldd	r19, Z+5	; 0x05
    e046:	8f 81       	ldd	r24, Y+7	; 0x07
    e048:	98 85       	ldd	r25, Y+8	; 0x08
    e04a:	82 0f       	add	r24, r18
    e04c:	93 1f       	adc	r25, r19
    e04e:	9a 83       	std	Y+2, r25	; 0x02
    e050:	89 83       	std	Y+1, r24	; 0x01
	if (!cstr) return 0;
    e052:	8d 81       	ldd	r24, Y+5	; 0x05
    e054:	9e 81       	ldd	r25, Y+6	; 0x06
    e056:	00 97       	sbiw	r24, 0x00	; 0
    e058:	11 f4       	brne	.+4      	; 0xe05e <_ZN6String6concatEPKcj+0x42>
    e05a:	80 e0       	ldi	r24, 0x00	; 0
    e05c:	2f c0       	rjmp	.+94     	; 0xe0bc <_ZN6String6concatEPKcj+0xa0>
	if (length == 0) return 1;
    e05e:	8f 81       	ldd	r24, Y+7	; 0x07
    e060:	98 85       	ldd	r25, Y+8	; 0x08
    e062:	00 97       	sbiw	r24, 0x00	; 0
    e064:	11 f4       	brne	.+4      	; 0xe06a <_ZN6String6concatEPKcj+0x4e>
    e066:	81 e0       	ldi	r24, 0x01	; 1
    e068:	29 c0       	rjmp	.+82     	; 0xe0bc <_ZN6String6concatEPKcj+0xa0>
	if (!reserve(newlen)) return 0;
    e06a:	29 81       	ldd	r18, Y+1	; 0x01
    e06c:	3a 81       	ldd	r19, Y+2	; 0x02
    e06e:	8b 81       	ldd	r24, Y+3	; 0x03
    e070:	9c 81       	ldd	r25, Y+4	; 0x04
    e072:	b9 01       	movw	r22, r18
    e074:	0e 94 d5 6e 	call	0xddaa	; 0xddaa <_ZN6String7reserveEj>
    e078:	98 2f       	mov	r25, r24
    e07a:	81 e0       	ldi	r24, 0x01	; 1
    e07c:	99 23       	and	r25, r25
    e07e:	09 f0       	breq	.+2      	; 0xe082 <_ZN6String6concatEPKcj+0x66>
    e080:	80 e0       	ldi	r24, 0x00	; 0
    e082:	88 23       	and	r24, r24
    e084:	11 f0       	breq	.+4      	; 0xe08a <_ZN6String6concatEPKcj+0x6e>
    e086:	80 e0       	ldi	r24, 0x00	; 0
    e088:	19 c0       	rjmp	.+50     	; 0xe0bc <_ZN6String6concatEPKcj+0xa0>
	strcpy(buffer + len, cstr);
    e08a:	8b 81       	ldd	r24, Y+3	; 0x03
    e08c:	9c 81       	ldd	r25, Y+4	; 0x04
    e08e:	fc 01       	movw	r30, r24
    e090:	20 81       	ld	r18, Z
    e092:	31 81       	ldd	r19, Z+1	; 0x01
    e094:	8b 81       	ldd	r24, Y+3	; 0x03
    e096:	9c 81       	ldd	r25, Y+4	; 0x04
    e098:	fc 01       	movw	r30, r24
    e09a:	84 81       	ldd	r24, Z+4	; 0x04
    e09c:	95 81       	ldd	r25, Z+5	; 0x05
    e09e:	82 0f       	add	r24, r18
    e0a0:	93 1f       	adc	r25, r19
    e0a2:	2d 81       	ldd	r18, Y+5	; 0x05
    e0a4:	3e 81       	ldd	r19, Y+6	; 0x06
    e0a6:	b9 01       	movw	r22, r18
    e0a8:	0e 94 34 b1 	call	0x16268	; 0x16268 <strcpy>
	len = newlen;
    e0ac:	8b 81       	ldd	r24, Y+3	; 0x03
    e0ae:	9c 81       	ldd	r25, Y+4	; 0x04
    e0b0:	29 81       	ldd	r18, Y+1	; 0x01
    e0b2:	3a 81       	ldd	r19, Y+2	; 0x02
    e0b4:	fc 01       	movw	r30, r24
    e0b6:	35 83       	std	Z+5, r19	; 0x05
    e0b8:	24 83       	std	Z+4, r18	; 0x04
	return 1;
    e0ba:	81 e0       	ldi	r24, 0x01	; 1
}
    e0bc:	28 96       	adiw	r28, 0x08	; 8
    e0be:	0f b6       	in	r0, 0x3f	; 63
    e0c0:	f8 94       	cli
    e0c2:	de bf       	out	0x3e, r29	; 62
    e0c4:	0f be       	out	0x3f, r0	; 63
    e0c6:	cd bf       	out	0x3d, r28	; 61
    e0c8:	df 91       	pop	r29
    e0ca:	cf 91       	pop	r28
    e0cc:	08 95       	ret

0000e0ce <_ZN6String6concatEPKc>:

unsigned char String::concat(const char *cstr)
{
    e0ce:	cf 93       	push	r28
    e0d0:	df 93       	push	r29
    e0d2:	00 d0       	rcall	.+0      	; 0xe0d4 <_ZN6String6concatEPKc+0x6>
    e0d4:	00 d0       	rcall	.+0      	; 0xe0d6 <_ZN6String6concatEPKc+0x8>
    e0d6:	cd b7       	in	r28, 0x3d	; 61
    e0d8:	de b7       	in	r29, 0x3e	; 62
    e0da:	9a 83       	std	Y+2, r25	; 0x02
    e0dc:	89 83       	std	Y+1, r24	; 0x01
    e0de:	7c 83       	std	Y+4, r23	; 0x04
    e0e0:	6b 83       	std	Y+3, r22	; 0x03
	if (!cstr) return 0;
    e0e2:	8b 81       	ldd	r24, Y+3	; 0x03
    e0e4:	9c 81       	ldd	r25, Y+4	; 0x04
    e0e6:	00 97       	sbiw	r24, 0x00	; 0
    e0e8:	11 f4       	brne	.+4      	; 0xe0ee <_ZN6String6concatEPKc+0x20>
    e0ea:	80 e0       	ldi	r24, 0x00	; 0
    e0ec:	0c c0       	rjmp	.+24     	; 0xe106 <_ZN6String6concatEPKc+0x38>
	return concat(cstr, strlen(cstr));
    e0ee:	8b 81       	ldd	r24, Y+3	; 0x03
    e0f0:	9c 81       	ldd	r25, Y+4	; 0x04
    e0f2:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    e0f6:	ac 01       	movw	r20, r24
    e0f8:	2b 81       	ldd	r18, Y+3	; 0x03
    e0fa:	3c 81       	ldd	r19, Y+4	; 0x04
    e0fc:	89 81       	ldd	r24, Y+1	; 0x01
    e0fe:	9a 81       	ldd	r25, Y+2	; 0x02
    e100:	b9 01       	movw	r22, r18
    e102:	0e 94 0e 70 	call	0xe01c	; 0xe01c <_ZN6String6concatEPKcj>
}
    e106:	0f 90       	pop	r0
    e108:	0f 90       	pop	r0
    e10a:	0f 90       	pop	r0
    e10c:	0f 90       	pop	r0
    e10e:	df 91       	pop	r29
    e110:	cf 91       	pop	r28
    e112:	08 95       	ret

0000e114 <_ZN6String6concatEc>:

unsigned char String::concat(char c)
{
    e114:	cf 93       	push	r28
    e116:	df 93       	push	r29
    e118:	00 d0       	rcall	.+0      	; 0xe11a <_ZN6String6concatEc+0x6>
    e11a:	00 d0       	rcall	.+0      	; 0xe11c <_ZN6String6concatEc+0x8>
    e11c:	1f 92       	push	r1
    e11e:	cd b7       	in	r28, 0x3d	; 61
    e120:	de b7       	in	r29, 0x3e	; 62
    e122:	9c 83       	std	Y+4, r25	; 0x04
    e124:	8b 83       	std	Y+3, r24	; 0x03
    e126:	6d 83       	std	Y+5, r22	; 0x05
	char buf[2];
	buf[0] = c;
    e128:	8d 81       	ldd	r24, Y+5	; 0x05
    e12a:	89 83       	std	Y+1, r24	; 0x01
	buf[1] = 0;
    e12c:	1a 82       	std	Y+2, r1	; 0x02
	return concat(buf, 1);
    e12e:	8b 81       	ldd	r24, Y+3	; 0x03
    e130:	9c 81       	ldd	r25, Y+4	; 0x04
    e132:	41 e0       	ldi	r20, 0x01	; 1
    e134:	50 e0       	ldi	r21, 0x00	; 0
    e136:	9e 01       	movw	r18, r28
    e138:	2f 5f       	subi	r18, 0xFF	; 255
    e13a:	3f 4f       	sbci	r19, 0xFF	; 255
    e13c:	b9 01       	movw	r22, r18
    e13e:	0e 94 0e 70 	call	0xe01c	; 0xe01c <_ZN6String6concatEPKcj>
}
    e142:	0f 90       	pop	r0
    e144:	0f 90       	pop	r0
    e146:	0f 90       	pop	r0
    e148:	0f 90       	pop	r0
    e14a:	0f 90       	pop	r0
    e14c:	df 91       	pop	r29
    e14e:	cf 91       	pop	r28
    e150:	08 95       	ret

0000e152 <_ZN6String6concatEh>:

unsigned char String::concat(unsigned char num)
{
    e152:	cf 93       	push	r28
    e154:	df 93       	push	r29
    e156:	cd b7       	in	r28, 0x3d	; 61
    e158:	de b7       	in	r29, 0x3e	; 62
    e15a:	27 97       	sbiw	r28, 0x07	; 7
    e15c:	0f b6       	in	r0, 0x3f	; 63
    e15e:	f8 94       	cli
    e160:	de bf       	out	0x3e, r29	; 62
    e162:	0f be       	out	0x3f, r0	; 63
    e164:	cd bf       	out	0x3d, r28	; 61
    e166:	9e 83       	std	Y+6, r25	; 0x06
    e168:	8d 83       	std	Y+5, r24	; 0x05
    e16a:	6f 83       	std	Y+7, r22	; 0x07
	char buf[4];
	itoa(num, buf, 10);
    e16c:	8f 81       	ldd	r24, Y+7	; 0x07
    e16e:	88 2f       	mov	r24, r24
    e170:	90 e0       	ldi	r25, 0x00	; 0
    e172:	4a e0       	ldi	r20, 0x0A	; 10
    e174:	50 e0       	ldi	r21, 0x00	; 0
    e176:	9e 01       	movw	r18, r28
    e178:	2f 5f       	subi	r18, 0xFF	; 255
    e17a:	3f 4f       	sbci	r19, 0xFF	; 255
    e17c:	b9 01       	movw	r22, r18
    e17e:	0e 94 86 b1 	call	0x1630c	; 0x1630c <itoa>
	return concat(buf, strlen(buf));
    e182:	ce 01       	movw	r24, r28
    e184:	01 96       	adiw	r24, 0x01	; 1
    e186:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    e18a:	9c 01       	movw	r18, r24
    e18c:	8d 81       	ldd	r24, Y+5	; 0x05
    e18e:	9e 81       	ldd	r25, Y+6	; 0x06
    e190:	a9 01       	movw	r20, r18
    e192:	9e 01       	movw	r18, r28
    e194:	2f 5f       	subi	r18, 0xFF	; 255
    e196:	3f 4f       	sbci	r19, 0xFF	; 255
    e198:	b9 01       	movw	r22, r18
    e19a:	0e 94 0e 70 	call	0xe01c	; 0xe01c <_ZN6String6concatEPKcj>
}
    e19e:	27 96       	adiw	r28, 0x07	; 7
    e1a0:	0f b6       	in	r0, 0x3f	; 63
    e1a2:	f8 94       	cli
    e1a4:	de bf       	out	0x3e, r29	; 62
    e1a6:	0f be       	out	0x3f, r0	; 63
    e1a8:	cd bf       	out	0x3d, r28	; 61
    e1aa:	df 91       	pop	r29
    e1ac:	cf 91       	pop	r28
    e1ae:	08 95       	ret

0000e1b0 <_ZN6String6concatEi>:

unsigned char String::concat(int num)
{
    e1b0:	cf 93       	push	r28
    e1b2:	df 93       	push	r29
    e1b4:	cd b7       	in	r28, 0x3d	; 61
    e1b6:	de b7       	in	r29, 0x3e	; 62
    e1b8:	2b 97       	sbiw	r28, 0x0b	; 11
    e1ba:	0f b6       	in	r0, 0x3f	; 63
    e1bc:	f8 94       	cli
    e1be:	de bf       	out	0x3e, r29	; 62
    e1c0:	0f be       	out	0x3f, r0	; 63
    e1c2:	cd bf       	out	0x3d, r28	; 61
    e1c4:	99 87       	std	Y+9, r25	; 0x09
    e1c6:	88 87       	std	Y+8, r24	; 0x08
    e1c8:	7b 87       	std	Y+11, r23	; 0x0b
    e1ca:	6a 87       	std	Y+10, r22	; 0x0a
	char buf[7];
	itoa(num, buf, 10);
    e1cc:	8a 85       	ldd	r24, Y+10	; 0x0a
    e1ce:	9b 85       	ldd	r25, Y+11	; 0x0b
    e1d0:	4a e0       	ldi	r20, 0x0A	; 10
    e1d2:	50 e0       	ldi	r21, 0x00	; 0
    e1d4:	9e 01       	movw	r18, r28
    e1d6:	2f 5f       	subi	r18, 0xFF	; 255
    e1d8:	3f 4f       	sbci	r19, 0xFF	; 255
    e1da:	b9 01       	movw	r22, r18
    e1dc:	0e 94 86 b1 	call	0x1630c	; 0x1630c <itoa>
	return concat(buf, strlen(buf));
    e1e0:	ce 01       	movw	r24, r28
    e1e2:	01 96       	adiw	r24, 0x01	; 1
    e1e4:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    e1e8:	9c 01       	movw	r18, r24
    e1ea:	88 85       	ldd	r24, Y+8	; 0x08
    e1ec:	99 85       	ldd	r25, Y+9	; 0x09
    e1ee:	a9 01       	movw	r20, r18
    e1f0:	9e 01       	movw	r18, r28
    e1f2:	2f 5f       	subi	r18, 0xFF	; 255
    e1f4:	3f 4f       	sbci	r19, 0xFF	; 255
    e1f6:	b9 01       	movw	r22, r18
    e1f8:	0e 94 0e 70 	call	0xe01c	; 0xe01c <_ZN6String6concatEPKcj>
}
    e1fc:	2b 96       	adiw	r28, 0x0b	; 11
    e1fe:	0f b6       	in	r0, 0x3f	; 63
    e200:	f8 94       	cli
    e202:	de bf       	out	0x3e, r29	; 62
    e204:	0f be       	out	0x3f, r0	; 63
    e206:	cd bf       	out	0x3d, r28	; 61
    e208:	df 91       	pop	r29
    e20a:	cf 91       	pop	r28
    e20c:	08 95       	ret

0000e20e <_ZN6String6concatEj>:

unsigned char String::concat(unsigned int num)
{
    e20e:	cf 93       	push	r28
    e210:	df 93       	push	r29
    e212:	cd b7       	in	r28, 0x3d	; 61
    e214:	de b7       	in	r29, 0x3e	; 62
    e216:	2a 97       	sbiw	r28, 0x0a	; 10
    e218:	0f b6       	in	r0, 0x3f	; 63
    e21a:	f8 94       	cli
    e21c:	de bf       	out	0x3e, r29	; 62
    e21e:	0f be       	out	0x3f, r0	; 63
    e220:	cd bf       	out	0x3d, r28	; 61
    e222:	98 87       	std	Y+8, r25	; 0x08
    e224:	8f 83       	std	Y+7, r24	; 0x07
    e226:	7a 87       	std	Y+10, r23	; 0x0a
    e228:	69 87       	std	Y+9, r22	; 0x09
	char buf[6];
	utoa(num, buf, 10);
    e22a:	89 85       	ldd	r24, Y+9	; 0x09
    e22c:	9a 85       	ldd	r25, Y+10	; 0x0a
    e22e:	4a e0       	ldi	r20, 0x0A	; 10
    e230:	50 e0       	ldi	r21, 0x00	; 0
    e232:	9e 01       	movw	r18, r28
    e234:	2f 5f       	subi	r18, 0xFF	; 255
    e236:	3f 4f       	sbci	r19, 0xFF	; 255
    e238:	b9 01       	movw	r22, r18
    e23a:	0e 94 15 b2 	call	0x1642a	; 0x1642a <utoa>
	return concat(buf, strlen(buf));
    e23e:	ce 01       	movw	r24, r28
    e240:	01 96       	adiw	r24, 0x01	; 1
    e242:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    e246:	9c 01       	movw	r18, r24
    e248:	8f 81       	ldd	r24, Y+7	; 0x07
    e24a:	98 85       	ldd	r25, Y+8	; 0x08
    e24c:	a9 01       	movw	r20, r18
    e24e:	9e 01       	movw	r18, r28
    e250:	2f 5f       	subi	r18, 0xFF	; 255
    e252:	3f 4f       	sbci	r19, 0xFF	; 255
    e254:	b9 01       	movw	r22, r18
    e256:	0e 94 0e 70 	call	0xe01c	; 0xe01c <_ZN6String6concatEPKcj>
}
    e25a:	2a 96       	adiw	r28, 0x0a	; 10
    e25c:	0f b6       	in	r0, 0x3f	; 63
    e25e:	f8 94       	cli
    e260:	de bf       	out	0x3e, r29	; 62
    e262:	0f be       	out	0x3f, r0	; 63
    e264:	cd bf       	out	0x3d, r28	; 61
    e266:	df 91       	pop	r29
    e268:	cf 91       	pop	r28
    e26a:	08 95       	ret

0000e26c <_ZN6String6concatEl>:

unsigned char String::concat(long num)
{
    e26c:	cf 93       	push	r28
    e26e:	df 93       	push	r29
    e270:	cd b7       	in	r28, 0x3d	; 61
    e272:	de b7       	in	r29, 0x3e	; 62
    e274:	62 97       	sbiw	r28, 0x12	; 18
    e276:	0f b6       	in	r0, 0x3f	; 63
    e278:	f8 94       	cli
    e27a:	de bf       	out	0x3e, r29	; 62
    e27c:	0f be       	out	0x3f, r0	; 63
    e27e:	cd bf       	out	0x3d, r28	; 61
    e280:	9e 87       	std	Y+14, r25	; 0x0e
    e282:	8d 87       	std	Y+13, r24	; 0x0d
    e284:	4f 87       	std	Y+15, r20	; 0x0f
    e286:	58 8b       	std	Y+16, r21	; 0x10
    e288:	69 8b       	std	Y+17, r22	; 0x11
    e28a:	7a 8b       	std	Y+18, r23	; 0x12
	char buf[12];
	ltoa(num, buf, 10);
    e28c:	8f 85       	ldd	r24, Y+15	; 0x0f
    e28e:	98 89       	ldd	r25, Y+16	; 0x10
    e290:	a9 89       	ldd	r26, Y+17	; 0x11
    e292:	ba 89       	ldd	r27, Y+18	; 0x12
    e294:	2a e0       	ldi	r18, 0x0A	; 10
    e296:	30 e0       	ldi	r19, 0x00	; 0
    e298:	ae 01       	movw	r20, r28
    e29a:	4f 5f       	subi	r20, 0xFF	; 255
    e29c:	5f 4f       	sbci	r21, 0xFF	; 255
    e29e:	bc 01       	movw	r22, r24
    e2a0:	cd 01       	movw	r24, r26
    e2a2:	0e 94 a7 b1 	call	0x1634e	; 0x1634e <ltoa>
	return concat(buf, strlen(buf));
    e2a6:	ce 01       	movw	r24, r28
    e2a8:	01 96       	adiw	r24, 0x01	; 1
    e2aa:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    e2ae:	9c 01       	movw	r18, r24
    e2b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    e2b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    e2b4:	a9 01       	movw	r20, r18
    e2b6:	9e 01       	movw	r18, r28
    e2b8:	2f 5f       	subi	r18, 0xFF	; 255
    e2ba:	3f 4f       	sbci	r19, 0xFF	; 255
    e2bc:	b9 01       	movw	r22, r18
    e2be:	0e 94 0e 70 	call	0xe01c	; 0xe01c <_ZN6String6concatEPKcj>
}
    e2c2:	62 96       	adiw	r28, 0x12	; 18
    e2c4:	0f b6       	in	r0, 0x3f	; 63
    e2c6:	f8 94       	cli
    e2c8:	de bf       	out	0x3e, r29	; 62
    e2ca:	0f be       	out	0x3f, r0	; 63
    e2cc:	cd bf       	out	0x3d, r28	; 61
    e2ce:	df 91       	pop	r29
    e2d0:	cf 91       	pop	r28
    e2d2:	08 95       	ret

0000e2d4 <_ZN6String6concatEm>:

unsigned char String::concat(unsigned long num)
{
    e2d4:	cf 93       	push	r28
    e2d6:	df 93       	push	r29
    e2d8:	cd b7       	in	r28, 0x3d	; 61
    e2da:	de b7       	in	r29, 0x3e	; 62
    e2dc:	61 97       	sbiw	r28, 0x11	; 17
    e2de:	0f b6       	in	r0, 0x3f	; 63
    e2e0:	f8 94       	cli
    e2e2:	de bf       	out	0x3e, r29	; 62
    e2e4:	0f be       	out	0x3f, r0	; 63
    e2e6:	cd bf       	out	0x3d, r28	; 61
    e2e8:	9d 87       	std	Y+13, r25	; 0x0d
    e2ea:	8c 87       	std	Y+12, r24	; 0x0c
    e2ec:	4e 87       	std	Y+14, r20	; 0x0e
    e2ee:	5f 87       	std	Y+15, r21	; 0x0f
    e2f0:	68 8b       	std	Y+16, r22	; 0x10
    e2f2:	79 8b       	std	Y+17, r23	; 0x11
	char buf[11];
	ultoa(num, buf, 10);
    e2f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    e2f6:	9f 85       	ldd	r25, Y+15	; 0x0f
    e2f8:	a8 89       	ldd	r26, Y+16	; 0x10
    e2fa:	b9 89       	ldd	r27, Y+17	; 0x11
    e2fc:	2a e0       	ldi	r18, 0x0A	; 10
    e2fe:	30 e0       	ldi	r19, 0x00	; 0
    e300:	ae 01       	movw	r20, r28
    e302:	4f 5f       	subi	r20, 0xFF	; 255
    e304:	5f 4f       	sbci	r21, 0xFF	; 255
    e306:	bc 01       	movw	r22, r24
    e308:	cd 01       	movw	r24, r26
    e30a:	0e 94 f0 b1 	call	0x163e0	; 0x163e0 <ultoa>
	return concat(buf, strlen(buf));
    e30e:	ce 01       	movw	r24, r28
    e310:	01 96       	adiw	r24, 0x01	; 1
    e312:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    e316:	9c 01       	movw	r18, r24
    e318:	8c 85       	ldd	r24, Y+12	; 0x0c
    e31a:	9d 85       	ldd	r25, Y+13	; 0x0d
    e31c:	a9 01       	movw	r20, r18
    e31e:	9e 01       	movw	r18, r28
    e320:	2f 5f       	subi	r18, 0xFF	; 255
    e322:	3f 4f       	sbci	r19, 0xFF	; 255
    e324:	b9 01       	movw	r22, r18
    e326:	0e 94 0e 70 	call	0xe01c	; 0xe01c <_ZN6String6concatEPKcj>
}
    e32a:	61 96       	adiw	r28, 0x11	; 17
    e32c:	0f b6       	in	r0, 0x3f	; 63
    e32e:	f8 94       	cli
    e330:	de bf       	out	0x3e, r29	; 62
    e332:	0f be       	out	0x3f, r0	; 63
    e334:	cd bf       	out	0x3d, r28	; 61
    e336:	df 91       	pop	r29
    e338:	cf 91       	pop	r28
    e33a:	08 95       	ret

0000e33c <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
    e33c:	cf 93       	push	r28
    e33e:	df 93       	push	r29
    e340:	00 d0       	rcall	.+0      	; 0xe342 <_ZplRK15StringSumHelperRK6String+0x6>
    e342:	00 d0       	rcall	.+0      	; 0xe344 <_ZplRK15StringSumHelperRK6String+0x8>
    e344:	00 d0       	rcall	.+0      	; 0xe346 <_ZplRK15StringSumHelperRK6String+0xa>
    e346:	cd b7       	in	r28, 0x3d	; 61
    e348:	de b7       	in	r29, 0x3e	; 62
    e34a:	9c 83       	std	Y+4, r25	; 0x04
    e34c:	8b 83       	std	Y+3, r24	; 0x03
    e34e:	7e 83       	std	Y+6, r23	; 0x06
    e350:	6d 83       	std	Y+5, r22	; 0x05
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
    e352:	8b 81       	ldd	r24, Y+3	; 0x03
    e354:	9c 81       	ldd	r25, Y+4	; 0x04
    e356:	9a 83       	std	Y+2, r25	; 0x02
    e358:	89 83       	std	Y+1, r24	; 0x01
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
    e35a:	8d 81       	ldd	r24, Y+5	; 0x05
    e35c:	9e 81       	ldd	r25, Y+6	; 0x06
    e35e:	fc 01       	movw	r30, r24
    e360:	44 81       	ldd	r20, Z+4	; 0x04
    e362:	55 81       	ldd	r21, Z+5	; 0x05
    e364:	8d 81       	ldd	r24, Y+5	; 0x05
    e366:	9e 81       	ldd	r25, Y+6	; 0x06
    e368:	fc 01       	movw	r30, r24
    e36a:	20 81       	ld	r18, Z
    e36c:	31 81       	ldd	r19, Z+1	; 0x01
    e36e:	89 81       	ldd	r24, Y+1	; 0x01
    e370:	9a 81       	ldd	r25, Y+2	; 0x02
    e372:	b9 01       	movw	r22, r18
    e374:	0e 94 0e 70 	call	0xe01c	; 0xe01c <_ZN6String6concatEPKcj>
    e378:	98 2f       	mov	r25, r24
    e37a:	81 e0       	ldi	r24, 0x01	; 1
    e37c:	99 23       	and	r25, r25
    e37e:	09 f0       	breq	.+2      	; 0xe382 <_ZplRK15StringSumHelperRK6String+0x46>
    e380:	80 e0       	ldi	r24, 0x00	; 0
    e382:	88 23       	and	r24, r24
    e384:	21 f0       	breq	.+8      	; 0xe38e <_ZplRK15StringSumHelperRK6String+0x52>
    e386:	89 81       	ldd	r24, Y+1	; 0x01
    e388:	9a 81       	ldd	r25, Y+2	; 0x02
    e38a:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
	return a;
    e38e:	89 81       	ldd	r24, Y+1	; 0x01
    e390:	9a 81       	ldd	r25, Y+2	; 0x02
}
    e392:	26 96       	adiw	r28, 0x06	; 6
    e394:	0f b6       	in	r0, 0x3f	; 63
    e396:	f8 94       	cli
    e398:	de bf       	out	0x3e, r29	; 62
    e39a:	0f be       	out	0x3f, r0	; 63
    e39c:	cd bf       	out	0x3d, r28	; 61
    e39e:	df 91       	pop	r29
    e3a0:	cf 91       	pop	r28
    e3a2:	08 95       	ret

0000e3a4 <_ZplRK15StringSumHelperPKc>:

StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
{
    e3a4:	cf 93       	push	r28
    e3a6:	df 93       	push	r29
    e3a8:	00 d0       	rcall	.+0      	; 0xe3aa <_ZplRK15StringSumHelperPKc+0x6>
    e3aa:	00 d0       	rcall	.+0      	; 0xe3ac <_ZplRK15StringSumHelperPKc+0x8>
    e3ac:	00 d0       	rcall	.+0      	; 0xe3ae <_ZplRK15StringSumHelperPKc+0xa>
    e3ae:	cd b7       	in	r28, 0x3d	; 61
    e3b0:	de b7       	in	r29, 0x3e	; 62
    e3b2:	9c 83       	std	Y+4, r25	; 0x04
    e3b4:	8b 83       	std	Y+3, r24	; 0x03
    e3b6:	7e 83       	std	Y+6, r23	; 0x06
    e3b8:	6d 83       	std	Y+5, r22	; 0x05
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
    e3ba:	8b 81       	ldd	r24, Y+3	; 0x03
    e3bc:	9c 81       	ldd	r25, Y+4	; 0x04
    e3be:	9a 83       	std	Y+2, r25	; 0x02
    e3c0:	89 83       	std	Y+1, r24	; 0x01
	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
    e3c2:	8d 81       	ldd	r24, Y+5	; 0x05
    e3c4:	9e 81       	ldd	r25, Y+6	; 0x06
    e3c6:	00 97       	sbiw	r24, 0x00	; 0
    e3c8:	71 f0       	breq	.+28     	; 0xe3e6 <_ZplRK15StringSumHelperPKc+0x42>
    e3ca:	8d 81       	ldd	r24, Y+5	; 0x05
    e3cc:	9e 81       	ldd	r25, Y+6	; 0x06
    e3ce:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
    e3d2:	ac 01       	movw	r20, r24
    e3d4:	89 81       	ldd	r24, Y+1	; 0x01
    e3d6:	9a 81       	ldd	r25, Y+2	; 0x02
    e3d8:	2d 81       	ldd	r18, Y+5	; 0x05
    e3da:	3e 81       	ldd	r19, Y+6	; 0x06
    e3dc:	b9 01       	movw	r22, r18
    e3de:	0e 94 0e 70 	call	0xe01c	; 0xe01c <_ZN6String6concatEPKcj>
    e3e2:	88 23       	and	r24, r24
    e3e4:	11 f4       	brne	.+4      	; 0xe3ea <_ZplRK15StringSumHelperPKc+0x46>
    e3e6:	81 e0       	ldi	r24, 0x01	; 1
    e3e8:	01 c0       	rjmp	.+2      	; 0xe3ec <_ZplRK15StringSumHelperPKc+0x48>
    e3ea:	80 e0       	ldi	r24, 0x00	; 0
    e3ec:	88 23       	and	r24, r24
    e3ee:	21 f0       	breq	.+8      	; 0xe3f8 <_ZplRK15StringSumHelperPKc+0x54>
    e3f0:	89 81       	ldd	r24, Y+1	; 0x01
    e3f2:	9a 81       	ldd	r25, Y+2	; 0x02
    e3f4:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
	return a;
    e3f8:	89 81       	ldd	r24, Y+1	; 0x01
    e3fa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    e3fc:	26 96       	adiw	r28, 0x06	; 6
    e3fe:	0f b6       	in	r0, 0x3f	; 63
    e400:	f8 94       	cli
    e402:	de bf       	out	0x3e, r29	; 62
    e404:	0f be       	out	0x3f, r0	; 63
    e406:	cd bf       	out	0x3d, r28	; 61
    e408:	df 91       	pop	r29
    e40a:	cf 91       	pop	r28
    e40c:	08 95       	ret

0000e40e <_ZplRK15StringSumHelperc>:

StringSumHelper & operator + (const StringSumHelper &lhs, char c)
{
    e40e:	cf 93       	push	r28
    e410:	df 93       	push	r29
    e412:	00 d0       	rcall	.+0      	; 0xe414 <_ZplRK15StringSumHelperc+0x6>
    e414:	00 d0       	rcall	.+0      	; 0xe416 <_ZplRK15StringSumHelperc+0x8>
    e416:	1f 92       	push	r1
    e418:	cd b7       	in	r28, 0x3d	; 61
    e41a:	de b7       	in	r29, 0x3e	; 62
    e41c:	9c 83       	std	Y+4, r25	; 0x04
    e41e:	8b 83       	std	Y+3, r24	; 0x03
    e420:	6d 83       	std	Y+5, r22	; 0x05
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
    e422:	8b 81       	ldd	r24, Y+3	; 0x03
    e424:	9c 81       	ldd	r25, Y+4	; 0x04
    e426:	9a 83       	std	Y+2, r25	; 0x02
    e428:	89 83       	std	Y+1, r24	; 0x01
	if (!a.concat(c)) a.invalidate();
    e42a:	89 81       	ldd	r24, Y+1	; 0x01
    e42c:	9a 81       	ldd	r25, Y+2	; 0x02
    e42e:	6d 81       	ldd	r22, Y+5	; 0x05
    e430:	0e 94 8a 70 	call	0xe114	; 0xe114 <_ZN6String6concatEc>
    e434:	98 2f       	mov	r25, r24
    e436:	81 e0       	ldi	r24, 0x01	; 1
    e438:	99 23       	and	r25, r25
    e43a:	09 f0       	breq	.+2      	; 0xe43e <_ZplRK15StringSumHelperc+0x30>
    e43c:	80 e0       	ldi	r24, 0x00	; 0
    e43e:	88 23       	and	r24, r24
    e440:	21 f0       	breq	.+8      	; 0xe44a <_ZplRK15StringSumHelperc+0x3c>
    e442:	89 81       	ldd	r24, Y+1	; 0x01
    e444:	9a 81       	ldd	r25, Y+2	; 0x02
    e446:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
	return a;
    e44a:	89 81       	ldd	r24, Y+1	; 0x01
    e44c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    e44e:	0f 90       	pop	r0
    e450:	0f 90       	pop	r0
    e452:	0f 90       	pop	r0
    e454:	0f 90       	pop	r0
    e456:	0f 90       	pop	r0
    e458:	df 91       	pop	r29
    e45a:	cf 91       	pop	r28
    e45c:	08 95       	ret

0000e45e <_ZplRK15StringSumHelperh>:

StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num)
{
    e45e:	cf 93       	push	r28
    e460:	df 93       	push	r29
    e462:	00 d0       	rcall	.+0      	; 0xe464 <_ZplRK15StringSumHelperh+0x6>
    e464:	00 d0       	rcall	.+0      	; 0xe466 <_ZplRK15StringSumHelperh+0x8>
    e466:	1f 92       	push	r1
    e468:	cd b7       	in	r28, 0x3d	; 61
    e46a:	de b7       	in	r29, 0x3e	; 62
    e46c:	9c 83       	std	Y+4, r25	; 0x04
    e46e:	8b 83       	std	Y+3, r24	; 0x03
    e470:	6d 83       	std	Y+5, r22	; 0x05
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
    e472:	8b 81       	ldd	r24, Y+3	; 0x03
    e474:	9c 81       	ldd	r25, Y+4	; 0x04
    e476:	9a 83       	std	Y+2, r25	; 0x02
    e478:	89 83       	std	Y+1, r24	; 0x01
	if (!a.concat(num)) a.invalidate();
    e47a:	89 81       	ldd	r24, Y+1	; 0x01
    e47c:	9a 81       	ldd	r25, Y+2	; 0x02
    e47e:	6d 81       	ldd	r22, Y+5	; 0x05
    e480:	0e 94 a9 70 	call	0xe152	; 0xe152 <_ZN6String6concatEh>
    e484:	98 2f       	mov	r25, r24
    e486:	81 e0       	ldi	r24, 0x01	; 1
    e488:	99 23       	and	r25, r25
    e48a:	09 f0       	breq	.+2      	; 0xe48e <_ZplRK15StringSumHelperh+0x30>
    e48c:	80 e0       	ldi	r24, 0x00	; 0
    e48e:	88 23       	and	r24, r24
    e490:	21 f0       	breq	.+8      	; 0xe49a <_ZplRK15StringSumHelperh+0x3c>
    e492:	89 81       	ldd	r24, Y+1	; 0x01
    e494:	9a 81       	ldd	r25, Y+2	; 0x02
    e496:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
	return a;
    e49a:	89 81       	ldd	r24, Y+1	; 0x01
    e49c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    e49e:	0f 90       	pop	r0
    e4a0:	0f 90       	pop	r0
    e4a2:	0f 90       	pop	r0
    e4a4:	0f 90       	pop	r0
    e4a6:	0f 90       	pop	r0
    e4a8:	df 91       	pop	r29
    e4aa:	cf 91       	pop	r28
    e4ac:	08 95       	ret

0000e4ae <_ZplRK15StringSumHelperi>:

StringSumHelper & operator + (const StringSumHelper &lhs, int num)
{
    e4ae:	cf 93       	push	r28
    e4b0:	df 93       	push	r29
    e4b2:	00 d0       	rcall	.+0      	; 0xe4b4 <_ZplRK15StringSumHelperi+0x6>
    e4b4:	00 d0       	rcall	.+0      	; 0xe4b6 <_ZplRK15StringSumHelperi+0x8>
    e4b6:	00 d0       	rcall	.+0      	; 0xe4b8 <_ZplRK15StringSumHelperi+0xa>
    e4b8:	cd b7       	in	r28, 0x3d	; 61
    e4ba:	de b7       	in	r29, 0x3e	; 62
    e4bc:	9c 83       	std	Y+4, r25	; 0x04
    e4be:	8b 83       	std	Y+3, r24	; 0x03
    e4c0:	7e 83       	std	Y+6, r23	; 0x06
    e4c2:	6d 83       	std	Y+5, r22	; 0x05
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
    e4c4:	8b 81       	ldd	r24, Y+3	; 0x03
    e4c6:	9c 81       	ldd	r25, Y+4	; 0x04
    e4c8:	9a 83       	std	Y+2, r25	; 0x02
    e4ca:	89 83       	std	Y+1, r24	; 0x01
	if (!a.concat(num)) a.invalidate();
    e4cc:	89 81       	ldd	r24, Y+1	; 0x01
    e4ce:	9a 81       	ldd	r25, Y+2	; 0x02
    e4d0:	2d 81       	ldd	r18, Y+5	; 0x05
    e4d2:	3e 81       	ldd	r19, Y+6	; 0x06
    e4d4:	b9 01       	movw	r22, r18
    e4d6:	0e 94 d8 70 	call	0xe1b0	; 0xe1b0 <_ZN6String6concatEi>
    e4da:	98 2f       	mov	r25, r24
    e4dc:	81 e0       	ldi	r24, 0x01	; 1
    e4de:	99 23       	and	r25, r25
    e4e0:	09 f0       	breq	.+2      	; 0xe4e4 <_ZplRK15StringSumHelperi+0x36>
    e4e2:	80 e0       	ldi	r24, 0x00	; 0
    e4e4:	88 23       	and	r24, r24
    e4e6:	21 f0       	breq	.+8      	; 0xe4f0 <_ZplRK15StringSumHelperi+0x42>
    e4e8:	89 81       	ldd	r24, Y+1	; 0x01
    e4ea:	9a 81       	ldd	r25, Y+2	; 0x02
    e4ec:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
	return a;
    e4f0:	89 81       	ldd	r24, Y+1	; 0x01
    e4f2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    e4f4:	26 96       	adiw	r28, 0x06	; 6
    e4f6:	0f b6       	in	r0, 0x3f	; 63
    e4f8:	f8 94       	cli
    e4fa:	de bf       	out	0x3e, r29	; 62
    e4fc:	0f be       	out	0x3f, r0	; 63
    e4fe:	cd bf       	out	0x3d, r28	; 61
    e500:	df 91       	pop	r29
    e502:	cf 91       	pop	r28
    e504:	08 95       	ret

0000e506 <_ZplRK15StringSumHelperj>:

StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num)
{
    e506:	cf 93       	push	r28
    e508:	df 93       	push	r29
    e50a:	00 d0       	rcall	.+0      	; 0xe50c <_ZplRK15StringSumHelperj+0x6>
    e50c:	00 d0       	rcall	.+0      	; 0xe50e <_ZplRK15StringSumHelperj+0x8>
    e50e:	00 d0       	rcall	.+0      	; 0xe510 <_ZplRK15StringSumHelperj+0xa>
    e510:	cd b7       	in	r28, 0x3d	; 61
    e512:	de b7       	in	r29, 0x3e	; 62
    e514:	9c 83       	std	Y+4, r25	; 0x04
    e516:	8b 83       	std	Y+3, r24	; 0x03
    e518:	7e 83       	std	Y+6, r23	; 0x06
    e51a:	6d 83       	std	Y+5, r22	; 0x05
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
    e51c:	8b 81       	ldd	r24, Y+3	; 0x03
    e51e:	9c 81       	ldd	r25, Y+4	; 0x04
    e520:	9a 83       	std	Y+2, r25	; 0x02
    e522:	89 83       	std	Y+1, r24	; 0x01
	if (!a.concat(num)) a.invalidate();
    e524:	89 81       	ldd	r24, Y+1	; 0x01
    e526:	9a 81       	ldd	r25, Y+2	; 0x02
    e528:	2d 81       	ldd	r18, Y+5	; 0x05
    e52a:	3e 81       	ldd	r19, Y+6	; 0x06
    e52c:	b9 01       	movw	r22, r18
    e52e:	0e 94 07 71 	call	0xe20e	; 0xe20e <_ZN6String6concatEj>
    e532:	98 2f       	mov	r25, r24
    e534:	81 e0       	ldi	r24, 0x01	; 1
    e536:	99 23       	and	r25, r25
    e538:	09 f0       	breq	.+2      	; 0xe53c <_ZplRK15StringSumHelperj+0x36>
    e53a:	80 e0       	ldi	r24, 0x00	; 0
    e53c:	88 23       	and	r24, r24
    e53e:	21 f0       	breq	.+8      	; 0xe548 <_ZplRK15StringSumHelperj+0x42>
    e540:	89 81       	ldd	r24, Y+1	; 0x01
    e542:	9a 81       	ldd	r25, Y+2	; 0x02
    e544:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
	return a;
    e548:	89 81       	ldd	r24, Y+1	; 0x01
    e54a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    e54c:	26 96       	adiw	r28, 0x06	; 6
    e54e:	0f b6       	in	r0, 0x3f	; 63
    e550:	f8 94       	cli
    e552:	de bf       	out	0x3e, r29	; 62
    e554:	0f be       	out	0x3f, r0	; 63
    e556:	cd bf       	out	0x3d, r28	; 61
    e558:	df 91       	pop	r29
    e55a:	cf 91       	pop	r28
    e55c:	08 95       	ret

0000e55e <_ZplRK15StringSumHelperl>:

StringSumHelper & operator + (const StringSumHelper &lhs, long num)
{
    e55e:	cf 93       	push	r28
    e560:	df 93       	push	r29
    e562:	cd b7       	in	r28, 0x3d	; 61
    e564:	de b7       	in	r29, 0x3e	; 62
    e566:	28 97       	sbiw	r28, 0x08	; 8
    e568:	0f b6       	in	r0, 0x3f	; 63
    e56a:	f8 94       	cli
    e56c:	de bf       	out	0x3e, r29	; 62
    e56e:	0f be       	out	0x3f, r0	; 63
    e570:	cd bf       	out	0x3d, r28	; 61
    e572:	9c 83       	std	Y+4, r25	; 0x04
    e574:	8b 83       	std	Y+3, r24	; 0x03
    e576:	4d 83       	std	Y+5, r20	; 0x05
    e578:	5e 83       	std	Y+6, r21	; 0x06
    e57a:	6f 83       	std	Y+7, r22	; 0x07
    e57c:	78 87       	std	Y+8, r23	; 0x08
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
    e57e:	8b 81       	ldd	r24, Y+3	; 0x03
    e580:	9c 81       	ldd	r25, Y+4	; 0x04
    e582:	9a 83       	std	Y+2, r25	; 0x02
    e584:	89 83       	std	Y+1, r24	; 0x01
	if (!a.concat(num)) a.invalidate();
    e586:	29 81       	ldd	r18, Y+1	; 0x01
    e588:	3a 81       	ldd	r19, Y+2	; 0x02
    e58a:	8d 81       	ldd	r24, Y+5	; 0x05
    e58c:	9e 81       	ldd	r25, Y+6	; 0x06
    e58e:	af 81       	ldd	r26, Y+7	; 0x07
    e590:	b8 85       	ldd	r27, Y+8	; 0x08
    e592:	ac 01       	movw	r20, r24
    e594:	bd 01       	movw	r22, r26
    e596:	c9 01       	movw	r24, r18
    e598:	0e 94 36 71 	call	0xe26c	; 0xe26c <_ZN6String6concatEl>
    e59c:	98 2f       	mov	r25, r24
    e59e:	81 e0       	ldi	r24, 0x01	; 1
    e5a0:	99 23       	and	r25, r25
    e5a2:	09 f0       	breq	.+2      	; 0xe5a6 <_ZplRK15StringSumHelperl+0x48>
    e5a4:	80 e0       	ldi	r24, 0x00	; 0
    e5a6:	88 23       	and	r24, r24
    e5a8:	21 f0       	breq	.+8      	; 0xe5b2 <_ZplRK15StringSumHelperl+0x54>
    e5aa:	89 81       	ldd	r24, Y+1	; 0x01
    e5ac:	9a 81       	ldd	r25, Y+2	; 0x02
    e5ae:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
	return a;
    e5b2:	89 81       	ldd	r24, Y+1	; 0x01
    e5b4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    e5b6:	28 96       	adiw	r28, 0x08	; 8
    e5b8:	0f b6       	in	r0, 0x3f	; 63
    e5ba:	f8 94       	cli
    e5bc:	de bf       	out	0x3e, r29	; 62
    e5be:	0f be       	out	0x3f, r0	; 63
    e5c0:	cd bf       	out	0x3d, r28	; 61
    e5c2:	df 91       	pop	r29
    e5c4:	cf 91       	pop	r28
    e5c6:	08 95       	ret

0000e5c8 <_ZplRK15StringSumHelperm>:

StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num)
{
    e5c8:	cf 93       	push	r28
    e5ca:	df 93       	push	r29
    e5cc:	cd b7       	in	r28, 0x3d	; 61
    e5ce:	de b7       	in	r29, 0x3e	; 62
    e5d0:	28 97       	sbiw	r28, 0x08	; 8
    e5d2:	0f b6       	in	r0, 0x3f	; 63
    e5d4:	f8 94       	cli
    e5d6:	de bf       	out	0x3e, r29	; 62
    e5d8:	0f be       	out	0x3f, r0	; 63
    e5da:	cd bf       	out	0x3d, r28	; 61
    e5dc:	9c 83       	std	Y+4, r25	; 0x04
    e5de:	8b 83       	std	Y+3, r24	; 0x03
    e5e0:	4d 83       	std	Y+5, r20	; 0x05
    e5e2:	5e 83       	std	Y+6, r21	; 0x06
    e5e4:	6f 83       	std	Y+7, r22	; 0x07
    e5e6:	78 87       	std	Y+8, r23	; 0x08
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
    e5e8:	8b 81       	ldd	r24, Y+3	; 0x03
    e5ea:	9c 81       	ldd	r25, Y+4	; 0x04
    e5ec:	9a 83       	std	Y+2, r25	; 0x02
    e5ee:	89 83       	std	Y+1, r24	; 0x01
	if (!a.concat(num)) a.invalidate();
    e5f0:	29 81       	ldd	r18, Y+1	; 0x01
    e5f2:	3a 81       	ldd	r19, Y+2	; 0x02
    e5f4:	8d 81       	ldd	r24, Y+5	; 0x05
    e5f6:	9e 81       	ldd	r25, Y+6	; 0x06
    e5f8:	af 81       	ldd	r26, Y+7	; 0x07
    e5fa:	b8 85       	ldd	r27, Y+8	; 0x08
    e5fc:	ac 01       	movw	r20, r24
    e5fe:	bd 01       	movw	r22, r26
    e600:	c9 01       	movw	r24, r18
    e602:	0e 94 6a 71 	call	0xe2d4	; 0xe2d4 <_ZN6String6concatEm>
    e606:	98 2f       	mov	r25, r24
    e608:	81 e0       	ldi	r24, 0x01	; 1
    e60a:	99 23       	and	r25, r25
    e60c:	09 f0       	breq	.+2      	; 0xe610 <_ZplRK15StringSumHelperm+0x48>
    e60e:	80 e0       	ldi	r24, 0x00	; 0
    e610:	88 23       	and	r24, r24
    e612:	21 f0       	breq	.+8      	; 0xe61c <_ZplRK15StringSumHelperm+0x54>
    e614:	89 81       	ldd	r24, Y+1	; 0x01
    e616:	9a 81       	ldd	r25, Y+2	; 0x02
    e618:	0e 94 a7 6e 	call	0xdd4e	; 0xdd4e <_ZN6String10invalidateEv>
	return a;
    e61c:	89 81       	ldd	r24, Y+1	; 0x01
    e61e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    e620:	28 96       	adiw	r28, 0x08	; 8
    e622:	0f b6       	in	r0, 0x3f	; 63
    e624:	f8 94       	cli
    e626:	de bf       	out	0x3e, r29	; 62
    e628:	0f be       	out	0x3f, r0	; 63
    e62a:	cd bf       	out	0x3d, r28	; 61
    e62c:	df 91       	pop	r29
    e62e:	cf 91       	pop	r28
    e630:	08 95       	ret

0000e632 <_ZNK6String9compareToERKS_>:
/*********************************************/
/*  Comparison                               */
/*********************************************/

int String::compareTo(const String &s) const
{
    e632:	cf 93       	push	r28
    e634:	df 93       	push	r29
    e636:	00 d0       	rcall	.+0      	; 0xe638 <_ZNK6String9compareToERKS_+0x6>
    e638:	00 d0       	rcall	.+0      	; 0xe63a <_ZNK6String9compareToERKS_+0x8>
    e63a:	cd b7       	in	r28, 0x3d	; 61
    e63c:	de b7       	in	r29, 0x3e	; 62
    e63e:	9a 83       	std	Y+2, r25	; 0x02
    e640:	89 83       	std	Y+1, r24	; 0x01
    e642:	7c 83       	std	Y+4, r23	; 0x04
    e644:	6b 83       	std	Y+3, r22	; 0x03
	if (!buffer || !s.buffer) {
    e646:	89 81       	ldd	r24, Y+1	; 0x01
    e648:	9a 81       	ldd	r25, Y+2	; 0x02
    e64a:	fc 01       	movw	r30, r24
    e64c:	80 81       	ld	r24, Z
    e64e:	91 81       	ldd	r25, Z+1	; 0x01
    e650:	00 97       	sbiw	r24, 0x00	; 0
    e652:	39 f0       	breq	.+14     	; 0xe662 <_ZNK6String9compareToERKS_+0x30>
    e654:	8b 81       	ldd	r24, Y+3	; 0x03
    e656:	9c 81       	ldd	r25, Y+4	; 0x04
    e658:	fc 01       	movw	r30, r24
    e65a:	80 81       	ld	r24, Z
    e65c:	91 81       	ldd	r25, Z+1	; 0x01
    e65e:	00 97       	sbiw	r24, 0x00	; 0
    e660:	b1 f5       	brne	.+108    	; 0xe6ce <_ZNK6String9compareToERKS_+0x9c>
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
    e662:	8b 81       	ldd	r24, Y+3	; 0x03
    e664:	9c 81       	ldd	r25, Y+4	; 0x04
    e666:	fc 01       	movw	r30, r24
    e668:	80 81       	ld	r24, Z
    e66a:	91 81       	ldd	r25, Z+1	; 0x01
    e66c:	00 97       	sbiw	r24, 0x00	; 0
    e66e:	a1 f0       	breq	.+40     	; 0xe698 <_ZNK6String9compareToERKS_+0x66>
    e670:	8b 81       	ldd	r24, Y+3	; 0x03
    e672:	9c 81       	ldd	r25, Y+4	; 0x04
    e674:	fc 01       	movw	r30, r24
    e676:	84 81       	ldd	r24, Z+4	; 0x04
    e678:	95 81       	ldd	r25, Z+5	; 0x05
    e67a:	00 97       	sbiw	r24, 0x00	; 0
    e67c:	69 f0       	breq	.+26     	; 0xe698 <_ZNK6String9compareToERKS_+0x66>
    e67e:	8b 81       	ldd	r24, Y+3	; 0x03
    e680:	9c 81       	ldd	r25, Y+4	; 0x04
    e682:	fc 01       	movw	r30, r24
    e684:	80 81       	ld	r24, Z
    e686:	91 81       	ldd	r25, Z+1	; 0x01
    e688:	fc 01       	movw	r30, r24
    e68a:	80 81       	ld	r24, Z
    e68c:	88 2f       	mov	r24, r24
    e68e:	90 e0       	ldi	r25, 0x00	; 0
    e690:	91 95       	neg	r25
    e692:	81 95       	neg	r24
    e694:	91 09       	sbc	r25, r1
    e696:	28 c0       	rjmp	.+80     	; 0xe6e8 <_ZNK6String9compareToERKS_+0xb6>
		if (buffer && len > 0) return *(unsigned char *)buffer;
    e698:	89 81       	ldd	r24, Y+1	; 0x01
    e69a:	9a 81       	ldd	r25, Y+2	; 0x02
    e69c:	fc 01       	movw	r30, r24
    e69e:	80 81       	ld	r24, Z
    e6a0:	91 81       	ldd	r25, Z+1	; 0x01
    e6a2:	00 97       	sbiw	r24, 0x00	; 0
    e6a4:	89 f0       	breq	.+34     	; 0xe6c8 <_ZNK6String9compareToERKS_+0x96>
    e6a6:	89 81       	ldd	r24, Y+1	; 0x01
    e6a8:	9a 81       	ldd	r25, Y+2	; 0x02
    e6aa:	fc 01       	movw	r30, r24
    e6ac:	84 81       	ldd	r24, Z+4	; 0x04
    e6ae:	95 81       	ldd	r25, Z+5	; 0x05
    e6b0:	00 97       	sbiw	r24, 0x00	; 0
    e6b2:	51 f0       	breq	.+20     	; 0xe6c8 <_ZNK6String9compareToERKS_+0x96>
    e6b4:	89 81       	ldd	r24, Y+1	; 0x01
    e6b6:	9a 81       	ldd	r25, Y+2	; 0x02
    e6b8:	fc 01       	movw	r30, r24
    e6ba:	80 81       	ld	r24, Z
    e6bc:	91 81       	ldd	r25, Z+1	; 0x01
    e6be:	fc 01       	movw	r30, r24
    e6c0:	80 81       	ld	r24, Z
    e6c2:	88 2f       	mov	r24, r24
    e6c4:	90 e0       	ldi	r25, 0x00	; 0
    e6c6:	10 c0       	rjmp	.+32     	; 0xe6e8 <_ZNK6String9compareToERKS_+0xb6>
		return 0;
    e6c8:	80 e0       	ldi	r24, 0x00	; 0
    e6ca:	90 e0       	ldi	r25, 0x00	; 0
    e6cc:	0d c0       	rjmp	.+26     	; 0xe6e8 <_ZNK6String9compareToERKS_+0xb6>
	}
	return strcmp(buffer, s.buffer);
    e6ce:	8b 81       	ldd	r24, Y+3	; 0x03
    e6d0:	9c 81       	ldd	r25, Y+4	; 0x04
    e6d2:	fc 01       	movw	r30, r24
    e6d4:	20 81       	ld	r18, Z
    e6d6:	31 81       	ldd	r19, Z+1	; 0x01
    e6d8:	89 81       	ldd	r24, Y+1	; 0x01
    e6da:	9a 81       	ldd	r25, Y+2	; 0x02
    e6dc:	fc 01       	movw	r30, r24
    e6de:	80 81       	ld	r24, Z
    e6e0:	91 81       	ldd	r25, Z+1	; 0x01
    e6e2:	b9 01       	movw	r22, r18
    e6e4:	0e 94 2b b1 	call	0x16256	; 0x16256 <strcmp>
}
    e6e8:	0f 90       	pop	r0
    e6ea:	0f 90       	pop	r0
    e6ec:	0f 90       	pop	r0
    e6ee:	0f 90       	pop	r0
    e6f0:	df 91       	pop	r29
    e6f2:	cf 91       	pop	r28
    e6f4:	08 95       	ret

0000e6f6 <_ZNK6String6equalsERKS_>:

unsigned char String::equals(const String &s2) const
{
    e6f6:	cf 93       	push	r28
    e6f8:	df 93       	push	r29
    e6fa:	00 d0       	rcall	.+0      	; 0xe6fc <_ZNK6String6equalsERKS_+0x6>
    e6fc:	00 d0       	rcall	.+0      	; 0xe6fe <_ZNK6String6equalsERKS_+0x8>
    e6fe:	cd b7       	in	r28, 0x3d	; 61
    e700:	de b7       	in	r29, 0x3e	; 62
    e702:	9a 83       	std	Y+2, r25	; 0x02
    e704:	89 83       	std	Y+1, r24	; 0x01
    e706:	7c 83       	std	Y+4, r23	; 0x04
    e708:	6b 83       	std	Y+3, r22	; 0x03
	return (len == s2.len && compareTo(s2) == 0);
    e70a:	89 81       	ldd	r24, Y+1	; 0x01
    e70c:	9a 81       	ldd	r25, Y+2	; 0x02
    e70e:	fc 01       	movw	r30, r24
    e710:	24 81       	ldd	r18, Z+4	; 0x04
    e712:	35 81       	ldd	r19, Z+5	; 0x05
    e714:	8b 81       	ldd	r24, Y+3	; 0x03
    e716:	9c 81       	ldd	r25, Y+4	; 0x04
    e718:	fc 01       	movw	r30, r24
    e71a:	84 81       	ldd	r24, Z+4	; 0x04
    e71c:	95 81       	ldd	r25, Z+5	; 0x05
    e71e:	28 17       	cp	r18, r24
    e720:	39 07       	cpc	r19, r25
    e722:	59 f4       	brne	.+22     	; 0xe73a <_ZNK6String6equalsERKS_+0x44>
    e724:	2b 81       	ldd	r18, Y+3	; 0x03
    e726:	3c 81       	ldd	r19, Y+4	; 0x04
    e728:	89 81       	ldd	r24, Y+1	; 0x01
    e72a:	9a 81       	ldd	r25, Y+2	; 0x02
    e72c:	b9 01       	movw	r22, r18
    e72e:	0e 94 19 73 	call	0xe632	; 0xe632 <_ZNK6String9compareToERKS_>
    e732:	00 97       	sbiw	r24, 0x00	; 0
    e734:	11 f4       	brne	.+4      	; 0xe73a <_ZNK6String6equalsERKS_+0x44>
    e736:	81 e0       	ldi	r24, 0x01	; 1
    e738:	01 c0       	rjmp	.+2      	; 0xe73c <_ZNK6String6equalsERKS_+0x46>
    e73a:	80 e0       	ldi	r24, 0x00	; 0
}
    e73c:	0f 90       	pop	r0
    e73e:	0f 90       	pop	r0
    e740:	0f 90       	pop	r0
    e742:	0f 90       	pop	r0
    e744:	df 91       	pop	r29
    e746:	cf 91       	pop	r28
    e748:	08 95       	ret

0000e74a <_ZNK6String6equalsEPKc>:

unsigned char String::equals(const char *cstr) const
{
    e74a:	cf 93       	push	r28
    e74c:	df 93       	push	r29
    e74e:	00 d0       	rcall	.+0      	; 0xe750 <_ZNK6String6equalsEPKc+0x6>
    e750:	00 d0       	rcall	.+0      	; 0xe752 <_ZNK6String6equalsEPKc+0x8>
    e752:	cd b7       	in	r28, 0x3d	; 61
    e754:	de b7       	in	r29, 0x3e	; 62
    e756:	9a 83       	std	Y+2, r25	; 0x02
    e758:	89 83       	std	Y+1, r24	; 0x01
    e75a:	7c 83       	std	Y+4, r23	; 0x04
    e75c:	6b 83       	std	Y+3, r22	; 0x03
	if (len == 0) return (cstr == NULL || *cstr == 0);
    e75e:	89 81       	ldd	r24, Y+1	; 0x01
    e760:	9a 81       	ldd	r25, Y+2	; 0x02
    e762:	fc 01       	movw	r30, r24
    e764:	84 81       	ldd	r24, Z+4	; 0x04
    e766:	95 81       	ldd	r25, Z+5	; 0x05
    e768:	00 97       	sbiw	r24, 0x00	; 0
    e76a:	71 f4       	brne	.+28     	; 0xe788 <_ZNK6String6equalsEPKc+0x3e>
    e76c:	8b 81       	ldd	r24, Y+3	; 0x03
    e76e:	9c 81       	ldd	r25, Y+4	; 0x04
    e770:	00 97       	sbiw	r24, 0x00	; 0
    e772:	31 f0       	breq	.+12     	; 0xe780 <_ZNK6String6equalsEPKc+0x36>
    e774:	8b 81       	ldd	r24, Y+3	; 0x03
    e776:	9c 81       	ldd	r25, Y+4	; 0x04
    e778:	fc 01       	movw	r30, r24
    e77a:	80 81       	ld	r24, Z
    e77c:	88 23       	and	r24, r24
    e77e:	11 f4       	brne	.+4      	; 0xe784 <_ZNK6String6equalsEPKc+0x3a>
    e780:	81 e0       	ldi	r24, 0x01	; 1
    e782:	01 c0       	rjmp	.+2      	; 0xe786 <_ZNK6String6equalsEPKc+0x3c>
    e784:	80 e0       	ldi	r24, 0x00	; 0
    e786:	1f c0       	rjmp	.+62     	; 0xe7c6 <_ZNK6String6equalsEPKc+0x7c>
	if (cstr == NULL) return buffer[0] == 0;
    e788:	8b 81       	ldd	r24, Y+3	; 0x03
    e78a:	9c 81       	ldd	r25, Y+4	; 0x04
    e78c:	00 97       	sbiw	r24, 0x00	; 0
    e78e:	61 f4       	brne	.+24     	; 0xe7a8 <_ZNK6String6equalsEPKc+0x5e>
    e790:	89 81       	ldd	r24, Y+1	; 0x01
    e792:	9a 81       	ldd	r25, Y+2	; 0x02
    e794:	fc 01       	movw	r30, r24
    e796:	80 81       	ld	r24, Z
    e798:	91 81       	ldd	r25, Z+1	; 0x01
    e79a:	fc 01       	movw	r30, r24
    e79c:	90 81       	ld	r25, Z
    e79e:	81 e0       	ldi	r24, 0x01	; 1
    e7a0:	99 23       	and	r25, r25
    e7a2:	09 f0       	breq	.+2      	; 0xe7a6 <_ZNK6String6equalsEPKc+0x5c>
    e7a4:	80 e0       	ldi	r24, 0x00	; 0
    e7a6:	0f c0       	rjmp	.+30     	; 0xe7c6 <_ZNK6String6equalsEPKc+0x7c>
	return strcmp(buffer, cstr) == 0;
    e7a8:	89 81       	ldd	r24, Y+1	; 0x01
    e7aa:	9a 81       	ldd	r25, Y+2	; 0x02
    e7ac:	fc 01       	movw	r30, r24
    e7ae:	80 81       	ld	r24, Z
    e7b0:	91 81       	ldd	r25, Z+1	; 0x01
    e7b2:	2b 81       	ldd	r18, Y+3	; 0x03
    e7b4:	3c 81       	ldd	r19, Y+4	; 0x04
    e7b6:	b9 01       	movw	r22, r18
    e7b8:	0e 94 2b b1 	call	0x16256	; 0x16256 <strcmp>
    e7bc:	21 e0       	ldi	r18, 0x01	; 1
    e7be:	00 97       	sbiw	r24, 0x00	; 0
    e7c0:	09 f0       	breq	.+2      	; 0xe7c4 <_ZNK6String6equalsEPKc+0x7a>
    e7c2:	20 e0       	ldi	r18, 0x00	; 0
    e7c4:	82 2f       	mov	r24, r18
}
    e7c6:	0f 90       	pop	r0
    e7c8:	0f 90       	pop	r0
    e7ca:	0f 90       	pop	r0
    e7cc:	0f 90       	pop	r0
    e7ce:	df 91       	pop	r29
    e7d0:	cf 91       	pop	r28
    e7d2:	08 95       	ret

0000e7d4 <_ZNK6StringltERKS_>:

unsigned char String::operator<(const String &rhs) const
{
    e7d4:	cf 93       	push	r28
    e7d6:	df 93       	push	r29
    e7d8:	00 d0       	rcall	.+0      	; 0xe7da <_ZNK6StringltERKS_+0x6>
    e7da:	00 d0       	rcall	.+0      	; 0xe7dc <_ZNK6StringltERKS_+0x8>
    e7dc:	cd b7       	in	r28, 0x3d	; 61
    e7de:	de b7       	in	r29, 0x3e	; 62
    e7e0:	9a 83       	std	Y+2, r25	; 0x02
    e7e2:	89 83       	std	Y+1, r24	; 0x01
    e7e4:	7c 83       	std	Y+4, r23	; 0x04
    e7e6:	6b 83       	std	Y+3, r22	; 0x03
	return compareTo(rhs) < 0;
    e7e8:	2b 81       	ldd	r18, Y+3	; 0x03
    e7ea:	3c 81       	ldd	r19, Y+4	; 0x04
    e7ec:	89 81       	ldd	r24, Y+1	; 0x01
    e7ee:	9a 81       	ldd	r25, Y+2	; 0x02
    e7f0:	b9 01       	movw	r22, r18
    e7f2:	0e 94 19 73 	call	0xe632	; 0xe632 <_ZNK6String9compareToERKS_>
    e7f6:	89 2f       	mov	r24, r25
    e7f8:	88 1f       	adc	r24, r24
    e7fa:	88 27       	eor	r24, r24
    e7fc:	88 1f       	adc	r24, r24
}
    e7fe:	0f 90       	pop	r0
    e800:	0f 90       	pop	r0
    e802:	0f 90       	pop	r0
    e804:	0f 90       	pop	r0
    e806:	df 91       	pop	r29
    e808:	cf 91       	pop	r28
    e80a:	08 95       	ret

0000e80c <_ZNK6StringgtERKS_>:

unsigned char String::operator>(const String &rhs) const
{
    e80c:	cf 93       	push	r28
    e80e:	df 93       	push	r29
    e810:	00 d0       	rcall	.+0      	; 0xe812 <_ZNK6StringgtERKS_+0x6>
    e812:	00 d0       	rcall	.+0      	; 0xe814 <_ZNK6StringgtERKS_+0x8>
    e814:	cd b7       	in	r28, 0x3d	; 61
    e816:	de b7       	in	r29, 0x3e	; 62
    e818:	9a 83       	std	Y+2, r25	; 0x02
    e81a:	89 83       	std	Y+1, r24	; 0x01
    e81c:	7c 83       	std	Y+4, r23	; 0x04
    e81e:	6b 83       	std	Y+3, r22	; 0x03
	return compareTo(rhs) > 0;
    e820:	2b 81       	ldd	r18, Y+3	; 0x03
    e822:	3c 81       	ldd	r19, Y+4	; 0x04
    e824:	89 81       	ldd	r24, Y+1	; 0x01
    e826:	9a 81       	ldd	r25, Y+2	; 0x02
    e828:	b9 01       	movw	r22, r18
    e82a:	0e 94 19 73 	call	0xe632	; 0xe632 <_ZNK6String9compareToERKS_>
    e82e:	21 e0       	ldi	r18, 0x01	; 1
    e830:	18 16       	cp	r1, r24
    e832:	19 06       	cpc	r1, r25
    e834:	0c f0       	brlt	.+2      	; 0xe838 <_ZNK6StringgtERKS_+0x2c>
    e836:	20 e0       	ldi	r18, 0x00	; 0
    e838:	82 2f       	mov	r24, r18
}
    e83a:	0f 90       	pop	r0
    e83c:	0f 90       	pop	r0
    e83e:	0f 90       	pop	r0
    e840:	0f 90       	pop	r0
    e842:	df 91       	pop	r29
    e844:	cf 91       	pop	r28
    e846:	08 95       	ret

0000e848 <_ZNK6StringleERKS_>:

unsigned char String::operator<=(const String &rhs) const
{
    e848:	cf 93       	push	r28
    e84a:	df 93       	push	r29
    e84c:	00 d0       	rcall	.+0      	; 0xe84e <_ZNK6StringleERKS_+0x6>
    e84e:	00 d0       	rcall	.+0      	; 0xe850 <_ZNK6StringleERKS_+0x8>
    e850:	cd b7       	in	r28, 0x3d	; 61
    e852:	de b7       	in	r29, 0x3e	; 62
    e854:	9a 83       	std	Y+2, r25	; 0x02
    e856:	89 83       	std	Y+1, r24	; 0x01
    e858:	7c 83       	std	Y+4, r23	; 0x04
    e85a:	6b 83       	std	Y+3, r22	; 0x03
	return compareTo(rhs) <= 0;
    e85c:	2b 81       	ldd	r18, Y+3	; 0x03
    e85e:	3c 81       	ldd	r19, Y+4	; 0x04
    e860:	89 81       	ldd	r24, Y+1	; 0x01
    e862:	9a 81       	ldd	r25, Y+2	; 0x02
    e864:	b9 01       	movw	r22, r18
    e866:	0e 94 19 73 	call	0xe632	; 0xe632 <_ZNK6String9compareToERKS_>
    e86a:	21 e0       	ldi	r18, 0x01	; 1
    e86c:	18 16       	cp	r1, r24
    e86e:	19 06       	cpc	r1, r25
    e870:	0c f4       	brge	.+2      	; 0xe874 <_ZNK6StringleERKS_+0x2c>
    e872:	20 e0       	ldi	r18, 0x00	; 0
    e874:	82 2f       	mov	r24, r18
}
    e876:	0f 90       	pop	r0
    e878:	0f 90       	pop	r0
    e87a:	0f 90       	pop	r0
    e87c:	0f 90       	pop	r0
    e87e:	df 91       	pop	r29
    e880:	cf 91       	pop	r28
    e882:	08 95       	ret

0000e884 <_ZNK6StringgeERKS_>:

unsigned char String::operator>=(const String &rhs) const
{
    e884:	cf 93       	push	r28
    e886:	df 93       	push	r29
    e888:	00 d0       	rcall	.+0      	; 0xe88a <_ZNK6StringgeERKS_+0x6>
    e88a:	00 d0       	rcall	.+0      	; 0xe88c <_ZNK6StringgeERKS_+0x8>
    e88c:	cd b7       	in	r28, 0x3d	; 61
    e88e:	de b7       	in	r29, 0x3e	; 62
    e890:	9a 83       	std	Y+2, r25	; 0x02
    e892:	89 83       	std	Y+1, r24	; 0x01
    e894:	7c 83       	std	Y+4, r23	; 0x04
    e896:	6b 83       	std	Y+3, r22	; 0x03
	return compareTo(rhs) >= 0;
    e898:	2b 81       	ldd	r18, Y+3	; 0x03
    e89a:	3c 81       	ldd	r19, Y+4	; 0x04
    e89c:	89 81       	ldd	r24, Y+1	; 0x01
    e89e:	9a 81       	ldd	r25, Y+2	; 0x02
    e8a0:	b9 01       	movw	r22, r18
    e8a2:	0e 94 19 73 	call	0xe632	; 0xe632 <_ZNK6String9compareToERKS_>
    e8a6:	89 2f       	mov	r24, r25
    e8a8:	80 95       	com	r24
    e8aa:	88 1f       	adc	r24, r24
    e8ac:	88 27       	eor	r24, r24
    e8ae:	88 1f       	adc	r24, r24
}
    e8b0:	0f 90       	pop	r0
    e8b2:	0f 90       	pop	r0
    e8b4:	0f 90       	pop	r0
    e8b6:	0f 90       	pop	r0
    e8b8:	df 91       	pop	r29
    e8ba:	cf 91       	pop	r28
    e8bc:	08 95       	ret

0000e8be <_ZNK6String16equalsIgnoreCaseERKS_>:

unsigned char String::equalsIgnoreCase( const String &s2 ) const
{
    e8be:	0f 93       	push	r16
    e8c0:	1f 93       	push	r17
    e8c2:	cf 93       	push	r28
    e8c4:	df 93       	push	r29
    e8c6:	cd b7       	in	r28, 0x3d	; 61
    e8c8:	de b7       	in	r29, 0x3e	; 62
    e8ca:	28 97       	sbiw	r28, 0x08	; 8
    e8cc:	0f b6       	in	r0, 0x3f	; 63
    e8ce:	f8 94       	cli
    e8d0:	de bf       	out	0x3e, r29	; 62
    e8d2:	0f be       	out	0x3f, r0	; 63
    e8d4:	cd bf       	out	0x3d, r28	; 61
    e8d6:	9e 83       	std	Y+6, r25	; 0x06
    e8d8:	8d 83       	std	Y+5, r24	; 0x05
    e8da:	78 87       	std	Y+8, r23	; 0x08
    e8dc:	6f 83       	std	Y+7, r22	; 0x07
	if (this == &s2) return 1;
    e8de:	2d 81       	ldd	r18, Y+5	; 0x05
    e8e0:	3e 81       	ldd	r19, Y+6	; 0x06
    e8e2:	8f 81       	ldd	r24, Y+7	; 0x07
    e8e4:	98 85       	ldd	r25, Y+8	; 0x08
    e8e6:	28 17       	cp	r18, r24
    e8e8:	39 07       	cpc	r19, r25
    e8ea:	11 f4       	brne	.+4      	; 0xe8f0 <_ZNK6String16equalsIgnoreCaseERKS_+0x32>
    e8ec:	81 e0       	ldi	r24, 0x01	; 1
    e8ee:	58 c0       	rjmp	.+176    	; 0xe9a0 <_ZNK6String16equalsIgnoreCaseERKS_+0xe2>
	if (len != s2.len) return 0;
    e8f0:	8d 81       	ldd	r24, Y+5	; 0x05
    e8f2:	9e 81       	ldd	r25, Y+6	; 0x06
    e8f4:	fc 01       	movw	r30, r24
    e8f6:	24 81       	ldd	r18, Z+4	; 0x04
    e8f8:	35 81       	ldd	r19, Z+5	; 0x05
    e8fa:	8f 81       	ldd	r24, Y+7	; 0x07
    e8fc:	98 85       	ldd	r25, Y+8	; 0x08
    e8fe:	fc 01       	movw	r30, r24
    e900:	84 81       	ldd	r24, Z+4	; 0x04
    e902:	95 81       	ldd	r25, Z+5	; 0x05
    e904:	28 17       	cp	r18, r24
    e906:	39 07       	cpc	r19, r25
    e908:	11 f0       	breq	.+4      	; 0xe90e <_ZNK6String16equalsIgnoreCaseERKS_+0x50>
    e90a:	80 e0       	ldi	r24, 0x00	; 0
    e90c:	49 c0       	rjmp	.+146    	; 0xe9a0 <_ZNK6String16equalsIgnoreCaseERKS_+0xe2>
	if (len == 0) return 1;
    e90e:	8d 81       	ldd	r24, Y+5	; 0x05
    e910:	9e 81       	ldd	r25, Y+6	; 0x06
    e912:	fc 01       	movw	r30, r24
    e914:	84 81       	ldd	r24, Z+4	; 0x04
    e916:	95 81       	ldd	r25, Z+5	; 0x05
    e918:	00 97       	sbiw	r24, 0x00	; 0
    e91a:	11 f4       	brne	.+4      	; 0xe920 <_ZNK6String16equalsIgnoreCaseERKS_+0x62>
    e91c:	81 e0       	ldi	r24, 0x01	; 1
    e91e:	40 c0       	rjmp	.+128    	; 0xe9a0 <_ZNK6String16equalsIgnoreCaseERKS_+0xe2>
	const char *p1 = buffer;
    e920:	8d 81       	ldd	r24, Y+5	; 0x05
    e922:	9e 81       	ldd	r25, Y+6	; 0x06
    e924:	fc 01       	movw	r30, r24
    e926:	80 81       	ld	r24, Z
    e928:	91 81       	ldd	r25, Z+1	; 0x01
    e92a:	9a 83       	std	Y+2, r25	; 0x02
    e92c:	89 83       	std	Y+1, r24	; 0x01
	const char *p2 = s2.buffer;
    e92e:	8f 81       	ldd	r24, Y+7	; 0x07
    e930:	98 85       	ldd	r25, Y+8	; 0x08
    e932:	fc 01       	movw	r30, r24
    e934:	80 81       	ld	r24, Z
    e936:	91 81       	ldd	r25, Z+1	; 0x01
    e938:	9c 83       	std	Y+4, r25	; 0x04
    e93a:	8b 83       	std	Y+3, r24	; 0x03
	while (*p1) {
    e93c:	26 c0       	rjmp	.+76     	; 0xe98a <_ZNK6String16equalsIgnoreCaseERKS_+0xcc>
		if (tolower(*p1++) != tolower(*p2++)) return 0;
    e93e:	89 81       	ldd	r24, Y+1	; 0x01
    e940:	9a 81       	ldd	r25, Y+2	; 0x02
    e942:	fc 01       	movw	r30, r24
    e944:	80 81       	ld	r24, Z
    e946:	88 2f       	mov	r24, r24
    e948:	90 e0       	ldi	r25, 0x00	; 0
    e94a:	29 81       	ldd	r18, Y+1	; 0x01
    e94c:	3a 81       	ldd	r19, Y+2	; 0x02
    e94e:	2f 5f       	subi	r18, 0xFF	; 255
    e950:	3f 4f       	sbci	r19, 0xFF	; 255
    e952:	3a 83       	std	Y+2, r19	; 0x02
    e954:	29 83       	std	Y+1, r18	; 0x01
    e956:	0e 94 e1 b0 	call	0x161c2	; 0x161c2 <tolower>
    e95a:	8c 01       	movw	r16, r24
    e95c:	8b 81       	ldd	r24, Y+3	; 0x03
    e95e:	9c 81       	ldd	r25, Y+4	; 0x04
    e960:	fc 01       	movw	r30, r24
    e962:	80 81       	ld	r24, Z
    e964:	88 2f       	mov	r24, r24
    e966:	90 e0       	ldi	r25, 0x00	; 0
    e968:	2b 81       	ldd	r18, Y+3	; 0x03
    e96a:	3c 81       	ldd	r19, Y+4	; 0x04
    e96c:	2f 5f       	subi	r18, 0xFF	; 255
    e96e:	3f 4f       	sbci	r19, 0xFF	; 255
    e970:	3c 83       	std	Y+4, r19	; 0x04
    e972:	2b 83       	std	Y+3, r18	; 0x03
    e974:	0e 94 e1 b0 	call	0x161c2	; 0x161c2 <tolower>
    e978:	21 e0       	ldi	r18, 0x01	; 1
    e97a:	08 17       	cp	r16, r24
    e97c:	19 07       	cpc	r17, r25
    e97e:	09 f4       	brne	.+2      	; 0xe982 <_ZNK6String16equalsIgnoreCaseERKS_+0xc4>
    e980:	20 e0       	ldi	r18, 0x00	; 0
    e982:	22 23       	and	r18, r18
    e984:	11 f0       	breq	.+4      	; 0xe98a <_ZNK6String16equalsIgnoreCaseERKS_+0xcc>
    e986:	80 e0       	ldi	r24, 0x00	; 0
    e988:	0b c0       	rjmp	.+22     	; 0xe9a0 <_ZNK6String16equalsIgnoreCaseERKS_+0xe2>
	if (this == &s2) return 1;
	if (len != s2.len) return 0;
	if (len == 0) return 1;
	const char *p1 = buffer;
	const char *p2 = s2.buffer;
	while (*p1) {
    e98a:	89 81       	ldd	r24, Y+1	; 0x01
    e98c:	9a 81       	ldd	r25, Y+2	; 0x02
    e98e:	fc 01       	movw	r30, r24
    e990:	90 81       	ld	r25, Z
    e992:	81 e0       	ldi	r24, 0x01	; 1
    e994:	99 23       	and	r25, r25
    e996:	09 f4       	brne	.+2      	; 0xe99a <_ZNK6String16equalsIgnoreCaseERKS_+0xdc>
    e998:	80 e0       	ldi	r24, 0x00	; 0
    e99a:	88 23       	and	r24, r24
    e99c:	81 f6       	brne	.-96     	; 0xe93e <_ZNK6String16equalsIgnoreCaseERKS_+0x80>
		if (tolower(*p1++) != tolower(*p2++)) return 0;
	} 
	return 1;
    e99e:	81 e0       	ldi	r24, 0x01	; 1
}
    e9a0:	28 96       	adiw	r28, 0x08	; 8
    e9a2:	0f b6       	in	r0, 0x3f	; 63
    e9a4:	f8 94       	cli
    e9a6:	de bf       	out	0x3e, r29	; 62
    e9a8:	0f be       	out	0x3f, r0	; 63
    e9aa:	cd bf       	out	0x3d, r28	; 61
    e9ac:	df 91       	pop	r29
    e9ae:	cf 91       	pop	r28
    e9b0:	1f 91       	pop	r17
    e9b2:	0f 91       	pop	r16
    e9b4:	08 95       	ret

0000e9b6 <_ZNK6String10startsWithERKS_>:

unsigned char String::startsWith( const String &s2 ) const
{
    e9b6:	cf 93       	push	r28
    e9b8:	df 93       	push	r29
    e9ba:	00 d0       	rcall	.+0      	; 0xe9bc <_ZNK6String10startsWithERKS_+0x6>
    e9bc:	00 d0       	rcall	.+0      	; 0xe9be <_ZNK6String10startsWithERKS_+0x8>
    e9be:	cd b7       	in	r28, 0x3d	; 61
    e9c0:	de b7       	in	r29, 0x3e	; 62
    e9c2:	9a 83       	std	Y+2, r25	; 0x02
    e9c4:	89 83       	std	Y+1, r24	; 0x01
    e9c6:	7c 83       	std	Y+4, r23	; 0x04
    e9c8:	6b 83       	std	Y+3, r22	; 0x03
	if (len < s2.len) return 0;
    e9ca:	89 81       	ldd	r24, Y+1	; 0x01
    e9cc:	9a 81       	ldd	r25, Y+2	; 0x02
    e9ce:	fc 01       	movw	r30, r24
    e9d0:	24 81       	ldd	r18, Z+4	; 0x04
    e9d2:	35 81       	ldd	r19, Z+5	; 0x05
    e9d4:	8b 81       	ldd	r24, Y+3	; 0x03
    e9d6:	9c 81       	ldd	r25, Y+4	; 0x04
    e9d8:	fc 01       	movw	r30, r24
    e9da:	84 81       	ldd	r24, Z+4	; 0x04
    e9dc:	95 81       	ldd	r25, Z+5	; 0x05
    e9de:	28 17       	cp	r18, r24
    e9e0:	39 07       	cpc	r19, r25
    e9e2:	10 f4       	brcc	.+4      	; 0xe9e8 <_ZNK6String10startsWithERKS_+0x32>
    e9e4:	80 e0       	ldi	r24, 0x00	; 0
    e9e6:	09 c0       	rjmp	.+18     	; 0xe9fa <_ZNK6String10startsWithERKS_+0x44>
	return startsWith(s2, 0);
    e9e8:	2b 81       	ldd	r18, Y+3	; 0x03
    e9ea:	3c 81       	ldd	r19, Y+4	; 0x04
    e9ec:	89 81       	ldd	r24, Y+1	; 0x01
    e9ee:	9a 81       	ldd	r25, Y+2	; 0x02
    e9f0:	40 e0       	ldi	r20, 0x00	; 0
    e9f2:	50 e0       	ldi	r21, 0x00	; 0
    e9f4:	b9 01       	movw	r22, r18
    e9f6:	0e 94 04 75 	call	0xea08	; 0xea08 <_ZNK6String10startsWithERKS_j>
}
    e9fa:	0f 90       	pop	r0
    e9fc:	0f 90       	pop	r0
    e9fe:	0f 90       	pop	r0
    ea00:	0f 90       	pop	r0
    ea02:	df 91       	pop	r29
    ea04:	cf 91       	pop	r28
    ea06:	08 95       	ret

0000ea08 <_ZNK6String10startsWithERKS_j>:

unsigned char String::startsWith( const String &s2, unsigned int offset ) const
{
    ea08:	cf 93       	push	r28
    ea0a:	df 93       	push	r29
    ea0c:	00 d0       	rcall	.+0      	; 0xea0e <_ZNK6String10startsWithERKS_j+0x6>
    ea0e:	00 d0       	rcall	.+0      	; 0xea10 <_ZNK6String10startsWithERKS_j+0x8>
    ea10:	00 d0       	rcall	.+0      	; 0xea12 <_ZNK6String10startsWithERKS_j+0xa>
    ea12:	cd b7       	in	r28, 0x3d	; 61
    ea14:	de b7       	in	r29, 0x3e	; 62
    ea16:	9a 83       	std	Y+2, r25	; 0x02
    ea18:	89 83       	std	Y+1, r24	; 0x01
    ea1a:	7c 83       	std	Y+4, r23	; 0x04
    ea1c:	6b 83       	std	Y+3, r22	; 0x03
    ea1e:	5e 83       	std	Y+6, r21	; 0x06
    ea20:	4d 83       	std	Y+5, r20	; 0x05
	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
    ea22:	89 81       	ldd	r24, Y+1	; 0x01
    ea24:	9a 81       	ldd	r25, Y+2	; 0x02
    ea26:	fc 01       	movw	r30, r24
    ea28:	24 81       	ldd	r18, Z+4	; 0x04
    ea2a:	35 81       	ldd	r19, Z+5	; 0x05
    ea2c:	8b 81       	ldd	r24, Y+3	; 0x03
    ea2e:	9c 81       	ldd	r25, Y+4	; 0x04
    ea30:	fc 01       	movw	r30, r24
    ea32:	84 81       	ldd	r24, Z+4	; 0x04
    ea34:	95 81       	ldd	r25, Z+5	; 0x05
    ea36:	28 1b       	sub	r18, r24
    ea38:	39 0b       	sbc	r19, r25
    ea3a:	8d 81       	ldd	r24, Y+5	; 0x05
    ea3c:	9e 81       	ldd	r25, Y+6	; 0x06
    ea3e:	28 17       	cp	r18, r24
    ea40:	39 07       	cpc	r19, r25
    ea42:	70 f0       	brcs	.+28     	; 0xea60 <_ZNK6String10startsWithERKS_j+0x58>
    ea44:	89 81       	ldd	r24, Y+1	; 0x01
    ea46:	9a 81       	ldd	r25, Y+2	; 0x02
    ea48:	fc 01       	movw	r30, r24
    ea4a:	80 81       	ld	r24, Z
    ea4c:	91 81       	ldd	r25, Z+1	; 0x01
    ea4e:	00 97       	sbiw	r24, 0x00	; 0
    ea50:	39 f0       	breq	.+14     	; 0xea60 <_ZNK6String10startsWithERKS_j+0x58>
    ea52:	8b 81       	ldd	r24, Y+3	; 0x03
    ea54:	9c 81       	ldd	r25, Y+4	; 0x04
    ea56:	fc 01       	movw	r30, r24
    ea58:	80 81       	ld	r24, Z
    ea5a:	91 81       	ldd	r25, Z+1	; 0x01
    ea5c:	00 97       	sbiw	r24, 0x00	; 0
    ea5e:	11 f4       	brne	.+4      	; 0xea64 <_ZNK6String10startsWithERKS_j+0x5c>
    ea60:	80 e0       	ldi	r24, 0x00	; 0
    ea62:	1b c0       	rjmp	.+54     	; 0xea9a <_ZNK6String10startsWithERKS_j+0x92>
	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
    ea64:	8b 81       	ldd	r24, Y+3	; 0x03
    ea66:	9c 81       	ldd	r25, Y+4	; 0x04
    ea68:	fc 01       	movw	r30, r24
    ea6a:	44 81       	ldd	r20, Z+4	; 0x04
    ea6c:	55 81       	ldd	r21, Z+5	; 0x05
    ea6e:	8b 81       	ldd	r24, Y+3	; 0x03
    ea70:	9c 81       	ldd	r25, Y+4	; 0x04
    ea72:	fc 01       	movw	r30, r24
    ea74:	20 81       	ld	r18, Z
    ea76:	31 81       	ldd	r19, Z+1	; 0x01
    ea78:	89 81       	ldd	r24, Y+1	; 0x01
    ea7a:	9a 81       	ldd	r25, Y+2	; 0x02
    ea7c:	fc 01       	movw	r30, r24
    ea7e:	60 81       	ld	r22, Z
    ea80:	71 81       	ldd	r23, Z+1	; 0x01
    ea82:	8d 81       	ldd	r24, Y+5	; 0x05
    ea84:	9e 81       	ldd	r25, Y+6	; 0x06
    ea86:	86 0f       	add	r24, r22
    ea88:	97 1f       	adc	r25, r23
    ea8a:	b9 01       	movw	r22, r18
    ea8c:	0e 94 44 b1 	call	0x16288	; 0x16288 <strncmp>
    ea90:	21 e0       	ldi	r18, 0x01	; 1
    ea92:	00 97       	sbiw	r24, 0x00	; 0
    ea94:	09 f0       	breq	.+2      	; 0xea98 <_ZNK6String10startsWithERKS_j+0x90>
    ea96:	20 e0       	ldi	r18, 0x00	; 0
    ea98:	82 2f       	mov	r24, r18
}
    ea9a:	26 96       	adiw	r28, 0x06	; 6
    ea9c:	0f b6       	in	r0, 0x3f	; 63
    ea9e:	f8 94       	cli
    eaa0:	de bf       	out	0x3e, r29	; 62
    eaa2:	0f be       	out	0x3f, r0	; 63
    eaa4:	cd bf       	out	0x3d, r28	; 61
    eaa6:	df 91       	pop	r29
    eaa8:	cf 91       	pop	r28
    eaaa:	08 95       	ret

0000eaac <_ZNK6String8endsWithERKS_>:

unsigned char String::endsWith( const String &s2 ) const
{
    eaac:	cf 93       	push	r28
    eaae:	df 93       	push	r29
    eab0:	00 d0       	rcall	.+0      	; 0xeab2 <_ZNK6String8endsWithERKS_+0x6>
    eab2:	00 d0       	rcall	.+0      	; 0xeab4 <_ZNK6String8endsWithERKS_+0x8>
    eab4:	cd b7       	in	r28, 0x3d	; 61
    eab6:	de b7       	in	r29, 0x3e	; 62
    eab8:	9a 83       	std	Y+2, r25	; 0x02
    eaba:	89 83       	std	Y+1, r24	; 0x01
    eabc:	7c 83       	std	Y+4, r23	; 0x04
    eabe:	6b 83       	std	Y+3, r22	; 0x03
	if ( len < s2.len || !buffer || !s2.buffer) return 0;
    eac0:	89 81       	ldd	r24, Y+1	; 0x01
    eac2:	9a 81       	ldd	r25, Y+2	; 0x02
    eac4:	fc 01       	movw	r30, r24
    eac6:	24 81       	ldd	r18, Z+4	; 0x04
    eac8:	35 81       	ldd	r19, Z+5	; 0x05
    eaca:	8b 81       	ldd	r24, Y+3	; 0x03
    eacc:	9c 81       	ldd	r25, Y+4	; 0x04
    eace:	fc 01       	movw	r30, r24
    ead0:	84 81       	ldd	r24, Z+4	; 0x04
    ead2:	95 81       	ldd	r25, Z+5	; 0x05
    ead4:	28 17       	cp	r18, r24
    ead6:	39 07       	cpc	r19, r25
    ead8:	70 f0       	brcs	.+28     	; 0xeaf6 <_ZNK6String8endsWithERKS_+0x4a>
    eada:	89 81       	ldd	r24, Y+1	; 0x01
    eadc:	9a 81       	ldd	r25, Y+2	; 0x02
    eade:	fc 01       	movw	r30, r24
    eae0:	80 81       	ld	r24, Z
    eae2:	91 81       	ldd	r25, Z+1	; 0x01
    eae4:	00 97       	sbiw	r24, 0x00	; 0
    eae6:	39 f0       	breq	.+14     	; 0xeaf6 <_ZNK6String8endsWithERKS_+0x4a>
    eae8:	8b 81       	ldd	r24, Y+3	; 0x03
    eaea:	9c 81       	ldd	r25, Y+4	; 0x04
    eaec:	fc 01       	movw	r30, r24
    eaee:	80 81       	ld	r24, Z
    eaf0:	91 81       	ldd	r25, Z+1	; 0x01
    eaf2:	00 97       	sbiw	r24, 0x00	; 0
    eaf4:	11 f4       	brne	.+4      	; 0xeafa <_ZNK6String8endsWithERKS_+0x4e>
    eaf6:	80 e0       	ldi	r24, 0x00	; 0
    eaf8:	22 c0       	rjmp	.+68     	; 0xeb3e <_ZNK6String8endsWithERKS_+0x92>
	return strcmp(&buffer[len - s2.len], s2.buffer) == 0;
    eafa:	8b 81       	ldd	r24, Y+3	; 0x03
    eafc:	9c 81       	ldd	r25, Y+4	; 0x04
    eafe:	fc 01       	movw	r30, r24
    eb00:	20 81       	ld	r18, Z
    eb02:	31 81       	ldd	r19, Z+1	; 0x01
    eb04:	89 81       	ldd	r24, Y+1	; 0x01
    eb06:	9a 81       	ldd	r25, Y+2	; 0x02
    eb08:	fc 01       	movw	r30, r24
    eb0a:	40 81       	ld	r20, Z
    eb0c:	51 81       	ldd	r21, Z+1	; 0x01
    eb0e:	89 81       	ldd	r24, Y+1	; 0x01
    eb10:	9a 81       	ldd	r25, Y+2	; 0x02
    eb12:	fc 01       	movw	r30, r24
    eb14:	64 81       	ldd	r22, Z+4	; 0x04
    eb16:	75 81       	ldd	r23, Z+5	; 0x05
    eb18:	8b 81       	ldd	r24, Y+3	; 0x03
    eb1a:	9c 81       	ldd	r25, Y+4	; 0x04
    eb1c:	fc 01       	movw	r30, r24
    eb1e:	84 81       	ldd	r24, Z+4	; 0x04
    eb20:	95 81       	ldd	r25, Z+5	; 0x05
    eb22:	fb 01       	movw	r30, r22
    eb24:	e8 1b       	sub	r30, r24
    eb26:	f9 0b       	sbc	r31, r25
    eb28:	cf 01       	movw	r24, r30
    eb2a:	84 0f       	add	r24, r20
    eb2c:	95 1f       	adc	r25, r21
    eb2e:	b9 01       	movw	r22, r18
    eb30:	0e 94 2b b1 	call	0x16256	; 0x16256 <strcmp>
    eb34:	21 e0       	ldi	r18, 0x01	; 1
    eb36:	00 97       	sbiw	r24, 0x00	; 0
    eb38:	09 f0       	breq	.+2      	; 0xeb3c <_ZNK6String8endsWithERKS_+0x90>
    eb3a:	20 e0       	ldi	r18, 0x00	; 0
    eb3c:	82 2f       	mov	r24, r18
}
    eb3e:	0f 90       	pop	r0
    eb40:	0f 90       	pop	r0
    eb42:	0f 90       	pop	r0
    eb44:	0f 90       	pop	r0
    eb46:	df 91       	pop	r29
    eb48:	cf 91       	pop	r28
    eb4a:	08 95       	ret

0000eb4c <_ZNK6String6charAtEj>:
/*********************************************/
/*  Character Access                         */
/*********************************************/

char String::charAt(unsigned int loc) const
{
    eb4c:	cf 93       	push	r28
    eb4e:	df 93       	push	r29
    eb50:	00 d0       	rcall	.+0      	; 0xeb52 <_ZNK6String6charAtEj+0x6>
    eb52:	00 d0       	rcall	.+0      	; 0xeb54 <_ZNK6String6charAtEj+0x8>
    eb54:	cd b7       	in	r28, 0x3d	; 61
    eb56:	de b7       	in	r29, 0x3e	; 62
    eb58:	9a 83       	std	Y+2, r25	; 0x02
    eb5a:	89 83       	std	Y+1, r24	; 0x01
    eb5c:	7c 83       	std	Y+4, r23	; 0x04
    eb5e:	6b 83       	std	Y+3, r22	; 0x03
	return operator[](loc);
    eb60:	2b 81       	ldd	r18, Y+3	; 0x03
    eb62:	3c 81       	ldd	r19, Y+4	; 0x04
    eb64:	89 81       	ldd	r24, Y+1	; 0x01
    eb66:	9a 81       	ldd	r25, Y+2	; 0x02
    eb68:	b9 01       	movw	r22, r18
    eb6a:	0e 94 18 76 	call	0xec30	; 0xec30 <_ZNK6StringixEj>
}
    eb6e:	0f 90       	pop	r0
    eb70:	0f 90       	pop	r0
    eb72:	0f 90       	pop	r0
    eb74:	0f 90       	pop	r0
    eb76:	df 91       	pop	r29
    eb78:	cf 91       	pop	r28
    eb7a:	08 95       	ret

0000eb7c <_ZN6String9setCharAtEjc>:

void String::setCharAt(unsigned int loc, char c) 
{
    eb7c:	cf 93       	push	r28
    eb7e:	df 93       	push	r29
    eb80:	00 d0       	rcall	.+0      	; 0xeb82 <_ZN6String9setCharAtEjc+0x6>
    eb82:	00 d0       	rcall	.+0      	; 0xeb84 <_ZN6String9setCharAtEjc+0x8>
    eb84:	1f 92       	push	r1
    eb86:	cd b7       	in	r28, 0x3d	; 61
    eb88:	de b7       	in	r29, 0x3e	; 62
    eb8a:	9a 83       	std	Y+2, r25	; 0x02
    eb8c:	89 83       	std	Y+1, r24	; 0x01
    eb8e:	7c 83       	std	Y+4, r23	; 0x04
    eb90:	6b 83       	std	Y+3, r22	; 0x03
    eb92:	4d 83       	std	Y+5, r20	; 0x05
	if (loc < len) buffer[loc] = c;
    eb94:	89 81       	ldd	r24, Y+1	; 0x01
    eb96:	9a 81       	ldd	r25, Y+2	; 0x02
    eb98:	fc 01       	movw	r30, r24
    eb9a:	24 81       	ldd	r18, Z+4	; 0x04
    eb9c:	35 81       	ldd	r19, Z+5	; 0x05
    eb9e:	8b 81       	ldd	r24, Y+3	; 0x03
    eba0:	9c 81       	ldd	r25, Y+4	; 0x04
    eba2:	82 17       	cp	r24, r18
    eba4:	93 07       	cpc	r25, r19
    eba6:	60 f4       	brcc	.+24     	; 0xebc0 <_ZN6String9setCharAtEjc+0x44>
    eba8:	89 81       	ldd	r24, Y+1	; 0x01
    ebaa:	9a 81       	ldd	r25, Y+2	; 0x02
    ebac:	fc 01       	movw	r30, r24
    ebae:	20 81       	ld	r18, Z
    ebb0:	31 81       	ldd	r19, Z+1	; 0x01
    ebb2:	8b 81       	ldd	r24, Y+3	; 0x03
    ebb4:	9c 81       	ldd	r25, Y+4	; 0x04
    ebb6:	82 0f       	add	r24, r18
    ebb8:	93 1f       	adc	r25, r19
    ebba:	2d 81       	ldd	r18, Y+5	; 0x05
    ebbc:	fc 01       	movw	r30, r24
    ebbe:	20 83       	st	Z, r18
}
    ebc0:	0f 90       	pop	r0
    ebc2:	0f 90       	pop	r0
    ebc4:	0f 90       	pop	r0
    ebc6:	0f 90       	pop	r0
    ebc8:	0f 90       	pop	r0
    ebca:	df 91       	pop	r29
    ebcc:	cf 91       	pop	r28
    ebce:	08 95       	ret

0000ebd0 <_ZN6StringixEj>:

char & String::operator[](unsigned int index)
{
    ebd0:	cf 93       	push	r28
    ebd2:	df 93       	push	r29
    ebd4:	00 d0       	rcall	.+0      	; 0xebd6 <_ZN6StringixEj+0x6>
    ebd6:	00 d0       	rcall	.+0      	; 0xebd8 <_ZN6StringixEj+0x8>
    ebd8:	cd b7       	in	r28, 0x3d	; 61
    ebda:	de b7       	in	r29, 0x3e	; 62
    ebdc:	9a 83       	std	Y+2, r25	; 0x02
    ebde:	89 83       	std	Y+1, r24	; 0x01
    ebe0:	7c 83       	std	Y+4, r23	; 0x04
    ebe2:	6b 83       	std	Y+3, r22	; 0x03
	static char dummy_writable_char;
	if (index >= len || !buffer) {
    ebe4:	89 81       	ldd	r24, Y+1	; 0x01
    ebe6:	9a 81       	ldd	r25, Y+2	; 0x02
    ebe8:	fc 01       	movw	r30, r24
    ebea:	24 81       	ldd	r18, Z+4	; 0x04
    ebec:	35 81       	ldd	r19, Z+5	; 0x05
    ebee:	8b 81       	ldd	r24, Y+3	; 0x03
    ebf0:	9c 81       	ldd	r25, Y+4	; 0x04
    ebf2:	82 17       	cp	r24, r18
    ebf4:	93 07       	cpc	r25, r19
    ebf6:	38 f4       	brcc	.+14     	; 0xec06 <_ZN6StringixEj+0x36>
    ebf8:	89 81       	ldd	r24, Y+1	; 0x01
    ebfa:	9a 81       	ldd	r25, Y+2	; 0x02
    ebfc:	fc 01       	movw	r30, r24
    ebfe:	80 81       	ld	r24, Z
    ec00:	91 81       	ldd	r25, Z+1	; 0x01
    ec02:	00 97       	sbiw	r24, 0x00	; 0
    ec04:	29 f4       	brne	.+10     	; 0xec10 <_ZN6StringixEj+0x40>
		dummy_writable_char = 0;
    ec06:	10 92 08 09 	sts	0x0908, r1
		return dummy_writable_char;
    ec0a:	88 e0       	ldi	r24, 0x08	; 8
    ec0c:	99 e0       	ldi	r25, 0x09	; 9
    ec0e:	09 c0       	rjmp	.+18     	; 0xec22 <_ZN6StringixEj+0x52>
	}
	return buffer[index];
    ec10:	89 81       	ldd	r24, Y+1	; 0x01
    ec12:	9a 81       	ldd	r25, Y+2	; 0x02
    ec14:	fc 01       	movw	r30, r24
    ec16:	20 81       	ld	r18, Z
    ec18:	31 81       	ldd	r19, Z+1	; 0x01
    ec1a:	8b 81       	ldd	r24, Y+3	; 0x03
    ec1c:	9c 81       	ldd	r25, Y+4	; 0x04
    ec1e:	82 0f       	add	r24, r18
    ec20:	93 1f       	adc	r25, r19
}
    ec22:	0f 90       	pop	r0
    ec24:	0f 90       	pop	r0
    ec26:	0f 90       	pop	r0
    ec28:	0f 90       	pop	r0
    ec2a:	df 91       	pop	r29
    ec2c:	cf 91       	pop	r28
    ec2e:	08 95       	ret

0000ec30 <_ZNK6StringixEj>:

char String::operator[]( unsigned int index ) const
{
    ec30:	cf 93       	push	r28
    ec32:	df 93       	push	r29
    ec34:	00 d0       	rcall	.+0      	; 0xec36 <_ZNK6StringixEj+0x6>
    ec36:	00 d0       	rcall	.+0      	; 0xec38 <_ZNK6StringixEj+0x8>
    ec38:	cd b7       	in	r28, 0x3d	; 61
    ec3a:	de b7       	in	r29, 0x3e	; 62
    ec3c:	9a 83       	std	Y+2, r25	; 0x02
    ec3e:	89 83       	std	Y+1, r24	; 0x01
    ec40:	7c 83       	std	Y+4, r23	; 0x04
    ec42:	6b 83       	std	Y+3, r22	; 0x03
	if (index >= len || !buffer) return 0;
    ec44:	89 81       	ldd	r24, Y+1	; 0x01
    ec46:	9a 81       	ldd	r25, Y+2	; 0x02
    ec48:	fc 01       	movw	r30, r24
    ec4a:	24 81       	ldd	r18, Z+4	; 0x04
    ec4c:	35 81       	ldd	r19, Z+5	; 0x05
    ec4e:	8b 81       	ldd	r24, Y+3	; 0x03
    ec50:	9c 81       	ldd	r25, Y+4	; 0x04
    ec52:	82 17       	cp	r24, r18
    ec54:	93 07       	cpc	r25, r19
    ec56:	38 f4       	brcc	.+14     	; 0xec66 <_ZNK6StringixEj+0x36>
    ec58:	89 81       	ldd	r24, Y+1	; 0x01
    ec5a:	9a 81       	ldd	r25, Y+2	; 0x02
    ec5c:	fc 01       	movw	r30, r24
    ec5e:	80 81       	ld	r24, Z
    ec60:	91 81       	ldd	r25, Z+1	; 0x01
    ec62:	00 97       	sbiw	r24, 0x00	; 0
    ec64:	11 f4       	brne	.+4      	; 0xec6a <_ZNK6StringixEj+0x3a>
    ec66:	80 e0       	ldi	r24, 0x00	; 0
    ec68:	0b c0       	rjmp	.+22     	; 0xec80 <_ZNK6StringixEj+0x50>
	return buffer[index];
    ec6a:	89 81       	ldd	r24, Y+1	; 0x01
    ec6c:	9a 81       	ldd	r25, Y+2	; 0x02
    ec6e:	fc 01       	movw	r30, r24
    ec70:	20 81       	ld	r18, Z
    ec72:	31 81       	ldd	r19, Z+1	; 0x01
    ec74:	8b 81       	ldd	r24, Y+3	; 0x03
    ec76:	9c 81       	ldd	r25, Y+4	; 0x04
    ec78:	82 0f       	add	r24, r18
    ec7a:	93 1f       	adc	r25, r19
    ec7c:	fc 01       	movw	r30, r24
    ec7e:	80 81       	ld	r24, Z
}
    ec80:	0f 90       	pop	r0
    ec82:	0f 90       	pop	r0
    ec84:	0f 90       	pop	r0
    ec86:	0f 90       	pop	r0
    ec88:	df 91       	pop	r29
    ec8a:	cf 91       	pop	r28
    ec8c:	08 95       	ret

0000ec8e <_ZNK6String8getBytesEPhjj>:

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
    ec8e:	cf 93       	push	r28
    ec90:	df 93       	push	r29
    ec92:	cd b7       	in	r28, 0x3d	; 61
    ec94:	de b7       	in	r29, 0x3e	; 62
    ec96:	2a 97       	sbiw	r28, 0x0a	; 10
    ec98:	0f b6       	in	r0, 0x3f	; 63
    ec9a:	f8 94       	cli
    ec9c:	de bf       	out	0x3e, r29	; 62
    ec9e:	0f be       	out	0x3f, r0	; 63
    eca0:	cd bf       	out	0x3d, r28	; 61
    eca2:	9c 83       	std	Y+4, r25	; 0x04
    eca4:	8b 83       	std	Y+3, r24	; 0x03
    eca6:	7e 83       	std	Y+6, r23	; 0x06
    eca8:	6d 83       	std	Y+5, r22	; 0x05
    ecaa:	58 87       	std	Y+8, r21	; 0x08
    ecac:	4f 83       	std	Y+7, r20	; 0x07
    ecae:	3a 87       	std	Y+10, r19	; 0x0a
    ecb0:	29 87       	std	Y+9, r18	; 0x09
	if (!bufsize || !buf) return;
    ecb2:	8f 81       	ldd	r24, Y+7	; 0x07
    ecb4:	98 85       	ldd	r25, Y+8	; 0x08
    ecb6:	00 97       	sbiw	r24, 0x00	; 0
    ecb8:	09 f4       	brne	.+2      	; 0xecbc <_ZNK6String8getBytesEPhjj+0x2e>
    ecba:	4d c0       	rjmp	.+154    	; 0xed56 <_ZNK6String8getBytesEPhjj+0xc8>
    ecbc:	8d 81       	ldd	r24, Y+5	; 0x05
    ecbe:	9e 81       	ldd	r25, Y+6	; 0x06
    ecc0:	00 97       	sbiw	r24, 0x00	; 0
    ecc2:	09 f4       	brne	.+2      	; 0xecc6 <_ZNK6String8getBytesEPhjj+0x38>
    ecc4:	48 c0       	rjmp	.+144    	; 0xed56 <_ZNK6String8getBytesEPhjj+0xc8>
	if (index >= len) {
    ecc6:	8b 81       	ldd	r24, Y+3	; 0x03
    ecc8:	9c 81       	ldd	r25, Y+4	; 0x04
    ecca:	fc 01       	movw	r30, r24
    eccc:	24 81       	ldd	r18, Z+4	; 0x04
    ecce:	35 81       	ldd	r19, Z+5	; 0x05
    ecd0:	89 85       	ldd	r24, Y+9	; 0x09
    ecd2:	9a 85       	ldd	r25, Y+10	; 0x0a
    ecd4:	82 17       	cp	r24, r18
    ecd6:	93 07       	cpc	r25, r19
    ecd8:	28 f0       	brcs	.+10     	; 0xece4 <_ZNK6String8getBytesEPhjj+0x56>
		buf[0] = 0;
    ecda:	8d 81       	ldd	r24, Y+5	; 0x05
    ecdc:	9e 81       	ldd	r25, Y+6	; 0x06
    ecde:	fc 01       	movw	r30, r24
    ece0:	10 82       	st	Z, r1
		return;
    ece2:	3a c0       	rjmp	.+116    	; 0xed58 <_ZNK6String8getBytesEPhjj+0xca>
	}
	unsigned int n = bufsize - 1;
    ece4:	8f 81       	ldd	r24, Y+7	; 0x07
    ece6:	98 85       	ldd	r25, Y+8	; 0x08
    ece8:	01 97       	sbiw	r24, 0x01	; 1
    ecea:	9a 83       	std	Y+2, r25	; 0x02
    ecec:	89 83       	std	Y+1, r24	; 0x01
	if (n > len - index) n = len - index;
    ecee:	8b 81       	ldd	r24, Y+3	; 0x03
    ecf0:	9c 81       	ldd	r25, Y+4	; 0x04
    ecf2:	fc 01       	movw	r30, r24
    ecf4:	24 81       	ldd	r18, Z+4	; 0x04
    ecf6:	35 81       	ldd	r19, Z+5	; 0x05
    ecf8:	89 85       	ldd	r24, Y+9	; 0x09
    ecfa:	9a 85       	ldd	r25, Y+10	; 0x0a
    ecfc:	28 1b       	sub	r18, r24
    ecfe:	39 0b       	sbc	r19, r25
    ed00:	89 81       	ldd	r24, Y+1	; 0x01
    ed02:	9a 81       	ldd	r25, Y+2	; 0x02
    ed04:	28 17       	cp	r18, r24
    ed06:	39 07       	cpc	r19, r25
    ed08:	68 f4       	brcc	.+26     	; 0xed24 <_ZNK6String8getBytesEPhjj+0x96>
    ed0a:	8b 81       	ldd	r24, Y+3	; 0x03
    ed0c:	9c 81       	ldd	r25, Y+4	; 0x04
    ed0e:	fc 01       	movw	r30, r24
    ed10:	24 81       	ldd	r18, Z+4	; 0x04
    ed12:	35 81       	ldd	r19, Z+5	; 0x05
    ed14:	89 85       	ldd	r24, Y+9	; 0x09
    ed16:	9a 85       	ldd	r25, Y+10	; 0x0a
    ed18:	a9 01       	movw	r20, r18
    ed1a:	48 1b       	sub	r20, r24
    ed1c:	59 0b       	sbc	r21, r25
    ed1e:	ca 01       	movw	r24, r20
    ed20:	9a 83       	std	Y+2, r25	; 0x02
    ed22:	89 83       	std	Y+1, r24	; 0x01
	strncpy((char *)buf, buffer + index, n);
    ed24:	8b 81       	ldd	r24, Y+3	; 0x03
    ed26:	9c 81       	ldd	r25, Y+4	; 0x04
    ed28:	fc 01       	movw	r30, r24
    ed2a:	20 81       	ld	r18, Z
    ed2c:	31 81       	ldd	r19, Z+1	; 0x01
    ed2e:	89 85       	ldd	r24, Y+9	; 0x09
    ed30:	9a 85       	ldd	r25, Y+10	; 0x0a
    ed32:	28 0f       	add	r18, r24
    ed34:	39 1f       	adc	r19, r25
    ed36:	49 81       	ldd	r20, Y+1	; 0x01
    ed38:	5a 81       	ldd	r21, Y+2	; 0x02
    ed3a:	8d 81       	ldd	r24, Y+5	; 0x05
    ed3c:	9e 81       	ldd	r25, Y+6	; 0x06
    ed3e:	b9 01       	movw	r22, r18
    ed40:	0e 94 52 b1 	call	0x162a4	; 0x162a4 <strncpy>
	buf[n] = 0;
    ed44:	2d 81       	ldd	r18, Y+5	; 0x05
    ed46:	3e 81       	ldd	r19, Y+6	; 0x06
    ed48:	89 81       	ldd	r24, Y+1	; 0x01
    ed4a:	9a 81       	ldd	r25, Y+2	; 0x02
    ed4c:	82 0f       	add	r24, r18
    ed4e:	93 1f       	adc	r25, r19
    ed50:	fc 01       	movw	r30, r24
    ed52:	10 82       	st	Z, r1
    ed54:	01 c0       	rjmp	.+2      	; 0xed58 <_ZNK6String8getBytesEPhjj+0xca>
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
    ed56:	00 00       	nop
	}
	unsigned int n = bufsize - 1;
	if (n > len - index) n = len - index;
	strncpy((char *)buf, buffer + index, n);
	buf[n] = 0;
}
    ed58:	2a 96       	adiw	r28, 0x0a	; 10
    ed5a:	0f b6       	in	r0, 0x3f	; 63
    ed5c:	f8 94       	cli
    ed5e:	de bf       	out	0x3e, r29	; 62
    ed60:	0f be       	out	0x3f, r0	; 63
    ed62:	cd bf       	out	0x3d, r28	; 61
    ed64:	df 91       	pop	r29
    ed66:	cf 91       	pop	r28
    ed68:	08 95       	ret

0000ed6a <_ZNK6String7indexOfEc>:
/*********************************************/
/*  Search                                   */
/*********************************************/

int String::indexOf(char c) const
{
    ed6a:	cf 93       	push	r28
    ed6c:	df 93       	push	r29
    ed6e:	00 d0       	rcall	.+0      	; 0xed70 <_ZNK6String7indexOfEc+0x6>
    ed70:	1f 92       	push	r1
    ed72:	cd b7       	in	r28, 0x3d	; 61
    ed74:	de b7       	in	r29, 0x3e	; 62
    ed76:	9a 83       	std	Y+2, r25	; 0x02
    ed78:	89 83       	std	Y+1, r24	; 0x01
    ed7a:	6b 83       	std	Y+3, r22	; 0x03
	return indexOf(c, 0);
    ed7c:	89 81       	ldd	r24, Y+1	; 0x01
    ed7e:	9a 81       	ldd	r25, Y+2	; 0x02
    ed80:	40 e0       	ldi	r20, 0x00	; 0
    ed82:	50 e0       	ldi	r21, 0x00	; 0
    ed84:	6b 81       	ldd	r22, Y+3	; 0x03
    ed86:	0e 94 cb 76 	call	0xed96	; 0xed96 <_ZNK6String7indexOfEcj>
}
    ed8a:	0f 90       	pop	r0
    ed8c:	0f 90       	pop	r0
    ed8e:	0f 90       	pop	r0
    ed90:	df 91       	pop	r29
    ed92:	cf 91       	pop	r28
    ed94:	08 95       	ret

0000ed96 <_ZNK6String7indexOfEcj>:

int String::indexOf( char ch, unsigned int fromIndex ) const
{
    ed96:	cf 93       	push	r28
    ed98:	df 93       	push	r29
    ed9a:	cd b7       	in	r28, 0x3d	; 61
    ed9c:	de b7       	in	r29, 0x3e	; 62
    ed9e:	27 97       	sbiw	r28, 0x07	; 7
    eda0:	0f b6       	in	r0, 0x3f	; 63
    eda2:	f8 94       	cli
    eda4:	de bf       	out	0x3e, r29	; 62
    eda6:	0f be       	out	0x3f, r0	; 63
    eda8:	cd bf       	out	0x3d, r28	; 61
    edaa:	9c 83       	std	Y+4, r25	; 0x04
    edac:	8b 83       	std	Y+3, r24	; 0x03
    edae:	6d 83       	std	Y+5, r22	; 0x05
    edb0:	5f 83       	std	Y+7, r21	; 0x07
    edb2:	4e 83       	std	Y+6, r20	; 0x06
	if (fromIndex >= len) return -1;
    edb4:	8b 81       	ldd	r24, Y+3	; 0x03
    edb6:	9c 81       	ldd	r25, Y+4	; 0x04
    edb8:	fc 01       	movw	r30, r24
    edba:	24 81       	ldd	r18, Z+4	; 0x04
    edbc:	35 81       	ldd	r19, Z+5	; 0x05
    edbe:	8e 81       	ldd	r24, Y+6	; 0x06
    edc0:	9f 81       	ldd	r25, Y+7	; 0x07
    edc2:	82 17       	cp	r24, r18
    edc4:	93 07       	cpc	r25, r19
    edc6:	18 f0       	brcs	.+6      	; 0xedce <_ZNK6String7indexOfEcj+0x38>
    edc8:	8f ef       	ldi	r24, 0xFF	; 255
    edca:	9f ef       	ldi	r25, 0xFF	; 255
    edcc:	23 c0       	rjmp	.+70     	; 0xee14 <_ZNK6String7indexOfEcj+0x7e>
	const char* temp = strchr(buffer + fromIndex, ch);
    edce:	8d 81       	ldd	r24, Y+5	; 0x05
    edd0:	28 2f       	mov	r18, r24
    edd2:	30 e0       	ldi	r19, 0x00	; 0
    edd4:	8b 81       	ldd	r24, Y+3	; 0x03
    edd6:	9c 81       	ldd	r25, Y+4	; 0x04
    edd8:	fc 01       	movw	r30, r24
    edda:	40 81       	ld	r20, Z
    eddc:	51 81       	ldd	r21, Z+1	; 0x01
    edde:	8e 81       	ldd	r24, Y+6	; 0x06
    ede0:	9f 81       	ldd	r25, Y+7	; 0x07
    ede2:	84 0f       	add	r24, r20
    ede4:	95 1f       	adc	r25, r21
    ede6:	b9 01       	movw	r22, r18
    ede8:	0e 94 20 b1 	call	0x16240	; 0x16240 <strchr>
    edec:	9a 83       	std	Y+2, r25	; 0x02
    edee:	89 83       	std	Y+1, r24	; 0x01
	if (temp == NULL) return -1;
    edf0:	89 81       	ldd	r24, Y+1	; 0x01
    edf2:	9a 81       	ldd	r25, Y+2	; 0x02
    edf4:	00 97       	sbiw	r24, 0x00	; 0
    edf6:	19 f4       	brne	.+6      	; 0xedfe <_ZNK6String7indexOfEcj+0x68>
    edf8:	8f ef       	ldi	r24, 0xFF	; 255
    edfa:	9f ef       	ldi	r25, 0xFF	; 255
    edfc:	0b c0       	rjmp	.+22     	; 0xee14 <_ZNK6String7indexOfEcj+0x7e>
	return temp - buffer;
    edfe:	29 81       	ldd	r18, Y+1	; 0x01
    ee00:	3a 81       	ldd	r19, Y+2	; 0x02
    ee02:	8b 81       	ldd	r24, Y+3	; 0x03
    ee04:	9c 81       	ldd	r25, Y+4	; 0x04
    ee06:	fc 01       	movw	r30, r24
    ee08:	80 81       	ld	r24, Z
    ee0a:	91 81       	ldd	r25, Z+1	; 0x01
    ee0c:	a9 01       	movw	r20, r18
    ee0e:	48 1b       	sub	r20, r24
    ee10:	59 0b       	sbc	r21, r25
    ee12:	ca 01       	movw	r24, r20
}
    ee14:	27 96       	adiw	r28, 0x07	; 7
    ee16:	0f b6       	in	r0, 0x3f	; 63
    ee18:	f8 94       	cli
    ee1a:	de bf       	out	0x3e, r29	; 62
    ee1c:	0f be       	out	0x3f, r0	; 63
    ee1e:	cd bf       	out	0x3d, r28	; 61
    ee20:	df 91       	pop	r29
    ee22:	cf 91       	pop	r28
    ee24:	08 95       	ret

0000ee26 <_ZNK6String7indexOfERKS_>:

int String::indexOf(const String &s2) const
{
    ee26:	cf 93       	push	r28
    ee28:	df 93       	push	r29
    ee2a:	00 d0       	rcall	.+0      	; 0xee2c <_ZNK6String7indexOfERKS_+0x6>
    ee2c:	00 d0       	rcall	.+0      	; 0xee2e <_ZNK6String7indexOfERKS_+0x8>
    ee2e:	cd b7       	in	r28, 0x3d	; 61
    ee30:	de b7       	in	r29, 0x3e	; 62
    ee32:	9a 83       	std	Y+2, r25	; 0x02
    ee34:	89 83       	std	Y+1, r24	; 0x01
    ee36:	7c 83       	std	Y+4, r23	; 0x04
    ee38:	6b 83       	std	Y+3, r22	; 0x03
	return indexOf(s2, 0);
    ee3a:	2b 81       	ldd	r18, Y+3	; 0x03
    ee3c:	3c 81       	ldd	r19, Y+4	; 0x04
    ee3e:	89 81       	ldd	r24, Y+1	; 0x01
    ee40:	9a 81       	ldd	r25, Y+2	; 0x02
    ee42:	40 e0       	ldi	r20, 0x00	; 0
    ee44:	50 e0       	ldi	r21, 0x00	; 0
    ee46:	b9 01       	movw	r22, r18
    ee48:	0e 94 2d 77 	call	0xee5a	; 0xee5a <_ZNK6String7indexOfERKS_j>
}
    ee4c:	0f 90       	pop	r0
    ee4e:	0f 90       	pop	r0
    ee50:	0f 90       	pop	r0
    ee52:	0f 90       	pop	r0
    ee54:	df 91       	pop	r29
    ee56:	cf 91       	pop	r28
    ee58:	08 95       	ret

0000ee5a <_ZNK6String7indexOfERKS_j>:

int String::indexOf(const String &s2, unsigned int fromIndex) const
{
    ee5a:	cf 93       	push	r28
    ee5c:	df 93       	push	r29
    ee5e:	cd b7       	in	r28, 0x3d	; 61
    ee60:	de b7       	in	r29, 0x3e	; 62
    ee62:	28 97       	sbiw	r28, 0x08	; 8
    ee64:	0f b6       	in	r0, 0x3f	; 63
    ee66:	f8 94       	cli
    ee68:	de bf       	out	0x3e, r29	; 62
    ee6a:	0f be       	out	0x3f, r0	; 63
    ee6c:	cd bf       	out	0x3d, r28	; 61
    ee6e:	9c 83       	std	Y+4, r25	; 0x04
    ee70:	8b 83       	std	Y+3, r24	; 0x03
    ee72:	7e 83       	std	Y+6, r23	; 0x06
    ee74:	6d 83       	std	Y+5, r22	; 0x05
    ee76:	58 87       	std	Y+8, r21	; 0x08
    ee78:	4f 83       	std	Y+7, r20	; 0x07
	if (fromIndex >= len) return -1;
    ee7a:	8b 81       	ldd	r24, Y+3	; 0x03
    ee7c:	9c 81       	ldd	r25, Y+4	; 0x04
    ee7e:	fc 01       	movw	r30, r24
    ee80:	24 81       	ldd	r18, Z+4	; 0x04
    ee82:	35 81       	ldd	r19, Z+5	; 0x05
    ee84:	8f 81       	ldd	r24, Y+7	; 0x07
    ee86:	98 85       	ldd	r25, Y+8	; 0x08
    ee88:	82 17       	cp	r24, r18
    ee8a:	93 07       	cpc	r25, r19
    ee8c:	18 f0       	brcs	.+6      	; 0xee94 <_ZNK6String7indexOfERKS_j+0x3a>
    ee8e:	8f ef       	ldi	r24, 0xFF	; 255
    ee90:	9f ef       	ldi	r25, 0xFF	; 255
    ee92:	25 c0       	rjmp	.+74     	; 0xeede <_ZNK6String7indexOfERKS_j+0x84>
	const char *found = strstr(buffer + fromIndex, s2.buffer);
    ee94:	8d 81       	ldd	r24, Y+5	; 0x05
    ee96:	9e 81       	ldd	r25, Y+6	; 0x06
    ee98:	fc 01       	movw	r30, r24
    ee9a:	20 81       	ld	r18, Z
    ee9c:	31 81       	ldd	r19, Z+1	; 0x01
    ee9e:	8b 81       	ldd	r24, Y+3	; 0x03
    eea0:	9c 81       	ldd	r25, Y+4	; 0x04
    eea2:	fc 01       	movw	r30, r24
    eea4:	40 81       	ld	r20, Z
    eea6:	51 81       	ldd	r21, Z+1	; 0x01
    eea8:	8f 81       	ldd	r24, Y+7	; 0x07
    eeaa:	98 85       	ldd	r25, Y+8	; 0x08
    eeac:	84 0f       	add	r24, r20
    eeae:	95 1f       	adc	r25, r21
    eeb0:	b9 01       	movw	r22, r18
    eeb2:	0e 94 6c b1 	call	0x162d8	; 0x162d8 <strstr>
    eeb6:	9a 83       	std	Y+2, r25	; 0x02
    eeb8:	89 83       	std	Y+1, r24	; 0x01
	if (found == NULL) return -1;
    eeba:	89 81       	ldd	r24, Y+1	; 0x01
    eebc:	9a 81       	ldd	r25, Y+2	; 0x02
    eebe:	00 97       	sbiw	r24, 0x00	; 0
    eec0:	19 f4       	brne	.+6      	; 0xeec8 <_ZNK6String7indexOfERKS_j+0x6e>
    eec2:	8f ef       	ldi	r24, 0xFF	; 255
    eec4:	9f ef       	ldi	r25, 0xFF	; 255
    eec6:	0b c0       	rjmp	.+22     	; 0xeede <_ZNK6String7indexOfERKS_j+0x84>
	return found - buffer;
    eec8:	29 81       	ldd	r18, Y+1	; 0x01
    eeca:	3a 81       	ldd	r19, Y+2	; 0x02
    eecc:	8b 81       	ldd	r24, Y+3	; 0x03
    eece:	9c 81       	ldd	r25, Y+4	; 0x04
    eed0:	fc 01       	movw	r30, r24
    eed2:	80 81       	ld	r24, Z
    eed4:	91 81       	ldd	r25, Z+1	; 0x01
    eed6:	a9 01       	movw	r20, r18
    eed8:	48 1b       	sub	r20, r24
    eeda:	59 0b       	sbc	r21, r25
    eedc:	ca 01       	movw	r24, r20
}
    eede:	28 96       	adiw	r28, 0x08	; 8
    eee0:	0f b6       	in	r0, 0x3f	; 63
    eee2:	f8 94       	cli
    eee4:	de bf       	out	0x3e, r29	; 62
    eee6:	0f be       	out	0x3f, r0	; 63
    eee8:	cd bf       	out	0x3d, r28	; 61
    eeea:	df 91       	pop	r29
    eeec:	cf 91       	pop	r28
    eeee:	08 95       	ret

0000eef0 <_ZNK6String11lastIndexOfEc>:

int String::lastIndexOf( char theChar ) const
{
    eef0:	cf 93       	push	r28
    eef2:	df 93       	push	r29
    eef4:	00 d0       	rcall	.+0      	; 0xeef6 <_ZNK6String11lastIndexOfEc+0x6>
    eef6:	1f 92       	push	r1
    eef8:	cd b7       	in	r28, 0x3d	; 61
    eefa:	de b7       	in	r29, 0x3e	; 62
    eefc:	9a 83       	std	Y+2, r25	; 0x02
    eefe:	89 83       	std	Y+1, r24	; 0x01
    ef00:	6b 83       	std	Y+3, r22	; 0x03
	return lastIndexOf(theChar, len - 1);
    ef02:	89 81       	ldd	r24, Y+1	; 0x01
    ef04:	9a 81       	ldd	r25, Y+2	; 0x02
    ef06:	fc 01       	movw	r30, r24
    ef08:	84 81       	ldd	r24, Z+4	; 0x04
    ef0a:	95 81       	ldd	r25, Z+5	; 0x05
    ef0c:	9c 01       	movw	r18, r24
    ef0e:	21 50       	subi	r18, 0x01	; 1
    ef10:	31 09       	sbc	r19, r1
    ef12:	89 81       	ldd	r24, Y+1	; 0x01
    ef14:	9a 81       	ldd	r25, Y+2	; 0x02
    ef16:	a9 01       	movw	r20, r18
    ef18:	6b 81       	ldd	r22, Y+3	; 0x03
    ef1a:	0e 94 95 77 	call	0xef2a	; 0xef2a <_ZNK6String11lastIndexOfEcj>
}
    ef1e:	0f 90       	pop	r0
    ef20:	0f 90       	pop	r0
    ef22:	0f 90       	pop	r0
    ef24:	df 91       	pop	r29
    ef26:	cf 91       	pop	r28
    ef28:	08 95       	ret

0000ef2a <_ZNK6String11lastIndexOfEcj>:

int String::lastIndexOf(char ch, unsigned int fromIndex) const
{
    ef2a:	cf 93       	push	r28
    ef2c:	df 93       	push	r29
    ef2e:	cd b7       	in	r28, 0x3d	; 61
    ef30:	de b7       	in	r29, 0x3e	; 62
    ef32:	28 97       	sbiw	r28, 0x08	; 8
    ef34:	0f b6       	in	r0, 0x3f	; 63
    ef36:	f8 94       	cli
    ef38:	de bf       	out	0x3e, r29	; 62
    ef3a:	0f be       	out	0x3f, r0	; 63
    ef3c:	cd bf       	out	0x3d, r28	; 61
    ef3e:	9d 83       	std	Y+5, r25	; 0x05
    ef40:	8c 83       	std	Y+4, r24	; 0x04
    ef42:	6e 83       	std	Y+6, r22	; 0x06
    ef44:	58 87       	std	Y+8, r21	; 0x08
    ef46:	4f 83       	std	Y+7, r20	; 0x07
	if (fromIndex >= len) return -1;
    ef48:	8c 81       	ldd	r24, Y+4	; 0x04
    ef4a:	9d 81       	ldd	r25, Y+5	; 0x05
    ef4c:	fc 01       	movw	r30, r24
    ef4e:	24 81       	ldd	r18, Z+4	; 0x04
    ef50:	35 81       	ldd	r19, Z+5	; 0x05
    ef52:	8f 81       	ldd	r24, Y+7	; 0x07
    ef54:	98 85       	ldd	r25, Y+8	; 0x08
    ef56:	82 17       	cp	r24, r18
    ef58:	93 07       	cpc	r25, r19
    ef5a:	18 f0       	brcs	.+6      	; 0xef62 <_ZNK6String11lastIndexOfEcj+0x38>
    ef5c:	8f ef       	ldi	r24, 0xFF	; 255
    ef5e:	9f ef       	ldi	r25, 0xFF	; 255
    ef60:	45 c0       	rjmp	.+138    	; 0xefec <_ZNK6String11lastIndexOfEcj+0xc2>
	char tempchar = buffer[fromIndex + 1];
    ef62:	8c 81       	ldd	r24, Y+4	; 0x04
    ef64:	9d 81       	ldd	r25, Y+5	; 0x05
    ef66:	fc 01       	movw	r30, r24
    ef68:	20 81       	ld	r18, Z
    ef6a:	31 81       	ldd	r19, Z+1	; 0x01
    ef6c:	8f 81       	ldd	r24, Y+7	; 0x07
    ef6e:	98 85       	ldd	r25, Y+8	; 0x08
    ef70:	01 96       	adiw	r24, 0x01	; 1
    ef72:	82 0f       	add	r24, r18
    ef74:	93 1f       	adc	r25, r19
    ef76:	fc 01       	movw	r30, r24
    ef78:	80 81       	ld	r24, Z
    ef7a:	89 83       	std	Y+1, r24	; 0x01
	buffer[fromIndex + 1] = '\0';
    ef7c:	8c 81       	ldd	r24, Y+4	; 0x04
    ef7e:	9d 81       	ldd	r25, Y+5	; 0x05
    ef80:	fc 01       	movw	r30, r24
    ef82:	20 81       	ld	r18, Z
    ef84:	31 81       	ldd	r19, Z+1	; 0x01
    ef86:	8f 81       	ldd	r24, Y+7	; 0x07
    ef88:	98 85       	ldd	r25, Y+8	; 0x08
    ef8a:	01 96       	adiw	r24, 0x01	; 1
    ef8c:	82 0f       	add	r24, r18
    ef8e:	93 1f       	adc	r25, r19
    ef90:	fc 01       	movw	r30, r24
    ef92:	10 82       	st	Z, r1
	char* temp = strrchr( buffer, ch );
    ef94:	8e 81       	ldd	r24, Y+6	; 0x06
    ef96:	28 2f       	mov	r18, r24
    ef98:	30 e0       	ldi	r19, 0x00	; 0
    ef9a:	8c 81       	ldd	r24, Y+4	; 0x04
    ef9c:	9d 81       	ldd	r25, Y+5	; 0x05
    ef9e:	fc 01       	movw	r30, r24
    efa0:	80 81       	ld	r24, Z
    efa2:	91 81       	ldd	r25, Z+1	; 0x01
    efa4:	b9 01       	movw	r22, r18
    efa6:	0e 94 61 b1 	call	0x162c2	; 0x162c2 <strrchr>
    efaa:	9b 83       	std	Y+3, r25	; 0x03
    efac:	8a 83       	std	Y+2, r24	; 0x02
	buffer[fromIndex + 1] = tempchar;
    efae:	8c 81       	ldd	r24, Y+4	; 0x04
    efb0:	9d 81       	ldd	r25, Y+5	; 0x05
    efb2:	fc 01       	movw	r30, r24
    efb4:	20 81       	ld	r18, Z
    efb6:	31 81       	ldd	r19, Z+1	; 0x01
    efb8:	8f 81       	ldd	r24, Y+7	; 0x07
    efba:	98 85       	ldd	r25, Y+8	; 0x08
    efbc:	01 96       	adiw	r24, 0x01	; 1
    efbe:	82 0f       	add	r24, r18
    efc0:	93 1f       	adc	r25, r19
    efc2:	29 81       	ldd	r18, Y+1	; 0x01
    efc4:	fc 01       	movw	r30, r24
    efc6:	20 83       	st	Z, r18
	if (temp == NULL) return -1;
    efc8:	8a 81       	ldd	r24, Y+2	; 0x02
    efca:	9b 81       	ldd	r25, Y+3	; 0x03
    efcc:	00 97       	sbiw	r24, 0x00	; 0
    efce:	19 f4       	brne	.+6      	; 0xefd6 <_ZNK6String11lastIndexOfEcj+0xac>
    efd0:	8f ef       	ldi	r24, 0xFF	; 255
    efd2:	9f ef       	ldi	r25, 0xFF	; 255
    efd4:	0b c0       	rjmp	.+22     	; 0xefec <_ZNK6String11lastIndexOfEcj+0xc2>
	return temp - buffer;
    efd6:	2a 81       	ldd	r18, Y+2	; 0x02
    efd8:	3b 81       	ldd	r19, Y+3	; 0x03
    efda:	8c 81       	ldd	r24, Y+4	; 0x04
    efdc:	9d 81       	ldd	r25, Y+5	; 0x05
    efde:	fc 01       	movw	r30, r24
    efe0:	80 81       	ld	r24, Z
    efe2:	91 81       	ldd	r25, Z+1	; 0x01
    efe4:	a9 01       	movw	r20, r18
    efe6:	48 1b       	sub	r20, r24
    efe8:	59 0b       	sbc	r21, r25
    efea:	ca 01       	movw	r24, r20
}
    efec:	28 96       	adiw	r28, 0x08	; 8
    efee:	0f b6       	in	r0, 0x3f	; 63
    eff0:	f8 94       	cli
    eff2:	de bf       	out	0x3e, r29	; 62
    eff4:	0f be       	out	0x3f, r0	; 63
    eff6:	cd bf       	out	0x3d, r28	; 61
    eff8:	df 91       	pop	r29
    effa:	cf 91       	pop	r28
    effc:	08 95       	ret

0000effe <_ZNK6String11lastIndexOfERKS_>:

int String::lastIndexOf(const String &s2) const
{
    effe:	cf 93       	push	r28
    f000:	df 93       	push	r29
    f002:	00 d0       	rcall	.+0      	; 0xf004 <_ZNK6String11lastIndexOfERKS_+0x6>
    f004:	00 d0       	rcall	.+0      	; 0xf006 <_ZNK6String11lastIndexOfERKS_+0x8>
    f006:	cd b7       	in	r28, 0x3d	; 61
    f008:	de b7       	in	r29, 0x3e	; 62
    f00a:	9a 83       	std	Y+2, r25	; 0x02
    f00c:	89 83       	std	Y+1, r24	; 0x01
    f00e:	7c 83       	std	Y+4, r23	; 0x04
    f010:	6b 83       	std	Y+3, r22	; 0x03
	return lastIndexOf(s2, len - s2.len);
    f012:	89 81       	ldd	r24, Y+1	; 0x01
    f014:	9a 81       	ldd	r25, Y+2	; 0x02
    f016:	fc 01       	movw	r30, r24
    f018:	24 81       	ldd	r18, Z+4	; 0x04
    f01a:	35 81       	ldd	r19, Z+5	; 0x05
    f01c:	8b 81       	ldd	r24, Y+3	; 0x03
    f01e:	9c 81       	ldd	r25, Y+4	; 0x04
    f020:	fc 01       	movw	r30, r24
    f022:	84 81       	ldd	r24, Z+4	; 0x04
    f024:	95 81       	ldd	r25, Z+5	; 0x05
    f026:	a9 01       	movw	r20, r18
    f028:	48 1b       	sub	r20, r24
    f02a:	59 0b       	sbc	r21, r25
    f02c:	2b 81       	ldd	r18, Y+3	; 0x03
    f02e:	3c 81       	ldd	r19, Y+4	; 0x04
    f030:	89 81       	ldd	r24, Y+1	; 0x01
    f032:	9a 81       	ldd	r25, Y+2	; 0x02
    f034:	b9 01       	movw	r22, r18
    f036:	0e 94 24 78 	call	0xf048	; 0xf048 <_ZNK6String11lastIndexOfERKS_j>
}
    f03a:	0f 90       	pop	r0
    f03c:	0f 90       	pop	r0
    f03e:	0f 90       	pop	r0
    f040:	0f 90       	pop	r0
    f042:	df 91       	pop	r29
    f044:	cf 91       	pop	r28
    f046:	08 95       	ret

0000f048 <_ZNK6String11lastIndexOfERKS_j>:

int String::lastIndexOf(const String &s2, unsigned int fromIndex) const
{
    f048:	cf 93       	push	r28
    f04a:	df 93       	push	r29
    f04c:	cd b7       	in	r28, 0x3d	; 61
    f04e:	de b7       	in	r29, 0x3e	; 62
    f050:	2a 97       	sbiw	r28, 0x0a	; 10
    f052:	0f b6       	in	r0, 0x3f	; 63
    f054:	f8 94       	cli
    f056:	de bf       	out	0x3e, r29	; 62
    f058:	0f be       	out	0x3f, r0	; 63
    f05a:	cd bf       	out	0x3d, r28	; 61
    f05c:	9e 83       	std	Y+6, r25	; 0x06
    f05e:	8d 83       	std	Y+5, r24	; 0x05
    f060:	78 87       	std	Y+8, r23	; 0x08
    f062:	6f 83       	std	Y+7, r22	; 0x07
    f064:	5a 87       	std	Y+10, r21	; 0x0a
    f066:	49 87       	std	Y+9, r20	; 0x09
  	if (s2.len == 0 || len == 0 || s2.len > len) return -1;
    f068:	8f 81       	ldd	r24, Y+7	; 0x07
    f06a:	98 85       	ldd	r25, Y+8	; 0x08
    f06c:	fc 01       	movw	r30, r24
    f06e:	84 81       	ldd	r24, Z+4	; 0x04
    f070:	95 81       	ldd	r25, Z+5	; 0x05
    f072:	00 97       	sbiw	r24, 0x00	; 0
    f074:	a1 f0       	breq	.+40     	; 0xf09e <_ZNK6String11lastIndexOfERKS_j+0x56>
    f076:	8d 81       	ldd	r24, Y+5	; 0x05
    f078:	9e 81       	ldd	r25, Y+6	; 0x06
    f07a:	fc 01       	movw	r30, r24
    f07c:	84 81       	ldd	r24, Z+4	; 0x04
    f07e:	95 81       	ldd	r25, Z+5	; 0x05
    f080:	00 97       	sbiw	r24, 0x00	; 0
    f082:	69 f0       	breq	.+26     	; 0xf09e <_ZNK6String11lastIndexOfERKS_j+0x56>
    f084:	8f 81       	ldd	r24, Y+7	; 0x07
    f086:	98 85       	ldd	r25, Y+8	; 0x08
    f088:	fc 01       	movw	r30, r24
    f08a:	24 81       	ldd	r18, Z+4	; 0x04
    f08c:	35 81       	ldd	r19, Z+5	; 0x05
    f08e:	8d 81       	ldd	r24, Y+5	; 0x05
    f090:	9e 81       	ldd	r25, Y+6	; 0x06
    f092:	fc 01       	movw	r30, r24
    f094:	84 81       	ldd	r24, Z+4	; 0x04
    f096:	95 81       	ldd	r25, Z+5	; 0x05
    f098:	82 17       	cp	r24, r18
    f09a:	93 07       	cpc	r25, r19
    f09c:	18 f4       	brcc	.+6      	; 0xf0a4 <_ZNK6String11lastIndexOfERKS_j+0x5c>
    f09e:	8f ef       	ldi	r24, 0xFF	; 255
    f0a0:	9f ef       	ldi	r25, 0xFF	; 255
    f0a2:	68 c0       	rjmp	.+208    	; 0xf174 <_ZNK6String11lastIndexOfERKS_j+0x12c>
	if (fromIndex >= len) fromIndex = len - 1;
    f0a4:	8d 81       	ldd	r24, Y+5	; 0x05
    f0a6:	9e 81       	ldd	r25, Y+6	; 0x06
    f0a8:	fc 01       	movw	r30, r24
    f0aa:	24 81       	ldd	r18, Z+4	; 0x04
    f0ac:	35 81       	ldd	r19, Z+5	; 0x05
    f0ae:	89 85       	ldd	r24, Y+9	; 0x09
    f0b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    f0b2:	82 17       	cp	r24, r18
    f0b4:	93 07       	cpc	r25, r19
    f0b6:	40 f0       	brcs	.+16     	; 0xf0c8 <_ZNK6String11lastIndexOfERKS_j+0x80>
    f0b8:	8d 81       	ldd	r24, Y+5	; 0x05
    f0ba:	9e 81       	ldd	r25, Y+6	; 0x06
    f0bc:	fc 01       	movw	r30, r24
    f0be:	84 81       	ldd	r24, Z+4	; 0x04
    f0c0:	95 81       	ldd	r25, Z+5	; 0x05
    f0c2:	01 97       	sbiw	r24, 0x01	; 1
    f0c4:	9a 87       	std	Y+10, r25	; 0x0a
    f0c6:	89 87       	std	Y+9, r24	; 0x09
	int found = -1;
    f0c8:	8f ef       	ldi	r24, 0xFF	; 255
    f0ca:	9f ef       	ldi	r25, 0xFF	; 255
    f0cc:	9a 83       	std	Y+2, r25	; 0x02
    f0ce:	89 83       	std	Y+1, r24	; 0x01
	for (char *p = buffer; p <= buffer + fromIndex; p++) {
    f0d0:	8d 81       	ldd	r24, Y+5	; 0x05
    f0d2:	9e 81       	ldd	r25, Y+6	; 0x06
    f0d4:	fc 01       	movw	r30, r24
    f0d6:	80 81       	ld	r24, Z
    f0d8:	91 81       	ldd	r25, Z+1	; 0x01
    f0da:	9c 83       	std	Y+4, r25	; 0x04
    f0dc:	8b 83       	std	Y+3, r24	; 0x03
    f0de:	33 c0       	rjmp	.+102    	; 0xf146 <_ZNK6String11lastIndexOfERKS_j+0xfe>
		p = strstr(p, s2.buffer);
    f0e0:	8f 81       	ldd	r24, Y+7	; 0x07
    f0e2:	98 85       	ldd	r25, Y+8	; 0x08
    f0e4:	fc 01       	movw	r30, r24
    f0e6:	20 81       	ld	r18, Z
    f0e8:	31 81       	ldd	r19, Z+1	; 0x01
    f0ea:	8b 81       	ldd	r24, Y+3	; 0x03
    f0ec:	9c 81       	ldd	r25, Y+4	; 0x04
    f0ee:	b9 01       	movw	r22, r18
    f0f0:	0e 94 6c b1 	call	0x162d8	; 0x162d8 <strstr>
    f0f4:	9c 83       	std	Y+4, r25	; 0x04
    f0f6:	8b 83       	std	Y+3, r24	; 0x03
		if (!p) break;
    f0f8:	8b 81       	ldd	r24, Y+3	; 0x03
    f0fa:	9c 81       	ldd	r25, Y+4	; 0x04
    f0fc:	00 97       	sbiw	r24, 0x00	; 0
    f0fe:	b9 f1       	breq	.+110    	; 0xf16e <_ZNK6String11lastIndexOfERKS_j+0x126>
		if ((unsigned int)(p - buffer) <= fromIndex) found = p - buffer;
    f100:	2b 81       	ldd	r18, Y+3	; 0x03
    f102:	3c 81       	ldd	r19, Y+4	; 0x04
    f104:	8d 81       	ldd	r24, Y+5	; 0x05
    f106:	9e 81       	ldd	r25, Y+6	; 0x06
    f108:	fc 01       	movw	r30, r24
    f10a:	80 81       	ld	r24, Z
    f10c:	91 81       	ldd	r25, Z+1	; 0x01
    f10e:	a9 01       	movw	r20, r18
    f110:	48 1b       	sub	r20, r24
    f112:	59 0b       	sbc	r21, r25
    f114:	ca 01       	movw	r24, r20
    f116:	9c 01       	movw	r18, r24
    f118:	89 85       	ldd	r24, Y+9	; 0x09
    f11a:	9a 85       	ldd	r25, Y+10	; 0x0a
    f11c:	82 17       	cp	r24, r18
    f11e:	93 07       	cpc	r25, r19
    f120:	68 f0       	brcs	.+26     	; 0xf13c <_ZNK6String11lastIndexOfERKS_j+0xf4>
    f122:	2b 81       	ldd	r18, Y+3	; 0x03
    f124:	3c 81       	ldd	r19, Y+4	; 0x04
    f126:	8d 81       	ldd	r24, Y+5	; 0x05
    f128:	9e 81       	ldd	r25, Y+6	; 0x06
    f12a:	fc 01       	movw	r30, r24
    f12c:	80 81       	ld	r24, Z
    f12e:	91 81       	ldd	r25, Z+1	; 0x01
    f130:	a9 01       	movw	r20, r18
    f132:	48 1b       	sub	r20, r24
    f134:	59 0b       	sbc	r21, r25
    f136:	ca 01       	movw	r24, r20
    f138:	9a 83       	std	Y+2, r25	; 0x02
    f13a:	89 83       	std	Y+1, r24	; 0x01
int String::lastIndexOf(const String &s2, unsigned int fromIndex) const
{
  	if (s2.len == 0 || len == 0 || s2.len > len) return -1;
	if (fromIndex >= len) fromIndex = len - 1;
	int found = -1;
	for (char *p = buffer; p <= buffer + fromIndex; p++) {
    f13c:	8b 81       	ldd	r24, Y+3	; 0x03
    f13e:	9c 81       	ldd	r25, Y+4	; 0x04
    f140:	01 96       	adiw	r24, 0x01	; 1
    f142:	9c 83       	std	Y+4, r25	; 0x04
    f144:	8b 83       	std	Y+3, r24	; 0x03
    f146:	8d 81       	ldd	r24, Y+5	; 0x05
    f148:	9e 81       	ldd	r25, Y+6	; 0x06
    f14a:	fc 01       	movw	r30, r24
    f14c:	20 81       	ld	r18, Z
    f14e:	31 81       	ldd	r19, Z+1	; 0x01
    f150:	89 85       	ldd	r24, Y+9	; 0x09
    f152:	9a 85       	ldd	r25, Y+10	; 0x0a
    f154:	28 0f       	add	r18, r24
    f156:	39 1f       	adc	r19, r25
    f158:	41 e0       	ldi	r20, 0x01	; 1
    f15a:	8b 81       	ldd	r24, Y+3	; 0x03
    f15c:	9c 81       	ldd	r25, Y+4	; 0x04
    f15e:	28 17       	cp	r18, r24
    f160:	39 07       	cpc	r19, r25
    f162:	08 f4       	brcc	.+2      	; 0xf166 <_ZNK6String11lastIndexOfERKS_j+0x11e>
    f164:	40 e0       	ldi	r20, 0x00	; 0
    f166:	44 23       	and	r20, r20
    f168:	09 f0       	breq	.+2      	; 0xf16c <_ZNK6String11lastIndexOfERKS_j+0x124>
    f16a:	ba cf       	rjmp	.-140    	; 0xf0e0 <_ZNK6String11lastIndexOfERKS_j+0x98>
    f16c:	01 c0       	rjmp	.+2      	; 0xf170 <_ZNK6String11lastIndexOfERKS_j+0x128>
		p = strstr(p, s2.buffer);
		if (!p) break;
    f16e:	00 00       	nop
		if ((unsigned int)(p - buffer) <= fromIndex) found = p - buffer;
	}
	return found;
    f170:	89 81       	ldd	r24, Y+1	; 0x01
    f172:	9a 81       	ldd	r25, Y+2	; 0x02
}
    f174:	2a 96       	adiw	r28, 0x0a	; 10
    f176:	0f b6       	in	r0, 0x3f	; 63
    f178:	f8 94       	cli
    f17a:	de bf       	out	0x3e, r29	; 62
    f17c:	0f be       	out	0x3f, r0	; 63
    f17e:	cd bf       	out	0x3d, r28	; 61
    f180:	df 91       	pop	r29
    f182:	cf 91       	pop	r28
    f184:	08 95       	ret

0000f186 <_ZNK6String9substringEj>:

String String::substring( unsigned int left ) const
{
    f186:	cf 93       	push	r28
    f188:	df 93       	push	r29
    f18a:	00 d0       	rcall	.+0      	; 0xf18c <_ZNK6String9substringEj+0x6>
    f18c:	00 d0       	rcall	.+0      	; 0xf18e <_ZNK6String9substringEj+0x8>
    f18e:	00 d0       	rcall	.+0      	; 0xf190 <_ZNK6String9substringEj+0xa>
    f190:	cd b7       	in	r28, 0x3d	; 61
    f192:	de b7       	in	r29, 0x3e	; 62
    f194:	9a 83       	std	Y+2, r25	; 0x02
    f196:	89 83       	std	Y+1, r24	; 0x01
    f198:	7c 83       	std	Y+4, r23	; 0x04
    f19a:	6b 83       	std	Y+3, r22	; 0x03
    f19c:	5e 83       	std	Y+6, r21	; 0x06
    f19e:	4d 83       	std	Y+5, r20	; 0x05
	return substring(left, len);
    f1a0:	8b 81       	ldd	r24, Y+3	; 0x03
    f1a2:	9c 81       	ldd	r25, Y+4	; 0x04
    f1a4:	fc 01       	movw	r30, r24
    f1a6:	24 81       	ldd	r18, Z+4	; 0x04
    f1a8:	35 81       	ldd	r19, Z+5	; 0x05
    f1aa:	89 81       	ldd	r24, Y+1	; 0x01
    f1ac:	9a 81       	ldd	r25, Y+2	; 0x02
    f1ae:	4d 81       	ldd	r20, Y+5	; 0x05
    f1b0:	5e 81       	ldd	r21, Y+6	; 0x06
    f1b2:	6b 81       	ldd	r22, Y+3	; 0x03
    f1b4:	7c 81       	ldd	r23, Y+4	; 0x04
    f1b6:	0e 94 e8 78 	call	0xf1d0	; 0xf1d0 <_ZNK6String9substringEjj>
}
    f1ba:	89 81       	ldd	r24, Y+1	; 0x01
    f1bc:	9a 81       	ldd	r25, Y+2	; 0x02
    f1be:	26 96       	adiw	r28, 0x06	; 6
    f1c0:	0f b6       	in	r0, 0x3f	; 63
    f1c2:	f8 94       	cli
    f1c4:	de bf       	out	0x3e, r29	; 62
    f1c6:	0f be       	out	0x3f, r0	; 63
    f1c8:	cd bf       	out	0x3d, r28	; 61
    f1ca:	df 91       	pop	r29
    f1cc:	cf 91       	pop	r28
    f1ce:	08 95       	ret

0000f1d0 <_ZNK6String9substringEjj>:

String String::substring(unsigned int left, unsigned int right) const
{
    f1d0:	cf 93       	push	r28
    f1d2:	df 93       	push	r29
    f1d4:	cd b7       	in	r28, 0x3d	; 61
    f1d6:	de b7       	in	r29, 0x3e	; 62
    f1d8:	2b 97       	sbiw	r28, 0x0b	; 11
    f1da:	0f b6       	in	r0, 0x3f	; 63
    f1dc:	f8 94       	cli
    f1de:	de bf       	out	0x3e, r29	; 62
    f1e0:	0f be       	out	0x3f, r0	; 63
    f1e2:	cd bf       	out	0x3d, r28	; 61
    f1e4:	9d 83       	std	Y+5, r25	; 0x05
    f1e6:	8c 83       	std	Y+4, r24	; 0x04
    f1e8:	7f 83       	std	Y+7, r23	; 0x07
    f1ea:	6e 83       	std	Y+6, r22	; 0x06
    f1ec:	59 87       	std	Y+9, r21	; 0x09
    f1ee:	48 87       	std	Y+8, r20	; 0x08
    f1f0:	3b 87       	std	Y+11, r19	; 0x0b
    f1f2:	2a 87       	std	Y+10, r18	; 0x0a
	if (left > right) {
    f1f4:	28 85       	ldd	r18, Y+8	; 0x08
    f1f6:	39 85       	ldd	r19, Y+9	; 0x09
    f1f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    f1fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    f1fc:	82 17       	cp	r24, r18
    f1fe:	93 07       	cpc	r25, r19
    f200:	60 f4       	brcc	.+24     	; 0xf21a <_ZNK6String9substringEjj+0x4a>
		unsigned int temp = right;
    f202:	8a 85       	ldd	r24, Y+10	; 0x0a
    f204:	9b 85       	ldd	r25, Y+11	; 0x0b
    f206:	9a 83       	std	Y+2, r25	; 0x02
    f208:	89 83       	std	Y+1, r24	; 0x01
		right = left;
    f20a:	88 85       	ldd	r24, Y+8	; 0x08
    f20c:	99 85       	ldd	r25, Y+9	; 0x09
    f20e:	9b 87       	std	Y+11, r25	; 0x0b
    f210:	8a 87       	std	Y+10, r24	; 0x0a
		left = temp;
    f212:	89 81       	ldd	r24, Y+1	; 0x01
    f214:	9a 81       	ldd	r25, Y+2	; 0x02
    f216:	99 87       	std	Y+9, r25	; 0x09
    f218:	88 87       	std	Y+8, r24	; 0x08
	}
	String out;
    f21a:	8c 81       	ldd	r24, Y+4	; 0x04
    f21c:	9d 81       	ldd	r25, Y+5	; 0x05
    f21e:	64 e3       	ldi	r22, 0x34	; 52
    f220:	74 e0       	ldi	r23, 0x04	; 4
    f222:	0e 94 3a 6d 	call	0xda74	; 0xda74 <_ZN6StringC1EPKc>
	if (left > len) return out;
    f226:	8e 81       	ldd	r24, Y+6	; 0x06
    f228:	9f 81       	ldd	r25, Y+7	; 0x07
    f22a:	fc 01       	movw	r30, r24
    f22c:	24 81       	ldd	r18, Z+4	; 0x04
    f22e:	35 81       	ldd	r19, Z+5	; 0x05
    f230:	88 85       	ldd	r24, Y+8	; 0x08
    f232:	99 85       	ldd	r25, Y+9	; 0x09
    f234:	28 17       	cp	r18, r24
    f236:	39 07       	cpc	r19, r25
    f238:	08 f4       	brcc	.+2      	; 0xf23c <_ZNK6String9substringEjj+0x6c>
    f23a:	44 c0       	rjmp	.+136    	; 0xf2c4 <_ZNK6String9substringEjj+0xf4>
	if (right > len) right = len;
    f23c:	8e 81       	ldd	r24, Y+6	; 0x06
    f23e:	9f 81       	ldd	r25, Y+7	; 0x07
    f240:	fc 01       	movw	r30, r24
    f242:	24 81       	ldd	r18, Z+4	; 0x04
    f244:	35 81       	ldd	r19, Z+5	; 0x05
    f246:	8a 85       	ldd	r24, Y+10	; 0x0a
    f248:	9b 85       	ldd	r25, Y+11	; 0x0b
    f24a:	28 17       	cp	r18, r24
    f24c:	39 07       	cpc	r19, r25
    f24e:	38 f4       	brcc	.+14     	; 0xf25e <_ZNK6String9substringEjj+0x8e>
    f250:	8e 81       	ldd	r24, Y+6	; 0x06
    f252:	9f 81       	ldd	r25, Y+7	; 0x07
    f254:	fc 01       	movw	r30, r24
    f256:	84 81       	ldd	r24, Z+4	; 0x04
    f258:	95 81       	ldd	r25, Z+5	; 0x05
    f25a:	9b 87       	std	Y+11, r25	; 0x0b
    f25c:	8a 87       	std	Y+10, r24	; 0x0a
	char temp = buffer[right];  // save the replaced character
    f25e:	8e 81       	ldd	r24, Y+6	; 0x06
    f260:	9f 81       	ldd	r25, Y+7	; 0x07
    f262:	fc 01       	movw	r30, r24
    f264:	20 81       	ld	r18, Z
    f266:	31 81       	ldd	r19, Z+1	; 0x01
    f268:	8a 85       	ldd	r24, Y+10	; 0x0a
    f26a:	9b 85       	ldd	r25, Y+11	; 0x0b
    f26c:	82 0f       	add	r24, r18
    f26e:	93 1f       	adc	r25, r19
    f270:	fc 01       	movw	r30, r24
    f272:	80 81       	ld	r24, Z
    f274:	8b 83       	std	Y+3, r24	; 0x03
	buffer[right] = '\0';	
    f276:	8e 81       	ldd	r24, Y+6	; 0x06
    f278:	9f 81       	ldd	r25, Y+7	; 0x07
    f27a:	fc 01       	movw	r30, r24
    f27c:	20 81       	ld	r18, Z
    f27e:	31 81       	ldd	r19, Z+1	; 0x01
    f280:	8a 85       	ldd	r24, Y+10	; 0x0a
    f282:	9b 85       	ldd	r25, Y+11	; 0x0b
    f284:	82 0f       	add	r24, r18
    f286:	93 1f       	adc	r25, r19
    f288:	fc 01       	movw	r30, r24
    f28a:	10 82       	st	Z, r1
	out = buffer + left;  // pointer arithmetic
    f28c:	8e 81       	ldd	r24, Y+6	; 0x06
    f28e:	9f 81       	ldd	r25, Y+7	; 0x07
    f290:	fc 01       	movw	r30, r24
    f292:	20 81       	ld	r18, Z
    f294:	31 81       	ldd	r19, Z+1	; 0x01
    f296:	88 85       	ldd	r24, Y+8	; 0x08
    f298:	99 85       	ldd	r25, Y+9	; 0x09
    f29a:	28 0f       	add	r18, r24
    f29c:	39 1f       	adc	r19, r25
    f29e:	8c 81       	ldd	r24, Y+4	; 0x04
    f2a0:	9d 81       	ldd	r25, Y+5	; 0x05
    f2a2:	b9 01       	movw	r22, r18
    f2a4:	0e 94 c6 6f 	call	0xdf8c	; 0xdf8c <_ZN6StringaSEPKc>
	buffer[right] = temp;  //restore character
    f2a8:	8e 81       	ldd	r24, Y+6	; 0x06
    f2aa:	9f 81       	ldd	r25, Y+7	; 0x07
    f2ac:	fc 01       	movw	r30, r24
    f2ae:	20 81       	ld	r18, Z
    f2b0:	31 81       	ldd	r19, Z+1	; 0x01
    f2b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    f2b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    f2b6:	82 0f       	add	r24, r18
    f2b8:	93 1f       	adc	r25, r19
    f2ba:	2b 81       	ldd	r18, Y+3	; 0x03
    f2bc:	fc 01       	movw	r30, r24
    f2be:	20 83       	st	Z, r18
	return out;
    f2c0:	00 00       	nop
    f2c2:	01 c0       	rjmp	.+2      	; 0xf2c6 <_ZNK6String9substringEjj+0xf6>
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
	if (left > len) return out;
    f2c4:	00 00       	nop
	char temp = buffer[right];  // save the replaced character
	buffer[right] = '\0';	
	out = buffer + left;  // pointer arithmetic
	buffer[right] = temp;  //restore character
	return out;
}
    f2c6:	8c 81       	ldd	r24, Y+4	; 0x04
    f2c8:	9d 81       	ldd	r25, Y+5	; 0x05
    f2ca:	2b 96       	adiw	r28, 0x0b	; 11
    f2cc:	0f b6       	in	r0, 0x3f	; 63
    f2ce:	f8 94       	cli
    f2d0:	de bf       	out	0x3e, r29	; 62
    f2d2:	0f be       	out	0x3f, r0	; 63
    f2d4:	cd bf       	out	0x3d, r28	; 61
    f2d6:	df 91       	pop	r29
    f2d8:	cf 91       	pop	r28
    f2da:	08 95       	ret

0000f2dc <_ZN6String7replaceEcc>:
/*********************************************/
/*  Modification                             */
/*********************************************/

void String::replace(char find, char replace)
{
    f2dc:	cf 93       	push	r28
    f2de:	df 93       	push	r29
    f2e0:	00 d0       	rcall	.+0      	; 0xf2e2 <_ZN6String7replaceEcc+0x6>
    f2e2:	00 d0       	rcall	.+0      	; 0xf2e4 <_ZN6String7replaceEcc+0x8>
    f2e4:	00 d0       	rcall	.+0      	; 0xf2e6 <_ZN6String7replaceEcc+0xa>
    f2e6:	cd b7       	in	r28, 0x3d	; 61
    f2e8:	de b7       	in	r29, 0x3e	; 62
    f2ea:	9c 83       	std	Y+4, r25	; 0x04
    f2ec:	8b 83       	std	Y+3, r24	; 0x03
    f2ee:	6d 83       	std	Y+5, r22	; 0x05
    f2f0:	4e 83       	std	Y+6, r20	; 0x06
	if (!buffer) return;
    f2f2:	8b 81       	ldd	r24, Y+3	; 0x03
    f2f4:	9c 81       	ldd	r25, Y+4	; 0x04
    f2f6:	fc 01       	movw	r30, r24
    f2f8:	80 81       	ld	r24, Z
    f2fa:	91 81       	ldd	r25, Z+1	; 0x01
    f2fc:	00 97       	sbiw	r24, 0x00	; 0
    f2fe:	21 f1       	breq	.+72     	; 0xf348 <_ZN6String7replaceEcc+0x6c>
	for (char *p = buffer; *p; p++) {
    f300:	8b 81       	ldd	r24, Y+3	; 0x03
    f302:	9c 81       	ldd	r25, Y+4	; 0x04
    f304:	fc 01       	movw	r30, r24
    f306:	80 81       	ld	r24, Z
    f308:	91 81       	ldd	r25, Z+1	; 0x01
    f30a:	9a 83       	std	Y+2, r25	; 0x02
    f30c:	89 83       	std	Y+1, r24	; 0x01
    f30e:	11 c0       	rjmp	.+34     	; 0xf332 <_ZN6String7replaceEcc+0x56>
		if (*p == find) *p = replace;
    f310:	89 81       	ldd	r24, Y+1	; 0x01
    f312:	9a 81       	ldd	r25, Y+2	; 0x02
    f314:	fc 01       	movw	r30, r24
    f316:	90 81       	ld	r25, Z
    f318:	8d 81       	ldd	r24, Y+5	; 0x05
    f31a:	98 17       	cp	r25, r24
    f31c:	29 f4       	brne	.+10     	; 0xf328 <_ZN6String7replaceEcc+0x4c>
    f31e:	89 81       	ldd	r24, Y+1	; 0x01
    f320:	9a 81       	ldd	r25, Y+2	; 0x02
    f322:	2e 81       	ldd	r18, Y+6	; 0x06
    f324:	fc 01       	movw	r30, r24
    f326:	20 83       	st	Z, r18
/*********************************************/

void String::replace(char find, char replace)
{
	if (!buffer) return;
	for (char *p = buffer; *p; p++) {
    f328:	89 81       	ldd	r24, Y+1	; 0x01
    f32a:	9a 81       	ldd	r25, Y+2	; 0x02
    f32c:	01 96       	adiw	r24, 0x01	; 1
    f32e:	9a 83       	std	Y+2, r25	; 0x02
    f330:	89 83       	std	Y+1, r24	; 0x01
    f332:	89 81       	ldd	r24, Y+1	; 0x01
    f334:	9a 81       	ldd	r25, Y+2	; 0x02
    f336:	fc 01       	movw	r30, r24
    f338:	90 81       	ld	r25, Z
    f33a:	81 e0       	ldi	r24, 0x01	; 1
    f33c:	99 23       	and	r25, r25
    f33e:	09 f4       	brne	.+2      	; 0xf342 <_ZN6String7replaceEcc+0x66>
    f340:	80 e0       	ldi	r24, 0x00	; 0
    f342:	88 23       	and	r24, r24
    f344:	29 f7       	brne	.-54     	; 0xf310 <_ZN6String7replaceEcc+0x34>
    f346:	01 c0       	rjmp	.+2      	; 0xf34a <_ZN6String7replaceEcc+0x6e>
/*  Modification                             */
/*********************************************/

void String::replace(char find, char replace)
{
	if (!buffer) return;
    f348:	00 00       	nop
	for (char *p = buffer; *p; p++) {
		if (*p == find) *p = replace;
	}
}
    f34a:	26 96       	adiw	r28, 0x06	; 6
    f34c:	0f b6       	in	r0, 0x3f	; 63
    f34e:	f8 94       	cli
    f350:	de bf       	out	0x3e, r29	; 62
    f352:	0f be       	out	0x3f, r0	; 63
    f354:	cd bf       	out	0x3d, r28	; 61
    f356:	df 91       	pop	r29
    f358:	cf 91       	pop	r28
    f35a:	08 95       	ret

0000f35c <_ZN6String7replaceERKS_S1_>:

void String::replace(const String& find, const String& replace)
{
    f35c:	cf 93       	push	r28
    f35e:	df 93       	push	r29
    f360:	cd b7       	in	r28, 0x3d	; 61
    f362:	de b7       	in	r29, 0x3e	; 62
    f364:	64 97       	sbiw	r28, 0x14	; 20
    f366:	0f b6       	in	r0, 0x3f	; 63
    f368:	f8 94       	cli
    f36a:	de bf       	out	0x3e, r29	; 62
    f36c:	0f be       	out	0x3f, r0	; 63
    f36e:	cd bf       	out	0x3d, r28	; 61
    f370:	98 8b       	std	Y+16, r25	; 0x10
    f372:	8f 87       	std	Y+15, r24	; 0x0f
    f374:	7a 8b       	std	Y+18, r23	; 0x12
    f376:	69 8b       	std	Y+17, r22	; 0x11
    f378:	5c 8b       	std	Y+20, r21	; 0x14
    f37a:	4b 8b       	std	Y+19, r20	; 0x13
	if (len == 0 || find.len == 0) return;
    f37c:	8f 85       	ldd	r24, Y+15	; 0x0f
    f37e:	98 89       	ldd	r25, Y+16	; 0x10
    f380:	fc 01       	movw	r30, r24
    f382:	84 81       	ldd	r24, Z+4	; 0x04
    f384:	95 81       	ldd	r25, Z+5	; 0x05
    f386:	00 97       	sbiw	r24, 0x00	; 0
    f388:	09 f4       	brne	.+2      	; 0xf38c <_ZN6String7replaceERKS_S1_+0x30>
    f38a:	a9 c1       	rjmp	.+850    	; 0xf6de <_ZN6String7replaceERKS_S1_+0x382>
    f38c:	89 89       	ldd	r24, Y+17	; 0x11
    f38e:	9a 89       	ldd	r25, Y+18	; 0x12
    f390:	fc 01       	movw	r30, r24
    f392:	84 81       	ldd	r24, Z+4	; 0x04
    f394:	95 81       	ldd	r25, Z+5	; 0x05
    f396:	00 97       	sbiw	r24, 0x00	; 0
    f398:	09 f4       	brne	.+2      	; 0xf39c <_ZN6String7replaceERKS_S1_+0x40>
    f39a:	a1 c1       	rjmp	.+834    	; 0xf6de <_ZN6String7replaceERKS_S1_+0x382>
	int diff = replace.len - find.len;
    f39c:	8b 89       	ldd	r24, Y+19	; 0x13
    f39e:	9c 89       	ldd	r25, Y+20	; 0x14
    f3a0:	fc 01       	movw	r30, r24
    f3a2:	24 81       	ldd	r18, Z+4	; 0x04
    f3a4:	35 81       	ldd	r19, Z+5	; 0x05
    f3a6:	89 89       	ldd	r24, Y+17	; 0x11
    f3a8:	9a 89       	ldd	r25, Y+18	; 0x12
    f3aa:	fc 01       	movw	r30, r24
    f3ac:	84 81       	ldd	r24, Z+4	; 0x04
    f3ae:	95 81       	ldd	r25, Z+5	; 0x05
    f3b0:	a9 01       	movw	r20, r18
    f3b2:	48 1b       	sub	r20, r24
    f3b4:	59 0b       	sbc	r21, r25
    f3b6:	ca 01       	movw	r24, r20
    f3b8:	9a 87       	std	Y+10, r25	; 0x0a
    f3ba:	89 87       	std	Y+9, r24	; 0x09
	char *readFrom = buffer;
    f3bc:	8f 85       	ldd	r24, Y+15	; 0x0f
    f3be:	98 89       	ldd	r25, Y+16	; 0x10
    f3c0:	fc 01       	movw	r30, r24
    f3c2:	80 81       	ld	r24, Z
    f3c4:	91 81       	ldd	r25, Z+1	; 0x01
    f3c6:	9a 83       	std	Y+2, r25	; 0x02
    f3c8:	89 83       	std	Y+1, r24	; 0x01
	char *foundAt;
	if (diff == 0) {
    f3ca:	89 85       	ldd	r24, Y+9	; 0x09
    f3cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    f3ce:	00 97       	sbiw	r24, 0x00	; 0
    f3d0:	81 f5       	brne	.+96     	; 0xf432 <_ZN6String7replaceERKS_S1_+0xd6>
		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
    f3d2:	1a c0       	rjmp	.+52     	; 0xf408 <_ZN6String7replaceERKS_S1_+0xac>
			memcpy(foundAt, replace.buffer, replace.len);
    f3d4:	8b 89       	ldd	r24, Y+19	; 0x13
    f3d6:	9c 89       	ldd	r25, Y+20	; 0x14
    f3d8:	fc 01       	movw	r30, r24
    f3da:	44 81       	ldd	r20, Z+4	; 0x04
    f3dc:	55 81       	ldd	r21, Z+5	; 0x05
    f3de:	8b 89       	ldd	r24, Y+19	; 0x13
    f3e0:	9c 89       	ldd	r25, Y+20	; 0x14
    f3e2:	fc 01       	movw	r30, r24
    f3e4:	20 81       	ld	r18, Z
    f3e6:	31 81       	ldd	r19, Z+1	; 0x01
    f3e8:	8b 85       	ldd	r24, Y+11	; 0x0b
    f3ea:	9c 85       	ldd	r25, Y+12	; 0x0c
    f3ec:	b9 01       	movw	r22, r18
    f3ee:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
			readFrom = foundAt + replace.len;
    f3f2:	8b 89       	ldd	r24, Y+19	; 0x13
    f3f4:	9c 89       	ldd	r25, Y+20	; 0x14
    f3f6:	fc 01       	movw	r30, r24
    f3f8:	84 81       	ldd	r24, Z+4	; 0x04
    f3fa:	95 81       	ldd	r25, Z+5	; 0x05
    f3fc:	2b 85       	ldd	r18, Y+11	; 0x0b
    f3fe:	3c 85       	ldd	r19, Y+12	; 0x0c
    f400:	82 0f       	add	r24, r18
    f402:	93 1f       	adc	r25, r19
    f404:	9a 83       	std	Y+2, r25	; 0x02
    f406:	89 83       	std	Y+1, r24	; 0x01
	if (len == 0 || find.len == 0) return;
	int diff = replace.len - find.len;
	char *readFrom = buffer;
	char *foundAt;
	if (diff == 0) {
		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
    f408:	89 89       	ldd	r24, Y+17	; 0x11
    f40a:	9a 89       	ldd	r25, Y+18	; 0x12
    f40c:	fc 01       	movw	r30, r24
    f40e:	20 81       	ld	r18, Z
    f410:	31 81       	ldd	r19, Z+1	; 0x01
    f412:	89 81       	ldd	r24, Y+1	; 0x01
    f414:	9a 81       	ldd	r25, Y+2	; 0x02
    f416:	b9 01       	movw	r22, r18
    f418:	0e 94 6c b1 	call	0x162d8	; 0x162d8 <strstr>
    f41c:	9c 87       	std	Y+12, r25	; 0x0c
    f41e:	8b 87       	std	Y+11, r24	; 0x0b
    f420:	21 e0       	ldi	r18, 0x01	; 1
    f422:	8b 85       	ldd	r24, Y+11	; 0x0b
    f424:	9c 85       	ldd	r25, Y+12	; 0x0c
    f426:	00 97       	sbiw	r24, 0x00	; 0
    f428:	09 f4       	brne	.+2      	; 0xf42c <_ZN6String7replaceERKS_S1_+0xd0>
    f42a:	20 e0       	ldi	r18, 0x00	; 0
    f42c:	22 23       	and	r18, r18
    f42e:	91 f6       	brne	.-92     	; 0xf3d4 <_ZN6String7replaceERKS_S1_+0x78>
    f430:	5b c1       	rjmp	.+694    	; 0xf6e8 <_ZN6String7replaceERKS_S1_+0x38c>
			memcpy(foundAt, replace.buffer, replace.len);
			readFrom = foundAt + replace.len;
		}
	} else if (diff < 0) {
    f432:	89 85       	ldd	r24, Y+9	; 0x09
    f434:	9a 85       	ldd	r25, Y+10	; 0x0a
    f436:	99 23       	and	r25, r25
    f438:	0c f0       	brlt	.+2      	; 0xf43c <_ZN6String7replaceERKS_S1_+0xe0>
    f43a:	73 c0       	rjmp	.+230    	; 0xf522 <_ZN6String7replaceERKS_S1_+0x1c6>
		char *writeTo = buffer;
    f43c:	8f 85       	ldd	r24, Y+15	; 0x0f
    f43e:	98 89       	ldd	r25, Y+16	; 0x10
    f440:	fc 01       	movw	r30, r24
    f442:	80 81       	ld	r24, Z
    f444:	91 81       	ldd	r25, Z+1	; 0x01
    f446:	9c 83       	std	Y+4, r25	; 0x04
    f448:	8b 83       	std	Y+3, r24	; 0x03
		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
    f44a:	4e c0       	rjmp	.+156    	; 0xf4e8 <_ZN6String7replaceERKS_S1_+0x18c>
			unsigned int n = foundAt - readFrom;
    f44c:	2b 85       	ldd	r18, Y+11	; 0x0b
    f44e:	3c 85       	ldd	r19, Y+12	; 0x0c
    f450:	89 81       	ldd	r24, Y+1	; 0x01
    f452:	9a 81       	ldd	r25, Y+2	; 0x02
    f454:	a9 01       	movw	r20, r18
    f456:	48 1b       	sub	r20, r24
    f458:	59 0b       	sbc	r21, r25
    f45a:	ca 01       	movw	r24, r20
    f45c:	9e 87       	std	Y+14, r25	; 0x0e
    f45e:	8d 87       	std	Y+13, r24	; 0x0d
			memcpy(writeTo, readFrom, n);
    f460:	4d 85       	ldd	r20, Y+13	; 0x0d
    f462:	5e 85       	ldd	r21, Y+14	; 0x0e
    f464:	29 81       	ldd	r18, Y+1	; 0x01
    f466:	3a 81       	ldd	r19, Y+2	; 0x02
    f468:	8b 81       	ldd	r24, Y+3	; 0x03
    f46a:	9c 81       	ldd	r25, Y+4	; 0x04
    f46c:	b9 01       	movw	r22, r18
    f46e:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
			writeTo += n;
    f472:	2b 81       	ldd	r18, Y+3	; 0x03
    f474:	3c 81       	ldd	r19, Y+4	; 0x04
    f476:	8d 85       	ldd	r24, Y+13	; 0x0d
    f478:	9e 85       	ldd	r25, Y+14	; 0x0e
    f47a:	82 0f       	add	r24, r18
    f47c:	93 1f       	adc	r25, r19
    f47e:	9c 83       	std	Y+4, r25	; 0x04
    f480:	8b 83       	std	Y+3, r24	; 0x03
			memcpy(writeTo, replace.buffer, replace.len);
    f482:	8b 89       	ldd	r24, Y+19	; 0x13
    f484:	9c 89       	ldd	r25, Y+20	; 0x14
    f486:	fc 01       	movw	r30, r24
    f488:	44 81       	ldd	r20, Z+4	; 0x04
    f48a:	55 81       	ldd	r21, Z+5	; 0x05
    f48c:	8b 89       	ldd	r24, Y+19	; 0x13
    f48e:	9c 89       	ldd	r25, Y+20	; 0x14
    f490:	fc 01       	movw	r30, r24
    f492:	20 81       	ld	r18, Z
    f494:	31 81       	ldd	r19, Z+1	; 0x01
    f496:	8b 81       	ldd	r24, Y+3	; 0x03
    f498:	9c 81       	ldd	r25, Y+4	; 0x04
    f49a:	b9 01       	movw	r22, r18
    f49c:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
			writeTo += replace.len;
    f4a0:	8b 89       	ldd	r24, Y+19	; 0x13
    f4a2:	9c 89       	ldd	r25, Y+20	; 0x14
    f4a4:	fc 01       	movw	r30, r24
    f4a6:	84 81       	ldd	r24, Z+4	; 0x04
    f4a8:	95 81       	ldd	r25, Z+5	; 0x05
    f4aa:	2b 81       	ldd	r18, Y+3	; 0x03
    f4ac:	3c 81       	ldd	r19, Y+4	; 0x04
    f4ae:	82 0f       	add	r24, r18
    f4b0:	93 1f       	adc	r25, r19
    f4b2:	9c 83       	std	Y+4, r25	; 0x04
    f4b4:	8b 83       	std	Y+3, r24	; 0x03
			readFrom = foundAt + find.len;
    f4b6:	89 89       	ldd	r24, Y+17	; 0x11
    f4b8:	9a 89       	ldd	r25, Y+18	; 0x12
    f4ba:	fc 01       	movw	r30, r24
    f4bc:	84 81       	ldd	r24, Z+4	; 0x04
    f4be:	95 81       	ldd	r25, Z+5	; 0x05
    f4c0:	2b 85       	ldd	r18, Y+11	; 0x0b
    f4c2:	3c 85       	ldd	r19, Y+12	; 0x0c
    f4c4:	82 0f       	add	r24, r18
    f4c6:	93 1f       	adc	r25, r19
    f4c8:	9a 83       	std	Y+2, r25	; 0x02
    f4ca:	89 83       	std	Y+1, r24	; 0x01
			len += diff;
    f4cc:	8f 85       	ldd	r24, Y+15	; 0x0f
    f4ce:	98 89       	ldd	r25, Y+16	; 0x10
    f4d0:	fc 01       	movw	r30, r24
    f4d2:	24 81       	ldd	r18, Z+4	; 0x04
    f4d4:	35 81       	ldd	r19, Z+5	; 0x05
    f4d6:	89 85       	ldd	r24, Y+9	; 0x09
    f4d8:	9a 85       	ldd	r25, Y+10	; 0x0a
    f4da:	28 0f       	add	r18, r24
    f4dc:	39 1f       	adc	r19, r25
    f4de:	8f 85       	ldd	r24, Y+15	; 0x0f
    f4e0:	98 89       	ldd	r25, Y+16	; 0x10
    f4e2:	fc 01       	movw	r30, r24
    f4e4:	35 83       	std	Z+5, r19	; 0x05
    f4e6:	24 83       	std	Z+4, r18	; 0x04
			memcpy(foundAt, replace.buffer, replace.len);
			readFrom = foundAt + replace.len;
		}
	} else if (diff < 0) {
		char *writeTo = buffer;
		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
    f4e8:	89 89       	ldd	r24, Y+17	; 0x11
    f4ea:	9a 89       	ldd	r25, Y+18	; 0x12
    f4ec:	fc 01       	movw	r30, r24
    f4ee:	20 81       	ld	r18, Z
    f4f0:	31 81       	ldd	r19, Z+1	; 0x01
    f4f2:	89 81       	ldd	r24, Y+1	; 0x01
    f4f4:	9a 81       	ldd	r25, Y+2	; 0x02
    f4f6:	b9 01       	movw	r22, r18
    f4f8:	0e 94 6c b1 	call	0x162d8	; 0x162d8 <strstr>
    f4fc:	9c 87       	std	Y+12, r25	; 0x0c
    f4fe:	8b 87       	std	Y+11, r24	; 0x0b
    f500:	21 e0       	ldi	r18, 0x01	; 1
    f502:	8b 85       	ldd	r24, Y+11	; 0x0b
    f504:	9c 85       	ldd	r25, Y+12	; 0x0c
    f506:	00 97       	sbiw	r24, 0x00	; 0
    f508:	09 f4       	brne	.+2      	; 0xf50c <_ZN6String7replaceERKS_S1_+0x1b0>
    f50a:	20 e0       	ldi	r18, 0x00	; 0
    f50c:	22 23       	and	r18, r18
    f50e:	09 f0       	breq	.+2      	; 0xf512 <_ZN6String7replaceERKS_S1_+0x1b6>
    f510:	9d cf       	rjmp	.-198    	; 0xf44c <_ZN6String7replaceERKS_S1_+0xf0>
			memcpy(writeTo, replace.buffer, replace.len);
			writeTo += replace.len;
			readFrom = foundAt + find.len;
			len += diff;
		}
		strcpy(writeTo, readFrom);
    f512:	29 81       	ldd	r18, Y+1	; 0x01
    f514:	3a 81       	ldd	r19, Y+2	; 0x02
    f516:	8b 81       	ldd	r24, Y+3	; 0x03
    f518:	9c 81       	ldd	r25, Y+4	; 0x04
    f51a:	b9 01       	movw	r22, r18
    f51c:	0e 94 34 b1 	call	0x16268	; 0x16268 <strcpy>
    f520:	e3 c0       	rjmp	.+454    	; 0xf6e8 <_ZN6String7replaceERKS_S1_+0x38c>
	} else {
		unsigned int size = len; // compute size needed for result
    f522:	8f 85       	ldd	r24, Y+15	; 0x0f
    f524:	98 89       	ldd	r25, Y+16	; 0x10
    f526:	fc 01       	movw	r30, r24
    f528:	84 81       	ldd	r24, Z+4	; 0x04
    f52a:	95 81       	ldd	r25, Z+5	; 0x05
    f52c:	9e 83       	std	Y+6, r25	; 0x06
    f52e:	8d 83       	std	Y+5, r24	; 0x05
		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
    f530:	13 c0       	rjmp	.+38     	; 0xf558 <_ZN6String7replaceERKS_S1_+0x1fc>
			readFrom = foundAt + find.len;
    f532:	89 89       	ldd	r24, Y+17	; 0x11
    f534:	9a 89       	ldd	r25, Y+18	; 0x12
    f536:	fc 01       	movw	r30, r24
    f538:	84 81       	ldd	r24, Z+4	; 0x04
    f53a:	95 81       	ldd	r25, Z+5	; 0x05
    f53c:	2b 85       	ldd	r18, Y+11	; 0x0b
    f53e:	3c 85       	ldd	r19, Y+12	; 0x0c
    f540:	82 0f       	add	r24, r18
    f542:	93 1f       	adc	r25, r19
    f544:	9a 83       	std	Y+2, r25	; 0x02
    f546:	89 83       	std	Y+1, r24	; 0x01
			size += diff;
    f548:	89 85       	ldd	r24, Y+9	; 0x09
    f54a:	9a 85       	ldd	r25, Y+10	; 0x0a
    f54c:	2d 81       	ldd	r18, Y+5	; 0x05
    f54e:	3e 81       	ldd	r19, Y+6	; 0x06
    f550:	82 0f       	add	r24, r18
    f552:	93 1f       	adc	r25, r19
    f554:	9e 83       	std	Y+6, r25	; 0x06
    f556:	8d 83       	std	Y+5, r24	; 0x05
			len += diff;
		}
		strcpy(writeTo, readFrom);
	} else {
		unsigned int size = len; // compute size needed for result
		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
    f558:	89 89       	ldd	r24, Y+17	; 0x11
    f55a:	9a 89       	ldd	r25, Y+18	; 0x12
    f55c:	fc 01       	movw	r30, r24
    f55e:	20 81       	ld	r18, Z
    f560:	31 81       	ldd	r19, Z+1	; 0x01
    f562:	89 81       	ldd	r24, Y+1	; 0x01
    f564:	9a 81       	ldd	r25, Y+2	; 0x02
    f566:	b9 01       	movw	r22, r18
    f568:	0e 94 6c b1 	call	0x162d8	; 0x162d8 <strstr>
    f56c:	9c 87       	std	Y+12, r25	; 0x0c
    f56e:	8b 87       	std	Y+11, r24	; 0x0b
    f570:	21 e0       	ldi	r18, 0x01	; 1
    f572:	8b 85       	ldd	r24, Y+11	; 0x0b
    f574:	9c 85       	ldd	r25, Y+12	; 0x0c
    f576:	00 97       	sbiw	r24, 0x00	; 0
    f578:	09 f4       	brne	.+2      	; 0xf57c <_ZN6String7replaceERKS_S1_+0x220>
    f57a:	20 e0       	ldi	r18, 0x00	; 0
    f57c:	22 23       	and	r18, r18
    f57e:	c9 f6       	brne	.-78     	; 0xf532 <_ZN6String7replaceERKS_S1_+0x1d6>
			readFrom = foundAt + find.len;
			size += diff;
		}
		if (size == len) return;
    f580:	8f 85       	ldd	r24, Y+15	; 0x0f
    f582:	98 89       	ldd	r25, Y+16	; 0x10
    f584:	fc 01       	movw	r30, r24
    f586:	24 81       	ldd	r18, Z+4	; 0x04
    f588:	35 81       	ldd	r19, Z+5	; 0x05
    f58a:	8d 81       	ldd	r24, Y+5	; 0x05
    f58c:	9e 81       	ldd	r25, Y+6	; 0x06
    f58e:	28 17       	cp	r18, r24
    f590:	39 07       	cpc	r19, r25
    f592:	09 f4       	brne	.+2      	; 0xf596 <_ZN6String7replaceERKS_S1_+0x23a>
    f594:	a6 c0       	rjmp	.+332    	; 0xf6e2 <_ZN6String7replaceERKS_S1_+0x386>
		if (size > capacity && !changeBuffer(size)) return; // XXX: tell user!
    f596:	8f 85       	ldd	r24, Y+15	; 0x0f
    f598:	98 89       	ldd	r25, Y+16	; 0x10
    f59a:	fc 01       	movw	r30, r24
    f59c:	22 81       	ldd	r18, Z+2	; 0x02
    f59e:	33 81       	ldd	r19, Z+3	; 0x03
    f5a0:	8d 81       	ldd	r24, Y+5	; 0x05
    f5a2:	9e 81       	ldd	r25, Y+6	; 0x06
    f5a4:	28 17       	cp	r18, r24
    f5a6:	39 07       	cpc	r19, r25
    f5a8:	58 f4       	brcc	.+22     	; 0xf5c0 <_ZN6String7replaceERKS_S1_+0x264>
    f5aa:	2d 81       	ldd	r18, Y+5	; 0x05
    f5ac:	3e 81       	ldd	r19, Y+6	; 0x06
    f5ae:	8f 85       	ldd	r24, Y+15	; 0x0f
    f5b0:	98 89       	ldd	r25, Y+16	; 0x10
    f5b2:	b9 01       	movw	r22, r18
    f5b4:	0e 94 18 6f 	call	0xde30	; 0xde30 <_ZN6String12changeBufferEj>
    f5b8:	88 23       	and	r24, r24
    f5ba:	11 f4       	brne	.+4      	; 0xf5c0 <_ZN6String7replaceERKS_S1_+0x264>
    f5bc:	81 e0       	ldi	r24, 0x01	; 1
    f5be:	01 c0       	rjmp	.+2      	; 0xf5c2 <_ZN6String7replaceERKS_S1_+0x266>
    f5c0:	80 e0       	ldi	r24, 0x00	; 0
    f5c2:	88 23       	and	r24, r24
    f5c4:	09 f0       	breq	.+2      	; 0xf5c8 <_ZN6String7replaceERKS_S1_+0x26c>
    f5c6:	8f c0       	rjmp	.+286    	; 0xf6e6 <_ZN6String7replaceERKS_S1_+0x38a>
		int index = len - 1;
    f5c8:	8f 85       	ldd	r24, Y+15	; 0x0f
    f5ca:	98 89       	ldd	r25, Y+16	; 0x10
    f5cc:	fc 01       	movw	r30, r24
    f5ce:	84 81       	ldd	r24, Z+4	; 0x04
    f5d0:	95 81       	ldd	r25, Z+5	; 0x05
    f5d2:	01 97       	sbiw	r24, 0x01	; 1
    f5d4:	98 87       	std	Y+8, r25	; 0x08
    f5d6:	8f 83       	std	Y+7, r24	; 0x07
		while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
    f5d8:	68 c0       	rjmp	.+208    	; 0xf6aa <_ZN6String7replaceERKS_S1_+0x34e>
			readFrom = buffer + index + find.len;
    f5da:	8f 85       	ldd	r24, Y+15	; 0x0f
    f5dc:	98 89       	ldd	r25, Y+16	; 0x10
    f5de:	fc 01       	movw	r30, r24
    f5e0:	20 81       	ld	r18, Z
    f5e2:	31 81       	ldd	r19, Z+1	; 0x01
    f5e4:	89 89       	ldd	r24, Y+17	; 0x11
    f5e6:	9a 89       	ldd	r25, Y+18	; 0x12
    f5e8:	fc 01       	movw	r30, r24
    f5ea:	44 81       	ldd	r20, Z+4	; 0x04
    f5ec:	55 81       	ldd	r21, Z+5	; 0x05
    f5ee:	8f 81       	ldd	r24, Y+7	; 0x07
    f5f0:	98 85       	ldd	r25, Y+8	; 0x08
    f5f2:	84 0f       	add	r24, r20
    f5f4:	95 1f       	adc	r25, r21
    f5f6:	82 0f       	add	r24, r18
    f5f8:	93 1f       	adc	r25, r19
    f5fa:	9a 83       	std	Y+2, r25	; 0x02
    f5fc:	89 83       	std	Y+1, r24	; 0x01
			memmove(readFrom + diff, readFrom, len - (readFrom - buffer));
    f5fe:	8f 85       	ldd	r24, Y+15	; 0x0f
    f600:	98 89       	ldd	r25, Y+16	; 0x10
    f602:	fc 01       	movw	r30, r24
    f604:	24 81       	ldd	r18, Z+4	; 0x04
    f606:	35 81       	ldd	r19, Z+5	; 0x05
    f608:	8f 85       	ldd	r24, Y+15	; 0x0f
    f60a:	98 89       	ldd	r25, Y+16	; 0x10
    f60c:	fc 01       	movw	r30, r24
    f60e:	80 81       	ld	r24, Z
    f610:	91 81       	ldd	r25, Z+1	; 0x01
    f612:	ac 01       	movw	r20, r24
    f614:	89 81       	ldd	r24, Y+1	; 0x01
    f616:	9a 81       	ldd	r25, Y+2	; 0x02
    f618:	ba 01       	movw	r22, r20
    f61a:	68 1b       	sub	r22, r24
    f61c:	79 0b       	sbc	r23, r25
    f61e:	cb 01       	movw	r24, r22
    f620:	a9 01       	movw	r20, r18
    f622:	48 0f       	add	r20, r24
    f624:	59 1f       	adc	r21, r25
    f626:	89 85       	ldd	r24, Y+9	; 0x09
    f628:	9a 85       	ldd	r25, Y+10	; 0x0a
    f62a:	29 81       	ldd	r18, Y+1	; 0x01
    f62c:	3a 81       	ldd	r19, Y+2	; 0x02
    f62e:	82 0f       	add	r24, r18
    f630:	93 1f       	adc	r25, r19
    f632:	29 81       	ldd	r18, Y+1	; 0x01
    f634:	3a 81       	ldd	r19, Y+2	; 0x02
    f636:	b9 01       	movw	r22, r18
    f638:	0e 94 07 b1 	call	0x1620e	; 0x1620e <memmove>
			len += diff;
    f63c:	8f 85       	ldd	r24, Y+15	; 0x0f
    f63e:	98 89       	ldd	r25, Y+16	; 0x10
    f640:	fc 01       	movw	r30, r24
    f642:	24 81       	ldd	r18, Z+4	; 0x04
    f644:	35 81       	ldd	r19, Z+5	; 0x05
    f646:	89 85       	ldd	r24, Y+9	; 0x09
    f648:	9a 85       	ldd	r25, Y+10	; 0x0a
    f64a:	28 0f       	add	r18, r24
    f64c:	39 1f       	adc	r19, r25
    f64e:	8f 85       	ldd	r24, Y+15	; 0x0f
    f650:	98 89       	ldd	r25, Y+16	; 0x10
    f652:	fc 01       	movw	r30, r24
    f654:	35 83       	std	Z+5, r19	; 0x05
    f656:	24 83       	std	Z+4, r18	; 0x04
			buffer[len] = 0;
    f658:	8f 85       	ldd	r24, Y+15	; 0x0f
    f65a:	98 89       	ldd	r25, Y+16	; 0x10
    f65c:	fc 01       	movw	r30, r24
    f65e:	20 81       	ld	r18, Z
    f660:	31 81       	ldd	r19, Z+1	; 0x01
    f662:	8f 85       	ldd	r24, Y+15	; 0x0f
    f664:	98 89       	ldd	r25, Y+16	; 0x10
    f666:	fc 01       	movw	r30, r24
    f668:	84 81       	ldd	r24, Z+4	; 0x04
    f66a:	95 81       	ldd	r25, Z+5	; 0x05
    f66c:	82 0f       	add	r24, r18
    f66e:	93 1f       	adc	r25, r19
    f670:	fc 01       	movw	r30, r24
    f672:	10 82       	st	Z, r1
			memcpy(buffer + index, replace.buffer, replace.len);
    f674:	8b 89       	ldd	r24, Y+19	; 0x13
    f676:	9c 89       	ldd	r25, Y+20	; 0x14
    f678:	fc 01       	movw	r30, r24
    f67a:	44 81       	ldd	r20, Z+4	; 0x04
    f67c:	55 81       	ldd	r21, Z+5	; 0x05
    f67e:	8b 89       	ldd	r24, Y+19	; 0x13
    f680:	9c 89       	ldd	r25, Y+20	; 0x14
    f682:	fc 01       	movw	r30, r24
    f684:	20 81       	ld	r18, Z
    f686:	31 81       	ldd	r19, Z+1	; 0x01
    f688:	8f 85       	ldd	r24, Y+15	; 0x0f
    f68a:	98 89       	ldd	r25, Y+16	; 0x10
    f68c:	fc 01       	movw	r30, r24
    f68e:	60 81       	ld	r22, Z
    f690:	71 81       	ldd	r23, Z+1	; 0x01
    f692:	8f 81       	ldd	r24, Y+7	; 0x07
    f694:	98 85       	ldd	r25, Y+8	; 0x08
    f696:	86 0f       	add	r24, r22
    f698:	97 1f       	adc	r25, r23
    f69a:	b9 01       	movw	r22, r18
    f69c:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
			index--;
    f6a0:	8f 81       	ldd	r24, Y+7	; 0x07
    f6a2:	98 85       	ldd	r25, Y+8	; 0x08
    f6a4:	01 97       	sbiw	r24, 0x01	; 1
    f6a6:	98 87       	std	Y+8, r25	; 0x08
    f6a8:	8f 83       	std	Y+7, r24	; 0x07
			size += diff;
		}
		if (size == len) return;
		if (size > capacity && !changeBuffer(size)) return; // XXX: tell user!
		int index = len - 1;
		while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
    f6aa:	8f 81       	ldd	r24, Y+7	; 0x07
    f6ac:	98 85       	ldd	r25, Y+8	; 0x08
    f6ae:	99 23       	and	r25, r25
    f6b0:	8c f0       	brlt	.+34     	; 0xf6d4 <_ZN6String7replaceERKS_S1_+0x378>
    f6b2:	4f 81       	ldd	r20, Y+7	; 0x07
    f6b4:	58 85       	ldd	r21, Y+8	; 0x08
    f6b6:	29 89       	ldd	r18, Y+17	; 0x11
    f6b8:	3a 89       	ldd	r19, Y+18	; 0x12
    f6ba:	8f 85       	ldd	r24, Y+15	; 0x0f
    f6bc:	98 89       	ldd	r25, Y+16	; 0x10
    f6be:	b9 01       	movw	r22, r18
    f6c0:	0e 94 24 78 	call	0xf048	; 0xf048 <_ZNK6String11lastIndexOfERKS_j>
    f6c4:	98 87       	std	Y+8, r25	; 0x08
    f6c6:	8f 83       	std	Y+7, r24	; 0x07
    f6c8:	8f 81       	ldd	r24, Y+7	; 0x07
    f6ca:	98 85       	ldd	r25, Y+8	; 0x08
    f6cc:	99 23       	and	r25, r25
    f6ce:	14 f0       	brlt	.+4      	; 0xf6d4 <_ZN6String7replaceERKS_S1_+0x378>
    f6d0:	81 e0       	ldi	r24, 0x01	; 1
    f6d2:	01 c0       	rjmp	.+2      	; 0xf6d6 <_ZN6String7replaceERKS_S1_+0x37a>
    f6d4:	80 e0       	ldi	r24, 0x00	; 0
    f6d6:	88 23       	and	r24, r24
    f6d8:	09 f0       	breq	.+2      	; 0xf6dc <_ZN6String7replaceERKS_S1_+0x380>
    f6da:	7f cf       	rjmp	.-258    	; 0xf5da <_ZN6String7replaceERKS_S1_+0x27e>
    f6dc:	05 c0       	rjmp	.+10     	; 0xf6e8 <_ZN6String7replaceERKS_S1_+0x38c>
	}
}

void String::replace(const String& find, const String& replace)
{
	if (len == 0 || find.len == 0) return;
    f6de:	00 00       	nop
    f6e0:	03 c0       	rjmp	.+6      	; 0xf6e8 <_ZN6String7replaceERKS_S1_+0x38c>
		unsigned int size = len; // compute size needed for result
		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
			readFrom = foundAt + find.len;
			size += diff;
		}
		if (size == len) return;
    f6e2:	00 00       	nop
    f6e4:	01 c0       	rjmp	.+2      	; 0xf6e8 <_ZN6String7replaceERKS_S1_+0x38c>
		if (size > capacity && !changeBuffer(size)) return; // XXX: tell user!
    f6e6:	00 00       	nop
			buffer[len] = 0;
			memcpy(buffer + index, replace.buffer, replace.len);
			index--;
		}
	}
}
    f6e8:	64 96       	adiw	r28, 0x14	; 20
    f6ea:	0f b6       	in	r0, 0x3f	; 63
    f6ec:	f8 94       	cli
    f6ee:	de bf       	out	0x3e, r29	; 62
    f6f0:	0f be       	out	0x3f, r0	; 63
    f6f2:	cd bf       	out	0x3d, r28	; 61
    f6f4:	df 91       	pop	r29
    f6f6:	cf 91       	pop	r28
    f6f8:	08 95       	ret

0000f6fa <_ZN6String11toLowerCaseEv>:

void String::toLowerCase(void)
{
    f6fa:	cf 93       	push	r28
    f6fc:	df 93       	push	r29
    f6fe:	00 d0       	rcall	.+0      	; 0xf700 <_ZN6String11toLowerCaseEv+0x6>
    f700:	00 d0       	rcall	.+0      	; 0xf702 <_ZN6String11toLowerCaseEv+0x8>
    f702:	cd b7       	in	r28, 0x3d	; 61
    f704:	de b7       	in	r29, 0x3e	; 62
    f706:	9c 83       	std	Y+4, r25	; 0x04
    f708:	8b 83       	std	Y+3, r24	; 0x03
	if (!buffer) return;
    f70a:	8b 81       	ldd	r24, Y+3	; 0x03
    f70c:	9c 81       	ldd	r25, Y+4	; 0x04
    f70e:	fc 01       	movw	r30, r24
    f710:	80 81       	ld	r24, Z
    f712:	91 81       	ldd	r25, Z+1	; 0x01
    f714:	00 97       	sbiw	r24, 0x00	; 0
    f716:	29 f1       	breq	.+74     	; 0xf762 <_ZN6String11toLowerCaseEv+0x68>
	for (char *p = buffer; *p; p++) {
    f718:	8b 81       	ldd	r24, Y+3	; 0x03
    f71a:	9c 81       	ldd	r25, Y+4	; 0x04
    f71c:	fc 01       	movw	r30, r24
    f71e:	80 81       	ld	r24, Z
    f720:	91 81       	ldd	r25, Z+1	; 0x01
    f722:	9a 83       	std	Y+2, r25	; 0x02
    f724:	89 83       	std	Y+1, r24	; 0x01
    f726:	12 c0       	rjmp	.+36     	; 0xf74c <_ZN6String11toLowerCaseEv+0x52>
		*p = tolower(*p);
    f728:	89 81       	ldd	r24, Y+1	; 0x01
    f72a:	9a 81       	ldd	r25, Y+2	; 0x02
    f72c:	fc 01       	movw	r30, r24
    f72e:	80 81       	ld	r24, Z
    f730:	88 2f       	mov	r24, r24
    f732:	90 e0       	ldi	r25, 0x00	; 0
    f734:	0e 94 e1 b0 	call	0x161c2	; 0x161c2 <tolower>
    f738:	28 2f       	mov	r18, r24
    f73a:	89 81       	ldd	r24, Y+1	; 0x01
    f73c:	9a 81       	ldd	r25, Y+2	; 0x02
    f73e:	fc 01       	movw	r30, r24
    f740:	20 83       	st	Z, r18
}

void String::toLowerCase(void)
{
	if (!buffer) return;
	for (char *p = buffer; *p; p++) {
    f742:	89 81       	ldd	r24, Y+1	; 0x01
    f744:	9a 81       	ldd	r25, Y+2	; 0x02
    f746:	01 96       	adiw	r24, 0x01	; 1
    f748:	9a 83       	std	Y+2, r25	; 0x02
    f74a:	89 83       	std	Y+1, r24	; 0x01
    f74c:	89 81       	ldd	r24, Y+1	; 0x01
    f74e:	9a 81       	ldd	r25, Y+2	; 0x02
    f750:	fc 01       	movw	r30, r24
    f752:	90 81       	ld	r25, Z
    f754:	81 e0       	ldi	r24, 0x01	; 1
    f756:	99 23       	and	r25, r25
    f758:	09 f4       	brne	.+2      	; 0xf75c <_ZN6String11toLowerCaseEv+0x62>
    f75a:	80 e0       	ldi	r24, 0x00	; 0
    f75c:	88 23       	and	r24, r24
    f75e:	21 f7       	brne	.-56     	; 0xf728 <_ZN6String11toLowerCaseEv+0x2e>
    f760:	01 c0       	rjmp	.+2      	; 0xf764 <_ZN6String11toLowerCaseEv+0x6a>
	}
}

void String::toLowerCase(void)
{
	if (!buffer) return;
    f762:	00 00       	nop
	for (char *p = buffer; *p; p++) {
		*p = tolower(*p);
	}
}
    f764:	0f 90       	pop	r0
    f766:	0f 90       	pop	r0
    f768:	0f 90       	pop	r0
    f76a:	0f 90       	pop	r0
    f76c:	df 91       	pop	r29
    f76e:	cf 91       	pop	r28
    f770:	08 95       	ret

0000f772 <_ZN6String11toUpperCaseEv>:

void String::toUpperCase(void)
{
    f772:	cf 93       	push	r28
    f774:	df 93       	push	r29
    f776:	00 d0       	rcall	.+0      	; 0xf778 <_ZN6String11toUpperCaseEv+0x6>
    f778:	00 d0       	rcall	.+0      	; 0xf77a <_ZN6String11toUpperCaseEv+0x8>
    f77a:	cd b7       	in	r28, 0x3d	; 61
    f77c:	de b7       	in	r29, 0x3e	; 62
    f77e:	9c 83       	std	Y+4, r25	; 0x04
    f780:	8b 83       	std	Y+3, r24	; 0x03
	if (!buffer) return;
    f782:	8b 81       	ldd	r24, Y+3	; 0x03
    f784:	9c 81       	ldd	r25, Y+4	; 0x04
    f786:	fc 01       	movw	r30, r24
    f788:	80 81       	ld	r24, Z
    f78a:	91 81       	ldd	r25, Z+1	; 0x01
    f78c:	00 97       	sbiw	r24, 0x00	; 0
    f78e:	29 f1       	breq	.+74     	; 0xf7da <_ZN6String11toUpperCaseEv+0x68>
	for (char *p = buffer; *p; p++) {
    f790:	8b 81       	ldd	r24, Y+3	; 0x03
    f792:	9c 81       	ldd	r25, Y+4	; 0x04
    f794:	fc 01       	movw	r30, r24
    f796:	80 81       	ld	r24, Z
    f798:	91 81       	ldd	r25, Z+1	; 0x01
    f79a:	9a 83       	std	Y+2, r25	; 0x02
    f79c:	89 83       	std	Y+1, r24	; 0x01
    f79e:	12 c0       	rjmp	.+36     	; 0xf7c4 <_ZN6String11toUpperCaseEv+0x52>
		*p = toupper(*p);
    f7a0:	89 81       	ldd	r24, Y+1	; 0x01
    f7a2:	9a 81       	ldd	r25, Y+2	; 0x02
    f7a4:	fc 01       	movw	r30, r24
    f7a6:	80 81       	ld	r24, Z
    f7a8:	88 2f       	mov	r24, r24
    f7aa:	90 e0       	ldi	r25, 0x00	; 0
    f7ac:	0e 94 e9 b0 	call	0x161d2	; 0x161d2 <toupper>
    f7b0:	28 2f       	mov	r18, r24
    f7b2:	89 81       	ldd	r24, Y+1	; 0x01
    f7b4:	9a 81       	ldd	r25, Y+2	; 0x02
    f7b6:	fc 01       	movw	r30, r24
    f7b8:	20 83       	st	Z, r18
}

void String::toUpperCase(void)
{
	if (!buffer) return;
	for (char *p = buffer; *p; p++) {
    f7ba:	89 81       	ldd	r24, Y+1	; 0x01
    f7bc:	9a 81       	ldd	r25, Y+2	; 0x02
    f7be:	01 96       	adiw	r24, 0x01	; 1
    f7c0:	9a 83       	std	Y+2, r25	; 0x02
    f7c2:	89 83       	std	Y+1, r24	; 0x01
    f7c4:	89 81       	ldd	r24, Y+1	; 0x01
    f7c6:	9a 81       	ldd	r25, Y+2	; 0x02
    f7c8:	fc 01       	movw	r30, r24
    f7ca:	90 81       	ld	r25, Z
    f7cc:	81 e0       	ldi	r24, 0x01	; 1
    f7ce:	99 23       	and	r25, r25
    f7d0:	09 f4       	brne	.+2      	; 0xf7d4 <_ZN6String11toUpperCaseEv+0x62>
    f7d2:	80 e0       	ldi	r24, 0x00	; 0
    f7d4:	88 23       	and	r24, r24
    f7d6:	21 f7       	brne	.-56     	; 0xf7a0 <_ZN6String11toUpperCaseEv+0x2e>
    f7d8:	01 c0       	rjmp	.+2      	; 0xf7dc <_ZN6String11toUpperCaseEv+0x6a>
	}
}

void String::toUpperCase(void)
{
	if (!buffer) return;
    f7da:	00 00       	nop
	for (char *p = buffer; *p; p++) {
		*p = toupper(*p);
	}
}
    f7dc:	0f 90       	pop	r0
    f7de:	0f 90       	pop	r0
    f7e0:	0f 90       	pop	r0
    f7e2:	0f 90       	pop	r0
    f7e4:	df 91       	pop	r29
    f7e6:	cf 91       	pop	r28
    f7e8:	08 95       	ret

0000f7ea <_ZN6String4trimEv>:

void String::trim(void)
{
    f7ea:	cf 93       	push	r28
    f7ec:	df 93       	push	r29
    f7ee:	00 d0       	rcall	.+0      	; 0xf7f0 <_ZN6String4trimEv+0x6>
    f7f0:	00 d0       	rcall	.+0      	; 0xf7f2 <_ZN6String4trimEv+0x8>
    f7f2:	00 d0       	rcall	.+0      	; 0xf7f4 <_ZN6String4trimEv+0xa>
    f7f4:	cd b7       	in	r28, 0x3d	; 61
    f7f6:	de b7       	in	r29, 0x3e	; 62
    f7f8:	9e 83       	std	Y+6, r25	; 0x06
    f7fa:	8d 83       	std	Y+5, r24	; 0x05
	if (!buffer || len == 0) return;
    f7fc:	8d 81       	ldd	r24, Y+5	; 0x05
    f7fe:	9e 81       	ldd	r25, Y+6	; 0x06
    f800:	fc 01       	movw	r30, r24
    f802:	80 81       	ld	r24, Z
    f804:	91 81       	ldd	r25, Z+1	; 0x01
    f806:	00 97       	sbiw	r24, 0x00	; 0
    f808:	09 f4       	brne	.+2      	; 0xf80c <_ZN6String4trimEv+0x22>
    f80a:	86 c0       	rjmp	.+268    	; 0xf918 <_ZN6String4trimEv+0x12e>
    f80c:	8d 81       	ldd	r24, Y+5	; 0x05
    f80e:	9e 81       	ldd	r25, Y+6	; 0x06
    f810:	fc 01       	movw	r30, r24
    f812:	84 81       	ldd	r24, Z+4	; 0x04
    f814:	95 81       	ldd	r25, Z+5	; 0x05
    f816:	00 97       	sbiw	r24, 0x00	; 0
    f818:	09 f4       	brne	.+2      	; 0xf81c <_ZN6String4trimEv+0x32>
    f81a:	7e c0       	rjmp	.+252    	; 0xf918 <_ZN6String4trimEv+0x12e>
	char *begin = buffer;
    f81c:	8d 81       	ldd	r24, Y+5	; 0x05
    f81e:	9e 81       	ldd	r25, Y+6	; 0x06
    f820:	fc 01       	movw	r30, r24
    f822:	80 81       	ld	r24, Z
    f824:	91 81       	ldd	r25, Z+1	; 0x01
    f826:	9a 83       	std	Y+2, r25	; 0x02
    f828:	89 83       	std	Y+1, r24	; 0x01
	while (isspace(*begin)) begin++;
    f82a:	05 c0       	rjmp	.+10     	; 0xf836 <_ZN6String4trimEv+0x4c>
    f82c:	89 81       	ldd	r24, Y+1	; 0x01
    f82e:	9a 81       	ldd	r25, Y+2	; 0x02
    f830:	01 96       	adiw	r24, 0x01	; 1
    f832:	9a 83       	std	Y+2, r25	; 0x02
    f834:	89 83       	std	Y+1, r24	; 0x01
    f836:	89 81       	ldd	r24, Y+1	; 0x01
    f838:	9a 81       	ldd	r25, Y+2	; 0x02
    f83a:	fc 01       	movw	r30, r24
    f83c:	80 81       	ld	r24, Z
    f83e:	88 2f       	mov	r24, r24
    f840:	90 e0       	ldi	r25, 0x00	; 0
    f842:	0e 94 d9 b0 	call	0x161b2	; 0x161b2 <isspace>
    f846:	21 e0       	ldi	r18, 0x01	; 1
    f848:	00 97       	sbiw	r24, 0x00	; 0
    f84a:	09 f4       	brne	.+2      	; 0xf84e <_ZN6String4trimEv+0x64>
    f84c:	20 e0       	ldi	r18, 0x00	; 0
    f84e:	22 23       	and	r18, r18
    f850:	69 f7       	brne	.-38     	; 0xf82c <_ZN6String4trimEv+0x42>
	char *end = buffer + len - 1;
    f852:	8d 81       	ldd	r24, Y+5	; 0x05
    f854:	9e 81       	ldd	r25, Y+6	; 0x06
    f856:	fc 01       	movw	r30, r24
    f858:	20 81       	ld	r18, Z
    f85a:	31 81       	ldd	r19, Z+1	; 0x01
    f85c:	8d 81       	ldd	r24, Y+5	; 0x05
    f85e:	9e 81       	ldd	r25, Y+6	; 0x06
    f860:	fc 01       	movw	r30, r24
    f862:	84 81       	ldd	r24, Z+4	; 0x04
    f864:	95 81       	ldd	r25, Z+5	; 0x05
    f866:	01 97       	sbiw	r24, 0x01	; 1
    f868:	82 0f       	add	r24, r18
    f86a:	93 1f       	adc	r25, r19
    f86c:	9c 83       	std	Y+4, r25	; 0x04
    f86e:	8b 83       	std	Y+3, r24	; 0x03
	while (isspace(*end) && end >= begin) end--;
    f870:	05 c0       	rjmp	.+10     	; 0xf87c <_ZN6String4trimEv+0x92>
    f872:	8b 81       	ldd	r24, Y+3	; 0x03
    f874:	9c 81       	ldd	r25, Y+4	; 0x04
    f876:	01 97       	sbiw	r24, 0x01	; 1
    f878:	9c 83       	std	Y+4, r25	; 0x04
    f87a:	8b 83       	std	Y+3, r24	; 0x03
    f87c:	8b 81       	ldd	r24, Y+3	; 0x03
    f87e:	9c 81       	ldd	r25, Y+4	; 0x04
    f880:	fc 01       	movw	r30, r24
    f882:	80 81       	ld	r24, Z
    f884:	88 2f       	mov	r24, r24
    f886:	90 e0       	ldi	r25, 0x00	; 0
    f888:	0e 94 d9 b0 	call	0x161b2	; 0x161b2 <isspace>
    f88c:	00 97       	sbiw	r24, 0x00	; 0
    f88e:	49 f0       	breq	.+18     	; 0xf8a2 <_ZN6String4trimEv+0xb8>
    f890:	2b 81       	ldd	r18, Y+3	; 0x03
    f892:	3c 81       	ldd	r19, Y+4	; 0x04
    f894:	89 81       	ldd	r24, Y+1	; 0x01
    f896:	9a 81       	ldd	r25, Y+2	; 0x02
    f898:	28 17       	cp	r18, r24
    f89a:	39 07       	cpc	r19, r25
    f89c:	10 f0       	brcs	.+4      	; 0xf8a2 <_ZN6String4trimEv+0xb8>
    f89e:	81 e0       	ldi	r24, 0x01	; 1
    f8a0:	01 c0       	rjmp	.+2      	; 0xf8a4 <_ZN6String4trimEv+0xba>
    f8a2:	80 e0       	ldi	r24, 0x00	; 0
    f8a4:	88 23       	and	r24, r24
    f8a6:	29 f7       	brne	.-54     	; 0xf872 <_ZN6String4trimEv+0x88>
	len = end + 1 - begin;
    f8a8:	8b 81       	ldd	r24, Y+3	; 0x03
    f8aa:	9c 81       	ldd	r25, Y+4	; 0x04
    f8ac:	01 96       	adiw	r24, 0x01	; 1
    f8ae:	9c 01       	movw	r18, r24
    f8b0:	89 81       	ldd	r24, Y+1	; 0x01
    f8b2:	9a 81       	ldd	r25, Y+2	; 0x02
    f8b4:	a9 01       	movw	r20, r18
    f8b6:	48 1b       	sub	r20, r24
    f8b8:	59 0b       	sbc	r21, r25
    f8ba:	ca 01       	movw	r24, r20
    f8bc:	9c 01       	movw	r18, r24
    f8be:	8d 81       	ldd	r24, Y+5	; 0x05
    f8c0:	9e 81       	ldd	r25, Y+6	; 0x06
    f8c2:	fc 01       	movw	r30, r24
    f8c4:	35 83       	std	Z+5, r19	; 0x05
    f8c6:	24 83       	std	Z+4, r18	; 0x04
	if (begin > buffer) memcpy(buffer, begin, len);
    f8c8:	8d 81       	ldd	r24, Y+5	; 0x05
    f8ca:	9e 81       	ldd	r25, Y+6	; 0x06
    f8cc:	fc 01       	movw	r30, r24
    f8ce:	20 81       	ld	r18, Z
    f8d0:	31 81       	ldd	r19, Z+1	; 0x01
    f8d2:	89 81       	ldd	r24, Y+1	; 0x01
    f8d4:	9a 81       	ldd	r25, Y+2	; 0x02
    f8d6:	28 17       	cp	r18, r24
    f8d8:	39 07       	cpc	r19, r25
    f8da:	78 f4       	brcc	.+30     	; 0xf8fa <_ZN6String4trimEv+0x110>
    f8dc:	8d 81       	ldd	r24, Y+5	; 0x05
    f8de:	9e 81       	ldd	r25, Y+6	; 0x06
    f8e0:	fc 01       	movw	r30, r24
    f8e2:	44 81       	ldd	r20, Z+4	; 0x04
    f8e4:	55 81       	ldd	r21, Z+5	; 0x05
    f8e6:	8d 81       	ldd	r24, Y+5	; 0x05
    f8e8:	9e 81       	ldd	r25, Y+6	; 0x06
    f8ea:	fc 01       	movw	r30, r24
    f8ec:	80 81       	ld	r24, Z
    f8ee:	91 81       	ldd	r25, Z+1	; 0x01
    f8f0:	29 81       	ldd	r18, Y+1	; 0x01
    f8f2:	3a 81       	ldd	r19, Y+2	; 0x02
    f8f4:	b9 01       	movw	r22, r18
    f8f6:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
	buffer[len] = 0;
    f8fa:	8d 81       	ldd	r24, Y+5	; 0x05
    f8fc:	9e 81       	ldd	r25, Y+6	; 0x06
    f8fe:	fc 01       	movw	r30, r24
    f900:	20 81       	ld	r18, Z
    f902:	31 81       	ldd	r19, Z+1	; 0x01
    f904:	8d 81       	ldd	r24, Y+5	; 0x05
    f906:	9e 81       	ldd	r25, Y+6	; 0x06
    f908:	fc 01       	movw	r30, r24
    f90a:	84 81       	ldd	r24, Z+4	; 0x04
    f90c:	95 81       	ldd	r25, Z+5	; 0x05
    f90e:	82 0f       	add	r24, r18
    f910:	93 1f       	adc	r25, r19
    f912:	fc 01       	movw	r30, r24
    f914:	10 82       	st	Z, r1
    f916:	01 c0       	rjmp	.+2      	; 0xf91a <_ZN6String4trimEv+0x130>
	}
}

void String::trim(void)
{
	if (!buffer || len == 0) return;
    f918:	00 00       	nop
	char *end = buffer + len - 1;
	while (isspace(*end) && end >= begin) end--;
	len = end + 1 - begin;
	if (begin > buffer) memcpy(buffer, begin, len);
	buffer[len] = 0;
}
    f91a:	26 96       	adiw	r28, 0x06	; 6
    f91c:	0f b6       	in	r0, 0x3f	; 63
    f91e:	f8 94       	cli
    f920:	de bf       	out	0x3e, r29	; 62
    f922:	0f be       	out	0x3f, r0	; 63
    f924:	cd bf       	out	0x3d, r28	; 61
    f926:	df 91       	pop	r29
    f928:	cf 91       	pop	r28
    f92a:	08 95       	ret

0000f92c <_ZNK6String5toIntEv>:
/*********************************************/
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
    f92c:	cf 93       	push	r28
    f92e:	df 93       	push	r29
    f930:	00 d0       	rcall	.+0      	; 0xf932 <_ZNK6String5toIntEv+0x6>
    f932:	cd b7       	in	r28, 0x3d	; 61
    f934:	de b7       	in	r29, 0x3e	; 62
    f936:	9a 83       	std	Y+2, r25	; 0x02
    f938:	89 83       	std	Y+1, r24	; 0x01
	if (buffer) return atol(buffer);
    f93a:	89 81       	ldd	r24, Y+1	; 0x01
    f93c:	9a 81       	ldd	r25, Y+2	; 0x02
    f93e:	fc 01       	movw	r30, r24
    f940:	80 81       	ld	r24, Z
    f942:	91 81       	ldd	r25, Z+1	; 0x01
    f944:	00 97       	sbiw	r24, 0x00	; 0
    f946:	51 f0       	breq	.+20     	; 0xf95c <_ZNK6String5toIntEv+0x30>
    f948:	89 81       	ldd	r24, Y+1	; 0x01
    f94a:	9a 81       	ldd	r25, Y+2	; 0x02
    f94c:	fc 01       	movw	r30, r24
    f94e:	80 81       	ld	r24, Z
    f950:	91 81       	ldd	r25, Z+1	; 0x01
    f952:	0e 94 b2 b0 	call	0x16164	; 0x16164 <atol>
    f956:	dc 01       	movw	r26, r24
    f958:	cb 01       	movw	r24, r22
    f95a:	03 c0       	rjmp	.+6      	; 0xf962 <_ZNK6String5toIntEv+0x36>
	return 0;
    f95c:	80 e0       	ldi	r24, 0x00	; 0
    f95e:	90 e0       	ldi	r25, 0x00	; 0
    f960:	dc 01       	movw	r26, r24
}
    f962:	bc 01       	movw	r22, r24
    f964:	cd 01       	movw	r24, r26
    f966:	0f 90       	pop	r0
    f968:	0f 90       	pop	r0
    f96a:	df 91       	pop	r29
    f96c:	cf 91       	pop	r28
    f96e:	08 95       	ret

0000f970 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    f970:	cf 93       	push	r28
    f972:	df 93       	push	r29
    f974:	cd b7       	in	r28, 0x3d	; 61
    f976:	de b7       	in	r29, 0x3e	; 62
	// Empty
}
    f978:	df 91       	pop	r29
    f97a:	cf 91       	pop	r28
    f97c:	08 95       	ret

0000f97e <main>:
#include <Arduino.h>

int main(void)
{
    f97e:	cf 93       	push	r28
    f980:	df 93       	push	r29
    f982:	cd b7       	in	r28, 0x3d	; 61
    f984:	de b7       	in	r29, 0x3e	; 62
	init();
    f986:	0e 94 b8 7e 	call	0xfd70	; 0xfd70 <init>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    f98a:	0e 94 f1 9d 	call	0x13be2	; 0x13be2 <setup>
    f98e:	01 c0       	rjmp	.+2      	; 0xf992 <main+0x14>
    
	for (;;) {
    f990:	00 00       	nop
		loop();
    f992:	0e 94 3e 9e 	call	0x13c7c	; 0x13c7c <loop>
		if (serialEventRun) serialEventRun();
    f996:	85 ed       	ldi	r24, 0xD5	; 213
    f998:	93 e5       	ldi	r25, 0x53	; 83
    f99a:	00 97       	sbiw	r24, 0x00	; 0
    f99c:	c9 f3       	breq	.-14     	; 0xf990 <main+0x12>
    f99e:	0e 94 d5 53 	call	0xa7aa	; 0xa7aa <_Z14serialEventRunv>
	USBDevice.attach();
#endif
	
	setup();
    
	for (;;) {
    f9a2:	f6 cf       	rjmp	.-20     	; 0xf990 <main+0x12>

0000f9a4 <_Znwj>:
#include <new.h>

void * operator new(size_t size)
{
    f9a4:	cf 93       	push	r28
    f9a6:	df 93       	push	r29
    f9a8:	00 d0       	rcall	.+0      	; 0xf9aa <_Znwj+0x6>
    f9aa:	cd b7       	in	r28, 0x3d	; 61
    f9ac:	de b7       	in	r29, 0x3e	; 62
    f9ae:	9a 83       	std	Y+2, r25	; 0x02
    f9b0:	89 83       	std	Y+1, r24	; 0x01
  return malloc(size);
    f9b2:	89 81       	ldd	r24, Y+1	; 0x01
    f9b4:	9a 81       	ldd	r25, Y+2	; 0x02
    f9b6:	0e 94 5a ae 	call	0x15cb4	; 0x15cb4 <malloc>
}
    f9ba:	0f 90       	pop	r0
    f9bc:	0f 90       	pop	r0
    f9be:	df 91       	pop	r29
    f9c0:	cf 91       	pop	r28
    f9c2:	08 95       	ret

0000f9c4 <_Znaj>:

void * operator new[](size_t size)
{
    f9c4:	cf 93       	push	r28
    f9c6:	df 93       	push	r29
    f9c8:	00 d0       	rcall	.+0      	; 0xf9ca <_Znaj+0x6>
    f9ca:	cd b7       	in	r28, 0x3d	; 61
    f9cc:	de b7       	in	r29, 0x3e	; 62
    f9ce:	9a 83       	std	Y+2, r25	; 0x02
    f9d0:	89 83       	std	Y+1, r24	; 0x01
  return malloc(size);
    f9d2:	89 81       	ldd	r24, Y+1	; 0x01
    f9d4:	9a 81       	ldd	r25, Y+2	; 0x02
    f9d6:	0e 94 5a ae 	call	0x15cb4	; 0x15cb4 <malloc>
}
    f9da:	0f 90       	pop	r0
    f9dc:	0f 90       	pop	r0
    f9de:	df 91       	pop	r29
    f9e0:	cf 91       	pop	r28
    f9e2:	08 95       	ret

0000f9e4 <_ZdlPv>:

void operator delete(void * ptr)
{
    f9e4:	cf 93       	push	r28
    f9e6:	df 93       	push	r29
    f9e8:	00 d0       	rcall	.+0      	; 0xf9ea <_ZdlPv+0x6>
    f9ea:	cd b7       	in	r28, 0x3d	; 61
    f9ec:	de b7       	in	r29, 0x3e	; 62
    f9ee:	9a 83       	std	Y+2, r25	; 0x02
    f9f0:	89 83       	std	Y+1, r24	; 0x01
  free(ptr);
    f9f2:	89 81       	ldd	r24, Y+1	; 0x01
    f9f4:	9a 81       	ldd	r25, Y+2	; 0x02
    f9f6:	0e 94 f0 ae 	call	0x15de0	; 0x15de0 <free>
}
    f9fa:	0f 90       	pop	r0
    f9fc:	0f 90       	pop	r0
    f9fe:	df 91       	pop	r29
    fa00:	cf 91       	pop	r28
    fa02:	08 95       	ret

0000fa04 <_ZdaPv>:

void operator delete[](void * ptr)
{
    fa04:	cf 93       	push	r28
    fa06:	df 93       	push	r29
    fa08:	00 d0       	rcall	.+0      	; 0xfa0a <_ZdaPv+0x6>
    fa0a:	cd b7       	in	r28, 0x3d	; 61
    fa0c:	de b7       	in	r29, 0x3e	; 62
    fa0e:	9a 83       	std	Y+2, r25	; 0x02
    fa10:	89 83       	std	Y+1, r24	; 0x01
  free(ptr);
    fa12:	89 81       	ldd	r24, Y+1	; 0x01
    fa14:	9a 81       	ldd	r25, Y+2	; 0x02
    fa16:	0e 94 f0 ae 	call	0x15de0	; 0x15de0 <free>
}
    fa1a:	0f 90       	pop	r0
    fa1c:	0f 90       	pop	r0
    fa1e:	df 91       	pop	r29
    fa20:	cf 91       	pop	r28
    fa22:	08 95       	ret

0000fa24 <__cxa_guard_acquire>:

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
    fa24:	cf 93       	push	r28
    fa26:	df 93       	push	r29
    fa28:	00 d0       	rcall	.+0      	; 0xfa2a <__cxa_guard_acquire+0x6>
    fa2a:	cd b7       	in	r28, 0x3d	; 61
    fa2c:	de b7       	in	r29, 0x3e	; 62
    fa2e:	9a 83       	std	Y+2, r25	; 0x02
    fa30:	89 83       	std	Y+1, r24	; 0x01
    fa32:	89 81       	ldd	r24, Y+1	; 0x01
    fa34:	9a 81       	ldd	r25, Y+2	; 0x02
    fa36:	fc 01       	movw	r30, r24
    fa38:	90 81       	ld	r25, Z
    fa3a:	81 e0       	ldi	r24, 0x01	; 1
    fa3c:	99 23       	and	r25, r25
    fa3e:	09 f0       	breq	.+2      	; 0xfa42 <__cxa_guard_acquire+0x1e>
    fa40:	80 e0       	ldi	r24, 0x00	; 0
    fa42:	88 2f       	mov	r24, r24
    fa44:	90 e0       	ldi	r25, 0x00	; 0
    fa46:	0f 90       	pop	r0
    fa48:	0f 90       	pop	r0
    fa4a:	df 91       	pop	r29
    fa4c:	cf 91       	pop	r28
    fa4e:	08 95       	ret

0000fa50 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
    fa50:	cf 93       	push	r28
    fa52:	df 93       	push	r29
    fa54:	00 d0       	rcall	.+0      	; 0xfa56 <__cxa_guard_release+0x6>
    fa56:	cd b7       	in	r28, 0x3d	; 61
    fa58:	de b7       	in	r29, 0x3e	; 62
    fa5a:	9a 83       	std	Y+2, r25	; 0x02
    fa5c:	89 83       	std	Y+1, r24	; 0x01
    fa5e:	89 81       	ldd	r24, Y+1	; 0x01
    fa60:	9a 81       	ldd	r25, Y+2	; 0x02
    fa62:	21 e0       	ldi	r18, 0x01	; 1
    fa64:	fc 01       	movw	r30, r24
    fa66:	20 83       	st	Z, r18
    fa68:	0f 90       	pop	r0
    fa6a:	0f 90       	pop	r0
    fa6c:	df 91       	pop	r29
    fa6e:	cf 91       	pop	r28
    fa70:	08 95       	ret

0000fa72 <__cxa_guard_abort>:
void __cxa_guard_abort (__guard *) {}; 
    fa72:	cf 93       	push	r28
    fa74:	df 93       	push	r29
    fa76:	00 d0       	rcall	.+0      	; 0xfa78 <__cxa_guard_abort+0x6>
    fa78:	cd b7       	in	r28, 0x3d	; 61
    fa7a:	de b7       	in	r29, 0x3e	; 62
    fa7c:	9a 83       	std	Y+2, r25	; 0x02
    fa7e:	89 83       	std	Y+1, r24	; 0x01
    fa80:	0f 90       	pop	r0
    fa82:	0f 90       	pop	r0
    fa84:	df 91       	pop	r29
    fa86:	cf 91       	pop	r28
    fa88:	08 95       	ret

0000fa8a <__cxa_pure_virtual>:

void __cxa_pure_virtual(void) {};
    fa8a:	cf 93       	push	r28
    fa8c:	df 93       	push	r29
    fa8e:	cd b7       	in	r28, 0x3d	; 61
    fa90:	de b7       	in	r29, 0x3e	; 62
    fa92:	df 91       	pop	r29
    fa94:	cf 91       	pop	r28
    fa96:	08 95       	ret

0000fa98 <__vector_16>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
SIGNAL(TIM0_OVF_vect)
#else
SIGNAL(TIMER0_OVF_vect)
#endif
{
    fa98:	1f 92       	push	r1
    fa9a:	0f 92       	push	r0
    fa9c:	00 90 5f 00 	lds	r0, 0x005F
    faa0:	0f 92       	push	r0
    faa2:	11 24       	eor	r1, r1
    faa4:	8f 93       	push	r24
    faa6:	9f 93       	push	r25
    faa8:	af 93       	push	r26
    faaa:	bf 93       	push	r27
    faac:	cf 93       	push	r28
    faae:	df 93       	push	r29
    fab0:	cd b7       	in	r28, 0x3d	; 61
    fab2:	de b7       	in	r29, 0x3e	; 62
    fab4:	25 97       	sbiw	r28, 0x05	; 5
    fab6:	de bf       	out	0x3e, r29	; 62
    fab8:	cd bf       	out	0x3d, r28	; 61
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
    faba:	80 91 0d 09 	lds	r24, 0x090D
    fabe:	90 91 0e 09 	lds	r25, 0x090E
    fac2:	a0 91 0f 09 	lds	r26, 0x090F
    fac6:	b0 91 10 09 	lds	r27, 0x0910
    faca:	89 83       	std	Y+1, r24	; 0x01
    facc:	9a 83       	std	Y+2, r25	; 0x02
    face:	ab 83       	std	Y+3, r26	; 0x03
    fad0:	bc 83       	std	Y+4, r27	; 0x04
	unsigned char f = timer0_fract;
    fad2:	80 91 11 09 	lds	r24, 0x0911
    fad6:	8d 83       	std	Y+5, r24	; 0x05

	m += MILLIS_INC;
    fad8:	89 81       	ldd	r24, Y+1	; 0x01
    fada:	9a 81       	ldd	r25, Y+2	; 0x02
    fadc:	ab 81       	ldd	r26, Y+3	; 0x03
    fade:	bc 81       	ldd	r27, Y+4	; 0x04
    fae0:	01 96       	adiw	r24, 0x01	; 1
    fae2:	a1 1d       	adc	r26, r1
    fae4:	b1 1d       	adc	r27, r1
    fae6:	89 83       	std	Y+1, r24	; 0x01
    fae8:	9a 83       	std	Y+2, r25	; 0x02
    faea:	ab 83       	std	Y+3, r26	; 0x03
    faec:	bc 83       	std	Y+4, r27	; 0x04
	f += FRACT_INC;
    faee:	8d 81       	ldd	r24, Y+5	; 0x05
    faf0:	8d 5f       	subi	r24, 0xFD	; 253
    faf2:	8d 83       	std	Y+5, r24	; 0x05
	if (f >= FRACT_MAX) {
    faf4:	8d 81       	ldd	r24, Y+5	; 0x05
    faf6:	8d 37       	cpi	r24, 0x7D	; 125
    faf8:	70 f0       	brcs	.+28     	; 0xfb16 <__vector_16+0x7e>
		f -= FRACT_MAX;
    fafa:	8d 81       	ldd	r24, Y+5	; 0x05
    fafc:	8d 57       	subi	r24, 0x7D	; 125
    fafe:	8d 83       	std	Y+5, r24	; 0x05
		m += 1;
    fb00:	89 81       	ldd	r24, Y+1	; 0x01
    fb02:	9a 81       	ldd	r25, Y+2	; 0x02
    fb04:	ab 81       	ldd	r26, Y+3	; 0x03
    fb06:	bc 81       	ldd	r27, Y+4	; 0x04
    fb08:	01 96       	adiw	r24, 0x01	; 1
    fb0a:	a1 1d       	adc	r26, r1
    fb0c:	b1 1d       	adc	r27, r1
    fb0e:	89 83       	std	Y+1, r24	; 0x01
    fb10:	9a 83       	std	Y+2, r25	; 0x02
    fb12:	ab 83       	std	Y+3, r26	; 0x03
    fb14:	bc 83       	std	Y+4, r27	; 0x04
	}

	timer0_fract = f;
    fb16:	8d 81       	ldd	r24, Y+5	; 0x05
    fb18:	80 93 11 09 	sts	0x0911, r24
	timer0_millis = m;
    fb1c:	89 81       	ldd	r24, Y+1	; 0x01
    fb1e:	9a 81       	ldd	r25, Y+2	; 0x02
    fb20:	ab 81       	ldd	r26, Y+3	; 0x03
    fb22:	bc 81       	ldd	r27, Y+4	; 0x04
    fb24:	80 93 0d 09 	sts	0x090D, r24
    fb28:	90 93 0e 09 	sts	0x090E, r25
    fb2c:	a0 93 0f 09 	sts	0x090F, r26
    fb30:	b0 93 10 09 	sts	0x0910, r27
	timer0_overflow_count++;
    fb34:	80 91 09 09 	lds	r24, 0x0909
    fb38:	90 91 0a 09 	lds	r25, 0x090A
    fb3c:	a0 91 0b 09 	lds	r26, 0x090B
    fb40:	b0 91 0c 09 	lds	r27, 0x090C
    fb44:	01 96       	adiw	r24, 0x01	; 1
    fb46:	a1 1d       	adc	r26, r1
    fb48:	b1 1d       	adc	r27, r1
    fb4a:	80 93 09 09 	sts	0x0909, r24
    fb4e:	90 93 0a 09 	sts	0x090A, r25
    fb52:	a0 93 0b 09 	sts	0x090B, r26
    fb56:	b0 93 0c 09 	sts	0x090C, r27
}
    fb5a:	0f 90       	pop	r0
    fb5c:	0f 90       	pop	r0
    fb5e:	0f 90       	pop	r0
    fb60:	0f 90       	pop	r0
    fb62:	0f 90       	pop	r0
    fb64:	df 91       	pop	r29
    fb66:	cf 91       	pop	r28
    fb68:	bf 91       	pop	r27
    fb6a:	af 91       	pop	r26
    fb6c:	9f 91       	pop	r25
    fb6e:	8f 91       	pop	r24
    fb70:	0f 90       	pop	r0
    fb72:	00 92 5f 00 	sts	0x005F, r0
    fb76:	0f 90       	pop	r0
    fb78:	1f 90       	pop	r1
    fb7a:	18 95       	reti

0000fb7c <millis>:

unsigned long millis()
{
    fb7c:	cf 93       	push	r28
    fb7e:	df 93       	push	r29
    fb80:	00 d0       	rcall	.+0      	; 0xfb82 <millis+0x6>
    fb82:	00 d0       	rcall	.+0      	; 0xfb84 <millis+0x8>
    fb84:	1f 92       	push	r1
    fb86:	cd b7       	in	r28, 0x3d	; 61
    fb88:	de b7       	in	r29, 0x3e	; 62
	unsigned long m;
	uint8_t oldSREG = SREG;
    fb8a:	8f e5       	ldi	r24, 0x5F	; 95
    fb8c:	90 e0       	ldi	r25, 0x00	; 0
    fb8e:	fc 01       	movw	r30, r24
    fb90:	80 81       	ld	r24, Z
    fb92:	89 83       	std	Y+1, r24	; 0x01

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
    fb94:	f8 94       	cli
	m = timer0_millis;
    fb96:	80 91 0d 09 	lds	r24, 0x090D
    fb9a:	90 91 0e 09 	lds	r25, 0x090E
    fb9e:	a0 91 0f 09 	lds	r26, 0x090F
    fba2:	b0 91 10 09 	lds	r27, 0x0910
    fba6:	8a 83       	std	Y+2, r24	; 0x02
    fba8:	9b 83       	std	Y+3, r25	; 0x03
    fbaa:	ac 83       	std	Y+4, r26	; 0x04
    fbac:	bd 83       	std	Y+5, r27	; 0x05
	SREG = oldSREG;
    fbae:	8f e5       	ldi	r24, 0x5F	; 95
    fbb0:	90 e0       	ldi	r25, 0x00	; 0
    fbb2:	29 81       	ldd	r18, Y+1	; 0x01
    fbb4:	fc 01       	movw	r30, r24
    fbb6:	20 83       	st	Z, r18

	return m;
    fbb8:	8a 81       	ldd	r24, Y+2	; 0x02
    fbba:	9b 81       	ldd	r25, Y+3	; 0x03
    fbbc:	ac 81       	ldd	r26, Y+4	; 0x04
    fbbe:	bd 81       	ldd	r27, Y+5	; 0x05
}
    fbc0:	bc 01       	movw	r22, r24
    fbc2:	cd 01       	movw	r24, r26
    fbc4:	0f 90       	pop	r0
    fbc6:	0f 90       	pop	r0
    fbc8:	0f 90       	pop	r0
    fbca:	0f 90       	pop	r0
    fbcc:	0f 90       	pop	r0
    fbce:	df 91       	pop	r29
    fbd0:	cf 91       	pop	r28
    fbd2:	08 95       	ret

0000fbd4 <micros>:

unsigned long micros() {
    fbd4:	cf 93       	push	r28
    fbd6:	df 93       	push	r29
    fbd8:	00 d0       	rcall	.+0      	; 0xfbda <micros+0x6>
    fbda:	00 d0       	rcall	.+0      	; 0xfbdc <micros+0x8>
    fbdc:	00 d0       	rcall	.+0      	; 0xfbde <micros+0xa>
    fbde:	cd b7       	in	r28, 0x3d	; 61
    fbe0:	de b7       	in	r29, 0x3e	; 62
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    fbe2:	8f e5       	ldi	r24, 0x5F	; 95
    fbe4:	90 e0       	ldi	r25, 0x00	; 0
    fbe6:	fc 01       	movw	r30, r24
    fbe8:	80 81       	ld	r24, Z
    fbea:	8d 83       	std	Y+5, r24	; 0x05
	
	cli();
    fbec:	f8 94       	cli
	m = timer0_overflow_count;
    fbee:	80 91 09 09 	lds	r24, 0x0909
    fbf2:	90 91 0a 09 	lds	r25, 0x090A
    fbf6:	a0 91 0b 09 	lds	r26, 0x090B
    fbfa:	b0 91 0c 09 	lds	r27, 0x090C
    fbfe:	89 83       	std	Y+1, r24	; 0x01
    fc00:	9a 83       	std	Y+2, r25	; 0x02
    fc02:	ab 83       	std	Y+3, r26	; 0x03
    fc04:	bc 83       	std	Y+4, r27	; 0x04
#if defined(TCNT0)
	t = TCNT0;
    fc06:	86 e4       	ldi	r24, 0x46	; 70
    fc08:	90 e0       	ldi	r25, 0x00	; 0
    fc0a:	fc 01       	movw	r30, r24
    fc0c:	80 81       	ld	r24, Z
    fc0e:	8e 83       	std	Y+6, r24	; 0x06
	#error TIMER 0 not defined
#endif

  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    fc10:	85 e3       	ldi	r24, 0x35	; 53
    fc12:	90 e0       	ldi	r25, 0x00	; 0
    fc14:	fc 01       	movw	r30, r24
    fc16:	80 81       	ld	r24, Z
    fc18:	88 2f       	mov	r24, r24
    fc1a:	90 e0       	ldi	r25, 0x00	; 0
    fc1c:	81 70       	andi	r24, 0x01	; 1
    fc1e:	99 27       	eor	r25, r25
    fc20:	00 97       	sbiw	r24, 0x00	; 0
    fc22:	71 f0       	breq	.+28     	; 0xfc40 <micros+0x6c>
    fc24:	8e 81       	ldd	r24, Y+6	; 0x06
    fc26:	8f 3f       	cpi	r24, 0xFF	; 255
    fc28:	59 f0       	breq	.+22     	; 0xfc40 <micros+0x6c>
		m++;
    fc2a:	89 81       	ldd	r24, Y+1	; 0x01
    fc2c:	9a 81       	ldd	r25, Y+2	; 0x02
    fc2e:	ab 81       	ldd	r26, Y+3	; 0x03
    fc30:	bc 81       	ldd	r27, Y+4	; 0x04
    fc32:	01 96       	adiw	r24, 0x01	; 1
    fc34:	a1 1d       	adc	r26, r1
    fc36:	b1 1d       	adc	r27, r1
    fc38:	89 83       	std	Y+1, r24	; 0x01
    fc3a:	9a 83       	std	Y+2, r25	; 0x02
    fc3c:	ab 83       	std	Y+3, r26	; 0x03
    fc3e:	bc 83       	std	Y+4, r27	; 0x04
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    fc40:	8f e5       	ldi	r24, 0x5F	; 95
    fc42:	90 e0       	ldi	r25, 0x00	; 0
    fc44:	2d 81       	ldd	r18, Y+5	; 0x05
    fc46:	fc 01       	movw	r30, r24
    fc48:	20 83       	st	Z, r18
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    fc4a:	89 81       	ldd	r24, Y+1	; 0x01
    fc4c:	9a 81       	ldd	r25, Y+2	; 0x02
    fc4e:	ab 81       	ldd	r26, Y+3	; 0x03
    fc50:	bc 81       	ldd	r27, Y+4	; 0x04
    fc52:	22 27       	eor	r18, r18
    fc54:	38 2f       	mov	r19, r24
    fc56:	49 2f       	mov	r20, r25
    fc58:	5a 2f       	mov	r21, r26
    fc5a:	8e 81       	ldd	r24, Y+6	; 0x06
    fc5c:	88 2f       	mov	r24, r24
    fc5e:	90 e0       	ldi	r25, 0x00	; 0
    fc60:	a0 e0       	ldi	r26, 0x00	; 0
    fc62:	b0 e0       	ldi	r27, 0x00	; 0
    fc64:	82 0f       	add	r24, r18
    fc66:	93 1f       	adc	r25, r19
    fc68:	a4 1f       	adc	r26, r20
    fc6a:	b5 1f       	adc	r27, r21
    fc6c:	88 0f       	add	r24, r24
    fc6e:	99 1f       	adc	r25, r25
    fc70:	aa 1f       	adc	r26, r26
    fc72:	bb 1f       	adc	r27, r27
    fc74:	88 0f       	add	r24, r24
    fc76:	99 1f       	adc	r25, r25
    fc78:	aa 1f       	adc	r26, r26
    fc7a:	bb 1f       	adc	r27, r27
}
    fc7c:	bc 01       	movw	r22, r24
    fc7e:	cd 01       	movw	r24, r26
    fc80:	26 96       	adiw	r28, 0x06	; 6
    fc82:	0f b6       	in	r0, 0x3f	; 63
    fc84:	f8 94       	cli
    fc86:	de bf       	out	0x3e, r29	; 62
    fc88:	0f be       	out	0x3f, r0	; 63
    fc8a:	cd bf       	out	0x3d, r28	; 61
    fc8c:	df 91       	pop	r29
    fc8e:	cf 91       	pop	r28
    fc90:	08 95       	ret

0000fc92 <delay>:

void delay(unsigned long ms)
{
    fc92:	cf 93       	push	r28
    fc94:	df 93       	push	r29
    fc96:	00 d0       	rcall	.+0      	; 0xfc98 <delay+0x6>
    fc98:	00 d0       	rcall	.+0      	; 0xfc9a <delay+0x8>
    fc9a:	00 d0       	rcall	.+0      	; 0xfc9c <delay+0xa>
    fc9c:	cd b7       	in	r28, 0x3d	; 61
    fc9e:	de b7       	in	r29, 0x3e	; 62
    fca0:	6b 83       	std	Y+3, r22	; 0x03
    fca2:	7c 83       	std	Y+4, r23	; 0x04
    fca4:	8d 83       	std	Y+5, r24	; 0x05
    fca6:	9e 83       	std	Y+6, r25	; 0x06
	uint16_t start = (uint16_t)micros();
    fca8:	0e 94 ea 7d 	call	0xfbd4	; 0xfbd4 <micros>
    fcac:	dc 01       	movw	r26, r24
    fcae:	cb 01       	movw	r24, r22
    fcb0:	9a 83       	std	Y+2, r25	; 0x02
    fcb2:	89 83       	std	Y+1, r24	; 0x01

	while (ms > 0) {
    fcb4:	22 c0       	rjmp	.+68     	; 0xfcfa <delay+0x68>
		yield();
    fcb6:	0e 94 b8 7c 	call	0xf970	; 0xf970 <yield>
		if (((uint16_t)micros() - start) >= 1000) {
    fcba:	0e 94 ea 7d 	call	0xfbd4	; 0xfbd4 <micros>
    fcbe:	dc 01       	movw	r26, r24
    fcc0:	cb 01       	movw	r24, r22
    fcc2:	9c 01       	movw	r18, r24
    fcc4:	89 81       	ldd	r24, Y+1	; 0x01
    fcc6:	9a 81       	ldd	r25, Y+2	; 0x02
    fcc8:	a9 01       	movw	r20, r18
    fcca:	48 1b       	sub	r20, r24
    fccc:	59 0b       	sbc	r21, r25
    fcce:	ca 01       	movw	r24, r20
    fcd0:	88 3e       	cpi	r24, 0xE8	; 232
    fcd2:	53 e0       	ldi	r21, 0x03	; 3
    fcd4:	95 07       	cpc	r25, r21
    fcd6:	88 f0       	brcs	.+34     	; 0xfcfa <delay+0x68>
			ms--;
    fcd8:	8b 81       	ldd	r24, Y+3	; 0x03
    fcda:	9c 81       	ldd	r25, Y+4	; 0x04
    fcdc:	ad 81       	ldd	r26, Y+5	; 0x05
    fcde:	be 81       	ldd	r27, Y+6	; 0x06
    fce0:	01 97       	sbiw	r24, 0x01	; 1
    fce2:	a1 09       	sbc	r26, r1
    fce4:	b1 09       	sbc	r27, r1
    fce6:	8b 83       	std	Y+3, r24	; 0x03
    fce8:	9c 83       	std	Y+4, r25	; 0x04
    fcea:	ad 83       	std	Y+5, r26	; 0x05
    fcec:	be 83       	std	Y+6, r27	; 0x06
			start += 1000;
    fcee:	89 81       	ldd	r24, Y+1	; 0x01
    fcf0:	9a 81       	ldd	r25, Y+2	; 0x02
    fcf2:	88 51       	subi	r24, 0x18	; 24
    fcf4:	9c 4f       	sbci	r25, 0xFC	; 252
    fcf6:	9a 83       	std	Y+2, r25	; 0x02
    fcf8:	89 83       	std	Y+1, r24	; 0x01

void delay(unsigned long ms)
{
	uint16_t start = (uint16_t)micros();

	while (ms > 0) {
    fcfa:	8b 81       	ldd	r24, Y+3	; 0x03
    fcfc:	9c 81       	ldd	r25, Y+4	; 0x04
    fcfe:	ad 81       	ldd	r26, Y+5	; 0x05
    fd00:	be 81       	ldd	r27, Y+6	; 0x06
    fd02:	00 97       	sbiw	r24, 0x00	; 0
    fd04:	a1 05       	cpc	r26, r1
    fd06:	b1 05       	cpc	r27, r1
    fd08:	b1 f6       	brne	.-84     	; 0xfcb6 <delay+0x24>
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    fd0a:	26 96       	adiw	r28, 0x06	; 6
    fd0c:	0f b6       	in	r0, 0x3f	; 63
    fd0e:	f8 94       	cli
    fd10:	de bf       	out	0x3e, r29	; 62
    fd12:	0f be       	out	0x3f, r0	; 63
    fd14:	cd bf       	out	0x3d, r28	; 61
    fd16:	df 91       	pop	r29
    fd18:	cf 91       	pop	r28
    fd1a:	08 95       	ret

0000fd1c <delayMicroseconds>:

/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
void delayMicroseconds(unsigned int us)
{
    fd1c:	cf 93       	push	r28
    fd1e:	df 93       	push	r29
    fd20:	00 d0       	rcall	.+0      	; 0xfd22 <delayMicroseconds+0x6>
    fd22:	cd b7       	in	r28, 0x3d	; 61
    fd24:	de b7       	in	r29, 0x3e	; 62
    fd26:	9a 83       	std	Y+2, r25	; 0x02
    fd28:	89 83       	std	Y+1, r24	; 0x01
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call yields a delay of approximately 1 1/8 us.
	if (--us == 0)
    fd2a:	89 81       	ldd	r24, Y+1	; 0x01
    fd2c:	9a 81       	ldd	r25, Y+2	; 0x02
    fd2e:	01 97       	sbiw	r24, 0x01	; 1
    fd30:	9a 83       	std	Y+2, r25	; 0x02
    fd32:	89 83       	std	Y+1, r24	; 0x01
    fd34:	89 81       	ldd	r24, Y+1	; 0x01
    fd36:	9a 81       	ldd	r25, Y+2	; 0x02
    fd38:	00 97       	sbiw	r24, 0x00	; 0
    fd3a:	a1 f0       	breq	.+40     	; 0xfd64 <delayMicroseconds+0x48>
		return;

	// the following loop takes a quarter of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2;
    fd3c:	89 81       	ldd	r24, Y+1	; 0x01
    fd3e:	9a 81       	ldd	r25, Y+2	; 0x02
    fd40:	88 0f       	add	r24, r24
    fd42:	99 1f       	adc	r25, r25
    fd44:	88 0f       	add	r24, r24
    fd46:	99 1f       	adc	r25, r25
    fd48:	9a 83       	std	Y+2, r25	; 0x02
    fd4a:	89 83       	std	Y+1, r24	; 0x01

	// account for the time taken in the preceeding commands.
	us -= 2;
    fd4c:	89 81       	ldd	r24, Y+1	; 0x01
    fd4e:	9a 81       	ldd	r25, Y+2	; 0x02
    fd50:	02 97       	sbiw	r24, 0x02	; 2
    fd52:	9a 83       	std	Y+2, r25	; 0x02
    fd54:	89 83       	std	Y+1, r24	; 0x01
	// we can't subtract any more than this or we'd overflow w/ small delays.
	us--;
#endif

	// busy wait
	__asm__ __volatile__ (
    fd56:	89 81       	ldd	r24, Y+1	; 0x01
    fd58:	9a 81       	ldd	r25, Y+2	; 0x02
    fd5a:	01 97       	sbiw	r24, 0x01	; 1
    fd5c:	f1 f7       	brne	.-4      	; 0xfd5a <delayMicroseconds+0x3e>
    fd5e:	9a 83       	std	Y+2, r25	; 0x02
    fd60:	89 83       	std	Y+1, r24	; 0x01
    fd62:	01 c0       	rjmp	.+2      	; 0xfd66 <delayMicroseconds+0x4a>
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call yields a delay of approximately 1 1/8 us.
	if (--us == 0)
		return;
    fd64:	00 00       	nop
	// busy wait
	__asm__ __volatile__ (
		"1: sbiw %0,1" "\n\t" // 2 cycles
		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
	);
}
    fd66:	0f 90       	pop	r0
    fd68:	0f 90       	pop	r0
    fd6a:	df 91       	pop	r29
    fd6c:	cf 91       	pop	r28
    fd6e:	08 95       	ret

0000fd70 <init>:

void init()
{
    fd70:	cf 93       	push	r28
    fd72:	df 93       	push	r29
    fd74:	cd b7       	in	r28, 0x3d	; 61
    fd76:	de b7       	in	r29, 0x3e	; 62
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    fd78:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    fd7a:	84 e4       	ldi	r24, 0x44	; 68
    fd7c:	90 e0       	ldi	r25, 0x00	; 0
    fd7e:	24 e4       	ldi	r18, 0x44	; 68
    fd80:	30 e0       	ldi	r19, 0x00	; 0
    fd82:	f9 01       	movw	r30, r18
    fd84:	20 81       	ld	r18, Z
    fd86:	22 60       	ori	r18, 0x02	; 2
    fd88:	fc 01       	movw	r30, r24
    fd8a:	20 83       	st	Z, r18
	sbi(TCCR0A, WGM00);
    fd8c:	84 e4       	ldi	r24, 0x44	; 68
    fd8e:	90 e0       	ldi	r25, 0x00	; 0
    fd90:	24 e4       	ldi	r18, 0x44	; 68
    fd92:	30 e0       	ldi	r19, 0x00	; 0
    fd94:	f9 01       	movw	r30, r18
    fd96:	20 81       	ld	r18, Z
    fd98:	21 60       	ori	r18, 0x01	; 1
    fd9a:	fc 01       	movw	r30, r24
    fd9c:	20 83       	st	Z, r18
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    fd9e:	85 e4       	ldi	r24, 0x45	; 69
    fda0:	90 e0       	ldi	r25, 0x00	; 0
    fda2:	25 e4       	ldi	r18, 0x45	; 69
    fda4:	30 e0       	ldi	r19, 0x00	; 0
    fda6:	f9 01       	movw	r30, r18
    fda8:	20 81       	ld	r18, Z
    fdaa:	22 60       	ori	r18, 0x02	; 2
    fdac:	fc 01       	movw	r30, r24
    fdae:	20 83       	st	Z, r18
	sbi(TCCR0B, CS00);
    fdb0:	85 e4       	ldi	r24, 0x45	; 69
    fdb2:	90 e0       	ldi	r25, 0x00	; 0
    fdb4:	25 e4       	ldi	r18, 0x45	; 69
    fdb6:	30 e0       	ldi	r19, 0x00	; 0
    fdb8:	f9 01       	movw	r30, r18
    fdba:	20 81       	ld	r18, Z
    fdbc:	21 60       	ori	r18, 0x01	; 1
    fdbe:	fc 01       	movw	r30, r24
    fdc0:	20 83       	st	Z, r18

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    fdc2:	8e e6       	ldi	r24, 0x6E	; 110
    fdc4:	90 e0       	ldi	r25, 0x00	; 0
    fdc6:	2e e6       	ldi	r18, 0x6E	; 110
    fdc8:	30 e0       	ldi	r19, 0x00	; 0
    fdca:	f9 01       	movw	r30, r18
    fdcc:	20 81       	ld	r18, Z
    fdce:	21 60       	ori	r18, 0x01	; 1
    fdd0:	fc 01       	movw	r30, r24
    fdd2:	20 83       	st	Z, r18
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    fdd4:	81 e8       	ldi	r24, 0x81	; 129
    fdd6:	90 e0       	ldi	r25, 0x00	; 0
    fdd8:	fc 01       	movw	r30, r24
    fdda:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    fddc:	81 e8       	ldi	r24, 0x81	; 129
    fdde:	90 e0       	ldi	r25, 0x00	; 0
    fde0:	21 e8       	ldi	r18, 0x81	; 129
    fde2:	30 e0       	ldi	r19, 0x00	; 0
    fde4:	f9 01       	movw	r30, r18
    fde6:	20 81       	ld	r18, Z
    fde8:	22 60       	ori	r18, 0x02	; 2
    fdea:	fc 01       	movw	r30, r24
    fdec:	20 83       	st	Z, r18
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    fdee:	81 e8       	ldi	r24, 0x81	; 129
    fdf0:	90 e0       	ldi	r25, 0x00	; 0
    fdf2:	21 e8       	ldi	r18, 0x81	; 129
    fdf4:	30 e0       	ldi	r19, 0x00	; 0
    fdf6:	f9 01       	movw	r30, r18
    fdf8:	20 81       	ld	r18, Z
    fdfa:	21 60       	ori	r18, 0x01	; 1
    fdfc:	fc 01       	movw	r30, r24
    fdfe:	20 83       	st	Z, r18
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    fe00:	80 e8       	ldi	r24, 0x80	; 128
    fe02:	90 e0       	ldi	r25, 0x00	; 0
    fe04:	20 e8       	ldi	r18, 0x80	; 128
    fe06:	30 e0       	ldi	r19, 0x00	; 0
    fe08:	f9 01       	movw	r30, r18
    fe0a:	20 81       	ld	r18, Z
    fe0c:	21 60       	ori	r18, 0x01	; 1
    fe0e:	fc 01       	movw	r30, r24
    fe10:	20 83       	st	Z, r18

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    fe12:	81 eb       	ldi	r24, 0xB1	; 177
    fe14:	90 e0       	ldi	r25, 0x00	; 0
    fe16:	21 eb       	ldi	r18, 0xB1	; 177
    fe18:	30 e0       	ldi	r19, 0x00	; 0
    fe1a:	f9 01       	movw	r30, r18
    fe1c:	20 81       	ld	r18, Z
    fe1e:	24 60       	ori	r18, 0x04	; 4
    fe20:	fc 01       	movw	r30, r24
    fe22:	20 83       	st	Z, r18

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    fe24:	80 eb       	ldi	r24, 0xB0	; 176
    fe26:	90 e0       	ldi	r25, 0x00	; 0
    fe28:	20 eb       	ldi	r18, 0xB0	; 176
    fe2a:	30 e0       	ldi	r19, 0x00	; 0
    fe2c:	f9 01       	movw	r30, r18
    fe2e:	20 81       	ld	r18, Z
    fe30:	21 60       	ori	r18, 0x01	; 1
    fe32:	fc 01       	movw	r30, r24
    fe34:	20 83       	st	Z, r18
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
    fe36:	8a e7       	ldi	r24, 0x7A	; 122
    fe38:	90 e0       	ldi	r25, 0x00	; 0
    fe3a:	2a e7       	ldi	r18, 0x7A	; 122
    fe3c:	30 e0       	ldi	r19, 0x00	; 0
    fe3e:	f9 01       	movw	r30, r18
    fe40:	20 81       	ld	r18, Z
    fe42:	24 60       	ori	r18, 0x04	; 4
    fe44:	fc 01       	movw	r30, r24
    fe46:	20 83       	st	Z, r18
	sbi(ADCSRA, ADPS1);
    fe48:	8a e7       	ldi	r24, 0x7A	; 122
    fe4a:	90 e0       	ldi	r25, 0x00	; 0
    fe4c:	2a e7       	ldi	r18, 0x7A	; 122
    fe4e:	30 e0       	ldi	r19, 0x00	; 0
    fe50:	f9 01       	movw	r30, r18
    fe52:	20 81       	ld	r18, Z
    fe54:	22 60       	ori	r18, 0x02	; 2
    fe56:	fc 01       	movw	r30, r24
    fe58:	20 83       	st	Z, r18
	sbi(ADCSRA, ADPS0);
    fe5a:	8a e7       	ldi	r24, 0x7A	; 122
    fe5c:	90 e0       	ldi	r25, 0x00	; 0
    fe5e:	2a e7       	ldi	r18, 0x7A	; 122
    fe60:	30 e0       	ldi	r19, 0x00	; 0
    fe62:	f9 01       	movw	r30, r18
    fe64:	20 81       	ld	r18, Z
    fe66:	21 60       	ori	r18, 0x01	; 1
    fe68:	fc 01       	movw	r30, r24
    fe6a:	20 83       	st	Z, r18

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    fe6c:	8a e7       	ldi	r24, 0x7A	; 122
    fe6e:	90 e0       	ldi	r25, 0x00	; 0
    fe70:	2a e7       	ldi	r18, 0x7A	; 122
    fe72:	30 e0       	ldi	r19, 0x00	; 0
    fe74:	f9 01       	movw	r30, r18
    fe76:	20 81       	ld	r18, Z
    fe78:	20 68       	ori	r18, 0x80	; 128
    fe7a:	fc 01       	movw	r30, r24
    fe7c:	20 83       	st	Z, r18
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    fe7e:	81 ec       	ldi	r24, 0xC1	; 193
    fe80:	90 e0       	ldi	r25, 0x00	; 0
    fe82:	fc 01       	movw	r30, r24
    fe84:	10 82       	st	Z, r1
#endif
}
    fe86:	df 91       	pop	r29
    fe88:	cf 91       	pop	r28
    fe8a:	08 95       	ret

0000fe8c <analogReference>:
#include "pins_arduino.h"

uint8_t analog_reference = DEFAULT;

void analogReference(uint8_t mode)
{
    fe8c:	cf 93       	push	r28
    fe8e:	df 93       	push	r29
    fe90:	1f 92       	push	r1
    fe92:	cd b7       	in	r28, 0x3d	; 61
    fe94:	de b7       	in	r29, 0x3e	; 62
    fe96:	89 83       	std	Y+1, r24	; 0x01
	// can't actually set the register here because the default setting
	// will connect AVCC and the AREF pin, which would cause a short if
	// there's something connected to AREF.
	analog_reference = mode;
    fe98:	89 81       	ldd	r24, Y+1	; 0x01
    fe9a:	80 93 45 02 	sts	0x0245, r24
}
    fe9e:	0f 90       	pop	r0
    fea0:	df 91       	pop	r29
    fea2:	cf 91       	pop	r28
    fea4:	08 95       	ret

0000fea6 <analogRead>:

int analogRead(uint8_t pin)
{
    fea6:	cf 93       	push	r28
    fea8:	df 93       	push	r29
    feaa:	00 d0       	rcall	.+0      	; 0xfeac <analogRead+0x6>
    feac:	1f 92       	push	r1
    feae:	cd b7       	in	r28, 0x3d	; 61
    feb0:	de b7       	in	r29, 0x3e	; 62
    feb2:	8b 83       	std	Y+3, r24	; 0x03
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
    feb4:	8b 81       	ldd	r24, Y+3	; 0x03
    feb6:	8e 30       	cpi	r24, 0x0E	; 14
    feb8:	18 f0       	brcs	.+6      	; 0xfec0 <analogRead+0x1a>
    feba:	8b 81       	ldd	r24, Y+3	; 0x03
    febc:	8e 50       	subi	r24, 0x0E	; 14
    febe:	8b 83       	std	Y+3, r24	; 0x03
  
	// set the analog reference (high two bits of ADMUX) and select the
	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
	// to 0 (the default).
#if defined(ADMUX)
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    fec0:	8c e7       	ldi	r24, 0x7C	; 124
    fec2:	90 e0       	ldi	r25, 0x00	; 0
    fec4:	20 91 45 02 	lds	r18, 0x0245
    fec8:	22 2f       	mov	r18, r18
    feca:	30 e0       	ldi	r19, 0x00	; 0
    fecc:	00 24       	eor	r0, r0
    fece:	36 95       	lsr	r19
    fed0:	27 95       	ror	r18
    fed2:	07 94       	ror	r0
    fed4:	36 95       	lsr	r19
    fed6:	27 95       	ror	r18
    fed8:	07 94       	ror	r0
    feda:	32 2f       	mov	r19, r18
    fedc:	20 2d       	mov	r18, r0
    fede:	32 2f       	mov	r19, r18
    fee0:	2b 81       	ldd	r18, Y+3	; 0x03
    fee2:	27 70       	andi	r18, 0x07	; 7
    fee4:	23 2b       	or	r18, r19
    fee6:	fc 01       	movw	r30, r24
    fee8:	20 83       	st	Z, r18
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    feea:	8a e7       	ldi	r24, 0x7A	; 122
    feec:	90 e0       	ldi	r25, 0x00	; 0
    feee:	2a e7       	ldi	r18, 0x7A	; 122
    fef0:	30 e0       	ldi	r19, 0x00	; 0
    fef2:	f9 01       	movw	r30, r18
    fef4:	20 81       	ld	r18, Z
    fef6:	20 64       	ori	r18, 0x40	; 64
    fef8:	fc 01       	movw	r30, r24
    fefa:	20 83       	st	Z, r18

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    fefc:	00 00       	nop
    fefe:	8a e7       	ldi	r24, 0x7A	; 122
    ff00:	90 e0       	ldi	r25, 0x00	; 0
    ff02:	fc 01       	movw	r30, r24
    ff04:	80 81       	ld	r24, Z
    ff06:	88 2f       	mov	r24, r24
    ff08:	90 e0       	ldi	r25, 0x00	; 0
    ff0a:	80 74       	andi	r24, 0x40	; 64
    ff0c:	99 27       	eor	r25, r25
    ff0e:	00 97       	sbiw	r24, 0x00	; 0
    ff10:	b1 f7       	brne	.-20     	; 0xfefe <analogRead+0x58>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    ff12:	88 e7       	ldi	r24, 0x78	; 120
    ff14:	90 e0       	ldi	r25, 0x00	; 0
    ff16:	fc 01       	movw	r30, r24
    ff18:	80 81       	ld	r24, Z
    ff1a:	89 83       	std	Y+1, r24	; 0x01
	high = ADCH;
    ff1c:	89 e7       	ldi	r24, 0x79	; 121
    ff1e:	90 e0       	ldi	r25, 0x00	; 0
    ff20:	fc 01       	movw	r30, r24
    ff22:	80 81       	ld	r24, Z
    ff24:	8a 83       	std	Y+2, r24	; 0x02
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    ff26:	8a 81       	ldd	r24, Y+2	; 0x02
    ff28:	88 2f       	mov	r24, r24
    ff2a:	90 e0       	ldi	r25, 0x00	; 0
    ff2c:	38 2f       	mov	r19, r24
    ff2e:	22 27       	eor	r18, r18
    ff30:	89 81       	ldd	r24, Y+1	; 0x01
    ff32:	88 2f       	mov	r24, r24
    ff34:	90 e0       	ldi	r25, 0x00	; 0
    ff36:	82 2b       	or	r24, r18
    ff38:	93 2b       	or	r25, r19
}
    ff3a:	0f 90       	pop	r0
    ff3c:	0f 90       	pop	r0
    ff3e:	0f 90       	pop	r0
    ff40:	df 91       	pop	r29
    ff42:	cf 91       	pop	r28
    ff44:	08 95       	ret

0000ff46 <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    ff46:	1f 93       	push	r17
    ff48:	cf 93       	push	r28
    ff4a:	df 93       	push	r29
    ff4c:	00 d0       	rcall	.+0      	; 0xff4e <analogWrite+0x8>
    ff4e:	00 d0       	rcall	.+0      	; 0xff50 <analogWrite+0xa>
    ff50:	00 d0       	rcall	.+0      	; 0xff52 <analogWrite+0xc>
    ff52:	cd b7       	in	r28, 0x3d	; 61
    ff54:	de b7       	in	r29, 0x3e	; 62
    ff56:	8c 83       	std	Y+4, r24	; 0x04
    ff58:	7e 83       	std	Y+6, r23	; 0x06
    ff5a:	6d 83       	std	Y+5, r22	; 0x05
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    ff5c:	61 e0       	ldi	r22, 0x01	; 1
    ff5e:	8c 81       	ldd	r24, Y+4	; 0x04
    ff60:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>
	if (val == 0)
    ff64:	8d 81       	ldd	r24, Y+5	; 0x05
    ff66:	9e 81       	ldd	r25, Y+6	; 0x06
    ff68:	00 97       	sbiw	r24, 0x00	; 0
    ff6a:	29 f4       	brne	.+10     	; 0xff76 <analogWrite+0x30>
	{
		digitalWrite(pin, LOW);
    ff6c:	60 e0       	ldi	r22, 0x00	; 0
    ff6e:	8c 81       	ldd	r24, Y+4	; 0x04
    ff70:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
    ff74:	9e c0       	rjmp	.+316    	; 0x100b2 <analogWrite+0x16c>
	}
	else if (val == 255)
    ff76:	8d 81       	ldd	r24, Y+5	; 0x05
    ff78:	9e 81       	ldd	r25, Y+6	; 0x06
    ff7a:	8f 3f       	cpi	r24, 0xFF	; 255
    ff7c:	91 05       	cpc	r25, r1
    ff7e:	29 f4       	brne	.+10     	; 0xff8a <analogWrite+0x44>
	{
		digitalWrite(pin, HIGH);
    ff80:	61 e0       	ldi	r22, 0x01	; 1
    ff82:	8c 81       	ldd	r24, Y+4	; 0x04
    ff84:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
    ff88:	94 c0       	rjmp	.+296    	; 0x100b2 <analogWrite+0x16c>
	}
	else
	{
		switch(digitalPinToTimer(pin))
    ff8a:	8c 81       	ldd	r24, Y+4	; 0x04
    ff8c:	88 2f       	mov	r24, r24
    ff8e:	90 e0       	ldi	r25, 0x00	; 0
    ff90:	8f 55       	subi	r24, 0x5F	; 95
    ff92:	9d 4f       	sbci	r25, 0xFD	; 253
    ff94:	9a 83       	std	Y+2, r25	; 0x02
    ff96:	89 83       	std	Y+1, r24	; 0x01
    ff98:	89 81       	ldd	r24, Y+1	; 0x01
    ff9a:	9a 81       	ldd	r25, Y+2	; 0x02
    ff9c:	fc 01       	movw	r30, r24
    ff9e:	14 91       	lpm	r17, Z
    ffa0:	1b 83       	std	Y+3, r17	; 0x03
    ffa2:	8b 81       	ldd	r24, Y+3	; 0x03
    ffa4:	88 2f       	mov	r24, r24
    ffa6:	90 e0       	ldi	r25, 0x00	; 0
    ffa8:	83 30       	cpi	r24, 0x03	; 3
    ffaa:	91 05       	cpc	r25, r1
    ffac:	a1 f1       	breq	.+104    	; 0x10016 <analogWrite+0xd0>
    ffae:	84 30       	cpi	r24, 0x04	; 4
    ffb0:	91 05       	cpc	r25, r1
    ffb2:	3c f4       	brge	.+14     	; 0xffc2 <analogWrite+0x7c>
    ffb4:	81 30       	cpi	r24, 0x01	; 1
    ffb6:	91 05       	cpc	r25, r1
    ffb8:	81 f0       	breq	.+32     	; 0xffda <analogWrite+0x94>
    ffba:	82 30       	cpi	r24, 0x02	; 2
    ffbc:	91 05       	cpc	r25, r1
    ffbe:	e1 f0       	breq	.+56     	; 0xfff8 <analogWrite+0xb2>
    ffc0:	6a c0       	rjmp	.+212    	; 0x10096 <analogWrite+0x150>
    ffc2:	86 30       	cpi	r24, 0x06	; 6
    ffc4:	91 05       	cpc	r25, r1
    ffc6:	09 f4       	brne	.+2      	; 0xffca <analogWrite+0x84>
    ffc8:	48 c0       	rjmp	.+144    	; 0x1005a <analogWrite+0x114>
    ffca:	87 30       	cpi	r24, 0x07	; 7
    ffcc:	91 05       	cpc	r25, r1
    ffce:	09 f4       	brne	.+2      	; 0xffd2 <analogWrite+0x8c>
    ffd0:	53 c0       	rjmp	.+166    	; 0x10078 <analogWrite+0x132>
    ffd2:	84 30       	cpi	r24, 0x04	; 4
    ffd4:	91 05       	cpc	r25, r1
    ffd6:	81 f1       	breq	.+96     	; 0x10038 <analogWrite+0xf2>
    ffd8:	5e c0       	rjmp	.+188    	; 0x10096 <analogWrite+0x150>
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    ffda:	84 e4       	ldi	r24, 0x44	; 68
    ffdc:	90 e0       	ldi	r25, 0x00	; 0
    ffde:	24 e4       	ldi	r18, 0x44	; 68
    ffe0:	30 e0       	ldi	r19, 0x00	; 0
    ffe2:	f9 01       	movw	r30, r18
    ffe4:	20 81       	ld	r18, Z
    ffe6:	20 68       	ori	r18, 0x80	; 128
    ffe8:	fc 01       	movw	r30, r24
    ffea:	20 83       	st	Z, r18
				OCR0A = val; // set pwm duty
    ffec:	87 e4       	ldi	r24, 0x47	; 71
    ffee:	90 e0       	ldi	r25, 0x00	; 0
    fff0:	2d 81       	ldd	r18, Y+5	; 0x05
    fff2:	fc 01       	movw	r30, r24
    fff4:	20 83       	st	Z, r18
				break;
    fff6:	5d c0       	rjmp	.+186    	; 0x100b2 <analogWrite+0x16c>
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    fff8:	84 e4       	ldi	r24, 0x44	; 68
    fffa:	90 e0       	ldi	r25, 0x00	; 0
    fffc:	24 e4       	ldi	r18, 0x44	; 68
    fffe:	30 e0       	ldi	r19, 0x00	; 0
   10000:	f9 01       	movw	r30, r18
   10002:	20 81       	ld	r18, Z
   10004:	20 62       	ori	r18, 0x20	; 32
   10006:	fc 01       	movw	r30, r24
   10008:	20 83       	st	Z, r18
				OCR0B = val; // set pwm duty
   1000a:	88 e4       	ldi	r24, 0x48	; 72
   1000c:	90 e0       	ldi	r25, 0x00	; 0
   1000e:	2d 81       	ldd	r18, Y+5	; 0x05
   10010:	fc 01       	movw	r30, r24
   10012:	20 83       	st	Z, r18
				break;
   10014:	4e c0       	rjmp	.+156    	; 0x100b2 <analogWrite+0x16c>
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
   10016:	80 e8       	ldi	r24, 0x80	; 128
   10018:	90 e0       	ldi	r25, 0x00	; 0
   1001a:	20 e8       	ldi	r18, 0x80	; 128
   1001c:	30 e0       	ldi	r19, 0x00	; 0
   1001e:	f9 01       	movw	r30, r18
   10020:	20 81       	ld	r18, Z
   10022:	20 68       	ori	r18, 0x80	; 128
   10024:	fc 01       	movw	r30, r24
   10026:	20 83       	st	Z, r18
				OCR1A = val; // set pwm duty
   10028:	88 e8       	ldi	r24, 0x88	; 136
   1002a:	90 e0       	ldi	r25, 0x00	; 0
   1002c:	2d 81       	ldd	r18, Y+5	; 0x05
   1002e:	3e 81       	ldd	r19, Y+6	; 0x06
   10030:	fc 01       	movw	r30, r24
   10032:	31 83       	std	Z+1, r19	; 0x01
   10034:	20 83       	st	Z, r18
				break;
   10036:	3d c0       	rjmp	.+122    	; 0x100b2 <analogWrite+0x16c>
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
   10038:	80 e8       	ldi	r24, 0x80	; 128
   1003a:	90 e0       	ldi	r25, 0x00	; 0
   1003c:	20 e8       	ldi	r18, 0x80	; 128
   1003e:	30 e0       	ldi	r19, 0x00	; 0
   10040:	f9 01       	movw	r30, r18
   10042:	20 81       	ld	r18, Z
   10044:	20 62       	ori	r18, 0x20	; 32
   10046:	fc 01       	movw	r30, r24
   10048:	20 83       	st	Z, r18
				OCR1B = val; // set pwm duty
   1004a:	8a e8       	ldi	r24, 0x8A	; 138
   1004c:	90 e0       	ldi	r25, 0x00	; 0
   1004e:	2d 81       	ldd	r18, Y+5	; 0x05
   10050:	3e 81       	ldd	r19, Y+6	; 0x06
   10052:	fc 01       	movw	r30, r24
   10054:	31 83       	std	Z+1, r19	; 0x01
   10056:	20 83       	st	Z, r18
				break;
   10058:	2c c0       	rjmp	.+88     	; 0x100b2 <analogWrite+0x16c>
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
   1005a:	80 eb       	ldi	r24, 0xB0	; 176
   1005c:	90 e0       	ldi	r25, 0x00	; 0
   1005e:	20 eb       	ldi	r18, 0xB0	; 176
   10060:	30 e0       	ldi	r19, 0x00	; 0
   10062:	f9 01       	movw	r30, r18
   10064:	20 81       	ld	r18, Z
   10066:	20 68       	ori	r18, 0x80	; 128
   10068:	fc 01       	movw	r30, r24
   1006a:	20 83       	st	Z, r18
				OCR2A = val; // set pwm duty
   1006c:	83 eb       	ldi	r24, 0xB3	; 179
   1006e:	90 e0       	ldi	r25, 0x00	; 0
   10070:	2d 81       	ldd	r18, Y+5	; 0x05
   10072:	fc 01       	movw	r30, r24
   10074:	20 83       	st	Z, r18
				break;
   10076:	1d c0       	rjmp	.+58     	; 0x100b2 <analogWrite+0x16c>
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
   10078:	80 eb       	ldi	r24, 0xB0	; 176
   1007a:	90 e0       	ldi	r25, 0x00	; 0
   1007c:	20 eb       	ldi	r18, 0xB0	; 176
   1007e:	30 e0       	ldi	r19, 0x00	; 0
   10080:	f9 01       	movw	r30, r18
   10082:	20 81       	ld	r18, Z
   10084:	20 62       	ori	r18, 0x20	; 32
   10086:	fc 01       	movw	r30, r24
   10088:	20 83       	st	Z, r18
				OCR2B = val; // set pwm duty
   1008a:	84 eb       	ldi	r24, 0xB4	; 180
   1008c:	90 e0       	ldi	r25, 0x00	; 0
   1008e:	2d 81       	ldd	r18, Y+5	; 0x05
   10090:	fc 01       	movw	r30, r24
   10092:	20 83       	st	Z, r18
				break;
   10094:	0e c0       	rjmp	.+28     	; 0x100b2 <analogWrite+0x16c>
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
   10096:	8d 81       	ldd	r24, Y+5	; 0x05
   10098:	9e 81       	ldd	r25, Y+6	; 0x06
   1009a:	80 38       	cpi	r24, 0x80	; 128
   1009c:	91 05       	cpc	r25, r1
   1009e:	2c f4       	brge	.+10     	; 0x100aa <analogWrite+0x164>
					digitalWrite(pin, LOW);
   100a0:	60 e0       	ldi	r22, 0x00	; 0
   100a2:	8c 81       	ldd	r24, Y+4	; 0x04
   100a4:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
   100a8:	04 c0       	rjmp	.+8      	; 0x100b2 <analogWrite+0x16c>
				} else {
					digitalWrite(pin, HIGH);
   100aa:	61 e0       	ldi	r22, 0x01	; 1
   100ac:	8c 81       	ldd	r24, Y+4	; 0x04
   100ae:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
				}
		}
	}
}
   100b2:	26 96       	adiw	r28, 0x06	; 6
   100b4:	0f b6       	in	r0, 0x3f	; 63
   100b6:	f8 94       	cli
   100b8:	de bf       	out	0x3e, r29	; 62
   100ba:	0f be       	out	0x3f, r0	; 63
   100bc:	cd bf       	out	0x3d, r28	; 61
   100be:	df 91       	pop	r29
   100c0:	cf 91       	pop	r28
   100c2:	1f 91       	pop	r17
   100c4:	08 95       	ret

000100c6 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
   100c6:	ef 92       	push	r14
   100c8:	ff 92       	push	r15
   100ca:	0f 93       	push	r16
   100cc:	1f 93       	push	r17
   100ce:	cf 93       	push	r28
   100d0:	df 93       	push	r29
   100d2:	cd b7       	in	r28, 0x3d	; 61
   100d4:	de b7       	in	r29, 0x3e	; 62
   100d6:	69 97       	sbiw	r28, 0x19	; 25
   100d8:	0f b6       	in	r0, 0x3f	; 63
   100da:	f8 94       	cli
   100dc:	de bf       	out	0x3e, r29	; 62
   100de:	0f be       	out	0x3f, r0	; 63
   100e0:	cd bf       	out	0x3d, r28	; 61
   100e2:	88 8f       	std	Y+24, r24	; 0x18
   100e4:	69 8f       	std	Y+25, r22	; 0x19
	uint8_t bit = digitalPinToBitMask(pin);
   100e6:	88 8d       	ldd	r24, Y+24	; 0x18
   100e8:	88 2f       	mov	r24, r24
   100ea:	90 e0       	ldi	r25, 0x00	; 0
   100ec:	83 57       	subi	r24, 0x73	; 115
   100ee:	9d 4f       	sbci	r25, 0xFD	; 253
   100f0:	9a 83       	std	Y+2, r25	; 0x02
   100f2:	89 83       	std	Y+1, r24	; 0x01
   100f4:	89 81       	ldd	r24, Y+1	; 0x01
   100f6:	9a 81       	ldd	r25, Y+2	; 0x02
   100f8:	fc 01       	movw	r30, r24
   100fa:	14 91       	lpm	r17, Z
   100fc:	1b 83       	std	Y+3, r17	; 0x03
   100fe:	8b 81       	ldd	r24, Y+3	; 0x03
   10100:	8c 83       	std	Y+4, r24	; 0x04
	uint8_t port = digitalPinToPort(pin);
   10102:	88 8d       	ldd	r24, Y+24	; 0x18
   10104:	88 2f       	mov	r24, r24
   10106:	90 e0       	ldi	r25, 0x00	; 0
   10108:	87 58       	subi	r24, 0x87	; 135
   1010a:	9d 4f       	sbci	r25, 0xFD	; 253
   1010c:	9e 83       	std	Y+6, r25	; 0x06
   1010e:	8d 83       	std	Y+5, r24	; 0x05
   10110:	8d 81       	ldd	r24, Y+5	; 0x05
   10112:	9e 81       	ldd	r25, Y+6	; 0x06
   10114:	fc 01       	movw	r30, r24
   10116:	14 91       	lpm	r17, Z
   10118:	1f 83       	std	Y+7, r17	; 0x07
   1011a:	8f 81       	ldd	r24, Y+7	; 0x07
   1011c:	88 87       	std	Y+8, r24	; 0x08
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
   1011e:	88 85       	ldd	r24, Y+8	; 0x08
   10120:	88 23       	and	r24, r24
   10122:	09 f4       	brne	.+2      	; 0x10126 <pinMode+0x60>
   10124:	97 c0       	rjmp	.+302    	; 0x10254 <pinMode+0x18e>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
   10126:	88 85       	ldd	r24, Y+8	; 0x08
   10128:	88 2f       	mov	r24, r24
   1012a:	90 e0       	ldi	r25, 0x00	; 0
   1012c:	88 0f       	add	r24, r24
   1012e:	99 1f       	adc	r25, r25
   10130:	85 5a       	subi	r24, 0xA5	; 165
   10132:	9d 4f       	sbci	r25, 0xFD	; 253
   10134:	9a 87       	std	Y+10, r25	; 0x0a
   10136:	89 87       	std	Y+9, r24	; 0x09
   10138:	89 85       	ldd	r24, Y+9	; 0x09
   1013a:	9a 85       	ldd	r25, Y+10	; 0x0a
   1013c:	8c 01       	movw	r16, r24
   1013e:	f8 01       	movw	r30, r16
   10140:	e5 90       	lpm	r14, Z+
   10142:	f4 90       	lpm	r15, Z
   10144:	8f 01       	movw	r16, r30
   10146:	fc 86       	std	Y+12, r15	; 0x0c
   10148:	eb 86       	std	Y+11, r14	; 0x0b
   1014a:	1a 87       	std	Y+10, r17	; 0x0a
   1014c:	09 87       	std	Y+9, r16	; 0x09
   1014e:	8b 85       	ldd	r24, Y+11	; 0x0b
   10150:	9c 85       	ldd	r25, Y+12	; 0x0c
   10152:	9e 87       	std	Y+14, r25	; 0x0e
   10154:	8d 87       	std	Y+13, r24	; 0x0d
	out = portOutputRegister(port);
   10156:	88 85       	ldd	r24, Y+8	; 0x08
   10158:	88 2f       	mov	r24, r24
   1015a:	90 e0       	ldi	r25, 0x00	; 0
   1015c:	88 0f       	add	r24, r24
   1015e:	99 1f       	adc	r25, r25
   10160:	8b 59       	subi	r24, 0x9B	; 155
   10162:	9d 4f       	sbci	r25, 0xFD	; 253
   10164:	98 8b       	std	Y+16, r25	; 0x10
   10166:	8f 87       	std	Y+15, r24	; 0x0f
   10168:	8f 85       	ldd	r24, Y+15	; 0x0f
   1016a:	98 89       	ldd	r25, Y+16	; 0x10
   1016c:	8c 01       	movw	r16, r24
   1016e:	f8 01       	movw	r30, r16
   10170:	e5 90       	lpm	r14, Z+
   10172:	f4 90       	lpm	r15, Z
   10174:	8f 01       	movw	r16, r30
   10176:	fa 8a       	std	Y+18, r15	; 0x12
   10178:	e9 8a       	std	Y+17, r14	; 0x11
   1017a:	18 8b       	std	Y+16, r17	; 0x10
   1017c:	0f 87       	std	Y+15, r16	; 0x0f
   1017e:	89 89       	ldd	r24, Y+17	; 0x11
   10180:	9a 89       	ldd	r25, Y+18	; 0x12
   10182:	9c 8b       	std	Y+20, r25	; 0x14
   10184:	8b 8b       	std	Y+19, r24	; 0x13

	if (mode == INPUT) { 
   10186:	89 8d       	ldd	r24, Y+25	; 0x19
   10188:	88 23       	and	r24, r24
   1018a:	31 f5       	brne	.+76     	; 0x101d8 <pinMode+0x112>
		uint8_t oldSREG = SREG;
   1018c:	8f e5       	ldi	r24, 0x5F	; 95
   1018e:	90 e0       	ldi	r25, 0x00	; 0
   10190:	fc 01       	movw	r30, r24
   10192:	80 81       	ld	r24, Z
   10194:	8d 8b       	std	Y+21, r24	; 0x15
                cli();
   10196:	f8 94       	cli
		*reg &= ~bit;
   10198:	8d 85       	ldd	r24, Y+13	; 0x0d
   1019a:	9e 85       	ldd	r25, Y+14	; 0x0e
   1019c:	fc 01       	movw	r30, r24
   1019e:	80 81       	ld	r24, Z
   101a0:	98 2f       	mov	r25, r24
   101a2:	8c 81       	ldd	r24, Y+4	; 0x04
   101a4:	80 95       	com	r24
   101a6:	89 23       	and	r24, r25
   101a8:	28 2f       	mov	r18, r24
   101aa:	8d 85       	ldd	r24, Y+13	; 0x0d
   101ac:	9e 85       	ldd	r25, Y+14	; 0x0e
   101ae:	fc 01       	movw	r30, r24
   101b0:	20 83       	st	Z, r18
		*out &= ~bit;
   101b2:	8b 89       	ldd	r24, Y+19	; 0x13
   101b4:	9c 89       	ldd	r25, Y+20	; 0x14
   101b6:	fc 01       	movw	r30, r24
   101b8:	80 81       	ld	r24, Z
   101ba:	98 2f       	mov	r25, r24
   101bc:	8c 81       	ldd	r24, Y+4	; 0x04
   101be:	80 95       	com	r24
   101c0:	89 23       	and	r24, r25
   101c2:	28 2f       	mov	r18, r24
   101c4:	8b 89       	ldd	r24, Y+19	; 0x13
   101c6:	9c 89       	ldd	r25, Y+20	; 0x14
   101c8:	fc 01       	movw	r30, r24
   101ca:	20 83       	st	Z, r18
		SREG = oldSREG;
   101cc:	8f e5       	ldi	r24, 0x5F	; 95
   101ce:	90 e0       	ldi	r25, 0x00	; 0
   101d0:	2d 89       	ldd	r18, Y+21	; 0x15
   101d2:	fc 01       	movw	r30, r24
   101d4:	20 83       	st	Z, r18
   101d6:	3f c0       	rjmp	.+126    	; 0x10256 <pinMode+0x190>
	} else if (mode == INPUT_PULLUP) {
   101d8:	89 8d       	ldd	r24, Y+25	; 0x19
   101da:	82 30       	cpi	r24, 0x02	; 2
   101dc:	21 f5       	brne	.+72     	; 0x10226 <pinMode+0x160>
		uint8_t oldSREG = SREG;
   101de:	8f e5       	ldi	r24, 0x5F	; 95
   101e0:	90 e0       	ldi	r25, 0x00	; 0
   101e2:	fc 01       	movw	r30, r24
   101e4:	80 81       	ld	r24, Z
   101e6:	8e 8b       	std	Y+22, r24	; 0x16
                cli();
   101e8:	f8 94       	cli
		*reg &= ~bit;
   101ea:	8d 85       	ldd	r24, Y+13	; 0x0d
   101ec:	9e 85       	ldd	r25, Y+14	; 0x0e
   101ee:	fc 01       	movw	r30, r24
   101f0:	80 81       	ld	r24, Z
   101f2:	98 2f       	mov	r25, r24
   101f4:	8c 81       	ldd	r24, Y+4	; 0x04
   101f6:	80 95       	com	r24
   101f8:	89 23       	and	r24, r25
   101fa:	28 2f       	mov	r18, r24
   101fc:	8d 85       	ldd	r24, Y+13	; 0x0d
   101fe:	9e 85       	ldd	r25, Y+14	; 0x0e
   10200:	fc 01       	movw	r30, r24
   10202:	20 83       	st	Z, r18
		*out |= bit;
   10204:	8b 89       	ldd	r24, Y+19	; 0x13
   10206:	9c 89       	ldd	r25, Y+20	; 0x14
   10208:	fc 01       	movw	r30, r24
   1020a:	90 81       	ld	r25, Z
   1020c:	8c 81       	ldd	r24, Y+4	; 0x04
   1020e:	29 2f       	mov	r18, r25
   10210:	28 2b       	or	r18, r24
   10212:	8b 89       	ldd	r24, Y+19	; 0x13
   10214:	9c 89       	ldd	r25, Y+20	; 0x14
   10216:	fc 01       	movw	r30, r24
   10218:	20 83       	st	Z, r18
		SREG = oldSREG;
   1021a:	8f e5       	ldi	r24, 0x5F	; 95
   1021c:	90 e0       	ldi	r25, 0x00	; 0
   1021e:	2e 89       	ldd	r18, Y+22	; 0x16
   10220:	fc 01       	movw	r30, r24
   10222:	20 83       	st	Z, r18
   10224:	18 c0       	rjmp	.+48     	; 0x10256 <pinMode+0x190>
	} else {
		uint8_t oldSREG = SREG;
   10226:	8f e5       	ldi	r24, 0x5F	; 95
   10228:	90 e0       	ldi	r25, 0x00	; 0
   1022a:	fc 01       	movw	r30, r24
   1022c:	80 81       	ld	r24, Z
   1022e:	8f 8b       	std	Y+23, r24	; 0x17
                cli();
   10230:	f8 94       	cli
		*reg |= bit;
   10232:	8d 85       	ldd	r24, Y+13	; 0x0d
   10234:	9e 85       	ldd	r25, Y+14	; 0x0e
   10236:	fc 01       	movw	r30, r24
   10238:	90 81       	ld	r25, Z
   1023a:	8c 81       	ldd	r24, Y+4	; 0x04
   1023c:	29 2f       	mov	r18, r25
   1023e:	28 2b       	or	r18, r24
   10240:	8d 85       	ldd	r24, Y+13	; 0x0d
   10242:	9e 85       	ldd	r25, Y+14	; 0x0e
   10244:	fc 01       	movw	r30, r24
   10246:	20 83       	st	Z, r18
		SREG = oldSREG;
   10248:	8f e5       	ldi	r24, 0x5F	; 95
   1024a:	90 e0       	ldi	r25, 0x00	; 0
   1024c:	2f 89       	ldd	r18, Y+23	; 0x17
   1024e:	fc 01       	movw	r30, r24
   10250:	20 83       	st	Z, r18
   10252:	01 c0       	rjmp	.+2      	; 0x10256 <pinMode+0x190>
{
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
   10254:	00 00       	nop
		uint8_t oldSREG = SREG;
                cli();
		*reg |= bit;
		SREG = oldSREG;
	}
}
   10256:	69 96       	adiw	r28, 0x19	; 25
   10258:	0f b6       	in	r0, 0x3f	; 63
   1025a:	f8 94       	cli
   1025c:	de bf       	out	0x3e, r29	; 62
   1025e:	0f be       	out	0x3f, r0	; 63
   10260:	cd bf       	out	0x3d, r28	; 61
   10262:	df 91       	pop	r29
   10264:	cf 91       	pop	r28
   10266:	1f 91       	pop	r17
   10268:	0f 91       	pop	r16
   1026a:	ff 90       	pop	r15
   1026c:	ef 90       	pop	r14
   1026e:	08 95       	ret

00010270 <turnOffPWM>:
// - Added more #ifdefs, now compiles for atmega645
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
   10270:	cf 93       	push	r28
   10272:	df 93       	push	r29
   10274:	1f 92       	push	r1
   10276:	cd b7       	in	r28, 0x3d	; 61
   10278:	de b7       	in	r29, 0x3e	; 62
   1027a:	89 83       	std	Y+1, r24	; 0x01
	switch (timer)
   1027c:	89 81       	ldd	r24, Y+1	; 0x01
   1027e:	88 2f       	mov	r24, r24
   10280:	90 e0       	ldi	r25, 0x00	; 0
   10282:	83 30       	cpi	r24, 0x03	; 3
   10284:	91 05       	cpc	r25, r1
   10286:	a1 f0       	breq	.+40     	; 0x102b0 <turnOffPWM+0x40>
   10288:	84 30       	cpi	r24, 0x04	; 4
   1028a:	91 05       	cpc	r25, r1
   1028c:	3c f4       	brge	.+14     	; 0x1029c <turnOffPWM+0x2c>
   1028e:	81 30       	cpi	r24, 0x01	; 1
   10290:	91 05       	cpc	r25, r1
   10292:	11 f1       	breq	.+68     	; 0x102d8 <turnOffPWM+0x68>
   10294:	82 30       	cpi	r24, 0x02	; 2
   10296:	91 05       	cpc	r25, r1
   10298:	49 f1       	breq	.+82     	; 0x102ec <turnOffPWM+0x7c>
   1029a:	46 c0       	rjmp	.+140    	; 0x10328 <turnOffPWM+0xb8>
   1029c:	86 30       	cpi	r24, 0x06	; 6
   1029e:	91 05       	cpc	r25, r1
   102a0:	79 f1       	breq	.+94     	; 0x10300 <turnOffPWM+0x90>
   102a2:	87 30       	cpi	r24, 0x07	; 7
   102a4:	91 05       	cpc	r25, r1
   102a6:	b1 f1       	breq	.+108    	; 0x10314 <turnOffPWM+0xa4>
   102a8:	84 30       	cpi	r24, 0x04	; 4
   102aa:	91 05       	cpc	r25, r1
   102ac:	59 f0       	breq	.+22     	; 0x102c4 <turnOffPWM+0x54>
   102ae:	3c c0       	rjmp	.+120    	; 0x10328 <turnOffPWM+0xb8>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
   102b0:	80 e8       	ldi	r24, 0x80	; 128
   102b2:	90 e0       	ldi	r25, 0x00	; 0
   102b4:	20 e8       	ldi	r18, 0x80	; 128
   102b6:	30 e0       	ldi	r19, 0x00	; 0
   102b8:	f9 01       	movw	r30, r18
   102ba:	20 81       	ld	r18, Z
   102bc:	2f 77       	andi	r18, 0x7F	; 127
   102be:	fc 01       	movw	r30, r24
   102c0:	20 83       	st	Z, r18
   102c2:	32 c0       	rjmp	.+100    	; 0x10328 <turnOffPWM+0xb8>
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
   102c4:	80 e8       	ldi	r24, 0x80	; 128
   102c6:	90 e0       	ldi	r25, 0x00	; 0
   102c8:	20 e8       	ldi	r18, 0x80	; 128
   102ca:	30 e0       	ldi	r19, 0x00	; 0
   102cc:	f9 01       	movw	r30, r18
   102ce:	20 81       	ld	r18, Z
   102d0:	2f 7d       	andi	r18, 0xDF	; 223
   102d2:	fc 01       	movw	r30, r24
   102d4:	20 83       	st	Z, r18
   102d6:	28 c0       	rjmp	.+80     	; 0x10328 <turnOffPWM+0xb8>
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
   102d8:	84 e4       	ldi	r24, 0x44	; 68
   102da:	90 e0       	ldi	r25, 0x00	; 0
   102dc:	24 e4       	ldi	r18, 0x44	; 68
   102de:	30 e0       	ldi	r19, 0x00	; 0
   102e0:	f9 01       	movw	r30, r18
   102e2:	20 81       	ld	r18, Z
   102e4:	2f 77       	andi	r18, 0x7F	; 127
   102e6:	fc 01       	movw	r30, r24
   102e8:	20 83       	st	Z, r18
   102ea:	1e c0       	rjmp	.+60     	; 0x10328 <turnOffPWM+0xb8>
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
   102ec:	84 e4       	ldi	r24, 0x44	; 68
   102ee:	90 e0       	ldi	r25, 0x00	; 0
   102f0:	24 e4       	ldi	r18, 0x44	; 68
   102f2:	30 e0       	ldi	r19, 0x00	; 0
   102f4:	f9 01       	movw	r30, r18
   102f6:	20 81       	ld	r18, Z
   102f8:	2f 7d       	andi	r18, 0xDF	; 223
   102fa:	fc 01       	movw	r30, r24
   102fc:	20 83       	st	Z, r18
   102fe:	14 c0       	rjmp	.+40     	; 0x10328 <turnOffPWM+0xb8>
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
   10300:	80 eb       	ldi	r24, 0xB0	; 176
   10302:	90 e0       	ldi	r25, 0x00	; 0
   10304:	20 eb       	ldi	r18, 0xB0	; 176
   10306:	30 e0       	ldi	r19, 0x00	; 0
   10308:	f9 01       	movw	r30, r18
   1030a:	20 81       	ld	r18, Z
   1030c:	2f 77       	andi	r18, 0x7F	; 127
   1030e:	fc 01       	movw	r30, r24
   10310:	20 83       	st	Z, r18
   10312:	0a c0       	rjmp	.+20     	; 0x10328 <turnOffPWM+0xb8>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
   10314:	80 eb       	ldi	r24, 0xB0	; 176
   10316:	90 e0       	ldi	r25, 0x00	; 0
   10318:	20 eb       	ldi	r18, 0xB0	; 176
   1031a:	30 e0       	ldi	r19, 0x00	; 0
   1031c:	f9 01       	movw	r30, r18
   1031e:	20 81       	ld	r18, Z
   10320:	2f 7d       	andi	r18, 0xDF	; 223
   10322:	fc 01       	movw	r30, r24
   10324:	20 83       	st	Z, r18
   10326:	00 00       	nop
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
		#endif
	}
}
   10328:	0f 90       	pop	r0
   1032a:	df 91       	pop	r29
   1032c:	cf 91       	pop	r28
   1032e:	08 95       	ret

00010330 <digitalWrite>:

void digitalWrite(uint8_t pin, uint8_t val)
{
   10330:	ef 92       	push	r14
   10332:	ff 92       	push	r15
   10334:	0f 93       	push	r16
   10336:	1f 93       	push	r17
   10338:	cf 93       	push	r28
   1033a:	df 93       	push	r29
   1033c:	cd b7       	in	r28, 0x3d	; 61
   1033e:	de b7       	in	r29, 0x3e	; 62
   10340:	65 97       	sbiw	r28, 0x15	; 21
   10342:	0f b6       	in	r0, 0x3f	; 63
   10344:	f8 94       	cli
   10346:	de bf       	out	0x3e, r29	; 62
   10348:	0f be       	out	0x3f, r0	; 63
   1034a:	cd bf       	out	0x3d, r28	; 61
   1034c:	8c 8b       	std	Y+20, r24	; 0x14
   1034e:	6d 8b       	std	Y+21, r22	; 0x15
	uint8_t timer = digitalPinToTimer(pin);
   10350:	8c 89       	ldd	r24, Y+20	; 0x14
   10352:	88 2f       	mov	r24, r24
   10354:	90 e0       	ldi	r25, 0x00	; 0
   10356:	8f 55       	subi	r24, 0x5F	; 95
   10358:	9d 4f       	sbci	r25, 0xFD	; 253
   1035a:	9a 83       	std	Y+2, r25	; 0x02
   1035c:	89 83       	std	Y+1, r24	; 0x01
   1035e:	89 81       	ldd	r24, Y+1	; 0x01
   10360:	9a 81       	ldd	r25, Y+2	; 0x02
   10362:	fc 01       	movw	r30, r24
   10364:	14 91       	lpm	r17, Z
   10366:	1b 83       	std	Y+3, r17	; 0x03
   10368:	8b 81       	ldd	r24, Y+3	; 0x03
   1036a:	8c 83       	std	Y+4, r24	; 0x04
	uint8_t bit = digitalPinToBitMask(pin);
   1036c:	8c 89       	ldd	r24, Y+20	; 0x14
   1036e:	88 2f       	mov	r24, r24
   10370:	90 e0       	ldi	r25, 0x00	; 0
   10372:	83 57       	subi	r24, 0x73	; 115
   10374:	9d 4f       	sbci	r25, 0xFD	; 253
   10376:	9e 83       	std	Y+6, r25	; 0x06
   10378:	8d 83       	std	Y+5, r24	; 0x05
   1037a:	8d 81       	ldd	r24, Y+5	; 0x05
   1037c:	9e 81       	ldd	r25, Y+6	; 0x06
   1037e:	fc 01       	movw	r30, r24
   10380:	14 91       	lpm	r17, Z
   10382:	1f 83       	std	Y+7, r17	; 0x07
   10384:	8f 81       	ldd	r24, Y+7	; 0x07
   10386:	88 87       	std	Y+8, r24	; 0x08
	uint8_t port = digitalPinToPort(pin);
   10388:	8c 89       	ldd	r24, Y+20	; 0x14
   1038a:	88 2f       	mov	r24, r24
   1038c:	90 e0       	ldi	r25, 0x00	; 0
   1038e:	87 58       	subi	r24, 0x87	; 135
   10390:	9d 4f       	sbci	r25, 0xFD	; 253
   10392:	9a 87       	std	Y+10, r25	; 0x0a
   10394:	89 87       	std	Y+9, r24	; 0x09
   10396:	89 85       	ldd	r24, Y+9	; 0x09
   10398:	9a 85       	ldd	r25, Y+10	; 0x0a
   1039a:	fc 01       	movw	r30, r24
   1039c:	14 91       	lpm	r17, Z
   1039e:	1b 87       	std	Y+11, r17	; 0x0b
   103a0:	8b 85       	ldd	r24, Y+11	; 0x0b
   103a2:	8c 87       	std	Y+12, r24	; 0x0c
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
   103a4:	8c 85       	ldd	r24, Y+12	; 0x0c
   103a6:	88 23       	and	r24, r24
   103a8:	09 f4       	brne	.+2      	; 0x103ac <digitalWrite+0x7c>
   103aa:	46 c0       	rjmp	.+140    	; 0x10438 <digitalWrite+0x108>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
   103ac:	8c 81       	ldd	r24, Y+4	; 0x04
   103ae:	88 23       	and	r24, r24
   103b0:	19 f0       	breq	.+6      	; 0x103b8 <digitalWrite+0x88>
   103b2:	8c 81       	ldd	r24, Y+4	; 0x04
   103b4:	0e 94 38 81 	call	0x10270	; 0x10270 <turnOffPWM>

	out = portOutputRegister(port);
   103b8:	8c 85       	ldd	r24, Y+12	; 0x0c
   103ba:	88 2f       	mov	r24, r24
   103bc:	90 e0       	ldi	r25, 0x00	; 0
   103be:	88 0f       	add	r24, r24
   103c0:	99 1f       	adc	r25, r25
   103c2:	8b 59       	subi	r24, 0x9B	; 155
   103c4:	9d 4f       	sbci	r25, 0xFD	; 253
   103c6:	9e 87       	std	Y+14, r25	; 0x0e
   103c8:	8d 87       	std	Y+13, r24	; 0x0d
   103ca:	8d 85       	ldd	r24, Y+13	; 0x0d
   103cc:	9e 85       	ldd	r25, Y+14	; 0x0e
   103ce:	8c 01       	movw	r16, r24
   103d0:	f8 01       	movw	r30, r16
   103d2:	e5 90       	lpm	r14, Z+
   103d4:	f4 90       	lpm	r15, Z
   103d6:	8f 01       	movw	r16, r30
   103d8:	f8 8a       	std	Y+16, r15	; 0x10
   103da:	ef 86       	std	Y+15, r14	; 0x0f
   103dc:	1e 87       	std	Y+14, r17	; 0x0e
   103de:	0d 87       	std	Y+13, r16	; 0x0d
   103e0:	8f 85       	ldd	r24, Y+15	; 0x0f
   103e2:	98 89       	ldd	r25, Y+16	; 0x10
   103e4:	9a 8b       	std	Y+18, r25	; 0x12
   103e6:	89 8b       	std	Y+17, r24	; 0x11

	uint8_t oldSREG = SREG;
   103e8:	8f e5       	ldi	r24, 0x5F	; 95
   103ea:	90 e0       	ldi	r25, 0x00	; 0
   103ec:	fc 01       	movw	r30, r24
   103ee:	80 81       	ld	r24, Z
   103f0:	8b 8b       	std	Y+19, r24	; 0x13
	cli();
   103f2:	f8 94       	cli

	if (val == LOW) {
   103f4:	8d 89       	ldd	r24, Y+21	; 0x15
   103f6:	88 23       	and	r24, r24
   103f8:	71 f4       	brne	.+28     	; 0x10416 <digitalWrite+0xe6>
		*out &= ~bit;
   103fa:	89 89       	ldd	r24, Y+17	; 0x11
   103fc:	9a 89       	ldd	r25, Y+18	; 0x12
   103fe:	fc 01       	movw	r30, r24
   10400:	80 81       	ld	r24, Z
   10402:	98 2f       	mov	r25, r24
   10404:	88 85       	ldd	r24, Y+8	; 0x08
   10406:	80 95       	com	r24
   10408:	89 23       	and	r24, r25
   1040a:	28 2f       	mov	r18, r24
   1040c:	89 89       	ldd	r24, Y+17	; 0x11
   1040e:	9a 89       	ldd	r25, Y+18	; 0x12
   10410:	fc 01       	movw	r30, r24
   10412:	20 83       	st	Z, r18
   10414:	0b c0       	rjmp	.+22     	; 0x1042c <digitalWrite+0xfc>
	} else {
		*out |= bit;
   10416:	89 89       	ldd	r24, Y+17	; 0x11
   10418:	9a 89       	ldd	r25, Y+18	; 0x12
   1041a:	fc 01       	movw	r30, r24
   1041c:	90 81       	ld	r25, Z
   1041e:	88 85       	ldd	r24, Y+8	; 0x08
   10420:	29 2f       	mov	r18, r25
   10422:	28 2b       	or	r18, r24
   10424:	89 89       	ldd	r24, Y+17	; 0x11
   10426:	9a 89       	ldd	r25, Y+18	; 0x12
   10428:	fc 01       	movw	r30, r24
   1042a:	20 83       	st	Z, r18
	}

	SREG = oldSREG;
   1042c:	8f e5       	ldi	r24, 0x5F	; 95
   1042e:	90 e0       	ldi	r25, 0x00	; 0
   10430:	2b 89       	ldd	r18, Y+19	; 0x13
   10432:	fc 01       	movw	r30, r24
   10434:	20 83       	st	Z, r18
   10436:	01 c0       	rjmp	.+2      	; 0x1043a <digitalWrite+0x10a>
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
   10438:	00 00       	nop
	} else {
		*out |= bit;
	}

	SREG = oldSREG;
}
   1043a:	65 96       	adiw	r28, 0x15	; 21
   1043c:	0f b6       	in	r0, 0x3f	; 63
   1043e:	f8 94       	cli
   10440:	de bf       	out	0x3e, r29	; 62
   10442:	0f be       	out	0x3f, r0	; 63
   10444:	cd bf       	out	0x3d, r28	; 61
   10446:	df 91       	pop	r29
   10448:	cf 91       	pop	r28
   1044a:	1f 91       	pop	r17
   1044c:	0f 91       	pop	r16
   1044e:	ff 90       	pop	r15
   10450:	ef 90       	pop	r14
   10452:	08 95       	ret

00010454 <digitalRead>:

int digitalRead(uint8_t pin)
{
   10454:	ef 92       	push	r14
   10456:	ff 92       	push	r15
   10458:	0f 93       	push	r16
   1045a:	1f 93       	push	r17
   1045c:	cf 93       	push	r28
   1045e:	df 93       	push	r29
   10460:	cd b7       	in	r28, 0x3d	; 61
   10462:	de b7       	in	r29, 0x3e	; 62
   10464:	61 97       	sbiw	r28, 0x11	; 17
   10466:	0f b6       	in	r0, 0x3f	; 63
   10468:	f8 94       	cli
   1046a:	de bf       	out	0x3e, r29	; 62
   1046c:	0f be       	out	0x3f, r0	; 63
   1046e:	cd bf       	out	0x3d, r28	; 61
   10470:	89 8b       	std	Y+17, r24	; 0x11
	uint8_t timer = digitalPinToTimer(pin);
   10472:	89 89       	ldd	r24, Y+17	; 0x11
   10474:	88 2f       	mov	r24, r24
   10476:	90 e0       	ldi	r25, 0x00	; 0
   10478:	8f 55       	subi	r24, 0x5F	; 95
   1047a:	9d 4f       	sbci	r25, 0xFD	; 253
   1047c:	9a 83       	std	Y+2, r25	; 0x02
   1047e:	89 83       	std	Y+1, r24	; 0x01
   10480:	89 81       	ldd	r24, Y+1	; 0x01
   10482:	9a 81       	ldd	r25, Y+2	; 0x02
   10484:	fc 01       	movw	r30, r24
   10486:	14 91       	lpm	r17, Z
   10488:	1b 83       	std	Y+3, r17	; 0x03
   1048a:	8b 81       	ldd	r24, Y+3	; 0x03
   1048c:	8c 83       	std	Y+4, r24	; 0x04
	uint8_t bit = digitalPinToBitMask(pin);
   1048e:	89 89       	ldd	r24, Y+17	; 0x11
   10490:	88 2f       	mov	r24, r24
   10492:	90 e0       	ldi	r25, 0x00	; 0
   10494:	83 57       	subi	r24, 0x73	; 115
   10496:	9d 4f       	sbci	r25, 0xFD	; 253
   10498:	9e 83       	std	Y+6, r25	; 0x06
   1049a:	8d 83       	std	Y+5, r24	; 0x05
   1049c:	8d 81       	ldd	r24, Y+5	; 0x05
   1049e:	9e 81       	ldd	r25, Y+6	; 0x06
   104a0:	fc 01       	movw	r30, r24
   104a2:	14 91       	lpm	r17, Z
   104a4:	1f 83       	std	Y+7, r17	; 0x07
   104a6:	8f 81       	ldd	r24, Y+7	; 0x07
   104a8:	88 87       	std	Y+8, r24	; 0x08
	uint8_t port = digitalPinToPort(pin);
   104aa:	89 89       	ldd	r24, Y+17	; 0x11
   104ac:	88 2f       	mov	r24, r24
   104ae:	90 e0       	ldi	r25, 0x00	; 0
   104b0:	87 58       	subi	r24, 0x87	; 135
   104b2:	9d 4f       	sbci	r25, 0xFD	; 253
   104b4:	9a 87       	std	Y+10, r25	; 0x0a
   104b6:	89 87       	std	Y+9, r24	; 0x09
   104b8:	89 85       	ldd	r24, Y+9	; 0x09
   104ba:	9a 85       	ldd	r25, Y+10	; 0x0a
   104bc:	fc 01       	movw	r30, r24
   104be:	14 91       	lpm	r17, Z
   104c0:	1b 87       	std	Y+11, r17	; 0x0b
   104c2:	8b 85       	ldd	r24, Y+11	; 0x0b
   104c4:	8c 87       	std	Y+12, r24	; 0x0c

	if (port == NOT_A_PIN) return LOW;
   104c6:	8c 85       	ldd	r24, Y+12	; 0x0c
   104c8:	88 23       	and	r24, r24
   104ca:	19 f4       	brne	.+6      	; 0x104d2 <digitalRead+0x7e>
   104cc:	80 e0       	ldi	r24, 0x00	; 0
   104ce:	90 e0       	ldi	r25, 0x00	; 0
   104d0:	27 c0       	rjmp	.+78     	; 0x10520 <digitalRead+0xcc>

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
   104d2:	8c 81       	ldd	r24, Y+4	; 0x04
   104d4:	88 23       	and	r24, r24
   104d6:	19 f0       	breq	.+6      	; 0x104de <digitalRead+0x8a>
   104d8:	8c 81       	ldd	r24, Y+4	; 0x04
   104da:	0e 94 38 81 	call	0x10270	; 0x10270 <turnOffPWM>

	if (*portInputRegister(port) & bit) return HIGH;
   104de:	8c 85       	ldd	r24, Y+12	; 0x0c
   104e0:	88 2f       	mov	r24, r24
   104e2:	90 e0       	ldi	r25, 0x00	; 0
   104e4:	88 0f       	add	r24, r24
   104e6:	99 1f       	adc	r25, r25
   104e8:	81 59       	subi	r24, 0x91	; 145
   104ea:	9d 4f       	sbci	r25, 0xFD	; 253
   104ec:	9e 87       	std	Y+14, r25	; 0x0e
   104ee:	8d 87       	std	Y+13, r24	; 0x0d
   104f0:	8d 85       	ldd	r24, Y+13	; 0x0d
   104f2:	9e 85       	ldd	r25, Y+14	; 0x0e
   104f4:	8c 01       	movw	r16, r24
   104f6:	f8 01       	movw	r30, r16
   104f8:	e5 90       	lpm	r14, Z+
   104fa:	f4 90       	lpm	r15, Z
   104fc:	8f 01       	movw	r16, r30
   104fe:	f8 8a       	std	Y+16, r15	; 0x10
   10500:	ef 86       	std	Y+15, r14	; 0x0f
   10502:	1e 87       	std	Y+14, r17	; 0x0e
   10504:	0d 87       	std	Y+13, r16	; 0x0d
   10506:	8f 85       	ldd	r24, Y+15	; 0x0f
   10508:	98 89       	ldd	r25, Y+16	; 0x10
   1050a:	fc 01       	movw	r30, r24
   1050c:	90 81       	ld	r25, Z
   1050e:	88 85       	ldd	r24, Y+8	; 0x08
   10510:	89 23       	and	r24, r25
   10512:	88 23       	and	r24, r24
   10514:	19 f0       	breq	.+6      	; 0x1051c <digitalRead+0xc8>
   10516:	81 e0       	ldi	r24, 0x01	; 1
   10518:	90 e0       	ldi	r25, 0x00	; 0
   1051a:	02 c0       	rjmp	.+4      	; 0x10520 <digitalRead+0xcc>
	return LOW;
   1051c:	80 e0       	ldi	r24, 0x00	; 0
   1051e:	90 e0       	ldi	r25, 0x00	; 0
}
   10520:	61 96       	adiw	r28, 0x11	; 17
   10522:	0f b6       	in	r0, 0x3f	; 63
   10524:	f8 94       	cli
   10526:	de bf       	out	0x3e, r29	; 62
   10528:	0f be       	out	0x3f, r0	; 63
   1052a:	cd bf       	out	0x3d, r28	; 61
   1052c:	df 91       	pop	r29
   1052e:	cf 91       	pop	r28
   10530:	1f 91       	pop	r17
   10532:	0f 91       	pop	r16
   10534:	ff 90       	pop	r15
   10536:	ef 90       	pop	r14
   10538:	08 95       	ret

0001053a <pulseIn>:
/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
 * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
 * to 3 minutes in length, but must be called at least a few dozen microseconds
 * before the start of the pulse. */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
   1053a:	ef 92       	push	r14
   1053c:	ff 92       	push	r15
   1053e:	0f 93       	push	r16
   10540:	1f 93       	push	r17
   10542:	cf 93       	push	r28
   10544:	df 93       	push	r29
   10546:	cd b7       	in	r28, 0x3d	; 61
   10548:	de b7       	in	r29, 0x3e	; 62
   1054a:	a7 97       	sbiw	r28, 0x27	; 39
   1054c:	0f b6       	in	r0, 0x3f	; 63
   1054e:	f8 94       	cli
   10550:	de bf       	out	0x3e, r29	; 62
   10552:	0f be       	out	0x3f, r0	; 63
   10554:	cd bf       	out	0x3d, r28	; 61
   10556:	8a a3       	std	Y+34, r24	; 0x22
   10558:	6b a3       	std	Y+35, r22	; 0x23
   1055a:	2c a3       	std	Y+36, r18	; 0x24
   1055c:	3d a3       	std	Y+37, r19	; 0x25
   1055e:	4e a3       	std	Y+38, r20	; 0x26
   10560:	5f a3       	std	Y+39, r21	; 0x27
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
   10562:	8a a1       	ldd	r24, Y+34	; 0x22
   10564:	88 2f       	mov	r24, r24
   10566:	90 e0       	ldi	r25, 0x00	; 0
   10568:	83 57       	subi	r24, 0x73	; 115
   1056a:	9d 4f       	sbci	r25, 0xFD	; 253
   1056c:	9a 87       	std	Y+10, r25	; 0x0a
   1056e:	89 87       	std	Y+9, r24	; 0x09
   10570:	89 85       	ldd	r24, Y+9	; 0x09
   10572:	9a 85       	ldd	r25, Y+10	; 0x0a
   10574:	fc 01       	movw	r30, r24
   10576:	14 91       	lpm	r17, Z
   10578:	1b 87       	std	Y+11, r17	; 0x0b
   1057a:	8b 85       	ldd	r24, Y+11	; 0x0b
   1057c:	8c 87       	std	Y+12, r24	; 0x0c
	uint8_t port = digitalPinToPort(pin);
   1057e:	8a a1       	ldd	r24, Y+34	; 0x22
   10580:	88 2f       	mov	r24, r24
   10582:	90 e0       	ldi	r25, 0x00	; 0
   10584:	87 58       	subi	r24, 0x87	; 135
   10586:	9d 4f       	sbci	r25, 0xFD	; 253
   10588:	9e 87       	std	Y+14, r25	; 0x0e
   1058a:	8d 87       	std	Y+13, r24	; 0x0d
   1058c:	8d 85       	ldd	r24, Y+13	; 0x0d
   1058e:	9e 85       	ldd	r25, Y+14	; 0x0e
   10590:	fc 01       	movw	r30, r24
   10592:	14 91       	lpm	r17, Z
   10594:	1f 87       	std	Y+15, r17	; 0x0f
   10596:	8f 85       	ldd	r24, Y+15	; 0x0f
   10598:	88 8b       	std	Y+16, r24	; 0x10
	uint8_t stateMask = (state ? bit : 0);
   1059a:	8b a1       	ldd	r24, Y+35	; 0x23
   1059c:	88 23       	and	r24, r24
   1059e:	11 f0       	breq	.+4      	; 0x105a4 <pulseIn+0x6a>
   105a0:	8c 85       	ldd	r24, Y+12	; 0x0c
   105a2:	01 c0       	rjmp	.+2      	; 0x105a6 <pulseIn+0x6c>
   105a4:	80 e0       	ldi	r24, 0x00	; 0
   105a6:	89 8b       	std	Y+17, r24	; 0x11
	unsigned long width = 0; // keep initialization out of time critical area
   105a8:	19 82       	std	Y+1, r1	; 0x01
   105aa:	1a 82       	std	Y+2, r1	; 0x02
   105ac:	1b 82       	std	Y+3, r1	; 0x03
   105ae:	1c 82       	std	Y+4, r1	; 0x04
	
	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes 16 clock cycles per iteration.
	unsigned long numloops = 0;
   105b0:	1d 82       	std	Y+5, r1	; 0x05
   105b2:	1e 82       	std	Y+6, r1	; 0x06
   105b4:	1f 82       	std	Y+7, r1	; 0x07
   105b6:	18 86       	std	Y+8, r1	; 0x08
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
   105b8:	8c a1       	ldd	r24, Y+36	; 0x24
   105ba:	9d a1       	ldd	r25, Y+37	; 0x25
   105bc:	ae a1       	ldd	r26, Y+38	; 0x26
   105be:	bf a1       	ldd	r27, Y+39	; 0x27
   105c0:	88 0f       	add	r24, r24
   105c2:	99 1f       	adc	r25, r25
   105c4:	aa 1f       	adc	r26, r26
   105c6:	bb 1f       	adc	r27, r27
   105c8:	88 0f       	add	r24, r24
   105ca:	99 1f       	adc	r25, r25
   105cc:	aa 1f       	adc	r26, r26
   105ce:	bb 1f       	adc	r27, r27
   105d0:	88 0f       	add	r24, r24
   105d2:	99 1f       	adc	r25, r25
   105d4:	aa 1f       	adc	r26, r26
   105d6:	bb 1f       	adc	r27, r27
   105d8:	88 0f       	add	r24, r24
   105da:	99 1f       	adc	r25, r25
   105dc:	aa 1f       	adc	r26, r26
   105de:	bb 1f       	adc	r27, r27
   105e0:	68 94       	set
   105e2:	13 f8       	bld	r1, 3
   105e4:	b6 95       	lsr	r27
   105e6:	a7 95       	ror	r26
   105e8:	97 95       	ror	r25
   105ea:	87 95       	ror	r24
   105ec:	16 94       	lsr	r1
   105ee:	d1 f7       	brne	.-12     	; 0x105e4 <pulseIn+0xaa>
   105f0:	8a 8b       	std	Y+18, r24	; 0x12
   105f2:	9b 8b       	std	Y+19, r25	; 0x13
   105f4:	ac 8b       	std	Y+20, r26	; 0x14
   105f6:	bd 8b       	std	Y+21, r27	; 0x15
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
   105f8:	20 c0       	rjmp	.+64     	; 0x1063a <pulseIn+0x100>
		if (numloops++ == maxloops)
   105fa:	61 e0       	ldi	r22, 0x01	; 1
   105fc:	2d 81       	ldd	r18, Y+5	; 0x05
   105fe:	3e 81       	ldd	r19, Y+6	; 0x06
   10600:	4f 81       	ldd	r20, Y+7	; 0x07
   10602:	58 85       	ldd	r21, Y+8	; 0x08
   10604:	8a 89       	ldd	r24, Y+18	; 0x12
   10606:	9b 89       	ldd	r25, Y+19	; 0x13
   10608:	ac 89       	ldd	r26, Y+20	; 0x14
   1060a:	bd 89       	ldd	r27, Y+21	; 0x15
   1060c:	28 17       	cp	r18, r24
   1060e:	39 07       	cpc	r19, r25
   10610:	4a 07       	cpc	r20, r26
   10612:	5b 07       	cpc	r21, r27
   10614:	09 f0       	breq	.+2      	; 0x10618 <pulseIn+0xde>
   10616:	60 e0       	ldi	r22, 0x00	; 0
   10618:	8d 81       	ldd	r24, Y+5	; 0x05
   1061a:	9e 81       	ldd	r25, Y+6	; 0x06
   1061c:	af 81       	ldd	r26, Y+7	; 0x07
   1061e:	b8 85       	ldd	r27, Y+8	; 0x08
   10620:	01 96       	adiw	r24, 0x01	; 1
   10622:	a1 1d       	adc	r26, r1
   10624:	b1 1d       	adc	r27, r1
   10626:	8d 83       	std	Y+5, r24	; 0x05
   10628:	9e 83       	std	Y+6, r25	; 0x06
   1062a:	af 83       	std	Y+7, r26	; 0x07
   1062c:	b8 87       	std	Y+8, r27	; 0x08
   1062e:	66 23       	and	r22, r22
   10630:	21 f0       	breq	.+8      	; 0x1063a <pulseIn+0x100>
			return 0;
   10632:	80 e0       	ldi	r24, 0x00	; 0
   10634:	90 e0       	ldi	r25, 0x00	; 0
   10636:	dc 01       	movw	r26, r24
   10638:	d2 c0       	rjmp	.+420    	; 0x107de <pulseIn+0x2a4>
	// the initial loop; it takes 16 clock cycles per iteration.
	unsigned long numloops = 0;
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
   1063a:	88 89       	ldd	r24, Y+16	; 0x10
   1063c:	88 2f       	mov	r24, r24
   1063e:	90 e0       	ldi	r25, 0x00	; 0
   10640:	88 0f       	add	r24, r24
   10642:	99 1f       	adc	r25, r25
   10644:	81 59       	subi	r24, 0x91	; 145
   10646:	9d 4f       	sbci	r25, 0xFD	; 253
   10648:	9f 8b       	std	Y+23, r25	; 0x17
   1064a:	8e 8b       	std	Y+22, r24	; 0x16
   1064c:	8e 89       	ldd	r24, Y+22	; 0x16
   1064e:	9f 89       	ldd	r25, Y+23	; 0x17
   10650:	8c 01       	movw	r16, r24
   10652:	f8 01       	movw	r30, r16
   10654:	e5 90       	lpm	r14, Z+
   10656:	f4 90       	lpm	r15, Z
   10658:	8f 01       	movw	r16, r30
   1065a:	f9 8e       	std	Y+25, r15	; 0x19
   1065c:	e8 8e       	std	Y+24, r14	; 0x18
   1065e:	1f 8b       	std	Y+23, r17	; 0x17
   10660:	0e 8b       	std	Y+22, r16	; 0x16
   10662:	88 8d       	ldd	r24, Y+24	; 0x18
   10664:	99 8d       	ldd	r25, Y+25	; 0x19
   10666:	fc 01       	movw	r30, r24
   10668:	90 81       	ld	r25, Z
   1066a:	8c 85       	ldd	r24, Y+12	; 0x0c
   1066c:	98 23       	and	r25, r24
   1066e:	89 89       	ldd	r24, Y+17	; 0x11
   10670:	98 17       	cp	r25, r24
   10672:	09 f4       	brne	.+2      	; 0x10676 <pulseIn+0x13c>
   10674:	c2 cf       	rjmp	.-124    	; 0x105fa <pulseIn+0xc0>
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to start
	while ((*portInputRegister(port) & bit) != stateMask)
   10676:	20 c0       	rjmp	.+64     	; 0x106b8 <pulseIn+0x17e>
		if (numloops++ == maxloops)
   10678:	61 e0       	ldi	r22, 0x01	; 1
   1067a:	2d 81       	ldd	r18, Y+5	; 0x05
   1067c:	3e 81       	ldd	r19, Y+6	; 0x06
   1067e:	4f 81       	ldd	r20, Y+7	; 0x07
   10680:	58 85       	ldd	r21, Y+8	; 0x08
   10682:	8a 89       	ldd	r24, Y+18	; 0x12
   10684:	9b 89       	ldd	r25, Y+19	; 0x13
   10686:	ac 89       	ldd	r26, Y+20	; 0x14
   10688:	bd 89       	ldd	r27, Y+21	; 0x15
   1068a:	28 17       	cp	r18, r24
   1068c:	39 07       	cpc	r19, r25
   1068e:	4a 07       	cpc	r20, r26
   10690:	5b 07       	cpc	r21, r27
   10692:	09 f0       	breq	.+2      	; 0x10696 <pulseIn+0x15c>
   10694:	60 e0       	ldi	r22, 0x00	; 0
   10696:	8d 81       	ldd	r24, Y+5	; 0x05
   10698:	9e 81       	ldd	r25, Y+6	; 0x06
   1069a:	af 81       	ldd	r26, Y+7	; 0x07
   1069c:	b8 85       	ldd	r27, Y+8	; 0x08
   1069e:	01 96       	adiw	r24, 0x01	; 1
   106a0:	a1 1d       	adc	r26, r1
   106a2:	b1 1d       	adc	r27, r1
   106a4:	8d 83       	std	Y+5, r24	; 0x05
   106a6:	9e 83       	std	Y+6, r25	; 0x06
   106a8:	af 83       	std	Y+7, r26	; 0x07
   106aa:	b8 87       	std	Y+8, r27	; 0x08
   106ac:	66 23       	and	r22, r22
   106ae:	21 f0       	breq	.+8      	; 0x106b8 <pulseIn+0x17e>
			return 0;
   106b0:	80 e0       	ldi	r24, 0x00	; 0
   106b2:	90 e0       	ldi	r25, 0x00	; 0
   106b4:	dc 01       	movw	r26, r24
   106b6:	93 c0       	rjmp	.+294    	; 0x107de <pulseIn+0x2a4>
	while ((*portInputRegister(port) & bit) == stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to start
	while ((*portInputRegister(port) & bit) != stateMask)
   106b8:	88 89       	ldd	r24, Y+16	; 0x10
   106ba:	88 2f       	mov	r24, r24
   106bc:	90 e0       	ldi	r25, 0x00	; 0
   106be:	88 0f       	add	r24, r24
   106c0:	99 1f       	adc	r25, r25
   106c2:	81 59       	subi	r24, 0x91	; 145
   106c4:	9d 4f       	sbci	r25, 0xFD	; 253
   106c6:	9b 8f       	std	Y+27, r25	; 0x1b
   106c8:	8a 8f       	std	Y+26, r24	; 0x1a
   106ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
   106cc:	9b 8d       	ldd	r25, Y+27	; 0x1b
   106ce:	8c 01       	movw	r16, r24
   106d0:	f8 01       	movw	r30, r16
   106d2:	e5 90       	lpm	r14, Z+
   106d4:	f4 90       	lpm	r15, Z
   106d6:	8f 01       	movw	r16, r30
   106d8:	fd 8e       	std	Y+29, r15	; 0x1d
   106da:	ec 8e       	std	Y+28, r14	; 0x1c
   106dc:	1b 8f       	std	Y+27, r17	; 0x1b
   106de:	0a 8f       	std	Y+26, r16	; 0x1a
   106e0:	8c 8d       	ldd	r24, Y+28	; 0x1c
   106e2:	9d 8d       	ldd	r25, Y+29	; 0x1d
   106e4:	fc 01       	movw	r30, r24
   106e6:	90 81       	ld	r25, Z
   106e8:	8c 85       	ldd	r24, Y+12	; 0x0c
   106ea:	98 23       	and	r25, r24
   106ec:	89 89       	ldd	r24, Y+17	; 0x11
   106ee:	98 17       	cp	r25, r24
   106f0:	09 f0       	breq	.+2      	; 0x106f4 <pulseIn+0x1ba>
   106f2:	c2 cf       	rjmp	.-124    	; 0x10678 <pulseIn+0x13e>
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask) {
   106f4:	2b c0       	rjmp	.+86     	; 0x1074c <pulseIn+0x212>
		if (numloops++ == maxloops)
   106f6:	61 e0       	ldi	r22, 0x01	; 1
   106f8:	2d 81       	ldd	r18, Y+5	; 0x05
   106fa:	3e 81       	ldd	r19, Y+6	; 0x06
   106fc:	4f 81       	ldd	r20, Y+7	; 0x07
   106fe:	58 85       	ldd	r21, Y+8	; 0x08
   10700:	8a 89       	ldd	r24, Y+18	; 0x12
   10702:	9b 89       	ldd	r25, Y+19	; 0x13
   10704:	ac 89       	ldd	r26, Y+20	; 0x14
   10706:	bd 89       	ldd	r27, Y+21	; 0x15
   10708:	28 17       	cp	r18, r24
   1070a:	39 07       	cpc	r19, r25
   1070c:	4a 07       	cpc	r20, r26
   1070e:	5b 07       	cpc	r21, r27
   10710:	09 f0       	breq	.+2      	; 0x10714 <pulseIn+0x1da>
   10712:	60 e0       	ldi	r22, 0x00	; 0
   10714:	8d 81       	ldd	r24, Y+5	; 0x05
   10716:	9e 81       	ldd	r25, Y+6	; 0x06
   10718:	af 81       	ldd	r26, Y+7	; 0x07
   1071a:	b8 85       	ldd	r27, Y+8	; 0x08
   1071c:	01 96       	adiw	r24, 0x01	; 1
   1071e:	a1 1d       	adc	r26, r1
   10720:	b1 1d       	adc	r27, r1
   10722:	8d 83       	std	Y+5, r24	; 0x05
   10724:	9e 83       	std	Y+6, r25	; 0x06
   10726:	af 83       	std	Y+7, r26	; 0x07
   10728:	b8 87       	std	Y+8, r27	; 0x08
   1072a:	66 23       	and	r22, r22
   1072c:	21 f0       	breq	.+8      	; 0x10736 <pulseIn+0x1fc>
			return 0;
   1072e:	80 e0       	ldi	r24, 0x00	; 0
   10730:	90 e0       	ldi	r25, 0x00	; 0
   10732:	dc 01       	movw	r26, r24
   10734:	54 c0       	rjmp	.+168    	; 0x107de <pulseIn+0x2a4>
		width++;
   10736:	89 81       	ldd	r24, Y+1	; 0x01
   10738:	9a 81       	ldd	r25, Y+2	; 0x02
   1073a:	ab 81       	ldd	r26, Y+3	; 0x03
   1073c:	bc 81       	ldd	r27, Y+4	; 0x04
   1073e:	01 96       	adiw	r24, 0x01	; 1
   10740:	a1 1d       	adc	r26, r1
   10742:	b1 1d       	adc	r27, r1
   10744:	89 83       	std	Y+1, r24	; 0x01
   10746:	9a 83       	std	Y+2, r25	; 0x02
   10748:	ab 83       	std	Y+3, r26	; 0x03
   1074a:	bc 83       	std	Y+4, r27	; 0x04
	while ((*portInputRegister(port) & bit) != stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask) {
   1074c:	88 89       	ldd	r24, Y+16	; 0x10
   1074e:	88 2f       	mov	r24, r24
   10750:	90 e0       	ldi	r25, 0x00	; 0
   10752:	88 0f       	add	r24, r24
   10754:	99 1f       	adc	r25, r25
   10756:	81 59       	subi	r24, 0x91	; 145
   10758:	9d 4f       	sbci	r25, 0xFD	; 253
   1075a:	9f 8f       	std	Y+31, r25	; 0x1f
   1075c:	8e 8f       	std	Y+30, r24	; 0x1e
   1075e:	8e 8d       	ldd	r24, Y+30	; 0x1e
   10760:	9f 8d       	ldd	r25, Y+31	; 0x1f
   10762:	8c 01       	movw	r16, r24
   10764:	f8 01       	movw	r30, r16
   10766:	e5 90       	lpm	r14, Z+
   10768:	f4 90       	lpm	r15, Z
   1076a:	8f 01       	movw	r16, r30
   1076c:	f9 a2       	std	Y+33, r15	; 0x21
   1076e:	e8 a2       	std	Y+32, r14	; 0x20
   10770:	1f 8f       	std	Y+31, r17	; 0x1f
   10772:	0e 8f       	std	Y+30, r16	; 0x1e
   10774:	88 a1       	ldd	r24, Y+32	; 0x20
   10776:	99 a1       	ldd	r25, Y+33	; 0x21
   10778:	fc 01       	movw	r30, r24
   1077a:	90 81       	ld	r25, Z
   1077c:	8c 85       	ldd	r24, Y+12	; 0x0c
   1077e:	98 23       	and	r25, r24
   10780:	89 89       	ldd	r24, Y+17	; 0x11
   10782:	98 17       	cp	r25, r24
   10784:	09 f4       	brne	.+2      	; 0x10788 <pulseIn+0x24e>
   10786:	b7 cf       	rjmp	.-146    	; 0x106f6 <pulseIn+0x1bc>

	// convert the reading to microseconds. The loop has been determined
	// to be 20 clock cycles long and have about 16 clocks between the edge
	// and the start of the loop. There will be some error introduced by
	// the interrupt handlers.
	return clockCyclesToMicroseconds(width * 21 + 16); 
   10788:	29 81       	ldd	r18, Y+1	; 0x01
   1078a:	3a 81       	ldd	r19, Y+2	; 0x02
   1078c:	4b 81       	ldd	r20, Y+3	; 0x03
   1078e:	5c 81       	ldd	r21, Y+4	; 0x04
   10790:	da 01       	movw	r26, r20
   10792:	c9 01       	movw	r24, r18
   10794:	88 0f       	add	r24, r24
   10796:	99 1f       	adc	r25, r25
   10798:	aa 1f       	adc	r26, r26
   1079a:	bb 1f       	adc	r27, r27
   1079c:	88 0f       	add	r24, r24
   1079e:	99 1f       	adc	r25, r25
   107a0:	aa 1f       	adc	r26, r26
   107a2:	bb 1f       	adc	r27, r27
   107a4:	7c 01       	movw	r14, r24
   107a6:	8d 01       	movw	r16, r26
   107a8:	ee 0c       	add	r14, r14
   107aa:	ff 1c       	adc	r15, r15
   107ac:	00 1f       	adc	r16, r16
   107ae:	11 1f       	adc	r17, r17
   107b0:	ee 0c       	add	r14, r14
   107b2:	ff 1c       	adc	r15, r15
   107b4:	00 1f       	adc	r16, r16
   107b6:	11 1f       	adc	r17, r17
   107b8:	8e 0d       	add	r24, r14
   107ba:	9f 1d       	adc	r25, r15
   107bc:	a0 1f       	adc	r26, r16
   107be:	b1 1f       	adc	r27, r17
   107c0:	82 0f       	add	r24, r18
   107c2:	93 1f       	adc	r25, r19
   107c4:	a4 1f       	adc	r26, r20
   107c6:	b5 1f       	adc	r27, r21
   107c8:	40 96       	adiw	r24, 0x10	; 16
   107ca:	a1 1d       	adc	r26, r1
   107cc:	b1 1d       	adc	r27, r1
   107ce:	68 94       	set
   107d0:	13 f8       	bld	r1, 3
   107d2:	b6 95       	lsr	r27
   107d4:	a7 95       	ror	r26
   107d6:	97 95       	ror	r25
   107d8:	87 95       	ror	r24
   107da:	16 94       	lsr	r1
   107dc:	d1 f7       	brne	.-12     	; 0x107d2 <pulseIn+0x298>
}
   107de:	bc 01       	movw	r22, r24
   107e0:	cd 01       	movw	r24, r26
   107e2:	a7 96       	adiw	r28, 0x27	; 39
   107e4:	0f b6       	in	r0, 0x3f	; 63
   107e6:	f8 94       	cli
   107e8:	de bf       	out	0x3e, r29	; 62
   107ea:	0f be       	out	0x3f, r0	; 63
   107ec:	cd bf       	out	0x3d, r28	; 61
   107ee:	df 91       	pop	r29
   107f0:	cf 91       	pop	r28
   107f2:	1f 91       	pop	r17
   107f4:	0f 91       	pop	r16
   107f6:	ff 90       	pop	r15
   107f8:	ef 90       	pop	r14
   107fa:	08 95       	ret

000107fc <shiftIn>:
  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
*/

#include "wiring_private.h"

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
   107fc:	cf 93       	push	r28
   107fe:	df 93       	push	r29
   10800:	00 d0       	rcall	.+0      	; 0x10802 <shiftIn+0x6>
   10802:	00 d0       	rcall	.+0      	; 0x10804 <shiftIn+0x8>
   10804:	1f 92       	push	r1
   10806:	cd b7       	in	r28, 0x3d	; 61
   10808:	de b7       	in	r29, 0x3e	; 62
   1080a:	8b 83       	std	Y+3, r24	; 0x03
   1080c:	6c 83       	std	Y+4, r22	; 0x04
   1080e:	4d 83       	std	Y+5, r20	; 0x05
	uint8_t value = 0;
   10810:	19 82       	std	Y+1, r1	; 0x01
	uint8_t i;

	for (i = 0; i < 8; ++i) {
   10812:	1a 82       	std	Y+2, r1	; 0x02
   10814:	34 c0       	rjmp	.+104    	; 0x1087e <shiftIn+0x82>
		digitalWrite(clockPin, HIGH);
   10816:	61 e0       	ldi	r22, 0x01	; 1
   10818:	8c 81       	ldd	r24, Y+4	; 0x04
   1081a:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
		if (bitOrder == LSBFIRST)
   1081e:	8d 81       	ldd	r24, Y+5	; 0x05
   10820:	88 23       	and	r24, r24
   10822:	89 f4       	brne	.+34     	; 0x10846 <shiftIn+0x4a>
			value |= digitalRead(dataPin) << i;
   10824:	8b 81       	ldd	r24, Y+3	; 0x03
   10826:	0e 94 2a 82 	call	0x10454	; 0x10454 <digitalRead>
   1082a:	2a 81       	ldd	r18, Y+2	; 0x02
   1082c:	22 2f       	mov	r18, r18
   1082e:	30 e0       	ldi	r19, 0x00	; 0
   10830:	02 2e       	mov	r0, r18
   10832:	02 c0       	rjmp	.+4      	; 0x10838 <shiftIn+0x3c>
   10834:	88 0f       	add	r24, r24
   10836:	99 1f       	adc	r25, r25
   10838:	0a 94       	dec	r0
   1083a:	e2 f7       	brpl	.-8      	; 0x10834 <shiftIn+0x38>
   1083c:	98 2f       	mov	r25, r24
   1083e:	89 81       	ldd	r24, Y+1	; 0x01
   10840:	89 2b       	or	r24, r25
   10842:	89 83       	std	Y+1, r24	; 0x01
   10844:	15 c0       	rjmp	.+42     	; 0x10870 <shiftIn+0x74>
		else
			value |= digitalRead(dataPin) << (7 - i);
   10846:	8b 81       	ldd	r24, Y+3	; 0x03
   10848:	0e 94 2a 82 	call	0x10454	; 0x10454 <digitalRead>
   1084c:	2a 81       	ldd	r18, Y+2	; 0x02
   1084e:	22 2f       	mov	r18, r18
   10850:	30 e0       	ldi	r19, 0x00	; 0
   10852:	47 e0       	ldi	r20, 0x07	; 7
   10854:	50 e0       	ldi	r21, 0x00	; 0
   10856:	ba 01       	movw	r22, r20
   10858:	62 1b       	sub	r22, r18
   1085a:	73 0b       	sbc	r23, r19
   1085c:	9b 01       	movw	r18, r22
   1085e:	02 c0       	rjmp	.+4      	; 0x10864 <shiftIn+0x68>
   10860:	88 0f       	add	r24, r24
   10862:	99 1f       	adc	r25, r25
   10864:	2a 95       	dec	r18
   10866:	e2 f7       	brpl	.-8      	; 0x10860 <shiftIn+0x64>
   10868:	98 2f       	mov	r25, r24
   1086a:	89 81       	ldd	r24, Y+1	; 0x01
   1086c:	89 2b       	or	r24, r25
   1086e:	89 83       	std	Y+1, r24	; 0x01
		digitalWrite(clockPin, LOW);
   10870:	60 e0       	ldi	r22, 0x00	; 0
   10872:	8c 81       	ldd	r24, Y+4	; 0x04
   10874:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
	uint8_t value = 0;
	uint8_t i;

	for (i = 0; i < 8; ++i) {
   10878:	8a 81       	ldd	r24, Y+2	; 0x02
   1087a:	8f 5f       	subi	r24, 0xFF	; 255
   1087c:	8a 83       	std	Y+2, r24	; 0x02
   1087e:	8a 81       	ldd	r24, Y+2	; 0x02
   10880:	88 30       	cpi	r24, 0x08	; 8
   10882:	48 f2       	brcs	.-110    	; 0x10816 <shiftIn+0x1a>
			value |= digitalRead(dataPin) << i;
		else
			value |= digitalRead(dataPin) << (7 - i);
		digitalWrite(clockPin, LOW);
	}
	return value;
   10884:	89 81       	ldd	r24, Y+1	; 0x01
}
   10886:	0f 90       	pop	r0
   10888:	0f 90       	pop	r0
   1088a:	0f 90       	pop	r0
   1088c:	0f 90       	pop	r0
   1088e:	0f 90       	pop	r0
   10890:	df 91       	pop	r29
   10892:	cf 91       	pop	r28
   10894:	08 95       	ret

00010896 <shiftOut>:

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
   10896:	cf 93       	push	r28
   10898:	df 93       	push	r29
   1089a:	00 d0       	rcall	.+0      	; 0x1089c <shiftOut+0x6>
   1089c:	00 d0       	rcall	.+0      	; 0x1089e <shiftOut+0x8>
   1089e:	1f 92       	push	r1
   108a0:	cd b7       	in	r28, 0x3d	; 61
   108a2:	de b7       	in	r29, 0x3e	; 62
   108a4:	8a 83       	std	Y+2, r24	; 0x02
   108a6:	6b 83       	std	Y+3, r22	; 0x03
   108a8:	4c 83       	std	Y+4, r20	; 0x04
   108aa:	2d 83       	std	Y+5, r18	; 0x05
	uint8_t i;

	for (i = 0; i < 8; i++)  {
   108ac:	19 82       	std	Y+1, r1	; 0x01
   108ae:	41 c0       	rjmp	.+130    	; 0x10932 <shiftOut+0x9c>
		if (bitOrder == LSBFIRST)
   108b0:	8c 81       	ldd	r24, Y+4	; 0x04
   108b2:	88 23       	and	r24, r24
   108b4:	b9 f4       	brne	.+46     	; 0x108e4 <shiftOut+0x4e>
			digitalWrite(dataPin, !!(val & (1 << i)));
   108b6:	8d 81       	ldd	r24, Y+5	; 0x05
   108b8:	88 2f       	mov	r24, r24
   108ba:	90 e0       	ldi	r25, 0x00	; 0
   108bc:	29 81       	ldd	r18, Y+1	; 0x01
   108be:	22 2f       	mov	r18, r18
   108c0:	30 e0       	ldi	r19, 0x00	; 0
   108c2:	02 c0       	rjmp	.+4      	; 0x108c8 <shiftOut+0x32>
   108c4:	95 95       	asr	r25
   108c6:	87 95       	ror	r24
   108c8:	2a 95       	dec	r18
   108ca:	e2 f7       	brpl	.-8      	; 0x108c4 <shiftOut+0x2e>
   108cc:	81 70       	andi	r24, 0x01	; 1
   108ce:	99 27       	eor	r25, r25
   108d0:	21 e0       	ldi	r18, 0x01	; 1
   108d2:	00 97       	sbiw	r24, 0x00	; 0
   108d4:	09 f4       	brne	.+2      	; 0x108d8 <shiftOut+0x42>
   108d6:	20 e0       	ldi	r18, 0x00	; 0
   108d8:	82 2f       	mov	r24, r18
   108da:	68 2f       	mov	r22, r24
   108dc:	8a 81       	ldd	r24, Y+2	; 0x02
   108de:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
   108e2:	1c c0       	rjmp	.+56     	; 0x1091c <shiftOut+0x86>
		else	
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
   108e4:	8d 81       	ldd	r24, Y+5	; 0x05
   108e6:	88 2f       	mov	r24, r24
   108e8:	90 e0       	ldi	r25, 0x00	; 0
   108ea:	29 81       	ldd	r18, Y+1	; 0x01
   108ec:	22 2f       	mov	r18, r18
   108ee:	30 e0       	ldi	r19, 0x00	; 0
   108f0:	47 e0       	ldi	r20, 0x07	; 7
   108f2:	50 e0       	ldi	r21, 0x00	; 0
   108f4:	ba 01       	movw	r22, r20
   108f6:	62 1b       	sub	r22, r18
   108f8:	73 0b       	sbc	r23, r19
   108fa:	9b 01       	movw	r18, r22
   108fc:	02 c0       	rjmp	.+4      	; 0x10902 <shiftOut+0x6c>
   108fe:	95 95       	asr	r25
   10900:	87 95       	ror	r24
   10902:	2a 95       	dec	r18
   10904:	e2 f7       	brpl	.-8      	; 0x108fe <shiftOut+0x68>
   10906:	81 70       	andi	r24, 0x01	; 1
   10908:	99 27       	eor	r25, r25
   1090a:	21 e0       	ldi	r18, 0x01	; 1
   1090c:	00 97       	sbiw	r24, 0x00	; 0
   1090e:	09 f4       	brne	.+2      	; 0x10912 <shiftOut+0x7c>
   10910:	20 e0       	ldi	r18, 0x00	; 0
   10912:	82 2f       	mov	r24, r18
   10914:	68 2f       	mov	r22, r24
   10916:	8a 81       	ldd	r24, Y+2	; 0x02
   10918:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
			
		digitalWrite(clockPin, HIGH);
   1091c:	61 e0       	ldi	r22, 0x01	; 1
   1091e:	8b 81       	ldd	r24, Y+3	; 0x03
   10920:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>
		digitalWrite(clockPin, LOW);		
   10924:	60 e0       	ldi	r22, 0x00	; 0
   10926:	8b 81       	ldd	r24, Y+3	; 0x03
   10928:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
   1092c:	89 81       	ldd	r24, Y+1	; 0x01
   1092e:	8f 5f       	subi	r24, 0xFF	; 255
   10930:	89 83       	std	Y+1, r24	; 0x01
   10932:	89 81       	ldd	r24, Y+1	; 0x01
   10934:	88 30       	cpi	r24, 0x08	; 8
   10936:	08 f4       	brcc	.+2      	; 0x1093a <shiftOut+0xa4>
   10938:	bb cf       	rjmp	.-138    	; 0x108b0 <shiftOut+0x1a>
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
			
		digitalWrite(clockPin, HIGH);
		digitalWrite(clockPin, LOW);		
	}
}
   1093a:	0f 90       	pop	r0
   1093c:	0f 90       	pop	r0
   1093e:	0f 90       	pop	r0
   10940:	0f 90       	pop	r0
   10942:	0f 90       	pop	r0
   10944:	df 91       	pop	r29
   10946:	cf 91       	pop	r28
   10948:	08 95       	ret

0001094a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
   1094a:	cf 93       	push	r28
   1094c:	df 93       	push	r29
   1094e:	cd b7       	in	r28, 0x3d	; 61
   10950:	de b7       	in	r29, 0x3e	; 62
   10952:	27 97       	sbiw	r28, 0x07	; 7
   10954:	0f b6       	in	r0, 0x3f	; 63
   10956:	f8 94       	cli
   10958:	de bf       	out	0x3e, r29	; 62
   1095a:	0f be       	out	0x3f, r0	; 63
   1095c:	cd bf       	out	0x3d, r28	; 61
   1095e:	9d 83       	std	Y+5, r25	; 0x05
   10960:	8c 83       	std	Y+4, r24	; 0x04
   10962:	6e 83       	std	Y+6, r22	; 0x06
   10964:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
   10966:	8a e1       	ldi	r24, 0x1A	; 26
   10968:	90 e0       	ldi	r25, 0x00	; 0
   1096a:	0e 94 a2 87 	call	0x10f44	; 0x10f44 <pvPortMalloc>
   1096e:	9b 83       	std	Y+3, r25	; 0x03
   10970:	8a 83       	std	Y+2, r24	; 0x02
	if( pxCoRoutine )
   10972:	8a 81       	ldd	r24, Y+2	; 0x02
   10974:	9b 81       	ldd	r25, Y+3	; 0x03
   10976:	00 97       	sbiw	r24, 0x00	; 0
   10978:	09 f4       	brne	.+2      	; 0x1097c <xCoRoutineCreate+0x32>
   1097a:	77 c0       	rjmp	.+238    	; 0x10a6a <xCoRoutineCreate+0x120>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
   1097c:	80 91 12 09 	lds	r24, 0x0912
   10980:	90 91 13 09 	lds	r25, 0x0913
   10984:	00 97       	sbiw	r24, 0x00	; 0
   10986:	41 f4       	brne	.+16     	; 0x10998 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
   10988:	8a 81       	ldd	r24, Y+2	; 0x02
   1098a:	9b 81       	ldd	r25, Y+3	; 0x03
   1098c:	90 93 13 09 	sts	0x0913, r25
   10990:	80 93 12 09 	sts	0x0912, r24
			prvInitialiseCoRoutineLists();
   10994:	0e 94 30 87 	call	0x10e60	; 0x10e60 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
   10998:	8e 81       	ldd	r24, Y+6	; 0x06
   1099a:	82 30       	cpi	r24, 0x02	; 2
   1099c:	10 f0       	brcs	.+4      	; 0x109a2 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
   1099e:	81 e0       	ldi	r24, 0x01	; 1
   109a0:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
   109a2:	8a 81       	ldd	r24, Y+2	; 0x02
   109a4:	9b 81       	ldd	r25, Y+3	; 0x03
   109a6:	fc 01       	movw	r30, r24
   109a8:	11 8e       	std	Z+25, r1	; 0x19
   109aa:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
   109ac:	8a 81       	ldd	r24, Y+2	; 0x02
   109ae:	9b 81       	ldd	r25, Y+3	; 0x03
   109b0:	2e 81       	ldd	r18, Y+6	; 0x06
   109b2:	fc 01       	movw	r30, r24
   109b4:	26 8b       	std	Z+22, r18	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
   109b6:	8a 81       	ldd	r24, Y+2	; 0x02
   109b8:	9b 81       	ldd	r25, Y+3	; 0x03
   109ba:	2f 81       	ldd	r18, Y+7	; 0x07
   109bc:	fc 01       	movw	r30, r24
   109be:	27 8b       	std	Z+23, r18	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
   109c0:	8a 81       	ldd	r24, Y+2	; 0x02
   109c2:	9b 81       	ldd	r25, Y+3	; 0x03
   109c4:	2c 81       	ldd	r18, Y+4	; 0x04
   109c6:	3d 81       	ldd	r19, Y+5	; 0x05
   109c8:	fc 01       	movw	r30, r24
   109ca:	31 83       	std	Z+1, r19	; 0x01
   109cc:	20 83       	st	Z, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
   109ce:	8a 81       	ldd	r24, Y+2	; 0x02
   109d0:	9b 81       	ldd	r25, Y+3	; 0x03
   109d2:	02 96       	adiw	r24, 0x02	; 2
   109d4:	0e 94 0a 88 	call	0x11014	; 0x11014 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
   109d8:	8a 81       	ldd	r24, Y+2	; 0x02
   109da:	9b 81       	ldd	r25, Y+3	; 0x03
   109dc:	0c 96       	adiw	r24, 0x0c	; 12
   109de:	0e 94 0a 88 	call	0x11014	; 0x11014 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
   109e2:	8a 81       	ldd	r24, Y+2	; 0x02
   109e4:	9b 81       	ldd	r25, Y+3	; 0x03
   109e6:	2a 81       	ldd	r18, Y+2	; 0x02
   109e8:	3b 81       	ldd	r19, Y+3	; 0x03
   109ea:	fc 01       	movw	r30, r24
   109ec:	31 87       	std	Z+9, r19	; 0x09
   109ee:	20 87       	std	Z+8, r18	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
   109f0:	8a 81       	ldd	r24, Y+2	; 0x02
   109f2:	9b 81       	ldd	r25, Y+3	; 0x03
   109f4:	2a 81       	ldd	r18, Y+2	; 0x02
   109f6:	3b 81       	ldd	r19, Y+3	; 0x03
   109f8:	fc 01       	movw	r30, r24
   109fa:	33 8b       	std	Z+19, r19	; 0x13
   109fc:	22 8b       	std	Z+18, r18	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
   109fe:	8e 81       	ldd	r24, Y+6	; 0x06
   10a00:	88 2f       	mov	r24, r24
   10a02:	90 e0       	ldi	r25, 0x00	; 0
   10a04:	24 e0       	ldi	r18, 0x04	; 4
   10a06:	30 e0       	ldi	r19, 0x00	; 0
   10a08:	28 1b       	sub	r18, r24
   10a0a:	39 0b       	sbc	r19, r25
   10a0c:	8a 81       	ldd	r24, Y+2	; 0x02
   10a0e:	9b 81       	ldd	r25, Y+3	; 0x03
   10a10:	fc 01       	movw	r30, r24
   10a12:	35 87       	std	Z+13, r19	; 0x0d
   10a14:	24 87       	std	Z+12, r18	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
   10a16:	8a 81       	ldd	r24, Y+2	; 0x02
   10a18:	9b 81       	ldd	r25, Y+3	; 0x03
   10a1a:	fc 01       	movw	r30, r24
   10a1c:	96 89       	ldd	r25, Z+22	; 0x16
   10a1e:	80 91 45 09 	lds	r24, 0x0945
   10a22:	89 17       	cp	r24, r25
   10a24:	30 f4       	brcc	.+12     	; 0x10a32 <xCoRoutineCreate+0xe8>
   10a26:	8a 81       	ldd	r24, Y+2	; 0x02
   10a28:	9b 81       	ldd	r25, Y+3	; 0x03
   10a2a:	fc 01       	movw	r30, r24
   10a2c:	86 89       	ldd	r24, Z+22	; 0x16
   10a2e:	80 93 45 09 	sts	0x0945, r24
   10a32:	8a 81       	ldd	r24, Y+2	; 0x02
   10a34:	9b 81       	ldd	r25, Y+3	; 0x03
   10a36:	ac 01       	movw	r20, r24
   10a38:	4e 5f       	subi	r20, 0xFE	; 254
   10a3a:	5f 4f       	sbci	r21, 0xFF	; 255
   10a3c:	8a 81       	ldd	r24, Y+2	; 0x02
   10a3e:	9b 81       	ldd	r25, Y+3	; 0x03
   10a40:	fc 01       	movw	r30, r24
   10a42:	86 89       	ldd	r24, Z+22	; 0x16
   10a44:	28 2f       	mov	r18, r24
   10a46:	30 e0       	ldi	r19, 0x00	; 0
   10a48:	c9 01       	movw	r24, r18
   10a4a:	88 0f       	add	r24, r24
   10a4c:	99 1f       	adc	r25, r25
   10a4e:	88 0f       	add	r24, r24
   10a50:	99 1f       	adc	r25, r25
   10a52:	88 0f       	add	r24, r24
   10a54:	99 1f       	adc	r25, r25
   10a56:	82 0f       	add	r24, r18
   10a58:	93 1f       	adc	r25, r19
   10a5a:	8c 5e       	subi	r24, 0xEC	; 236
   10a5c:	96 4f       	sbci	r25, 0xF6	; 246
   10a5e:	ba 01       	movw	r22, r20
   10a60:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>

		xReturn = pdPASS;
   10a64:	81 e0       	ldi	r24, 0x01	; 1
   10a66:	89 83       	std	Y+1, r24	; 0x01
   10a68:	02 c0       	rjmp	.+4      	; 0x10a6e <xCoRoutineCreate+0x124>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   10a6a:	8f ef       	ldi	r24, 0xFF	; 255
   10a6c:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return xReturn;	
   10a6e:	89 81       	ldd	r24, Y+1	; 0x01
}
   10a70:	27 96       	adiw	r28, 0x07	; 7
   10a72:	0f b6       	in	r0, 0x3f	; 63
   10a74:	f8 94       	cli
   10a76:	de bf       	out	0x3e, r29	; 62
   10a78:	0f be       	out	0x3f, r0	; 63
   10a7a:	cd bf       	out	0x3d, r28	; 61
   10a7c:	df 91       	pop	r29
   10a7e:	cf 91       	pop	r28
   10a80:	08 95       	ret

00010a82 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
   10a82:	cf 93       	push	r28
   10a84:	df 93       	push	r29
   10a86:	00 d0       	rcall	.+0      	; 0x10a88 <vCoRoutineAddToDelayedList+0x6>
   10a88:	00 d0       	rcall	.+0      	; 0x10a8a <vCoRoutineAddToDelayedList+0x8>
   10a8a:	00 d0       	rcall	.+0      	; 0x10a8c <vCoRoutineAddToDelayedList+0xa>
   10a8c:	cd b7       	in	r28, 0x3d	; 61
   10a8e:	de b7       	in	r29, 0x3e	; 62
   10a90:	9c 83       	std	Y+4, r25	; 0x04
   10a92:	8b 83       	std	Y+3, r24	; 0x03
   10a94:	7e 83       	std	Y+6, r23	; 0x06
   10a96:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
   10a98:	20 91 46 09 	lds	r18, 0x0946
   10a9c:	30 91 47 09 	lds	r19, 0x0947
   10aa0:	8b 81       	ldd	r24, Y+3	; 0x03
   10aa2:	9c 81       	ldd	r25, Y+4	; 0x04
   10aa4:	82 0f       	add	r24, r18
   10aa6:	93 1f       	adc	r25, r19
   10aa8:	9a 83       	std	Y+2, r25	; 0x02
   10aaa:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
   10aac:	80 91 12 09 	lds	r24, 0x0912
   10ab0:	90 91 13 09 	lds	r25, 0x0913
   10ab4:	02 96       	adiw	r24, 0x02	; 2
   10ab6:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
   10aba:	80 91 12 09 	lds	r24, 0x0912
   10abe:	90 91 13 09 	lds	r25, 0x0913
   10ac2:	29 81       	ldd	r18, Y+1	; 0x01
   10ac4:	3a 81       	ldd	r19, Y+2	; 0x02
   10ac6:	fc 01       	movw	r30, r24
   10ac8:	33 83       	std	Z+3, r19	; 0x03
   10aca:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
   10acc:	80 91 46 09 	lds	r24, 0x0946
   10ad0:	90 91 47 09 	lds	r25, 0x0947
   10ad4:	29 81       	ldd	r18, Y+1	; 0x01
   10ad6:	3a 81       	ldd	r19, Y+2	; 0x02
   10ad8:	28 17       	cp	r18, r24
   10ada:	39 07       	cpc	r19, r25
   10adc:	78 f4       	brcc	.+30     	; 0x10afc <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
   10ade:	80 91 12 09 	lds	r24, 0x0912
   10ae2:	90 91 13 09 	lds	r25, 0x0913
   10ae6:	9c 01       	movw	r18, r24
   10ae8:	2e 5f       	subi	r18, 0xFE	; 254
   10aea:	3f 4f       	sbci	r19, 0xFF	; 255
   10aec:	80 91 3a 09 	lds	r24, 0x093A
   10af0:	90 91 3b 09 	lds	r25, 0x093B
   10af4:	b9 01       	movw	r22, r18
   10af6:	0e 94 73 88 	call	0x110e6	; 0x110e6 <vListInsert>
   10afa:	0e c0       	rjmp	.+28     	; 0x10b18 <vCoRoutineAddToDelayedList+0x96>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
   10afc:	80 91 12 09 	lds	r24, 0x0912
   10b00:	90 91 13 09 	lds	r25, 0x0913
   10b04:	9c 01       	movw	r18, r24
   10b06:	2e 5f       	subi	r18, 0xFE	; 254
   10b08:	3f 4f       	sbci	r19, 0xFF	; 255
   10b0a:	80 91 38 09 	lds	r24, 0x0938
   10b0e:	90 91 39 09 	lds	r25, 0x0939
   10b12:	b9 01       	movw	r22, r18
   10b14:	0e 94 73 88 	call	0x110e6	; 0x110e6 <vListInsert>
	}

	if( pxEventList )
   10b18:	8d 81       	ldd	r24, Y+5	; 0x05
   10b1a:	9e 81       	ldd	r25, Y+6	; 0x06
   10b1c:	00 97       	sbiw	r24, 0x00	; 0
   10b1e:	61 f0       	breq	.+24     	; 0x10b38 <vCoRoutineAddToDelayedList+0xb6>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
   10b20:	80 91 12 09 	lds	r24, 0x0912
   10b24:	90 91 13 09 	lds	r25, 0x0913
   10b28:	9c 01       	movw	r18, r24
   10b2a:	24 5f       	subi	r18, 0xF4	; 244
   10b2c:	3f 4f       	sbci	r19, 0xFF	; 255
   10b2e:	8d 81       	ldd	r24, Y+5	; 0x05
   10b30:	9e 81       	ldd	r25, Y+6	; 0x06
   10b32:	b9 01       	movw	r22, r18
   10b34:	0e 94 73 88 	call	0x110e6	; 0x110e6 <vListInsert>
	}
}
   10b38:	26 96       	adiw	r28, 0x06	; 6
   10b3a:	0f b6       	in	r0, 0x3f	; 63
   10b3c:	f8 94       	cli
   10b3e:	de bf       	out	0x3e, r29	; 62
   10b40:	0f be       	out	0x3f, r0	; 63
   10b42:	cd bf       	out	0x3d, r28	; 61
   10b44:	df 91       	pop	r29
   10b46:	cf 91       	pop	r28
   10b48:	08 95       	ret

00010b4a <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
   10b4a:	cf 93       	push	r28
   10b4c:	df 93       	push	r29
   10b4e:	00 d0       	rcall	.+0      	; 0x10b50 <prvCheckPendingReadyList+0x6>
   10b50:	cd b7       	in	r28, 0x3d	; 61
   10b52:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
   10b54:	3c c0       	rjmp	.+120    	; 0x10bce <prvCheckPendingReadyList+0x84>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
   10b56:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
   10b58:	80 91 41 09 	lds	r24, 0x0941
   10b5c:	90 91 42 09 	lds	r25, 0x0942
   10b60:	fc 01       	movw	r30, r24
   10b62:	86 81       	ldd	r24, Z+6	; 0x06
   10b64:	97 81       	ldd	r25, Z+7	; 0x07
   10b66:	9a 83       	std	Y+2, r25	; 0x02
   10b68:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
   10b6a:	89 81       	ldd	r24, Y+1	; 0x01
   10b6c:	9a 81       	ldd	r25, Y+2	; 0x02
   10b6e:	0c 96       	adiw	r24, 0x0c	; 12
   10b70:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
   10b74:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
   10b76:	89 81       	ldd	r24, Y+1	; 0x01
   10b78:	9a 81       	ldd	r25, Y+2	; 0x02
   10b7a:	02 96       	adiw	r24, 0x02	; 2
   10b7c:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
   10b80:	89 81       	ldd	r24, Y+1	; 0x01
   10b82:	9a 81       	ldd	r25, Y+2	; 0x02
   10b84:	fc 01       	movw	r30, r24
   10b86:	96 89       	ldd	r25, Z+22	; 0x16
   10b88:	80 91 45 09 	lds	r24, 0x0945
   10b8c:	89 17       	cp	r24, r25
   10b8e:	30 f4       	brcc	.+12     	; 0x10b9c <prvCheckPendingReadyList+0x52>
   10b90:	89 81       	ldd	r24, Y+1	; 0x01
   10b92:	9a 81       	ldd	r25, Y+2	; 0x02
   10b94:	fc 01       	movw	r30, r24
   10b96:	86 89       	ldd	r24, Z+22	; 0x16
   10b98:	80 93 45 09 	sts	0x0945, r24
   10b9c:	89 81       	ldd	r24, Y+1	; 0x01
   10b9e:	9a 81       	ldd	r25, Y+2	; 0x02
   10ba0:	ac 01       	movw	r20, r24
   10ba2:	4e 5f       	subi	r20, 0xFE	; 254
   10ba4:	5f 4f       	sbci	r21, 0xFF	; 255
   10ba6:	89 81       	ldd	r24, Y+1	; 0x01
   10ba8:	9a 81       	ldd	r25, Y+2	; 0x02
   10baa:	fc 01       	movw	r30, r24
   10bac:	86 89       	ldd	r24, Z+22	; 0x16
   10bae:	28 2f       	mov	r18, r24
   10bb0:	30 e0       	ldi	r19, 0x00	; 0
   10bb2:	c9 01       	movw	r24, r18
   10bb4:	88 0f       	add	r24, r24
   10bb6:	99 1f       	adc	r25, r25
   10bb8:	88 0f       	add	r24, r24
   10bba:	99 1f       	adc	r25, r25
   10bbc:	88 0f       	add	r24, r24
   10bbe:	99 1f       	adc	r25, r25
   10bc0:	82 0f       	add	r24, r18
   10bc2:	93 1f       	adc	r25, r19
   10bc4:	8c 5e       	subi	r24, 0xEC	; 236
   10bc6:	96 4f       	sbci	r25, 0xF6	; 246
   10bc8:	ba 01       	movw	r22, r20
   10bca:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
   10bce:	80 91 3c 09 	lds	r24, 0x093C
   10bd2:	88 23       	and	r24, r24
   10bd4:	09 f0       	breq	.+2      	; 0x10bd8 <prvCheckPendingReadyList+0x8e>
   10bd6:	bf cf       	rjmp	.-130    	; 0x10b56 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
   10bd8:	0f 90       	pop	r0
   10bda:	0f 90       	pop	r0
   10bdc:	df 91       	pop	r29
   10bde:	cf 91       	pop	r28
   10be0:	08 95       	ret

00010be2 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
   10be2:	cf 93       	push	r28
   10be4:	df 93       	push	r29
   10be6:	00 d0       	rcall	.+0      	; 0x10be8 <prvCheckDelayedList+0x6>
   10be8:	00 d0       	rcall	.+0      	; 0x10bea <prvCheckDelayedList+0x8>
   10bea:	cd b7       	in	r28, 0x3d	; 61
   10bec:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
   10bee:	0e 94 30 97 	call	0x12e60	; 0x12e60 <xTaskGetTickCount>
   10bf2:	9c 01       	movw	r18, r24
   10bf4:	80 91 48 09 	lds	r24, 0x0948
   10bf8:	90 91 49 09 	lds	r25, 0x0949
   10bfc:	a9 01       	movw	r20, r18
   10bfe:	48 1b       	sub	r20, r24
   10c00:	59 0b       	sbc	r21, r25
   10c02:	ca 01       	movw	r24, r20
   10c04:	90 93 4b 09 	sts	0x094B, r25
   10c08:	80 93 4a 09 	sts	0x094A, r24
	while( xPassedTicks )
   10c0c:	8e c0       	rjmp	.+284    	; 0x10d2a <prvCheckDelayedList+0x148>
	{
		xCoRoutineTickCount++;
   10c0e:	80 91 46 09 	lds	r24, 0x0946
   10c12:	90 91 47 09 	lds	r25, 0x0947
   10c16:	01 96       	adiw	r24, 0x01	; 1
   10c18:	90 93 47 09 	sts	0x0947, r25
   10c1c:	80 93 46 09 	sts	0x0946, r24
		xPassedTicks--;
   10c20:	80 91 4a 09 	lds	r24, 0x094A
   10c24:	90 91 4b 09 	lds	r25, 0x094B
   10c28:	01 97       	sbiw	r24, 0x01	; 1
   10c2a:	90 93 4b 09 	sts	0x094B, r25
   10c2e:	80 93 4a 09 	sts	0x094A, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
   10c32:	80 91 46 09 	lds	r24, 0x0946
   10c36:	90 91 47 09 	lds	r25, 0x0947
   10c3a:	00 97       	sbiw	r24, 0x00	; 0
   10c3c:	09 f0       	breq	.+2      	; 0x10c40 <prvCheckDelayedList+0x5e>
   10c3e:	69 c0       	rjmp	.+210    	; 0x10d12 <prvCheckDelayedList+0x130>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
   10c40:	80 91 38 09 	lds	r24, 0x0938
   10c44:	90 91 39 09 	lds	r25, 0x0939
   10c48:	9a 83       	std	Y+2, r25	; 0x02
   10c4a:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
   10c4c:	80 91 3a 09 	lds	r24, 0x093A
   10c50:	90 91 3b 09 	lds	r25, 0x093B
   10c54:	90 93 39 09 	sts	0x0939, r25
   10c58:	80 93 38 09 	sts	0x0938, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
   10c5c:	89 81       	ldd	r24, Y+1	; 0x01
   10c5e:	9a 81       	ldd	r25, Y+2	; 0x02
   10c60:	90 93 3b 09 	sts	0x093B, r25
   10c64:	80 93 3a 09 	sts	0x093A, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
   10c68:	54 c0       	rjmp	.+168    	; 0x10d12 <prvCheckDelayedList+0x130>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
   10c6a:	80 91 38 09 	lds	r24, 0x0938
   10c6e:	90 91 39 09 	lds	r25, 0x0939
   10c72:	fc 01       	movw	r30, r24
   10c74:	85 81       	ldd	r24, Z+5	; 0x05
   10c76:	96 81       	ldd	r25, Z+6	; 0x06
   10c78:	fc 01       	movw	r30, r24
   10c7a:	86 81       	ldd	r24, Z+6	; 0x06
   10c7c:	97 81       	ldd	r25, Z+7	; 0x07
   10c7e:	9c 83       	std	Y+4, r25	; 0x04
   10c80:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
   10c82:	8b 81       	ldd	r24, Y+3	; 0x03
   10c84:	9c 81       	ldd	r25, Y+4	; 0x04
   10c86:	fc 01       	movw	r30, r24
   10c88:	22 81       	ldd	r18, Z+2	; 0x02
   10c8a:	33 81       	ldd	r19, Z+3	; 0x03
   10c8c:	80 91 46 09 	lds	r24, 0x0946
   10c90:	90 91 47 09 	lds	r25, 0x0947
   10c94:	82 17       	cp	r24, r18
   10c96:	93 07       	cpc	r25, r19
   10c98:	08 f4       	brcc	.+2      	; 0x10c9c <prvCheckDelayedList+0xba>
   10c9a:	46 c0       	rjmp	.+140    	; 0x10d28 <prvCheckDelayedList+0x146>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
   10c9c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
   10c9e:	8b 81       	ldd	r24, Y+3	; 0x03
   10ca0:	9c 81       	ldd	r25, Y+4	; 0x04
   10ca2:	02 96       	adiw	r24, 0x02	; 2
   10ca4:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
   10ca8:	8b 81       	ldd	r24, Y+3	; 0x03
   10caa:	9c 81       	ldd	r25, Y+4	; 0x04
   10cac:	fc 01       	movw	r30, r24
   10cae:	84 89       	ldd	r24, Z+20	; 0x14
   10cb0:	95 89       	ldd	r25, Z+21	; 0x15
   10cb2:	00 97       	sbiw	r24, 0x00	; 0
   10cb4:	29 f0       	breq	.+10     	; 0x10cc0 <prvCheckDelayedList+0xde>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
   10cb6:	8b 81       	ldd	r24, Y+3	; 0x03
   10cb8:	9c 81       	ldd	r25, Y+4	; 0x04
   10cba:	0c 96       	adiw	r24, 0x0c	; 12
   10cbc:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
   10cc0:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
   10cc2:	8b 81       	ldd	r24, Y+3	; 0x03
   10cc4:	9c 81       	ldd	r25, Y+4	; 0x04
   10cc6:	fc 01       	movw	r30, r24
   10cc8:	96 89       	ldd	r25, Z+22	; 0x16
   10cca:	80 91 45 09 	lds	r24, 0x0945
   10cce:	89 17       	cp	r24, r25
   10cd0:	30 f4       	brcc	.+12     	; 0x10cde <prvCheckDelayedList+0xfc>
   10cd2:	8b 81       	ldd	r24, Y+3	; 0x03
   10cd4:	9c 81       	ldd	r25, Y+4	; 0x04
   10cd6:	fc 01       	movw	r30, r24
   10cd8:	86 89       	ldd	r24, Z+22	; 0x16
   10cda:	80 93 45 09 	sts	0x0945, r24
   10cde:	8b 81       	ldd	r24, Y+3	; 0x03
   10ce0:	9c 81       	ldd	r25, Y+4	; 0x04
   10ce2:	ac 01       	movw	r20, r24
   10ce4:	4e 5f       	subi	r20, 0xFE	; 254
   10ce6:	5f 4f       	sbci	r21, 0xFF	; 255
   10ce8:	8b 81       	ldd	r24, Y+3	; 0x03
   10cea:	9c 81       	ldd	r25, Y+4	; 0x04
   10cec:	fc 01       	movw	r30, r24
   10cee:	86 89       	ldd	r24, Z+22	; 0x16
   10cf0:	28 2f       	mov	r18, r24
   10cf2:	30 e0       	ldi	r19, 0x00	; 0
   10cf4:	c9 01       	movw	r24, r18
   10cf6:	88 0f       	add	r24, r24
   10cf8:	99 1f       	adc	r25, r25
   10cfa:	88 0f       	add	r24, r24
   10cfc:	99 1f       	adc	r25, r25
   10cfe:	88 0f       	add	r24, r24
   10d00:	99 1f       	adc	r25, r25
   10d02:	82 0f       	add	r24, r18
   10d04:	93 1f       	adc	r25, r19
   10d06:	8c 5e       	subi	r24, 0xEC	; 236
   10d08:	96 4f       	sbci	r25, 0xF6	; 246
   10d0a:	ba 01       	movw	r22, r20
   10d0c:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>
   10d10:	01 c0       	rjmp	.+2      	; 0x10d14 <prvCheckDelayedList+0x132>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
   10d12:	00 00       	nop
   10d14:	80 91 38 09 	lds	r24, 0x0938
   10d18:	90 91 39 09 	lds	r25, 0x0939
   10d1c:	fc 01       	movw	r30, r24
   10d1e:	80 81       	ld	r24, Z
   10d20:	88 23       	and	r24, r24
   10d22:	09 f0       	breq	.+2      	; 0x10d26 <prvCheckDelayedList+0x144>
   10d24:	a2 cf       	rjmp	.-188    	; 0x10c6a <prvCheckDelayedList+0x88>
   10d26:	01 c0       	rjmp	.+2      	; 0x10d2a <prvCheckDelayedList+0x148>
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
			{			
				/* Timeout not yet expired. */																			
				break;																				
   10d28:	00 00       	nop
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
   10d2a:	80 91 4a 09 	lds	r24, 0x094A
   10d2e:	90 91 4b 09 	lds	r25, 0x094B
   10d32:	00 97       	sbiw	r24, 0x00	; 0
   10d34:	09 f0       	breq	.+2      	; 0x10d38 <prvCheckDelayedList+0x156>
   10d36:	6b cf       	rjmp	.-298    	; 0x10c0e <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
   10d38:	80 91 46 09 	lds	r24, 0x0946
   10d3c:	90 91 47 09 	lds	r25, 0x0947
   10d40:	90 93 49 09 	sts	0x0949, r25
   10d44:	80 93 48 09 	sts	0x0948, r24
}
   10d48:	0f 90       	pop	r0
   10d4a:	0f 90       	pop	r0
   10d4c:	0f 90       	pop	r0
   10d4e:	0f 90       	pop	r0
   10d50:	df 91       	pop	r29
   10d52:	cf 91       	pop	r28
   10d54:	08 95       	ret

00010d56 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
   10d56:	cf 93       	push	r28
   10d58:	df 93       	push	r29
   10d5a:	00 d0       	rcall	.+0      	; 0x10d5c <vCoRoutineSchedule+0x6>
   10d5c:	cd b7       	in	r28, 0x3d	; 61
   10d5e:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
   10d60:	0e 94 a5 85 	call	0x10b4a	; 0x10b4a <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
   10d64:	0e 94 f1 85 	call	0x10be2	; 0x10be2 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
   10d68:	0a c0       	rjmp	.+20     	; 0x10d7e <vCoRoutineSchedule+0x28>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
   10d6a:	80 91 45 09 	lds	r24, 0x0945
   10d6e:	88 23       	and	r24, r24
   10d70:	09 f4       	brne	.+2      	; 0x10d74 <vCoRoutineSchedule+0x1e>
   10d72:	70 c0       	rjmp	.+224    	; 0x10e54 <vCoRoutineSchedule+0xfe>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
   10d74:	80 91 45 09 	lds	r24, 0x0945
   10d78:	81 50       	subi	r24, 0x01	; 1
   10d7a:	80 93 45 09 	sts	0x0945, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
   10d7e:	80 91 45 09 	lds	r24, 0x0945
   10d82:	28 2f       	mov	r18, r24
   10d84:	30 e0       	ldi	r19, 0x00	; 0
   10d86:	c9 01       	movw	r24, r18
   10d88:	88 0f       	add	r24, r24
   10d8a:	99 1f       	adc	r25, r25
   10d8c:	88 0f       	add	r24, r24
   10d8e:	99 1f       	adc	r25, r25
   10d90:	88 0f       	add	r24, r24
   10d92:	99 1f       	adc	r25, r25
   10d94:	82 0f       	add	r24, r18
   10d96:	93 1f       	adc	r25, r19
   10d98:	8c 5e       	subi	r24, 0xEC	; 236
   10d9a:	96 4f       	sbci	r25, 0xF6	; 246
   10d9c:	fc 01       	movw	r30, r24
   10d9e:	80 81       	ld	r24, Z
   10da0:	88 23       	and	r24, r24
   10da2:	19 f3       	breq	.-58     	; 0x10d6a <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
   10da4:	80 91 45 09 	lds	r24, 0x0945
   10da8:	28 2f       	mov	r18, r24
   10daa:	30 e0       	ldi	r19, 0x00	; 0
   10dac:	c9 01       	movw	r24, r18
   10dae:	88 0f       	add	r24, r24
   10db0:	99 1f       	adc	r25, r25
   10db2:	88 0f       	add	r24, r24
   10db4:	99 1f       	adc	r25, r25
   10db6:	88 0f       	add	r24, r24
   10db8:	99 1f       	adc	r25, r25
   10dba:	82 0f       	add	r24, r18
   10dbc:	93 1f       	adc	r25, r19
   10dbe:	8c 5e       	subi	r24, 0xEC	; 236
   10dc0:	96 4f       	sbci	r25, 0xF6	; 246
   10dc2:	9a 83       	std	Y+2, r25	; 0x02
   10dc4:	89 83       	std	Y+1, r24	; 0x01
   10dc6:	89 81       	ldd	r24, Y+1	; 0x01
   10dc8:	9a 81       	ldd	r25, Y+2	; 0x02
   10dca:	fc 01       	movw	r30, r24
   10dcc:	81 81       	ldd	r24, Z+1	; 0x01
   10dce:	92 81       	ldd	r25, Z+2	; 0x02
   10dd0:	fc 01       	movw	r30, r24
   10dd2:	22 81       	ldd	r18, Z+2	; 0x02
   10dd4:	33 81       	ldd	r19, Z+3	; 0x03
   10dd6:	89 81       	ldd	r24, Y+1	; 0x01
   10dd8:	9a 81       	ldd	r25, Y+2	; 0x02
   10dda:	fc 01       	movw	r30, r24
   10ddc:	32 83       	std	Z+2, r19	; 0x02
   10dde:	21 83       	std	Z+1, r18	; 0x01
   10de0:	89 81       	ldd	r24, Y+1	; 0x01
   10de2:	9a 81       	ldd	r25, Y+2	; 0x02
   10de4:	fc 01       	movw	r30, r24
   10de6:	21 81       	ldd	r18, Z+1	; 0x01
   10de8:	32 81       	ldd	r19, Z+2	; 0x02
   10dea:	89 81       	ldd	r24, Y+1	; 0x01
   10dec:	9a 81       	ldd	r25, Y+2	; 0x02
   10dee:	03 96       	adiw	r24, 0x03	; 3
   10df0:	28 17       	cp	r18, r24
   10df2:	39 07       	cpc	r19, r25
   10df4:	69 f4       	brne	.+26     	; 0x10e10 <vCoRoutineSchedule+0xba>
   10df6:	89 81       	ldd	r24, Y+1	; 0x01
   10df8:	9a 81       	ldd	r25, Y+2	; 0x02
   10dfa:	fc 01       	movw	r30, r24
   10dfc:	81 81       	ldd	r24, Z+1	; 0x01
   10dfe:	92 81       	ldd	r25, Z+2	; 0x02
   10e00:	fc 01       	movw	r30, r24
   10e02:	22 81       	ldd	r18, Z+2	; 0x02
   10e04:	33 81       	ldd	r19, Z+3	; 0x03
   10e06:	89 81       	ldd	r24, Y+1	; 0x01
   10e08:	9a 81       	ldd	r25, Y+2	; 0x02
   10e0a:	fc 01       	movw	r30, r24
   10e0c:	32 83       	std	Z+2, r19	; 0x02
   10e0e:	21 83       	std	Z+1, r18	; 0x01
   10e10:	89 81       	ldd	r24, Y+1	; 0x01
   10e12:	9a 81       	ldd	r25, Y+2	; 0x02
   10e14:	fc 01       	movw	r30, r24
   10e16:	81 81       	ldd	r24, Z+1	; 0x01
   10e18:	92 81       	ldd	r25, Z+2	; 0x02
   10e1a:	fc 01       	movw	r30, r24
   10e1c:	86 81       	ldd	r24, Z+6	; 0x06
   10e1e:	97 81       	ldd	r25, Z+7	; 0x07
   10e20:	90 93 13 09 	sts	0x0913, r25
   10e24:	80 93 12 09 	sts	0x0912, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
   10e28:	80 91 12 09 	lds	r24, 0x0912
   10e2c:	90 91 13 09 	lds	r25, 0x0913
   10e30:	fc 01       	movw	r30, r24
   10e32:	20 81       	ld	r18, Z
   10e34:	31 81       	ldd	r19, Z+1	; 0x01
   10e36:	80 91 12 09 	lds	r24, 0x0912
   10e3a:	90 91 13 09 	lds	r25, 0x0913
   10e3e:	fc 01       	movw	r30, r24
   10e40:	47 89       	ldd	r20, Z+23	; 0x17
   10e42:	80 91 12 09 	lds	r24, 0x0912
   10e46:	90 91 13 09 	lds	r25, 0x0913
   10e4a:	64 2f       	mov	r22, r20
   10e4c:	f9 01       	movw	r30, r18
   10e4e:	09 95       	icall

	return;
   10e50:	00 00       	nop
   10e52:	01 c0       	rjmp	.+2      	; 0x10e56 <vCoRoutineSchedule+0x100>
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
   10e54:	00 00       	nop

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
   10e56:	0f 90       	pop	r0
   10e58:	0f 90       	pop	r0
   10e5a:	df 91       	pop	r29
   10e5c:	cf 91       	pop	r28
   10e5e:	08 95       	ret

00010e60 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
   10e60:	cf 93       	push	r28
   10e62:	df 93       	push	r29
   10e64:	1f 92       	push	r1
   10e66:	cd b7       	in	r28, 0x3d	; 61
   10e68:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
   10e6a:	19 82       	std	Y+1, r1	; 0x01
   10e6c:	13 c0       	rjmp	.+38     	; 0x10e94 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
   10e6e:	89 81       	ldd	r24, Y+1	; 0x01
   10e70:	28 2f       	mov	r18, r24
   10e72:	30 e0       	ldi	r19, 0x00	; 0
   10e74:	c9 01       	movw	r24, r18
   10e76:	88 0f       	add	r24, r24
   10e78:	99 1f       	adc	r25, r25
   10e7a:	88 0f       	add	r24, r24
   10e7c:	99 1f       	adc	r25, r25
   10e7e:	88 0f       	add	r24, r24
   10e80:	99 1f       	adc	r25, r25
   10e82:	82 0f       	add	r24, r18
   10e84:	93 1f       	adc	r25, r19
   10e86:	8c 5e       	subi	r24, 0xEC	; 236
   10e88:	96 4f       	sbci	r25, 0xF6	; 246
   10e8a:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
   10e8e:	89 81       	ldd	r24, Y+1	; 0x01
   10e90:	8f 5f       	subi	r24, 0xFF	; 255
   10e92:	89 83       	std	Y+1, r24	; 0x01
   10e94:	89 81       	ldd	r24, Y+1	; 0x01
   10e96:	82 30       	cpi	r24, 0x02	; 2
   10e98:	50 f3       	brcs	.-44     	; 0x10e6e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
   10e9a:	86 e2       	ldi	r24, 0x26	; 38
   10e9c:	99 e0       	ldi	r25, 0x09	; 9
   10e9e:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
   10ea2:	8f e2       	ldi	r24, 0x2F	; 47
   10ea4:	99 e0       	ldi	r25, 0x09	; 9
   10ea6:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
   10eaa:	8c e3       	ldi	r24, 0x3C	; 60
   10eac:	99 e0       	ldi	r25, 0x09	; 9
   10eae:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
   10eb2:	86 e2       	ldi	r24, 0x26	; 38
   10eb4:	99 e0       	ldi	r25, 0x09	; 9
   10eb6:	90 93 39 09 	sts	0x0939, r25
   10eba:	80 93 38 09 	sts	0x0938, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
   10ebe:	8f e2       	ldi	r24, 0x2F	; 47
   10ec0:	99 e0       	ldi	r25, 0x09	; 9
   10ec2:	90 93 3b 09 	sts	0x093B, r25
   10ec6:	80 93 3a 09 	sts	0x093A, r24
}
   10eca:	0f 90       	pop	r0
   10ecc:	df 91       	pop	r29
   10ece:	cf 91       	pop	r28
   10ed0:	08 95       	ret

00010ed2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
   10ed2:	cf 93       	push	r28
   10ed4:	df 93       	push	r29
   10ed6:	00 d0       	rcall	.+0      	; 0x10ed8 <xCoRoutineRemoveFromEventList+0x6>
   10ed8:	00 d0       	rcall	.+0      	; 0x10eda <xCoRoutineRemoveFromEventList+0x8>
   10eda:	1f 92       	push	r1
   10edc:	cd b7       	in	r28, 0x3d	; 61
   10ede:	de b7       	in	r29, 0x3e	; 62
   10ee0:	9d 83       	std	Y+5, r25	; 0x05
   10ee2:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   10ee4:	8c 81       	ldd	r24, Y+4	; 0x04
   10ee6:	9d 81       	ldd	r25, Y+5	; 0x05
   10ee8:	fc 01       	movw	r30, r24
   10eea:	85 81       	ldd	r24, Z+5	; 0x05
   10eec:	96 81       	ldd	r25, Z+6	; 0x06
   10eee:	fc 01       	movw	r30, r24
   10ef0:	86 81       	ldd	r24, Z+6	; 0x06
   10ef2:	97 81       	ldd	r25, Z+7	; 0x07
   10ef4:	9b 83       	std	Y+3, r25	; 0x03
   10ef6:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
   10ef8:	8a 81       	ldd	r24, Y+2	; 0x02
   10efa:	9b 81       	ldd	r25, Y+3	; 0x03
   10efc:	0c 96       	adiw	r24, 0x0c	; 12
   10efe:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
   10f02:	8a 81       	ldd	r24, Y+2	; 0x02
   10f04:	9b 81       	ldd	r25, Y+3	; 0x03
   10f06:	0c 96       	adiw	r24, 0x0c	; 12
   10f08:	bc 01       	movw	r22, r24
   10f0a:	8c e3       	ldi	r24, 0x3C	; 60
   10f0c:	99 e0       	ldi	r25, 0x09	; 9
   10f0e:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
   10f12:	8a 81       	ldd	r24, Y+2	; 0x02
   10f14:	9b 81       	ldd	r25, Y+3	; 0x03
   10f16:	fc 01       	movw	r30, r24
   10f18:	26 89       	ldd	r18, Z+22	; 0x16
   10f1a:	80 91 12 09 	lds	r24, 0x0912
   10f1e:	90 91 13 09 	lds	r25, 0x0913
   10f22:	fc 01       	movw	r30, r24
   10f24:	86 89       	ldd	r24, Z+22	; 0x16
   10f26:	28 17       	cp	r18, r24
   10f28:	18 f0       	brcs	.+6      	; 0x10f30 <xCoRoutineRemoveFromEventList+0x5e>
	{
		xReturn = pdTRUE;
   10f2a:	81 e0       	ldi	r24, 0x01	; 1
   10f2c:	89 83       	std	Y+1, r24	; 0x01
   10f2e:	01 c0       	rjmp	.+2      	; 0x10f32 <xCoRoutineRemoveFromEventList+0x60>
	}
	else
	{
		xReturn = pdFALSE;
   10f30:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
   10f32:	89 81       	ldd	r24, Y+1	; 0x01
}
   10f34:	0f 90       	pop	r0
   10f36:	0f 90       	pop	r0
   10f38:	0f 90       	pop	r0
   10f3a:	0f 90       	pop	r0
   10f3c:	0f 90       	pop	r0
   10f3e:	df 91       	pop	r29
   10f40:	cf 91       	pop	r28
   10f42:	08 95       	ret

00010f44 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   10f44:	cf 93       	push	r28
   10f46:	df 93       	push	r29
   10f48:	00 d0       	rcall	.+0      	; 0x10f4a <pvPortMalloc+0x6>
   10f4a:	00 d0       	rcall	.+0      	; 0x10f4c <pvPortMalloc+0x8>
   10f4c:	cd b7       	in	r28, 0x3d	; 61
   10f4e:	de b7       	in	r29, 0x3e	; 62
   10f50:	9c 83       	std	Y+4, r25	; 0x04
   10f52:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn;

	vTaskSuspendAll();
   10f54:	0e 94 a1 96 	call	0x12d42	; 0x12d42 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
   10f58:	8b 81       	ldd	r24, Y+3	; 0x03
   10f5a:	9c 81       	ldd	r25, Y+4	; 0x04
   10f5c:	0e 94 5a ae 	call	0x15cb4	; 0x15cb4 <malloc>
   10f60:	9a 83       	std	Y+2, r25	; 0x02
   10f62:	89 83       	std	Y+1, r24	; 0x01
	}
	xTaskResumeAll();
   10f64:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif
	
	return pvReturn;
   10f68:	89 81       	ldd	r24, Y+1	; 0x01
   10f6a:	9a 81       	ldd	r25, Y+2	; 0x02
}
   10f6c:	0f 90       	pop	r0
   10f6e:	0f 90       	pop	r0
   10f70:	0f 90       	pop	r0
   10f72:	0f 90       	pop	r0
   10f74:	df 91       	pop	r29
   10f76:	cf 91       	pop	r28
   10f78:	08 95       	ret

00010f7a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   10f7a:	cf 93       	push	r28
   10f7c:	df 93       	push	r29
   10f7e:	00 d0       	rcall	.+0      	; 0x10f80 <vPortFree+0x6>
   10f80:	cd b7       	in	r28, 0x3d	; 61
   10f82:	de b7       	in	r29, 0x3e	; 62
   10f84:	9a 83       	std	Y+2, r25	; 0x02
   10f86:	89 83       	std	Y+1, r24	; 0x01
	if( pv )
   10f88:	89 81       	ldd	r24, Y+1	; 0x01
   10f8a:	9a 81       	ldd	r25, Y+2	; 0x02
   10f8c:	00 97       	sbiw	r24, 0x00	; 0
   10f8e:	41 f0       	breq	.+16     	; 0x10fa0 <vPortFree+0x26>
	{
		vTaskSuspendAll();
   10f90:	0e 94 a1 96 	call	0x12d42	; 0x12d42 <vTaskSuspendAll>
		{
			free( pv );
   10f94:	89 81       	ldd	r24, Y+1	; 0x01
   10f96:	9a 81       	ldd	r25, Y+2	; 0x02
   10f98:	0e 94 f0 ae 	call	0x15de0	; 0x15de0 <free>
		}
		xTaskResumeAll();
   10f9c:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>
	}
}
   10fa0:	0f 90       	pop	r0
   10fa2:	0f 90       	pop	r0
   10fa4:	df 91       	pop	r29
   10fa6:	cf 91       	pop	r28
   10fa8:	08 95       	ret

00010faa <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
   10faa:	cf 93       	push	r28
   10fac:	df 93       	push	r29
   10fae:	00 d0       	rcall	.+0      	; 0x10fb0 <vListInitialise+0x6>
   10fb0:	cd b7       	in	r28, 0x3d	; 61
   10fb2:	de b7       	in	r29, 0x3e	; 62
   10fb4:	9a 83       	std	Y+2, r25	; 0x02
   10fb6:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
   10fb8:	89 81       	ldd	r24, Y+1	; 0x01
   10fba:	9a 81       	ldd	r25, Y+2	; 0x02
   10fbc:	9c 01       	movw	r18, r24
   10fbe:	2d 5f       	subi	r18, 0xFD	; 253
   10fc0:	3f 4f       	sbci	r19, 0xFF	; 255
   10fc2:	89 81       	ldd	r24, Y+1	; 0x01
   10fc4:	9a 81       	ldd	r25, Y+2	; 0x02
   10fc6:	fc 01       	movw	r30, r24
   10fc8:	32 83       	std	Z+2, r19	; 0x02
   10fca:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   10fcc:	89 81       	ldd	r24, Y+1	; 0x01
   10fce:	9a 81       	ldd	r25, Y+2	; 0x02
   10fd0:	2f ef       	ldi	r18, 0xFF	; 255
   10fd2:	3f ef       	ldi	r19, 0xFF	; 255
   10fd4:	fc 01       	movw	r30, r24
   10fd6:	34 83       	std	Z+4, r19	; 0x04
   10fd8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
   10fda:	89 81       	ldd	r24, Y+1	; 0x01
   10fdc:	9a 81       	ldd	r25, Y+2	; 0x02
   10fde:	9c 01       	movw	r18, r24
   10fe0:	2d 5f       	subi	r18, 0xFD	; 253
   10fe2:	3f 4f       	sbci	r19, 0xFF	; 255
   10fe4:	89 81       	ldd	r24, Y+1	; 0x01
   10fe6:	9a 81       	ldd	r25, Y+2	; 0x02
   10fe8:	fc 01       	movw	r30, r24
   10fea:	36 83       	std	Z+6, r19	; 0x06
   10fec:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
   10fee:	89 81       	ldd	r24, Y+1	; 0x01
   10ff0:	9a 81       	ldd	r25, Y+2	; 0x02
   10ff2:	9c 01       	movw	r18, r24
   10ff4:	2d 5f       	subi	r18, 0xFD	; 253
   10ff6:	3f 4f       	sbci	r19, 0xFF	; 255
   10ff8:	89 81       	ldd	r24, Y+1	; 0x01
   10ffa:	9a 81       	ldd	r25, Y+2	; 0x02
   10ffc:	fc 01       	movw	r30, r24
   10ffe:	30 87       	std	Z+8, r19	; 0x08
   11000:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
   11002:	89 81       	ldd	r24, Y+1	; 0x01
   11004:	9a 81       	ldd	r25, Y+2	; 0x02
   11006:	fc 01       	movw	r30, r24
   11008:	10 82       	st	Z, r1
}
   1100a:	0f 90       	pop	r0
   1100c:	0f 90       	pop	r0
   1100e:	df 91       	pop	r29
   11010:	cf 91       	pop	r28
   11012:	08 95       	ret

00011014 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
   11014:	cf 93       	push	r28
   11016:	df 93       	push	r29
   11018:	00 d0       	rcall	.+0      	; 0x1101a <vListInitialiseItem+0x6>
   1101a:	cd b7       	in	r28, 0x3d	; 61
   1101c:	de b7       	in	r29, 0x3e	; 62
   1101e:	9a 83       	std	Y+2, r25	; 0x02
   11020:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   11022:	89 81       	ldd	r24, Y+1	; 0x01
   11024:	9a 81       	ldd	r25, Y+2	; 0x02
   11026:	fc 01       	movw	r30, r24
   11028:	11 86       	std	Z+9, r1	; 0x09
   1102a:	10 86       	std	Z+8, r1	; 0x08
}
   1102c:	0f 90       	pop	r0
   1102e:	0f 90       	pop	r0
   11030:	df 91       	pop	r29
   11032:	cf 91       	pop	r28
   11034:	08 95       	ret

00011036 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
   11036:	cf 93       	push	r28
   11038:	df 93       	push	r29
   1103a:	00 d0       	rcall	.+0      	; 0x1103c <vListInsertEnd+0x6>
   1103c:	00 d0       	rcall	.+0      	; 0x1103e <vListInsertEnd+0x8>
   1103e:	00 d0       	rcall	.+0      	; 0x11040 <vListInsertEnd+0xa>
   11040:	cd b7       	in	r28, 0x3d	; 61
   11042:	de b7       	in	r29, 0x3e	; 62
   11044:	9c 83       	std	Y+4, r25	; 0x04
   11046:	8b 83       	std	Y+3, r24	; 0x03
   11048:	7e 83       	std	Y+6, r23	; 0x06
   1104a:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
   1104c:	8b 81       	ldd	r24, Y+3	; 0x03
   1104e:	9c 81       	ldd	r25, Y+4	; 0x04
   11050:	fc 01       	movw	r30, r24
   11052:	81 81       	ldd	r24, Z+1	; 0x01
   11054:	92 81       	ldd	r25, Z+2	; 0x02
   11056:	9a 83       	std	Y+2, r25	; 0x02
   11058:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
   1105a:	89 81       	ldd	r24, Y+1	; 0x01
   1105c:	9a 81       	ldd	r25, Y+2	; 0x02
   1105e:	fc 01       	movw	r30, r24
   11060:	22 81       	ldd	r18, Z+2	; 0x02
   11062:	33 81       	ldd	r19, Z+3	; 0x03
   11064:	8d 81       	ldd	r24, Y+5	; 0x05
   11066:	9e 81       	ldd	r25, Y+6	; 0x06
   11068:	fc 01       	movw	r30, r24
   1106a:	33 83       	std	Z+3, r19	; 0x03
   1106c:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
   1106e:	8b 81       	ldd	r24, Y+3	; 0x03
   11070:	9c 81       	ldd	r25, Y+4	; 0x04
   11072:	fc 01       	movw	r30, r24
   11074:	21 81       	ldd	r18, Z+1	; 0x01
   11076:	32 81       	ldd	r19, Z+2	; 0x02
   11078:	8d 81       	ldd	r24, Y+5	; 0x05
   1107a:	9e 81       	ldd	r25, Y+6	; 0x06
   1107c:	fc 01       	movw	r30, r24
   1107e:	35 83       	std	Z+5, r19	; 0x05
   11080:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
   11082:	89 81       	ldd	r24, Y+1	; 0x01
   11084:	9a 81       	ldd	r25, Y+2	; 0x02
   11086:	fc 01       	movw	r30, r24
   11088:	82 81       	ldd	r24, Z+2	; 0x02
   1108a:	93 81       	ldd	r25, Z+3	; 0x03
   1108c:	2d 81       	ldd	r18, Y+5	; 0x05
   1108e:	3e 81       	ldd	r19, Y+6	; 0x06
   11090:	fc 01       	movw	r30, r24
   11092:	35 83       	std	Z+5, r19	; 0x05
   11094:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
   11096:	89 81       	ldd	r24, Y+1	; 0x01
   11098:	9a 81       	ldd	r25, Y+2	; 0x02
   1109a:	2d 81       	ldd	r18, Y+5	; 0x05
   1109c:	3e 81       	ldd	r19, Y+6	; 0x06
   1109e:	fc 01       	movw	r30, r24
   110a0:	33 83       	std	Z+3, r19	; 0x03
   110a2:	22 83       	std	Z+2, r18	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
   110a4:	8b 81       	ldd	r24, Y+3	; 0x03
   110a6:	9c 81       	ldd	r25, Y+4	; 0x04
   110a8:	2d 81       	ldd	r18, Y+5	; 0x05
   110aa:	3e 81       	ldd	r19, Y+6	; 0x06
   110ac:	fc 01       	movw	r30, r24
   110ae:	32 83       	std	Z+2, r19	; 0x02
   110b0:	21 83       	std	Z+1, r18	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   110b2:	8d 81       	ldd	r24, Y+5	; 0x05
   110b4:	9e 81       	ldd	r25, Y+6	; 0x06
   110b6:	2b 81       	ldd	r18, Y+3	; 0x03
   110b8:	3c 81       	ldd	r19, Y+4	; 0x04
   110ba:	fc 01       	movw	r30, r24
   110bc:	31 87       	std	Z+9, r19	; 0x09
   110be:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
   110c0:	8b 81       	ldd	r24, Y+3	; 0x03
   110c2:	9c 81       	ldd	r25, Y+4	; 0x04
   110c4:	fc 01       	movw	r30, r24
   110c6:	80 81       	ld	r24, Z
   110c8:	28 2f       	mov	r18, r24
   110ca:	2f 5f       	subi	r18, 0xFF	; 255
   110cc:	8b 81       	ldd	r24, Y+3	; 0x03
   110ce:	9c 81       	ldd	r25, Y+4	; 0x04
   110d0:	fc 01       	movw	r30, r24
   110d2:	20 83       	st	Z, r18
}
   110d4:	26 96       	adiw	r28, 0x06	; 6
   110d6:	0f b6       	in	r0, 0x3f	; 63
   110d8:	f8 94       	cli
   110da:	de bf       	out	0x3e, r29	; 62
   110dc:	0f be       	out	0x3f, r0	; 63
   110de:	cd bf       	out	0x3d, r28	; 61
   110e0:	df 91       	pop	r29
   110e2:	cf 91       	pop	r28
   110e4:	08 95       	ret

000110e6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
   110e6:	cf 93       	push	r28
   110e8:	df 93       	push	r29
   110ea:	cd b7       	in	r28, 0x3d	; 61
   110ec:	de b7       	in	r29, 0x3e	; 62
   110ee:	28 97       	sbiw	r28, 0x08	; 8
   110f0:	0f b6       	in	r0, 0x3f	; 63
   110f2:	f8 94       	cli
   110f4:	de bf       	out	0x3e, r29	; 62
   110f6:	0f be       	out	0x3f, r0	; 63
   110f8:	cd bf       	out	0x3d, r28	; 61
   110fa:	9e 83       	std	Y+6, r25	; 0x06
   110fc:	8d 83       	std	Y+5, r24	; 0x05
   110fe:	78 87       	std	Y+8, r23	; 0x08
   11100:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
   11102:	8f 81       	ldd	r24, Y+7	; 0x07
   11104:	98 85       	ldd	r25, Y+8	; 0x08
   11106:	fc 01       	movw	r30, r24
   11108:	80 81       	ld	r24, Z
   1110a:	91 81       	ldd	r25, Z+1	; 0x01
   1110c:	9c 83       	std	Y+4, r25	; 0x04
   1110e:	8b 83       	std	Y+3, r24	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   11110:	8b 81       	ldd	r24, Y+3	; 0x03
   11112:	9c 81       	ldd	r25, Y+4	; 0x04
   11114:	8f 3f       	cpi	r24, 0xFF	; 255
   11116:	ff ef       	ldi	r31, 0xFF	; 255
   11118:	9f 07       	cpc	r25, r31
   1111a:	41 f4       	brne	.+16     	; 0x1112c <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   1111c:	8d 81       	ldd	r24, Y+5	; 0x05
   1111e:	9e 81       	ldd	r25, Y+6	; 0x06
   11120:	fc 01       	movw	r30, r24
   11122:	87 81       	ldd	r24, Z+7	; 0x07
   11124:	90 85       	ldd	r25, Z+8	; 0x08
   11126:	9a 83       	std	Y+2, r25	; 0x02
   11128:	89 83       	std	Y+1, r24	; 0x01
   1112a:	1a c0       	rjmp	.+52     	; 0x11160 <vListInsert+0x7a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
   1112c:	8d 81       	ldd	r24, Y+5	; 0x05
   1112e:	9e 81       	ldd	r25, Y+6	; 0x06
   11130:	03 96       	adiw	r24, 0x03	; 3
   11132:	9a 83       	std	Y+2, r25	; 0x02
   11134:	89 83       	std	Y+1, r24	; 0x01
   11136:	07 c0       	rjmp	.+14     	; 0x11146 <vListInsert+0x60>
   11138:	89 81       	ldd	r24, Y+1	; 0x01
   1113a:	9a 81       	ldd	r25, Y+2	; 0x02
   1113c:	fc 01       	movw	r30, r24
   1113e:	82 81       	ldd	r24, Z+2	; 0x02
   11140:	93 81       	ldd	r25, Z+3	; 0x03
   11142:	9a 83       	std	Y+2, r25	; 0x02
   11144:	89 83       	std	Y+1, r24	; 0x01
   11146:	89 81       	ldd	r24, Y+1	; 0x01
   11148:	9a 81       	ldd	r25, Y+2	; 0x02
   1114a:	fc 01       	movw	r30, r24
   1114c:	82 81       	ldd	r24, Z+2	; 0x02
   1114e:	93 81       	ldd	r25, Z+3	; 0x03
   11150:	fc 01       	movw	r30, r24
   11152:	20 81       	ld	r18, Z
   11154:	31 81       	ldd	r19, Z+1	; 0x01
   11156:	8b 81       	ldd	r24, Y+3	; 0x03
   11158:	9c 81       	ldd	r25, Y+4	; 0x04
   1115a:	82 17       	cp	r24, r18
   1115c:	93 07       	cpc	r25, r19
   1115e:	60 f7       	brcc	.-40     	; 0x11138 <vListInsert+0x52>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   11160:	89 81       	ldd	r24, Y+1	; 0x01
   11162:	9a 81       	ldd	r25, Y+2	; 0x02
   11164:	fc 01       	movw	r30, r24
   11166:	22 81       	ldd	r18, Z+2	; 0x02
   11168:	33 81       	ldd	r19, Z+3	; 0x03
   1116a:	8f 81       	ldd	r24, Y+7	; 0x07
   1116c:	98 85       	ldd	r25, Y+8	; 0x08
   1116e:	fc 01       	movw	r30, r24
   11170:	33 83       	std	Z+3, r19	; 0x03
   11172:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
   11174:	8f 81       	ldd	r24, Y+7	; 0x07
   11176:	98 85       	ldd	r25, Y+8	; 0x08
   11178:	fc 01       	movw	r30, r24
   1117a:	82 81       	ldd	r24, Z+2	; 0x02
   1117c:	93 81       	ldd	r25, Z+3	; 0x03
   1117e:	2f 81       	ldd	r18, Y+7	; 0x07
   11180:	38 85       	ldd	r19, Y+8	; 0x08
   11182:	fc 01       	movw	r30, r24
   11184:	35 83       	std	Z+5, r19	; 0x05
   11186:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
   11188:	8f 81       	ldd	r24, Y+7	; 0x07
   1118a:	98 85       	ldd	r25, Y+8	; 0x08
   1118c:	29 81       	ldd	r18, Y+1	; 0x01
   1118e:	3a 81       	ldd	r19, Y+2	; 0x02
   11190:	fc 01       	movw	r30, r24
   11192:	35 83       	std	Z+5, r19	; 0x05
   11194:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
   11196:	89 81       	ldd	r24, Y+1	; 0x01
   11198:	9a 81       	ldd	r25, Y+2	; 0x02
   1119a:	2f 81       	ldd	r18, Y+7	; 0x07
   1119c:	38 85       	ldd	r19, Y+8	; 0x08
   1119e:	fc 01       	movw	r30, r24
   111a0:	33 83       	std	Z+3, r19	; 0x03
   111a2:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   111a4:	8f 81       	ldd	r24, Y+7	; 0x07
   111a6:	98 85       	ldd	r25, Y+8	; 0x08
   111a8:	2d 81       	ldd	r18, Y+5	; 0x05
   111aa:	3e 81       	ldd	r19, Y+6	; 0x06
   111ac:	fc 01       	movw	r30, r24
   111ae:	31 87       	std	Z+9, r19	; 0x09
   111b0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
   111b2:	8d 81       	ldd	r24, Y+5	; 0x05
   111b4:	9e 81       	ldd	r25, Y+6	; 0x06
   111b6:	fc 01       	movw	r30, r24
   111b8:	80 81       	ld	r24, Z
   111ba:	28 2f       	mov	r18, r24
   111bc:	2f 5f       	subi	r18, 0xFF	; 255
   111be:	8d 81       	ldd	r24, Y+5	; 0x05
   111c0:	9e 81       	ldd	r25, Y+6	; 0x06
   111c2:	fc 01       	movw	r30, r24
   111c4:	20 83       	st	Z, r18
}
   111c6:	28 96       	adiw	r28, 0x08	; 8
   111c8:	0f b6       	in	r0, 0x3f	; 63
   111ca:	f8 94       	cli
   111cc:	de bf       	out	0x3e, r29	; 62
   111ce:	0f be       	out	0x3f, r0	; 63
   111d0:	cd bf       	out	0x3d, r28	; 61
   111d2:	df 91       	pop	r29
   111d4:	cf 91       	pop	r28
   111d6:	08 95       	ret

000111d8 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
   111d8:	cf 93       	push	r28
   111da:	df 93       	push	r29
   111dc:	00 d0       	rcall	.+0      	; 0x111de <uxListRemove+0x6>
   111de:	00 d0       	rcall	.+0      	; 0x111e0 <uxListRemove+0x8>
   111e0:	cd b7       	in	r28, 0x3d	; 61
   111e2:	de b7       	in	r29, 0x3e	; 62
   111e4:	9c 83       	std	Y+4, r25	; 0x04
   111e6:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   111e8:	8b 81       	ldd	r24, Y+3	; 0x03
   111ea:	9c 81       	ldd	r25, Y+4	; 0x04
   111ec:	fc 01       	movw	r30, r24
   111ee:	82 81       	ldd	r24, Z+2	; 0x02
   111f0:	93 81       	ldd	r25, Z+3	; 0x03
   111f2:	2b 81       	ldd	r18, Y+3	; 0x03
   111f4:	3c 81       	ldd	r19, Y+4	; 0x04
   111f6:	f9 01       	movw	r30, r18
   111f8:	24 81       	ldd	r18, Z+4	; 0x04
   111fa:	35 81       	ldd	r19, Z+5	; 0x05
   111fc:	fc 01       	movw	r30, r24
   111fe:	35 83       	std	Z+5, r19	; 0x05
   11200:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   11202:	8b 81       	ldd	r24, Y+3	; 0x03
   11204:	9c 81       	ldd	r25, Y+4	; 0x04
   11206:	fc 01       	movw	r30, r24
   11208:	84 81       	ldd	r24, Z+4	; 0x04
   1120a:	95 81       	ldd	r25, Z+5	; 0x05
   1120c:	2b 81       	ldd	r18, Y+3	; 0x03
   1120e:	3c 81       	ldd	r19, Y+4	; 0x04
   11210:	f9 01       	movw	r30, r18
   11212:	22 81       	ldd	r18, Z+2	; 0x02
   11214:	33 81       	ldd	r19, Z+3	; 0x03
   11216:	fc 01       	movw	r30, r24
   11218:	33 83       	std	Z+3, r19	; 0x03
   1121a:	22 83       	std	Z+2, r18	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
   1121c:	8b 81       	ldd	r24, Y+3	; 0x03
   1121e:	9c 81       	ldd	r25, Y+4	; 0x04
   11220:	fc 01       	movw	r30, r24
   11222:	80 85       	ldd	r24, Z+8	; 0x08
   11224:	91 85       	ldd	r25, Z+9	; 0x09
   11226:	9a 83       	std	Y+2, r25	; 0x02
   11228:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   1122a:	89 81       	ldd	r24, Y+1	; 0x01
   1122c:	9a 81       	ldd	r25, Y+2	; 0x02
   1122e:	fc 01       	movw	r30, r24
   11230:	21 81       	ldd	r18, Z+1	; 0x01
   11232:	32 81       	ldd	r19, Z+2	; 0x02
   11234:	8b 81       	ldd	r24, Y+3	; 0x03
   11236:	9c 81       	ldd	r25, Y+4	; 0x04
   11238:	28 17       	cp	r18, r24
   1123a:	39 07       	cpc	r19, r25
   1123c:	51 f4       	brne	.+20     	; 0x11252 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   1123e:	8b 81       	ldd	r24, Y+3	; 0x03
   11240:	9c 81       	ldd	r25, Y+4	; 0x04
   11242:	fc 01       	movw	r30, r24
   11244:	24 81       	ldd	r18, Z+4	; 0x04
   11246:	35 81       	ldd	r19, Z+5	; 0x05
   11248:	89 81       	ldd	r24, Y+1	; 0x01
   1124a:	9a 81       	ldd	r25, Y+2	; 0x02
   1124c:	fc 01       	movw	r30, r24
   1124e:	32 83       	std	Z+2, r19	; 0x02
   11250:	21 83       	std	Z+1, r18	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
   11252:	8b 81       	ldd	r24, Y+3	; 0x03
   11254:	9c 81       	ldd	r25, Y+4	; 0x04
   11256:	fc 01       	movw	r30, r24
   11258:	11 86       	std	Z+9, r1	; 0x09
   1125a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
   1125c:	89 81       	ldd	r24, Y+1	; 0x01
   1125e:	9a 81       	ldd	r25, Y+2	; 0x02
   11260:	fc 01       	movw	r30, r24
   11262:	80 81       	ld	r24, Z
   11264:	28 2f       	mov	r18, r24
   11266:	21 50       	subi	r18, 0x01	; 1
   11268:	89 81       	ldd	r24, Y+1	; 0x01
   1126a:	9a 81       	ldd	r25, Y+2	; 0x02
   1126c:	fc 01       	movw	r30, r24
   1126e:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
   11270:	89 81       	ldd	r24, Y+1	; 0x01
   11272:	9a 81       	ldd	r25, Y+2	; 0x02
   11274:	fc 01       	movw	r30, r24
   11276:	80 81       	ld	r24, Z
}
   11278:	0f 90       	pop	r0
   1127a:	0f 90       	pop	r0
   1127c:	0f 90       	pop	r0
   1127e:	0f 90       	pop	r0
   11280:	df 91       	pop	r29
   11282:	cf 91       	pop	r28
   11284:	08 95       	ret

00011286 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
   11286:	cf 93       	push	r28
   11288:	df 93       	push	r29
   1128a:	cd b7       	in	r28, 0x3d	; 61
   1128c:	de b7       	in	r29, 0x3e	; 62
   1128e:	28 97       	sbiw	r28, 0x08	; 8
   11290:	0f b6       	in	r0, 0x3f	; 63
   11292:	f8 94       	cli
   11294:	de bf       	out	0x3e, r29	; 62
   11296:	0f be       	out	0x3f, r0	; 63
   11298:	cd bf       	out	0x3d, r28	; 61
   1129a:	9c 83       	std	Y+4, r25	; 0x04
   1129c:	8b 83       	std	Y+3, r24	; 0x03
   1129e:	7e 83       	std	Y+6, r23	; 0x06
   112a0:	6d 83       	std	Y+5, r22	; 0x05
   112a2:	58 87       	std	Y+8, r21	; 0x08
   112a4:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
   112a6:	8b 81       	ldd	r24, Y+3	; 0x03
   112a8:	9c 81       	ldd	r25, Y+4	; 0x04
   112aa:	21 e1       	ldi	r18, 0x11	; 17
   112ac:	fc 01       	movw	r30, r24
   112ae:	20 83       	st	Z, r18
	pxTopOfStack--;
   112b0:	8b 81       	ldd	r24, Y+3	; 0x03
   112b2:	9c 81       	ldd	r25, Y+4	; 0x04
   112b4:	01 97       	sbiw	r24, 0x01	; 1
   112b6:	9c 83       	std	Y+4, r25	; 0x04
   112b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
   112ba:	8b 81       	ldd	r24, Y+3	; 0x03
   112bc:	9c 81       	ldd	r25, Y+4	; 0x04
   112be:	22 e2       	ldi	r18, 0x22	; 34
   112c0:	fc 01       	movw	r30, r24
   112c2:	20 83       	st	Z, r18
	pxTopOfStack--;
   112c4:	8b 81       	ldd	r24, Y+3	; 0x03
   112c6:	9c 81       	ldd	r25, Y+4	; 0x04
   112c8:	01 97       	sbiw	r24, 0x01	; 1
   112ca:	9c 83       	std	Y+4, r25	; 0x04
   112cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
   112ce:	8b 81       	ldd	r24, Y+3	; 0x03
   112d0:	9c 81       	ldd	r25, Y+4	; 0x04
   112d2:	23 e3       	ldi	r18, 0x33	; 51
   112d4:	fc 01       	movw	r30, r24
   112d6:	20 83       	st	Z, r18
	pxTopOfStack--;
   112d8:	8b 81       	ldd	r24, Y+3	; 0x03
   112da:	9c 81       	ldd	r25, Y+4	; 0x04
   112dc:	01 97       	sbiw	r24, 0x01	; 1
   112de:	9c 83       	std	Y+4, r25	; 0x04
   112e0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
   112e2:	8d 81       	ldd	r24, Y+5	; 0x05
   112e4:	9e 81       	ldd	r25, Y+6	; 0x06
   112e6:	9a 83       	std	Y+2, r25	; 0x02
   112e8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
   112ea:	29 81       	ldd	r18, Y+1	; 0x01
   112ec:	8b 81       	ldd	r24, Y+3	; 0x03
   112ee:	9c 81       	ldd	r25, Y+4	; 0x04
   112f0:	fc 01       	movw	r30, r24
   112f2:	20 83       	st	Z, r18
	pxTopOfStack--;
   112f4:	8b 81       	ldd	r24, Y+3	; 0x03
   112f6:	9c 81       	ldd	r25, Y+4	; 0x04
   112f8:	01 97       	sbiw	r24, 0x01	; 1
   112fa:	9c 83       	std	Y+4, r25	; 0x04
   112fc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
   112fe:	89 81       	ldd	r24, Y+1	; 0x01
   11300:	9a 81       	ldd	r25, Y+2	; 0x02
   11302:	89 2f       	mov	r24, r25
   11304:	99 27       	eor	r25, r25
   11306:	9a 83       	std	Y+2, r25	; 0x02
   11308:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
   1130a:	29 81       	ldd	r18, Y+1	; 0x01
   1130c:	8b 81       	ldd	r24, Y+3	; 0x03
   1130e:	9c 81       	ldd	r25, Y+4	; 0x04
   11310:	fc 01       	movw	r30, r24
   11312:	20 83       	st	Z, r18
	pxTopOfStack--;
   11314:	8b 81       	ldd	r24, Y+3	; 0x03
   11316:	9c 81       	ldd	r25, Y+4	; 0x04
   11318:	01 97       	sbiw	r24, 0x01	; 1
   1131a:	9c 83       	std	Y+4, r25	; 0x04
   1131c:	8b 83       	std	Y+3, r24	; 0x03
#endif // __AVR_3_BYTE_PC__
	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
   1131e:	8b 81       	ldd	r24, Y+3	; 0x03
   11320:	9c 81       	ldd	r25, Y+4	; 0x04
   11322:	fc 01       	movw	r30, r24
   11324:	10 82       	st	Z, r1
	pxTopOfStack--;
   11326:	8b 81       	ldd	r24, Y+3	; 0x03
   11328:	9c 81       	ldd	r25, Y+4	; 0x04
   1132a:	01 97       	sbiw	r24, 0x01	; 1
   1132c:	9c 83       	std	Y+4, r25	; 0x04
   1132e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
   11330:	8b 81       	ldd	r24, Y+3	; 0x03
   11332:	9c 81       	ldd	r25, Y+4	; 0x04
   11334:	20 e8       	ldi	r18, 0x80	; 128
   11336:	fc 01       	movw	r30, r24
   11338:	20 83       	st	Z, r18
	pxTopOfStack--;
   1133a:	8b 81       	ldd	r24, Y+3	; 0x03
   1133c:	9c 81       	ldd	r25, Y+4	; 0x04
   1133e:	01 97       	sbiw	r24, 0x01	; 1
   11340:	9c 83       	std	Y+4, r25	; 0x04
   11342:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
   11344:	8b 81       	ldd	r24, Y+3	; 0x03
   11346:	9c 81       	ldd	r25, Y+4	; 0x04
   11348:	fc 01       	movw	r30, r24
   1134a:	10 82       	st	Z, r1
	pxTopOfStack--;
   1134c:	8b 81       	ldd	r24, Y+3	; 0x03
   1134e:	9c 81       	ldd	r25, Y+4	; 0x04
   11350:	01 97       	sbiw	r24, 0x01	; 1
   11352:	9c 83       	std	Y+4, r25	; 0x04
   11354:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
   11356:	8b 81       	ldd	r24, Y+3	; 0x03
   11358:	9c 81       	ldd	r25, Y+4	; 0x04
   1135a:	22 e0       	ldi	r18, 0x02	; 2
   1135c:	fc 01       	movw	r30, r24
   1135e:	20 83       	st	Z, r18
	pxTopOfStack--;
   11360:	8b 81       	ldd	r24, Y+3	; 0x03
   11362:	9c 81       	ldd	r25, Y+4	; 0x04
   11364:	01 97       	sbiw	r24, 0x01	; 1
   11366:	9c 83       	std	Y+4, r25	; 0x04
   11368:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
   1136a:	8b 81       	ldd	r24, Y+3	; 0x03
   1136c:	9c 81       	ldd	r25, Y+4	; 0x04
   1136e:	23 e0       	ldi	r18, 0x03	; 3
   11370:	fc 01       	movw	r30, r24
   11372:	20 83       	st	Z, r18
	pxTopOfStack--;
   11374:	8b 81       	ldd	r24, Y+3	; 0x03
   11376:	9c 81       	ldd	r25, Y+4	; 0x04
   11378:	01 97       	sbiw	r24, 0x01	; 1
   1137a:	9c 83       	std	Y+4, r25	; 0x04
   1137c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
   1137e:	8b 81       	ldd	r24, Y+3	; 0x03
   11380:	9c 81       	ldd	r25, Y+4	; 0x04
   11382:	24 e0       	ldi	r18, 0x04	; 4
   11384:	fc 01       	movw	r30, r24
   11386:	20 83       	st	Z, r18
	pxTopOfStack--;
   11388:	8b 81       	ldd	r24, Y+3	; 0x03
   1138a:	9c 81       	ldd	r25, Y+4	; 0x04
   1138c:	01 97       	sbiw	r24, 0x01	; 1
   1138e:	9c 83       	std	Y+4, r25	; 0x04
   11390:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
   11392:	8b 81       	ldd	r24, Y+3	; 0x03
   11394:	9c 81       	ldd	r25, Y+4	; 0x04
   11396:	25 e0       	ldi	r18, 0x05	; 5
   11398:	fc 01       	movw	r30, r24
   1139a:	20 83       	st	Z, r18
	pxTopOfStack--;
   1139c:	8b 81       	ldd	r24, Y+3	; 0x03
   1139e:	9c 81       	ldd	r25, Y+4	; 0x04
   113a0:	01 97       	sbiw	r24, 0x01	; 1
   113a2:	9c 83       	std	Y+4, r25	; 0x04
   113a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
   113a6:	8b 81       	ldd	r24, Y+3	; 0x03
   113a8:	9c 81       	ldd	r25, Y+4	; 0x04
   113aa:	26 e0       	ldi	r18, 0x06	; 6
   113ac:	fc 01       	movw	r30, r24
   113ae:	20 83       	st	Z, r18
	pxTopOfStack--;
   113b0:	8b 81       	ldd	r24, Y+3	; 0x03
   113b2:	9c 81       	ldd	r25, Y+4	; 0x04
   113b4:	01 97       	sbiw	r24, 0x01	; 1
   113b6:	9c 83       	std	Y+4, r25	; 0x04
   113b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
   113ba:	8b 81       	ldd	r24, Y+3	; 0x03
   113bc:	9c 81       	ldd	r25, Y+4	; 0x04
   113be:	27 e0       	ldi	r18, 0x07	; 7
   113c0:	fc 01       	movw	r30, r24
   113c2:	20 83       	st	Z, r18
	pxTopOfStack--;
   113c4:	8b 81       	ldd	r24, Y+3	; 0x03
   113c6:	9c 81       	ldd	r25, Y+4	; 0x04
   113c8:	01 97       	sbiw	r24, 0x01	; 1
   113ca:	9c 83       	std	Y+4, r25	; 0x04
   113cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
   113ce:	8b 81       	ldd	r24, Y+3	; 0x03
   113d0:	9c 81       	ldd	r25, Y+4	; 0x04
   113d2:	28 e0       	ldi	r18, 0x08	; 8
   113d4:	fc 01       	movw	r30, r24
   113d6:	20 83       	st	Z, r18
	pxTopOfStack--;
   113d8:	8b 81       	ldd	r24, Y+3	; 0x03
   113da:	9c 81       	ldd	r25, Y+4	; 0x04
   113dc:	01 97       	sbiw	r24, 0x01	; 1
   113de:	9c 83       	std	Y+4, r25	; 0x04
   113e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
   113e2:	8b 81       	ldd	r24, Y+3	; 0x03
   113e4:	9c 81       	ldd	r25, Y+4	; 0x04
   113e6:	29 e0       	ldi	r18, 0x09	; 9
   113e8:	fc 01       	movw	r30, r24
   113ea:	20 83       	st	Z, r18
	pxTopOfStack--;
   113ec:	8b 81       	ldd	r24, Y+3	; 0x03
   113ee:	9c 81       	ldd	r25, Y+4	; 0x04
   113f0:	01 97       	sbiw	r24, 0x01	; 1
   113f2:	9c 83       	std	Y+4, r25	; 0x04
   113f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
   113f6:	8b 81       	ldd	r24, Y+3	; 0x03
   113f8:	9c 81       	ldd	r25, Y+4	; 0x04
   113fa:	20 e1       	ldi	r18, 0x10	; 16
   113fc:	fc 01       	movw	r30, r24
   113fe:	20 83       	st	Z, r18
	pxTopOfStack--;
   11400:	8b 81       	ldd	r24, Y+3	; 0x03
   11402:	9c 81       	ldd	r25, Y+4	; 0x04
   11404:	01 97       	sbiw	r24, 0x01	; 1
   11406:	9c 83       	std	Y+4, r25	; 0x04
   11408:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
   1140a:	8b 81       	ldd	r24, Y+3	; 0x03
   1140c:	9c 81       	ldd	r25, Y+4	; 0x04
   1140e:	21 e1       	ldi	r18, 0x11	; 17
   11410:	fc 01       	movw	r30, r24
   11412:	20 83       	st	Z, r18
	pxTopOfStack--;
   11414:	8b 81       	ldd	r24, Y+3	; 0x03
   11416:	9c 81       	ldd	r25, Y+4	; 0x04
   11418:	01 97       	sbiw	r24, 0x01	; 1
   1141a:	9c 83       	std	Y+4, r25	; 0x04
   1141c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
   1141e:	8b 81       	ldd	r24, Y+3	; 0x03
   11420:	9c 81       	ldd	r25, Y+4	; 0x04
   11422:	22 e1       	ldi	r18, 0x12	; 18
   11424:	fc 01       	movw	r30, r24
   11426:	20 83       	st	Z, r18
	pxTopOfStack--;
   11428:	8b 81       	ldd	r24, Y+3	; 0x03
   1142a:	9c 81       	ldd	r25, Y+4	; 0x04
   1142c:	01 97       	sbiw	r24, 0x01	; 1
   1142e:	9c 83       	std	Y+4, r25	; 0x04
   11430:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
   11432:	8b 81       	ldd	r24, Y+3	; 0x03
   11434:	9c 81       	ldd	r25, Y+4	; 0x04
   11436:	23 e1       	ldi	r18, 0x13	; 19
   11438:	fc 01       	movw	r30, r24
   1143a:	20 83       	st	Z, r18
	pxTopOfStack--;
   1143c:	8b 81       	ldd	r24, Y+3	; 0x03
   1143e:	9c 81       	ldd	r25, Y+4	; 0x04
   11440:	01 97       	sbiw	r24, 0x01	; 1
   11442:	9c 83       	std	Y+4, r25	; 0x04
   11444:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
   11446:	8b 81       	ldd	r24, Y+3	; 0x03
   11448:	9c 81       	ldd	r25, Y+4	; 0x04
   1144a:	24 e1       	ldi	r18, 0x14	; 20
   1144c:	fc 01       	movw	r30, r24
   1144e:	20 83       	st	Z, r18
	pxTopOfStack--;
   11450:	8b 81       	ldd	r24, Y+3	; 0x03
   11452:	9c 81       	ldd	r25, Y+4	; 0x04
   11454:	01 97       	sbiw	r24, 0x01	; 1
   11456:	9c 83       	std	Y+4, r25	; 0x04
   11458:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
   1145a:	8b 81       	ldd	r24, Y+3	; 0x03
   1145c:	9c 81       	ldd	r25, Y+4	; 0x04
   1145e:	25 e1       	ldi	r18, 0x15	; 21
   11460:	fc 01       	movw	r30, r24
   11462:	20 83       	st	Z, r18
	pxTopOfStack--;
   11464:	8b 81       	ldd	r24, Y+3	; 0x03
   11466:	9c 81       	ldd	r25, Y+4	; 0x04
   11468:	01 97       	sbiw	r24, 0x01	; 1
   1146a:	9c 83       	std	Y+4, r25	; 0x04
   1146c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
   1146e:	8b 81       	ldd	r24, Y+3	; 0x03
   11470:	9c 81       	ldd	r25, Y+4	; 0x04
   11472:	26 e1       	ldi	r18, 0x16	; 22
   11474:	fc 01       	movw	r30, r24
   11476:	20 83       	st	Z, r18
	pxTopOfStack--;
   11478:	8b 81       	ldd	r24, Y+3	; 0x03
   1147a:	9c 81       	ldd	r25, Y+4	; 0x04
   1147c:	01 97       	sbiw	r24, 0x01	; 1
   1147e:	9c 83       	std	Y+4, r25	; 0x04
   11480:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
   11482:	8b 81       	ldd	r24, Y+3	; 0x03
   11484:	9c 81       	ldd	r25, Y+4	; 0x04
   11486:	27 e1       	ldi	r18, 0x17	; 23
   11488:	fc 01       	movw	r30, r24
   1148a:	20 83       	st	Z, r18
	pxTopOfStack--;
   1148c:	8b 81       	ldd	r24, Y+3	; 0x03
   1148e:	9c 81       	ldd	r25, Y+4	; 0x04
   11490:	01 97       	sbiw	r24, 0x01	; 1
   11492:	9c 83       	std	Y+4, r25	; 0x04
   11494:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
   11496:	8b 81       	ldd	r24, Y+3	; 0x03
   11498:	9c 81       	ldd	r25, Y+4	; 0x04
   1149a:	28 e1       	ldi	r18, 0x18	; 24
   1149c:	fc 01       	movw	r30, r24
   1149e:	20 83       	st	Z, r18
	pxTopOfStack--;
   114a0:	8b 81       	ldd	r24, Y+3	; 0x03
   114a2:	9c 81       	ldd	r25, Y+4	; 0x04
   114a4:	01 97       	sbiw	r24, 0x01	; 1
   114a6:	9c 83       	std	Y+4, r25	; 0x04
   114a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
   114aa:	8b 81       	ldd	r24, Y+3	; 0x03
   114ac:	9c 81       	ldd	r25, Y+4	; 0x04
   114ae:	29 e1       	ldi	r18, 0x19	; 25
   114b0:	fc 01       	movw	r30, r24
   114b2:	20 83       	st	Z, r18
	pxTopOfStack--;
   114b4:	8b 81       	ldd	r24, Y+3	; 0x03
   114b6:	9c 81       	ldd	r25, Y+4	; 0x04
   114b8:	01 97       	sbiw	r24, 0x01	; 1
   114ba:	9c 83       	std	Y+4, r25	; 0x04
   114bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
   114be:	8b 81       	ldd	r24, Y+3	; 0x03
   114c0:	9c 81       	ldd	r25, Y+4	; 0x04
   114c2:	20 e2       	ldi	r18, 0x20	; 32
   114c4:	fc 01       	movw	r30, r24
   114c6:	20 83       	st	Z, r18
	pxTopOfStack--;
   114c8:	8b 81       	ldd	r24, Y+3	; 0x03
   114ca:	9c 81       	ldd	r25, Y+4	; 0x04
   114cc:	01 97       	sbiw	r24, 0x01	; 1
   114ce:	9c 83       	std	Y+4, r25	; 0x04
   114d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
   114d2:	8b 81       	ldd	r24, Y+3	; 0x03
   114d4:	9c 81       	ldd	r25, Y+4	; 0x04
   114d6:	21 e2       	ldi	r18, 0x21	; 33
   114d8:	fc 01       	movw	r30, r24
   114da:	20 83       	st	Z, r18
	pxTopOfStack--;
   114dc:	8b 81       	ldd	r24, Y+3	; 0x03
   114de:	9c 81       	ldd	r25, Y+4	; 0x04
   114e0:	01 97       	sbiw	r24, 0x01	; 1
   114e2:	9c 83       	std	Y+4, r25	; 0x04
   114e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
   114e6:	8b 81       	ldd	r24, Y+3	; 0x03
   114e8:	9c 81       	ldd	r25, Y+4	; 0x04
   114ea:	22 e2       	ldi	r18, 0x22	; 34
   114ec:	fc 01       	movw	r30, r24
   114ee:	20 83       	st	Z, r18
	pxTopOfStack--;
   114f0:	8b 81       	ldd	r24, Y+3	; 0x03
   114f2:	9c 81       	ldd	r25, Y+4	; 0x04
   114f4:	01 97       	sbiw	r24, 0x01	; 1
   114f6:	9c 83       	std	Y+4, r25	; 0x04
   114f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
   114fa:	8b 81       	ldd	r24, Y+3	; 0x03
   114fc:	9c 81       	ldd	r25, Y+4	; 0x04
   114fe:	23 e2       	ldi	r18, 0x23	; 35
   11500:	fc 01       	movw	r30, r24
   11502:	20 83       	st	Z, r18
	pxTopOfStack--;
   11504:	8b 81       	ldd	r24, Y+3	; 0x03
   11506:	9c 81       	ldd	r25, Y+4	; 0x04
   11508:	01 97       	sbiw	r24, 0x01	; 1
   1150a:	9c 83       	std	Y+4, r25	; 0x04
   1150c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
   1150e:	8f 81       	ldd	r24, Y+7	; 0x07
   11510:	98 85       	ldd	r25, Y+8	; 0x08
   11512:	9a 83       	std	Y+2, r25	; 0x02
   11514:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
   11516:	29 81       	ldd	r18, Y+1	; 0x01
   11518:	8b 81       	ldd	r24, Y+3	; 0x03
   1151a:	9c 81       	ldd	r25, Y+4	; 0x04
   1151c:	fc 01       	movw	r30, r24
   1151e:	20 83       	st	Z, r18
	pxTopOfStack--;
   11520:	8b 81       	ldd	r24, Y+3	; 0x03
   11522:	9c 81       	ldd	r25, Y+4	; 0x04
   11524:	01 97       	sbiw	r24, 0x01	; 1
   11526:	9c 83       	std	Y+4, r25	; 0x04
   11528:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
   1152a:	89 81       	ldd	r24, Y+1	; 0x01
   1152c:	9a 81       	ldd	r25, Y+2	; 0x02
   1152e:	89 2f       	mov	r24, r25
   11530:	99 27       	eor	r25, r25
   11532:	9a 83       	std	Y+2, r25	; 0x02
   11534:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
   11536:	29 81       	ldd	r18, Y+1	; 0x01
   11538:	8b 81       	ldd	r24, Y+3	; 0x03
   1153a:	9c 81       	ldd	r25, Y+4	; 0x04
   1153c:	fc 01       	movw	r30, r24
   1153e:	20 83       	st	Z, r18
	pxTopOfStack--;
   11540:	8b 81       	ldd	r24, Y+3	; 0x03
   11542:	9c 81       	ldd	r25, Y+4	; 0x04
   11544:	01 97       	sbiw	r24, 0x01	; 1
   11546:	9c 83       	std	Y+4, r25	; 0x04
   11548:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
   1154a:	8b 81       	ldd	r24, Y+3	; 0x03
   1154c:	9c 81       	ldd	r25, Y+4	; 0x04
   1154e:	26 e2       	ldi	r18, 0x26	; 38
   11550:	fc 01       	movw	r30, r24
   11552:	20 83       	st	Z, r18
	pxTopOfStack--;
   11554:	8b 81       	ldd	r24, Y+3	; 0x03
   11556:	9c 81       	ldd	r25, Y+4	; 0x04
   11558:	01 97       	sbiw	r24, 0x01	; 1
   1155a:	9c 83       	std	Y+4, r25	; 0x04
   1155c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
   1155e:	8b 81       	ldd	r24, Y+3	; 0x03
   11560:	9c 81       	ldd	r25, Y+4	; 0x04
   11562:	27 e2       	ldi	r18, 0x27	; 39
   11564:	fc 01       	movw	r30, r24
   11566:	20 83       	st	Z, r18
	pxTopOfStack--;
   11568:	8b 81       	ldd	r24, Y+3	; 0x03
   1156a:	9c 81       	ldd	r25, Y+4	; 0x04
   1156c:	01 97       	sbiw	r24, 0x01	; 1
   1156e:	9c 83       	std	Y+4, r25	; 0x04
   11570:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
   11572:	8b 81       	ldd	r24, Y+3	; 0x03
   11574:	9c 81       	ldd	r25, Y+4	; 0x04
   11576:	28 e2       	ldi	r18, 0x28	; 40
   11578:	fc 01       	movw	r30, r24
   1157a:	20 83       	st	Z, r18
	pxTopOfStack--;
   1157c:	8b 81       	ldd	r24, Y+3	; 0x03
   1157e:	9c 81       	ldd	r25, Y+4	; 0x04
   11580:	01 97       	sbiw	r24, 0x01	; 1
   11582:	9c 83       	std	Y+4, r25	; 0x04
   11584:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
   11586:	8b 81       	ldd	r24, Y+3	; 0x03
   11588:	9c 81       	ldd	r25, Y+4	; 0x04
   1158a:	29 e2       	ldi	r18, 0x29	; 41
   1158c:	fc 01       	movw	r30, r24
   1158e:	20 83       	st	Z, r18
	pxTopOfStack--;
   11590:	8b 81       	ldd	r24, Y+3	; 0x03
   11592:	9c 81       	ldd	r25, Y+4	; 0x04
   11594:	01 97       	sbiw	r24, 0x01	; 1
   11596:	9c 83       	std	Y+4, r25	; 0x04
   11598:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
   1159a:	8b 81       	ldd	r24, Y+3	; 0x03
   1159c:	9c 81       	ldd	r25, Y+4	; 0x04
   1159e:	20 e3       	ldi	r18, 0x30	; 48
   115a0:	fc 01       	movw	r30, r24
   115a2:	20 83       	st	Z, r18
	pxTopOfStack--;
   115a4:	8b 81       	ldd	r24, Y+3	; 0x03
   115a6:	9c 81       	ldd	r25, Y+4	; 0x04
   115a8:	01 97       	sbiw	r24, 0x01	; 1
   115aa:	9c 83       	std	Y+4, r25	; 0x04
   115ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
   115ae:	8b 81       	ldd	r24, Y+3	; 0x03
   115b0:	9c 81       	ldd	r25, Y+4	; 0x04
   115b2:	21 e3       	ldi	r18, 0x31	; 49
   115b4:	fc 01       	movw	r30, r24
   115b6:	20 83       	st	Z, r18
	pxTopOfStack--;
   115b8:	8b 81       	ldd	r24, Y+3	; 0x03
   115ba:	9c 81       	ldd	r25, Y+4	; 0x04
   115bc:	01 97       	sbiw	r24, 0x01	; 1
   115be:	9c 83       	std	Y+4, r25	; 0x04
   115c0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
   115c2:	8b 81       	ldd	r24, Y+3	; 0x03
   115c4:	9c 81       	ldd	r25, Y+4	; 0x04
}
   115c6:	28 96       	adiw	r28, 0x08	; 8
   115c8:	0f b6       	in	r0, 0x3f	; 63
   115ca:	f8 94       	cli
   115cc:	de bf       	out	0x3e, r29	; 62
   115ce:	0f be       	out	0x3f, r0	; 63
   115d0:	cd bf       	out	0x3d, r28	; 61
   115d2:	df 91       	pop	r29
   115d4:	cf 91       	pop	r28
   115d6:	08 95       	ret

000115d8 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
   115d8:	cf 93       	push	r28
   115da:	df 93       	push	r29
   115dc:	cd b7       	in	r28, 0x3d	; 61
   115de:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
   115e0:	0e 94 dc 8b 	call	0x117b8	; 0x117b8 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
   115e4:	a0 91 4c 09 	lds	r26, 0x094C
   115e8:	b0 91 4d 09 	lds	r27, 0x094D
   115ec:	cd 91       	ld	r28, X+
   115ee:	cd bf       	out	0x3d, r28	; 61
   115f0:	dd 91       	ld	r29, X+
   115f2:	de bf       	out	0x3e, r29	; 62
   115f4:	ff 91       	pop	r31
   115f6:	ef 91       	pop	r30
   115f8:	df 91       	pop	r29
   115fa:	cf 91       	pop	r28
   115fc:	bf 91       	pop	r27
   115fe:	af 91       	pop	r26
   11600:	9f 91       	pop	r25
   11602:	8f 91       	pop	r24
   11604:	7f 91       	pop	r23
   11606:	6f 91       	pop	r22
   11608:	5f 91       	pop	r21
   1160a:	4f 91       	pop	r20
   1160c:	3f 91       	pop	r19
   1160e:	2f 91       	pop	r18
   11610:	1f 91       	pop	r17
   11612:	0f 91       	pop	r16
   11614:	ff 90       	pop	r15
   11616:	ef 90       	pop	r14
   11618:	df 90       	pop	r13
   1161a:	cf 90       	pop	r12
   1161c:	bf 90       	pop	r11
   1161e:	af 90       	pop	r10
   11620:	9f 90       	pop	r9
   11622:	8f 90       	pop	r8
   11624:	7f 90       	pop	r7
   11626:	6f 90       	pop	r6
   11628:	5f 90       	pop	r5
   1162a:	4f 90       	pop	r4
   1162c:	3f 90       	pop	r3
   1162e:	2f 90       	pop	r2
   11630:	1f 90       	pop	r1
   11632:	0f 90       	pop	r0
   11634:	0f be       	out	0x3f, r0	; 63
   11636:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
   11638:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
   1163a:	81 e0       	ldi	r24, 0x01	; 1
}
   1163c:	df 91       	pop	r29
   1163e:	cf 91       	pop	r28
   11640:	08 95       	ret

00011642 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
   11642:	cf 93       	push	r28
   11644:	df 93       	push	r29
   11646:	cd b7       	in	r28, 0x3d	; 61
   11648:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
   1164a:	df 91       	pop	r29
   1164c:	cf 91       	pop	r28
   1164e:	08 95       	ret

00011650 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
   11650:	0f 92       	push	r0
   11652:	0f b6       	in	r0, 0x3f	; 63
   11654:	f8 94       	cli
   11656:	0f 92       	push	r0
   11658:	1f 92       	push	r1
   1165a:	11 24       	eor	r1, r1
   1165c:	2f 92       	push	r2
   1165e:	3f 92       	push	r3
   11660:	4f 92       	push	r4
   11662:	5f 92       	push	r5
   11664:	6f 92       	push	r6
   11666:	7f 92       	push	r7
   11668:	8f 92       	push	r8
   1166a:	9f 92       	push	r9
   1166c:	af 92       	push	r10
   1166e:	bf 92       	push	r11
   11670:	cf 92       	push	r12
   11672:	df 92       	push	r13
   11674:	ef 92       	push	r14
   11676:	ff 92       	push	r15
   11678:	0f 93       	push	r16
   1167a:	1f 93       	push	r17
   1167c:	2f 93       	push	r18
   1167e:	3f 93       	push	r19
   11680:	4f 93       	push	r20
   11682:	5f 93       	push	r21
   11684:	6f 93       	push	r22
   11686:	7f 93       	push	r23
   11688:	8f 93       	push	r24
   1168a:	9f 93       	push	r25
   1168c:	af 93       	push	r26
   1168e:	bf 93       	push	r27
   11690:	cf 93       	push	r28
   11692:	df 93       	push	r29
   11694:	ef 93       	push	r30
   11696:	ff 93       	push	r31
   11698:	a0 91 4c 09 	lds	r26, 0x094C
   1169c:	b0 91 4d 09 	lds	r27, 0x094D
   116a0:	0d b6       	in	r0, 0x3d	; 61
   116a2:	0d 92       	st	X+, r0
   116a4:	0e b6       	in	r0, 0x3e	; 62
   116a6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
   116a8:	0e 94 55 98 	call	0x130aa	; 0x130aa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
   116ac:	a0 91 4c 09 	lds	r26, 0x094C
   116b0:	b0 91 4d 09 	lds	r27, 0x094D
   116b4:	cd 91       	ld	r28, X+
   116b6:	cd bf       	out	0x3d, r28	; 61
   116b8:	dd 91       	ld	r29, X+
   116ba:	de bf       	out	0x3e, r29	; 62
   116bc:	ff 91       	pop	r31
   116be:	ef 91       	pop	r30
   116c0:	df 91       	pop	r29
   116c2:	cf 91       	pop	r28
   116c4:	bf 91       	pop	r27
   116c6:	af 91       	pop	r26
   116c8:	9f 91       	pop	r25
   116ca:	8f 91       	pop	r24
   116cc:	7f 91       	pop	r23
   116ce:	6f 91       	pop	r22
   116d0:	5f 91       	pop	r21
   116d2:	4f 91       	pop	r20
   116d4:	3f 91       	pop	r19
   116d6:	2f 91       	pop	r18
   116d8:	1f 91       	pop	r17
   116da:	0f 91       	pop	r16
   116dc:	ff 90       	pop	r15
   116de:	ef 90       	pop	r14
   116e0:	df 90       	pop	r13
   116e2:	cf 90       	pop	r12
   116e4:	bf 90       	pop	r11
   116e6:	af 90       	pop	r10
   116e8:	9f 90       	pop	r9
   116ea:	8f 90       	pop	r8
   116ec:	7f 90       	pop	r7
   116ee:	6f 90       	pop	r6
   116f0:	5f 90       	pop	r5
   116f2:	4f 90       	pop	r4
   116f4:	3f 90       	pop	r3
   116f6:	2f 90       	pop	r2
   116f8:	1f 90       	pop	r1
   116fa:	0f 90       	pop	r0
   116fc:	0f be       	out	0x3f, r0	; 63
   116fe:	0f 90       	pop	r0

	asm volatile ( "ret" );
   11700:	08 95       	ret

00011702 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
   11702:	0f 92       	push	r0
   11704:	0f b6       	in	r0, 0x3f	; 63
   11706:	f8 94       	cli
   11708:	0f 92       	push	r0
   1170a:	1f 92       	push	r1
   1170c:	11 24       	eor	r1, r1
   1170e:	2f 92       	push	r2
   11710:	3f 92       	push	r3
   11712:	4f 92       	push	r4
   11714:	5f 92       	push	r5
   11716:	6f 92       	push	r6
   11718:	7f 92       	push	r7
   1171a:	8f 92       	push	r8
   1171c:	9f 92       	push	r9
   1171e:	af 92       	push	r10
   11720:	bf 92       	push	r11
   11722:	cf 92       	push	r12
   11724:	df 92       	push	r13
   11726:	ef 92       	push	r14
   11728:	ff 92       	push	r15
   1172a:	0f 93       	push	r16
   1172c:	1f 93       	push	r17
   1172e:	2f 93       	push	r18
   11730:	3f 93       	push	r19
   11732:	4f 93       	push	r20
   11734:	5f 93       	push	r21
   11736:	6f 93       	push	r22
   11738:	7f 93       	push	r23
   1173a:	8f 93       	push	r24
   1173c:	9f 93       	push	r25
   1173e:	af 93       	push	r26
   11740:	bf 93       	push	r27
   11742:	cf 93       	push	r28
   11744:	df 93       	push	r29
   11746:	ef 93       	push	r30
   11748:	ff 93       	push	r31
   1174a:	a0 91 4c 09 	lds	r26, 0x094C
   1174e:	b0 91 4d 09 	lds	r27, 0x094D
   11752:	0d b6       	in	r0, 0x3d	; 61
   11754:	0d 92       	st	X+, r0
   11756:	0e b6       	in	r0, 0x3e	; 62
   11758:	0d 92       	st	X+, r0
	vTaskIncrementTick();
   1175a:	0e 94 70 97 	call	0x12ee0	; 0x12ee0 <vTaskIncrementTick>
	vTaskSwitchContext();
   1175e:	0e 94 55 98 	call	0x130aa	; 0x130aa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
   11762:	a0 91 4c 09 	lds	r26, 0x094C
   11766:	b0 91 4d 09 	lds	r27, 0x094D
   1176a:	cd 91       	ld	r28, X+
   1176c:	cd bf       	out	0x3d, r28	; 61
   1176e:	dd 91       	ld	r29, X+
   11770:	de bf       	out	0x3e, r29	; 62
   11772:	ff 91       	pop	r31
   11774:	ef 91       	pop	r30
   11776:	df 91       	pop	r29
   11778:	cf 91       	pop	r28
   1177a:	bf 91       	pop	r27
   1177c:	af 91       	pop	r26
   1177e:	9f 91       	pop	r25
   11780:	8f 91       	pop	r24
   11782:	7f 91       	pop	r23
   11784:	6f 91       	pop	r22
   11786:	5f 91       	pop	r21
   11788:	4f 91       	pop	r20
   1178a:	3f 91       	pop	r19
   1178c:	2f 91       	pop	r18
   1178e:	1f 91       	pop	r17
   11790:	0f 91       	pop	r16
   11792:	ff 90       	pop	r15
   11794:	ef 90       	pop	r14
   11796:	df 90       	pop	r13
   11798:	cf 90       	pop	r12
   1179a:	bf 90       	pop	r11
   1179c:	af 90       	pop	r10
   1179e:	9f 90       	pop	r9
   117a0:	8f 90       	pop	r8
   117a2:	7f 90       	pop	r7
   117a4:	6f 90       	pop	r6
   117a6:	5f 90       	pop	r5
   117a8:	4f 90       	pop	r4
   117aa:	3f 90       	pop	r3
   117ac:	2f 90       	pop	r2
   117ae:	1f 90       	pop	r1
   117b0:	0f 90       	pop	r0
   117b2:	0f be       	out	0x3f, r0	; 63
   117b4:	0f 90       	pop	r0

	asm volatile ( "ret" );
   117b6:	08 95       	ret

000117b8 <prvSetupTimerInterrupt>:
/*-----------------------------------------------------------*/
/*
 * Setup timer 0 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
   117b8:	cf 93       	push	r28
   117ba:	df 93       	push	r29
   117bc:	cd b7       	in	r28, 0x3d	; 61
   117be:	de b7       	in	r29, 0x3e	; 62
  OCR0A = 1;
   117c0:	87 e4       	ldi	r24, 0x47	; 71
   117c2:	90 e0       	ldi	r25, 0x00	; 0
   117c4:	21 e0       	ldi	r18, 0x01	; 1
   117c6:	fc 01       	movw	r30, r24
   117c8:	20 83       	st	Z, r18
  TIMSK0  |= (1 << OCIE0A);
   117ca:	8e e6       	ldi	r24, 0x6E	; 110
   117cc:	90 e0       	ldi	r25, 0x00	; 0
   117ce:	2e e6       	ldi	r18, 0x6E	; 110
   117d0:	30 e0       	ldi	r19, 0x00	; 0
   117d2:	f9 01       	movw	r30, r18
   117d4:	20 81       	ld	r18, Z
   117d6:	22 60       	ori	r18, 0x02	; 2
   117d8:	fc 01       	movw	r30, r24
   117da:	20 83       	st	Z, r18
}
   117dc:	df 91       	pop	r29
   117de:	cf 91       	pop	r28
   117e0:	08 95       	ret

000117e2 <__vector_14>:
	 * count is incremented after the context is saved.
	 */
ISR(TIMER0_COMPA_vect, ISR_NAKED)

{
  vPortYieldFromTick();
   117e2:	0e 94 81 8b 	call	0x11702	; 0x11702 <vPortYieldFromTick>
  asm volatile ( "reti" );
   117e6:	18 95       	reti

000117e8 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
   117e8:	cf 93       	push	r28
   117ea:	df 93       	push	r29
   117ec:	00 d0       	rcall	.+0      	; 0x117ee <xQueueGenericReset+0x6>
   117ee:	1f 92       	push	r1
   117f0:	cd b7       	in	r28, 0x3d	; 61
   117f2:	de b7       	in	r29, 0x3e	; 62
   117f4:	9a 83       	std	Y+2, r25	; 0x02
   117f6:	89 83       	std	Y+1, r24	; 0x01
   117f8:	6b 83       	std	Y+3, r22	; 0x03
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
   117fa:	0f b6       	in	r0, 0x3f	; 63
   117fc:	f8 94       	cli
   117fe:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   11800:	89 81       	ldd	r24, Y+1	; 0x01
   11802:	9a 81       	ldd	r25, Y+2	; 0x02
   11804:	fc 01       	movw	r30, r24
   11806:	20 81       	ld	r18, Z
   11808:	31 81       	ldd	r19, Z+1	; 0x01
   1180a:	89 81       	ldd	r24, Y+1	; 0x01
   1180c:	9a 81       	ldd	r25, Y+2	; 0x02
   1180e:	fc 01       	movw	r30, r24
   11810:	83 8d       	ldd	r24, Z+27	; 0x1b
   11812:	68 2f       	mov	r22, r24
   11814:	70 e0       	ldi	r23, 0x00	; 0
   11816:	89 81       	ldd	r24, Y+1	; 0x01
   11818:	9a 81       	ldd	r25, Y+2	; 0x02
   1181a:	fc 01       	movw	r30, r24
   1181c:	84 8d       	ldd	r24, Z+28	; 0x1c
   1181e:	48 2f       	mov	r20, r24
   11820:	50 e0       	ldi	r21, 0x00	; 0
   11822:	64 9f       	mul	r22, r20
   11824:	c0 01       	movw	r24, r0
   11826:	65 9f       	mul	r22, r21
   11828:	90 0d       	add	r25, r0
   1182a:	74 9f       	mul	r23, r20
   1182c:	90 0d       	add	r25, r0
   1182e:	11 24       	eor	r1, r1
   11830:	28 0f       	add	r18, r24
   11832:	39 1f       	adc	r19, r25
   11834:	89 81       	ldd	r24, Y+1	; 0x01
   11836:	9a 81       	ldd	r25, Y+2	; 0x02
   11838:	fc 01       	movw	r30, r24
   1183a:	33 83       	std	Z+3, r19	; 0x03
   1183c:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
   1183e:	89 81       	ldd	r24, Y+1	; 0x01
   11840:	9a 81       	ldd	r25, Y+2	; 0x02
   11842:	fc 01       	movw	r30, r24
   11844:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
   11846:	89 81       	ldd	r24, Y+1	; 0x01
   11848:	9a 81       	ldd	r25, Y+2	; 0x02
   1184a:	fc 01       	movw	r30, r24
   1184c:	20 81       	ld	r18, Z
   1184e:	31 81       	ldd	r19, Z+1	; 0x01
   11850:	89 81       	ldd	r24, Y+1	; 0x01
   11852:	9a 81       	ldd	r25, Y+2	; 0x02
   11854:	fc 01       	movw	r30, r24
   11856:	35 83       	std	Z+5, r19	; 0x05
   11858:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
   1185a:	89 81       	ldd	r24, Y+1	; 0x01
   1185c:	9a 81       	ldd	r25, Y+2	; 0x02
   1185e:	fc 01       	movw	r30, r24
   11860:	20 81       	ld	r18, Z
   11862:	31 81       	ldd	r19, Z+1	; 0x01
   11864:	89 81       	ldd	r24, Y+1	; 0x01
   11866:	9a 81       	ldd	r25, Y+2	; 0x02
   11868:	fc 01       	movw	r30, r24
   1186a:	83 8d       	ldd	r24, Z+27	; 0x1b
   1186c:	88 2f       	mov	r24, r24
   1186e:	90 e0       	ldi	r25, 0x00	; 0
   11870:	bc 01       	movw	r22, r24
   11872:	61 50       	subi	r22, 0x01	; 1
   11874:	71 09       	sbc	r23, r1
   11876:	89 81       	ldd	r24, Y+1	; 0x01
   11878:	9a 81       	ldd	r25, Y+2	; 0x02
   1187a:	fc 01       	movw	r30, r24
   1187c:	84 8d       	ldd	r24, Z+28	; 0x1c
   1187e:	48 2f       	mov	r20, r24
   11880:	50 e0       	ldi	r21, 0x00	; 0
   11882:	64 9f       	mul	r22, r20
   11884:	c0 01       	movw	r24, r0
   11886:	65 9f       	mul	r22, r21
   11888:	90 0d       	add	r25, r0
   1188a:	74 9f       	mul	r23, r20
   1188c:	90 0d       	add	r25, r0
   1188e:	11 24       	eor	r1, r1
   11890:	28 0f       	add	r18, r24
   11892:	39 1f       	adc	r19, r25
   11894:	89 81       	ldd	r24, Y+1	; 0x01
   11896:	9a 81       	ldd	r25, Y+2	; 0x02
   11898:	fc 01       	movw	r30, r24
   1189a:	37 83       	std	Z+7, r19	; 0x07
   1189c:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
   1189e:	89 81       	ldd	r24, Y+1	; 0x01
   118a0:	9a 81       	ldd	r25, Y+2	; 0x02
   118a2:	2f ef       	ldi	r18, 0xFF	; 255
   118a4:	fc 01       	movw	r30, r24
   118a6:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
   118a8:	89 81       	ldd	r24, Y+1	; 0x01
   118aa:	9a 81       	ldd	r25, Y+2	; 0x02
   118ac:	2f ef       	ldi	r18, 0xFF	; 255
   118ae:	fc 01       	movw	r30, r24
   118b0:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
   118b2:	8b 81       	ldd	r24, Y+3	; 0x03
   118b4:	88 23       	and	r24, r24
   118b6:	81 f4       	brne	.+32     	; 0x118d8 <xQueueGenericReset+0xf0>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   118b8:	89 81       	ldd	r24, Y+1	; 0x01
   118ba:	9a 81       	ldd	r25, Y+2	; 0x02
   118bc:	fc 01       	movw	r30, r24
   118be:	80 85       	ldd	r24, Z+8	; 0x08
   118c0:	88 23       	and	r24, r24
   118c2:	a1 f0       	breq	.+40     	; 0x118ec <xQueueGenericReset+0x104>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   118c4:	89 81       	ldd	r24, Y+1	; 0x01
   118c6:	9a 81       	ldd	r25, Y+2	; 0x02
   118c8:	08 96       	adiw	r24, 0x08	; 8
   118ca:	0e 94 f6 98 	call	0x131ec	; 0x131ec <xTaskRemoveFromEventList>
   118ce:	81 30       	cpi	r24, 0x01	; 1
   118d0:	69 f4       	brne	.+26     	; 0x118ec <xQueueGenericReset+0x104>
				{
					portYIELD_WITHIN_API();
   118d2:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
   118d6:	0a c0       	rjmp	.+20     	; 0x118ec <xQueueGenericReset+0x104>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   118d8:	89 81       	ldd	r24, Y+1	; 0x01
   118da:	9a 81       	ldd	r25, Y+2	; 0x02
   118dc:	08 96       	adiw	r24, 0x08	; 8
   118de:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   118e2:	89 81       	ldd	r24, Y+1	; 0x01
   118e4:	9a 81       	ldd	r25, Y+2	; 0x02
   118e6:	41 96       	adiw	r24, 0x11	; 17
   118e8:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
   118ec:	0f 90       	pop	r0
   118ee:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
   118f0:	81 e0       	ldi	r24, 0x01	; 1
}
   118f2:	0f 90       	pop	r0
   118f4:	0f 90       	pop	r0
   118f6:	0f 90       	pop	r0
   118f8:	df 91       	pop	r29
   118fa:	cf 91       	pop	r28
   118fc:	08 95       	ret

000118fe <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
   118fe:	cf 93       	push	r28
   11900:	df 93       	push	r29
   11902:	cd b7       	in	r28, 0x3d	; 61
   11904:	de b7       	in	r29, 0x3e	; 62
   11906:	29 97       	sbiw	r28, 0x09	; 9
   11908:	0f b6       	in	r0, 0x3f	; 63
   1190a:	f8 94       	cli
   1190c:	de bf       	out	0x3e, r29	; 62
   1190e:	0f be       	out	0x3f, r0	; 63
   11910:	cd bf       	out	0x3d, r28	; 61
   11912:	8f 83       	std	Y+7, r24	; 0x07
   11914:	68 87       	std	Y+8, r22	; 0x08
   11916:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
   11918:	1a 82       	std	Y+2, r1	; 0x02
   1191a:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
   1191c:	8f 81       	ldd	r24, Y+7	; 0x07
   1191e:	88 23       	and	r24, r24
   11920:	09 f4       	brne	.+2      	; 0x11924 <xQueueGenericCreate+0x26>
   11922:	43 c0       	rjmp	.+134    	; 0x119aa <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
   11924:	8f e1       	ldi	r24, 0x1F	; 31
   11926:	90 e0       	ldi	r25, 0x00	; 0
   11928:	0e 94 a2 87 	call	0x10f44	; 0x10f44 <pvPortMalloc>
   1192c:	9c 83       	std	Y+4, r25	; 0x04
   1192e:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
   11930:	8b 81       	ldd	r24, Y+3	; 0x03
   11932:	9c 81       	ldd	r25, Y+4	; 0x04
   11934:	00 97       	sbiw	r24, 0x00	; 0
   11936:	c9 f1       	breq	.+114    	; 0x119aa <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
   11938:	8f 81       	ldd	r24, Y+7	; 0x07
   1193a:	48 2f       	mov	r20, r24
   1193c:	50 e0       	ldi	r21, 0x00	; 0
   1193e:	88 85       	ldd	r24, Y+8	; 0x08
   11940:	28 2f       	mov	r18, r24
   11942:	30 e0       	ldi	r19, 0x00	; 0
   11944:	42 9f       	mul	r20, r18
   11946:	c0 01       	movw	r24, r0
   11948:	43 9f       	mul	r20, r19
   1194a:	90 0d       	add	r25, r0
   1194c:	52 9f       	mul	r21, r18
   1194e:	90 0d       	add	r25, r0
   11950:	11 24       	eor	r1, r1
   11952:	01 96       	adiw	r24, 0x01	; 1
   11954:	9e 83       	std	Y+6, r25	; 0x06
   11956:	8d 83       	std	Y+5, r24	; 0x05

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
   11958:	8d 81       	ldd	r24, Y+5	; 0x05
   1195a:	9e 81       	ldd	r25, Y+6	; 0x06
   1195c:	0e 94 a2 87 	call	0x10f44	; 0x10f44 <pvPortMalloc>
   11960:	9c 01       	movw	r18, r24
   11962:	8b 81       	ldd	r24, Y+3	; 0x03
   11964:	9c 81       	ldd	r25, Y+4	; 0x04
   11966:	fc 01       	movw	r30, r24
   11968:	31 83       	std	Z+1, r19	; 0x01
   1196a:	20 83       	st	Z, r18
			if( pxNewQueue->pcHead != NULL )
   1196c:	8b 81       	ldd	r24, Y+3	; 0x03
   1196e:	9c 81       	ldd	r25, Y+4	; 0x04
   11970:	fc 01       	movw	r30, r24
   11972:	80 81       	ld	r24, Z
   11974:	91 81       	ldd	r25, Z+1	; 0x01
   11976:	00 97       	sbiw	r24, 0x00	; 0
   11978:	a1 f0       	breq	.+40     	; 0x119a2 <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
   1197a:	8b 81       	ldd	r24, Y+3	; 0x03
   1197c:	9c 81       	ldd	r25, Y+4	; 0x04
   1197e:	2f 81       	ldd	r18, Y+7	; 0x07
   11980:	fc 01       	movw	r30, r24
   11982:	23 8f       	std	Z+27, r18	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
   11984:	8b 81       	ldd	r24, Y+3	; 0x03
   11986:	9c 81       	ldd	r25, Y+4	; 0x04
   11988:	28 85       	ldd	r18, Y+8	; 0x08
   1198a:	fc 01       	movw	r30, r24
   1198c:	24 8f       	std	Z+28, r18	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
   1198e:	8b 81       	ldd	r24, Y+3	; 0x03
   11990:	9c 81       	ldd	r25, Y+4	; 0x04
   11992:	61 e0       	ldi	r22, 0x01	; 1
   11994:	0e 94 f4 8b 	call	0x117e8	; 0x117e8 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
   11998:	8b 81       	ldd	r24, Y+3	; 0x03
   1199a:	9c 81       	ldd	r25, Y+4	; 0x04
   1199c:	9a 83       	std	Y+2, r25	; 0x02
   1199e:	89 83       	std	Y+1, r24	; 0x01
   119a0:	04 c0       	rjmp	.+8      	; 0x119aa <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
   119a2:	8b 81       	ldd	r24, Y+3	; 0x03
   119a4:	9c 81       	ldd	r25, Y+4	; 0x04
   119a6:	0e 94 bd 87 	call	0x10f7a	; 0x10f7a <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
   119aa:	89 81       	ldd	r24, Y+1	; 0x01
   119ac:	9a 81       	ldd	r25, Y+2	; 0x02
}
   119ae:	29 96       	adiw	r28, 0x09	; 9
   119b0:	0f b6       	in	r0, 0x3f	; 63
   119b2:	f8 94       	cli
   119b4:	de bf       	out	0x3e, r29	; 62
   119b6:	0f be       	out	0x3f, r0	; 63
   119b8:	cd bf       	out	0x3d, r28	; 61
   119ba:	df 91       	pop	r29
   119bc:	cf 91       	pop	r28
   119be:	08 95       	ret

000119c0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
   119c0:	cf 93       	push	r28
   119c2:	df 93       	push	r29
   119c4:	00 d0       	rcall	.+0      	; 0x119c6 <xQueueCreateMutex+0x6>
   119c6:	1f 92       	push	r1
   119c8:	cd b7       	in	r28, 0x3d	; 61
   119ca:	de b7       	in	r29, 0x3e	; 62
   119cc:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
   119ce:	8f e1       	ldi	r24, 0x1F	; 31
   119d0:	90 e0       	ldi	r25, 0x00	; 0
   119d2:	0e 94 a2 87 	call	0x10f44	; 0x10f44 <pvPortMalloc>
   119d6:	9a 83       	std	Y+2, r25	; 0x02
   119d8:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
   119da:	89 81       	ldd	r24, Y+1	; 0x01
   119dc:	9a 81       	ldd	r25, Y+2	; 0x02
   119de:	00 97       	sbiw	r24, 0x00	; 0
   119e0:	f1 f1       	breq	.+124    	; 0x11a5e <xQueueCreateMutex+0x9e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
   119e2:	89 81       	ldd	r24, Y+1	; 0x01
   119e4:	9a 81       	ldd	r25, Y+2	; 0x02
   119e6:	fc 01       	movw	r30, r24
   119e8:	13 82       	std	Z+3, r1	; 0x03
   119ea:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   119ec:	89 81       	ldd	r24, Y+1	; 0x01
   119ee:	9a 81       	ldd	r25, Y+2	; 0x02
   119f0:	fc 01       	movw	r30, r24
   119f2:	11 82       	std	Z+1, r1	; 0x01
   119f4:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
   119f6:	89 81       	ldd	r24, Y+1	; 0x01
   119f8:	9a 81       	ldd	r25, Y+2	; 0x02
   119fa:	fc 01       	movw	r30, r24
   119fc:	15 82       	std	Z+5, r1	; 0x05
   119fe:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
   11a00:	89 81       	ldd	r24, Y+1	; 0x01
   11a02:	9a 81       	ldd	r25, Y+2	; 0x02
   11a04:	fc 01       	movw	r30, r24
   11a06:	17 82       	std	Z+7, r1	; 0x07
   11a08:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
   11a0a:	89 81       	ldd	r24, Y+1	; 0x01
   11a0c:	9a 81       	ldd	r25, Y+2	; 0x02
   11a0e:	fc 01       	movw	r30, r24
   11a10:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
   11a12:	89 81       	ldd	r24, Y+1	; 0x01
   11a14:	9a 81       	ldd	r25, Y+2	; 0x02
   11a16:	21 e0       	ldi	r18, 0x01	; 1
   11a18:	fc 01       	movw	r30, r24
   11a1a:	23 8f       	std	Z+27, r18	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
   11a1c:	89 81       	ldd	r24, Y+1	; 0x01
   11a1e:	9a 81       	ldd	r25, Y+2	; 0x02
   11a20:	fc 01       	movw	r30, r24
   11a22:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
   11a24:	89 81       	ldd	r24, Y+1	; 0x01
   11a26:	9a 81       	ldd	r25, Y+2	; 0x02
   11a28:	2f ef       	ldi	r18, 0xFF	; 255
   11a2a:	fc 01       	movw	r30, r24
   11a2c:	25 8f       	std	Z+29, r18	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
   11a2e:	89 81       	ldd	r24, Y+1	; 0x01
   11a30:	9a 81       	ldd	r25, Y+2	; 0x02
   11a32:	2f ef       	ldi	r18, 0xFF	; 255
   11a34:	fc 01       	movw	r30, r24
   11a36:	26 8f       	std	Z+30, r18	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
   11a38:	89 81       	ldd	r24, Y+1	; 0x01
   11a3a:	9a 81       	ldd	r25, Y+2	; 0x02
   11a3c:	08 96       	adiw	r24, 0x08	; 8
   11a3e:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
   11a42:	89 81       	ldd	r24, Y+1	; 0x01
   11a44:	9a 81       	ldd	r25, Y+2	; 0x02
   11a46:	41 96       	adiw	r24, 0x11	; 17
   11a48:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
   11a4c:	89 81       	ldd	r24, Y+1	; 0x01
   11a4e:	9a 81       	ldd	r25, Y+2	; 0x02
   11a50:	20 e0       	ldi	r18, 0x00	; 0
   11a52:	40 e0       	ldi	r20, 0x00	; 0
   11a54:	50 e0       	ldi	r21, 0x00	; 0
   11a56:	60 e0       	ldi	r22, 0x00	; 0
   11a58:	70 e0       	ldi	r23, 0x00	; 0
   11a5a:	0e 94 58 8d 	call	0x11ab0	; 0x11ab0 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
   11a5e:	89 81       	ldd	r24, Y+1	; 0x01
   11a60:	9a 81       	ldd	r25, Y+2	; 0x02
	}
   11a62:	0f 90       	pop	r0
   11a64:	0f 90       	pop	r0
   11a66:	0f 90       	pop	r0
   11a68:	df 91       	pop	r29
   11a6a:	cf 91       	pop	r28
   11a6c:	08 95       	ret

00011a6e <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
   11a6e:	cf 93       	push	r28
   11a70:	df 93       	push	r29
   11a72:	00 d0       	rcall	.+0      	; 0x11a74 <xQueueCreateCountingSemaphore+0x6>
   11a74:	00 d0       	rcall	.+0      	; 0x11a76 <xQueueCreateCountingSemaphore+0x8>
   11a76:	cd b7       	in	r28, 0x3d	; 61
   11a78:	de b7       	in	r29, 0x3e	; 62
   11a7a:	8b 83       	std	Y+3, r24	; 0x03
   11a7c:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   11a7e:	42 e0       	ldi	r20, 0x02	; 2
   11a80:	60 e0       	ldi	r22, 0x00	; 0
   11a82:	8b 81       	ldd	r24, Y+3	; 0x03
   11a84:	0e 94 7f 8c 	call	0x118fe	; 0x118fe <xQueueGenericCreate>
   11a88:	9a 83       	std	Y+2, r25	; 0x02
   11a8a:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
   11a8c:	89 81       	ldd	r24, Y+1	; 0x01
   11a8e:	9a 81       	ldd	r25, Y+2	; 0x02
   11a90:	00 97       	sbiw	r24, 0x00	; 0
   11a92:	29 f0       	breq	.+10     	; 0x11a9e <xQueueCreateCountingSemaphore+0x30>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
   11a94:	89 81       	ldd	r24, Y+1	; 0x01
   11a96:	9a 81       	ldd	r25, Y+2	; 0x02
   11a98:	2c 81       	ldd	r18, Y+4	; 0x04
   11a9a:	fc 01       	movw	r30, r24
   11a9c:	22 8f       	std	Z+26, r18	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
   11a9e:	89 81       	ldd	r24, Y+1	; 0x01
   11aa0:	9a 81       	ldd	r25, Y+2	; 0x02
	}
   11aa2:	0f 90       	pop	r0
   11aa4:	0f 90       	pop	r0
   11aa6:	0f 90       	pop	r0
   11aa8:	0f 90       	pop	r0
   11aaa:	df 91       	pop	r29
   11aac:	cf 91       	pop	r28
   11aae:	08 95       	ret

00011ab0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
   11ab0:	cf 93       	push	r28
   11ab2:	df 93       	push	r29
   11ab4:	cd b7       	in	r28, 0x3d	; 61
   11ab6:	de b7       	in	r29, 0x3e	; 62
   11ab8:	2b 97       	sbiw	r28, 0x0b	; 11
   11aba:	0f b6       	in	r0, 0x3f	; 63
   11abc:	f8 94       	cli
   11abe:	de bf       	out	0x3e, r29	; 62
   11ac0:	0f be       	out	0x3f, r0	; 63
   11ac2:	cd bf       	out	0x3d, r28	; 61
   11ac4:	9e 83       	std	Y+6, r25	; 0x06
   11ac6:	8d 83       	std	Y+5, r24	; 0x05
   11ac8:	78 87       	std	Y+8, r23	; 0x08
   11aca:	6f 83       	std	Y+7, r22	; 0x07
   11acc:	5a 87       	std	Y+10, r21	; 0x0a
   11ace:	49 87       	std	Y+9, r20	; 0x09
   11ad0:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
   11ad2:	19 82       	std	Y+1, r1	; 0x01
   11ad4:	01 c0       	rjmp	.+2      	; 0x11ad8 <xQueueGenericSend+0x28>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
   11ad6:	00 00       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   11ad8:	0f b6       	in	r0, 0x3f	; 63
   11ada:	f8 94       	cli
   11adc:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   11ade:	8d 81       	ldd	r24, Y+5	; 0x05
   11ae0:	9e 81       	ldd	r25, Y+6	; 0x06
   11ae2:	fc 01       	movw	r30, r24
   11ae4:	22 8d       	ldd	r18, Z+26	; 0x1a
   11ae6:	8d 81       	ldd	r24, Y+5	; 0x05
   11ae8:	9e 81       	ldd	r25, Y+6	; 0x06
   11aea:	fc 01       	movw	r30, r24
   11aec:	83 8d       	ldd	r24, Z+27	; 0x1b
   11aee:	28 17       	cp	r18, r24
   11af0:	d8 f4       	brcc	.+54     	; 0x11b28 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   11af2:	2f 81       	ldd	r18, Y+7	; 0x07
   11af4:	38 85       	ldd	r19, Y+8	; 0x08
   11af6:	8d 81       	ldd	r24, Y+5	; 0x05
   11af8:	9e 81       	ldd	r25, Y+6	; 0x06
   11afa:	4b 85       	ldd	r20, Y+11	; 0x0b
   11afc:	b9 01       	movw	r22, r18
   11afe:	0e 94 e5 8f 	call	0x11fca	; 0x11fca <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   11b02:	8d 81       	ldd	r24, Y+5	; 0x05
   11b04:	9e 81       	ldd	r25, Y+6	; 0x06
   11b06:	fc 01       	movw	r30, r24
   11b08:	81 89       	ldd	r24, Z+17	; 0x11
   11b0a:	88 23       	and	r24, r24
   11b0c:	49 f0       	breq	.+18     	; 0x11b20 <xQueueGenericSend+0x70>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
   11b0e:	8d 81       	ldd	r24, Y+5	; 0x05
   11b10:	9e 81       	ldd	r25, Y+6	; 0x06
   11b12:	41 96       	adiw	r24, 0x11	; 17
   11b14:	0e 94 f6 98 	call	0x131ec	; 0x131ec <xTaskRemoveFromEventList>
   11b18:	81 30       	cpi	r24, 0x01	; 1
   11b1a:	11 f4       	brne	.+4      	; 0x11b20 <xQueueGenericSend+0x70>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
   11b1c:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
   11b20:	0f 90       	pop	r0
   11b22:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
   11b24:	81 e0       	ldi	r24, 0x01	; 1
   11b26:	60 c0       	rjmp	.+192    	; 0x11be8 <xQueueGenericSend+0x138>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
   11b28:	89 85       	ldd	r24, Y+9	; 0x09
   11b2a:	9a 85       	ldd	r25, Y+10	; 0x0a
   11b2c:	00 97       	sbiw	r24, 0x00	; 0
   11b2e:	21 f4       	brne	.+8      	; 0x11b38 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   11b30:	0f 90       	pop	r0
   11b32:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
   11b34:	80 e0       	ldi	r24, 0x00	; 0
   11b36:	58 c0       	rjmp	.+176    	; 0x11be8 <xQueueGenericSend+0x138>
				}
				else if( xEntryTimeSet == pdFALSE )
   11b38:	89 81       	ldd	r24, Y+1	; 0x01
   11b3a:	88 23       	and	r24, r24
   11b3c:	31 f4       	brne	.+12     	; 0x11b4a <xQueueGenericSend+0x9a>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   11b3e:	ce 01       	movw	r24, r28
   11b40:	02 96       	adiw	r24, 0x02	; 2
   11b42:	0e 94 60 99 	call	0x132c0	; 0x132c0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   11b46:	81 e0       	ldi	r24, 0x01	; 1
   11b48:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
   11b4a:	0f 90       	pop	r0
   11b4c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   11b4e:	0e 94 a1 96 	call	0x12d42	; 0x12d42 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   11b52:	0f b6       	in	r0, 0x3f	; 63
   11b54:	f8 94       	cli
   11b56:	0f 92       	push	r0
   11b58:	8d 81       	ldd	r24, Y+5	; 0x05
   11b5a:	9e 81       	ldd	r25, Y+6	; 0x06
   11b5c:	fc 01       	movw	r30, r24
   11b5e:	85 8d       	ldd	r24, Z+29	; 0x1d
   11b60:	8f 3f       	cpi	r24, 0xFF	; 255
   11b62:	21 f4       	brne	.+8      	; 0x11b6c <xQueueGenericSend+0xbc>
   11b64:	8d 81       	ldd	r24, Y+5	; 0x05
   11b66:	9e 81       	ldd	r25, Y+6	; 0x06
   11b68:	fc 01       	movw	r30, r24
   11b6a:	15 8e       	std	Z+29, r1	; 0x1d
   11b6c:	8d 81       	ldd	r24, Y+5	; 0x05
   11b6e:	9e 81       	ldd	r25, Y+6	; 0x06
   11b70:	fc 01       	movw	r30, r24
   11b72:	86 8d       	ldd	r24, Z+30	; 0x1e
   11b74:	8f 3f       	cpi	r24, 0xFF	; 255
   11b76:	21 f4       	brne	.+8      	; 0x11b80 <xQueueGenericSend+0xd0>
   11b78:	8d 81       	ldd	r24, Y+5	; 0x05
   11b7a:	9e 81       	ldd	r25, Y+6	; 0x06
   11b7c:	fc 01       	movw	r30, r24
   11b7e:	16 8e       	std	Z+30, r1	; 0x1e
   11b80:	0f 90       	pop	r0
   11b82:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   11b84:	9e 01       	movw	r18, r28
   11b86:	27 5f       	subi	r18, 0xF7	; 247
   11b88:	3f 4f       	sbci	r19, 0xFF	; 255
   11b8a:	ce 01       	movw	r24, r28
   11b8c:	02 96       	adiw	r24, 0x02	; 2
   11b8e:	b9 01       	movw	r22, r18
   11b90:	0e 94 7b 99 	call	0x132f6	; 0x132f6 <xTaskCheckForTimeOut>
   11b94:	88 23       	and	r24, r24
   11b96:	09 f5       	brne	.+66     	; 0x11bda <xQueueGenericSend+0x12a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   11b98:	8d 81       	ldd	r24, Y+5	; 0x05
   11b9a:	9e 81       	ldd	r25, Y+6	; 0x06
   11b9c:	0e 94 8d 91 	call	0x1231a	; 0x1231a <prvIsQueueFull>
   11ba0:	88 23       	and	r24, r24
   11ba2:	a1 f0       	breq	.+40     	; 0x11bcc <xQueueGenericSend+0x11c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   11ba4:	29 85       	ldd	r18, Y+9	; 0x09
   11ba6:	3a 85       	ldd	r19, Y+10	; 0x0a
   11ba8:	8d 81       	ldd	r24, Y+5	; 0x05
   11baa:	9e 81       	ldd	r25, Y+6	; 0x06
   11bac:	08 96       	adiw	r24, 0x08	; 8
   11bae:	b9 01       	movw	r22, r18
   11bb0:	0e 94 c1 98 	call	0x13182	; 0x13182 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
   11bb4:	8d 81       	ldd	r24, Y+5	; 0x05
   11bb6:	9e 81       	ldd	r25, Y+6	; 0x06
   11bb8:	0e 94 f4 90 	call	0x121e8	; 0x121e8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
   11bbc:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>
   11bc0:	88 23       	and	r24, r24
   11bc2:	09 f0       	breq	.+2      	; 0x11bc6 <xQueueGenericSend+0x116>
   11bc4:	88 cf       	rjmp	.-240    	; 0x11ad6 <xQueueGenericSend+0x26>
				{
					portYIELD_WITHIN_API();
   11bc6:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
   11bca:	85 cf       	rjmp	.-246    	; 0x11ad6 <xQueueGenericSend+0x26>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   11bcc:	8d 81       	ldd	r24, Y+5	; 0x05
   11bce:	9e 81       	ldd	r25, Y+6	; 0x06
   11bd0:	0e 94 f4 90 	call	0x121e8	; 0x121e8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   11bd4:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
   11bd8:	7e cf       	rjmp	.-260    	; 0x11ad6 <xQueueGenericSend+0x26>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
   11bda:	8d 81       	ldd	r24, Y+5	; 0x05
   11bdc:	9e 81       	ldd	r25, Y+6	; 0x06
   11bde:	0e 94 f4 90 	call	0x121e8	; 0x121e8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   11be2:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
   11be6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
   11be8:	2b 96       	adiw	r28, 0x0b	; 11
   11bea:	0f b6       	in	r0, 0x3f	; 63
   11bec:	f8 94       	cli
   11bee:	de bf       	out	0x3e, r29	; 62
   11bf0:	0f be       	out	0x3f, r0	; 63
   11bf2:	cd bf       	out	0x3d, r28	; 61
   11bf4:	df 91       	pop	r29
   11bf6:	cf 91       	pop	r28
   11bf8:	08 95       	ret

00011bfa <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
   11bfa:	cf 93       	push	r28
   11bfc:	df 93       	push	r29
   11bfe:	cd b7       	in	r28, 0x3d	; 61
   11c00:	de b7       	in	r29, 0x3e	; 62
   11c02:	29 97       	sbiw	r28, 0x09	; 9
   11c04:	0f b6       	in	r0, 0x3f	; 63
   11c06:	f8 94       	cli
   11c08:	de bf       	out	0x3e, r29	; 62
   11c0a:	0f be       	out	0x3f, r0	; 63
   11c0c:	cd bf       	out	0x3d, r28	; 61
   11c0e:	9c 83       	std	Y+4, r25	; 0x04
   11c10:	8b 83       	std	Y+3, r24	; 0x03
   11c12:	7e 83       	std	Y+6, r23	; 0x06
   11c14:	6d 83       	std	Y+5, r22	; 0x05
   11c16:	58 87       	std	Y+8, r21	; 0x08
   11c18:	4f 83       	std	Y+7, r20	; 0x07
   11c1a:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   11c1c:	1a 82       	std	Y+2, r1	; 0x02
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   11c1e:	8b 81       	ldd	r24, Y+3	; 0x03
   11c20:	9c 81       	ldd	r25, Y+4	; 0x04
   11c22:	fc 01       	movw	r30, r24
   11c24:	22 8d       	ldd	r18, Z+26	; 0x1a
   11c26:	8b 81       	ldd	r24, Y+3	; 0x03
   11c28:	9c 81       	ldd	r25, Y+4	; 0x04
   11c2a:	fc 01       	movw	r30, r24
   11c2c:	83 8d       	ldd	r24, Z+27	; 0x1b
   11c2e:	28 17       	cp	r18, r24
   11c30:	90 f5       	brcc	.+100    	; 0x11c96 <xQueueGenericSendFromISR+0x9c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   11c32:	2d 81       	ldd	r18, Y+5	; 0x05
   11c34:	3e 81       	ldd	r19, Y+6	; 0x06
   11c36:	8b 81       	ldd	r24, Y+3	; 0x03
   11c38:	9c 81       	ldd	r25, Y+4	; 0x04
   11c3a:	49 85       	ldd	r20, Y+9	; 0x09
   11c3c:	b9 01       	movw	r22, r18
   11c3e:	0e 94 e5 8f 	call	0x11fca	; 0x11fca <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
   11c42:	8b 81       	ldd	r24, Y+3	; 0x03
   11c44:	9c 81       	ldd	r25, Y+4	; 0x04
   11c46:	fc 01       	movw	r30, r24
   11c48:	86 8d       	ldd	r24, Z+30	; 0x1e
   11c4a:	8f 3f       	cpi	r24, 0xFF	; 255
   11c4c:	b9 f4       	brne	.+46     	; 0x11c7c <xQueueGenericSendFromISR+0x82>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   11c4e:	8b 81       	ldd	r24, Y+3	; 0x03
   11c50:	9c 81       	ldd	r25, Y+4	; 0x04
   11c52:	fc 01       	movw	r30, r24
   11c54:	81 89       	ldd	r24, Z+17	; 0x11
   11c56:	88 23       	and	r24, r24
   11c58:	d9 f0       	breq	.+54     	; 0x11c90 <xQueueGenericSendFromISR+0x96>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   11c5a:	8b 81       	ldd	r24, Y+3	; 0x03
   11c5c:	9c 81       	ldd	r25, Y+4	; 0x04
   11c5e:	41 96       	adiw	r24, 0x11	; 17
   11c60:	0e 94 f6 98 	call	0x131ec	; 0x131ec <xTaskRemoveFromEventList>
   11c64:	88 23       	and	r24, r24
   11c66:	a1 f0       	breq	.+40     	; 0x11c90 <xQueueGenericSendFromISR+0x96>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
   11c68:	8f 81       	ldd	r24, Y+7	; 0x07
   11c6a:	98 85       	ldd	r25, Y+8	; 0x08
   11c6c:	00 97       	sbiw	r24, 0x00	; 0
   11c6e:	81 f0       	breq	.+32     	; 0x11c90 <xQueueGenericSendFromISR+0x96>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
   11c70:	8f 81       	ldd	r24, Y+7	; 0x07
   11c72:	98 85       	ldd	r25, Y+8	; 0x08
   11c74:	21 e0       	ldi	r18, 0x01	; 1
   11c76:	fc 01       	movw	r30, r24
   11c78:	20 83       	st	Z, r18
   11c7a:	0a c0       	rjmp	.+20     	; 0x11c90 <xQueueGenericSendFromISR+0x96>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
   11c7c:	8b 81       	ldd	r24, Y+3	; 0x03
   11c7e:	9c 81       	ldd	r25, Y+4	; 0x04
   11c80:	fc 01       	movw	r30, r24
   11c82:	86 8d       	ldd	r24, Z+30	; 0x1e
   11c84:	28 2f       	mov	r18, r24
   11c86:	2f 5f       	subi	r18, 0xFF	; 255
   11c88:	8b 81       	ldd	r24, Y+3	; 0x03
   11c8a:	9c 81       	ldd	r25, Y+4	; 0x04
   11c8c:	fc 01       	movw	r30, r24
   11c8e:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
   11c90:	81 e0       	ldi	r24, 0x01	; 1
   11c92:	89 83       	std	Y+1, r24	; 0x01
   11c94:	01 c0       	rjmp	.+2      	; 0x11c98 <xQueueGenericSendFromISR+0x9e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   11c96:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   11c98:	89 81       	ldd	r24, Y+1	; 0x01
}
   11c9a:	29 96       	adiw	r28, 0x09	; 9
   11c9c:	0f b6       	in	r0, 0x3f	; 63
   11c9e:	f8 94       	cli
   11ca0:	de bf       	out	0x3e, r29	; 62
   11ca2:	0f be       	out	0x3f, r0	; 63
   11ca4:	cd bf       	out	0x3d, r28	; 61
   11ca6:	df 91       	pop	r29
   11ca8:	cf 91       	pop	r28
   11caa:	08 95       	ret

00011cac <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
   11cac:	cf 93       	push	r28
   11cae:	df 93       	push	r29
   11cb0:	cd b7       	in	r28, 0x3d	; 61
   11cb2:	de b7       	in	r29, 0x3e	; 62
   11cb4:	2d 97       	sbiw	r28, 0x0d	; 13
   11cb6:	0f b6       	in	r0, 0x3f	; 63
   11cb8:	f8 94       	cli
   11cba:	de bf       	out	0x3e, r29	; 62
   11cbc:	0f be       	out	0x3f, r0	; 63
   11cbe:	cd bf       	out	0x3d, r28	; 61
   11cc0:	98 87       	std	Y+8, r25	; 0x08
   11cc2:	8f 83       	std	Y+7, r24	; 0x07
   11cc4:	7a 87       	std	Y+10, r23	; 0x0a
   11cc6:	69 87       	std	Y+9, r22	; 0x09
   11cc8:	5c 87       	std	Y+12, r21	; 0x0c
   11cca:	4b 87       	std	Y+11, r20	; 0x0b
   11ccc:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
   11cce:	19 82       	std	Y+1, r1	; 0x01
   11cd0:	01 c0       	rjmp	.+2      	; 0x11cd4 <xQueueGenericReceive+0x28>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
   11cd2:	00 00       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   11cd4:	0f b6       	in	r0, 0x3f	; 63
   11cd6:	f8 94       	cli
   11cd8:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   11cda:	8f 81       	ldd	r24, Y+7	; 0x07
   11cdc:	98 85       	ldd	r25, Y+8	; 0x08
   11cde:	fc 01       	movw	r30, r24
   11ce0:	82 8d       	ldd	r24, Z+26	; 0x1a
   11ce2:	88 23       	and	r24, r24
   11ce4:	09 f4       	brne	.+2      	; 0x11ce8 <xQueueGenericReceive+0x3c>
   11ce6:	54 c0       	rjmp	.+168    	; 0x11d90 <xQueueGenericReceive+0xe4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
   11ce8:	8f 81       	ldd	r24, Y+7	; 0x07
   11cea:	98 85       	ldd	r25, Y+8	; 0x08
   11cec:	fc 01       	movw	r30, r24
   11cee:	86 81       	ldd	r24, Z+6	; 0x06
   11cf0:	97 81       	ldd	r25, Z+7	; 0x07
   11cf2:	9b 83       	std	Y+3, r25	; 0x03
   11cf4:	8a 83       	std	Y+2, r24	; 0x02

				prvCopyDataFromQueue( pxQueue, pvBuffer );
   11cf6:	29 85       	ldd	r18, Y+9	; 0x09
   11cf8:	3a 85       	ldd	r19, Y+10	; 0x0a
   11cfa:	8f 81       	ldd	r24, Y+7	; 0x07
   11cfc:	98 85       	ldd	r25, Y+8	; 0x08
   11cfe:	b9 01       	movw	r22, r18
   11d00:	0e 94 a3 90 	call	0x12146	; 0x12146 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
   11d04:	8d 85       	ldd	r24, Y+13	; 0x0d
   11d06:	88 23       	and	r24, r24
   11d08:	49 f5       	brne	.+82     	; 0x11d5c <xQueueGenericReceive+0xb0>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
   11d0a:	8f 81       	ldd	r24, Y+7	; 0x07
   11d0c:	98 85       	ldd	r25, Y+8	; 0x08
   11d0e:	fc 01       	movw	r30, r24
   11d10:	82 8d       	ldd	r24, Z+26	; 0x1a
   11d12:	28 2f       	mov	r18, r24
   11d14:	21 50       	subi	r18, 0x01	; 1
   11d16:	8f 81       	ldd	r24, Y+7	; 0x07
   11d18:	98 85       	ldd	r25, Y+8	; 0x08
   11d1a:	fc 01       	movw	r30, r24
   11d1c:	22 8f       	std	Z+26, r18	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   11d1e:	8f 81       	ldd	r24, Y+7	; 0x07
   11d20:	98 85       	ldd	r25, Y+8	; 0x08
   11d22:	fc 01       	movw	r30, r24
   11d24:	80 81       	ld	r24, Z
   11d26:	91 81       	ldd	r25, Z+1	; 0x01
   11d28:	00 97       	sbiw	r24, 0x00	; 0
   11d2a:	41 f4       	brne	.+16     	; 0x11d3c <xQueueGenericReceive+0x90>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
   11d2c:	0e 94 d4 9b 	call	0x137a8	; 0x137a8 <xTaskGetCurrentTaskHandle>
   11d30:	9c 01       	movw	r18, r24
   11d32:	8f 81       	ldd	r24, Y+7	; 0x07
   11d34:	98 85       	ldd	r25, Y+8	; 0x08
   11d36:	fc 01       	movw	r30, r24
   11d38:	33 83       	std	Z+3, r19	; 0x03
   11d3a:	22 83       	std	Z+2, r18	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   11d3c:	8f 81       	ldd	r24, Y+7	; 0x07
   11d3e:	98 85       	ldd	r25, Y+8	; 0x08
   11d40:	fc 01       	movw	r30, r24
   11d42:	80 85       	ldd	r24, Z+8	; 0x08
   11d44:	88 23       	and	r24, r24
   11d46:	01 f1       	breq	.+64     	; 0x11d88 <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   11d48:	8f 81       	ldd	r24, Y+7	; 0x07
   11d4a:	98 85       	ldd	r25, Y+8	; 0x08
   11d4c:	08 96       	adiw	r24, 0x08	; 8
   11d4e:	0e 94 f6 98 	call	0x131ec	; 0x131ec <xTaskRemoveFromEventList>
   11d52:	81 30       	cpi	r24, 0x01	; 1
   11d54:	c9 f4       	brne	.+50     	; 0x11d88 <xQueueGenericReceive+0xdc>
						{
							portYIELD_WITHIN_API();
   11d56:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
   11d5a:	16 c0       	rjmp	.+44     	; 0x11d88 <xQueueGenericReceive+0xdc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
   11d5c:	8f 81       	ldd	r24, Y+7	; 0x07
   11d5e:	98 85       	ldd	r25, Y+8	; 0x08
   11d60:	2a 81       	ldd	r18, Y+2	; 0x02
   11d62:	3b 81       	ldd	r19, Y+3	; 0x03
   11d64:	fc 01       	movw	r30, r24
   11d66:	37 83       	std	Z+7, r19	; 0x07
   11d68:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   11d6a:	8f 81       	ldd	r24, Y+7	; 0x07
   11d6c:	98 85       	ldd	r25, Y+8	; 0x08
   11d6e:	fc 01       	movw	r30, r24
   11d70:	81 89       	ldd	r24, Z+17	; 0x11
   11d72:	88 23       	and	r24, r24
   11d74:	49 f0       	breq	.+18     	; 0x11d88 <xQueueGenericReceive+0xdc>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   11d76:	8f 81       	ldd	r24, Y+7	; 0x07
   11d78:	98 85       	ldd	r25, Y+8	; 0x08
   11d7a:	41 96       	adiw	r24, 0x11	; 17
   11d7c:	0e 94 f6 98 	call	0x131ec	; 0x131ec <xTaskRemoveFromEventList>
   11d80:	88 23       	and	r24, r24
   11d82:	11 f0       	breq	.+4      	; 0x11d88 <xQueueGenericReceive+0xdc>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
   11d84:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
   11d88:	0f 90       	pop	r0
   11d8a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
   11d8c:	81 e0       	ldi	r24, 0x01	; 1
   11d8e:	73 c0       	rjmp	.+230    	; 0x11e76 <xQueueGenericReceive+0x1ca>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
   11d90:	8b 85       	ldd	r24, Y+11	; 0x0b
   11d92:	9c 85       	ldd	r25, Y+12	; 0x0c
   11d94:	00 97       	sbiw	r24, 0x00	; 0
   11d96:	21 f4       	brne	.+8      	; 0x11da0 <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   11d98:	0f 90       	pop	r0
   11d9a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   11d9c:	80 e0       	ldi	r24, 0x00	; 0
   11d9e:	6b c0       	rjmp	.+214    	; 0x11e76 <xQueueGenericReceive+0x1ca>
				}
				else if( xEntryTimeSet == pdFALSE )
   11da0:	89 81       	ldd	r24, Y+1	; 0x01
   11da2:	88 23       	and	r24, r24
   11da4:	31 f4       	brne	.+12     	; 0x11db2 <xQueueGenericReceive+0x106>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   11da6:	ce 01       	movw	r24, r28
   11da8:	04 96       	adiw	r24, 0x04	; 4
   11daa:	0e 94 60 99 	call	0x132c0	; 0x132c0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   11dae:	81 e0       	ldi	r24, 0x01	; 1
   11db0:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
   11db2:	0f 90       	pop	r0
   11db4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   11db6:	0e 94 a1 96 	call	0x12d42	; 0x12d42 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   11dba:	0f b6       	in	r0, 0x3f	; 63
   11dbc:	f8 94       	cli
   11dbe:	0f 92       	push	r0
   11dc0:	8f 81       	ldd	r24, Y+7	; 0x07
   11dc2:	98 85       	ldd	r25, Y+8	; 0x08
   11dc4:	fc 01       	movw	r30, r24
   11dc6:	85 8d       	ldd	r24, Z+29	; 0x1d
   11dc8:	8f 3f       	cpi	r24, 0xFF	; 255
   11dca:	21 f4       	brne	.+8      	; 0x11dd4 <xQueueGenericReceive+0x128>
   11dcc:	8f 81       	ldd	r24, Y+7	; 0x07
   11dce:	98 85       	ldd	r25, Y+8	; 0x08
   11dd0:	fc 01       	movw	r30, r24
   11dd2:	15 8e       	std	Z+29, r1	; 0x1d
   11dd4:	8f 81       	ldd	r24, Y+7	; 0x07
   11dd6:	98 85       	ldd	r25, Y+8	; 0x08
   11dd8:	fc 01       	movw	r30, r24
   11dda:	86 8d       	ldd	r24, Z+30	; 0x1e
   11ddc:	8f 3f       	cpi	r24, 0xFF	; 255
   11dde:	21 f4       	brne	.+8      	; 0x11de8 <xQueueGenericReceive+0x13c>
   11de0:	8f 81       	ldd	r24, Y+7	; 0x07
   11de2:	98 85       	ldd	r25, Y+8	; 0x08
   11de4:	fc 01       	movw	r30, r24
   11de6:	16 8e       	std	Z+30, r1	; 0x1e
   11de8:	0f 90       	pop	r0
   11dea:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   11dec:	9e 01       	movw	r18, r28
   11dee:	25 5f       	subi	r18, 0xF5	; 245
   11df0:	3f 4f       	sbci	r19, 0xFF	; 255
   11df2:	ce 01       	movw	r24, r28
   11df4:	04 96       	adiw	r24, 0x04	; 4
   11df6:	b9 01       	movw	r22, r18
   11df8:	0e 94 7b 99 	call	0x132f6	; 0x132f6 <xTaskCheckForTimeOut>
   11dfc:	88 23       	and	r24, r24
   11dfe:	a1 f5       	brne	.+104    	; 0x11e68 <xQueueGenericReceive+0x1bc>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   11e00:	8f 81       	ldd	r24, Y+7	; 0x07
   11e02:	98 85       	ldd	r25, Y+8	; 0x08
   11e04:	0e 94 58 91 	call	0x122b0	; 0x122b0 <prvIsQueueEmpty>
   11e08:	88 23       	and	r24, r24
   11e0a:	39 f1       	breq	.+78     	; 0x11e5a <xQueueGenericReceive+0x1ae>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   11e0c:	8f 81       	ldd	r24, Y+7	; 0x07
   11e0e:	98 85       	ldd	r25, Y+8	; 0x08
   11e10:	fc 01       	movw	r30, r24
   11e12:	80 81       	ld	r24, Z
   11e14:	91 81       	ldd	r25, Z+1	; 0x01
   11e16:	00 97       	sbiw	r24, 0x00	; 0
   11e18:	61 f4       	brne	.+24     	; 0x11e32 <xQueueGenericReceive+0x186>
					{
						portENTER_CRITICAL();
   11e1a:	0f b6       	in	r0, 0x3f	; 63
   11e1c:	f8 94       	cli
   11e1e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   11e20:	8f 81       	ldd	r24, Y+7	; 0x07
   11e22:	98 85       	ldd	r25, Y+8	; 0x08
   11e24:	fc 01       	movw	r30, r24
   11e26:	82 81       	ldd	r24, Z+2	; 0x02
   11e28:	93 81       	ldd	r25, Z+3	; 0x03
   11e2a:	0e 94 e6 9b 	call	0x137cc	; 0x137cc <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
   11e2e:	0f 90       	pop	r0
   11e30:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   11e32:	2b 85       	ldd	r18, Y+11	; 0x0b
   11e34:	3c 85       	ldd	r19, Y+12	; 0x0c
   11e36:	8f 81       	ldd	r24, Y+7	; 0x07
   11e38:	98 85       	ldd	r25, Y+8	; 0x08
   11e3a:	41 96       	adiw	r24, 0x11	; 17
   11e3c:	b9 01       	movw	r22, r18
   11e3e:	0e 94 c1 98 	call	0x13182	; 0x13182 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   11e42:	8f 81       	ldd	r24, Y+7	; 0x07
   11e44:	98 85       	ldd	r25, Y+8	; 0x08
   11e46:	0e 94 f4 90 	call	0x121e8	; 0x121e8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   11e4a:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>
   11e4e:	88 23       	and	r24, r24
   11e50:	09 f0       	breq	.+2      	; 0x11e54 <xQueueGenericReceive+0x1a8>
   11e52:	3f cf       	rjmp	.-386    	; 0x11cd2 <xQueueGenericReceive+0x26>
				{
					portYIELD_WITHIN_API();
   11e54:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
   11e58:	3c cf       	rjmp	.-392    	; 0x11cd2 <xQueueGenericReceive+0x26>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   11e5a:	8f 81       	ldd	r24, Y+7	; 0x07
   11e5c:	98 85       	ldd	r25, Y+8	; 0x08
   11e5e:	0e 94 f4 90 	call	0x121e8	; 0x121e8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   11e62:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
   11e66:	35 cf       	rjmp	.-406    	; 0x11cd2 <xQueueGenericReceive+0x26>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
   11e68:	8f 81       	ldd	r24, Y+7	; 0x07
   11e6a:	98 85       	ldd	r25, Y+8	; 0x08
   11e6c:	0e 94 f4 90 	call	0x121e8	; 0x121e8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   11e70:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
   11e74:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
   11e76:	2d 96       	adiw	r28, 0x0d	; 13
   11e78:	0f b6       	in	r0, 0x3f	; 63
   11e7a:	f8 94       	cli
   11e7c:	de bf       	out	0x3e, r29	; 62
   11e7e:	0f be       	out	0x3f, r0	; 63
   11e80:	cd bf       	out	0x3d, r28	; 61
   11e82:	df 91       	pop	r29
   11e84:	cf 91       	pop	r28
   11e86:	08 95       	ret

00011e88 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
   11e88:	cf 93       	push	r28
   11e8a:	df 93       	push	r29
   11e8c:	cd b7       	in	r28, 0x3d	; 61
   11e8e:	de b7       	in	r29, 0x3e	; 62
   11e90:	28 97       	sbiw	r28, 0x08	; 8
   11e92:	0f b6       	in	r0, 0x3f	; 63
   11e94:	f8 94       	cli
   11e96:	de bf       	out	0x3e, r29	; 62
   11e98:	0f be       	out	0x3f, r0	; 63
   11e9a:	cd bf       	out	0x3d, r28	; 61
   11e9c:	9c 83       	std	Y+4, r25	; 0x04
   11e9e:	8b 83       	std	Y+3, r24	; 0x03
   11ea0:	7e 83       	std	Y+6, r23	; 0x06
   11ea2:	6d 83       	std	Y+5, r22	; 0x05
   11ea4:	58 87       	std	Y+8, r21	; 0x08
   11ea6:	4f 83       	std	Y+7, r20	; 0x07
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   11ea8:	1a 82       	std	Y+2, r1	; 0x02
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   11eaa:	8b 81       	ldd	r24, Y+3	; 0x03
   11eac:	9c 81       	ldd	r25, Y+4	; 0x04
   11eae:	fc 01       	movw	r30, r24
   11eb0:	82 8d       	ldd	r24, Z+26	; 0x1a
   11eb2:	88 23       	and	r24, r24
   11eb4:	d9 f1       	breq	.+118    	; 0x11f2c <xQueueReceiveFromISR+0xa4>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
   11eb6:	2d 81       	ldd	r18, Y+5	; 0x05
   11eb8:	3e 81       	ldd	r19, Y+6	; 0x06
   11eba:	8b 81       	ldd	r24, Y+3	; 0x03
   11ebc:	9c 81       	ldd	r25, Y+4	; 0x04
   11ebe:	b9 01       	movw	r22, r18
   11ec0:	0e 94 a3 90 	call	0x12146	; 0x12146 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
   11ec4:	8b 81       	ldd	r24, Y+3	; 0x03
   11ec6:	9c 81       	ldd	r25, Y+4	; 0x04
   11ec8:	fc 01       	movw	r30, r24
   11eca:	82 8d       	ldd	r24, Z+26	; 0x1a
   11ecc:	28 2f       	mov	r18, r24
   11ece:	21 50       	subi	r18, 0x01	; 1
   11ed0:	8b 81       	ldd	r24, Y+3	; 0x03
   11ed2:	9c 81       	ldd	r25, Y+4	; 0x04
   11ed4:	fc 01       	movw	r30, r24
   11ed6:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
   11ed8:	8b 81       	ldd	r24, Y+3	; 0x03
   11eda:	9c 81       	ldd	r25, Y+4	; 0x04
   11edc:	fc 01       	movw	r30, r24
   11ede:	85 8d       	ldd	r24, Z+29	; 0x1d
   11ee0:	8f 3f       	cpi	r24, 0xFF	; 255
   11ee2:	b9 f4       	brne	.+46     	; 0x11f12 <xQueueReceiveFromISR+0x8a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   11ee4:	8b 81       	ldd	r24, Y+3	; 0x03
   11ee6:	9c 81       	ldd	r25, Y+4	; 0x04
   11ee8:	fc 01       	movw	r30, r24
   11eea:	80 85       	ldd	r24, Z+8	; 0x08
   11eec:	88 23       	and	r24, r24
   11eee:	d9 f0       	breq	.+54     	; 0x11f26 <xQueueReceiveFromISR+0x9e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   11ef0:	8b 81       	ldd	r24, Y+3	; 0x03
   11ef2:	9c 81       	ldd	r25, Y+4	; 0x04
   11ef4:	08 96       	adiw	r24, 0x08	; 8
   11ef6:	0e 94 f6 98 	call	0x131ec	; 0x131ec <xTaskRemoveFromEventList>
   11efa:	88 23       	and	r24, r24
   11efc:	a1 f0       	breq	.+40     	; 0x11f26 <xQueueReceiveFromISR+0x9e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
   11efe:	8f 81       	ldd	r24, Y+7	; 0x07
   11f00:	98 85       	ldd	r25, Y+8	; 0x08
   11f02:	00 97       	sbiw	r24, 0x00	; 0
   11f04:	81 f0       	breq	.+32     	; 0x11f26 <xQueueReceiveFromISR+0x9e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
   11f06:	8f 81       	ldd	r24, Y+7	; 0x07
   11f08:	98 85       	ldd	r25, Y+8	; 0x08
   11f0a:	21 e0       	ldi	r18, 0x01	; 1
   11f0c:	fc 01       	movw	r30, r24
   11f0e:	20 83       	st	Z, r18
   11f10:	0a c0       	rjmp	.+20     	; 0x11f26 <xQueueReceiveFromISR+0x9e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
   11f12:	8b 81       	ldd	r24, Y+3	; 0x03
   11f14:	9c 81       	ldd	r25, Y+4	; 0x04
   11f16:	fc 01       	movw	r30, r24
   11f18:	85 8d       	ldd	r24, Z+29	; 0x1d
   11f1a:	28 2f       	mov	r18, r24
   11f1c:	2f 5f       	subi	r18, 0xFF	; 255
   11f1e:	8b 81       	ldd	r24, Y+3	; 0x03
   11f20:	9c 81       	ldd	r25, Y+4	; 0x04
   11f22:	fc 01       	movw	r30, r24
   11f24:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
   11f26:	81 e0       	ldi	r24, 0x01	; 1
   11f28:	89 83       	std	Y+1, r24	; 0x01
   11f2a:	01 c0       	rjmp	.+2      	; 0x11f2e <xQueueReceiveFromISR+0xa6>
		}
		else
		{
			xReturn = pdFAIL;
   11f2c:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   11f2e:	89 81       	ldd	r24, Y+1	; 0x01
}
   11f30:	28 96       	adiw	r28, 0x08	; 8
   11f32:	0f b6       	in	r0, 0x3f	; 63
   11f34:	f8 94       	cli
   11f36:	de bf       	out	0x3e, r29	; 62
   11f38:	0f be       	out	0x3f, r0	; 63
   11f3a:	cd bf       	out	0x3d, r28	; 61
   11f3c:	df 91       	pop	r29
   11f3e:	cf 91       	pop	r28
   11f40:	08 95       	ret

00011f42 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
   11f42:	cf 93       	push	r28
   11f44:	df 93       	push	r29
   11f46:	00 d0       	rcall	.+0      	; 0x11f48 <uxQueueMessagesWaiting+0x6>
   11f48:	1f 92       	push	r1
   11f4a:	cd b7       	in	r28, 0x3d	; 61
   11f4c:	de b7       	in	r29, 0x3e	; 62
   11f4e:	9b 83       	std	Y+3, r25	; 0x03
   11f50:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
   11f52:	0f b6       	in	r0, 0x3f	; 63
   11f54:	f8 94       	cli
   11f56:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
   11f58:	8a 81       	ldd	r24, Y+2	; 0x02
   11f5a:	9b 81       	ldd	r25, Y+3	; 0x03
   11f5c:	fc 01       	movw	r30, r24
   11f5e:	82 8d       	ldd	r24, Z+26	; 0x1a
   11f60:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
   11f62:	0f 90       	pop	r0
   11f64:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
   11f66:	89 81       	ldd	r24, Y+1	; 0x01
}
   11f68:	0f 90       	pop	r0
   11f6a:	0f 90       	pop	r0
   11f6c:	0f 90       	pop	r0
   11f6e:	df 91       	pop	r29
   11f70:	cf 91       	pop	r28
   11f72:	08 95       	ret

00011f74 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
   11f74:	cf 93       	push	r28
   11f76:	df 93       	push	r29
   11f78:	00 d0       	rcall	.+0      	; 0x11f7a <uxQueueMessagesWaitingFromISR+0x6>
   11f7a:	1f 92       	push	r1
   11f7c:	cd b7       	in	r28, 0x3d	; 61
   11f7e:	de b7       	in	r29, 0x3e	; 62
   11f80:	9b 83       	std	Y+3, r25	; 0x03
   11f82:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
   11f84:	8a 81       	ldd	r24, Y+2	; 0x02
   11f86:	9b 81       	ldd	r25, Y+3	; 0x03
   11f88:	fc 01       	movw	r30, r24
   11f8a:	82 8d       	ldd	r24, Z+26	; 0x1a
   11f8c:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
   11f8e:	89 81       	ldd	r24, Y+1	; 0x01
}
   11f90:	0f 90       	pop	r0
   11f92:	0f 90       	pop	r0
   11f94:	0f 90       	pop	r0
   11f96:	df 91       	pop	r29
   11f98:	cf 91       	pop	r28
   11f9a:	08 95       	ret

00011f9c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
   11f9c:	cf 93       	push	r28
   11f9e:	df 93       	push	r29
   11fa0:	00 d0       	rcall	.+0      	; 0x11fa2 <vQueueDelete+0x6>
   11fa2:	cd b7       	in	r28, 0x3d	; 61
   11fa4:	de b7       	in	r29, 0x3e	; 62
   11fa6:	9a 83       	std	Y+2, r25	; 0x02
   11fa8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
   11faa:	89 81       	ldd	r24, Y+1	; 0x01
   11fac:	9a 81       	ldd	r25, Y+2	; 0x02
   11fae:	fc 01       	movw	r30, r24
   11fb0:	80 81       	ld	r24, Z
   11fb2:	91 81       	ldd	r25, Z+1	; 0x01
   11fb4:	0e 94 bd 87 	call	0x10f7a	; 0x10f7a <vPortFree>
	vPortFree( pxQueue );
   11fb8:	89 81       	ldd	r24, Y+1	; 0x01
   11fba:	9a 81       	ldd	r25, Y+2	; 0x02
   11fbc:	0e 94 bd 87 	call	0x10f7a	; 0x10f7a <vPortFree>
}
   11fc0:	0f 90       	pop	r0
   11fc2:	0f 90       	pop	r0
   11fc4:	df 91       	pop	r29
   11fc6:	cf 91       	pop	r28
   11fc8:	08 95       	ret

00011fca <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
   11fca:	cf 93       	push	r28
   11fcc:	df 93       	push	r29
   11fce:	00 d0       	rcall	.+0      	; 0x11fd0 <prvCopyDataToQueue+0x6>
   11fd0:	00 d0       	rcall	.+0      	; 0x11fd2 <prvCopyDataToQueue+0x8>
   11fd2:	1f 92       	push	r1
   11fd4:	cd b7       	in	r28, 0x3d	; 61
   11fd6:	de b7       	in	r29, 0x3e	; 62
   11fd8:	9a 83       	std	Y+2, r25	; 0x02
   11fda:	89 83       	std	Y+1, r24	; 0x01
   11fdc:	7c 83       	std	Y+4, r23	; 0x04
   11fde:	6b 83       	std	Y+3, r22	; 0x03
   11fe0:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
   11fe2:	89 81       	ldd	r24, Y+1	; 0x01
   11fe4:	9a 81       	ldd	r25, Y+2	; 0x02
   11fe6:	fc 01       	movw	r30, r24
   11fe8:	84 8d       	ldd	r24, Z+28	; 0x1c
   11fea:	88 23       	and	r24, r24
   11fec:	a9 f4       	brne	.+42     	; 0x12018 <prvCopyDataToQueue+0x4e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   11fee:	89 81       	ldd	r24, Y+1	; 0x01
   11ff0:	9a 81       	ldd	r25, Y+2	; 0x02
   11ff2:	fc 01       	movw	r30, r24
   11ff4:	80 81       	ld	r24, Z
   11ff6:	91 81       	ldd	r25, Z+1	; 0x01
   11ff8:	00 97       	sbiw	r24, 0x00	; 0
   11ffa:	09 f0       	breq	.+2      	; 0x11ffe <prvCopyDataToQueue+0x34>
   11ffc:	92 c0       	rjmp	.+292    	; 0x12122 <prvCopyDataToQueue+0x158>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   11ffe:	89 81       	ldd	r24, Y+1	; 0x01
   12000:	9a 81       	ldd	r25, Y+2	; 0x02
   12002:	fc 01       	movw	r30, r24
   12004:	82 81       	ldd	r24, Z+2	; 0x02
   12006:	93 81       	ldd	r25, Z+3	; 0x03
   12008:	0e 94 76 9c 	call	0x138ec	; 0x138ec <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
   1200c:	89 81       	ldd	r24, Y+1	; 0x01
   1200e:	9a 81       	ldd	r25, Y+2	; 0x02
   12010:	fc 01       	movw	r30, r24
   12012:	13 82       	std	Z+3, r1	; 0x03
   12014:	12 82       	std	Z+2, r1	; 0x02
   12016:	85 c0       	rjmp	.+266    	; 0x12122 <prvCopyDataToQueue+0x158>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
   12018:	8d 81       	ldd	r24, Y+5	; 0x05
   1201a:	88 23       	and	r24, r24
   1201c:	d9 f5       	brne	.+118    	; 0x12094 <prvCopyDataToQueue+0xca>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
   1201e:	89 81       	ldd	r24, Y+1	; 0x01
   12020:	9a 81       	ldd	r25, Y+2	; 0x02
   12022:	fc 01       	movw	r30, r24
   12024:	84 8d       	ldd	r24, Z+28	; 0x1c
   12026:	48 2f       	mov	r20, r24
   12028:	50 e0       	ldi	r21, 0x00	; 0
   1202a:	89 81       	ldd	r24, Y+1	; 0x01
   1202c:	9a 81       	ldd	r25, Y+2	; 0x02
   1202e:	fc 01       	movw	r30, r24
   12030:	84 81       	ldd	r24, Z+4	; 0x04
   12032:	95 81       	ldd	r25, Z+5	; 0x05
   12034:	2b 81       	ldd	r18, Y+3	; 0x03
   12036:	3c 81       	ldd	r19, Y+4	; 0x04
   12038:	b9 01       	movw	r22, r18
   1203a:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   1203e:	89 81       	ldd	r24, Y+1	; 0x01
   12040:	9a 81       	ldd	r25, Y+2	; 0x02
   12042:	fc 01       	movw	r30, r24
   12044:	24 81       	ldd	r18, Z+4	; 0x04
   12046:	35 81       	ldd	r19, Z+5	; 0x05
   12048:	89 81       	ldd	r24, Y+1	; 0x01
   1204a:	9a 81       	ldd	r25, Y+2	; 0x02
   1204c:	fc 01       	movw	r30, r24
   1204e:	84 8d       	ldd	r24, Z+28	; 0x1c
   12050:	88 2f       	mov	r24, r24
   12052:	90 e0       	ldi	r25, 0x00	; 0
   12054:	28 0f       	add	r18, r24
   12056:	39 1f       	adc	r19, r25
   12058:	89 81       	ldd	r24, Y+1	; 0x01
   1205a:	9a 81       	ldd	r25, Y+2	; 0x02
   1205c:	fc 01       	movw	r30, r24
   1205e:	35 83       	std	Z+5, r19	; 0x05
   12060:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
   12062:	89 81       	ldd	r24, Y+1	; 0x01
   12064:	9a 81       	ldd	r25, Y+2	; 0x02
   12066:	fc 01       	movw	r30, r24
   12068:	24 81       	ldd	r18, Z+4	; 0x04
   1206a:	35 81       	ldd	r19, Z+5	; 0x05
   1206c:	89 81       	ldd	r24, Y+1	; 0x01
   1206e:	9a 81       	ldd	r25, Y+2	; 0x02
   12070:	fc 01       	movw	r30, r24
   12072:	82 81       	ldd	r24, Z+2	; 0x02
   12074:	93 81       	ldd	r25, Z+3	; 0x03
   12076:	28 17       	cp	r18, r24
   12078:	39 07       	cpc	r19, r25
   1207a:	08 f4       	brcc	.+2      	; 0x1207e <prvCopyDataToQueue+0xb4>
   1207c:	52 c0       	rjmp	.+164    	; 0x12122 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   1207e:	89 81       	ldd	r24, Y+1	; 0x01
   12080:	9a 81       	ldd	r25, Y+2	; 0x02
   12082:	fc 01       	movw	r30, r24
   12084:	20 81       	ld	r18, Z
   12086:	31 81       	ldd	r19, Z+1	; 0x01
   12088:	89 81       	ldd	r24, Y+1	; 0x01
   1208a:	9a 81       	ldd	r25, Y+2	; 0x02
   1208c:	fc 01       	movw	r30, r24
   1208e:	35 83       	std	Z+5, r19	; 0x05
   12090:	24 83       	std	Z+4, r18	; 0x04
   12092:	47 c0       	rjmp	.+142    	; 0x12122 <prvCopyDataToQueue+0x158>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
   12094:	89 81       	ldd	r24, Y+1	; 0x01
   12096:	9a 81       	ldd	r25, Y+2	; 0x02
   12098:	fc 01       	movw	r30, r24
   1209a:	84 8d       	ldd	r24, Z+28	; 0x1c
   1209c:	48 2f       	mov	r20, r24
   1209e:	50 e0       	ldi	r21, 0x00	; 0
   120a0:	89 81       	ldd	r24, Y+1	; 0x01
   120a2:	9a 81       	ldd	r25, Y+2	; 0x02
   120a4:	fc 01       	movw	r30, r24
   120a6:	86 81       	ldd	r24, Z+6	; 0x06
   120a8:	97 81       	ldd	r25, Z+7	; 0x07
   120aa:	2b 81       	ldd	r18, Y+3	; 0x03
   120ac:	3c 81       	ldd	r19, Y+4	; 0x04
   120ae:	b9 01       	movw	r22, r18
   120b0:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
   120b4:	89 81       	ldd	r24, Y+1	; 0x01
   120b6:	9a 81       	ldd	r25, Y+2	; 0x02
   120b8:	fc 01       	movw	r30, r24
   120ba:	26 81       	ldd	r18, Z+6	; 0x06
   120bc:	37 81       	ldd	r19, Z+7	; 0x07
   120be:	89 81       	ldd	r24, Y+1	; 0x01
   120c0:	9a 81       	ldd	r25, Y+2	; 0x02
   120c2:	fc 01       	movw	r30, r24
   120c4:	84 8d       	ldd	r24, Z+28	; 0x1c
   120c6:	88 2f       	mov	r24, r24
   120c8:	90 e0       	ldi	r25, 0x00	; 0
   120ca:	91 95       	neg	r25
   120cc:	81 95       	neg	r24
   120ce:	91 09       	sbc	r25, r1
   120d0:	28 0f       	add	r18, r24
   120d2:	39 1f       	adc	r19, r25
   120d4:	89 81       	ldd	r24, Y+1	; 0x01
   120d6:	9a 81       	ldd	r25, Y+2	; 0x02
   120d8:	fc 01       	movw	r30, r24
   120da:	37 83       	std	Z+7, r19	; 0x07
   120dc:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
   120de:	89 81       	ldd	r24, Y+1	; 0x01
   120e0:	9a 81       	ldd	r25, Y+2	; 0x02
   120e2:	fc 01       	movw	r30, r24
   120e4:	26 81       	ldd	r18, Z+6	; 0x06
   120e6:	37 81       	ldd	r19, Z+7	; 0x07
   120e8:	89 81       	ldd	r24, Y+1	; 0x01
   120ea:	9a 81       	ldd	r25, Y+2	; 0x02
   120ec:	fc 01       	movw	r30, r24
   120ee:	80 81       	ld	r24, Z
   120f0:	91 81       	ldd	r25, Z+1	; 0x01
   120f2:	28 17       	cp	r18, r24
   120f4:	39 07       	cpc	r19, r25
   120f6:	a8 f4       	brcc	.+42     	; 0x12122 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   120f8:	89 81       	ldd	r24, Y+1	; 0x01
   120fa:	9a 81       	ldd	r25, Y+2	; 0x02
   120fc:	fc 01       	movw	r30, r24
   120fe:	22 81       	ldd	r18, Z+2	; 0x02
   12100:	33 81       	ldd	r19, Z+3	; 0x03
   12102:	89 81       	ldd	r24, Y+1	; 0x01
   12104:	9a 81       	ldd	r25, Y+2	; 0x02
   12106:	fc 01       	movw	r30, r24
   12108:	84 8d       	ldd	r24, Z+28	; 0x1c
   1210a:	88 2f       	mov	r24, r24
   1210c:	90 e0       	ldi	r25, 0x00	; 0
   1210e:	91 95       	neg	r25
   12110:	81 95       	neg	r24
   12112:	91 09       	sbc	r25, r1
   12114:	28 0f       	add	r18, r24
   12116:	39 1f       	adc	r19, r25
   12118:	89 81       	ldd	r24, Y+1	; 0x01
   1211a:	9a 81       	ldd	r25, Y+2	; 0x02
   1211c:	fc 01       	movw	r30, r24
   1211e:	37 83       	std	Z+7, r19	; 0x07
   12120:	26 83       	std	Z+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
   12122:	89 81       	ldd	r24, Y+1	; 0x01
   12124:	9a 81       	ldd	r25, Y+2	; 0x02
   12126:	fc 01       	movw	r30, r24
   12128:	82 8d       	ldd	r24, Z+26	; 0x1a
   1212a:	28 2f       	mov	r18, r24
   1212c:	2f 5f       	subi	r18, 0xFF	; 255
   1212e:	89 81       	ldd	r24, Y+1	; 0x01
   12130:	9a 81       	ldd	r25, Y+2	; 0x02
   12132:	fc 01       	movw	r30, r24
   12134:	22 8f       	std	Z+26, r18	; 0x1a
}
   12136:	0f 90       	pop	r0
   12138:	0f 90       	pop	r0
   1213a:	0f 90       	pop	r0
   1213c:	0f 90       	pop	r0
   1213e:	0f 90       	pop	r0
   12140:	df 91       	pop	r29
   12142:	cf 91       	pop	r28
   12144:	08 95       	ret

00012146 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
   12146:	cf 93       	push	r28
   12148:	df 93       	push	r29
   1214a:	00 d0       	rcall	.+0      	; 0x1214c <prvCopyDataFromQueue+0x6>
   1214c:	00 d0       	rcall	.+0      	; 0x1214e <prvCopyDataFromQueue+0x8>
   1214e:	cd b7       	in	r28, 0x3d	; 61
   12150:	de b7       	in	r29, 0x3e	; 62
   12152:	9a 83       	std	Y+2, r25	; 0x02
   12154:	89 83       	std	Y+1, r24	; 0x01
   12156:	7c 83       	std	Y+4, r23	; 0x04
   12158:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
   1215a:	89 81       	ldd	r24, Y+1	; 0x01
   1215c:	9a 81       	ldd	r25, Y+2	; 0x02
   1215e:	fc 01       	movw	r30, r24
   12160:	80 81       	ld	r24, Z
   12162:	91 81       	ldd	r25, Z+1	; 0x01
   12164:	00 97       	sbiw	r24, 0x00	; 0
   12166:	c9 f1       	breq	.+114    	; 0x121da <prvCopyDataFromQueue+0x94>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
   12168:	89 81       	ldd	r24, Y+1	; 0x01
   1216a:	9a 81       	ldd	r25, Y+2	; 0x02
   1216c:	fc 01       	movw	r30, r24
   1216e:	26 81       	ldd	r18, Z+6	; 0x06
   12170:	37 81       	ldd	r19, Z+7	; 0x07
   12172:	89 81       	ldd	r24, Y+1	; 0x01
   12174:	9a 81       	ldd	r25, Y+2	; 0x02
   12176:	fc 01       	movw	r30, r24
   12178:	84 8d       	ldd	r24, Z+28	; 0x1c
   1217a:	88 2f       	mov	r24, r24
   1217c:	90 e0       	ldi	r25, 0x00	; 0
   1217e:	28 0f       	add	r18, r24
   12180:	39 1f       	adc	r19, r25
   12182:	89 81       	ldd	r24, Y+1	; 0x01
   12184:	9a 81       	ldd	r25, Y+2	; 0x02
   12186:	fc 01       	movw	r30, r24
   12188:	37 83       	std	Z+7, r19	; 0x07
   1218a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
   1218c:	89 81       	ldd	r24, Y+1	; 0x01
   1218e:	9a 81       	ldd	r25, Y+2	; 0x02
   12190:	fc 01       	movw	r30, r24
   12192:	26 81       	ldd	r18, Z+6	; 0x06
   12194:	37 81       	ldd	r19, Z+7	; 0x07
   12196:	89 81       	ldd	r24, Y+1	; 0x01
   12198:	9a 81       	ldd	r25, Y+2	; 0x02
   1219a:	fc 01       	movw	r30, r24
   1219c:	82 81       	ldd	r24, Z+2	; 0x02
   1219e:	93 81       	ldd	r25, Z+3	; 0x03
   121a0:	28 17       	cp	r18, r24
   121a2:	39 07       	cpc	r19, r25
   121a4:	50 f0       	brcs	.+20     	; 0x121ba <prvCopyDataFromQueue+0x74>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
   121a6:	89 81       	ldd	r24, Y+1	; 0x01
   121a8:	9a 81       	ldd	r25, Y+2	; 0x02
   121aa:	fc 01       	movw	r30, r24
   121ac:	20 81       	ld	r18, Z
   121ae:	31 81       	ldd	r19, Z+1	; 0x01
   121b0:	89 81       	ldd	r24, Y+1	; 0x01
   121b2:	9a 81       	ldd	r25, Y+2	; 0x02
   121b4:	fc 01       	movw	r30, r24
   121b6:	37 83       	std	Z+7, r19	; 0x07
   121b8:	26 83       	std	Z+6, r18	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   121ba:	89 81       	ldd	r24, Y+1	; 0x01
   121bc:	9a 81       	ldd	r25, Y+2	; 0x02
   121be:	fc 01       	movw	r30, r24
   121c0:	84 8d       	ldd	r24, Z+28	; 0x1c
   121c2:	48 2f       	mov	r20, r24
   121c4:	50 e0       	ldi	r21, 0x00	; 0
   121c6:	89 81       	ldd	r24, Y+1	; 0x01
   121c8:	9a 81       	ldd	r25, Y+2	; 0x02
   121ca:	fc 01       	movw	r30, r24
   121cc:	26 81       	ldd	r18, Z+6	; 0x06
   121ce:	37 81       	ldd	r19, Z+7	; 0x07
   121d0:	8b 81       	ldd	r24, Y+3	; 0x03
   121d2:	9c 81       	ldd	r25, Y+4	; 0x04
   121d4:	b9 01       	movw	r22, r18
   121d6:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
	}
}
   121da:	0f 90       	pop	r0
   121dc:	0f 90       	pop	r0
   121de:	0f 90       	pop	r0
   121e0:	0f 90       	pop	r0
   121e2:	df 91       	pop	r29
   121e4:	cf 91       	pop	r28
   121e6:	08 95       	ret

000121e8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
   121e8:	cf 93       	push	r28
   121ea:	df 93       	push	r29
   121ec:	00 d0       	rcall	.+0      	; 0x121ee <prvUnlockQueue+0x6>
   121ee:	cd b7       	in	r28, 0x3d	; 61
   121f0:	de b7       	in	r29, 0x3e	; 62
   121f2:	9a 83       	std	Y+2, r25	; 0x02
   121f4:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   121f6:	0f b6       	in	r0, 0x3f	; 63
   121f8:	f8 94       	cli
   121fa:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   121fc:	19 c0       	rjmp	.+50     	; 0x12230 <prvUnlockQueue+0x48>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   121fe:	89 81       	ldd	r24, Y+1	; 0x01
   12200:	9a 81       	ldd	r25, Y+2	; 0x02
   12202:	fc 01       	movw	r30, r24
   12204:	81 89       	ldd	r24, Z+17	; 0x11
   12206:	88 23       	and	r24, r24
   12208:	d1 f0       	breq	.+52     	; 0x1223e <prvUnlockQueue+0x56>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1220a:	89 81       	ldd	r24, Y+1	; 0x01
   1220c:	9a 81       	ldd	r25, Y+2	; 0x02
   1220e:	41 96       	adiw	r24, 0x11	; 17
   12210:	0e 94 f6 98 	call	0x131ec	; 0x131ec <xTaskRemoveFromEventList>
   12214:	88 23       	and	r24, r24
   12216:	11 f0       	breq	.+4      	; 0x1221c <prvUnlockQueue+0x34>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
   12218:	0e 94 df 99 	call	0x133be	; 0x133be <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
   1221c:	89 81       	ldd	r24, Y+1	; 0x01
   1221e:	9a 81       	ldd	r25, Y+2	; 0x02
   12220:	fc 01       	movw	r30, r24
   12222:	86 8d       	ldd	r24, Z+30	; 0x1e
   12224:	28 2f       	mov	r18, r24
   12226:	21 50       	subi	r18, 0x01	; 1
   12228:	89 81       	ldd	r24, Y+1	; 0x01
   1222a:	9a 81       	ldd	r25, Y+2	; 0x02
   1222c:	fc 01       	movw	r30, r24
   1222e:	26 8f       	std	Z+30, r18	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   12230:	89 81       	ldd	r24, Y+1	; 0x01
   12232:	9a 81       	ldd	r25, Y+2	; 0x02
   12234:	fc 01       	movw	r30, r24
   12236:	86 8d       	ldd	r24, Z+30	; 0x1e
   12238:	18 16       	cp	r1, r24
   1223a:	0c f3       	brlt	.-62     	; 0x121fe <prvUnlockQueue+0x16>
   1223c:	01 c0       	rjmp	.+2      	; 0x12240 <prvUnlockQueue+0x58>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
   1223e:	00 00       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
   12240:	89 81       	ldd	r24, Y+1	; 0x01
   12242:	9a 81       	ldd	r25, Y+2	; 0x02
   12244:	2f ef       	ldi	r18, 0xFF	; 255
   12246:	fc 01       	movw	r30, r24
   12248:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
   1224a:	0f 90       	pop	r0
   1224c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   1224e:	0f b6       	in	r0, 0x3f	; 63
   12250:	f8 94       	cli
   12252:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   12254:	19 c0       	rjmp	.+50     	; 0x12288 <prvUnlockQueue+0xa0>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   12256:	89 81       	ldd	r24, Y+1	; 0x01
   12258:	9a 81       	ldd	r25, Y+2	; 0x02
   1225a:	fc 01       	movw	r30, r24
   1225c:	80 85       	ldd	r24, Z+8	; 0x08
   1225e:	88 23       	and	r24, r24
   12260:	d1 f0       	breq	.+52     	; 0x12296 <prvUnlockQueue+0xae>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   12262:	89 81       	ldd	r24, Y+1	; 0x01
   12264:	9a 81       	ldd	r25, Y+2	; 0x02
   12266:	08 96       	adiw	r24, 0x08	; 8
   12268:	0e 94 f6 98 	call	0x131ec	; 0x131ec <xTaskRemoveFromEventList>
   1226c:	88 23       	and	r24, r24
   1226e:	11 f0       	breq	.+4      	; 0x12274 <prvUnlockQueue+0x8c>
				{
					vTaskMissedYield();
   12270:	0e 94 df 99 	call	0x133be	; 0x133be <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
   12274:	89 81       	ldd	r24, Y+1	; 0x01
   12276:	9a 81       	ldd	r25, Y+2	; 0x02
   12278:	fc 01       	movw	r30, r24
   1227a:	85 8d       	ldd	r24, Z+29	; 0x1d
   1227c:	28 2f       	mov	r18, r24
   1227e:	21 50       	subi	r18, 0x01	; 1
   12280:	89 81       	ldd	r24, Y+1	; 0x01
   12282:	9a 81       	ldd	r25, Y+2	; 0x02
   12284:	fc 01       	movw	r30, r24
   12286:	25 8f       	std	Z+29, r18	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   12288:	89 81       	ldd	r24, Y+1	; 0x01
   1228a:	9a 81       	ldd	r25, Y+2	; 0x02
   1228c:	fc 01       	movw	r30, r24
   1228e:	85 8d       	ldd	r24, Z+29	; 0x1d
   12290:	18 16       	cp	r1, r24
   12292:	0c f3       	brlt	.-62     	; 0x12256 <prvUnlockQueue+0x6e>
   12294:	01 c0       	rjmp	.+2      	; 0x12298 <prvUnlockQueue+0xb0>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
   12296:	00 00       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
   12298:	89 81       	ldd	r24, Y+1	; 0x01
   1229a:	9a 81       	ldd	r25, Y+2	; 0x02
   1229c:	2f ef       	ldi	r18, 0xFF	; 255
   1229e:	fc 01       	movw	r30, r24
   122a0:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
   122a2:	0f 90       	pop	r0
   122a4:	0f be       	out	0x3f, r0	; 63
}
   122a6:	0f 90       	pop	r0
   122a8:	0f 90       	pop	r0
   122aa:	df 91       	pop	r29
   122ac:	cf 91       	pop	r28
   122ae:	08 95       	ret

000122b0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
   122b0:	cf 93       	push	r28
   122b2:	df 93       	push	r29
   122b4:	00 d0       	rcall	.+0      	; 0x122b6 <prvIsQueueEmpty+0x6>
   122b6:	1f 92       	push	r1
   122b8:	cd b7       	in	r28, 0x3d	; 61
   122ba:	de b7       	in	r29, 0x3e	; 62
   122bc:	9b 83       	std	Y+3, r25	; 0x03
   122be:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
   122c0:	0f b6       	in	r0, 0x3f	; 63
   122c2:	f8 94       	cli
   122c4:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
   122c6:	8a 81       	ldd	r24, Y+2	; 0x02
   122c8:	9b 81       	ldd	r25, Y+3	; 0x03
   122ca:	fc 01       	movw	r30, r24
   122cc:	92 8d       	ldd	r25, Z+26	; 0x1a
   122ce:	81 e0       	ldi	r24, 0x01	; 1
   122d0:	99 23       	and	r25, r25
   122d2:	09 f0       	breq	.+2      	; 0x122d6 <prvIsQueueEmpty+0x26>
   122d4:	80 e0       	ldi	r24, 0x00	; 0
   122d6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
   122d8:	0f 90       	pop	r0
   122da:	0f be       	out	0x3f, r0	; 63

	return xReturn;
   122dc:	89 81       	ldd	r24, Y+1	; 0x01
}
   122de:	0f 90       	pop	r0
   122e0:	0f 90       	pop	r0
   122e2:	0f 90       	pop	r0
   122e4:	df 91       	pop	r29
   122e6:	cf 91       	pop	r28
   122e8:	08 95       	ret

000122ea <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
   122ea:	cf 93       	push	r28
   122ec:	df 93       	push	r29
   122ee:	00 d0       	rcall	.+0      	; 0x122f0 <xQueueIsQueueEmptyFromISR+0x6>
   122f0:	1f 92       	push	r1
   122f2:	cd b7       	in	r28, 0x3d	; 61
   122f4:	de b7       	in	r29, 0x3e	; 62
   122f6:	9b 83       	std	Y+3, r25	; 0x03
   122f8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
   122fa:	8a 81       	ldd	r24, Y+2	; 0x02
   122fc:	9b 81       	ldd	r25, Y+3	; 0x03
   122fe:	fc 01       	movw	r30, r24
   12300:	92 8d       	ldd	r25, Z+26	; 0x1a
   12302:	81 e0       	ldi	r24, 0x01	; 1
   12304:	99 23       	and	r25, r25
   12306:	09 f0       	breq	.+2      	; 0x1230a <xQueueIsQueueEmptyFromISR+0x20>
   12308:	80 e0       	ldi	r24, 0x00	; 0
   1230a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
   1230c:	89 81       	ldd	r24, Y+1	; 0x01
}
   1230e:	0f 90       	pop	r0
   12310:	0f 90       	pop	r0
   12312:	0f 90       	pop	r0
   12314:	df 91       	pop	r29
   12316:	cf 91       	pop	r28
   12318:	08 95       	ret

0001231a <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
   1231a:	cf 93       	push	r28
   1231c:	df 93       	push	r29
   1231e:	00 d0       	rcall	.+0      	; 0x12320 <prvIsQueueFull+0x6>
   12320:	1f 92       	push	r1
   12322:	cd b7       	in	r28, 0x3d	; 61
   12324:	de b7       	in	r29, 0x3e	; 62
   12326:	9b 83       	std	Y+3, r25	; 0x03
   12328:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
   1232a:	0f b6       	in	r0, 0x3f	; 63
   1232c:	f8 94       	cli
   1232e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
   12330:	8a 81       	ldd	r24, Y+2	; 0x02
   12332:	9b 81       	ldd	r25, Y+3	; 0x03
   12334:	fc 01       	movw	r30, r24
   12336:	22 8d       	ldd	r18, Z+26	; 0x1a
   12338:	8a 81       	ldd	r24, Y+2	; 0x02
   1233a:	9b 81       	ldd	r25, Y+3	; 0x03
   1233c:	fc 01       	movw	r30, r24
   1233e:	93 8d       	ldd	r25, Z+27	; 0x1b
   12340:	81 e0       	ldi	r24, 0x01	; 1
   12342:	29 17       	cp	r18, r25
   12344:	09 f0       	breq	.+2      	; 0x12348 <prvIsQueueFull+0x2e>
   12346:	80 e0       	ldi	r24, 0x00	; 0
   12348:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
   1234a:	0f 90       	pop	r0
   1234c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
   1234e:	89 81       	ldd	r24, Y+1	; 0x01
}
   12350:	0f 90       	pop	r0
   12352:	0f 90       	pop	r0
   12354:	0f 90       	pop	r0
   12356:	df 91       	pop	r29
   12358:	cf 91       	pop	r28
   1235a:	08 95       	ret

0001235c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   1235c:	cf 93       	push	r28
   1235e:	df 93       	push	r29
   12360:	00 d0       	rcall	.+0      	; 0x12362 <xQueueIsQueueFullFromISR+0x6>
   12362:	1f 92       	push	r1
   12364:	cd b7       	in	r28, 0x3d	; 61
   12366:	de b7       	in	r29, 0x3e	; 62
   12368:	9b 83       	std	Y+3, r25	; 0x03
   1236a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
   1236c:	8a 81       	ldd	r24, Y+2	; 0x02
   1236e:	9b 81       	ldd	r25, Y+3	; 0x03
   12370:	fc 01       	movw	r30, r24
   12372:	22 8d       	ldd	r18, Z+26	; 0x1a
   12374:	8a 81       	ldd	r24, Y+2	; 0x02
   12376:	9b 81       	ldd	r25, Y+3	; 0x03
   12378:	fc 01       	movw	r30, r24
   1237a:	93 8d       	ldd	r25, Z+27	; 0x1b
   1237c:	81 e0       	ldi	r24, 0x01	; 1
   1237e:	29 17       	cp	r18, r25
   12380:	09 f0       	breq	.+2      	; 0x12384 <xQueueIsQueueFullFromISR+0x28>
   12382:	80 e0       	ldi	r24, 0x00	; 0
   12384:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
   12386:	89 81       	ldd	r24, Y+1	; 0x01
}
   12388:	0f 90       	pop	r0
   1238a:	0f 90       	pop	r0
   1238c:	0f 90       	pop	r0
   1238e:	df 91       	pop	r29
   12390:	cf 91       	pop	r28
   12392:	08 95       	ret

00012394 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xTicksToWait )
{
   12394:	cf 93       	push	r28
   12396:	df 93       	push	r29
   12398:	cd b7       	in	r28, 0x3d	; 61
   1239a:	de b7       	in	r29, 0x3e	; 62
   1239c:	27 97       	sbiw	r28, 0x07	; 7
   1239e:	0f b6       	in	r0, 0x3f	; 63
   123a0:	f8 94       	cli
   123a2:	de bf       	out	0x3e, r29	; 62
   123a4:	0f be       	out	0x3f, r0	; 63
   123a6:	cd bf       	out	0x3d, r28	; 61
   123a8:	9b 83       	std	Y+3, r25	; 0x03
   123aa:	8a 83       	std	Y+2, r24	; 0x02
   123ac:	7d 83       	std	Y+5, r23	; 0x05
   123ae:	6c 83       	std	Y+4, r22	; 0x04
   123b0:	5f 83       	std	Y+7, r21	; 0x07
   123b2:	4e 83       	std	Y+6, r20	; 0x06
signed portBASE_TYPE xReturn;

	/* If the queue is already full we may have to block.  A critical section
	is required to prevent an interrupt removing something from the queue
	between the check to see if the queue is full and blocking on the queue. */
	portDISABLE_INTERRUPTS();
   123b4:	f8 94       	cli
	{
		if( prvIsQueueFull( pxQueue ) != pdFALSE )
   123b6:	8a 81       	ldd	r24, Y+2	; 0x02
   123b8:	9b 81       	ldd	r25, Y+3	; 0x03
   123ba:	0e 94 8d 91 	call	0x1231a	; 0x1231a <prvIsQueueFull>
   123be:	88 23       	and	r24, r24
   123c0:	a1 f0       	breq	.+40     	; 0x123ea <xQueueCRSend+0x56>
		{
			/* The queue is full - do we want to block or just leave without
			posting? */
			if( xTicksToWait > ( portTickType ) 0 )
   123c2:	8e 81       	ldd	r24, Y+6	; 0x06
   123c4:	9f 81       	ldd	r25, Y+7	; 0x07
   123c6:	00 97       	sbiw	r24, 0x00	; 0
   123c8:	69 f0       	breq	.+26     	; 0x123e4 <xQueueCRSend+0x50>
			{
				/* As this is called from a coroutine we cannot block directly, but
				return indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
   123ca:	8a 81       	ldd	r24, Y+2	; 0x02
   123cc:	9b 81       	ldd	r25, Y+3	; 0x03
   123ce:	9c 01       	movw	r18, r24
   123d0:	28 5f       	subi	r18, 0xF8	; 248
   123d2:	3f 4f       	sbci	r19, 0xFF	; 255
   123d4:	8e 81       	ldd	r24, Y+6	; 0x06
   123d6:	9f 81       	ldd	r25, Y+7	; 0x07
   123d8:	b9 01       	movw	r22, r18
   123da:	0e 94 41 85 	call	0x10a82	; 0x10a82 <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
   123de:	78 94       	sei
				return errQUEUE_BLOCKED;
   123e0:	8c ef       	ldi	r24, 0xFC	; 252
   123e2:	2d c0       	rjmp	.+90     	; 0x1243e <xQueueCRSend+0xaa>
			}
			else
			{
				portENABLE_INTERRUPTS();
   123e4:	78 94       	sei
				return errQUEUE_FULL;
   123e6:	80 e0       	ldi	r24, 0x00	; 0
   123e8:	2a c0       	rjmp	.+84     	; 0x1243e <xQueueCRSend+0xaa>
			}
		}
	}
	portENABLE_INTERRUPTS();
   123ea:	78 94       	sei

	portNOP();
   123ec:	00 00       	nop

	portDISABLE_INTERRUPTS();
   123ee:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   123f0:	8a 81       	ldd	r24, Y+2	; 0x02
   123f2:	9b 81       	ldd	r25, Y+3	; 0x03
   123f4:	fc 01       	movw	r30, r24
   123f6:	22 8d       	ldd	r18, Z+26	; 0x1a
   123f8:	8a 81       	ldd	r24, Y+2	; 0x02
   123fa:	9b 81       	ldd	r25, Y+3	; 0x03
   123fc:	fc 01       	movw	r30, r24
   123fe:	83 8d       	ldd	r24, Z+27	; 0x1b
   12400:	28 17       	cp	r18, r24
   12402:	d0 f4       	brcc	.+52     	; 0x12438 <xQueueCRSend+0xa4>
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   12404:	2c 81       	ldd	r18, Y+4	; 0x04
   12406:	3d 81       	ldd	r19, Y+5	; 0x05
   12408:	8a 81       	ldd	r24, Y+2	; 0x02
   1240a:	9b 81       	ldd	r25, Y+3	; 0x03
   1240c:	40 e0       	ldi	r20, 0x00	; 0
   1240e:	b9 01       	movw	r22, r18
   12410:	0e 94 e5 8f 	call	0x11fca	; 0x11fca <prvCopyDataToQueue>
			xReturn = pdPASS;
   12414:	81 e0       	ldi	r24, 0x01	; 1
   12416:	89 83       	std	Y+1, r24	; 0x01

			/* Were any co-routines waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   12418:	8a 81       	ldd	r24, Y+2	; 0x02
   1241a:	9b 81       	ldd	r25, Y+3	; 0x03
   1241c:	fc 01       	movw	r30, r24
   1241e:	81 89       	ldd	r24, Z+17	; 0x11
   12420:	88 23       	and	r24, r24
   12422:	59 f0       	breq	.+22     	; 0x1243a <xQueueCRSend+0xa6>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   12424:	8a 81       	ldd	r24, Y+2	; 0x02
   12426:	9b 81       	ldd	r25, Y+3	; 0x03
   12428:	41 96       	adiw	r24, 0x11	; 17
   1242a:	0e 94 69 87 	call	0x10ed2	; 0x10ed2 <xCoRoutineRemoveFromEventList>
   1242e:	88 23       	and	r24, r24
   12430:	21 f0       	breq	.+8      	; 0x1243a <xQueueCRSend+0xa6>
				{
					/* The co-routine waiting has a higher priority so record
					that a yield might be appropriate. */
					xReturn = errQUEUE_YIELD;
   12432:	8b ef       	ldi	r24, 0xFB	; 251
   12434:	89 83       	std	Y+1, r24	; 0x01
   12436:	01 c0       	rjmp	.+2      	; 0x1243a <xQueueCRSend+0xa6>
				}
			}
		}
		else
		{
			xReturn = errQUEUE_FULL;
   12438:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portENABLE_INTERRUPTS();
   1243a:	78 94       	sei

	return xReturn;
   1243c:	89 81       	ldd	r24, Y+1	; 0x01
}
   1243e:	27 96       	adiw	r28, 0x07	; 7
   12440:	0f b6       	in	r0, 0x3f	; 63
   12442:	f8 94       	cli
   12444:	de bf       	out	0x3e, r29	; 62
   12446:	0f be       	out	0x3f, r0	; 63
   12448:	cd bf       	out	0x3d, r28	; 61
   1244a:	df 91       	pop	r29
   1244c:	cf 91       	pop	r28
   1244e:	08 95       	ret

00012450 <xQueueCRReceive>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWait )
{
   12450:	cf 93       	push	r28
   12452:	df 93       	push	r29
   12454:	cd b7       	in	r28, 0x3d	; 61
   12456:	de b7       	in	r29, 0x3e	; 62
   12458:	27 97       	sbiw	r28, 0x07	; 7
   1245a:	0f b6       	in	r0, 0x3f	; 63
   1245c:	f8 94       	cli
   1245e:	de bf       	out	0x3e, r29	; 62
   12460:	0f be       	out	0x3f, r0	; 63
   12462:	cd bf       	out	0x3d, r28	; 61
   12464:	9b 83       	std	Y+3, r25	; 0x03
   12466:	8a 83       	std	Y+2, r24	; 0x02
   12468:	7d 83       	std	Y+5, r23	; 0x05
   1246a:	6c 83       	std	Y+4, r22	; 0x04
   1246c:	5f 83       	std	Y+7, r21	; 0x07
   1246e:	4e 83       	std	Y+6, r20	; 0x06
signed portBASE_TYPE xReturn;

	/* If the queue is already empty we may have to block.  A critical section
	is required to prevent an interrupt adding something to the queue
	between the check to see if the queue is empty and blocking on the queue. */
	portDISABLE_INTERRUPTS();
   12470:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
   12472:	8a 81       	ldd	r24, Y+2	; 0x02
   12474:	9b 81       	ldd	r25, Y+3	; 0x03
   12476:	fc 01       	movw	r30, r24
   12478:	82 8d       	ldd	r24, Z+26	; 0x1a
   1247a:	88 23       	and	r24, r24
   1247c:	a1 f4       	brne	.+40     	; 0x124a6 <xQueueCRReceive+0x56>
		{
			/* There are no messages in the queue, do we want to block or just
			leave with nothing? */
			if( xTicksToWait > ( portTickType ) 0 )
   1247e:	8e 81       	ldd	r24, Y+6	; 0x06
   12480:	9f 81       	ldd	r25, Y+7	; 0x07
   12482:	00 97       	sbiw	r24, 0x00	; 0
   12484:	69 f0       	breq	.+26     	; 0x124a0 <xQueueCRReceive+0x50>
			{
				/* As this is a co-routine we cannot block directly, but return
				indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
   12486:	8a 81       	ldd	r24, Y+2	; 0x02
   12488:	9b 81       	ldd	r25, Y+3	; 0x03
   1248a:	9c 01       	movw	r18, r24
   1248c:	2f 5e       	subi	r18, 0xEF	; 239
   1248e:	3f 4f       	sbci	r19, 0xFF	; 255
   12490:	8e 81       	ldd	r24, Y+6	; 0x06
   12492:	9f 81       	ldd	r25, Y+7	; 0x07
   12494:	b9 01       	movw	r22, r18
   12496:	0e 94 41 85 	call	0x10a82	; 0x10a82 <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
   1249a:	78 94       	sei
				return errQUEUE_BLOCKED;
   1249c:	8c ef       	ldi	r24, 0xFC	; 252
   1249e:	65 c0       	rjmp	.+202    	; 0x1256a <xQueueCRReceive+0x11a>
			}
			else
			{
				portENABLE_INTERRUPTS();
   124a0:	78 94       	sei
				return errQUEUE_FULL;
   124a2:	80 e0       	ldi	r24, 0x00	; 0
   124a4:	62 c0       	rjmp	.+196    	; 0x1256a <xQueueCRReceive+0x11a>
			}
		}
	}
	portENABLE_INTERRUPTS();
   124a6:	78 94       	sei

	portNOP();
   124a8:	00 00       	nop

	portDISABLE_INTERRUPTS();
   124aa:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   124ac:	8a 81       	ldd	r24, Y+2	; 0x02
   124ae:	9b 81       	ldd	r25, Y+3	; 0x03
   124b0:	fc 01       	movw	r30, r24
   124b2:	82 8d       	ldd	r24, Z+26	; 0x1a
   124b4:	88 23       	and	r24, r24
   124b6:	09 f4       	brne	.+2      	; 0x124ba <xQueueCRReceive+0x6a>
   124b8:	55 c0       	rjmp	.+170    	; 0x12564 <xQueueCRReceive+0x114>
		{
			/* Data is available from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
   124ba:	8a 81       	ldd	r24, Y+2	; 0x02
   124bc:	9b 81       	ldd	r25, Y+3	; 0x03
   124be:	fc 01       	movw	r30, r24
   124c0:	26 81       	ldd	r18, Z+6	; 0x06
   124c2:	37 81       	ldd	r19, Z+7	; 0x07
   124c4:	8a 81       	ldd	r24, Y+2	; 0x02
   124c6:	9b 81       	ldd	r25, Y+3	; 0x03
   124c8:	fc 01       	movw	r30, r24
   124ca:	84 8d       	ldd	r24, Z+28	; 0x1c
   124cc:	88 2f       	mov	r24, r24
   124ce:	90 e0       	ldi	r25, 0x00	; 0
   124d0:	28 0f       	add	r18, r24
   124d2:	39 1f       	adc	r19, r25
   124d4:	8a 81       	ldd	r24, Y+2	; 0x02
   124d6:	9b 81       	ldd	r25, Y+3	; 0x03
   124d8:	fc 01       	movw	r30, r24
   124da:	37 83       	std	Z+7, r19	; 0x07
   124dc:	26 83       	std	Z+6, r18	; 0x06
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
   124de:	8a 81       	ldd	r24, Y+2	; 0x02
   124e0:	9b 81       	ldd	r25, Y+3	; 0x03
   124e2:	fc 01       	movw	r30, r24
   124e4:	26 81       	ldd	r18, Z+6	; 0x06
   124e6:	37 81       	ldd	r19, Z+7	; 0x07
   124e8:	8a 81       	ldd	r24, Y+2	; 0x02
   124ea:	9b 81       	ldd	r25, Y+3	; 0x03
   124ec:	fc 01       	movw	r30, r24
   124ee:	82 81       	ldd	r24, Z+2	; 0x02
   124f0:	93 81       	ldd	r25, Z+3	; 0x03
   124f2:	28 17       	cp	r18, r24
   124f4:	39 07       	cpc	r19, r25
   124f6:	50 f0       	brcs	.+20     	; 0x1250c <xQueueCRReceive+0xbc>
			{
				pxQueue->pcReadFrom = pxQueue->pcHead;
   124f8:	8a 81       	ldd	r24, Y+2	; 0x02
   124fa:	9b 81       	ldd	r25, Y+3	; 0x03
   124fc:	fc 01       	movw	r30, r24
   124fe:	20 81       	ld	r18, Z
   12500:	31 81       	ldd	r19, Z+1	; 0x01
   12502:	8a 81       	ldd	r24, Y+2	; 0x02
   12504:	9b 81       	ldd	r25, Y+3	; 0x03
   12506:	fc 01       	movw	r30, r24
   12508:	37 83       	std	Z+7, r19	; 0x07
   1250a:	26 83       	std	Z+6, r18	; 0x06
			}
			--( pxQueue->uxMessagesWaiting );
   1250c:	8a 81       	ldd	r24, Y+2	; 0x02
   1250e:	9b 81       	ldd	r25, Y+3	; 0x03
   12510:	fc 01       	movw	r30, r24
   12512:	82 8d       	ldd	r24, Z+26	; 0x1a
   12514:	28 2f       	mov	r18, r24
   12516:	21 50       	subi	r18, 0x01	; 1
   12518:	8a 81       	ldd	r24, Y+2	; 0x02
   1251a:	9b 81       	ldd	r25, Y+3	; 0x03
   1251c:	fc 01       	movw	r30, r24
   1251e:	22 8f       	std	Z+26, r18	; 0x1a
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   12520:	8a 81       	ldd	r24, Y+2	; 0x02
   12522:	9b 81       	ldd	r25, Y+3	; 0x03
   12524:	fc 01       	movw	r30, r24
   12526:	84 8d       	ldd	r24, Z+28	; 0x1c
   12528:	48 2f       	mov	r20, r24
   1252a:	50 e0       	ldi	r21, 0x00	; 0
   1252c:	8a 81       	ldd	r24, Y+2	; 0x02
   1252e:	9b 81       	ldd	r25, Y+3	; 0x03
   12530:	fc 01       	movw	r30, r24
   12532:	26 81       	ldd	r18, Z+6	; 0x06
   12534:	37 81       	ldd	r19, Z+7	; 0x07
   12536:	8c 81       	ldd	r24, Y+4	; 0x04
   12538:	9d 81       	ldd	r25, Y+5	; 0x05
   1253a:	b9 01       	movw	r22, r18
   1253c:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>

			xReturn = pdPASS;
   12540:	81 e0       	ldi	r24, 0x01	; 1
   12542:	89 83       	std	Y+1, r24	; 0x01

			/* Were any co-routines waiting for space to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   12544:	8a 81       	ldd	r24, Y+2	; 0x02
   12546:	9b 81       	ldd	r25, Y+3	; 0x03
   12548:	fc 01       	movw	r30, r24
   1254a:	80 85       	ldd	r24, Z+8	; 0x08
   1254c:	88 23       	and	r24, r24
   1254e:	59 f0       	breq	.+22     	; 0x12566 <xQueueCRReceive+0x116>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   12550:	8a 81       	ldd	r24, Y+2	; 0x02
   12552:	9b 81       	ldd	r25, Y+3	; 0x03
   12554:	08 96       	adiw	r24, 0x08	; 8
   12556:	0e 94 69 87 	call	0x10ed2	; 0x10ed2 <xCoRoutineRemoveFromEventList>
   1255a:	88 23       	and	r24, r24
   1255c:	21 f0       	breq	.+8      	; 0x12566 <xQueueCRReceive+0x116>
				{
					xReturn = errQUEUE_YIELD;
   1255e:	8b ef       	ldi	r24, 0xFB	; 251
   12560:	89 83       	std	Y+1, r24	; 0x01
   12562:	01 c0       	rjmp	.+2      	; 0x12566 <xQueueCRReceive+0x116>
				}
			}
		}
		else
		{
			xReturn = pdFAIL;
   12564:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portENABLE_INTERRUPTS();
   12566:	78 94       	sei

	return xReturn;
   12568:	89 81       	ldd	r24, Y+1	; 0x01
}
   1256a:	27 96       	adiw	r28, 0x07	; 7
   1256c:	0f b6       	in	r0, 0x3f	; 63
   1256e:	f8 94       	cli
   12570:	de bf       	out	0x3e, r29	; 62
   12572:	0f be       	out	0x3f, r0	; 63
   12574:	cd bf       	out	0x3d, r28	; 61
   12576:	df 91       	pop	r29
   12578:	cf 91       	pop	r28
   1257a:	08 95       	ret

0001257c <xQueueCRSendFromISR>:



#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
{
   1257c:	cf 93       	push	r28
   1257e:	df 93       	push	r29
   12580:	00 d0       	rcall	.+0      	; 0x12582 <xQueueCRSendFromISR+0x6>
   12582:	00 d0       	rcall	.+0      	; 0x12584 <xQueueCRSendFromISR+0x8>
   12584:	1f 92       	push	r1
   12586:	cd b7       	in	r28, 0x3d	; 61
   12588:	de b7       	in	r29, 0x3e	; 62
   1258a:	9a 83       	std	Y+2, r25	; 0x02
   1258c:	89 83       	std	Y+1, r24	; 0x01
   1258e:	7c 83       	std	Y+4, r23	; 0x04
   12590:	6b 83       	std	Y+3, r22	; 0x03
   12592:	4d 83       	std	Y+5, r20	; 0x05
	/* Cannot block within an ISR so if there is no space on the queue then
	exit without doing anything. */
	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   12594:	89 81       	ldd	r24, Y+1	; 0x01
   12596:	9a 81       	ldd	r25, Y+2	; 0x02
   12598:	fc 01       	movw	r30, r24
   1259a:	22 8d       	ldd	r18, Z+26	; 0x1a
   1259c:	89 81       	ldd	r24, Y+1	; 0x01
   1259e:	9a 81       	ldd	r25, Y+2	; 0x02
   125a0:	fc 01       	movw	r30, r24
   125a2:	83 8d       	ldd	r24, Z+27	; 0x1b
   125a4:	28 17       	cp	r18, r24
   125a6:	d0 f4       	brcc	.+52     	; 0x125dc <xQueueCRSendFromISR+0x60>
	{
		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   125a8:	2b 81       	ldd	r18, Y+3	; 0x03
   125aa:	3c 81       	ldd	r19, Y+4	; 0x04
   125ac:	89 81       	ldd	r24, Y+1	; 0x01
   125ae:	9a 81       	ldd	r25, Y+2	; 0x02
   125b0:	40 e0       	ldi	r20, 0x00	; 0
   125b2:	b9 01       	movw	r22, r18
   125b4:	0e 94 e5 8f 	call	0x11fca	; 0x11fca <prvCopyDataToQueue>

		/* We only want to wake one co-routine per ISR, so check that a
		co-routine has not already been woken. */
		if( xCoRoutinePreviouslyWoken == pdFALSE )
   125b8:	8d 81       	ldd	r24, Y+5	; 0x05
   125ba:	88 23       	and	r24, r24
   125bc:	79 f4       	brne	.+30     	; 0x125dc <xQueueCRSendFromISR+0x60>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   125be:	89 81       	ldd	r24, Y+1	; 0x01
   125c0:	9a 81       	ldd	r25, Y+2	; 0x02
   125c2:	fc 01       	movw	r30, r24
   125c4:	81 89       	ldd	r24, Z+17	; 0x11
   125c6:	88 23       	and	r24, r24
   125c8:	49 f0       	breq	.+18     	; 0x125dc <xQueueCRSendFromISR+0x60>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   125ca:	89 81       	ldd	r24, Y+1	; 0x01
   125cc:	9a 81       	ldd	r25, Y+2	; 0x02
   125ce:	41 96       	adiw	r24, 0x11	; 17
   125d0:	0e 94 69 87 	call	0x10ed2	; 0x10ed2 <xCoRoutineRemoveFromEventList>
   125d4:	88 23       	and	r24, r24
   125d6:	11 f0       	breq	.+4      	; 0x125dc <xQueueCRSendFromISR+0x60>
				{
					return pdTRUE;
   125d8:	81 e0       	ldi	r24, 0x01	; 1
   125da:	01 c0       	rjmp	.+2      	; 0x125de <xQueueCRSendFromISR+0x62>
				}
			}
		}
	}

	return xCoRoutinePreviouslyWoken;
   125dc:	8d 81       	ldd	r24, Y+5	; 0x05
}
   125de:	0f 90       	pop	r0
   125e0:	0f 90       	pop	r0
   125e2:	0f 90       	pop	r0
   125e4:	0f 90       	pop	r0
   125e6:	0f 90       	pop	r0
   125e8:	df 91       	pop	r29
   125ea:	cf 91       	pop	r28
   125ec:	08 95       	ret

000125ee <xQueueCRReceiveFromISR>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
{
   125ee:	cf 93       	push	r28
   125f0:	df 93       	push	r29
   125f2:	cd b7       	in	r28, 0x3d	; 61
   125f4:	de b7       	in	r29, 0x3e	; 62
   125f6:	27 97       	sbiw	r28, 0x07	; 7
   125f8:	0f b6       	in	r0, 0x3f	; 63
   125fa:	f8 94       	cli
   125fc:	de bf       	out	0x3e, r29	; 62
   125fe:	0f be       	out	0x3f, r0	; 63
   12600:	cd bf       	out	0x3d, r28	; 61
   12602:	9b 83       	std	Y+3, r25	; 0x03
   12604:	8a 83       	std	Y+2, r24	; 0x02
   12606:	7d 83       	std	Y+5, r23	; 0x05
   12608:	6c 83       	std	Y+4, r22	; 0x04
   1260a:	5f 83       	std	Y+7, r21	; 0x07
   1260c:	4e 83       	std	Y+6, r20	; 0x06
signed portBASE_TYPE xReturn;

	/* We cannot block from an ISR, so check there is data available. If
	not then just leave without doing anything. */
	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   1260e:	8a 81       	ldd	r24, Y+2	; 0x02
   12610:	9b 81       	ldd	r25, Y+3	; 0x03
   12612:	fc 01       	movw	r30, r24
   12614:	82 8d       	ldd	r24, Z+26	; 0x1a
   12616:	88 23       	and	r24, r24
   12618:	09 f4       	brne	.+2      	; 0x1261c <xQueueCRReceiveFromISR+0x2e>
   1261a:	5e c0       	rjmp	.+188    	; 0x126d8 <xQueueCRReceiveFromISR+0xea>
	{
		/* Copy the data from the queue. */
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
   1261c:	8a 81       	ldd	r24, Y+2	; 0x02
   1261e:	9b 81       	ldd	r25, Y+3	; 0x03
   12620:	fc 01       	movw	r30, r24
   12622:	26 81       	ldd	r18, Z+6	; 0x06
   12624:	37 81       	ldd	r19, Z+7	; 0x07
   12626:	8a 81       	ldd	r24, Y+2	; 0x02
   12628:	9b 81       	ldd	r25, Y+3	; 0x03
   1262a:	fc 01       	movw	r30, r24
   1262c:	84 8d       	ldd	r24, Z+28	; 0x1c
   1262e:	88 2f       	mov	r24, r24
   12630:	90 e0       	ldi	r25, 0x00	; 0
   12632:	28 0f       	add	r18, r24
   12634:	39 1f       	adc	r19, r25
   12636:	8a 81       	ldd	r24, Y+2	; 0x02
   12638:	9b 81       	ldd	r25, Y+3	; 0x03
   1263a:	fc 01       	movw	r30, r24
   1263c:	37 83       	std	Z+7, r19	; 0x07
   1263e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
   12640:	8a 81       	ldd	r24, Y+2	; 0x02
   12642:	9b 81       	ldd	r25, Y+3	; 0x03
   12644:	fc 01       	movw	r30, r24
   12646:	26 81       	ldd	r18, Z+6	; 0x06
   12648:	37 81       	ldd	r19, Z+7	; 0x07
   1264a:	8a 81       	ldd	r24, Y+2	; 0x02
   1264c:	9b 81       	ldd	r25, Y+3	; 0x03
   1264e:	fc 01       	movw	r30, r24
   12650:	82 81       	ldd	r24, Z+2	; 0x02
   12652:	93 81       	ldd	r25, Z+3	; 0x03
   12654:	28 17       	cp	r18, r24
   12656:	39 07       	cpc	r19, r25
   12658:	50 f0       	brcs	.+20     	; 0x1266e <xQueueCRReceiveFromISR+0x80>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
   1265a:	8a 81       	ldd	r24, Y+2	; 0x02
   1265c:	9b 81       	ldd	r25, Y+3	; 0x03
   1265e:	fc 01       	movw	r30, r24
   12660:	20 81       	ld	r18, Z
   12662:	31 81       	ldd	r19, Z+1	; 0x01
   12664:	8a 81       	ldd	r24, Y+2	; 0x02
   12666:	9b 81       	ldd	r25, Y+3	; 0x03
   12668:	fc 01       	movw	r30, r24
   1266a:	37 83       	std	Z+7, r19	; 0x07
   1266c:	26 83       	std	Z+6, r18	; 0x06
		}
		--( pxQueue->uxMessagesWaiting );
   1266e:	8a 81       	ldd	r24, Y+2	; 0x02
   12670:	9b 81       	ldd	r25, Y+3	; 0x03
   12672:	fc 01       	movw	r30, r24
   12674:	82 8d       	ldd	r24, Z+26	; 0x1a
   12676:	28 2f       	mov	r18, r24
   12678:	21 50       	subi	r18, 0x01	; 1
   1267a:	8a 81       	ldd	r24, Y+2	; 0x02
   1267c:	9b 81       	ldd	r25, Y+3	; 0x03
   1267e:	fc 01       	movw	r30, r24
   12680:	22 8f       	std	Z+26, r18	; 0x1a
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   12682:	8a 81       	ldd	r24, Y+2	; 0x02
   12684:	9b 81       	ldd	r25, Y+3	; 0x03
   12686:	fc 01       	movw	r30, r24
   12688:	84 8d       	ldd	r24, Z+28	; 0x1c
   1268a:	48 2f       	mov	r20, r24
   1268c:	50 e0       	ldi	r21, 0x00	; 0
   1268e:	8a 81       	ldd	r24, Y+2	; 0x02
   12690:	9b 81       	ldd	r25, Y+3	; 0x03
   12692:	fc 01       	movw	r30, r24
   12694:	26 81       	ldd	r18, Z+6	; 0x06
   12696:	37 81       	ldd	r19, Z+7	; 0x07
   12698:	8c 81       	ldd	r24, Y+4	; 0x04
   1269a:	9d 81       	ldd	r25, Y+5	; 0x05
   1269c:	b9 01       	movw	r22, r18
   1269e:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>

		if( ( *pxCoRoutineWoken ) == pdFALSE )
   126a2:	8e 81       	ldd	r24, Y+6	; 0x06
   126a4:	9f 81       	ldd	r25, Y+7	; 0x07
   126a6:	fc 01       	movw	r30, r24
   126a8:	80 81       	ld	r24, Z
   126aa:	88 23       	and	r24, r24
   126ac:	91 f4       	brne	.+36     	; 0x126d2 <xQueueCRReceiveFromISR+0xe4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   126ae:	8a 81       	ldd	r24, Y+2	; 0x02
   126b0:	9b 81       	ldd	r25, Y+3	; 0x03
   126b2:	fc 01       	movw	r30, r24
   126b4:	80 85       	ldd	r24, Z+8	; 0x08
   126b6:	88 23       	and	r24, r24
   126b8:	61 f0       	breq	.+24     	; 0x126d2 <xQueueCRReceiveFromISR+0xe4>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   126ba:	8a 81       	ldd	r24, Y+2	; 0x02
   126bc:	9b 81       	ldd	r25, Y+3	; 0x03
   126be:	08 96       	adiw	r24, 0x08	; 8
   126c0:	0e 94 69 87 	call	0x10ed2	; 0x10ed2 <xCoRoutineRemoveFromEventList>
   126c4:	88 23       	and	r24, r24
   126c6:	29 f0       	breq	.+10     	; 0x126d2 <xQueueCRReceiveFromISR+0xe4>
				{
					*pxCoRoutineWoken = pdTRUE;
   126c8:	8e 81       	ldd	r24, Y+6	; 0x06
   126ca:	9f 81       	ldd	r25, Y+7	; 0x07
   126cc:	21 e0       	ldi	r18, 0x01	; 1
   126ce:	fc 01       	movw	r30, r24
   126d0:	20 83       	st	Z, r18
				}
			}
		}

		xReturn = pdPASS;
   126d2:	81 e0       	ldi	r24, 0x01	; 1
   126d4:	89 83       	std	Y+1, r24	; 0x01
   126d6:	01 c0       	rjmp	.+2      	; 0x126da <xQueueCRReceiveFromISR+0xec>
	}
	else
	{
		xReturn = pdFAIL;
   126d8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
   126da:	89 81       	ldd	r24, Y+1	; 0x01
}
   126dc:	27 96       	adiw	r28, 0x07	; 7
   126de:	0f b6       	in	r0, 0x3f	; 63
   126e0:	f8 94       	cli
   126e2:	de bf       	out	0x3e, r29	; 62
   126e4:	0f be       	out	0x3f, r0	; 63
   126e6:	cd bf       	out	0x3d, r28	; 61
   126e8:	df 91       	pop	r29
   126ea:	cf 91       	pop	r28
   126ec:	08 95       	ret

000126ee <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
   126ee:	af 92       	push	r10
   126f0:	bf 92       	push	r11
   126f2:	cf 92       	push	r12
   126f4:	df 92       	push	r13
   126f6:	ef 92       	push	r14
   126f8:	ff 92       	push	r15
   126fa:	0f 93       	push	r16
   126fc:	1f 93       	push	r17
   126fe:	cf 93       	push	r28
   12700:	df 93       	push	r29
   12702:	cd b7       	in	r28, 0x3d	; 61
   12704:	de b7       	in	r29, 0x3e	; 62
   12706:	64 97       	sbiw	r28, 0x14	; 20
   12708:	0f b6       	in	r0, 0x3f	; 63
   1270a:	f8 94       	cli
   1270c:	de bf       	out	0x3e, r29	; 62
   1270e:	0f be       	out	0x3f, r0	; 63
   12710:	cd bf       	out	0x3d, r28	; 61
   12712:	9f 83       	std	Y+7, r25	; 0x07
   12714:	8e 83       	std	Y+6, r24	; 0x06
   12716:	79 87       	std	Y+9, r23	; 0x09
   12718:	68 87       	std	Y+8, r22	; 0x08
   1271a:	5b 87       	std	Y+11, r21	; 0x0b
   1271c:	4a 87       	std	Y+10, r20	; 0x0a
   1271e:	3d 87       	std	Y+13, r19	; 0x0d
   12720:	2c 87       	std	Y+12, r18	; 0x0c
   12722:	0e 87       	std	Y+14, r16	; 0x0e
   12724:	f8 8a       	std	Y+16, r15	; 0x10
   12726:	ef 86       	std	Y+15, r14	; 0x0f
   12728:	da 8a       	std	Y+18, r13	; 0x12
   1272a:	c9 8a       	std	Y+17, r12	; 0x11
   1272c:	bc 8a       	std	Y+20, r11	; 0x14
   1272e:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
   12730:	29 89       	ldd	r18, Y+17	; 0x11
   12732:	3a 89       	ldd	r19, Y+18	; 0x12
   12734:	8a 85       	ldd	r24, Y+10	; 0x0a
   12736:	9b 85       	ldd	r25, Y+11	; 0x0b
   12738:	b9 01       	movw	r22, r18
   1273a:	0e 94 23 9b 	call	0x13646	; 0x13646 <prvAllocateTCBAndStack>
   1273e:	9b 83       	std	Y+3, r25	; 0x03
   12740:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
   12742:	8a 81       	ldd	r24, Y+2	; 0x02
   12744:	9b 81       	ldd	r25, Y+3	; 0x03
   12746:	00 97       	sbiw	r24, 0x00	; 0
   12748:	09 f4       	brne	.+2      	; 0x1274c <xTaskGenericCreate+0x5e>
   1274a:	9f c0       	rjmp	.+318    	; 0x1288a <xTaskGenericCreate+0x19c>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
   1274c:	8a 81       	ldd	r24, Y+2	; 0x02
   1274e:	9b 81       	ldd	r25, Y+3	; 0x03
   12750:	fc 01       	movw	r30, r24
   12752:	27 89       	ldd	r18, Z+23	; 0x17
   12754:	30 8d       	ldd	r19, Z+24	; 0x18
   12756:	8a 85       	ldd	r24, Y+10	; 0x0a
   12758:	9b 85       	ldd	r25, Y+11	; 0x0b
   1275a:	01 97       	sbiw	r24, 0x01	; 1
   1275c:	82 0f       	add	r24, r18
   1275e:	93 1f       	adc	r25, r19
   12760:	9d 83       	std	Y+5, r25	; 0x05
   12762:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
   12764:	4a 85       	ldd	r20, Y+10	; 0x0a
   12766:	5b 85       	ldd	r21, Y+11	; 0x0b
   12768:	2b 89       	ldd	r18, Y+19	; 0x13
   1276a:	3c 89       	ldd	r19, Y+20	; 0x14
   1276c:	68 85       	ldd	r22, Y+8	; 0x08
   1276e:	79 85       	ldd	r23, Y+9	; 0x09
   12770:	8a 81       	ldd	r24, Y+2	; 0x02
   12772:	9b 81       	ldd	r25, Y+3	; 0x03
   12774:	8a 01       	movw	r16, r20
   12776:	4e 85       	ldd	r20, Y+14	; 0x0e
   12778:	0e 94 fb 99 	call	0x133f6	; 0x133f6 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   1277c:	4c 85       	ldd	r20, Y+12	; 0x0c
   1277e:	5d 85       	ldd	r21, Y+13	; 0x0d
   12780:	2e 81       	ldd	r18, Y+6	; 0x06
   12782:	3f 81       	ldd	r19, Y+7	; 0x07
   12784:	8c 81       	ldd	r24, Y+4	; 0x04
   12786:	9d 81       	ldd	r25, Y+5	; 0x05
   12788:	b9 01       	movw	r22, r18
   1278a:	0e 94 43 89 	call	0x11286	; 0x11286 <pxPortInitialiseStack>
   1278e:	9c 01       	movw	r18, r24
   12790:	8a 81       	ldd	r24, Y+2	; 0x02
   12792:	9b 81       	ldd	r25, Y+3	; 0x03
   12794:	fc 01       	movw	r30, r24
   12796:	31 83       	std	Z+1, r19	; 0x01
   12798:	20 83       	st	Z, r18
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
   1279a:	8f 85       	ldd	r24, Y+15	; 0x0f
   1279c:	98 89       	ldd	r25, Y+16	; 0x10
   1279e:	00 97       	sbiw	r24, 0x00	; 0
   127a0:	39 f0       	breq	.+14     	; 0x127b0 <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
   127a2:	8f 85       	ldd	r24, Y+15	; 0x0f
   127a4:	98 89       	ldd	r25, Y+16	; 0x10
   127a6:	2a 81       	ldd	r18, Y+2	; 0x02
   127a8:	3b 81       	ldd	r19, Y+3	; 0x03
   127aa:	fc 01       	movw	r30, r24
   127ac:	31 83       	std	Z+1, r19	; 0x01
   127ae:	20 83       	st	Z, r18
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
   127b0:	0f b6       	in	r0, 0x3f	; 63
   127b2:	f8 94       	cli
   127b4:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
   127b6:	80 91 9d 09 	lds	r24, 0x099D
   127ba:	8f 5f       	subi	r24, 0xFF	; 255
   127bc:	80 93 9d 09 	sts	0x099D, r24
			if( pxCurrentTCB == NULL )
   127c0:	80 91 4c 09 	lds	r24, 0x094C
   127c4:	90 91 4d 09 	lds	r25, 0x094D
   127c8:	00 97       	sbiw	r24, 0x00	; 0
   127ca:	69 f4       	brne	.+26     	; 0x127e6 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
   127cc:	8a 81       	ldd	r24, Y+2	; 0x02
   127ce:	9b 81       	ldd	r25, Y+3	; 0x03
   127d0:	90 93 4d 09 	sts	0x094D, r25
   127d4:	80 93 4c 09 	sts	0x094C, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
   127d8:	80 91 9d 09 	lds	r24, 0x099D
   127dc:	81 30       	cpi	r24, 0x01	; 1
   127de:	b1 f4       	brne	.+44     	; 0x1280c <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
   127e0:	0e 94 5c 9a 	call	0x134b8	; 0x134b8 <prvInitialiseTaskLists>
   127e4:	13 c0       	rjmp	.+38     	; 0x1280c <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
   127e6:	80 91 a2 09 	lds	r24, 0x09A2
   127ea:	88 23       	and	r24, r24
   127ec:	79 f4       	brne	.+30     	; 0x1280c <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
   127ee:	80 91 4c 09 	lds	r24, 0x094C
   127f2:	90 91 4d 09 	lds	r25, 0x094D
   127f6:	fc 01       	movw	r30, r24
   127f8:	96 89       	ldd	r25, Z+22	; 0x16
   127fa:	8e 85       	ldd	r24, Y+14	; 0x0e
   127fc:	89 17       	cp	r24, r25
   127fe:	30 f0       	brcs	.+12     	; 0x1280c <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
   12800:	8a 81       	ldd	r24, Y+2	; 0x02
   12802:	9b 81       	ldd	r25, Y+3	; 0x03
   12804:	90 93 4d 09 	sts	0x094D, r25
   12808:	80 93 4c 09 	sts	0x094C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
   1280c:	8a 81       	ldd	r24, Y+2	; 0x02
   1280e:	9b 81       	ldd	r25, Y+3	; 0x03
   12810:	fc 01       	movw	r30, r24
   12812:	96 89       	ldd	r25, Z+22	; 0x16
   12814:	80 91 a0 09 	lds	r24, 0x09A0
   12818:	89 17       	cp	r24, r25
   1281a:	30 f4       	brcc	.+12     	; 0x12828 <xTaskGenericCreate+0x13a>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
   1281c:	8a 81       	ldd	r24, Y+2	; 0x02
   1281e:	9b 81       	ldd	r25, Y+3	; 0x03
   12820:	fc 01       	movw	r30, r24
   12822:	86 89       	ldd	r24, Z+22	; 0x16
   12824:	80 93 a0 09 	sts	0x09A0, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
   12828:	80 91 a7 09 	lds	r24, 0x09A7
   1282c:	8f 5f       	subi	r24, 0xFF	; 255
   1282e:	80 93 a7 09 	sts	0x09A7, r24

			prvAddTaskToReadyQueue( pxNewTCB );
   12832:	8a 81       	ldd	r24, Y+2	; 0x02
   12834:	9b 81       	ldd	r25, Y+3	; 0x03
   12836:	fc 01       	movw	r30, r24
   12838:	96 89       	ldd	r25, Z+22	; 0x16
   1283a:	80 91 a1 09 	lds	r24, 0x09A1
   1283e:	89 17       	cp	r24, r25
   12840:	30 f4       	brcc	.+12     	; 0x1284e <xTaskGenericCreate+0x160>
   12842:	8a 81       	ldd	r24, Y+2	; 0x02
   12844:	9b 81       	ldd	r25, Y+3	; 0x03
   12846:	fc 01       	movw	r30, r24
   12848:	86 89       	ldd	r24, Z+22	; 0x16
   1284a:	80 93 a1 09 	sts	0x09A1, r24
   1284e:	8a 81       	ldd	r24, Y+2	; 0x02
   12850:	9b 81       	ldd	r25, Y+3	; 0x03
   12852:	ac 01       	movw	r20, r24
   12854:	4e 5f       	subi	r20, 0xFE	; 254
   12856:	5f 4f       	sbci	r21, 0xFF	; 255
   12858:	8a 81       	ldd	r24, Y+2	; 0x02
   1285a:	9b 81       	ldd	r25, Y+3	; 0x03
   1285c:	fc 01       	movw	r30, r24
   1285e:	86 89       	ldd	r24, Z+22	; 0x16
   12860:	28 2f       	mov	r18, r24
   12862:	30 e0       	ldi	r19, 0x00	; 0
   12864:	c9 01       	movw	r24, r18
   12866:	88 0f       	add	r24, r24
   12868:	99 1f       	adc	r25, r25
   1286a:	88 0f       	add	r24, r24
   1286c:	99 1f       	adc	r25, r25
   1286e:	88 0f       	add	r24, r24
   12870:	99 1f       	adc	r25, r25
   12872:	82 0f       	add	r24, r18
   12874:	93 1f       	adc	r25, r19
   12876:	82 5b       	subi	r24, 0xB2	; 178
   12878:	96 4f       	sbci	r25, 0xF6	; 246
   1287a:	ba 01       	movw	r22, r20
   1287c:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>

			xReturn = pdPASS;
   12880:	81 e0       	ldi	r24, 0x01	; 1
   12882:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
   12884:	0f 90       	pop	r0
   12886:	0f be       	out	0x3f, r0	; 63
   12888:	02 c0       	rjmp	.+4      	; 0x1288e <xTaskGenericCreate+0x1a0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   1288a:	8f ef       	ldi	r24, 0xFF	; 255
   1288c:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
   1288e:	89 81       	ldd	r24, Y+1	; 0x01
   12890:	81 30       	cpi	r24, 0x01	; 1
   12892:	79 f4       	brne	.+30     	; 0x128b2 <xTaskGenericCreate+0x1c4>
	{
		if( xSchedulerRunning != pdFALSE )
   12894:	80 91 a2 09 	lds	r24, 0x09A2
   12898:	88 23       	and	r24, r24
   1289a:	59 f0       	breq	.+22     	; 0x128b2 <xTaskGenericCreate+0x1c4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
   1289c:	80 91 4c 09 	lds	r24, 0x094C
   128a0:	90 91 4d 09 	lds	r25, 0x094D
   128a4:	fc 01       	movw	r30, r24
   128a6:	96 89       	ldd	r25, Z+22	; 0x16
   128a8:	8e 85       	ldd	r24, Y+14	; 0x0e
   128aa:	98 17       	cp	r25, r24
   128ac:	10 f4       	brcc	.+4      	; 0x128b2 <xTaskGenericCreate+0x1c4>
			{
				portYIELD_WITHIN_API();
   128ae:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
			}
		}
	}

	return xReturn;
   128b2:	89 81       	ldd	r24, Y+1	; 0x01
}
   128b4:	64 96       	adiw	r28, 0x14	; 20
   128b6:	0f b6       	in	r0, 0x3f	; 63
   128b8:	f8 94       	cli
   128ba:	de bf       	out	0x3e, r29	; 62
   128bc:	0f be       	out	0x3f, r0	; 63
   128be:	cd bf       	out	0x3d, r28	; 61
   128c0:	df 91       	pop	r29
   128c2:	cf 91       	pop	r28
   128c4:	1f 91       	pop	r17
   128c6:	0f 91       	pop	r16
   128c8:	ff 90       	pop	r15
   128ca:	ef 90       	pop	r14
   128cc:	df 90       	pop	r13
   128ce:	cf 90       	pop	r12
   128d0:	bf 90       	pop	r11
   128d2:	af 90       	pop	r10
   128d4:	08 95       	ret

000128d6 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
   128d6:	cf 93       	push	r28
   128d8:	df 93       	push	r29
   128da:	00 d0       	rcall	.+0      	; 0x128dc <vTaskDelete+0x6>
   128dc:	00 d0       	rcall	.+0      	; 0x128de <vTaskDelete+0x8>
   128de:	cd b7       	in	r28, 0x3d	; 61
   128e0:	de b7       	in	r29, 0x3e	; 62
   128e2:	9c 83       	std	Y+4, r25	; 0x04
   128e4:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
   128e6:	0f b6       	in	r0, 0x3f	; 63
   128e8:	f8 94       	cli
   128ea:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
   128ec:	80 91 4c 09 	lds	r24, 0x094C
   128f0:	90 91 4d 09 	lds	r25, 0x094D
   128f4:	2b 81       	ldd	r18, Y+3	; 0x03
   128f6:	3c 81       	ldd	r19, Y+4	; 0x04
   128f8:	28 17       	cp	r18, r24
   128fa:	39 07       	cpc	r19, r25
   128fc:	11 f4       	brne	.+4      	; 0x12902 <vTaskDelete+0x2c>
			{
				pxTaskToDelete = NULL;
   128fe:	1c 82       	std	Y+4, r1	; 0x04
   12900:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
   12902:	8b 81       	ldd	r24, Y+3	; 0x03
   12904:	9c 81       	ldd	r25, Y+4	; 0x04
   12906:	00 97       	sbiw	r24, 0x00	; 0
   12908:	29 f4       	brne	.+10     	; 0x12914 <vTaskDelete+0x3e>
   1290a:	80 91 4c 09 	lds	r24, 0x094C
   1290e:	90 91 4d 09 	lds	r25, 0x094D
   12912:	02 c0       	rjmp	.+4      	; 0x12918 <vTaskDelete+0x42>
   12914:	8b 81       	ldd	r24, Y+3	; 0x03
   12916:	9c 81       	ldd	r25, Y+4	; 0x04
   12918:	9a 83       	std	Y+2, r25	; 0x02
   1291a:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   1291c:	89 81       	ldd	r24, Y+1	; 0x01
   1291e:	9a 81       	ldd	r25, Y+2	; 0x02
   12920:	02 96       	adiw	r24, 0x02	; 2
   12922:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
   12926:	89 81       	ldd	r24, Y+1	; 0x01
   12928:	9a 81       	ldd	r25, Y+2	; 0x02
   1292a:	fc 01       	movw	r30, r24
   1292c:	84 89       	ldd	r24, Z+20	; 0x14
   1292e:	95 89       	ldd	r25, Z+21	; 0x15
   12930:	00 97       	sbiw	r24, 0x00	; 0
   12932:	29 f0       	breq	.+10     	; 0x1293e <vTaskDelete+0x68>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
   12934:	89 81       	ldd	r24, Y+1	; 0x01
   12936:	9a 81       	ldd	r25, Y+2	; 0x02
   12938:	0c 96       	adiw	r24, 0x0c	; 12
   1293a:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
   1293e:	89 81       	ldd	r24, Y+1	; 0x01
   12940:	9a 81       	ldd	r25, Y+2	; 0x02
   12942:	02 96       	adiw	r24, 0x02	; 2
   12944:	bc 01       	movw	r22, r24
   12946:	81 e9       	ldi	r24, 0x91	; 145
   12948:	99 e0       	ldi	r25, 0x09	; 9
   1294a:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
   1294e:	80 91 9a 09 	lds	r24, 0x099A
   12952:	8f 5f       	subi	r24, 0xFF	; 255
   12954:	80 93 9a 09 	sts	0x099A, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
   12958:	80 91 a7 09 	lds	r24, 0x09A7
   1295c:	8f 5f       	subi	r24, 0xFF	; 255
   1295e:	80 93 a7 09 	sts	0x09A7, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
   12962:	0f 90       	pop	r0
   12964:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
   12966:	80 91 a2 09 	lds	r24, 0x09A2
   1296a:	88 23       	and	r24, r24
   1296c:	31 f0       	breq	.+12     	; 0x1297a <vTaskDelete+0xa4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
   1296e:	8b 81       	ldd	r24, Y+3	; 0x03
   12970:	9c 81       	ldd	r25, Y+4	; 0x04
   12972:	00 97       	sbiw	r24, 0x00	; 0
   12974:	11 f4       	brne	.+4      	; 0x1297a <vTaskDelete+0xa4>
			{
				portYIELD_WITHIN_API();
   12976:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
			}
		}
	}
   1297a:	0f 90       	pop	r0
   1297c:	0f 90       	pop	r0
   1297e:	0f 90       	pop	r0
   12980:	0f 90       	pop	r0
   12982:	df 91       	pop	r29
   12984:	cf 91       	pop	r28
   12986:	08 95       	ret

00012988 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
   12988:	cf 93       	push	r28
   1298a:	df 93       	push	r29
   1298c:	cd b7       	in	r28, 0x3d	; 61
   1298e:	de b7       	in	r29, 0x3e	; 62
   12990:	28 97       	sbiw	r28, 0x08	; 8
   12992:	0f b6       	in	r0, 0x3f	; 63
   12994:	f8 94       	cli
   12996:	de bf       	out	0x3e, r29	; 62
   12998:	0f be       	out	0x3f, r0	; 63
   1299a:	cd bf       	out	0x3d, r28	; 61
   1299c:	9e 83       	std	Y+6, r25	; 0x06
   1299e:	8d 83       	std	Y+5, r24	; 0x05
   129a0:	78 87       	std	Y+8, r23	; 0x08
   129a2:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
   129a4:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
   129a6:	0e 94 a1 96 	call	0x12d42	; 0x12d42 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   129aa:	8d 81       	ldd	r24, Y+5	; 0x05
   129ac:	9e 81       	ldd	r25, Y+6	; 0x06
   129ae:	fc 01       	movw	r30, r24
   129b0:	20 81       	ld	r18, Z
   129b2:	31 81       	ldd	r19, Z+1	; 0x01
   129b4:	8f 81       	ldd	r24, Y+7	; 0x07
   129b6:	98 85       	ldd	r25, Y+8	; 0x08
   129b8:	82 0f       	add	r24, r18
   129ba:	93 1f       	adc	r25, r19
   129bc:	9b 83       	std	Y+3, r25	; 0x03
   129be:	8a 83       	std	Y+2, r24	; 0x02

			if( xTickCount < *pxPreviousWakeTime )
   129c0:	8d 81       	ldd	r24, Y+5	; 0x05
   129c2:	9e 81       	ldd	r25, Y+6	; 0x06
   129c4:	fc 01       	movw	r30, r24
   129c6:	20 81       	ld	r18, Z
   129c8:	31 81       	ldd	r19, Z+1	; 0x01
   129ca:	80 91 9e 09 	lds	r24, 0x099E
   129ce:	90 91 9f 09 	lds	r25, 0x099F
   129d2:	82 17       	cp	r24, r18
   129d4:	93 07       	cpc	r25, r19
   129d6:	b0 f4       	brcc	.+44     	; 0x12a04 <vTaskDelayUntil+0x7c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
   129d8:	8d 81       	ldd	r24, Y+5	; 0x05
   129da:	9e 81       	ldd	r25, Y+6	; 0x06
   129dc:	fc 01       	movw	r30, r24
   129de:	20 81       	ld	r18, Z
   129e0:	31 81       	ldd	r19, Z+1	; 0x01
   129e2:	8a 81       	ldd	r24, Y+2	; 0x02
   129e4:	9b 81       	ldd	r25, Y+3	; 0x03
   129e6:	82 17       	cp	r24, r18
   129e8:	93 07       	cpc	r25, r19
   129ea:	08 f5       	brcc	.+66     	; 0x12a2e <vTaskDelayUntil+0xa6>
   129ec:	80 91 9e 09 	lds	r24, 0x099E
   129f0:	90 91 9f 09 	lds	r25, 0x099F
   129f4:	2a 81       	ldd	r18, Y+2	; 0x02
   129f6:	3b 81       	ldd	r19, Y+3	; 0x03
   129f8:	82 17       	cp	r24, r18
   129fa:	93 07       	cpc	r25, r19
   129fc:	c0 f4       	brcc	.+48     	; 0x12a2e <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
   129fe:	81 e0       	ldi	r24, 0x01	; 1
   12a00:	89 83       	std	Y+1, r24	; 0x01
   12a02:	15 c0       	rjmp	.+42     	; 0x12a2e <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
   12a04:	8d 81       	ldd	r24, Y+5	; 0x05
   12a06:	9e 81       	ldd	r25, Y+6	; 0x06
   12a08:	fc 01       	movw	r30, r24
   12a0a:	20 81       	ld	r18, Z
   12a0c:	31 81       	ldd	r19, Z+1	; 0x01
   12a0e:	8a 81       	ldd	r24, Y+2	; 0x02
   12a10:	9b 81       	ldd	r25, Y+3	; 0x03
   12a12:	82 17       	cp	r24, r18
   12a14:	93 07       	cpc	r25, r19
   12a16:	48 f0       	brcs	.+18     	; 0x12a2a <vTaskDelayUntil+0xa2>
   12a18:	80 91 9e 09 	lds	r24, 0x099E
   12a1c:	90 91 9f 09 	lds	r25, 0x099F
   12a20:	2a 81       	ldd	r18, Y+2	; 0x02
   12a22:	3b 81       	ldd	r19, Y+3	; 0x03
   12a24:	82 17       	cp	r24, r18
   12a26:	93 07       	cpc	r25, r19
   12a28:	10 f4       	brcc	.+4      	; 0x12a2e <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
   12a2a:	81 e0       	ldi	r24, 0x01	; 1
   12a2c:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
   12a2e:	8d 81       	ldd	r24, Y+5	; 0x05
   12a30:	9e 81       	ldd	r25, Y+6	; 0x06
   12a32:	2a 81       	ldd	r18, Y+2	; 0x02
   12a34:	3b 81       	ldd	r19, Y+3	; 0x03
   12a36:	fc 01       	movw	r30, r24
   12a38:	31 83       	std	Z+1, r19	; 0x01
   12a3a:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
   12a3c:	89 81       	ldd	r24, Y+1	; 0x01
   12a3e:	88 23       	and	r24, r24
   12a40:	59 f0       	breq	.+22     	; 0x12a58 <vTaskDelayUntil+0xd0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   12a42:	80 91 4c 09 	lds	r24, 0x094C
   12a46:	90 91 4d 09 	lds	r25, 0x094D
   12a4a:	02 96       	adiw	r24, 0x02	; 2
   12a4c:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
   12a50:	8a 81       	ldd	r24, Y+2	; 0x02
   12a52:	9b 81       	ldd	r25, Y+3	; 0x03
   12a54:	0e 94 d9 9a 	call	0x135b2	; 0x135b2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
   12a58:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>
   12a5c:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   12a5e:	8c 81       	ldd	r24, Y+4	; 0x04
   12a60:	88 23       	and	r24, r24
   12a62:	11 f4       	brne	.+4      	; 0x12a68 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
   12a64:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
		}
	}
   12a68:	28 96       	adiw	r28, 0x08	; 8
   12a6a:	0f b6       	in	r0, 0x3f	; 63
   12a6c:	f8 94       	cli
   12a6e:	de bf       	out	0x3e, r29	; 62
   12a70:	0f be       	out	0x3f, r0	; 63
   12a72:	cd bf       	out	0x3d, r28	; 61
   12a74:	df 91       	pop	r29
   12a76:	cf 91       	pop	r28
   12a78:	08 95       	ret

00012a7a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
   12a7a:	cf 93       	push	r28
   12a7c:	df 93       	push	r29
   12a7e:	00 d0       	rcall	.+0      	; 0x12a80 <vTaskDelay+0x6>
   12a80:	00 d0       	rcall	.+0      	; 0x12a82 <vTaskDelay+0x8>
   12a82:	1f 92       	push	r1
   12a84:	cd b7       	in	r28, 0x3d	; 61
   12a86:	de b7       	in	r29, 0x3e	; 62
   12a88:	9d 83       	std	Y+5, r25	; 0x05
   12a8a:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   12a8c:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
   12a8e:	8c 81       	ldd	r24, Y+4	; 0x04
   12a90:	9d 81       	ldd	r25, Y+5	; 0x05
   12a92:	00 97       	sbiw	r24, 0x00	; 0
   12a94:	d1 f0       	breq	.+52     	; 0x12aca <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
   12a96:	0e 94 a1 96 	call	0x12d42	; 0x12d42 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
   12a9a:	20 91 9e 09 	lds	r18, 0x099E
   12a9e:	30 91 9f 09 	lds	r19, 0x099F
   12aa2:	8c 81       	ldd	r24, Y+4	; 0x04
   12aa4:	9d 81       	ldd	r25, Y+5	; 0x05
   12aa6:	82 0f       	add	r24, r18
   12aa8:	93 1f       	adc	r25, r19
   12aaa:	9b 83       	std	Y+3, r25	; 0x03
   12aac:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   12aae:	80 91 4c 09 	lds	r24, 0x094C
   12ab2:	90 91 4d 09 	lds	r25, 0x094D
   12ab6:	02 96       	adiw	r24, 0x02	; 2
   12ab8:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
   12abc:	8a 81       	ldd	r24, Y+2	; 0x02
   12abe:	9b 81       	ldd	r25, Y+3	; 0x03
   12ac0:	0e 94 d9 9a 	call	0x135b2	; 0x135b2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
   12ac4:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>
   12ac8:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   12aca:	89 81       	ldd	r24, Y+1	; 0x01
   12acc:	88 23       	and	r24, r24
   12ace:	11 f4       	brne	.+4      	; 0x12ad4 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
   12ad0:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
		}
	}
   12ad4:	0f 90       	pop	r0
   12ad6:	0f 90       	pop	r0
   12ad8:	0f 90       	pop	r0
   12ada:	0f 90       	pop	r0
   12adc:	0f 90       	pop	r0
   12ade:	df 91       	pop	r29
   12ae0:	cf 91       	pop	r28
   12ae2:	08 95       	ret

00012ae4 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
   12ae4:	cf 93       	push	r28
   12ae6:	df 93       	push	r29
   12ae8:	00 d0       	rcall	.+0      	; 0x12aea <uxTaskPriorityGet+0x6>
   12aea:	00 d0       	rcall	.+0      	; 0x12aec <uxTaskPriorityGet+0x8>
   12aec:	1f 92       	push	r1
   12aee:	cd b7       	in	r28, 0x3d	; 61
   12af0:	de b7       	in	r29, 0x3e	; 62
   12af2:	9d 83       	std	Y+5, r25	; 0x05
   12af4:	8c 83       	std	Y+4, r24	; 0x04
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
   12af6:	0f b6       	in	r0, 0x3f	; 63
   12af8:	f8 94       	cli
   12afa:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
   12afc:	8c 81       	ldd	r24, Y+4	; 0x04
   12afe:	9d 81       	ldd	r25, Y+5	; 0x05
   12b00:	00 97       	sbiw	r24, 0x00	; 0
   12b02:	29 f4       	brne	.+10     	; 0x12b0e <uxTaskPriorityGet+0x2a>
   12b04:	80 91 4c 09 	lds	r24, 0x094C
   12b08:	90 91 4d 09 	lds	r25, 0x094D
   12b0c:	02 c0       	rjmp	.+4      	; 0x12b12 <uxTaskPriorityGet+0x2e>
   12b0e:	8c 81       	ldd	r24, Y+4	; 0x04
   12b10:	9d 81       	ldd	r25, Y+5	; 0x05
   12b12:	9a 83       	std	Y+2, r25	; 0x02
   12b14:	89 83       	std	Y+1, r24	; 0x01
			uxReturn = pxTCB->uxPriority;
   12b16:	89 81       	ldd	r24, Y+1	; 0x01
   12b18:	9a 81       	ldd	r25, Y+2	; 0x02
   12b1a:	fc 01       	movw	r30, r24
   12b1c:	86 89       	ldd	r24, Z+22	; 0x16
   12b1e:	8b 83       	std	Y+3, r24	; 0x03
		}
		taskEXIT_CRITICAL();
   12b20:	0f 90       	pop	r0
   12b22:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
   12b24:	8b 81       	ldd	r24, Y+3	; 0x03
	}
   12b26:	0f 90       	pop	r0
   12b28:	0f 90       	pop	r0
   12b2a:	0f 90       	pop	r0
   12b2c:	0f 90       	pop	r0
   12b2e:	0f 90       	pop	r0
   12b30:	df 91       	pop	r29
   12b32:	cf 91       	pop	r28
   12b34:	08 95       	ret

00012b36 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
   12b36:	cf 93       	push	r28
   12b38:	df 93       	push	r29
   12b3a:	cd b7       	in	r28, 0x3d	; 61
   12b3c:	de b7       	in	r29, 0x3e	; 62
   12b3e:	28 97       	sbiw	r28, 0x08	; 8
   12b40:	0f b6       	in	r0, 0x3f	; 63
   12b42:	f8 94       	cli
   12b44:	de bf       	out	0x3e, r29	; 62
   12b46:	0f be       	out	0x3f, r0	; 63
   12b48:	cd bf       	out	0x3d, r28	; 61
   12b4a:	9f 83       	std	Y+7, r25	; 0x07
   12b4c:	8e 83       	std	Y+6, r24	; 0x06
   12b4e:	68 87       	std	Y+8, r22	; 0x08
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
	portBASE_TYPE xYieldRequired = pdFALSE;
   12b50:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
   12b52:	88 85       	ldd	r24, Y+8	; 0x08
   12b54:	84 30       	cpi	r24, 0x04	; 4
   12b56:	10 f0       	brcs	.+4      	; 0x12b5c <vTaskPrioritySet+0x26>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
   12b58:	83 e0       	ldi	r24, 0x03	; 3
   12b5a:	88 87       	std	Y+8, r24	; 0x08
		}

		taskENTER_CRITICAL();
   12b5c:	0f b6       	in	r0, 0x3f	; 63
   12b5e:	f8 94       	cli
   12b60:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
   12b62:	80 91 4c 09 	lds	r24, 0x094C
   12b66:	90 91 4d 09 	lds	r25, 0x094D
   12b6a:	2e 81       	ldd	r18, Y+6	; 0x06
   12b6c:	3f 81       	ldd	r19, Y+7	; 0x07
   12b6e:	28 17       	cp	r18, r24
   12b70:	39 07       	cpc	r19, r25
   12b72:	11 f4       	brne	.+4      	; 0x12b78 <vTaskPrioritySet+0x42>
			{
				pxTask = NULL;
   12b74:	1f 82       	std	Y+7, r1	; 0x07
   12b76:	1e 82       	std	Y+6, r1	; 0x06
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
   12b78:	8e 81       	ldd	r24, Y+6	; 0x06
   12b7a:	9f 81       	ldd	r25, Y+7	; 0x07
   12b7c:	00 97       	sbiw	r24, 0x00	; 0
   12b7e:	29 f4       	brne	.+10     	; 0x12b8a <vTaskPrioritySet+0x54>
   12b80:	80 91 4c 09 	lds	r24, 0x094C
   12b84:	90 91 4d 09 	lds	r25, 0x094D
   12b88:	02 c0       	rjmp	.+4      	; 0x12b8e <vTaskPrioritySet+0x58>
   12b8a:	8e 81       	ldd	r24, Y+6	; 0x06
   12b8c:	9f 81       	ldd	r25, Y+7	; 0x07
   12b8e:	9b 83       	std	Y+3, r25	; 0x03
   12b90:	8a 83       	std	Y+2, r24	; 0x02

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
   12b92:	8a 81       	ldd	r24, Y+2	; 0x02
   12b94:	9b 81       	ldd	r25, Y+3	; 0x03
   12b96:	fc 01       	movw	r30, r24
   12b98:	81 a1       	ldd	r24, Z+33	; 0x21
   12b9a:	8c 83       	std	Y+4, r24	; 0x04
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
   12b9c:	9c 81       	ldd	r25, Y+4	; 0x04
   12b9e:	88 85       	ldd	r24, Y+8	; 0x08
   12ba0:	98 17       	cp	r25, r24
   12ba2:	09 f4       	brne	.+2      	; 0x12ba6 <vTaskPrioritySet+0x70>
   12ba4:	7d c0       	rjmp	.+250    	; 0x12ca0 <vTaskPrioritySet+0x16a>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
   12ba6:	98 85       	ldd	r25, Y+8	; 0x08
   12ba8:	8c 81       	ldd	r24, Y+4	; 0x04
   12baa:	89 17       	cp	r24, r25
   12bac:	38 f4       	brcc	.+14     	; 0x12bbc <vTaskPrioritySet+0x86>
				{
					if( pxTask != NULL )
   12bae:	8e 81       	ldd	r24, Y+6	; 0x06
   12bb0:	9f 81       	ldd	r25, Y+7	; 0x07
   12bb2:	00 97       	sbiw	r24, 0x00	; 0
   12bb4:	49 f0       	breq	.+18     	; 0x12bc8 <vTaskPrioritySet+0x92>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
   12bb6:	81 e0       	ldi	r24, 0x01	; 1
   12bb8:	89 83       	std	Y+1, r24	; 0x01
   12bba:	06 c0       	rjmp	.+12     	; 0x12bc8 <vTaskPrioritySet+0x92>
					}
				}
				else if( pxTask == NULL )
   12bbc:	8e 81       	ldd	r24, Y+6	; 0x06
   12bbe:	9f 81       	ldd	r25, Y+7	; 0x07
   12bc0:	00 97       	sbiw	r24, 0x00	; 0
   12bc2:	11 f4       	brne	.+4      	; 0x12bc8 <vTaskPrioritySet+0x92>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
   12bc4:	81 e0       	ldi	r24, 0x01	; 1
   12bc6:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   12bc8:	8a 81       	ldd	r24, Y+2	; 0x02
   12bca:	9b 81       	ldd	r25, Y+3	; 0x03
   12bcc:	fc 01       	movw	r30, r24
   12bce:	86 89       	ldd	r24, Z+22	; 0x16
   12bd0:	8d 83       	std	Y+5, r24	; 0x05

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   12bd2:	8a 81       	ldd	r24, Y+2	; 0x02
   12bd4:	9b 81       	ldd	r25, Y+3	; 0x03
   12bd6:	fc 01       	movw	r30, r24
   12bd8:	21 a1       	ldd	r18, Z+33	; 0x21
   12bda:	8a 81       	ldd	r24, Y+2	; 0x02
   12bdc:	9b 81       	ldd	r25, Y+3	; 0x03
   12bde:	fc 01       	movw	r30, r24
   12be0:	86 89       	ldd	r24, Z+22	; 0x16
   12be2:	28 17       	cp	r18, r24
   12be4:	29 f4       	brne	.+10     	; 0x12bf0 <vTaskPrioritySet+0xba>
					{
						pxTCB->uxPriority = uxNewPriority;
   12be6:	8a 81       	ldd	r24, Y+2	; 0x02
   12be8:	9b 81       	ldd	r25, Y+3	; 0x03
   12bea:	28 85       	ldd	r18, Y+8	; 0x08
   12bec:	fc 01       	movw	r30, r24
   12bee:	26 8b       	std	Z+22, r18	; 0x16
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
   12bf0:	8a 81       	ldd	r24, Y+2	; 0x02
   12bf2:	9b 81       	ldd	r25, Y+3	; 0x03
   12bf4:	28 85       	ldd	r18, Y+8	; 0x08
   12bf6:	fc 01       	movw	r30, r24
   12bf8:	21 a3       	std	Z+33, r18	; 0x21
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
   12bfa:	88 85       	ldd	r24, Y+8	; 0x08
   12bfc:	88 2f       	mov	r24, r24
   12bfe:	90 e0       	ldi	r25, 0x00	; 0
   12c00:	24 e0       	ldi	r18, 0x04	; 4
   12c02:	30 e0       	ldi	r19, 0x00	; 0
   12c04:	28 1b       	sub	r18, r24
   12c06:	39 0b       	sbc	r19, r25
   12c08:	8a 81       	ldd	r24, Y+2	; 0x02
   12c0a:	9b 81       	ldd	r25, Y+3	; 0x03
   12c0c:	fc 01       	movw	r30, r24
   12c0e:	35 87       	std	Z+13, r19	; 0x0d
   12c10:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
   12c12:	8a 81       	ldd	r24, Y+2	; 0x02
   12c14:	9b 81       	ldd	r25, Y+3	; 0x03
   12c16:	fc 01       	movw	r30, r24
   12c18:	42 85       	ldd	r20, Z+10	; 0x0a
   12c1a:	53 85       	ldd	r21, Z+11	; 0x0b
   12c1c:	8c 81       	ldd	r24, Y+4	; 0x04
   12c1e:	28 2f       	mov	r18, r24
   12c20:	30 e0       	ldi	r19, 0x00	; 0
   12c22:	c9 01       	movw	r24, r18
   12c24:	88 0f       	add	r24, r24
   12c26:	99 1f       	adc	r25, r25
   12c28:	88 0f       	add	r24, r24
   12c2a:	99 1f       	adc	r25, r25
   12c2c:	88 0f       	add	r24, r24
   12c2e:	99 1f       	adc	r25, r25
   12c30:	82 0f       	add	r24, r18
   12c32:	93 1f       	adc	r25, r19
   12c34:	82 5b       	subi	r24, 0xB2	; 178
   12c36:	96 4f       	sbci	r25, 0xF6	; 246
   12c38:	48 17       	cp	r20, r24
   12c3a:	59 07       	cpc	r21, r25
   12c3c:	61 f5       	brne	.+88     	; 0x12c96 <vTaskPrioritySet+0x160>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   12c3e:	8a 81       	ldd	r24, Y+2	; 0x02
   12c40:	9b 81       	ldd	r25, Y+3	; 0x03
   12c42:	02 96       	adiw	r24, 0x02	; 2
   12c44:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
					}
					prvAddTaskToReadyQueue( pxTCB );
   12c48:	8a 81       	ldd	r24, Y+2	; 0x02
   12c4a:	9b 81       	ldd	r25, Y+3	; 0x03
   12c4c:	fc 01       	movw	r30, r24
   12c4e:	96 89       	ldd	r25, Z+22	; 0x16
   12c50:	80 91 a1 09 	lds	r24, 0x09A1
   12c54:	89 17       	cp	r24, r25
   12c56:	30 f4       	brcc	.+12     	; 0x12c64 <vTaskPrioritySet+0x12e>
   12c58:	8a 81       	ldd	r24, Y+2	; 0x02
   12c5a:	9b 81       	ldd	r25, Y+3	; 0x03
   12c5c:	fc 01       	movw	r30, r24
   12c5e:	86 89       	ldd	r24, Z+22	; 0x16
   12c60:	80 93 a1 09 	sts	0x09A1, r24
   12c64:	8a 81       	ldd	r24, Y+2	; 0x02
   12c66:	9b 81       	ldd	r25, Y+3	; 0x03
   12c68:	ac 01       	movw	r20, r24
   12c6a:	4e 5f       	subi	r20, 0xFE	; 254
   12c6c:	5f 4f       	sbci	r21, 0xFF	; 255
   12c6e:	8a 81       	ldd	r24, Y+2	; 0x02
   12c70:	9b 81       	ldd	r25, Y+3	; 0x03
   12c72:	fc 01       	movw	r30, r24
   12c74:	86 89       	ldd	r24, Z+22	; 0x16
   12c76:	28 2f       	mov	r18, r24
   12c78:	30 e0       	ldi	r19, 0x00	; 0
   12c7a:	c9 01       	movw	r24, r18
   12c7c:	88 0f       	add	r24, r24
   12c7e:	99 1f       	adc	r25, r25
   12c80:	88 0f       	add	r24, r24
   12c82:	99 1f       	adc	r25, r25
   12c84:	88 0f       	add	r24, r24
   12c86:	99 1f       	adc	r25, r25
   12c88:	82 0f       	add	r24, r18
   12c8a:	93 1f       	adc	r25, r19
   12c8c:	82 5b       	subi	r24, 0xB2	; 178
   12c8e:	96 4f       	sbci	r25, 0xF6	; 246
   12c90:	ba 01       	movw	r22, r20
   12c92:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
   12c96:	89 81       	ldd	r24, Y+1	; 0x01
   12c98:	81 30       	cpi	r24, 0x01	; 1
   12c9a:	11 f4       	brne	.+4      	; 0x12ca0 <vTaskPrioritySet+0x16a>
				{
					portYIELD_WITHIN_API();
   12c9c:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
				}
			}
		}
		taskEXIT_CRITICAL();
   12ca0:	0f 90       	pop	r0
   12ca2:	0f be       	out	0x3f, r0	; 63

		/* Remove compiler warning about unused parameter when the port
		optimised task selection is not being used. */
		( void ) uxPriorityUsedOnEntry;
	}
   12ca4:	28 96       	adiw	r28, 0x08	; 8
   12ca6:	0f b6       	in	r0, 0x3f	; 63
   12ca8:	f8 94       	cli
   12caa:	de bf       	out	0x3e, r29	; 62
   12cac:	0f be       	out	0x3f, r0	; 63
   12cae:	cd bf       	out	0x3d, r28	; 61
   12cb0:	df 91       	pop	r29
   12cb2:	cf 91       	pop	r28
   12cb4:	08 95       	ret

00012cb6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
   12cb6:	af 92       	push	r10
   12cb8:	bf 92       	push	r11
   12cba:	cf 92       	push	r12
   12cbc:	df 92       	push	r13
   12cbe:	ef 92       	push	r14
   12cc0:	ff 92       	push	r15
   12cc2:	0f 93       	push	r16
   12cc4:	cf 93       	push	r28
   12cc6:	df 93       	push	r29
   12cc8:	1f 92       	push	r1
   12cca:	cd b7       	in	r28, 0x3d	; 61
   12ccc:	de b7       	in	r29, 0x3e	; 62
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
   12cce:	a1 2c       	mov	r10, r1
   12cd0:	b1 2c       	mov	r11, r1
   12cd2:	c1 2c       	mov	r12, r1
   12cd4:	d1 2c       	mov	r13, r1
   12cd6:	0f 2e       	mov	r0, r31
   12cd8:	fb e9       	ldi	r31, 0x9B	; 155
   12cda:	ef 2e       	mov	r14, r31
   12cdc:	f9 e0       	ldi	r31, 0x09	; 9
   12cde:	ff 2e       	mov	r15, r31
   12ce0:	f0 2d       	mov	r31, r0
   12ce2:	00 e0       	ldi	r16, 0x00	; 0
   12ce4:	20 e0       	ldi	r18, 0x00	; 0
   12ce6:	30 e0       	ldi	r19, 0x00	; 0
   12ce8:	45 e5       	ldi	r20, 0x55	; 85
   12cea:	50 e0       	ldi	r21, 0x00	; 0
   12cec:	6f e8       	ldi	r22, 0x8F	; 143
   12cee:	74 e0       	ldi	r23, 0x04	; 4
   12cf0:	89 ee       	ldi	r24, 0xE9	; 233
   12cf2:	99 e9       	ldi	r25, 0x99	; 153
   12cf4:	0e 94 77 93 	call	0x126ee	; 0x126ee <xTaskGenericCreate>
   12cf8:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
   12cfa:	89 81       	ldd	r24, Y+1	; 0x01
   12cfc:	81 30       	cpi	r24, 0x01	; 1
   12cfe:	51 f4       	brne	.+20     	; 0x12d14 <vTaskStartScheduler+0x5e>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
   12d00:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
   12d02:	81 e0       	ldi	r24, 0x01	; 1
   12d04:	80 93 a2 09 	sts	0x09A2, r24
		xTickCount = ( portTickType ) 0U;
   12d08:	10 92 9f 09 	sts	0x099F, r1
   12d0c:	10 92 9e 09 	sts	0x099E, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   12d10:	0e 94 ec 8a 	call	0x115d8	; 0x115d8 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
   12d14:	0f 90       	pop	r0
   12d16:	df 91       	pop	r29
   12d18:	cf 91       	pop	r28
   12d1a:	0f 91       	pop	r16
   12d1c:	ff 90       	pop	r15
   12d1e:	ef 90       	pop	r14
   12d20:	df 90       	pop	r13
   12d22:	cf 90       	pop	r12
   12d24:	bf 90       	pop	r11
   12d26:	af 90       	pop	r10
   12d28:	08 95       	ret

00012d2a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
   12d2a:	cf 93       	push	r28
   12d2c:	df 93       	push	r29
   12d2e:	cd b7       	in	r28, 0x3d	; 61
   12d30:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
   12d32:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
   12d34:	10 92 a2 09 	sts	0x09A2, r1
	vPortEndScheduler();
   12d38:	0e 94 21 8b 	call	0x11642	; 0x11642 <vPortEndScheduler>
}
   12d3c:	df 91       	pop	r29
   12d3e:	cf 91       	pop	r28
   12d40:	08 95       	ret

00012d42 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
   12d42:	cf 93       	push	r28
   12d44:	df 93       	push	r29
   12d46:	cd b7       	in	r28, 0x3d	; 61
   12d48:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
   12d4a:	80 91 a3 09 	lds	r24, 0x09A3
   12d4e:	8f 5f       	subi	r24, 0xFF	; 255
   12d50:	80 93 a3 09 	sts	0x09A3, r24
}
   12d54:	df 91       	pop	r29
   12d56:	cf 91       	pop	r28
   12d58:	08 95       	ret

00012d5a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
   12d5a:	0f 93       	push	r16
   12d5c:	1f 93       	push	r17
   12d5e:	cf 93       	push	r28
   12d60:	df 93       	push	r29
   12d62:	00 d0       	rcall	.+0      	; 0x12d64 <xTaskResumeAll+0xa>
   12d64:	cd b7       	in	r28, 0x3d	; 61
   12d66:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   12d68:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   12d6a:	0f b6       	in	r0, 0x3f	; 63
   12d6c:	f8 94       	cli
   12d6e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
   12d70:	80 91 a3 09 	lds	r24, 0x09A3
   12d74:	81 50       	subi	r24, 0x01	; 1
   12d76:	80 93 a3 09 	sts	0x09A3, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   12d7a:	80 91 a3 09 	lds	r24, 0x09A3
   12d7e:	88 23       	and	r24, r24
   12d80:	09 f0       	breq	.+2      	; 0x12d84 <xTaskResumeAll+0x2a>
   12d82:	64 c0       	rjmp	.+200    	; 0x12e4c <xTaskResumeAll+0xf2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
   12d84:	80 91 9d 09 	lds	r24, 0x099D
   12d88:	88 23       	and	r24, r24
   12d8a:	09 f4       	brne	.+2      	; 0x12d8e <xTaskResumeAll+0x34>
   12d8c:	5f c0       	rjmp	.+190    	; 0x12e4c <xTaskResumeAll+0xf2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
   12d8e:	1a 82       	std	Y+2, r1	; 0x02

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
   12d90:	3a c0       	rjmp	.+116    	; 0x12e06 <xTaskResumeAll+0xac>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
   12d92:	80 91 8d 09 	lds	r24, 0x098D
   12d96:	90 91 8e 09 	lds	r25, 0x098E
   12d9a:	fc 01       	movw	r30, r24
   12d9c:	06 81       	ldd	r16, Z+6	; 0x06
   12d9e:	17 81       	ldd	r17, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
   12da0:	c8 01       	movw	r24, r16
   12da2:	0c 96       	adiw	r24, 0x0c	; 12
   12da4:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
   12da8:	c8 01       	movw	r24, r16
   12daa:	02 96       	adiw	r24, 0x02	; 2
   12dac:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
   12db0:	f8 01       	movw	r30, r16
   12db2:	96 89       	ldd	r25, Z+22	; 0x16
   12db4:	80 91 a1 09 	lds	r24, 0x09A1
   12db8:	89 17       	cp	r24, r25
   12dba:	20 f4       	brcc	.+8      	; 0x12dc4 <xTaskResumeAll+0x6a>
   12dbc:	f8 01       	movw	r30, r16
   12dbe:	86 89       	ldd	r24, Z+22	; 0x16
   12dc0:	80 93 a1 09 	sts	0x09A1, r24
   12dc4:	a8 01       	movw	r20, r16
   12dc6:	4e 5f       	subi	r20, 0xFE	; 254
   12dc8:	5f 4f       	sbci	r21, 0xFF	; 255
   12dca:	f8 01       	movw	r30, r16
   12dcc:	86 89       	ldd	r24, Z+22	; 0x16
   12dce:	28 2f       	mov	r18, r24
   12dd0:	30 e0       	ldi	r19, 0x00	; 0
   12dd2:	c9 01       	movw	r24, r18
   12dd4:	88 0f       	add	r24, r24
   12dd6:	99 1f       	adc	r25, r25
   12dd8:	88 0f       	add	r24, r24
   12dda:	99 1f       	adc	r25, r25
   12ddc:	88 0f       	add	r24, r24
   12dde:	99 1f       	adc	r25, r25
   12de0:	82 0f       	add	r24, r18
   12de2:	93 1f       	adc	r25, r19
   12de4:	82 5b       	subi	r24, 0xB2	; 178
   12de6:	96 4f       	sbci	r25, 0xF6	; 246
   12de8:	ba 01       	movw	r22, r20
   12dea:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   12dee:	f8 01       	movw	r30, r16
   12df0:	26 89       	ldd	r18, Z+22	; 0x16
   12df2:	80 91 4c 09 	lds	r24, 0x094C
   12df6:	90 91 4d 09 	lds	r25, 0x094D
   12dfa:	fc 01       	movw	r30, r24
   12dfc:	86 89       	ldd	r24, Z+22	; 0x16
   12dfe:	28 17       	cp	r18, r24
   12e00:	10 f0       	brcs	.+4      	; 0x12e06 <xTaskResumeAll+0xac>
					{
						xYieldRequired = pdTRUE;
   12e02:	81 e0       	ldi	r24, 0x01	; 1
   12e04:	8a 83       	std	Y+2, r24	; 0x02
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
   12e06:	80 91 88 09 	lds	r24, 0x0988
   12e0a:	88 23       	and	r24, r24
   12e0c:	11 f6       	brne	.-124    	; 0x12d92 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   12e0e:	80 91 a4 09 	lds	r24, 0x09A4
   12e12:	88 23       	and	r24, r24
   12e14:	71 f0       	breq	.+28     	; 0x12e32 <xTaskResumeAll+0xd8>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   12e16:	07 c0       	rjmp	.+14     	; 0x12e26 <xTaskResumeAll+0xcc>
					{
						vTaskIncrementTick();
   12e18:	0e 94 70 97 	call	0x12ee0	; 0x12ee0 <vTaskIncrementTick>
						--uxMissedTicks;
   12e1c:	80 91 a4 09 	lds	r24, 0x09A4
   12e20:	81 50       	subi	r24, 0x01	; 1
   12e22:	80 93 a4 09 	sts	0x09A4, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   12e26:	80 91 a4 09 	lds	r24, 0x09A4
   12e2a:	88 23       	and	r24, r24
   12e2c:	a9 f7       	brne	.-22     	; 0x12e18 <xTaskResumeAll+0xbe>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
   12e2e:	81 e0       	ldi	r24, 0x01	; 1
   12e30:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
   12e32:	8a 81       	ldd	r24, Y+2	; 0x02
   12e34:	81 30       	cpi	r24, 0x01	; 1
   12e36:	21 f0       	breq	.+8      	; 0x12e40 <xTaskResumeAll+0xe6>
   12e38:	80 91 a5 09 	lds	r24, 0x09A5
   12e3c:	81 30       	cpi	r24, 0x01	; 1
   12e3e:	31 f4       	brne	.+12     	; 0x12e4c <xTaskResumeAll+0xf2>
				{
					xAlreadyYielded = pdTRUE;
   12e40:	81 e0       	ldi	r24, 0x01	; 1
   12e42:	89 83       	std	Y+1, r24	; 0x01
					xMissedYield = pdFALSE;
   12e44:	10 92 a5 09 	sts	0x09A5, r1
					portYIELD_WITHIN_API();
   12e48:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
   12e4c:	0f 90       	pop	r0
   12e4e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
   12e50:	89 81       	ldd	r24, Y+1	; 0x01
}
   12e52:	0f 90       	pop	r0
   12e54:	0f 90       	pop	r0
   12e56:	df 91       	pop	r29
   12e58:	cf 91       	pop	r28
   12e5a:	1f 91       	pop	r17
   12e5c:	0f 91       	pop	r16
   12e5e:	08 95       	ret

00012e60 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
   12e60:	cf 93       	push	r28
   12e62:	df 93       	push	r29
   12e64:	00 d0       	rcall	.+0      	; 0x12e66 <xTaskGetTickCount+0x6>
   12e66:	cd b7       	in	r28, 0x3d	; 61
   12e68:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
   12e6a:	0f b6       	in	r0, 0x3f	; 63
   12e6c:	f8 94       	cli
   12e6e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
   12e70:	80 91 9e 09 	lds	r24, 0x099E
   12e74:	90 91 9f 09 	lds	r25, 0x099F
   12e78:	9a 83       	std	Y+2, r25	; 0x02
   12e7a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
   12e7c:	0f 90       	pop	r0
   12e7e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
   12e80:	89 81       	ldd	r24, Y+1	; 0x01
   12e82:	9a 81       	ldd	r25, Y+2	; 0x02
}
   12e84:	0f 90       	pop	r0
   12e86:	0f 90       	pop	r0
   12e88:	df 91       	pop	r29
   12e8a:	cf 91       	pop	r28
   12e8c:	08 95       	ret

00012e8e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
   12e8e:	cf 93       	push	r28
   12e90:	df 93       	push	r29
   12e92:	00 d0       	rcall	.+0      	; 0x12e94 <xTaskGetTickCountFromISR+0x6>
   12e94:	1f 92       	push	r1
   12e96:	cd b7       	in	r28, 0x3d	; 61
   12e98:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   12e9a:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
   12e9c:	80 91 9e 09 	lds	r24, 0x099E
   12ea0:	90 91 9f 09 	lds	r25, 0x099F
   12ea4:	9b 83       	std	Y+3, r25	; 0x03
   12ea6:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   12ea8:	8a 81       	ldd	r24, Y+2	; 0x02
   12eaa:	9b 81       	ldd	r25, Y+3	; 0x03
}
   12eac:	0f 90       	pop	r0
   12eae:	0f 90       	pop	r0
   12eb0:	0f 90       	pop	r0
   12eb2:	df 91       	pop	r29
   12eb4:	cf 91       	pop	r28
   12eb6:	08 95       	ret

00012eb8 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
   12eb8:	cf 93       	push	r28
   12eba:	df 93       	push	r29
   12ebc:	cd b7       	in	r28, 0x3d	; 61
   12ebe:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
   12ec0:	80 91 9d 09 	lds	r24, 0x099D
}
   12ec4:	df 91       	pop	r29
   12ec6:	cf 91       	pop	r28
   12ec8:	08 95       	ret

00012eca <xTaskGetIdleTaskHandle>:
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )

	xTaskHandle xTaskGetIdleTaskHandle( void )
	{
   12eca:	cf 93       	push	r28
   12ecc:	df 93       	push	r29
   12ece:	cd b7       	in	r28, 0x3d	; 61
   12ed0:	de b7       	in	r29, 0x3e	; 62
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
   12ed2:	80 91 9b 09 	lds	r24, 0x099B
   12ed6:	90 91 9c 09 	lds	r25, 0x099C
	}
   12eda:	df 91       	pop	r29
   12edc:	cf 91       	pop	r28
   12ede:	08 95       	ret

00012ee0 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
   12ee0:	cf 93       	push	r28
   12ee2:	df 93       	push	r29
   12ee4:	00 d0       	rcall	.+0      	; 0x12ee6 <vTaskIncrementTick+0x6>
   12ee6:	00 d0       	rcall	.+0      	; 0x12ee8 <vTaskIncrementTick+0x8>
   12ee8:	00 d0       	rcall	.+0      	; 0x12eea <vTaskIncrementTick+0xa>
   12eea:	cd b7       	in	r28, 0x3d	; 61
   12eec:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   12eee:	80 91 a3 09 	lds	r24, 0x09A3
   12ef2:	88 23       	and	r24, r24
   12ef4:	09 f0       	breq	.+2      	; 0x12ef8 <vTaskIncrementTick+0x18>
   12ef6:	c3 c0       	rjmp	.+390    	; 0x1307e <vTaskIncrementTick+0x19e>
	{
		++xTickCount;
   12ef8:	80 91 9e 09 	lds	r24, 0x099E
   12efc:	90 91 9f 09 	lds	r25, 0x099F
   12f00:	01 96       	adiw	r24, 0x01	; 1
   12f02:	90 93 9f 09 	sts	0x099F, r25
   12f06:	80 93 9e 09 	sts	0x099E, r24
		if( xTickCount == ( portTickType ) 0U )
   12f0a:	80 91 9e 09 	lds	r24, 0x099E
   12f0e:	90 91 9f 09 	lds	r25, 0x099F
   12f12:	00 97       	sbiw	r24, 0x00	; 0
   12f14:	e9 f5       	brne	.+122    	; 0x12f90 <vTaskIncrementTick+0xb0>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
   12f16:	80 91 84 09 	lds	r24, 0x0984
   12f1a:	90 91 85 09 	lds	r25, 0x0985
   12f1e:	9a 83       	std	Y+2, r25	; 0x02
   12f20:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedTaskList = pxOverflowDelayedTaskList;
   12f22:	80 91 86 09 	lds	r24, 0x0986
   12f26:	90 91 87 09 	lds	r25, 0x0987
   12f2a:	90 93 85 09 	sts	0x0985, r25
   12f2e:	80 93 84 09 	sts	0x0984, r24
			pxOverflowDelayedTaskList = pxTemp;
   12f32:	89 81       	ldd	r24, Y+1	; 0x01
   12f34:	9a 81       	ldd	r25, Y+2	; 0x02
   12f36:	90 93 87 09 	sts	0x0987, r25
   12f3a:	80 93 86 09 	sts	0x0986, r24
			xNumOfOverflows++;
   12f3e:	80 91 a6 09 	lds	r24, 0x09A6
   12f42:	8f 5f       	subi	r24, 0xFF	; 255
   12f44:	80 93 a6 09 	sts	0x09A6, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   12f48:	80 91 84 09 	lds	r24, 0x0984
   12f4c:	90 91 85 09 	lds	r25, 0x0985
   12f50:	fc 01       	movw	r30, r24
   12f52:	80 81       	ld	r24, Z
   12f54:	88 23       	and	r24, r24
   12f56:	39 f4       	brne	.+14     	; 0x12f66 <vTaskIncrementTick+0x86>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
   12f58:	8f ef       	ldi	r24, 0xFF	; 255
   12f5a:	9f ef       	ldi	r25, 0xFF	; 255
   12f5c:	90 93 47 02 	sts	0x0247, r25
   12f60:	80 93 46 02 	sts	0x0246, r24
   12f64:	15 c0       	rjmp	.+42     	; 0x12f90 <vTaskIncrementTick+0xb0>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   12f66:	80 91 84 09 	lds	r24, 0x0984
   12f6a:	90 91 85 09 	lds	r25, 0x0985
   12f6e:	fc 01       	movw	r30, r24
   12f70:	85 81       	ldd	r24, Z+5	; 0x05
   12f72:	96 81       	ldd	r25, Z+6	; 0x06
   12f74:	fc 01       	movw	r30, r24
   12f76:	86 81       	ldd	r24, Z+6	; 0x06
   12f78:	97 81       	ldd	r25, Z+7	; 0x07
   12f7a:	9c 83       	std	Y+4, r25	; 0x04
   12f7c:	8b 83       	std	Y+3, r24	; 0x03
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   12f7e:	8b 81       	ldd	r24, Y+3	; 0x03
   12f80:	9c 81       	ldd	r25, Y+4	; 0x04
   12f82:	fc 01       	movw	r30, r24
   12f84:	82 81       	ldd	r24, Z+2	; 0x02
   12f86:	93 81       	ldd	r25, Z+3	; 0x03
   12f88:	90 93 47 02 	sts	0x0247, r25
   12f8c:	80 93 46 02 	sts	0x0246, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
   12f90:	20 91 9e 09 	lds	r18, 0x099E
   12f94:	30 91 9f 09 	lds	r19, 0x099F
   12f98:	80 91 46 02 	lds	r24, 0x0246
   12f9c:	90 91 47 02 	lds	r25, 0x0247
   12fa0:	28 17       	cp	r18, r24
   12fa2:	39 07       	cpc	r19, r25
   12fa4:	08 f4       	brcc	.+2      	; 0x12fa8 <vTaskIncrementTick+0xc8>
   12fa6:	72 c0       	rjmp	.+228    	; 0x1308c <vTaskIncrementTick+0x1ac>
   12fa8:	80 91 84 09 	lds	r24, 0x0984
   12fac:	90 91 85 09 	lds	r25, 0x0985
   12fb0:	fc 01       	movw	r30, r24
   12fb2:	80 81       	ld	r24, Z
   12fb4:	88 23       	and	r24, r24
   12fb6:	39 f4       	brne	.+14     	; 0x12fc6 <vTaskIncrementTick+0xe6>
   12fb8:	8f ef       	ldi	r24, 0xFF	; 255
   12fba:	9f ef       	ldi	r25, 0xFF	; 255
   12fbc:	90 93 47 02 	sts	0x0247, r25
   12fc0:	80 93 46 02 	sts	0x0246, r24
   12fc4:	63 c0       	rjmp	.+198    	; 0x1308c <vTaskIncrementTick+0x1ac>
   12fc6:	80 91 84 09 	lds	r24, 0x0984
   12fca:	90 91 85 09 	lds	r25, 0x0985
   12fce:	fc 01       	movw	r30, r24
   12fd0:	85 81       	ldd	r24, Z+5	; 0x05
   12fd2:	96 81       	ldd	r25, Z+6	; 0x06
   12fd4:	fc 01       	movw	r30, r24
   12fd6:	86 81       	ldd	r24, Z+6	; 0x06
   12fd8:	97 81       	ldd	r25, Z+7	; 0x07
   12fda:	9c 83       	std	Y+4, r25	; 0x04
   12fdc:	8b 83       	std	Y+3, r24	; 0x03
   12fde:	8b 81       	ldd	r24, Y+3	; 0x03
   12fe0:	9c 81       	ldd	r25, Y+4	; 0x04
   12fe2:	fc 01       	movw	r30, r24
   12fe4:	82 81       	ldd	r24, Z+2	; 0x02
   12fe6:	93 81       	ldd	r25, Z+3	; 0x03
   12fe8:	9e 83       	std	Y+6, r25	; 0x06
   12fea:	8d 83       	std	Y+5, r24	; 0x05
   12fec:	20 91 9e 09 	lds	r18, 0x099E
   12ff0:	30 91 9f 09 	lds	r19, 0x099F
   12ff4:	8d 81       	ldd	r24, Y+5	; 0x05
   12ff6:	9e 81       	ldd	r25, Y+6	; 0x06
   12ff8:	28 17       	cp	r18, r24
   12ffa:	39 07       	cpc	r19, r25
   12ffc:	38 f4       	brcc	.+14     	; 0x1300c <vTaskIncrementTick+0x12c>
   12ffe:	8d 81       	ldd	r24, Y+5	; 0x05
   13000:	9e 81       	ldd	r25, Y+6	; 0x06
   13002:	90 93 47 02 	sts	0x0247, r25
   13006:	80 93 46 02 	sts	0x0246, r24
   1300a:	40 c0       	rjmp	.+128    	; 0x1308c <vTaskIncrementTick+0x1ac>
   1300c:	8b 81       	ldd	r24, Y+3	; 0x03
   1300e:	9c 81       	ldd	r25, Y+4	; 0x04
   13010:	02 96       	adiw	r24, 0x02	; 2
   13012:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
   13016:	8b 81       	ldd	r24, Y+3	; 0x03
   13018:	9c 81       	ldd	r25, Y+4	; 0x04
   1301a:	fc 01       	movw	r30, r24
   1301c:	84 89       	ldd	r24, Z+20	; 0x14
   1301e:	95 89       	ldd	r25, Z+21	; 0x15
   13020:	00 97       	sbiw	r24, 0x00	; 0
   13022:	29 f0       	breq	.+10     	; 0x1302e <vTaskIncrementTick+0x14e>
   13024:	8b 81       	ldd	r24, Y+3	; 0x03
   13026:	9c 81       	ldd	r25, Y+4	; 0x04
   13028:	0c 96       	adiw	r24, 0x0c	; 12
   1302a:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
   1302e:	8b 81       	ldd	r24, Y+3	; 0x03
   13030:	9c 81       	ldd	r25, Y+4	; 0x04
   13032:	fc 01       	movw	r30, r24
   13034:	96 89       	ldd	r25, Z+22	; 0x16
   13036:	80 91 a1 09 	lds	r24, 0x09A1
   1303a:	89 17       	cp	r24, r25
   1303c:	30 f4       	brcc	.+12     	; 0x1304a <vTaskIncrementTick+0x16a>
   1303e:	8b 81       	ldd	r24, Y+3	; 0x03
   13040:	9c 81       	ldd	r25, Y+4	; 0x04
   13042:	fc 01       	movw	r30, r24
   13044:	86 89       	ldd	r24, Z+22	; 0x16
   13046:	80 93 a1 09 	sts	0x09A1, r24
   1304a:	8b 81       	ldd	r24, Y+3	; 0x03
   1304c:	9c 81       	ldd	r25, Y+4	; 0x04
   1304e:	ac 01       	movw	r20, r24
   13050:	4e 5f       	subi	r20, 0xFE	; 254
   13052:	5f 4f       	sbci	r21, 0xFF	; 255
   13054:	8b 81       	ldd	r24, Y+3	; 0x03
   13056:	9c 81       	ldd	r25, Y+4	; 0x04
   13058:	fc 01       	movw	r30, r24
   1305a:	86 89       	ldd	r24, Z+22	; 0x16
   1305c:	28 2f       	mov	r18, r24
   1305e:	30 e0       	ldi	r19, 0x00	; 0
   13060:	c9 01       	movw	r24, r18
   13062:	88 0f       	add	r24, r24
   13064:	99 1f       	adc	r25, r25
   13066:	88 0f       	add	r24, r24
   13068:	99 1f       	adc	r25, r25
   1306a:	88 0f       	add	r24, r24
   1306c:	99 1f       	adc	r25, r25
   1306e:	82 0f       	add	r24, r18
   13070:	93 1f       	adc	r25, r19
   13072:	82 5b       	subi	r24, 0xB2	; 178
   13074:	96 4f       	sbci	r25, 0xF6	; 246
   13076:	ba 01       	movw	r22, r20
   13078:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>
   1307c:	95 cf       	rjmp	.-214    	; 0x12fa8 <vTaskIncrementTick+0xc8>
	}
	else
	{
		++uxMissedTicks;
   1307e:	80 91 a4 09 	lds	r24, 0x09A4
   13082:	8f 5f       	subi	r24, 0xFF	; 255
   13084:	80 93 a4 09 	sts	0x09A4, r24

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
   13088:	0e 94 71 9d 	call	0x13ae2	; 0x13ae2 <vApplicationTickHook>

	#if ( configUSE_TICK_HOOK == 1 )
	{
		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
   1308c:	80 91 a4 09 	lds	r24, 0x09A4
   13090:	88 23       	and	r24, r24
   13092:	11 f4       	brne	.+4      	; 0x13098 <vTaskIncrementTick+0x1b8>
		{
			vApplicationTickHook();
   13094:	0e 94 71 9d 	call	0x13ae2	; 0x13ae2 <vApplicationTickHook>
		}
	}
	#endif
}
   13098:	26 96       	adiw	r28, 0x06	; 6
   1309a:	0f b6       	in	r0, 0x3f	; 63
   1309c:	f8 94       	cli
   1309e:	de bf       	out	0x3e, r29	; 62
   130a0:	0f be       	out	0x3f, r0	; 63
   130a2:	cd bf       	out	0x3d, r28	; 61
   130a4:	df 91       	pop	r29
   130a6:	cf 91       	pop	r28
   130a8:	08 95       	ret

000130aa <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   130aa:	cf 93       	push	r28
   130ac:	df 93       	push	r29
   130ae:	00 d0       	rcall	.+0      	; 0x130b0 <vTaskSwitchContext+0x6>
   130b0:	cd b7       	in	r28, 0x3d	; 61
   130b2:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   130b4:	80 91 a3 09 	lds	r24, 0x09A3
   130b8:	88 23       	and	r24, r24
   130ba:	49 f0       	breq	.+18     	; 0x130ce <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
   130bc:	81 e0       	ldi	r24, 0x01	; 1
   130be:	80 93 a5 09 	sts	0x09A5, r24
   130c2:	5a c0       	rjmp	.+180    	; 0x13178 <vTaskSwitchContext+0xce>
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
   130c4:	80 91 a1 09 	lds	r24, 0x09A1
   130c8:	81 50       	subi	r24, 0x01	; 1
   130ca:	80 93 a1 09 	sts	0x09A1, r24
   130ce:	80 91 a1 09 	lds	r24, 0x09A1
   130d2:	28 2f       	mov	r18, r24
   130d4:	30 e0       	ldi	r19, 0x00	; 0
   130d6:	c9 01       	movw	r24, r18
   130d8:	88 0f       	add	r24, r24
   130da:	99 1f       	adc	r25, r25
   130dc:	88 0f       	add	r24, r24
   130de:	99 1f       	adc	r25, r25
   130e0:	88 0f       	add	r24, r24
   130e2:	99 1f       	adc	r25, r25
   130e4:	82 0f       	add	r24, r18
   130e6:	93 1f       	adc	r25, r19
   130e8:	82 5b       	subi	r24, 0xB2	; 178
   130ea:	96 4f       	sbci	r25, 0xF6	; 246
   130ec:	fc 01       	movw	r30, r24
   130ee:	80 81       	ld	r24, Z
   130f0:	88 23       	and	r24, r24
   130f2:	41 f3       	breq	.-48     	; 0x130c4 <vTaskSwitchContext+0x1a>
   130f4:	80 91 a1 09 	lds	r24, 0x09A1
   130f8:	28 2f       	mov	r18, r24
   130fa:	30 e0       	ldi	r19, 0x00	; 0
   130fc:	c9 01       	movw	r24, r18
   130fe:	88 0f       	add	r24, r24
   13100:	99 1f       	adc	r25, r25
   13102:	88 0f       	add	r24, r24
   13104:	99 1f       	adc	r25, r25
   13106:	88 0f       	add	r24, r24
   13108:	99 1f       	adc	r25, r25
   1310a:	82 0f       	add	r24, r18
   1310c:	93 1f       	adc	r25, r19
   1310e:	82 5b       	subi	r24, 0xB2	; 178
   13110:	96 4f       	sbci	r25, 0xF6	; 246
   13112:	9a 83       	std	Y+2, r25	; 0x02
   13114:	89 83       	std	Y+1, r24	; 0x01
   13116:	89 81       	ldd	r24, Y+1	; 0x01
   13118:	9a 81       	ldd	r25, Y+2	; 0x02
   1311a:	fc 01       	movw	r30, r24
   1311c:	81 81       	ldd	r24, Z+1	; 0x01
   1311e:	92 81       	ldd	r25, Z+2	; 0x02
   13120:	fc 01       	movw	r30, r24
   13122:	22 81       	ldd	r18, Z+2	; 0x02
   13124:	33 81       	ldd	r19, Z+3	; 0x03
   13126:	89 81       	ldd	r24, Y+1	; 0x01
   13128:	9a 81       	ldd	r25, Y+2	; 0x02
   1312a:	fc 01       	movw	r30, r24
   1312c:	32 83       	std	Z+2, r19	; 0x02
   1312e:	21 83       	std	Z+1, r18	; 0x01
   13130:	89 81       	ldd	r24, Y+1	; 0x01
   13132:	9a 81       	ldd	r25, Y+2	; 0x02
   13134:	fc 01       	movw	r30, r24
   13136:	21 81       	ldd	r18, Z+1	; 0x01
   13138:	32 81       	ldd	r19, Z+2	; 0x02
   1313a:	89 81       	ldd	r24, Y+1	; 0x01
   1313c:	9a 81       	ldd	r25, Y+2	; 0x02
   1313e:	03 96       	adiw	r24, 0x03	; 3
   13140:	28 17       	cp	r18, r24
   13142:	39 07       	cpc	r19, r25
   13144:	69 f4       	brne	.+26     	; 0x13160 <vTaskSwitchContext+0xb6>
   13146:	89 81       	ldd	r24, Y+1	; 0x01
   13148:	9a 81       	ldd	r25, Y+2	; 0x02
   1314a:	fc 01       	movw	r30, r24
   1314c:	81 81       	ldd	r24, Z+1	; 0x01
   1314e:	92 81       	ldd	r25, Z+2	; 0x02
   13150:	fc 01       	movw	r30, r24
   13152:	22 81       	ldd	r18, Z+2	; 0x02
   13154:	33 81       	ldd	r19, Z+3	; 0x03
   13156:	89 81       	ldd	r24, Y+1	; 0x01
   13158:	9a 81       	ldd	r25, Y+2	; 0x02
   1315a:	fc 01       	movw	r30, r24
   1315c:	32 83       	std	Z+2, r19	; 0x02
   1315e:	21 83       	std	Z+1, r18	; 0x01
   13160:	89 81       	ldd	r24, Y+1	; 0x01
   13162:	9a 81       	ldd	r25, Y+2	; 0x02
   13164:	fc 01       	movw	r30, r24
   13166:	81 81       	ldd	r24, Z+1	; 0x01
   13168:	92 81       	ldd	r25, Z+2	; 0x02
   1316a:	fc 01       	movw	r30, r24
   1316c:	86 81       	ldd	r24, Z+6	; 0x06
   1316e:	97 81       	ldd	r25, Z+7	; 0x07
   13170:	90 93 4d 09 	sts	0x094D, r25
   13174:	80 93 4c 09 	sts	0x094C, r24

		traceTASK_SWITCHED_IN();
	}
}
   13178:	0f 90       	pop	r0
   1317a:	0f 90       	pop	r0
   1317c:	df 91       	pop	r29
   1317e:	cf 91       	pop	r28
   13180:	08 95       	ret

00013182 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
   13182:	cf 93       	push	r28
   13184:	df 93       	push	r29
   13186:	00 d0       	rcall	.+0      	; 0x13188 <vTaskPlaceOnEventList+0x6>
   13188:	00 d0       	rcall	.+0      	; 0x1318a <vTaskPlaceOnEventList+0x8>
   1318a:	00 d0       	rcall	.+0      	; 0x1318c <vTaskPlaceOnEventList+0xa>
   1318c:	cd b7       	in	r28, 0x3d	; 61
   1318e:	de b7       	in	r29, 0x3e	; 62
   13190:	9c 83       	std	Y+4, r25	; 0x04
   13192:	8b 83       	std	Y+3, r24	; 0x03
   13194:	7e 83       	std	Y+6, r23	; 0x06
   13196:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   13198:	80 91 4c 09 	lds	r24, 0x094C
   1319c:	90 91 4d 09 	lds	r25, 0x094D
   131a0:	9c 01       	movw	r18, r24
   131a2:	24 5f       	subi	r18, 0xF4	; 244
   131a4:	3f 4f       	sbci	r19, 0xFF	; 255
   131a6:	8b 81       	ldd	r24, Y+3	; 0x03
   131a8:	9c 81       	ldd	r25, Y+4	; 0x04
   131aa:	b9 01       	movw	r22, r18
   131ac:	0e 94 73 88 	call	0x110e6	; 0x110e6 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   131b0:	80 91 4c 09 	lds	r24, 0x094C
   131b4:	90 91 4d 09 	lds	r25, 0x094D
   131b8:	02 96       	adiw	r24, 0x02	; 2
   131ba:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
   131be:	20 91 9e 09 	lds	r18, 0x099E
   131c2:	30 91 9f 09 	lds	r19, 0x099F
   131c6:	8d 81       	ldd	r24, Y+5	; 0x05
   131c8:	9e 81       	ldd	r25, Y+6	; 0x06
   131ca:	82 0f       	add	r24, r18
   131cc:	93 1f       	adc	r25, r19
   131ce:	9a 83       	std	Y+2, r25	; 0x02
   131d0:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
   131d2:	89 81       	ldd	r24, Y+1	; 0x01
   131d4:	9a 81       	ldd	r25, Y+2	; 0x02
   131d6:	0e 94 d9 9a 	call	0x135b2	; 0x135b2 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
   131da:	26 96       	adiw	r28, 0x06	; 6
   131dc:	0f b6       	in	r0, 0x3f	; 63
   131de:	f8 94       	cli
   131e0:	de bf       	out	0x3e, r29	; 62
   131e2:	0f be       	out	0x3f, r0	; 63
   131e4:	cd bf       	out	0x3d, r28	; 61
   131e6:	df 91       	pop	r29
   131e8:	cf 91       	pop	r28
   131ea:	08 95       	ret

000131ec <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
   131ec:	cf 93       	push	r28
   131ee:	df 93       	push	r29
   131f0:	00 d0       	rcall	.+0      	; 0x131f2 <xTaskRemoveFromEventList+0x6>
   131f2:	00 d0       	rcall	.+0      	; 0x131f4 <xTaskRemoveFromEventList+0x8>
   131f4:	1f 92       	push	r1
   131f6:	cd b7       	in	r28, 0x3d	; 61
   131f8:	de b7       	in	r29, 0x3e	; 62
   131fa:	9d 83       	std	Y+5, r25	; 0x05
   131fc:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   131fe:	8c 81       	ldd	r24, Y+4	; 0x04
   13200:	9d 81       	ldd	r25, Y+5	; 0x05
   13202:	fc 01       	movw	r30, r24
   13204:	85 81       	ldd	r24, Z+5	; 0x05
   13206:	96 81       	ldd	r25, Z+6	; 0x06
   13208:	fc 01       	movw	r30, r24
   1320a:	86 81       	ldd	r24, Z+6	; 0x06
   1320c:	97 81       	ldd	r25, Z+7	; 0x07
   1320e:	9b 83       	std	Y+3, r25	; 0x03
   13210:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   13212:	8a 81       	ldd	r24, Y+2	; 0x02
   13214:	9b 81       	ldd	r25, Y+3	; 0x03
   13216:	0c 96       	adiw	r24, 0x0c	; 12
   13218:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   1321c:	80 91 a3 09 	lds	r24, 0x09A3
   13220:	88 23       	and	r24, r24
   13222:	69 f5       	brne	.+90     	; 0x1327e <xTaskRemoveFromEventList+0x92>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   13224:	8a 81       	ldd	r24, Y+2	; 0x02
   13226:	9b 81       	ldd	r25, Y+3	; 0x03
   13228:	02 96       	adiw	r24, 0x02	; 2
   1322a:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
   1322e:	8a 81       	ldd	r24, Y+2	; 0x02
   13230:	9b 81       	ldd	r25, Y+3	; 0x03
   13232:	fc 01       	movw	r30, r24
   13234:	96 89       	ldd	r25, Z+22	; 0x16
   13236:	80 91 a1 09 	lds	r24, 0x09A1
   1323a:	89 17       	cp	r24, r25
   1323c:	30 f4       	brcc	.+12     	; 0x1324a <xTaskRemoveFromEventList+0x5e>
   1323e:	8a 81       	ldd	r24, Y+2	; 0x02
   13240:	9b 81       	ldd	r25, Y+3	; 0x03
   13242:	fc 01       	movw	r30, r24
   13244:	86 89       	ldd	r24, Z+22	; 0x16
   13246:	80 93 a1 09 	sts	0x09A1, r24
   1324a:	8a 81       	ldd	r24, Y+2	; 0x02
   1324c:	9b 81       	ldd	r25, Y+3	; 0x03
   1324e:	ac 01       	movw	r20, r24
   13250:	4e 5f       	subi	r20, 0xFE	; 254
   13252:	5f 4f       	sbci	r21, 0xFF	; 255
   13254:	8a 81       	ldd	r24, Y+2	; 0x02
   13256:	9b 81       	ldd	r25, Y+3	; 0x03
   13258:	fc 01       	movw	r30, r24
   1325a:	86 89       	ldd	r24, Z+22	; 0x16
   1325c:	28 2f       	mov	r18, r24
   1325e:	30 e0       	ldi	r19, 0x00	; 0
   13260:	c9 01       	movw	r24, r18
   13262:	88 0f       	add	r24, r24
   13264:	99 1f       	adc	r25, r25
   13266:	88 0f       	add	r24, r24
   13268:	99 1f       	adc	r25, r25
   1326a:	88 0f       	add	r24, r24
   1326c:	99 1f       	adc	r25, r25
   1326e:	82 0f       	add	r24, r18
   13270:	93 1f       	adc	r25, r19
   13272:	82 5b       	subi	r24, 0xB2	; 178
   13274:	96 4f       	sbci	r25, 0xF6	; 246
   13276:	ba 01       	movw	r22, r20
   13278:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>
   1327c:	08 c0       	rjmp	.+16     	; 0x1328e <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   1327e:	8a 81       	ldd	r24, Y+2	; 0x02
   13280:	9b 81       	ldd	r25, Y+3	; 0x03
   13282:	0c 96       	adiw	r24, 0x0c	; 12
   13284:	bc 01       	movw	r22, r24
   13286:	88 e8       	ldi	r24, 0x88	; 136
   13288:	99 e0       	ldi	r25, 0x09	; 9
   1328a:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1328e:	8a 81       	ldd	r24, Y+2	; 0x02
   13290:	9b 81       	ldd	r25, Y+3	; 0x03
   13292:	fc 01       	movw	r30, r24
   13294:	26 89       	ldd	r18, Z+22	; 0x16
   13296:	80 91 4c 09 	lds	r24, 0x094C
   1329a:	90 91 4d 09 	lds	r25, 0x094D
   1329e:	fc 01       	movw	r30, r24
   132a0:	86 89       	ldd	r24, Z+22	; 0x16
   132a2:	28 17       	cp	r18, r24
   132a4:	18 f0       	brcs	.+6      	; 0x132ac <xTaskRemoveFromEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
   132a6:	81 e0       	ldi	r24, 0x01	; 1
   132a8:	89 83       	std	Y+1, r24	; 0x01
   132aa:	01 c0       	rjmp	.+2      	; 0x132ae <xTaskRemoveFromEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
   132ac:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
   132ae:	89 81       	ldd	r24, Y+1	; 0x01
}
   132b0:	0f 90       	pop	r0
   132b2:	0f 90       	pop	r0
   132b4:	0f 90       	pop	r0
   132b6:	0f 90       	pop	r0
   132b8:	0f 90       	pop	r0
   132ba:	df 91       	pop	r29
   132bc:	cf 91       	pop	r28
   132be:	08 95       	ret

000132c0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
   132c0:	cf 93       	push	r28
   132c2:	df 93       	push	r29
   132c4:	00 d0       	rcall	.+0      	; 0x132c6 <vTaskSetTimeOutState+0x6>
   132c6:	cd b7       	in	r28, 0x3d	; 61
   132c8:	de b7       	in	r29, 0x3e	; 62
   132ca:	9a 83       	std	Y+2, r25	; 0x02
   132cc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   132ce:	20 91 a6 09 	lds	r18, 0x09A6
   132d2:	89 81       	ldd	r24, Y+1	; 0x01
   132d4:	9a 81       	ldd	r25, Y+2	; 0x02
   132d6:	fc 01       	movw	r30, r24
   132d8:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
   132da:	20 91 9e 09 	lds	r18, 0x099E
   132de:	30 91 9f 09 	lds	r19, 0x099F
   132e2:	89 81       	ldd	r24, Y+1	; 0x01
   132e4:	9a 81       	ldd	r25, Y+2	; 0x02
   132e6:	fc 01       	movw	r30, r24
   132e8:	32 83       	std	Z+2, r19	; 0x02
   132ea:	21 83       	std	Z+1, r18	; 0x01
}
   132ec:	0f 90       	pop	r0
   132ee:	0f 90       	pop	r0
   132f0:	df 91       	pop	r29
   132f2:	cf 91       	pop	r28
   132f4:	08 95       	ret

000132f6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
   132f6:	cf 93       	push	r28
   132f8:	df 93       	push	r29
   132fa:	00 d0       	rcall	.+0      	; 0x132fc <xTaskCheckForTimeOut+0x6>
   132fc:	00 d0       	rcall	.+0      	; 0x132fe <xTaskCheckForTimeOut+0x8>
   132fe:	1f 92       	push	r1
   13300:	cd b7       	in	r28, 0x3d	; 61
   13302:	de b7       	in	r29, 0x3e	; 62
   13304:	9b 83       	std	Y+3, r25	; 0x03
   13306:	8a 83       	std	Y+2, r24	; 0x02
   13308:	7d 83       	std	Y+5, r23	; 0x05
   1330a:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
   1330c:	0f b6       	in	r0, 0x3f	; 63
   1330e:	f8 94       	cli
   13310:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
   13312:	8a 81       	ldd	r24, Y+2	; 0x02
   13314:	9b 81       	ldd	r25, Y+3	; 0x03
   13316:	fc 01       	movw	r30, r24
   13318:	90 81       	ld	r25, Z
   1331a:	80 91 a6 09 	lds	r24, 0x09A6
   1331e:	98 17       	cp	r25, r24
   13320:	79 f0       	breq	.+30     	; 0x13340 <xTaskCheckForTimeOut+0x4a>
   13322:	8a 81       	ldd	r24, Y+2	; 0x02
   13324:	9b 81       	ldd	r25, Y+3	; 0x03
   13326:	fc 01       	movw	r30, r24
   13328:	21 81       	ldd	r18, Z+1	; 0x01
   1332a:	32 81       	ldd	r19, Z+2	; 0x02
   1332c:	80 91 9e 09 	lds	r24, 0x099E
   13330:	90 91 9f 09 	lds	r25, 0x099F
   13334:	82 17       	cp	r24, r18
   13336:	93 07       	cpc	r25, r19
   13338:	18 f0       	brcs	.+6      	; 0x13340 <xTaskCheckForTimeOut+0x4a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
   1333a:	81 e0       	ldi	r24, 0x01	; 1
   1333c:	89 83       	std	Y+1, r24	; 0x01
   1333e:	34 c0       	rjmp	.+104    	; 0x133a8 <xTaskCheckForTimeOut+0xb2>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
   13340:	20 91 9e 09 	lds	r18, 0x099E
   13344:	30 91 9f 09 	lds	r19, 0x099F
   13348:	8a 81       	ldd	r24, Y+2	; 0x02
   1334a:	9b 81       	ldd	r25, Y+3	; 0x03
   1334c:	fc 01       	movw	r30, r24
   1334e:	81 81       	ldd	r24, Z+1	; 0x01
   13350:	92 81       	ldd	r25, Z+2	; 0x02
   13352:	28 1b       	sub	r18, r24
   13354:	39 0b       	sbc	r19, r25
   13356:	8c 81       	ldd	r24, Y+4	; 0x04
   13358:	9d 81       	ldd	r25, Y+5	; 0x05
   1335a:	fc 01       	movw	r30, r24
   1335c:	80 81       	ld	r24, Z
   1335e:	91 81       	ldd	r25, Z+1	; 0x01
   13360:	28 17       	cp	r18, r24
   13362:	39 07       	cpc	r19, r25
   13364:	f8 f4       	brcc	.+62     	; 0x133a4 <xTaskCheckForTimeOut+0xae>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
   13366:	8c 81       	ldd	r24, Y+4	; 0x04
   13368:	9d 81       	ldd	r25, Y+5	; 0x05
   1336a:	fc 01       	movw	r30, r24
   1336c:	20 81       	ld	r18, Z
   1336e:	31 81       	ldd	r19, Z+1	; 0x01
   13370:	8a 81       	ldd	r24, Y+2	; 0x02
   13372:	9b 81       	ldd	r25, Y+3	; 0x03
   13374:	fc 01       	movw	r30, r24
   13376:	41 81       	ldd	r20, Z+1	; 0x01
   13378:	52 81       	ldd	r21, Z+2	; 0x02
   1337a:	80 91 9e 09 	lds	r24, 0x099E
   1337e:	90 91 9f 09 	lds	r25, 0x099F
   13382:	ba 01       	movw	r22, r20
   13384:	68 1b       	sub	r22, r24
   13386:	79 0b       	sbc	r23, r25
   13388:	cb 01       	movw	r24, r22
   1338a:	28 0f       	add	r18, r24
   1338c:	39 1f       	adc	r19, r25
   1338e:	8c 81       	ldd	r24, Y+4	; 0x04
   13390:	9d 81       	ldd	r25, Y+5	; 0x05
   13392:	fc 01       	movw	r30, r24
   13394:	31 83       	std	Z+1, r19	; 0x01
   13396:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
   13398:	8a 81       	ldd	r24, Y+2	; 0x02
   1339a:	9b 81       	ldd	r25, Y+3	; 0x03
   1339c:	0e 94 60 99 	call	0x132c0	; 0x132c0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
   133a0:	19 82       	std	Y+1, r1	; 0x01
   133a2:	02 c0       	rjmp	.+4      	; 0x133a8 <xTaskCheckForTimeOut+0xb2>
		}
		else
		{
			xReturn = pdTRUE;
   133a4:	81 e0       	ldi	r24, 0x01	; 1
   133a6:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
   133a8:	0f 90       	pop	r0
   133aa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
   133ac:	89 81       	ldd	r24, Y+1	; 0x01
}
   133ae:	0f 90       	pop	r0
   133b0:	0f 90       	pop	r0
   133b2:	0f 90       	pop	r0
   133b4:	0f 90       	pop	r0
   133b6:	0f 90       	pop	r0
   133b8:	df 91       	pop	r29
   133ba:	cf 91       	pop	r28
   133bc:	08 95       	ret

000133be <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
   133be:	cf 93       	push	r28
   133c0:	df 93       	push	r29
   133c2:	cd b7       	in	r28, 0x3d	; 61
   133c4:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
   133c6:	81 e0       	ldi	r24, 0x01	; 1
   133c8:	80 93 a5 09 	sts	0x09A5, r24
}
   133cc:	df 91       	pop	r29
   133ce:	cf 91       	pop	r28
   133d0:	08 95       	ret

000133d2 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   133d2:	cf 93       	push	r28
   133d4:	df 93       	push	r29
   133d6:	00 d0       	rcall	.+0      	; 0x133d8 <prvIdleTask+0x6>
   133d8:	cd b7       	in	r28, 0x3d	; 61
   133da:	de b7       	in	r29, 0x3e	; 62
   133dc:	9a 83       	std	Y+2, r25	; 0x02
   133de:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
   133e0:	0e 94 99 9a 	call	0x13532	; 0x13532 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
   133e4:	80 91 4e 09 	lds	r24, 0x094E
   133e8:	82 30       	cpi	r24, 0x02	; 2
   133ea:	10 f0       	brcs	.+4      	; 0x133f0 <prvIdleTask+0x1e>
			{
				taskYIELD();
   133ec:	0e 94 28 8b 	call	0x11650	; 0x11650 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
   133f0:	0e 94 68 9d 	call	0x13ad0	; 0x13ad0 <vApplicationIdleHook>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
   133f4:	f5 cf       	rjmp	.-22     	; 0x133e0 <prvIdleTask+0xe>

000133f6 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
   133f6:	0f 93       	push	r16
   133f8:	1f 93       	push	r17
   133fa:	cf 93       	push	r28
   133fc:	df 93       	push	r29
   133fe:	cd b7       	in	r28, 0x3d	; 61
   13400:	de b7       	in	r29, 0x3e	; 62
   13402:	29 97       	sbiw	r28, 0x09	; 9
   13404:	0f b6       	in	r0, 0x3f	; 63
   13406:	f8 94       	cli
   13408:	de bf       	out	0x3e, r29	; 62
   1340a:	0f be       	out	0x3f, r0	; 63
   1340c:	cd bf       	out	0x3d, r28	; 61
   1340e:	9a 83       	std	Y+2, r25	; 0x02
   13410:	89 83       	std	Y+1, r24	; 0x01
   13412:	7c 83       	std	Y+4, r23	; 0x04
   13414:	6b 83       	std	Y+3, r22	; 0x03
   13416:	4d 83       	std	Y+5, r20	; 0x05
   13418:	3f 83       	std	Y+7, r19	; 0x07
   1341a:	2e 83       	std	Y+6, r18	; 0x06
   1341c:	19 87       	std	Y+9, r17	; 0x09
   1341e:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
   13420:	89 81       	ldd	r24, Y+1	; 0x01
   13422:	9a 81       	ldd	r25, Y+2	; 0x02
   13424:	49 96       	adiw	r24, 0x19	; 25
   13426:	2b 81       	ldd	r18, Y+3	; 0x03
   13428:	3c 81       	ldd	r19, Y+4	; 0x04
   1342a:	48 e0       	ldi	r20, 0x08	; 8
   1342c:	50 e0       	ldi	r21, 0x00	; 0
   1342e:	b9 01       	movw	r22, r18
   13430:	0e 94 52 b1 	call	0x162a4	; 0x162a4 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
   13434:	89 81       	ldd	r24, Y+1	; 0x01
   13436:	9a 81       	ldd	r25, Y+2	; 0x02
   13438:	fc 01       	movw	r30, r24
   1343a:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
   1343c:	8d 81       	ldd	r24, Y+5	; 0x05
   1343e:	84 30       	cpi	r24, 0x04	; 4
   13440:	10 f0       	brcs	.+4      	; 0x13446 <prvInitialiseTCBVariables+0x50>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
   13442:	83 e0       	ldi	r24, 0x03	; 3
   13444:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
   13446:	89 81       	ldd	r24, Y+1	; 0x01
   13448:	9a 81       	ldd	r25, Y+2	; 0x02
   1344a:	2d 81       	ldd	r18, Y+5	; 0x05
   1344c:	fc 01       	movw	r30, r24
   1344e:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
   13450:	89 81       	ldd	r24, Y+1	; 0x01
   13452:	9a 81       	ldd	r25, Y+2	; 0x02
   13454:	2d 81       	ldd	r18, Y+5	; 0x05
   13456:	fc 01       	movw	r30, r24
   13458:	21 a3       	std	Z+33, r18	; 0x21
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   1345a:	89 81       	ldd	r24, Y+1	; 0x01
   1345c:	9a 81       	ldd	r25, Y+2	; 0x02
   1345e:	02 96       	adiw	r24, 0x02	; 2
   13460:	0e 94 0a 88 	call	0x11014	; 0x11014 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   13464:	89 81       	ldd	r24, Y+1	; 0x01
   13466:	9a 81       	ldd	r25, Y+2	; 0x02
   13468:	0c 96       	adiw	r24, 0x0c	; 12
   1346a:	0e 94 0a 88 	call	0x11014	; 0x11014 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   1346e:	89 81       	ldd	r24, Y+1	; 0x01
   13470:	9a 81       	ldd	r25, Y+2	; 0x02
   13472:	29 81       	ldd	r18, Y+1	; 0x01
   13474:	3a 81       	ldd	r19, Y+2	; 0x02
   13476:	fc 01       	movw	r30, r24
   13478:	31 87       	std	Z+9, r19	; 0x09
   1347a:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
   1347c:	8d 81       	ldd	r24, Y+5	; 0x05
   1347e:	88 2f       	mov	r24, r24
   13480:	90 e0       	ldi	r25, 0x00	; 0
   13482:	24 e0       	ldi	r18, 0x04	; 4
   13484:	30 e0       	ldi	r19, 0x00	; 0
   13486:	28 1b       	sub	r18, r24
   13488:	39 0b       	sbc	r19, r25
   1348a:	89 81       	ldd	r24, Y+1	; 0x01
   1348c:	9a 81       	ldd	r25, Y+2	; 0x02
   1348e:	fc 01       	movw	r30, r24
   13490:	35 87       	std	Z+13, r19	; 0x0d
   13492:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   13494:	89 81       	ldd	r24, Y+1	; 0x01
   13496:	9a 81       	ldd	r25, Y+2	; 0x02
   13498:	29 81       	ldd	r18, Y+1	; 0x01
   1349a:	3a 81       	ldd	r19, Y+2	; 0x02
   1349c:	fc 01       	movw	r30, r24
   1349e:	33 8b       	std	Z+19, r19	; 0x13
   134a0:	22 8b       	std	Z+18, r18	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
   134a2:	29 96       	adiw	r28, 0x09	; 9
   134a4:	0f b6       	in	r0, 0x3f	; 63
   134a6:	f8 94       	cli
   134a8:	de bf       	out	0x3e, r29	; 62
   134aa:	0f be       	out	0x3f, r0	; 63
   134ac:	cd bf       	out	0x3d, r28	; 61
   134ae:	df 91       	pop	r29
   134b0:	cf 91       	pop	r28
   134b2:	1f 91       	pop	r17
   134b4:	0f 91       	pop	r16
   134b6:	08 95       	ret

000134b8 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
   134b8:	cf 93       	push	r28
   134ba:	df 93       	push	r29
   134bc:	1f 92       	push	r1
   134be:	cd b7       	in	r28, 0x3d	; 61
   134c0:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   134c2:	19 82       	std	Y+1, r1	; 0x01
   134c4:	13 c0       	rjmp	.+38     	; 0x134ec <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
   134c6:	89 81       	ldd	r24, Y+1	; 0x01
   134c8:	28 2f       	mov	r18, r24
   134ca:	30 e0       	ldi	r19, 0x00	; 0
   134cc:	c9 01       	movw	r24, r18
   134ce:	88 0f       	add	r24, r24
   134d0:	99 1f       	adc	r25, r25
   134d2:	88 0f       	add	r24, r24
   134d4:	99 1f       	adc	r25, r25
   134d6:	88 0f       	add	r24, r24
   134d8:	99 1f       	adc	r25, r25
   134da:	82 0f       	add	r24, r18
   134dc:	93 1f       	adc	r25, r19
   134de:	82 5b       	subi	r24, 0xB2	; 178
   134e0:	96 4f       	sbci	r25, 0xF6	; 246
   134e2:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   134e6:	89 81       	ldd	r24, Y+1	; 0x01
   134e8:	8f 5f       	subi	r24, 0xFF	; 255
   134ea:	89 83       	std	Y+1, r24	; 0x01
   134ec:	89 81       	ldd	r24, Y+1	; 0x01
   134ee:	84 30       	cpi	r24, 0x04	; 4
   134f0:	50 f3       	brcs	.-44     	; 0x134c6 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
   134f2:	82 e7       	ldi	r24, 0x72	; 114
   134f4:	99 e0       	ldi	r25, 0x09	; 9
   134f6:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
   134fa:	8b e7       	ldi	r24, 0x7B	; 123
   134fc:	99 e0       	ldi	r25, 0x09	; 9
   134fe:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
   13502:	88 e8       	ldi	r24, 0x88	; 136
   13504:	99 e0       	ldi	r25, 0x09	; 9
   13506:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
   1350a:	81 e9       	ldi	r24, 0x91	; 145
   1350c:	99 e0       	ldi	r25, 0x09	; 9
   1350e:	0e 94 d5 87 	call	0x10faa	; 0x10faa <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   13512:	82 e7       	ldi	r24, 0x72	; 114
   13514:	99 e0       	ldi	r25, 0x09	; 9
   13516:	90 93 85 09 	sts	0x0985, r25
   1351a:	80 93 84 09 	sts	0x0984, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   1351e:	8b e7       	ldi	r24, 0x7B	; 123
   13520:	99 e0       	ldi	r25, 0x09	; 9
   13522:	90 93 87 09 	sts	0x0987, r25
   13526:	80 93 86 09 	sts	0x0986, r24
}
   1352a:	0f 90       	pop	r0
   1352c:	df 91       	pop	r29
   1352e:	cf 91       	pop	r28
   13530:	08 95       	ret

00013532 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   13532:	cf 93       	push	r28
   13534:	df 93       	push	r29
   13536:	00 d0       	rcall	.+0      	; 0x13538 <prvCheckTasksWaitingTermination+0x6>
   13538:	1f 92       	push	r1
   1353a:	cd b7       	in	r28, 0x3d	; 61
   1353c:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
   1353e:	2f c0       	rjmp	.+94     	; 0x1359e <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
   13540:	0e 94 a1 96 	call	0x12d42	; 0x12d42 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   13544:	90 91 91 09 	lds	r25, 0x0991
   13548:	81 e0       	ldi	r24, 0x01	; 1
   1354a:	99 23       	and	r25, r25
   1354c:	09 f0       	breq	.+2      	; 0x13550 <prvCheckTasksWaitingTermination+0x1e>
   1354e:	80 e0       	ldi	r24, 0x00	; 0
   13550:	89 83       	std	Y+1, r24	; 0x01
			xTaskResumeAll();
   13552:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
   13556:	89 81       	ldd	r24, Y+1	; 0x01
   13558:	88 23       	and	r24, r24
   1355a:	09 f5       	brne	.+66     	; 0x1359e <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
   1355c:	0f b6       	in	r0, 0x3f	; 63
   1355e:	f8 94       	cli
   13560:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
   13562:	80 91 96 09 	lds	r24, 0x0996
   13566:	90 91 97 09 	lds	r25, 0x0997
   1356a:	fc 01       	movw	r30, r24
   1356c:	86 81       	ldd	r24, Z+6	; 0x06
   1356e:	97 81       	ldd	r25, Z+7	; 0x07
   13570:	9b 83       	std	Y+3, r25	; 0x03
   13572:	8a 83       	std	Y+2, r24	; 0x02
					uxListRemove( &( pxTCB->xGenericListItem ) );
   13574:	8a 81       	ldd	r24, Y+2	; 0x02
   13576:	9b 81       	ldd	r25, Y+3	; 0x03
   13578:	02 96       	adiw	r24, 0x02	; 2
   1357a:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
					--uxCurrentNumberOfTasks;
   1357e:	80 91 9d 09 	lds	r24, 0x099D
   13582:	81 50       	subi	r24, 0x01	; 1
   13584:	80 93 9d 09 	sts	0x099D, r24
					--uxTasksDeleted;
   13588:	80 91 9a 09 	lds	r24, 0x099A
   1358c:	81 50       	subi	r24, 0x01	; 1
   1358e:	80 93 9a 09 	sts	0x099A, r24
				}
				taskEXIT_CRITICAL();
   13592:	0f 90       	pop	r0
   13594:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
   13596:	8a 81       	ldd	r24, Y+2	; 0x02
   13598:	9b 81       	ldd	r25, Y+3	; 0x03
   1359a:	0e 94 bd 9b 	call	0x1377a	; 0x1377a <prvDeleteTCB>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
   1359e:	80 91 9a 09 	lds	r24, 0x099A
   135a2:	88 23       	and	r24, r24
   135a4:	69 f6       	brne	.-102    	; 0x13540 <prvCheckTasksWaitingTermination+0xe>
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
   135a6:	0f 90       	pop	r0
   135a8:	0f 90       	pop	r0
   135aa:	0f 90       	pop	r0
   135ac:	df 91       	pop	r29
   135ae:	cf 91       	pop	r28
   135b0:	08 95       	ret

000135b2 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
   135b2:	cf 93       	push	r28
   135b4:	df 93       	push	r29
   135b6:	00 d0       	rcall	.+0      	; 0x135b8 <prvAddCurrentTaskToDelayedList+0x6>
   135b8:	cd b7       	in	r28, 0x3d	; 61
   135ba:	de b7       	in	r29, 0x3e	; 62
   135bc:	9a 83       	std	Y+2, r25	; 0x02
   135be:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   135c0:	80 91 4c 09 	lds	r24, 0x094C
   135c4:	90 91 4d 09 	lds	r25, 0x094D
   135c8:	29 81       	ldd	r18, Y+1	; 0x01
   135ca:	3a 81       	ldd	r19, Y+2	; 0x02
   135cc:	fc 01       	movw	r30, r24
   135ce:	33 83       	std	Z+3, r19	; 0x03
   135d0:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
   135d2:	80 91 9e 09 	lds	r24, 0x099E
   135d6:	90 91 9f 09 	lds	r25, 0x099F
   135da:	29 81       	ldd	r18, Y+1	; 0x01
   135dc:	3a 81       	ldd	r19, Y+2	; 0x02
   135de:	28 17       	cp	r18, r24
   135e0:	39 07       	cpc	r19, r25
   135e2:	78 f4       	brcc	.+30     	; 0x13602 <prvAddCurrentTaskToDelayedList+0x50>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   135e4:	80 91 4c 09 	lds	r24, 0x094C
   135e8:	90 91 4d 09 	lds	r25, 0x094D
   135ec:	9c 01       	movw	r18, r24
   135ee:	2e 5f       	subi	r18, 0xFE	; 254
   135f0:	3f 4f       	sbci	r19, 0xFF	; 255
   135f2:	80 91 86 09 	lds	r24, 0x0986
   135f6:	90 91 87 09 	lds	r25, 0x0987
   135fa:	b9 01       	movw	r22, r18
   135fc:	0e 94 73 88 	call	0x110e6	; 0x110e6 <vListInsert>
   13600:	1d c0       	rjmp	.+58     	; 0x1363c <prvAddCurrentTaskToDelayedList+0x8a>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   13602:	80 91 4c 09 	lds	r24, 0x094C
   13606:	90 91 4d 09 	lds	r25, 0x094D
   1360a:	9c 01       	movw	r18, r24
   1360c:	2e 5f       	subi	r18, 0xFE	; 254
   1360e:	3f 4f       	sbci	r19, 0xFF	; 255
   13610:	80 91 84 09 	lds	r24, 0x0984
   13614:	90 91 85 09 	lds	r25, 0x0985
   13618:	b9 01       	movw	r22, r18
   1361a:	0e 94 73 88 	call	0x110e6	; 0x110e6 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
   1361e:	80 91 46 02 	lds	r24, 0x0246
   13622:	90 91 47 02 	lds	r25, 0x0247
   13626:	29 81       	ldd	r18, Y+1	; 0x01
   13628:	3a 81       	ldd	r19, Y+2	; 0x02
   1362a:	28 17       	cp	r18, r24
   1362c:	39 07       	cpc	r19, r25
   1362e:	30 f4       	brcc	.+12     	; 0x1363c <prvAddCurrentTaskToDelayedList+0x8a>
		{
			xNextTaskUnblockTime = xTimeToWake;
   13630:	89 81       	ldd	r24, Y+1	; 0x01
   13632:	9a 81       	ldd	r25, Y+2	; 0x02
   13634:	90 93 47 02 	sts	0x0247, r25
   13638:	80 93 46 02 	sts	0x0246, r24
		}
	}
}
   1363c:	0f 90       	pop	r0
   1363e:	0f 90       	pop	r0
   13640:	df 91       	pop	r29
   13642:	cf 91       	pop	r28
   13644:	08 95       	ret

00013646 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
   13646:	cf 93       	push	r28
   13648:	df 93       	push	r29
   1364a:	00 d0       	rcall	.+0      	; 0x1364c <prvAllocateTCBAndStack+0x6>
   1364c:	00 d0       	rcall	.+0      	; 0x1364e <prvAllocateTCBAndStack+0x8>
   1364e:	00 d0       	rcall	.+0      	; 0x13650 <prvAllocateTCBAndStack+0xa>
   13650:	cd b7       	in	r28, 0x3d	; 61
   13652:	de b7       	in	r29, 0x3e	; 62
   13654:	9c 83       	std	Y+4, r25	; 0x04
   13656:	8b 83       	std	Y+3, r24	; 0x03
   13658:	7e 83       	std	Y+6, r23	; 0x06
   1365a:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   1365c:	82 e2       	ldi	r24, 0x22	; 34
   1365e:	90 e0       	ldi	r25, 0x00	; 0
   13660:	0e 94 a2 87 	call	0x10f44	; 0x10f44 <pvPortMalloc>
   13664:	9a 83       	std	Y+2, r25	; 0x02
   13666:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
   13668:	89 81       	ldd	r24, Y+1	; 0x01
   1366a:	9a 81       	ldd	r25, Y+2	; 0x02
   1366c:	00 97       	sbiw	r24, 0x00	; 0
   1366e:	51 f1       	breq	.+84     	; 0x136c4 <prvAllocateTCBAndStack+0x7e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   13670:	8d 81       	ldd	r24, Y+5	; 0x05
   13672:	9e 81       	ldd	r25, Y+6	; 0x06
   13674:	00 97       	sbiw	r24, 0x00	; 0
   13676:	29 f4       	brne	.+10     	; 0x13682 <prvAllocateTCBAndStack+0x3c>
   13678:	8b 81       	ldd	r24, Y+3	; 0x03
   1367a:	9c 81       	ldd	r25, Y+4	; 0x04
   1367c:	0e 94 a2 87 	call	0x10f44	; 0x10f44 <pvPortMalloc>
   13680:	02 c0       	rjmp	.+4      	; 0x13686 <prvAllocateTCBAndStack+0x40>
   13682:	8d 81       	ldd	r24, Y+5	; 0x05
   13684:	9e 81       	ldd	r25, Y+6	; 0x06
   13686:	29 81       	ldd	r18, Y+1	; 0x01
   13688:	3a 81       	ldd	r19, Y+2	; 0x02
   1368a:	f9 01       	movw	r30, r18
   1368c:	90 8f       	std	Z+24, r25	; 0x18
   1368e:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
   13690:	89 81       	ldd	r24, Y+1	; 0x01
   13692:	9a 81       	ldd	r25, Y+2	; 0x02
   13694:	fc 01       	movw	r30, r24
   13696:	87 89       	ldd	r24, Z+23	; 0x17
   13698:	90 8d       	ldd	r25, Z+24	; 0x18
   1369a:	00 97       	sbiw	r24, 0x00	; 0
   1369c:	39 f4       	brne	.+14     	; 0x136ac <prvAllocateTCBAndStack+0x66>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
   1369e:	89 81       	ldd	r24, Y+1	; 0x01
   136a0:	9a 81       	ldd	r25, Y+2	; 0x02
   136a2:	0e 94 bd 87 	call	0x10f7a	; 0x10f7a <vPortFree>
			pxNewTCB = NULL;
   136a6:	1a 82       	std	Y+2, r1	; 0x02
   136a8:	19 82       	std	Y+1, r1	; 0x01
   136aa:	0c c0       	rjmp	.+24     	; 0x136c4 <prvAllocateTCBAndStack+0x7e>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
   136ac:	89 81       	ldd	r24, Y+1	; 0x01
   136ae:	9a 81       	ldd	r25, Y+2	; 0x02
   136b0:	fc 01       	movw	r30, r24
   136b2:	87 89       	ldd	r24, Z+23	; 0x17
   136b4:	90 8d       	ldd	r25, Z+24	; 0x18
   136b6:	2b 81       	ldd	r18, Y+3	; 0x03
   136b8:	3c 81       	ldd	r19, Y+4	; 0x04
   136ba:	a9 01       	movw	r20, r18
   136bc:	65 ea       	ldi	r22, 0xA5	; 165
   136be:	70 e0       	ldi	r23, 0x00	; 0
   136c0:	0e 94 19 b1 	call	0x16232	; 0x16232 <memset>
		}
	}

	return pxNewTCB;
   136c4:	89 81       	ldd	r24, Y+1	; 0x01
   136c6:	9a 81       	ldd	r25, Y+2	; 0x02
}
   136c8:	26 96       	adiw	r28, 0x06	; 6
   136ca:	0f b6       	in	r0, 0x3f	; 63
   136cc:	f8 94       	cli
   136ce:	de bf       	out	0x3e, r29	; 62
   136d0:	0f be       	out	0x3f, r0	; 63
   136d2:	cd bf       	out	0x3d, r28	; 61
   136d4:	df 91       	pop	r29
   136d6:	cf 91       	pop	r28
   136d8:	08 95       	ret

000136da <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
   136da:	0f 93       	push	r16
   136dc:	1f 93       	push	r17
   136de:	cf 93       	push	r28
   136e0:	df 93       	push	r29
   136e2:	00 d0       	rcall	.+0      	; 0x136e4 <usTaskCheckFreeStackSpace+0xa>
   136e4:	cd b7       	in	r28, 0x3d	; 61
   136e6:	de b7       	in	r29, 0x3e	; 62
   136e8:	9a 83       	std	Y+2, r25	; 0x02
   136ea:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
   136ec:	00 e0       	ldi	r16, 0x00	; 0
   136ee:	10 e0       	ldi	r17, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
   136f0:	07 c0       	rjmp	.+14     	; 0x13700 <usTaskCheckFreeStackSpace+0x26>
		{
			pucStackByte -= portSTACK_GROWTH;
   136f2:	89 81       	ldd	r24, Y+1	; 0x01
   136f4:	9a 81       	ldd	r25, Y+2	; 0x02
   136f6:	01 96       	adiw	r24, 0x01	; 1
   136f8:	9a 83       	std	Y+2, r25	; 0x02
   136fa:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
   136fc:	0f 5f       	subi	r16, 0xFF	; 255
   136fe:	1f 4f       	sbci	r17, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
   13700:	89 81       	ldd	r24, Y+1	; 0x01
   13702:	9a 81       	ldd	r25, Y+2	; 0x02
   13704:	fc 01       	movw	r30, r24
   13706:	80 81       	ld	r24, Z
   13708:	85 3a       	cpi	r24, 0xA5	; 165
   1370a:	99 f3       	breq	.-26     	; 0x136f2 <usTaskCheckFreeStackSpace+0x18>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
   1370c:	c8 01       	movw	r24, r16
	}
   1370e:	0f 90       	pop	r0
   13710:	0f 90       	pop	r0
   13712:	df 91       	pop	r29
   13714:	cf 91       	pop	r28
   13716:	1f 91       	pop	r17
   13718:	0f 91       	pop	r16
   1371a:	08 95       	ret

0001371c <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
   1371c:	cf 93       	push	r28
   1371e:	df 93       	push	r29
   13720:	cd b7       	in	r28, 0x3d	; 61
   13722:	de b7       	in	r29, 0x3e	; 62
   13724:	27 97       	sbiw	r28, 0x07	; 7
   13726:	0f b6       	in	r0, 0x3f	; 63
   13728:	f8 94       	cli
   1372a:	de bf       	out	0x3e, r29	; 62
   1372c:	0f be       	out	0x3f, r0	; 63
   1372e:	cd bf       	out	0x3d, r28	; 61
   13730:	9f 83       	std	Y+7, r25	; 0x07
   13732:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
   13734:	8e 81       	ldd	r24, Y+6	; 0x06
   13736:	9f 81       	ldd	r25, Y+7	; 0x07
   13738:	00 97       	sbiw	r24, 0x00	; 0
   1373a:	29 f4       	brne	.+10     	; 0x13746 <uxTaskGetStackHighWaterMark+0x2a>
   1373c:	80 91 4c 09 	lds	r24, 0x094C
   13740:	90 91 4d 09 	lds	r25, 0x094D
   13744:	02 c0       	rjmp	.+4      	; 0x1374a <uxTaskGetStackHighWaterMark+0x2e>
   13746:	8e 81       	ldd	r24, Y+6	; 0x06
   13748:	9f 81       	ldd	r25, Y+7	; 0x07
   1374a:	9a 83       	std	Y+2, r25	; 0x02
   1374c:	89 83       	std	Y+1, r24	; 0x01

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
   1374e:	89 81       	ldd	r24, Y+1	; 0x01
   13750:	9a 81       	ldd	r25, Y+2	; 0x02
   13752:	fc 01       	movw	r30, r24
   13754:	87 89       	ldd	r24, Z+23	; 0x17
   13756:	90 8d       	ldd	r25, Z+24	; 0x18
   13758:	9c 83       	std	Y+4, r25	; 0x04
   1375a:	8b 83       	std	Y+3, r24	; 0x03
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
   1375c:	8b 81       	ldd	r24, Y+3	; 0x03
   1375e:	9c 81       	ldd	r25, Y+4	; 0x04
   13760:	0e 94 6d 9b 	call	0x136da	; 0x136da <usTaskCheckFreeStackSpace>
   13764:	8d 83       	std	Y+5, r24	; 0x05

		return uxReturn;
   13766:	8d 81       	ldd	r24, Y+5	; 0x05
	}
   13768:	27 96       	adiw	r28, 0x07	; 7
   1376a:	0f b6       	in	r0, 0x3f	; 63
   1376c:	f8 94       	cli
   1376e:	de bf       	out	0x3e, r29	; 62
   13770:	0f be       	out	0x3f, r0	; 63
   13772:	cd bf       	out	0x3d, r28	; 61
   13774:	df 91       	pop	r29
   13776:	cf 91       	pop	r28
   13778:	08 95       	ret

0001377a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   1377a:	cf 93       	push	r28
   1377c:	df 93       	push	r29
   1377e:	00 d0       	rcall	.+0      	; 0x13780 <prvDeleteTCB+0x6>
   13780:	cd b7       	in	r28, 0x3d	; 61
   13782:	de b7       	in	r29, 0x3e	; 62
   13784:	9a 83       	std	Y+2, r25	; 0x02
   13786:	89 83       	std	Y+1, r24	; 0x01
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   13788:	89 81       	ldd	r24, Y+1	; 0x01
   1378a:	9a 81       	ldd	r25, Y+2	; 0x02
   1378c:	fc 01       	movw	r30, r24
   1378e:	87 89       	ldd	r24, Z+23	; 0x17
   13790:	90 8d       	ldd	r25, Z+24	; 0x18
   13792:	0e 94 bd 87 	call	0x10f7a	; 0x10f7a <vPortFree>
		vPortFree( pxTCB );
   13796:	89 81       	ldd	r24, Y+1	; 0x01
   13798:	9a 81       	ldd	r25, Y+2	; 0x02
   1379a:	0e 94 bd 87 	call	0x10f7a	; 0x10f7a <vPortFree>
	}
   1379e:	0f 90       	pop	r0
   137a0:	0f 90       	pop	r0
   137a2:	df 91       	pop	r29
   137a4:	cf 91       	pop	r28
   137a6:	08 95       	ret

000137a8 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
   137a8:	cf 93       	push	r28
   137aa:	df 93       	push	r29
   137ac:	00 d0       	rcall	.+0      	; 0x137ae <xTaskGetCurrentTaskHandle+0x6>
   137ae:	cd b7       	in	r28, 0x3d	; 61
   137b0:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
   137b2:	80 91 4c 09 	lds	r24, 0x094C
   137b6:	90 91 4d 09 	lds	r25, 0x094D
   137ba:	9a 83       	std	Y+2, r25	; 0x02
   137bc:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
   137be:	89 81       	ldd	r24, Y+1	; 0x01
   137c0:	9a 81       	ldd	r25, Y+2	; 0x02
	}
   137c2:	0f 90       	pop	r0
   137c4:	0f 90       	pop	r0
   137c6:	df 91       	pop	r29
   137c8:	cf 91       	pop	r28
   137ca:	08 95       	ret

000137cc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
   137cc:	cf 93       	push	r28
   137ce:	df 93       	push	r29
   137d0:	00 d0       	rcall	.+0      	; 0x137d2 <vTaskPriorityInherit+0x6>
   137d2:	00 d0       	rcall	.+0      	; 0x137d4 <vTaskPriorityInherit+0x8>
   137d4:	cd b7       	in	r28, 0x3d	; 61
   137d6:	de b7       	in	r29, 0x3e	; 62
   137d8:	9c 83       	std	Y+4, r25	; 0x04
   137da:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   137dc:	8b 81       	ldd	r24, Y+3	; 0x03
   137de:	9c 81       	ldd	r25, Y+4	; 0x04
   137e0:	9a 83       	std	Y+2, r25	; 0x02
   137e2:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
   137e4:	8b 81       	ldd	r24, Y+3	; 0x03
   137e6:	9c 81       	ldd	r25, Y+4	; 0x04
   137e8:	00 97       	sbiw	r24, 0x00	; 0
   137ea:	09 f4       	brne	.+2      	; 0x137ee <vTaskPriorityInherit+0x22>
   137ec:	78 c0       	rjmp	.+240    	; 0x138de <vTaskPriorityInherit+0x112>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   137ee:	89 81       	ldd	r24, Y+1	; 0x01
   137f0:	9a 81       	ldd	r25, Y+2	; 0x02
   137f2:	fc 01       	movw	r30, r24
   137f4:	26 89       	ldd	r18, Z+22	; 0x16
   137f6:	80 91 4c 09 	lds	r24, 0x094C
   137fa:	90 91 4d 09 	lds	r25, 0x094D
   137fe:	fc 01       	movw	r30, r24
   13800:	86 89       	ldd	r24, Z+22	; 0x16
   13802:	28 17       	cp	r18, r24
   13804:	08 f0       	brcs	.+2      	; 0x13808 <vTaskPriorityInherit+0x3c>
   13806:	6b c0       	rjmp	.+214    	; 0x138de <vTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
   13808:	80 91 4c 09 	lds	r24, 0x094C
   1380c:	90 91 4d 09 	lds	r25, 0x094D
   13810:	fc 01       	movw	r30, r24
   13812:	86 89       	ldd	r24, Z+22	; 0x16
   13814:	88 2f       	mov	r24, r24
   13816:	90 e0       	ldi	r25, 0x00	; 0
   13818:	24 e0       	ldi	r18, 0x04	; 4
   1381a:	30 e0       	ldi	r19, 0x00	; 0
   1381c:	28 1b       	sub	r18, r24
   1381e:	39 0b       	sbc	r19, r25
   13820:	89 81       	ldd	r24, Y+1	; 0x01
   13822:	9a 81       	ldd	r25, Y+2	; 0x02
   13824:	fc 01       	movw	r30, r24
   13826:	35 87       	std	Z+13, r19	; 0x0d
   13828:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   1382a:	89 81       	ldd	r24, Y+1	; 0x01
   1382c:	9a 81       	ldd	r25, Y+2	; 0x02
   1382e:	fc 01       	movw	r30, r24
   13830:	42 85       	ldd	r20, Z+10	; 0x0a
   13832:	53 85       	ldd	r21, Z+11	; 0x0b
   13834:	89 81       	ldd	r24, Y+1	; 0x01
   13836:	9a 81       	ldd	r25, Y+2	; 0x02
   13838:	fc 01       	movw	r30, r24
   1383a:	86 89       	ldd	r24, Z+22	; 0x16
   1383c:	28 2f       	mov	r18, r24
   1383e:	30 e0       	ldi	r19, 0x00	; 0
   13840:	c9 01       	movw	r24, r18
   13842:	88 0f       	add	r24, r24
   13844:	99 1f       	adc	r25, r25
   13846:	88 0f       	add	r24, r24
   13848:	99 1f       	adc	r25, r25
   1384a:	88 0f       	add	r24, r24
   1384c:	99 1f       	adc	r25, r25
   1384e:	82 0f       	add	r24, r18
   13850:	93 1f       	adc	r25, r19
   13852:	82 5b       	subi	r24, 0xB2	; 178
   13854:	96 4f       	sbci	r25, 0xF6	; 246
   13856:	48 17       	cp	r20, r24
   13858:	59 07       	cpc	r21, r25
   1385a:	b9 f5       	brne	.+110    	; 0x138ca <vTaskPriorityInherit+0xfe>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   1385c:	89 81       	ldd	r24, Y+1	; 0x01
   1385e:	9a 81       	ldd	r25, Y+2	; 0x02
   13860:	02 96       	adiw	r24, 0x02	; 2
   13862:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   13866:	80 91 4c 09 	lds	r24, 0x094C
   1386a:	90 91 4d 09 	lds	r25, 0x094D
   1386e:	fc 01       	movw	r30, r24
   13870:	26 89       	ldd	r18, Z+22	; 0x16
   13872:	89 81       	ldd	r24, Y+1	; 0x01
   13874:	9a 81       	ldd	r25, Y+2	; 0x02
   13876:	fc 01       	movw	r30, r24
   13878:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
   1387a:	89 81       	ldd	r24, Y+1	; 0x01
   1387c:	9a 81       	ldd	r25, Y+2	; 0x02
   1387e:	fc 01       	movw	r30, r24
   13880:	96 89       	ldd	r25, Z+22	; 0x16
   13882:	80 91 a1 09 	lds	r24, 0x09A1
   13886:	89 17       	cp	r24, r25
   13888:	30 f4       	brcc	.+12     	; 0x13896 <vTaskPriorityInherit+0xca>
   1388a:	89 81       	ldd	r24, Y+1	; 0x01
   1388c:	9a 81       	ldd	r25, Y+2	; 0x02
   1388e:	fc 01       	movw	r30, r24
   13890:	86 89       	ldd	r24, Z+22	; 0x16
   13892:	80 93 a1 09 	sts	0x09A1, r24
   13896:	89 81       	ldd	r24, Y+1	; 0x01
   13898:	9a 81       	ldd	r25, Y+2	; 0x02
   1389a:	ac 01       	movw	r20, r24
   1389c:	4e 5f       	subi	r20, 0xFE	; 254
   1389e:	5f 4f       	sbci	r21, 0xFF	; 255
   138a0:	89 81       	ldd	r24, Y+1	; 0x01
   138a2:	9a 81       	ldd	r25, Y+2	; 0x02
   138a4:	fc 01       	movw	r30, r24
   138a6:	86 89       	ldd	r24, Z+22	; 0x16
   138a8:	28 2f       	mov	r18, r24
   138aa:	30 e0       	ldi	r19, 0x00	; 0
   138ac:	c9 01       	movw	r24, r18
   138ae:	88 0f       	add	r24, r24
   138b0:	99 1f       	adc	r25, r25
   138b2:	88 0f       	add	r24, r24
   138b4:	99 1f       	adc	r25, r25
   138b6:	88 0f       	add	r24, r24
   138b8:	99 1f       	adc	r25, r25
   138ba:	82 0f       	add	r24, r18
   138bc:	93 1f       	adc	r25, r19
   138be:	82 5b       	subi	r24, 0xB2	; 178
   138c0:	96 4f       	sbci	r25, 0xF6	; 246
   138c2:	ba 01       	movw	r22, r20
   138c4:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>
   138c8:	0a c0       	rjmp	.+20     	; 0x138de <vTaskPriorityInherit+0x112>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   138ca:	80 91 4c 09 	lds	r24, 0x094C
   138ce:	90 91 4d 09 	lds	r25, 0x094D
   138d2:	fc 01       	movw	r30, r24
   138d4:	26 89       	ldd	r18, Z+22	; 0x16
   138d6:	89 81       	ldd	r24, Y+1	; 0x01
   138d8:	9a 81       	ldd	r25, Y+2	; 0x02
   138da:	fc 01       	movw	r30, r24
   138dc:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
   138de:	0f 90       	pop	r0
   138e0:	0f 90       	pop	r0
   138e2:	0f 90       	pop	r0
   138e4:	0f 90       	pop	r0
   138e6:	df 91       	pop	r29
   138e8:	cf 91       	pop	r28
   138ea:	08 95       	ret

000138ec <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
   138ec:	cf 93       	push	r28
   138ee:	df 93       	push	r29
   138f0:	00 d0       	rcall	.+0      	; 0x138f2 <vTaskPriorityDisinherit+0x6>
   138f2:	00 d0       	rcall	.+0      	; 0x138f4 <vTaskPriorityDisinherit+0x8>
   138f4:	cd b7       	in	r28, 0x3d	; 61
   138f6:	de b7       	in	r29, 0x3e	; 62
   138f8:	9c 83       	std	Y+4, r25	; 0x04
   138fa:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   138fc:	8b 81       	ldd	r24, Y+3	; 0x03
   138fe:	9c 81       	ldd	r25, Y+4	; 0x04
   13900:	9a 83       	std	Y+2, r25	; 0x02
   13902:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
   13904:	8b 81       	ldd	r24, Y+3	; 0x03
   13906:	9c 81       	ldd	r25, Y+4	; 0x04
   13908:	00 97       	sbiw	r24, 0x00	; 0
   1390a:	09 f4       	brne	.+2      	; 0x1390e <vTaskPriorityDisinherit+0x22>
   1390c:	4e c0       	rjmp	.+156    	; 0x139aa <vTaskPriorityDisinherit+0xbe>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   1390e:	89 81       	ldd	r24, Y+1	; 0x01
   13910:	9a 81       	ldd	r25, Y+2	; 0x02
   13912:	fc 01       	movw	r30, r24
   13914:	26 89       	ldd	r18, Z+22	; 0x16
   13916:	89 81       	ldd	r24, Y+1	; 0x01
   13918:	9a 81       	ldd	r25, Y+2	; 0x02
   1391a:	fc 01       	movw	r30, r24
   1391c:	81 a1       	ldd	r24, Z+33	; 0x21
   1391e:	28 17       	cp	r18, r24
   13920:	09 f4       	brne	.+2      	; 0x13924 <vTaskPriorityDisinherit+0x38>
   13922:	43 c0       	rjmp	.+134    	; 0x139aa <vTaskPriorityDisinherit+0xbe>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   13924:	89 81       	ldd	r24, Y+1	; 0x01
   13926:	9a 81       	ldd	r25, Y+2	; 0x02
   13928:	02 96       	adiw	r24, 0x02	; 2
   1392a:	0e 94 ec 88 	call	0x111d8	; 0x111d8 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
   1392e:	89 81       	ldd	r24, Y+1	; 0x01
   13930:	9a 81       	ldd	r25, Y+2	; 0x02
   13932:	fc 01       	movw	r30, r24
   13934:	21 a1       	ldd	r18, Z+33	; 0x21
   13936:	89 81       	ldd	r24, Y+1	; 0x01
   13938:	9a 81       	ldd	r25, Y+2	; 0x02
   1393a:	fc 01       	movw	r30, r24
   1393c:	26 8b       	std	Z+22, r18	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
   1393e:	89 81       	ldd	r24, Y+1	; 0x01
   13940:	9a 81       	ldd	r25, Y+2	; 0x02
   13942:	fc 01       	movw	r30, r24
   13944:	86 89       	ldd	r24, Z+22	; 0x16
   13946:	88 2f       	mov	r24, r24
   13948:	90 e0       	ldi	r25, 0x00	; 0
   1394a:	24 e0       	ldi	r18, 0x04	; 4
   1394c:	30 e0       	ldi	r19, 0x00	; 0
   1394e:	28 1b       	sub	r18, r24
   13950:	39 0b       	sbc	r19, r25
   13952:	89 81       	ldd	r24, Y+1	; 0x01
   13954:	9a 81       	ldd	r25, Y+2	; 0x02
   13956:	fc 01       	movw	r30, r24
   13958:	35 87       	std	Z+13, r19	; 0x0d
   1395a:	24 87       	std	Z+12, r18	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
   1395c:	89 81       	ldd	r24, Y+1	; 0x01
   1395e:	9a 81       	ldd	r25, Y+2	; 0x02
   13960:	fc 01       	movw	r30, r24
   13962:	96 89       	ldd	r25, Z+22	; 0x16
   13964:	80 91 a1 09 	lds	r24, 0x09A1
   13968:	89 17       	cp	r24, r25
   1396a:	30 f4       	brcc	.+12     	; 0x13978 <vTaskPriorityDisinherit+0x8c>
   1396c:	89 81       	ldd	r24, Y+1	; 0x01
   1396e:	9a 81       	ldd	r25, Y+2	; 0x02
   13970:	fc 01       	movw	r30, r24
   13972:	86 89       	ldd	r24, Z+22	; 0x16
   13974:	80 93 a1 09 	sts	0x09A1, r24
   13978:	89 81       	ldd	r24, Y+1	; 0x01
   1397a:	9a 81       	ldd	r25, Y+2	; 0x02
   1397c:	ac 01       	movw	r20, r24
   1397e:	4e 5f       	subi	r20, 0xFE	; 254
   13980:	5f 4f       	sbci	r21, 0xFF	; 255
   13982:	89 81       	ldd	r24, Y+1	; 0x01
   13984:	9a 81       	ldd	r25, Y+2	; 0x02
   13986:	fc 01       	movw	r30, r24
   13988:	86 89       	ldd	r24, Z+22	; 0x16
   1398a:	28 2f       	mov	r18, r24
   1398c:	30 e0       	ldi	r19, 0x00	; 0
   1398e:	c9 01       	movw	r24, r18
   13990:	88 0f       	add	r24, r24
   13992:	99 1f       	adc	r25, r25
   13994:	88 0f       	add	r24, r24
   13996:	99 1f       	adc	r25, r25
   13998:	88 0f       	add	r24, r24
   1399a:	99 1f       	adc	r25, r25
   1399c:	82 0f       	add	r24, r18
   1399e:	93 1f       	adc	r25, r19
   139a0:	82 5b       	subi	r24, 0xB2	; 178
   139a2:	96 4f       	sbci	r25, 0xF6	; 246
   139a4:	ba 01       	movw	r22, r20
   139a6:	0e 94 1b 88 	call	0x11036	; 0x11036 <vListInsertEnd>
			}
		}
	}
   139aa:	0f 90       	pop	r0
   139ac:	0f 90       	pop	r0
   139ae:	0f 90       	pop	r0
   139b0:	0f 90       	pop	r0
   139b2:	df 91       	pop	r29
   139b4:	cf 91       	pop	r28
   139b6:	08 95       	ret

000139b8 <freeHeap>:
 */
#include <FreeRTOS_AVR.h>
/** current begining of heap */
extern char *__brkval;
/** \return free heap size */
size_t freeHeap() {
   139b8:	cf 93       	push	r28
   139ba:	df 93       	push	r29
   139bc:	cd b7       	in	r28, 0x3d	; 61
   139be:	de b7       	in	r29, 0x3e	; 62
#if defined(CORE_TEENSY) || (ARDUINO > 103 && ARDUINO != 151)
  return (char*)RAMEND - __brkval +1;
#else  // CORE_TEENSY
/** initial begining of heap */
 extern char *__malloc_heap_start;
  return (char*)RAMEND - (__brkval ? __brkval : __malloc_heap_start) + 1;
   139c0:	80 91 ae 09 	lds	r24, 0x09AE
   139c4:	90 91 af 09 	lds	r25, 0x09AF
   139c8:	00 97       	sbiw	r24, 0x00	; 0
   139ca:	59 f0       	breq	.+22     	; 0x139e2 <freeHeap+0x2a>
   139cc:	80 91 ae 09 	lds	r24, 0x09AE
   139d0:	90 91 af 09 	lds	r25, 0x09AF
   139d4:	20 e0       	ldi	r18, 0x00	; 0
   139d6:	39 e0       	ldi	r19, 0x09	; 9
   139d8:	a9 01       	movw	r20, r18
   139da:	48 1b       	sub	r20, r24
   139dc:	59 0b       	sbc	r21, r25
   139de:	ca 01       	movw	r24, r20
   139e0:	0a c0       	rjmp	.+20     	; 0x139f6 <freeHeap+0x3e>
   139e2:	80 91 4a 02 	lds	r24, 0x024A
   139e6:	90 91 4b 02 	lds	r25, 0x024B
   139ea:	20 e0       	ldi	r18, 0x00	; 0
   139ec:	39 e0       	ldi	r19, 0x09	; 9
   139ee:	a9 01       	movw	r20, r18
   139f0:	48 1b       	sub	r20, r24
   139f2:	59 0b       	sbc	r21, r25
   139f4:	ca 01       	movw	r24, r20
#endif  // CORE_TEENSY
}
   139f6:	df 91       	pop	r29
   139f8:	cf 91       	pop	r28
   139fa:	08 95       	ret

000139fc <_Z12vPrintStringPKc>:
#include <Arduino.h>
#include "FreeRTOS_AVR.h"
//#include "task.h"

void vPrintString( const portCHAR *pcString )
{
   139fc:	cf 93       	push	r28
   139fe:	df 93       	push	r29
   13a00:	00 d0       	rcall	.+0      	; 0x13a02 <_Z12vPrintStringPKc+0x6>
   13a02:	cd b7       	in	r28, 0x3d	; 61
   13a04:	de b7       	in	r29, 0x3e	; 62
   13a06:	9a 83       	std	Y+2, r25	; 0x02
   13a08:	89 83       	std	Y+1, r24	; 0x01
	/* Print the string, suspending the scheduler as method of mutual
	exclusion. */
	vTaskSuspendAll();
   13a0a:	0e 94 a1 96 	call	0x12d42	; 0x12d42 <vTaskSuspendAll>
	{
      Serial.print(pcString);
   13a0e:	89 81       	ldd	r24, Y+1	; 0x01
   13a10:	9a 81       	ldd	r25, Y+2	; 0x02
   13a12:	bc 01       	movw	r22, r24
   13a14:	87 ec       	ldi	r24, 0xC7	; 199
   13a16:	98 e0       	ldi	r25, 0x08	; 8
   13a18:	0e 94 0b 5c 	call	0xb816	; 0xb816 <_ZN5Print5printEPKc>
      Serial.flush();
   13a1c:	87 ec       	ldi	r24, 0xC7	; 199
   13a1e:	98 e0       	ldi	r25, 0x08	; 8
   13a20:	0e 94 60 58 	call	0xb0c0	; 0xb0c0 <_ZN14HardwareSerial5flushEv>
	//	printf( "%s", pcString );
	//	fflush( stdout );
	}
	xTaskResumeAll();
   13a24:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>

    /* Allow any key to stop the application running.  A real application that
    actually used the key value should protect access to the keyboard too. */
	if( Serial.available() )
   13a28:	87 ec       	ldi	r24, 0xC7	; 199
   13a2a:	98 e0       	ldi	r25, 0x08	; 8
   13a2c:	0e 94 a0 57 	call	0xaf40	; 0xaf40 <_ZN14HardwareSerial9availableEv>
   13a30:	21 e0       	ldi	r18, 0x01	; 1
   13a32:	00 97       	sbiw	r24, 0x00	; 0
   13a34:	09 f4       	brne	.+2      	; 0x13a38 <_Z12vPrintStringPKc+0x3c>
   13a36:	20 e0       	ldi	r18, 0x00	; 0
   13a38:	22 23       	and	r18, r18
   13a3a:	11 f0       	breq	.+4      	; 0x13a40 <_Z12vPrintStringPKc+0x44>
	{
		vTaskEndScheduler();
   13a3c:	0e 94 95 96 	call	0x12d2a	; 0x12d2a <vTaskEndScheduler>
	}
}
   13a40:	0f 90       	pop	r0
   13a42:	0f 90       	pop	r0
   13a44:	df 91       	pop	r29
   13a46:	cf 91       	pop	r28
   13a48:	08 95       	ret

00013a4a <_Z21vPrintStringAndNumberPKcm>:
/*-----------------------------------------------------------*/

void vPrintStringAndNumber( const portCHAR *pcString, unsigned portLONG ulValue )
{
   13a4a:	cf 93       	push	r28
   13a4c:	df 93       	push	r29
   13a4e:	00 d0       	rcall	.+0      	; 0x13a50 <_Z21vPrintStringAndNumberPKcm+0x6>
   13a50:	00 d0       	rcall	.+0      	; 0x13a52 <_Z21vPrintStringAndNumberPKcm+0x8>
   13a52:	00 d0       	rcall	.+0      	; 0x13a54 <_Z21vPrintStringAndNumberPKcm+0xa>
   13a54:	cd b7       	in	r28, 0x3d	; 61
   13a56:	de b7       	in	r29, 0x3e	; 62
   13a58:	9a 83       	std	Y+2, r25	; 0x02
   13a5a:	89 83       	std	Y+1, r24	; 0x01
   13a5c:	4b 83       	std	Y+3, r20	; 0x03
   13a5e:	5c 83       	std	Y+4, r21	; 0x04
   13a60:	6d 83       	std	Y+5, r22	; 0x05
   13a62:	7e 83       	std	Y+6, r23	; 0x06
	/* Print the string, suspending the scheduler as method of mutual
	exclusion. */
	vTaskSuspendAll();
   13a64:	0e 94 a1 96 	call	0x12d42	; 0x12d42 <vTaskSuspendAll>
	{
//		printf( "%s %lu\r\n", pcString, ulValue );
//		fflush( stdout );
      Serial.print(pcString);
   13a68:	89 81       	ldd	r24, Y+1	; 0x01
   13a6a:	9a 81       	ldd	r25, Y+2	; 0x02
   13a6c:	bc 01       	movw	r22, r24
   13a6e:	87 ec       	ldi	r24, 0xC7	; 199
   13a70:	98 e0       	ldi	r25, 0x08	; 8
   13a72:	0e 94 0b 5c 	call	0xb816	; 0xb816 <_ZN5Print5printEPKc>
      Serial.write(' ');
   13a76:	60 e2       	ldi	r22, 0x20	; 32
   13a78:	70 e0       	ldi	r23, 0x00	; 0
   13a7a:	87 ec       	ldi	r24, 0xC7	; 199
   13a7c:	98 e0       	ldi	r25, 0x08	; 8
   13a7e:	0e 94 7e ad 	call	0x15afc	; 0x15afc <_ZN14HardwareSerial5writeEi>
      Serial.println(ulValue);
   13a82:	8b 81       	ldd	r24, Y+3	; 0x03
   13a84:	9c 81       	ldd	r25, Y+4	; 0x04
   13a86:	ad 81       	ldd	r26, Y+5	; 0x05
   13a88:	be 81       	ldd	r27, Y+6	; 0x06
   13a8a:	2a e0       	ldi	r18, 0x0A	; 10
   13a8c:	30 e0       	ldi	r19, 0x00	; 0
   13a8e:	ac 01       	movw	r20, r24
   13a90:	bd 01       	movw	r22, r26
   13a92:	87 ec       	ldi	r24, 0xC7	; 199
   13a94:	98 e0       	ldi	r25, 0x08	; 8
   13a96:	0e 94 2c 5f 	call	0xbe58	; 0xbe58 <_ZN5Print7printlnEmi>
      Serial.flush();
   13a9a:	87 ec       	ldi	r24, 0xC7	; 199
   13a9c:	98 e0       	ldi	r25, 0x08	; 8
   13a9e:	0e 94 60 58 	call	0xb0c0	; 0xb0c0 <_ZN14HardwareSerial5flushEv>
	}
	xTaskResumeAll();
   13aa2:	0e 94 ad 96 	call	0x12d5a	; 0x12d5a <xTaskResumeAll>

	/* Allow any key to stop the application running. */
	if( Serial.available() )
   13aa6:	87 ec       	ldi	r24, 0xC7	; 199
   13aa8:	98 e0       	ldi	r25, 0x08	; 8
   13aaa:	0e 94 a0 57 	call	0xaf40	; 0xaf40 <_ZN14HardwareSerial9availableEv>
   13aae:	21 e0       	ldi	r18, 0x01	; 1
   13ab0:	00 97       	sbiw	r24, 0x00	; 0
   13ab2:	09 f4       	brne	.+2      	; 0x13ab6 <_Z21vPrintStringAndNumberPKcm+0x6c>
   13ab4:	20 e0       	ldi	r18, 0x00	; 0
   13ab6:	22 23       	and	r18, r18
   13ab8:	11 f0       	breq	.+4      	; 0x13abe <_Z21vPrintStringAndNumberPKcm+0x74>
	{
		vTaskEndScheduler();
   13aba:	0e 94 95 96 	call	0x12d2a	; 0x12d2a <vTaskEndScheduler>
	}
}
   13abe:	26 96       	adiw	r28, 0x06	; 6
   13ac0:	0f b6       	in	r0, 0x3f	; 63
   13ac2:	f8 94       	cli
   13ac4:	de bf       	out	0x3e, r29	; 62
   13ac6:	0f be       	out	0x3f, r0	; 63
   13ac8:	cd bf       	out	0x3d, r28	; 61
   13aca:	df 91       	pop	r29
   13acc:	cf 91       	pop	r28
   13ace:	08 95       	ret

00013ad0 <vApplicationIdleHook>:
void loop();
void __attribute__((weak)) vApplicationIdleHook() {
   13ad0:	cf 93       	push	r28
   13ad2:	df 93       	push	r29
   13ad4:	cd b7       	in	r28, 0x3d	; 61
   13ad6:	de b7       	in	r29, 0x3e	; 62
  loop();
   13ad8:	0e 94 3e 9e 	call	0x13c7c	; 0x13c7c <loop>
}
   13adc:	df 91       	pop	r29
   13ade:	cf 91       	pop	r28
   13ae0:	08 95       	ret

00013ae2 <vApplicationTickHook>:
void __attribute__((weak)) vApplicationTickHook() {
   13ae2:	cf 93       	push	r28
   13ae4:	df 93       	push	r29
   13ae6:	cd b7       	in	r28, 0x3d	; 61
   13ae8:	de b7       	in	r29, 0x3e	; 62
   13aea:	df 91       	pop	r29
   13aec:	cf 91       	pop	r28
   13aee:	08 95       	ret

00013af0 <_ZL13vLEDFlashTaskPv>:
// handle for blink task
xTaskHandle blink;

//------------------------------------------------------------------------------
// high priority for blinking LED
static void vLEDFlashTask(void *pvParameters) {
   13af0:	cf 93       	push	r28
   13af2:	df 93       	push	r29
   13af4:	00 d0       	rcall	.+0      	; 0x13af6 <_ZL13vLEDFlashTaskPv+0x6>
   13af6:	cd b7       	in	r28, 0x3d	; 61
   13af8:	de b7       	in	r29, 0x3e	; 62
   13afa:	9a 83       	std	Y+2, r25	; 0x02
   13afc:	89 83       	std	Y+1, r24	; 0x01
  pinMode(LED_PIN, OUTPUT);
   13afe:	61 e0       	ldi	r22, 0x01	; 1
   13b00:	8d e0       	ldi	r24, 0x0D	; 13
   13b02:	0e 94 63 80 	call	0x100c6	; 0x100c6 <pinMode>

  // Flash led every 200 ms.
  for (;;) {
    // Turn LED on.
    digitalWrite(LED_PIN, HIGH);
   13b06:	61 e0       	ldi	r22, 0x01	; 1
   13b08:	8d e0       	ldi	r24, 0x0D	; 13
   13b0a:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>

    // Sleep for 50 milliseconds.
    vTaskDelay((250L * configTICK_RATE_HZ) / 1000L);
   13b0e:	84 ef       	ldi	r24, 0xF4	; 244
   13b10:	90 e0       	ldi	r25, 0x00	; 0
   13b12:	0e 94 3d 95 	call	0x12a7a	; 0x12a7a <vTaskDelay>

    // Turn LED off.
    digitalWrite(LED_PIN, LOW);
   13b16:	60 e0       	ldi	r22, 0x00	; 0
   13b18:	8d e0       	ldi	r24, 0x0D	; 13
   13b1a:	0e 94 98 81 	call	0x10330	; 0x10330 <digitalWrite>

    // Sleep for 150 milliseconds.
    vTaskDelay((750L * configTICK_RATE_HZ) / 1000L);
   13b1e:	8c ed       	ldi	r24, 0xDC	; 220
   13b20:	92 e0       	ldi	r25, 0x02	; 2
   13b22:	0e 94 3d 95 	call	0x12a7a	; 0x12a7a <vTaskDelay>
// high priority for blinking LED
static void vLEDFlashTask(void *pvParameters) {
  pinMode(LED_PIN, OUTPUT);

  // Flash led every 200 ms.
  for (;;) {
   13b26:	ef cf       	rjmp	.-34     	; 0x13b06 <_ZL13vLEDFlashTaskPv+0x16>

00013b28 <_ZL10vPrintTaskPv>:
    // Sleep for 150 milliseconds.
    vTaskDelay((750L * configTICK_RATE_HZ) / 1000L);
  }
}
//------------------------------------------------------------------------------
static void vPrintTask(void *pvParameters) {
   13b28:	cf 93       	push	r28
   13b2a:	df 93       	push	r29
   13b2c:	00 d0       	rcall	.+0      	; 0x13b2e <_ZL10vPrintTaskPv+0x6>
   13b2e:	cd b7       	in	r28, 0x3d	; 61
   13b30:	de b7       	in	r29, 0x3e	; 62
   13b32:	9a 83       	std	Y+2, r25	; 0x02
   13b34:	89 83       	std	Y+1, r24	; 0x01
  while (1) {
    // Sleep for one second.
    vTaskDelay(configTICK_RATE_HZ);
   13b36:	80 ed       	ldi	r24, 0xD0	; 208
   13b38:	93 e0       	ldi	r25, 0x03	; 3
   13b3a:	0e 94 3d 95 	call	0x12a7a	; 0x12a7a <vTaskDelay>

    // Print count for previous second.
    Serial.print(F("Count: "));
   13b3e:	89 eb       	ldi	r24, 0xB9	; 185
   13b40:	92 e0       	ldi	r25, 0x02	; 2
   13b42:	bc 01       	movw	r22, r24
   13b44:	87 ec       	ldi	r24, 0xC7	; 199
   13b46:	98 e0       	ldi	r25, 0x08	; 8
   13b48:	0e 94 72 5b 	call	0xb6e4	; 0xb6e4 <_ZN5Print5printEPK19__FlashStringHelper>
    Serial.print(count);
   13b4c:	80 91 a8 09 	lds	r24, 0x09A8
   13b50:	90 91 a9 09 	lds	r25, 0x09A9
   13b54:	a0 91 aa 09 	lds	r26, 0x09AA
   13b58:	b0 91 ab 09 	lds	r27, 0x09AB
   13b5c:	2a e0       	ldi	r18, 0x0A	; 10
   13b5e:	30 e0       	ldi	r19, 0x00	; 0
   13b60:	ac 01       	movw	r20, r24
   13b62:	bd 01       	movw	r22, r26
   13b64:	87 ec       	ldi	r24, 0xC7	; 199
   13b66:	98 e0       	ldi	r25, 0x08	; 8
   13b68:	0e 94 24 5d 	call	0xba48	; 0xba48 <_ZN5Print5printEmi>

    // Print unused stack for threads.
    Serial.print(F(", Unused Stack: "));
   13b6c:	81 ec       	ldi	r24, 0xC1	; 193
   13b6e:	92 e0       	ldi	r25, 0x02	; 2
   13b70:	bc 01       	movw	r22, r24
   13b72:	87 ec       	ldi	r24, 0xC7	; 199
   13b74:	98 e0       	ldi	r25, 0x08	; 8
   13b76:	0e 94 72 5b 	call	0xb6e4	; 0xb6e4 <_ZN5Print5printEPK19__FlashStringHelper>
    Serial.print(uxTaskGetStackHighWaterMark(blink));
   13b7a:	80 91 ac 09 	lds	r24, 0x09AC
   13b7e:	90 91 ad 09 	lds	r25, 0x09AD
   13b82:	0e 94 8e 9b 	call	0x1371c	; 0x1371c <uxTaskGetStackHighWaterMark>
   13b86:	4a e0       	ldi	r20, 0x0A	; 10
   13b88:	50 e0       	ldi	r21, 0x00	; 0
   13b8a:	68 2f       	mov	r22, r24
   13b8c:	87 ec       	ldi	r24, 0xC7	; 199
   13b8e:	98 e0       	ldi	r25, 0x08	; 8
   13b90:	0e 94 3f 5c 	call	0xb87e	; 0xb87e <_ZN5Print5printEhi>
    Serial.print(' ');
   13b94:	60 e2       	ldi	r22, 0x20	; 32
   13b96:	87 ec       	ldi	r24, 0xC7	; 199
   13b98:	98 e0       	ldi	r25, 0x08	; 8
   13b9a:	0e 94 23 5c 	call	0xb846	; 0xb846 <_ZN5Print5printEc>
    Serial.print(uxTaskGetStackHighWaterMark(0));
   13b9e:	80 e0       	ldi	r24, 0x00	; 0
   13ba0:	90 e0       	ldi	r25, 0x00	; 0
   13ba2:	0e 94 8e 9b 	call	0x1371c	; 0x1371c <uxTaskGetStackHighWaterMark>
   13ba6:	4a e0       	ldi	r20, 0x0A	; 10
   13ba8:	50 e0       	ldi	r21, 0x00	; 0
   13baa:	68 2f       	mov	r22, r24
   13bac:	87 ec       	ldi	r24, 0xC7	; 199
   13bae:	98 e0       	ldi	r25, 0x08	; 8
   13bb0:	0e 94 3f 5c 	call	0xb87e	; 0xb87e <_ZN5Print5printEhi>
    Serial.print(' ');
   13bb4:	60 e2       	ldi	r22, 0x20	; 32
   13bb6:	87 ec       	ldi	r24, 0xC7	; 199
   13bb8:	98 e0       	ldi	r25, 0x08	; 8
   13bba:	0e 94 23 5c 	call	0xb846	; 0xb846 <_ZN5Print5printEc>
    Serial.println(freeHeap());
   13bbe:	0e 94 dc 9c 	call	0x139b8	; 0x139b8 <freeHeap>
   13bc2:	4a e0       	ldi	r20, 0x0A	; 10
   13bc4:	50 e0       	ldi	r21, 0x00	; 0
   13bc6:	bc 01       	movw	r22, r24
   13bc8:	87 ec       	ldi	r24, 0xC7	; 199
   13bca:	98 e0       	ldi	r25, 0x08	; 8
   13bcc:	0e 94 c6 5e 	call	0xbd8c	; 0xbd8c <_ZN5Print7printlnEji>

    // Zero count.
    count = 0;
   13bd0:	10 92 a8 09 	sts	0x09A8, r1
   13bd4:	10 92 a9 09 	sts	0x09A9, r1
   13bd8:	10 92 aa 09 	sts	0x09AA, r1
   13bdc:	10 92 ab 09 	sts	0x09AB, r1
    vTaskDelay((750L * configTICK_RATE_HZ) / 1000L);
  }
}
//------------------------------------------------------------------------------
static void vPrintTask(void *pvParameters) {
  while (1) {
   13be0:	aa cf       	rjmp	.-172    	; 0x13b36 <_ZL10vPrintTaskPv+0xe>

00013be2 <setup>:
    // Zero count.
    count = 0;
  }
}
//------------------------------------------------------------------------------
void setup() {
   13be2:	af 92       	push	r10
   13be4:	bf 92       	push	r11
   13be6:	cf 92       	push	r12
   13be8:	df 92       	push	r13
   13bea:	ef 92       	push	r14
   13bec:	ff 92       	push	r15
   13bee:	0f 93       	push	r16
   13bf0:	cf 93       	push	r28
   13bf2:	df 93       	push	r29
   13bf4:	cd b7       	in	r28, 0x3d	; 61
   13bf6:	de b7       	in	r29, 0x3e	; 62
  Serial.begin(9600);
   13bf8:	40 e8       	ldi	r20, 0x80	; 128
   13bfa:	55 e2       	ldi	r21, 0x25	; 37
   13bfc:	60 e0       	ldi	r22, 0x00	; 0
   13bfe:	70 e0       	ldi	r23, 0x00	; 0
   13c00:	87 ec       	ldi	r24, 0xC7	; 199
   13c02:	98 e0       	ldi	r25, 0x08	; 8
   13c04:	0e 94 d1 54 	call	0xa9a2	; 0xa9a2 <_ZN14HardwareSerial5beginEm>
  // wait for Leonardo
  while(!Serial) {}
   13c08:	00 00       	nop
   13c0a:	87 ec       	ldi	r24, 0xC7	; 199
   13c0c:	98 e0       	ldi	r25, 0x08	; 8
   13c0e:	0e 94 10 59 	call	0xb220	; 0xb220 <_ZN14HardwareSerialcvbEv>
   13c12:	98 2f       	mov	r25, r24
   13c14:	81 e0       	ldi	r24, 0x01	; 1
   13c16:	89 27       	eor	r24, r25
   13c18:	88 23       	and	r24, r24
   13c1a:	b9 f7       	brne	.-18     	; 0x13c0a <setup+0x28>
  xTaskCreate(vLEDFlashTask,
    (signed portCHAR *)"Task1",
    configMINIMAL_STACK_SIZE + 50,
    NULL,
    tskIDLE_PRIORITY + 2,
    &blink);
   13c1c:	a1 2c       	mov	r10, r1
   13c1e:	b1 2c       	mov	r11, r1
   13c20:	c1 2c       	mov	r12, r1
   13c22:	d1 2c       	mov	r13, r1
   13c24:	0f 2e       	mov	r0, r31
   13c26:	fc ea       	ldi	r31, 0xAC	; 172
   13c28:	ef 2e       	mov	r14, r31
   13c2a:	f9 e0       	ldi	r31, 0x09	; 9
   13c2c:	ff 2e       	mov	r15, r31
   13c2e:	f0 2d       	mov	r31, r0
   13c30:	02 e0       	ldi	r16, 0x02	; 2
   13c32:	20 e0       	ldi	r18, 0x00	; 0
   13c34:	30 e0       	ldi	r19, 0x00	; 0
   13c36:	47 e8       	ldi	r20, 0x87	; 135
   13c38:	50 e0       	ldi	r21, 0x00	; 0
   13c3a:	63 ea       	ldi	r22, 0xA3	; 163
   13c3c:	74 e0       	ldi	r23, 0x04	; 4
   13c3e:	88 e7       	ldi	r24, 0x78	; 120
   13c40:	9d e9       	ldi	r25, 0x9D	; 157
   13c42:	0e 94 77 93 	call	0x126ee	; 0x126ee <xTaskGenericCreate>
  xTaskCreate(vPrintTask,
    (signed portCHAR *)"Task2",
    configMINIMAL_STACK_SIZE + 100,
    NULL,
    tskIDLE_PRIORITY + 1,
    NULL);
   13c46:	a1 2c       	mov	r10, r1
   13c48:	b1 2c       	mov	r11, r1
   13c4a:	c1 2c       	mov	r12, r1
   13c4c:	d1 2c       	mov	r13, r1
   13c4e:	e1 2c       	mov	r14, r1
   13c50:	f1 2c       	mov	r15, r1
   13c52:	01 e0       	ldi	r16, 0x01	; 1
   13c54:	20 e0       	ldi	r18, 0x00	; 0
   13c56:	30 e0       	ldi	r19, 0x00	; 0
   13c58:	49 eb       	ldi	r20, 0xB9	; 185
   13c5a:	50 e0       	ldi	r21, 0x00	; 0
   13c5c:	69 ea       	ldi	r22, 0xA9	; 169
   13c5e:	74 e0       	ldi	r23, 0x04	; 4
   13c60:	84 e9       	ldi	r24, 0x94	; 148
   13c62:	9d e9       	ldi	r25, 0x9D	; 157
   13c64:	0e 94 77 93 	call	0x126ee	; 0x126ee <xTaskGenericCreate>

  // start FreeRTOS
  vTaskStartScheduler();
   13c68:	0e 94 5b 96 	call	0x12cb6	; 0x12cb6 <vTaskStartScheduler>

  // should never return
  Serial.println(F("Die"));
   13c6c:	85 eb       	ldi	r24, 0xB5	; 181
   13c6e:	92 e0       	ldi	r25, 0x02	; 2
   13c70:	bc 01       	movw	r22, r24
   13c72:	87 ec       	ldi	r24, 0xC7	; 199
   13c74:	98 e0       	ldi	r25, 0x08	; 8
   13c76:	0e 94 85 5d 	call	0xbb0a	; 0xbb0a <_ZN5Print7printlnEPK19__FlashStringHelper>
  while(1);
   13c7a:	ff cf       	rjmp	.-2      	; 0x13c7a <setup+0x98>

00013c7c <loop>:
}
//------------------------------------------------------------------------------
// WARNING idle loop has a very small stack (configMINIMAL_STACK_SIZE)
// loop must never block
void loop() {
   13c7c:	cf 93       	push	r28
   13c7e:	df 93       	push	r29
   13c80:	cd b7       	in	r28, 0x3d	; 61
   13c82:	de b7       	in	r29, 0x3e	; 62
  while(1) {
    // must insure increment is atomic
    // in case of context switch for print
    noInterrupts();
   13c84:	f8 94       	cli
    count++;
   13c86:	80 91 a8 09 	lds	r24, 0x09A8
   13c8a:	90 91 a9 09 	lds	r25, 0x09A9
   13c8e:	a0 91 aa 09 	lds	r26, 0x09AA
   13c92:	b0 91 ab 09 	lds	r27, 0x09AB
   13c96:	01 96       	adiw	r24, 0x01	; 1
   13c98:	a1 1d       	adc	r26, r1
   13c9a:	b1 1d       	adc	r27, r1
   13c9c:	80 93 a8 09 	sts	0x09A8, r24
   13ca0:	90 93 a9 09 	sts	0x09A9, r25
   13ca4:	a0 93 aa 09 	sts	0x09AA, r26
   13ca8:	b0 93 ab 09 	sts	0x09AB, r27
    interrupts();
   13cac:	78 94       	sei
}
//------------------------------------------------------------------------------
// WARNING idle loop has a very small stack (configMINIMAL_STACK_SIZE)
// loop must never block
void loop() {
  while(1) {
   13cae:	ea cf       	rjmp	.-44     	; 0x13c84 <loop+0x8>

00013cb0 <__fixunssfsi>:
#undef MAX
#include <limits.h>

UWtype
__fixunssfSI (SFtype a)
{
   13cb0:	cf 92       	push	r12
   13cb2:	df 92       	push	r13
   13cb4:	ef 92       	push	r14
   13cb6:	ff 92       	push	r15
   13cb8:	0f 93       	push	r16
   13cba:	1f 93       	push	r17
   13cbc:	6b 01       	movw	r12, r22
   13cbe:	7c 01       	movw	r14, r24
  if (a >= - (SFtype) Wtype_MIN)
   13cc0:	20 e0       	ldi	r18, 0x00	; 0
   13cc2:	30 e0       	ldi	r19, 0x00	; 0
   13cc4:	40 e0       	ldi	r20, 0x00	; 0
   13cc6:	5f e4       	ldi	r21, 0x4F	; 79
   13cc8:	0e 94 f4 a1 	call	0x143e8	; 0x143e8 <__gesf2>
   13ccc:	87 fd       	sbrc	r24, 7
   13cce:	0e c0       	rjmp	.+28     	; 0x13cec <__fixunssfsi+0x3c>
    return (Wtype) (a + Wtype_MIN) - Wtype_MIN;
   13cd0:	20 e0       	ldi	r18, 0x00	; 0
   13cd2:	30 e0       	ldi	r19, 0x00	; 0
   13cd4:	40 e0       	ldi	r20, 0x00	; 0
   13cd6:	5f e4       	ldi	r21, 0x4F	; 79
   13cd8:	c7 01       	movw	r24, r14
   13cda:	b6 01       	movw	r22, r12
   13cdc:	0e 94 0d a0 	call	0x1401a	; 0x1401a <__subsf3>
   13ce0:	0e 94 0a a3 	call	0x14614	; 0x14614 <__fixsfsi>
   13ce4:	8b 01       	movw	r16, r22
   13ce6:	9c 01       	movw	r18, r24
   13ce8:	30 58       	subi	r19, 0x80	; 128
   13cea:	06 c0       	rjmp	.+12     	; 0x13cf8 <__fixunssfsi+0x48>
  return (Wtype) a;
   13cec:	c7 01       	movw	r24, r14
   13cee:	b6 01       	movw	r22, r12
   13cf0:	0e 94 0a a3 	call	0x14614	; 0x14614 <__fixsfsi>
   13cf4:	8b 01       	movw	r16, r22
   13cf6:	9c 01       	movw	r18, r24
}
   13cf8:	b8 01       	movw	r22, r16
   13cfa:	c9 01       	movw	r24, r18
   13cfc:	1f 91       	pop	r17
   13cfe:	0f 91       	pop	r16
   13d00:	ff 90       	pop	r15
   13d02:	ef 90       	pop	r14
   13d04:	df 90       	pop	r13
   13d06:	cf 90       	pop	r12
   13d08:	08 95       	ret

00013d0a <_fpadd_parts>:
#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
static const fp_number_type *
_fpadd_parts (fp_number_type * a,
	      fp_number_type * b,
	      fp_number_type * tmp)
{
   13d0a:	a4 e0       	ldi	r26, 0x04	; 4
   13d0c:	b0 e0       	ldi	r27, 0x00	; 0
   13d0e:	eb e8       	ldi	r30, 0x8B	; 139
   13d10:	fe e9       	ldi	r31, 0x9E	; 158
   13d12:	0c 94 fe ad 	jmp	0x15bfc	; 0x15bfc <__prologue_saves__+0x4>
   13d16:	7c 01       	movw	r14, r24
   13d18:	6a 01       	movw	r12, r20
  b.sign ^= 1;

  res = _fpadd_parts (&a, &b, &tmp);

  return pack_d (res);
}
   13d1a:	fc 01       	movw	r30, r24
   13d1c:	80 81       	ld	r24, Z
  int a_normal_exp;
  int b_normal_exp;
  fractype a_fraction;
  fractype b_fraction;

  if (isnan (a))
   13d1e:	82 30       	cpi	r24, 0x02	; 2
   13d20:	08 f4       	brcc	.+2      	; 0x13d24 <_fpadd_parts+0x1a>
   13d22:	4a c1       	rjmp	.+660    	; 0x13fb8 <_fpadd_parts+0x2ae>
  b.sign ^= 1;

  res = _fpadd_parts (&a, &b, &tmp);

  return pack_d (res);
}
   13d24:	fb 01       	movw	r30, r22
   13d26:	90 81       	ld	r25, Z

  if (isnan (a))
    {
      return a;
    }
  if (isnan (b))
   13d28:	92 30       	cpi	r25, 0x02	; 2
   13d2a:	08 f4       	brcc	.+2      	; 0x13d2e <_fpadd_parts+0x24>
   13d2c:	42 c1       	rjmp	.+644    	; 0x13fb2 <_fpadd_parts+0x2a8>
    {
      return b;
    }
  if (isinf (a))
   13d2e:	84 30       	cpi	r24, 0x04	; 4
   13d30:	79 f4       	brne	.+30     	; 0x13d50 <_fpadd_parts+0x46>
    {
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
   13d32:	94 30       	cpi	r25, 0x04	; 4
   13d34:	09 f0       	breq	.+2      	; 0x13d38 <_fpadd_parts+0x2e>
   13d36:	40 c1       	rjmp	.+640    	; 0x13fb8 <_fpadd_parts+0x2ae>
   13d38:	f7 01       	movw	r30, r14
   13d3a:	91 81       	ldd	r25, Z+1	; 0x01
   13d3c:	fb 01       	movw	r30, r22
   13d3e:	81 81       	ldd	r24, Z+1	; 0x01
   13d40:	98 17       	cp	r25, r24
   13d42:	09 f4       	brne	.+2      	; 0x13d46 <_fpadd_parts+0x3c>
   13d44:	39 c1       	rjmp	.+626    	; 0x13fb8 <_fpadd_parts+0x2ae>
	return makenan ();
   13d46:	af eb       	ldi	r26, 0xBF	; 191
   13d48:	ea 2e       	mov	r14, r26
   13d4a:	a4 e0       	ldi	r26, 0x04	; 4
   13d4c:	fa 2e       	mov	r15, r26
   13d4e:	34 c1       	rjmp	.+616    	; 0x13fb8 <_fpadd_parts+0x2ae>
      return a;
    }
  if (isinf (b))
   13d50:	94 30       	cpi	r25, 0x04	; 4
   13d52:	09 f4       	brne	.+2      	; 0x13d56 <_fpadd_parts+0x4c>
   13d54:	2e c1       	rjmp	.+604    	; 0x13fb2 <_fpadd_parts+0x2a8>
    {
      return b;
    }
  if (iszero (b))
   13d56:	92 30       	cpi	r25, 0x02	; 2
   13d58:	91 f4       	brne	.+36     	; 0x13d7e <_fpadd_parts+0x74>
    {
      if (iszero (a))
   13d5a:	82 30       	cpi	r24, 0x02	; 2
   13d5c:	09 f0       	breq	.+2      	; 0x13d60 <_fpadd_parts+0x56>
   13d5e:	2c c1       	rjmp	.+600    	; 0x13fb8 <_fpadd_parts+0x2ae>
	{
	  *tmp = *a;
   13d60:	88 e0       	ldi	r24, 0x08	; 8
   13d62:	f7 01       	movw	r30, r14
   13d64:	da 01       	movw	r26, r20
   13d66:	01 90       	ld	r0, Z+
   13d68:	0d 92       	st	X+, r0
   13d6a:	8a 95       	dec	r24
   13d6c:	e1 f7       	brne	.-8      	; 0x13d66 <_fpadd_parts+0x5c>
	  tmp->sign = a->sign & b->sign;
   13d6e:	fb 01       	movw	r30, r22
   13d70:	81 81       	ldd	r24, Z+1	; 0x01
   13d72:	f7 01       	movw	r30, r14
   13d74:	91 81       	ldd	r25, Z+1	; 0x01
   13d76:	89 23       	and	r24, r25
   13d78:	fa 01       	movw	r30, r20
   13d7a:	81 83       	std	Z+1, r24	; 0x01
   13d7c:	1c c1       	rjmp	.+568    	; 0x13fb6 <_fpadd_parts+0x2ac>
	  return tmp;
	}
      return a;
    }
  if (iszero (a))
   13d7e:	82 30       	cpi	r24, 0x02	; 2
   13d80:	09 f4       	brne	.+2      	; 0x13d84 <_fpadd_parts+0x7a>
   13d82:	17 c1       	rjmp	.+558    	; 0x13fb2 <_fpadd_parts+0x2a8>
     they're the same */
  {
    int diff;
    int sdiff;

    a_normal_exp = a->normal_exp;
   13d84:	f7 01       	movw	r30, r14
   13d86:	82 81       	ldd	r24, Z+2	; 0x02
   13d88:	93 81       	ldd	r25, Z+3	; 0x03
    b_normal_exp = b->normal_exp;
   13d8a:	fb 01       	movw	r30, r22
   13d8c:	a2 81       	ldd	r26, Z+2	; 0x02
   13d8e:	b3 81       	ldd	r27, Z+3	; 0x03
    a_fraction = a->fraction.ll;
   13d90:	f7 01       	movw	r30, r14
   13d92:	04 81       	ldd	r16, Z+4	; 0x04
   13d94:	15 81       	ldd	r17, Z+5	; 0x05
   13d96:	26 81       	ldd	r18, Z+6	; 0x06
   13d98:	37 81       	ldd	r19, Z+7	; 0x07
    b_fraction = b->fraction.ll;
   13d9a:	fb 01       	movw	r30, r22
   13d9c:	84 80       	ldd	r8, Z+4	; 0x04
   13d9e:	95 80       	ldd	r9, Z+5	; 0x05
   13da0:	a6 80       	ldd	r10, Z+6	; 0x06
   13da2:	b7 80       	ldd	r11, Z+7	; 0x07

    diff = a_normal_exp - b_normal_exp;
   13da4:	fc 01       	movw	r30, r24
   13da6:	ea 1b       	sub	r30, r26
   13da8:	fb 0b       	sbc	r31, r27
   13daa:	af 01       	movw	r20, r30
   13dac:	f7 ff       	sbrs	r31, 7
   13dae:	04 c0       	rjmp	.+8      	; 0x13db8 <_fpadd_parts+0xae>
   13db0:	44 27       	eor	r20, r20
   13db2:	55 27       	eor	r21, r21
   13db4:	4e 1b       	sub	r20, r30
   13db6:	5f 0b       	sbc	r21, r31
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   13db8:	40 32       	cpi	r20, 0x20	; 32
   13dba:	51 05       	cpc	r21, r1
   13dbc:	0c f0       	brlt	.+2      	; 0x13dc0 <_fpadd_parts+0xb6>
   13dbe:	74 c0       	rjmp	.+232    	; 0x13ea8 <_fpadd_parts+0x19e>
      {
	if (sdiff > 0)
   13dc0:	1e 16       	cp	r1, r30
   13dc2:	1f 06       	cpc	r1, r31
   13dc4:	b4 f5       	brge	.+108    	; 0x13e32 <_fpadd_parts+0x128>
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   13dc6:	24 01       	movw	r4, r8
   13dc8:	35 01       	movw	r6, r10
   13dca:	04 2e       	mov	r0, r20
   13dcc:	04 c0       	rjmp	.+8      	; 0x13dd6 <_fpadd_parts+0xcc>
   13dce:	76 94       	lsr	r7
   13dd0:	67 94       	ror	r6
   13dd2:	57 94       	ror	r5
   13dd4:	47 94       	ror	r4
   13dd6:	0a 94       	dec	r0
   13dd8:	d2 f7       	brpl	.-12     	; 0x13dce <_fpadd_parts+0xc4>
   13dda:	49 82       	std	Y+1, r4	; 0x01
   13ddc:	5a 82       	std	Y+2, r5	; 0x02
   13dde:	6b 82       	std	Y+3, r6	; 0x03
   13de0:	7c 82       	std	Y+4, r7	; 0x04
   13de2:	41 2c       	mov	r4, r1
   13de4:	51 2c       	mov	r5, r1
   13de6:	32 01       	movw	r6, r4
   13de8:	43 94       	inc	r4
   13dea:	04 c0       	rjmp	.+8      	; 0x13df4 <_fpadd_parts+0xea>
   13dec:	44 0c       	add	r4, r4
   13dee:	55 1c       	adc	r5, r5
   13df0:	66 1c       	adc	r6, r6
   13df2:	77 1c       	adc	r7, r7
   13df4:	4a 95       	dec	r20
   13df6:	d2 f7       	brpl	.-12     	; 0x13dec <_fpadd_parts+0xe2>
   13df8:	41 e0       	ldi	r20, 0x01	; 1
   13dfa:	44 1a       	sub	r4, r20
   13dfc:	51 08       	sbc	r5, r1
   13dfe:	61 08       	sbc	r6, r1
   13e00:	71 08       	sbc	r7, r1
   13e02:	48 20       	and	r4, r8
   13e04:	59 20       	and	r5, r9
   13e06:	6a 20       	and	r6, r10
   13e08:	7b 20       	and	r7, r11
   13e0a:	81 2c       	mov	r8, r1
   13e0c:	91 2c       	mov	r9, r1
   13e0e:	54 01       	movw	r10, r8
   13e10:	83 94       	inc	r8
   13e12:	45 28       	or	r4, r5
   13e14:	46 28       	or	r4, r6
   13e16:	47 28       	or	r4, r7
   13e18:	19 f4       	brne	.+6      	; 0x13e20 <_fpadd_parts+0x116>
   13e1a:	81 2c       	mov	r8, r1
   13e1c:	91 2c       	mov	r9, r1
   13e1e:	54 01       	movw	r10, r8
   13e20:	49 80       	ldd	r4, Y+1	; 0x01
   13e22:	5a 80       	ldd	r5, Y+2	; 0x02
   13e24:	6b 80       	ldd	r6, Y+3	; 0x03
   13e26:	7c 80       	ldd	r7, Y+4	; 0x04
   13e28:	84 28       	or	r8, r4
   13e2a:	95 28       	or	r9, r5
   13e2c:	a6 28       	or	r10, r6
   13e2e:	b7 28       	or	r11, r7
   13e30:	46 c0       	rjmp	.+140    	; 0x13ebe <_fpadd_parts+0x1b4>
	  }
	else if (sdiff < 0)
   13e32:	ef 2b       	or	r30, r31
   13e34:	09 f4       	brne	.+2      	; 0x13e38 <_fpadd_parts+0x12e>
   13e36:	43 c0       	rjmp	.+134    	; 0x13ebe <_fpadd_parts+0x1b4>
	  {
	    a_normal_exp += diff;
   13e38:	84 0f       	add	r24, r20
   13e3a:	95 1f       	adc	r25, r21
	    LSHIFT (a_fraction, diff);
   13e3c:	28 01       	movw	r4, r16
   13e3e:	39 01       	movw	r6, r18
   13e40:	04 2e       	mov	r0, r20
   13e42:	04 c0       	rjmp	.+8      	; 0x13e4c <_fpadd_parts+0x142>
   13e44:	76 94       	lsr	r7
   13e46:	67 94       	ror	r6
   13e48:	57 94       	ror	r5
   13e4a:	47 94       	ror	r4
   13e4c:	0a 94       	dec	r0
   13e4e:	d2 f7       	brpl	.-12     	; 0x13e44 <_fpadd_parts+0x13a>
   13e50:	49 82       	std	Y+1, r4	; 0x01
   13e52:	5a 82       	std	Y+2, r5	; 0x02
   13e54:	6b 82       	std	Y+3, r6	; 0x03
   13e56:	7c 82       	std	Y+4, r7	; 0x04
   13e58:	41 2c       	mov	r4, r1
   13e5a:	51 2c       	mov	r5, r1
   13e5c:	32 01       	movw	r6, r4
   13e5e:	43 94       	inc	r4
   13e60:	04 c0       	rjmp	.+8      	; 0x13e6a <_fpadd_parts+0x160>
   13e62:	44 0c       	add	r4, r4
   13e64:	55 1c       	adc	r5, r5
   13e66:	66 1c       	adc	r6, r6
   13e68:	77 1c       	adc	r7, r7
   13e6a:	4a 95       	dec	r20
   13e6c:	d2 f7       	brpl	.-12     	; 0x13e62 <_fpadd_parts+0x158>
   13e6e:	41 e0       	ldi	r20, 0x01	; 1
   13e70:	44 1a       	sub	r4, r20
   13e72:	51 08       	sbc	r5, r1
   13e74:	61 08       	sbc	r6, r1
   13e76:	71 08       	sbc	r7, r1
   13e78:	40 22       	and	r4, r16
   13e7a:	51 22       	and	r5, r17
   13e7c:	62 22       	and	r6, r18
   13e7e:	73 22       	and	r7, r19
   13e80:	01 e0       	ldi	r16, 0x01	; 1
   13e82:	10 e0       	ldi	r17, 0x00	; 0
   13e84:	20 e0       	ldi	r18, 0x00	; 0
   13e86:	30 e0       	ldi	r19, 0x00	; 0
   13e88:	45 28       	or	r4, r5
   13e8a:	46 28       	or	r4, r6
   13e8c:	47 28       	or	r4, r7
   13e8e:	19 f4       	brne	.+6      	; 0x13e96 <_fpadd_parts+0x18c>
   13e90:	00 e0       	ldi	r16, 0x00	; 0
   13e92:	10 e0       	ldi	r17, 0x00	; 0
   13e94:	98 01       	movw	r18, r16
   13e96:	49 80       	ldd	r4, Y+1	; 0x01
   13e98:	5a 80       	ldd	r5, Y+2	; 0x02
   13e9a:	6b 80       	ldd	r6, Y+3	; 0x03
   13e9c:	7c 80       	ldd	r7, Y+4	; 0x04
   13e9e:	04 29       	or	r16, r4
   13ea0:	15 29       	or	r17, r5
   13ea2:	26 29       	or	r18, r6
   13ea4:	37 29       	or	r19, r7
   13ea6:	0b c0       	rjmp	.+22     	; 0x13ebe <_fpadd_parts+0x1b4>
	  }
      }
    else
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
   13ea8:	a8 17       	cp	r26, r24
   13eaa:	b9 07       	cpc	r27, r25
   13eac:	24 f4       	brge	.+8      	; 0x13eb6 <_fpadd_parts+0x1ac>
	  {
	    b_normal_exp = a_normal_exp;
	    b_fraction = 0;
   13eae:	81 2c       	mov	r8, r1
   13eb0:	91 2c       	mov	r9, r1
   13eb2:	54 01       	movw	r10, r8
   13eb4:	04 c0       	rjmp	.+8      	; 0x13ebe <_fpadd_parts+0x1b4>
	  }
      }
    else
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
   13eb6:	cd 01       	movw	r24, r26
	    b_fraction = 0;
	  }
	else
	  {
	    a_normal_exp = b_normal_exp;
	    a_fraction = 0;
   13eb8:	00 e0       	ldi	r16, 0x00	; 0
   13eba:	10 e0       	ldi	r17, 0x00	; 0
   13ebc:	98 01       	movw	r18, r16
	  }
      }
  }

  if (a->sign != b->sign)
   13ebe:	f7 01       	movw	r30, r14
   13ec0:	41 81       	ldd	r20, Z+1	; 0x01
   13ec2:	fb 01       	movw	r30, r22
   13ec4:	51 81       	ldd	r21, Z+1	; 0x01
   13ec6:	45 17       	cp	r20, r21
   13ec8:	09 f4       	brne	.+2      	; 0x13ecc <_fpadd_parts+0x1c2>
   13eca:	46 c0       	rjmp	.+140    	; 0x13f58 <_fpadd_parts+0x24e>
    {
      if (a->sign)
   13ecc:	44 23       	and	r20, r20
   13ece:	49 f0       	breq	.+18     	; 0x13ee2 <_fpadd_parts+0x1d8>
	{
	  tfraction = -a_fraction + b_fraction;
   13ed0:	24 01       	movw	r4, r8
   13ed2:	35 01       	movw	r6, r10
   13ed4:	40 1a       	sub	r4, r16
   13ed6:	51 0a       	sbc	r5, r17
   13ed8:	62 0a       	sbc	r6, r18
   13eda:	73 0a       	sbc	r7, r19
   13edc:	93 01       	movw	r18, r6
   13ede:	82 01       	movw	r16, r4
   13ee0:	04 c0       	rjmp	.+8      	; 0x13eea <_fpadd_parts+0x1e0>
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
   13ee2:	08 19       	sub	r16, r8
   13ee4:	19 09       	sbc	r17, r9
   13ee6:	2a 09       	sbc	r18, r10
   13ee8:	3b 09       	sbc	r19, r11
	}
      if (tfraction >= 0)
   13eea:	37 fd       	sbrc	r19, 7
   13eec:	05 c0       	rjmp	.+10     	; 0x13ef8 <_fpadd_parts+0x1ee>
	{
	  tmp->sign = 0;
   13eee:	f6 01       	movw	r30, r12
   13ef0:	11 82       	std	Z+1, r1	; 0x01
	  tmp->normal_exp = a_normal_exp;
   13ef2:	93 83       	std	Z+3, r25	; 0x03
   13ef4:	82 83       	std	Z+2, r24	; 0x02
   13ef6:	0c c0       	rjmp	.+24     	; 0x13f10 <_fpadd_parts+0x206>
	  tmp->fraction.ll = tfraction;
	}
      else
	{
	  tmp->sign = 1;
   13ef8:	41 e0       	ldi	r20, 0x01	; 1
   13efa:	f6 01       	movw	r30, r12
   13efc:	41 83       	std	Z+1, r20	; 0x01
	  tmp->normal_exp = a_normal_exp;
   13efe:	93 83       	std	Z+3, r25	; 0x03
   13f00:	82 83       	std	Z+2, r24	; 0x02
	  tmp->fraction.ll = -tfraction;
   13f02:	30 95       	com	r19
   13f04:	20 95       	com	r18
   13f06:	10 95       	com	r17
   13f08:	01 95       	neg	r16
   13f0a:	1f 4f       	sbci	r17, 0xFF	; 255
   13f0c:	2f 4f       	sbci	r18, 0xFF	; 255
   13f0e:	3f 4f       	sbci	r19, 0xFF	; 255
   13f10:	04 83       	std	Z+4, r16	; 0x04
   13f12:	15 83       	std	Z+5, r17	; 0x05
   13f14:	26 83       	std	Z+6, r18	; 0x06
   13f16:	37 83       	std	Z+7, r19	; 0x07
   13f18:	0e c0       	rjmp	.+28     	; 0x13f36 <_fpadd_parts+0x22c>
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
	{
	  tmp->fraction.ll <<= 1;
   13f1a:	88 0f       	add	r24, r24
   13f1c:	99 1f       	adc	r25, r25
   13f1e:	aa 1f       	adc	r26, r26
   13f20:	bb 1f       	adc	r27, r27
   13f22:	f6 01       	movw	r30, r12
   13f24:	84 83       	std	Z+4, r24	; 0x04
   13f26:	95 83       	std	Z+5, r25	; 0x05
   13f28:	a6 83       	std	Z+6, r26	; 0x06
   13f2a:	b7 83       	std	Z+7, r27	; 0x07
	  tmp->normal_exp--;
   13f2c:	82 81       	ldd	r24, Z+2	; 0x02
   13f2e:	93 81       	ldd	r25, Z+3	; 0x03
   13f30:	01 97       	sbiw	r24, 0x01	; 1
   13f32:	93 83       	std	Z+3, r25	; 0x03
   13f34:	82 83       	std	Z+2, r24	; 0x02
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   13f36:	f6 01       	movw	r30, r12
   13f38:	84 81       	ldd	r24, Z+4	; 0x04
   13f3a:	95 81       	ldd	r25, Z+5	; 0x05
   13f3c:	a6 81       	ldd	r26, Z+6	; 0x06
   13f3e:	b7 81       	ldd	r27, Z+7	; 0x07
   13f40:	ac 01       	movw	r20, r24
   13f42:	bd 01       	movw	r22, r26
   13f44:	41 50       	subi	r20, 0x01	; 1
   13f46:	51 09       	sbc	r21, r1
   13f48:	61 09       	sbc	r22, r1
   13f4a:	71 09       	sbc	r23, r1
   13f4c:	4f 3f       	cpi	r20, 0xFF	; 255
   13f4e:	5f 4f       	sbci	r21, 0xFF	; 255
   13f50:	6f 4f       	sbci	r22, 0xFF	; 255
   13f52:	7f 43       	sbci	r23, 0x3F	; 63
   13f54:	10 f3       	brcs	.-60     	; 0x13f1a <_fpadd_parts+0x210>
   13f56:	0c c0       	rjmp	.+24     	; 0x13f70 <_fpadd_parts+0x266>
	  tmp->normal_exp--;
	}
    }
  else
    {
      tmp->sign = a->sign;
   13f58:	f6 01       	movw	r30, r12
   13f5a:	41 83       	std	Z+1, r20	; 0x01
      tmp->normal_exp = a_normal_exp;
   13f5c:	93 83       	std	Z+3, r25	; 0x03
   13f5e:	82 83       	std	Z+2, r24	; 0x02
      tmp->fraction.ll = a_fraction + b_fraction;
   13f60:	08 0d       	add	r16, r8
   13f62:	19 1d       	adc	r17, r9
   13f64:	2a 1d       	adc	r18, r10
   13f66:	3b 1d       	adc	r19, r11
   13f68:	04 83       	std	Z+4, r16	; 0x04
   13f6a:	15 83       	std	Z+5, r17	; 0x05
   13f6c:	26 83       	std	Z+6, r18	; 0x06
   13f6e:	37 83       	std	Z+7, r19	; 0x07
    }
  tmp->class = CLASS_NUMBER;
   13f70:	83 e0       	ldi	r24, 0x03	; 3
   13f72:	f6 01       	movw	r30, r12
   13f74:	80 83       	st	Z, r24
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
   13f76:	44 81       	ldd	r20, Z+4	; 0x04
   13f78:	55 81       	ldd	r21, Z+5	; 0x05
   13f7a:	66 81       	ldd	r22, Z+6	; 0x06
   13f7c:	77 81       	ldd	r23, Z+7	; 0x07
   13f7e:	77 ff       	sbrs	r23, 7
   13f80:	1a c0       	rjmp	.+52     	; 0x13fb6 <_fpadd_parts+0x2ac>
    {
      LSHIFT (tmp->fraction.ll, 1);
   13f82:	db 01       	movw	r26, r22
   13f84:	ca 01       	movw	r24, r20
   13f86:	81 70       	andi	r24, 0x01	; 1
   13f88:	99 27       	eor	r25, r25
   13f8a:	aa 27       	eor	r26, r26
   13f8c:	bb 27       	eor	r27, r27
   13f8e:	76 95       	lsr	r23
   13f90:	67 95       	ror	r22
   13f92:	57 95       	ror	r21
   13f94:	47 95       	ror	r20
   13f96:	84 2b       	or	r24, r20
   13f98:	95 2b       	or	r25, r21
   13f9a:	a6 2b       	or	r26, r22
   13f9c:	b7 2b       	or	r27, r23
   13f9e:	84 83       	std	Z+4, r24	; 0x04
   13fa0:	95 83       	std	Z+5, r25	; 0x05
   13fa2:	a6 83       	std	Z+6, r26	; 0x06
   13fa4:	b7 83       	std	Z+7, r27	; 0x07
      tmp->normal_exp++;
   13fa6:	82 81       	ldd	r24, Z+2	; 0x02
   13fa8:	93 81       	ldd	r25, Z+3	; 0x03
   13faa:	01 96       	adiw	r24, 0x01	; 1
   13fac:	93 83       	std	Z+3, r25	; 0x03
   13fae:	82 83       	std	Z+2, r24	; 0x02
   13fb0:	02 c0       	rjmp	.+4      	; 0x13fb6 <_fpadd_parts+0x2ac>
    {
      return a;
    }
  if (isnan (b))
    {
      return b;
   13fb2:	7b 01       	movw	r14, r22
   13fb4:	01 c0       	rjmp	.+2      	; 0x13fb8 <_fpadd_parts+0x2ae>
  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
      tmp->normal_exp++;
    }
  return tmp;
   13fb6:	76 01       	movw	r14, r12
}
   13fb8:	c7 01       	movw	r24, r14
   13fba:	24 96       	adiw	r28, 0x04	; 4
   13fbc:	e0 e1       	ldi	r30, 0x10	; 16
   13fbe:	0c 94 1a ae 	jmp	0x15c34	; 0x15c34 <__epilogue_restores__+0x4>

00013fc2 <__addsf3>:

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   13fc2:	a0 e2       	ldi	r26, 0x20	; 32
   13fc4:	b0 e0       	ldi	r27, 0x00	; 0
   13fc6:	e7 ee       	ldi	r30, 0xE7	; 231
   13fc8:	ff e9       	ldi	r31, 0x9F	; 159
   13fca:	0c 94 0c ae 	jmp	0x15c18	; 0x15c18 <__prologue_saves__+0x20>
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   13fce:	6d 8f       	std	Y+29, r22	; 0x1d
   13fd0:	7e 8f       	std	Y+30, r23	; 0x1e
   13fd2:	8f 8f       	std	Y+31, r24	; 0x1f
   13fd4:	98 a3       	std	Y+32, r25	; 0x20
  bu.value = arg_b;
   13fd6:	29 8f       	std	Y+25, r18	; 0x19
   13fd8:	3a 8f       	std	Y+26, r19	; 0x1a
   13fda:	4b 8f       	std	Y+27, r20	; 0x1b
   13fdc:	5c 8f       	std	Y+28, r21	; 0x1c

  unpack_d (&au, &a);
   13fde:	be 01       	movw	r22, r28
   13fe0:	6f 5e       	subi	r22, 0xEF	; 239
   13fe2:	7f 4f       	sbci	r23, 0xFF	; 255
   13fe4:	ce 01       	movw	r24, r28
   13fe6:	4d 96       	adiw	r24, 0x1d	; 29
   13fe8:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>
  unpack_d (&bu, &b);
   13fec:	be 01       	movw	r22, r28
   13fee:	67 5f       	subi	r22, 0xF7	; 247
   13ff0:	7f 4f       	sbci	r23, 0xFF	; 255
   13ff2:	ce 01       	movw	r24, r28
   13ff4:	49 96       	adiw	r24, 0x19	; 25
   13ff6:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>

  res = _fpadd_parts (&a, &b, &tmp);
   13ffa:	ae 01       	movw	r20, r28
   13ffc:	4f 5f       	subi	r20, 0xFF	; 255
   13ffe:	5f 4f       	sbci	r21, 0xFF	; 255
   14000:	be 01       	movw	r22, r28
   14002:	67 5f       	subi	r22, 0xF7	; 247
   14004:	7f 4f       	sbci	r23, 0xFF	; 255
   14006:	ce 01       	movw	r24, r28
   14008:	41 96       	adiw	r24, 0x11	; 17
   1400a:	0e 94 85 9e 	call	0x13d0a	; 0x13d0a <_fpadd_parts>

  return pack_d (res);
   1400e:	0e 94 cf a3 	call	0x1479e	; 0x1479e <__pack_f>
}
   14012:	a0 96       	adiw	r28, 0x20	; 32
   14014:	e2 e0       	ldi	r30, 0x02	; 2
   14016:	0c 94 28 ae 	jmp	0x15c50	; 0x15c50 <__epilogue_restores__+0x20>

0001401a <__subsf3>:

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1401a:	a0 e2       	ldi	r26, 0x20	; 32
   1401c:	b0 e0       	ldi	r27, 0x00	; 0
   1401e:	e3 e1       	ldi	r30, 0x13	; 19
   14020:	f0 ea       	ldi	r31, 0xA0	; 160
   14022:	0c 94 0c ae 	jmp	0x15c18	; 0x15c18 <__prologue_saves__+0x20>
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   14026:	6d 8f       	std	Y+29, r22	; 0x1d
   14028:	7e 8f       	std	Y+30, r23	; 0x1e
   1402a:	8f 8f       	std	Y+31, r24	; 0x1f
   1402c:	98 a3       	std	Y+32, r25	; 0x20
  bu.value = arg_b;
   1402e:	29 8f       	std	Y+25, r18	; 0x19
   14030:	3a 8f       	std	Y+26, r19	; 0x1a
   14032:	4b 8f       	std	Y+27, r20	; 0x1b
   14034:	5c 8f       	std	Y+28, r21	; 0x1c

  unpack_d (&au, &a);
   14036:	be 01       	movw	r22, r28
   14038:	6f 5e       	subi	r22, 0xEF	; 239
   1403a:	7f 4f       	sbci	r23, 0xFF	; 255
   1403c:	ce 01       	movw	r24, r28
   1403e:	4d 96       	adiw	r24, 0x1d	; 29
   14040:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>
  unpack_d (&bu, &b);
   14044:	be 01       	movw	r22, r28
   14046:	67 5f       	subi	r22, 0xF7	; 247
   14048:	7f 4f       	sbci	r23, 0xFF	; 255
   1404a:	ce 01       	movw	r24, r28
   1404c:	49 96       	adiw	r24, 0x19	; 25
   1404e:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>

  b.sign ^= 1;
   14052:	8a 85       	ldd	r24, Y+10	; 0x0a
   14054:	91 e0       	ldi	r25, 0x01	; 1
   14056:	89 27       	eor	r24, r25
   14058:	8a 87       	std	Y+10, r24	; 0x0a

  res = _fpadd_parts (&a, &b, &tmp);
   1405a:	ae 01       	movw	r20, r28
   1405c:	4f 5f       	subi	r20, 0xFF	; 255
   1405e:	5f 4f       	sbci	r21, 0xFF	; 255
   14060:	be 01       	movw	r22, r28
   14062:	67 5f       	subi	r22, 0xF7	; 247
   14064:	7f 4f       	sbci	r23, 0xFF	; 255
   14066:	ce 01       	movw	r24, r28
   14068:	41 96       	adiw	r24, 0x11	; 17
   1406a:	0e 94 85 9e 	call	0x13d0a	; 0x13d0a <_fpadd_parts>

  return pack_d (res);
   1406e:	0e 94 cf a3 	call	0x1479e	; 0x1479e <__pack_f>
}
   14072:	a0 96       	adiw	r28, 0x20	; 32
   14074:	e2 e0       	ldi	r30, 0x02	; 2
   14076:	0c 94 28 ae 	jmp	0x15c50	; 0x15c50 <__epilogue_restores__+0x20>

0001407a <__mulsf3>:
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1407a:	a0 e2       	ldi	r26, 0x20	; 32
   1407c:	b0 e0       	ldi	r27, 0x00	; 0
   1407e:	e3 e4       	ldi	r30, 0x43	; 67
   14080:	f0 ea       	ldi	r31, 0xA0	; 160
   14082:	0c 94 fe ad 	jmp	0x15bfc	; 0x15bfc <__prologue_saves__+0x4>
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   14086:	6d 8f       	std	Y+29, r22	; 0x1d
   14088:	7e 8f       	std	Y+30, r23	; 0x1e
   1408a:	8f 8f       	std	Y+31, r24	; 0x1f
   1408c:	98 a3       	std	Y+32, r25	; 0x20
  bu.value = arg_b;
   1408e:	29 8f       	std	Y+25, r18	; 0x19
   14090:	3a 8f       	std	Y+26, r19	; 0x1a
   14092:	4b 8f       	std	Y+27, r20	; 0x1b
   14094:	5c 8f       	std	Y+28, r21	; 0x1c

  unpack_d (&au, &a);
   14096:	be 01       	movw	r22, r28
   14098:	6f 5e       	subi	r22, 0xEF	; 239
   1409a:	7f 4f       	sbci	r23, 0xFF	; 255
   1409c:	ce 01       	movw	r24, r28
   1409e:	4d 96       	adiw	r24, 0x1d	; 29
   140a0:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>
  unpack_d (&bu, &b);
   140a4:	be 01       	movw	r22, r28
   140a6:	67 5f       	subi	r22, 0xF7	; 247
   140a8:	7f 4f       	sbci	r23, 0xFF	; 255
   140aa:	ce 01       	movw	r24, r28
   140ac:	49 96       	adiw	r24, 0x19	; 25
   140ae:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
}
   140b2:	99 89       	ldd	r25, Y+17	; 0x11
	       fp_number_type * tmp)
{
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
   140b4:	92 30       	cpi	r25, 0x02	; 2
   140b6:	08 f4       	brcc	.+2      	; 0x140ba <__mulsf3+0x40>
   140b8:	12 c0       	rjmp	.+36     	; 0x140de <__mulsf3+0x64>
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
}
   140ba:	89 85       	ldd	r24, Y+9	; 0x09
  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
   140bc:	82 30       	cpi	r24, 0x02	; 2
   140be:	08 f4       	brcc	.+2      	; 0x140c2 <__mulsf3+0x48>
   140c0:	1a c0       	rjmp	.+52     	; 0x140f6 <__mulsf3+0x7c>
    {
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
   140c2:	94 30       	cpi	r25, 0x04	; 4
   140c4:	21 f4       	brne	.+8      	; 0x140ce <__mulsf3+0x54>
    {
      if (iszero (b))
   140c6:	82 30       	cpi	r24, 0x02	; 2
   140c8:	09 f4       	brne	.+2      	; 0x140cc <__mulsf3+0x52>
   140ca:	b4 c0       	rjmp	.+360    	; 0x14234 <__mulsf3+0x1ba>
   140cc:	08 c0       	rjmp	.+16     	; 0x140de <__mulsf3+0x64>
	return makenan ();
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
   140ce:	84 30       	cpi	r24, 0x04	; 4
   140d0:	21 f4       	brne	.+8      	; 0x140da <__mulsf3+0x60>
    {
      if (iszero (a))
   140d2:	92 30       	cpi	r25, 0x02	; 2
   140d4:	09 f4       	brne	.+2      	; 0x140d8 <__mulsf3+0x5e>
   140d6:	ae c0       	rjmp	.+348    	; 0x14234 <__mulsf3+0x1ba>
   140d8:	0e c0       	rjmp	.+28     	; 0x140f6 <__mulsf3+0x7c>
	  return makenan ();
	}
      b->sign = a->sign != b->sign;
      return b;
    }
  if (iszero (a))
   140da:	92 30       	cpi	r25, 0x02	; 2
   140dc:	51 f4       	brne	.+20     	; 0x140f2 <__mulsf3+0x78>
    {
      a->sign = a->sign != b->sign;
   140de:	81 e0       	ldi	r24, 0x01	; 1
   140e0:	2a 89       	ldd	r18, Y+18	; 0x12
   140e2:	9a 85       	ldd	r25, Y+10	; 0x0a
   140e4:	29 13       	cpse	r18, r25
   140e6:	01 c0       	rjmp	.+2      	; 0x140ea <__mulsf3+0x70>
   140e8:	80 e0       	ldi	r24, 0x00	; 0
   140ea:	8a 8b       	std	Y+18, r24	; 0x12
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);
   140ec:	ce 01       	movw	r24, r28
   140ee:	41 96       	adiw	r24, 0x11	; 17
   140f0:	a3 c0       	rjmp	.+326    	; 0x14238 <__mulsf3+0x1be>
  if (iszero (a))
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (iszero (b))
   140f2:	82 30       	cpi	r24, 0x02	; 2
   140f4:	51 f4       	brne	.+20     	; 0x1410a <__mulsf3+0x90>
    {
      b->sign = a->sign != b->sign;
   140f6:	81 e0       	ldi	r24, 0x01	; 1
   140f8:	2a 89       	ldd	r18, Y+18	; 0x12
   140fa:	9a 85       	ldd	r25, Y+10	; 0x0a
   140fc:	29 13       	cpse	r18, r25
   140fe:	01 c0       	rjmp	.+2      	; 0x14102 <__mulsf3+0x88>
   14100:	80 e0       	ldi	r24, 0x00	; 0
   14102:	8a 87       	std	Y+10, r24	; 0x0a
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);
   14104:	ce 01       	movw	r24, r28
   14106:	09 96       	adiw	r24, 0x09	; 9
   14108:	97 c0       	rjmp	.+302    	; 0x14238 <__mulsf3+0x1be>
  /* Calculate the mantissa by multiplying both numbers to get a
     twice-as-wide number.  */
  {
#if defined(NO_DI_MODE) || defined(TFLOAT)
    {
      fractype x = a->fraction.ll;
   1410a:	8d 88       	ldd	r8, Y+21	; 0x15
   1410c:	9e 88       	ldd	r9, Y+22	; 0x16
   1410e:	af 88       	ldd	r10, Y+23	; 0x17
   14110:	b8 8c       	ldd	r11, Y+24	; 0x18
      fractype ylow = b->fraction.ll;
   14112:	0d 85       	ldd	r16, Y+13	; 0x0d
   14114:	1e 85       	ldd	r17, Y+14	; 0x0e
   14116:	2f 85       	ldd	r18, Y+15	; 0x0f
   14118:	38 89       	ldd	r19, Y+16	; 0x10
   1411a:	e0 e2       	ldi	r30, 0x20	; 32
   1411c:	f0 e0       	ldi	r31, 0x00	; 0
_fpmul_parts ( fp_number_type *  a,
	       fp_number_type *  b,
	       fp_number_type * tmp)
{
  fractype low = 0;
  fractype high = 0;
   1411e:	80 e0       	ldi	r24, 0x00	; 0
   14120:	90 e0       	ldi	r25, 0x00	; 0
   14122:	dc 01       	movw	r26, r24
  {
#if defined(NO_DI_MODE) || defined(TFLOAT)
    {
      fractype x = a->fraction.ll;
      fractype ylow = b->fraction.ll;
      fractype yhigh = 0;
   14124:	c1 2c       	mov	r12, r1
   14126:	d1 2c       	mov	r13, r1
   14128:	76 01       	movw	r14, r12
static inline __attribute__ ((__always_inline__)) const fp_number_type *
_fpmul_parts ( fp_number_type *  a,
	       fp_number_type *  b,
	       fp_number_type * tmp)
{
  fractype low = 0;
   1412a:	40 e0       	ldi	r20, 0x00	; 0
   1412c:	50 e0       	ldi	r21, 0x00	; 0
   1412e:	ba 01       	movw	r22, r20
      /* ??? This does multiplies one bit at a time.  Optimize.  */
      for (bit = 0; bit < FRAC_NBITS; bit++)
	{
	  int carry;

	  if (x & 1)
   14130:	80 fe       	sbrs	r8, 0
   14132:	18 c0       	rjmp	.+48     	; 0x14164 <__mulsf3+0xea>
	    {
	      carry = (low += ylow) < ylow;
   14134:	40 0f       	add	r20, r16
   14136:	51 1f       	adc	r21, r17
   14138:	62 1f       	adc	r22, r18
   1413a:	73 1f       	adc	r23, r19
	      high += yhigh + carry;
   1413c:	8c 0d       	add	r24, r12
   1413e:	9d 1d       	adc	r25, r13
   14140:	ae 1d       	adc	r26, r14
   14142:	bf 1d       	adc	r27, r15
	{
	  int carry;

	  if (x & 1)
	    {
	      carry = (low += ylow) < ylow;
   14144:	41 2c       	mov	r4, r1
   14146:	51 2c       	mov	r5, r1
   14148:	32 01       	movw	r6, r4
   1414a:	43 94       	inc	r4
   1414c:	40 17       	cp	r20, r16
   1414e:	51 07       	cpc	r21, r17
   14150:	62 07       	cpc	r22, r18
   14152:	73 07       	cpc	r23, r19
   14154:	18 f0       	brcs	.+6      	; 0x1415c <__mulsf3+0xe2>
   14156:	41 2c       	mov	r4, r1
   14158:	51 2c       	mov	r5, r1
   1415a:	32 01       	movw	r6, r4
	      high += yhigh + carry;
   1415c:	84 0d       	add	r24, r4
   1415e:	95 1d       	adc	r25, r5
   14160:	a6 1d       	adc	r26, r6
   14162:	b7 1d       	adc	r27, r7
	    }
	  yhigh <<= 1;
   14164:	cc 0c       	add	r12, r12
   14166:	dd 1c       	adc	r13, r13
   14168:	ee 1c       	adc	r14, r14
   1416a:	ff 1c       	adc	r15, r15
	  if (ylow & FRACHIGH)
   1416c:	37 ff       	sbrs	r19, 7
   1416e:	02 c0       	rjmp	.+4      	; 0x14174 <__mulsf3+0xfa>
	    {
	      yhigh |= 1;
   14170:	68 94       	set
   14172:	c0 f8       	bld	r12, 0
	    }
	  ylow <<= 1;
   14174:	00 0f       	add	r16, r16
   14176:	11 1f       	adc	r17, r17
   14178:	22 1f       	adc	r18, r18
   1417a:	33 1f       	adc	r19, r19
	  x >>= 1;
   1417c:	b6 94       	lsr	r11
   1417e:	a7 94       	ror	r10
   14180:	97 94       	ror	r9
   14182:	87 94       	ror	r8
   14184:	31 97       	sbiw	r30, 0x01	; 1
      fractype ylow = b->fraction.ll;
      fractype yhigh = 0;
      int bit;

      /* ??? This does multiplies one bit at a time.  Optimize.  */
      for (bit = 0; bit < FRAC_NBITS; bit++)
   14186:	a1 f6       	brne	.-88     	; 0x14130 <__mulsf3+0xb6>
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   14188:	2b 89       	ldd	r18, Y+19	; 0x13
   1418a:	3c 89       	ldd	r19, Y+20	; 0x14
   1418c:	eb 85       	ldd	r30, Y+11	; 0x0b
   1418e:	fc 85       	ldd	r31, Y+12	; 0x0c
   14190:	2e 0f       	add	r18, r30
   14192:	3f 1f       	adc	r19, r31
   14194:	2e 5f       	subi	r18, 0xFE	; 254
   14196:	3f 4f       	sbci	r19, 0xFF	; 255
   14198:	3c 83       	std	Y+4, r19	; 0x04
   1419a:	2b 83       	std	Y+3, r18	; 0x03
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1419c:	21 e0       	ldi	r18, 0x01	; 1
   1419e:	ea 89       	ldd	r30, Y+18	; 0x12
   141a0:	3a 85       	ldd	r19, Y+10	; 0x0a
   141a2:	e3 13       	cpse	r30, r19
   141a4:	01 c0       	rjmp	.+2      	; 0x141a8 <__mulsf3+0x12e>
   141a6:	20 e0       	ldi	r18, 0x00	; 0
   141a8:	2a 83       	std	Y+2, r18	; 0x02
   141aa:	eb 81       	ldd	r30, Y+3	; 0x03
   141ac:	fc 81       	ldd	r31, Y+4	; 0x04
   141ae:	0c c0       	rjmp	.+24     	; 0x141c8 <__mulsf3+0x14e>
  while (high >= IMPLICIT_2)
    {
      tmp->normal_exp++;
      if (high & 1)
   141b0:	80 ff       	sbrs	r24, 0
   141b2:	05 c0       	rjmp	.+10     	; 0x141be <__mulsf3+0x144>
	{
	  low >>= 1;
   141b4:	76 95       	lsr	r23
   141b6:	67 95       	ror	r22
   141b8:	57 95       	ror	r21
   141ba:	47 95       	ror	r20
	  low |= FRACHIGH;
   141bc:	70 68       	ori	r23, 0x80	; 128
	}
      high >>= 1;
   141be:	b6 95       	lsr	r27
   141c0:	a7 95       	ror	r26
   141c2:	97 95       	ror	r25
   141c4:	87 95       	ror	r24
   141c6:	31 96       	adiw	r30, 0x01	; 1
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   141c8:	b7 fd       	sbrc	r27, 7
   141ca:	f2 cf       	rjmp	.-28     	; 0x141b0 <__mulsf3+0x136>
   141cc:	9f 01       	movw	r18, r30
   141ce:	0c c0       	rjmp	.+24     	; 0x141e8 <__mulsf3+0x16e>
    }
  while (high < IMPLICIT_1)
    {
      tmp->normal_exp--;

      high <<= 1;
   141d0:	88 0f       	add	r24, r24
   141d2:	99 1f       	adc	r25, r25
   141d4:	aa 1f       	adc	r26, r26
   141d6:	bb 1f       	adc	r27, r27
      if (low & FRACHIGH)
   141d8:	77 fd       	sbrc	r23, 7
	high |= 1;
   141da:	81 60       	ori	r24, 0x01	; 1
      low <<= 1;
   141dc:	44 0f       	add	r20, r20
   141de:	55 1f       	adc	r21, r21
   141e0:	66 1f       	adc	r22, r22
   141e2:	77 1f       	adc	r23, r23
   141e4:	21 50       	subi	r18, 0x01	; 1
   141e6:	31 09       	sbc	r19, r1
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   141e8:	00 97       	sbiw	r24, 0x00	; 0
   141ea:	a1 05       	cpc	r26, r1
   141ec:	e0 e4       	ldi	r30, 0x40	; 64
   141ee:	be 07       	cpc	r27, r30
   141f0:	78 f3       	brcs	.-34     	; 0x141d0 <__mulsf3+0x156>
   141f2:	2b 83       	std	Y+3, r18	; 0x03
   141f4:	3c 83       	std	Y+4, r19	; 0x04
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
    }

  if (!ROUND_TOWARDS_ZERO && (high & GARDMASK) == GARDMSB)
   141f6:	8c 01       	movw	r16, r24
   141f8:	9d 01       	movw	r18, r26
   141fa:	0f 77       	andi	r16, 0x7F	; 127
   141fc:	11 27       	eor	r17, r17
   141fe:	22 27       	eor	r18, r18
   14200:	33 27       	eor	r19, r19
   14202:	00 34       	cpi	r16, 0x40	; 64
   14204:	11 05       	cpc	r17, r1
   14206:	21 05       	cpc	r18, r1
   14208:	31 05       	cpc	r19, r1
   1420a:	59 f4       	brne	.+22     	; 0x14222 <__mulsf3+0x1a8>
    {
      if (high & (1 << NGARDS))
   1420c:	87 fd       	sbrc	r24, 7
   1420e:	09 c0       	rjmp	.+18     	; 0x14222 <__mulsf3+0x1a8>
	     function, and rounding twice will lose precision and cause
	     the result to be too far off.  Example: 32-bit floats with
	     bit patterns 0xfff * 0x3f800400 ~= 0xfff (less than 0.5ulp
	     off), not 0x1000 (more than 0.5ulp off).  */
	}
      else if (low)
   14210:	45 2b       	or	r20, r21
   14212:	46 2b       	or	r20, r22
   14214:	47 2b       	or	r20, r23
   14216:	29 f0       	breq	.+10     	; 0x14222 <__mulsf3+0x1a8>
	{
	  /* We're a further than half way by a small amount corresponding
	     to the bits set in "low".  Knowing that, we round here and
	     not in pack_d, because there we don't have "low" available
	     anymore.  */
	  high += GARDROUND + 1;
   14218:	80 5c       	subi	r24, 0xC0	; 192
   1421a:	9f 4f       	sbci	r25, 0xFF	; 255
   1421c:	af 4f       	sbci	r26, 0xFF	; 255
   1421e:	bf 4f       	sbci	r27, 0xFF	; 255

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
   14220:	80 78       	andi	r24, 0x80	; 128
	}
    }
  tmp->fraction.ll = high;
   14222:	8d 83       	std	Y+5, r24	; 0x05
   14224:	9e 83       	std	Y+6, r25	; 0x06
   14226:	af 83       	std	Y+7, r26	; 0x07
   14228:	b8 87       	std	Y+8, r27	; 0x08
  tmp->class = CLASS_NUMBER;
   1422a:	83 e0       	ldi	r24, 0x03	; 3
   1422c:	89 83       	std	Y+1, r24	; 0x01
  return tmp;
   1422e:	ce 01       	movw	r24, r28
   14230:	01 96       	adiw	r24, 0x01	; 1
   14232:	02 c0       	rjmp	.+4      	; 0x14238 <__mulsf3+0x1be>
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
	return makenan ();
   14234:	8f eb       	ldi	r24, 0xBF	; 191
   14236:	94 e0       	ldi	r25, 0x04	; 4
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   14238:	0e 94 cf a3 	call	0x1479e	; 0x1479e <__pack_f>
}
   1423c:	a0 96       	adiw	r28, 0x20	; 32
   1423e:	e0 e1       	ldi	r30, 0x10	; 16
   14240:	0c 94 1a ae 	jmp	0x15c34	; 0x15c34 <__epilogue_restores__+0x4>

00014244 <__divsf3>:
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   14244:	a8 e1       	ldi	r26, 0x18	; 24
   14246:	b0 e0       	ldi	r27, 0x00	; 0
   14248:	e8 e2       	ldi	r30, 0x28	; 40
   1424a:	f1 ea       	ldi	r31, 0xA1	; 161
   1424c:	0c 94 06 ae 	jmp	0x15c0c	; 0x15c0c <__prologue_saves__+0x14>
  fp_number_type a;
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   14250:	6d 8b       	std	Y+21, r22	; 0x15
   14252:	7e 8b       	std	Y+22, r23	; 0x16
   14254:	8f 8b       	std	Y+23, r24	; 0x17
   14256:	98 8f       	std	Y+24, r25	; 0x18
  bu.value = arg_b;
   14258:	29 8b       	std	Y+17, r18	; 0x11
   1425a:	3a 8b       	std	Y+18, r19	; 0x12
   1425c:	4b 8b       	std	Y+19, r20	; 0x13
   1425e:	5c 8b       	std	Y+20, r21	; 0x14

  unpack_d (&au, &a);
   14260:	be 01       	movw	r22, r28
   14262:	67 5f       	subi	r22, 0xF7	; 247
   14264:	7f 4f       	sbci	r23, 0xFF	; 255
   14266:	ce 01       	movw	r24, r28
   14268:	45 96       	adiw	r24, 0x15	; 21
   1426a:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>
  unpack_d (&bu, &b);
   1426e:	be 01       	movw	r22, r28
   14270:	6f 5f       	subi	r22, 0xFF	; 255
   14272:	7f 4f       	sbci	r23, 0xFF	; 255
   14274:	ce 01       	movw	r24, r28
   14276:	41 96       	adiw	r24, 0x11	; 17
   14278:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>

  res = _fpdiv_parts (&a, &b);

  return pack_d (res);
}
   1427c:	99 85       	ldd	r25, Y+9	; 0x09
  fractype bit;
  fractype numerator;
  fractype denominator;
  fractype quotient;

  if (isnan (a))
   1427e:	92 30       	cpi	r25, 0x02	; 2
   14280:	08 f4       	brcc	.+2      	; 0x14284 <__divsf3+0x40>
   14282:	75 c0       	rjmp	.+234    	; 0x1436e <__divsf3+0x12a>
  unpack_d (&bu, &b);

  res = _fpdiv_parts (&a, &b);

  return pack_d (res);
}
   14284:	89 81       	ldd	r24, Y+1	; 0x01

  if (isnan (a))
    {
      return a;
    }
  if (isnan (b))
   14286:	82 30       	cpi	r24, 0x02	; 2
   14288:	08 f4       	brcc	.+2      	; 0x1428c <__divsf3+0x48>
   1428a:	74 c0       	rjmp	.+232    	; 0x14374 <__divsf3+0x130>
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1428c:	2a 85       	ldd	r18, Y+10	; 0x0a
   1428e:	3a 81       	ldd	r19, Y+2	; 0x02
   14290:	23 27       	eor	r18, r19
   14292:	2a 87       	std	Y+10, r18	; 0x0a

  if (isinf (a) || iszero (a))
   14294:	94 30       	cpi	r25, 0x04	; 4
   14296:	11 f0       	breq	.+4      	; 0x1429c <__divsf3+0x58>
   14298:	92 30       	cpi	r25, 0x02	; 2
   1429a:	19 f4       	brne	.+6      	; 0x142a2 <__divsf3+0x5e>
    {
      if (a->class == b->class)
   1429c:	98 13       	cpse	r25, r24
   1429e:	67 c0       	rjmp	.+206    	; 0x1436e <__divsf3+0x12a>
   142a0:	6c c0       	rjmp	.+216    	; 0x1437a <__divsf3+0x136>
	return makenan ();
      return a;
    }

  if (isinf (b))
   142a2:	84 30       	cpi	r24, 0x04	; 4
   142a4:	39 f4       	brne	.+14     	; 0x142b4 <__divsf3+0x70>
    {
      a->fraction.ll = 0;
   142a6:	1d 86       	std	Y+13, r1	; 0x0d
   142a8:	1e 86       	std	Y+14, r1	; 0x0e
   142aa:	1f 86       	std	Y+15, r1	; 0x0f
   142ac:	18 8a       	std	Y+16, r1	; 0x10
      a->normal_exp = 0;
   142ae:	1c 86       	std	Y+12, r1	; 0x0c
   142b0:	1b 86       	std	Y+11, r1	; 0x0b
   142b2:	04 c0       	rjmp	.+8      	; 0x142bc <__divsf3+0x78>
      return a;
    }
  if (iszero (b))
   142b4:	82 30       	cpi	r24, 0x02	; 2
   142b6:	29 f4       	brne	.+10     	; 0x142c2 <__divsf3+0x7e>
    {
      a->class = CLASS_INFINITY;
   142b8:	84 e0       	ldi	r24, 0x04	; 4
   142ba:	89 87       	std	Y+9, r24	; 0x09
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpdiv_parts (&a, &b);
   142bc:	ce 01       	movw	r24, r28
   142be:	09 96       	adiw	r24, 0x09	; 9
   142c0:	5e c0       	rjmp	.+188    	; 0x1437e <__divsf3+0x13a>
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   142c2:	8b 85       	ldd	r24, Y+11	; 0x0b
   142c4:	9c 85       	ldd	r25, Y+12	; 0x0c
   142c6:	2b 81       	ldd	r18, Y+3	; 0x03
   142c8:	3c 81       	ldd	r19, Y+4	; 0x04
   142ca:	82 1b       	sub	r24, r18
   142cc:	93 0b       	sbc	r25, r19
   142ce:	9c 87       	std	Y+12, r25	; 0x0c
   142d0:	8b 87       	std	Y+11, r24	; 0x0b
    numerator = a->fraction.ll;
   142d2:	4d 85       	ldd	r20, Y+13	; 0x0d
   142d4:	5e 85       	ldd	r21, Y+14	; 0x0e
   142d6:	6f 85       	ldd	r22, Y+15	; 0x0f
   142d8:	78 89       	ldd	r23, Y+16	; 0x10
    denominator = b->fraction.ll;
   142da:	cd 80       	ldd	r12, Y+5	; 0x05
   142dc:	de 80       	ldd	r13, Y+6	; 0x06
   142de:	ef 80       	ldd	r14, Y+7	; 0x07
   142e0:	f8 84       	ldd	r15, Y+8	; 0x08

    if (numerator < denominator)
   142e2:	4c 15       	cp	r20, r12
   142e4:	5d 05       	cpc	r21, r13
   142e6:	6e 05       	cpc	r22, r14
   142e8:	7f 05       	cpc	r23, r15
   142ea:	38 f4       	brcc	.+14     	; 0x142fa <__divsf3+0xb6>
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
   142ec:	44 0f       	add	r20, r20
   142ee:	55 1f       	adc	r21, r21
   142f0:	66 1f       	adc	r22, r22
   142f2:	77 1f       	adc	r23, r23
	a->normal_exp--;
   142f4:	01 97       	sbiw	r24, 0x01	; 1
   142f6:	9c 87       	std	Y+12, r25	; 0x0c
   142f8:	8b 87       	std	Y+11, r24	; 0x0b
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   142fa:	ef e1       	ldi	r30, 0x1F	; 31
   142fc:	f0 e0       	ldi	r31, 0x00	; 0
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
   142fe:	00 e0       	ldi	r16, 0x00	; 0
   14300:	10 e0       	ldi	r17, 0x00	; 0
   14302:	20 e0       	ldi	r18, 0x00	; 0
   14304:	30 e4       	ldi	r19, 0x40	; 64
    quotient = 0;
   14306:	80 e0       	ldi	r24, 0x00	; 0
   14308:	90 e0       	ldi	r25, 0x00	; 0
   1430a:	dc 01       	movw	r26, r24
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
   1430c:	4c 15       	cp	r20, r12
   1430e:	5d 05       	cpc	r21, r13
   14310:	6e 05       	cpc	r22, r14
   14312:	7f 05       	cpc	r23, r15
   14314:	40 f0       	brcs	.+16     	; 0x14326 <__divsf3+0xe2>
	  {
	    quotient |= bit;
   14316:	80 2b       	or	r24, r16
   14318:	91 2b       	or	r25, r17
   1431a:	a2 2b       	or	r26, r18
   1431c:	b3 2b       	or	r27, r19
	    numerator -= denominator;
   1431e:	4c 19       	sub	r20, r12
   14320:	5d 09       	sbc	r21, r13
   14322:	6e 09       	sbc	r22, r14
   14324:	7f 09       	sbc	r23, r15
	  }
	bit >>= 1;
   14326:	36 95       	lsr	r19
   14328:	27 95       	ror	r18
   1432a:	17 95       	ror	r17
   1432c:	07 95       	ror	r16
	numerator *= 2;
   1432e:	44 0f       	add	r20, r20
   14330:	55 1f       	adc	r21, r21
   14332:	66 1f       	adc	r22, r22
   14334:	77 1f       	adc	r23, r23
   14336:	31 97       	sbiw	r30, 0x01	; 1
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
   14338:	49 f7       	brne	.-46     	; 0x1430c <__divsf3+0xc8>
	  }
	bit >>= 1;
	numerator *= 2;
      }

    if (!ROUND_TOWARDS_ZERO && (quotient & GARDMASK) == GARDMSB)
   1433a:	8c 01       	movw	r16, r24
   1433c:	9d 01       	movw	r18, r26
   1433e:	0f 77       	andi	r16, 0x7F	; 127
   14340:	11 27       	eor	r17, r17
   14342:	22 27       	eor	r18, r18
   14344:	33 27       	eor	r19, r19
   14346:	00 34       	cpi	r16, 0x40	; 64
   14348:	11 05       	cpc	r17, r1
   1434a:	21 05       	cpc	r18, r1
   1434c:	31 05       	cpc	r19, r1
   1434e:	59 f4       	brne	.+22     	; 0x14366 <__divsf3+0x122>
      {
	if (quotient & (1 << NGARDS))
   14350:	87 fd       	sbrc	r24, 7
   14352:	09 c0       	rjmp	.+18     	; 0x14366 <__divsf3+0x122>
	    /* Because we're half way, we would round to even by adding
	       GARDROUND + 1, except that's also done in the packing
	       function, and rounding twice will lose precision and cause
	       the result to be too far off.  */
	  }
	else if (numerator)
   14354:	45 2b       	or	r20, r21
   14356:	46 2b       	or	r20, r22
   14358:	47 2b       	or	r20, r23
   1435a:	29 f0       	breq	.+10     	; 0x14366 <__divsf3+0x122>
	  {
	    /* We're a further than half way by the small amount
	       corresponding to the bits set in "numerator".  Knowing
	       that, we round here and not in pack_d, because there we
	       don't have "numerator" available anymore.  */
	    quotient += GARDROUND + 1;
   1435c:	80 5c       	subi	r24, 0xC0	; 192
   1435e:	9f 4f       	sbci	r25, 0xFF	; 255
   14360:	af 4f       	sbci	r26, 0xFF	; 255
   14362:	bf 4f       	sbci	r27, 0xFF	; 255

	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
   14364:	80 78       	andi	r24, 0x80	; 128
	  }
      }

    a->fraction.ll = quotient;
   14366:	8d 87       	std	Y+13, r24	; 0x0d
   14368:	9e 87       	std	Y+14, r25	; 0x0e
   1436a:	af 87       	std	Y+15, r26	; 0x0f
   1436c:	b8 8b       	std	Y+16, r27	; 0x10
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpdiv_parts (&a, &b);
   1436e:	ce 01       	movw	r24, r28
   14370:	09 96       	adiw	r24, 0x09	; 9
   14372:	05 c0       	rjmp	.+10     	; 0x1437e <__divsf3+0x13a>
    {
      return a;
    }
  if (isnan (b))
    {
      return b;
   14374:	ce 01       	movw	r24, r28
   14376:	01 96       	adiw	r24, 0x01	; 1
   14378:	02 c0       	rjmp	.+4      	; 0x1437e <__divsf3+0x13a>
  a->sign = a->sign ^ b->sign;

  if (isinf (a) || iszero (a))
    {
      if (a->class == b->class)
	return makenan ();
   1437a:	8f eb       	ldi	r24, 0xBF	; 191
   1437c:	94 e0       	ldi	r25, 0x04	; 4
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpdiv_parts (&a, &b);

  return pack_d (res);
   1437e:	0e 94 cf a3 	call	0x1479e	; 0x1479e <__pack_f>
}
   14382:	68 96       	adiw	r28, 0x18	; 24
   14384:	e8 e0       	ldi	r30, 0x08	; 8
   14386:	0c 94 22 ae 	jmp	0x15c44	; 0x15c44 <__epilogue_restores__+0x14>

0001438a <__gtsf2>:
#endif /* L_ne_sf || L_ne_df */

#if defined(L_gt_sf) || defined(L_gt_df) || defined(L_gt_tf)
CMPtype
_gt_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1438a:	a8 e1       	ldi	r26, 0x18	; 24
   1438c:	b0 e0       	ldi	r27, 0x00	; 0
   1438e:	eb ec       	ldi	r30, 0xCB	; 203
   14390:	f1 ea       	ldi	r31, 0xA1	; 161
   14392:	0c 94 0c ae 	jmp	0x15c18	; 0x15c18 <__prologue_saves__+0x20>
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   14396:	6d 8b       	std	Y+21, r22	; 0x15
   14398:	7e 8b       	std	Y+22, r23	; 0x16
   1439a:	8f 8b       	std	Y+23, r24	; 0x17
   1439c:	98 8f       	std	Y+24, r25	; 0x18
  bu.value = arg_b;
   1439e:	29 8b       	std	Y+17, r18	; 0x11
   143a0:	3a 8b       	std	Y+18, r19	; 0x12
   143a2:	4b 8b       	std	Y+19, r20	; 0x13
   143a4:	5c 8b       	std	Y+20, r21	; 0x14

  unpack_d (&au, &a);
   143a6:	be 01       	movw	r22, r28
   143a8:	67 5f       	subi	r22, 0xF7	; 247
   143aa:	7f 4f       	sbci	r23, 0xFF	; 255
   143ac:	ce 01       	movw	r24, r28
   143ae:	45 96       	adiw	r24, 0x15	; 21
   143b0:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>
  unpack_d (&bu, &b);
   143b4:	be 01       	movw	r22, r28
   143b6:	6f 5f       	subi	r22, 0xFF	; 255
   143b8:	7f 4f       	sbci	r23, 0xFF	; 255
   143ba:	ce 01       	movw	r24, r28
   143bc:	41 96       	adiw	r24, 0x11	; 17
   143be:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>

  if (isnan (&a) || isnan (&b))
   143c2:	89 85       	ldd	r24, Y+9	; 0x09
   143c4:	82 30       	cpi	r24, 0x02	; 2
   143c6:	58 f0       	brcs	.+22     	; 0x143de <__gtsf2+0x54>
   143c8:	89 81       	ldd	r24, Y+1	; 0x01
   143ca:	82 30       	cpi	r24, 0x02	; 2
   143cc:	40 f0       	brcs	.+16     	; 0x143de <__gtsf2+0x54>
    return -1;			/* false, truth > 0 */

  return __fpcmp_parts (&a, &b);
   143ce:	be 01       	movw	r22, r28
   143d0:	6f 5f       	subi	r22, 0xFF	; 255
   143d2:	7f 4f       	sbci	r23, 0xFF	; 255
   143d4:	ce 01       	movw	r24, r28
   143d6:	09 96       	adiw	r24, 0x09	; 9
   143d8:	0e 94 08 a5 	call	0x14a10	; 0x14a10 <__fpcmp_parts_f>
   143dc:	01 c0       	rjmp	.+2      	; 0x143e0 <__gtsf2+0x56>

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  if (isnan (&a) || isnan (&b))
    return -1;			/* false, truth > 0 */
   143de:	8f ef       	ldi	r24, 0xFF	; 255

  return __fpcmp_parts (&a, &b);
}
   143e0:	68 96       	adiw	r28, 0x18	; 24
   143e2:	e2 e0       	ldi	r30, 0x02	; 2
   143e4:	0c 94 28 ae 	jmp	0x15c50	; 0x15c50 <__epilogue_restores__+0x20>

000143e8 <__gesf2>:
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   143e8:	a8 e1       	ldi	r26, 0x18	; 24
   143ea:	b0 e0       	ldi	r27, 0x00	; 0
   143ec:	ea ef       	ldi	r30, 0xFA	; 250
   143ee:	f1 ea       	ldi	r31, 0xA1	; 161
   143f0:	0c 94 0c ae 	jmp	0x15c18	; 0x15c18 <__prologue_saves__+0x20>
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   143f4:	6d 8b       	std	Y+21, r22	; 0x15
   143f6:	7e 8b       	std	Y+22, r23	; 0x16
   143f8:	8f 8b       	std	Y+23, r24	; 0x17
   143fa:	98 8f       	std	Y+24, r25	; 0x18
  bu.value = arg_b;
   143fc:	29 8b       	std	Y+17, r18	; 0x11
   143fe:	3a 8b       	std	Y+18, r19	; 0x12
   14400:	4b 8b       	std	Y+19, r20	; 0x13
   14402:	5c 8b       	std	Y+20, r21	; 0x14

  unpack_d (&au, &a);
   14404:	be 01       	movw	r22, r28
   14406:	67 5f       	subi	r22, 0xF7	; 247
   14408:	7f 4f       	sbci	r23, 0xFF	; 255
   1440a:	ce 01       	movw	r24, r28
   1440c:	45 96       	adiw	r24, 0x15	; 21
   1440e:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>
  unpack_d (&bu, &b);
   14412:	be 01       	movw	r22, r28
   14414:	6f 5f       	subi	r22, 0xFF	; 255
   14416:	7f 4f       	sbci	r23, 0xFF	; 255
   14418:	ce 01       	movw	r24, r28
   1441a:	41 96       	adiw	r24, 0x11	; 17
   1441c:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>

  if (isnan (&a) || isnan (&b))
   14420:	89 85       	ldd	r24, Y+9	; 0x09
   14422:	82 30       	cpi	r24, 0x02	; 2
   14424:	58 f0       	brcs	.+22     	; 0x1443c <__gesf2+0x54>
   14426:	89 81       	ldd	r24, Y+1	; 0x01
   14428:	82 30       	cpi	r24, 0x02	; 2
   1442a:	40 f0       	brcs	.+16     	; 0x1443c <__gesf2+0x54>
    return -1;			/* false, truth >= 0 */
  return __fpcmp_parts (&a, &b) ;
   1442c:	be 01       	movw	r22, r28
   1442e:	6f 5f       	subi	r22, 0xFF	; 255
   14430:	7f 4f       	sbci	r23, 0xFF	; 255
   14432:	ce 01       	movw	r24, r28
   14434:	09 96       	adiw	r24, 0x09	; 9
   14436:	0e 94 08 a5 	call	0x14a10	; 0x14a10 <__fpcmp_parts_f>
   1443a:	01 c0       	rjmp	.+2      	; 0x1443e <__gesf2+0x56>

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  if (isnan (&a) || isnan (&b))
    return -1;			/* false, truth >= 0 */
   1443c:	8f ef       	ldi	r24, 0xFF	; 255
  return __fpcmp_parts (&a, &b) ;
}
   1443e:	68 96       	adiw	r28, 0x18	; 24
   14440:	e2 e0       	ldi	r30, 0x02	; 2
   14442:	0c 94 28 ae 	jmp	0x15c50	; 0x15c50 <__epilogue_restores__+0x20>

00014446 <__ltsf2>:
#endif /* L_ge_sf || L_ge_df */

#if defined(L_lt_sf) || defined(L_lt_df) || defined(L_lt_tf)
CMPtype
_lt_f2 (FLO_type arg_a, FLO_type arg_b)
{
   14446:	a8 e1       	ldi	r26, 0x18	; 24
   14448:	b0 e0       	ldi	r27, 0x00	; 0
   1444a:	e9 e2       	ldi	r30, 0x29	; 41
   1444c:	f2 ea       	ldi	r31, 0xA2	; 162
   1444e:	0c 94 0c ae 	jmp	0x15c18	; 0x15c18 <__prologue_saves__+0x20>
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   14452:	6d 8b       	std	Y+21, r22	; 0x15
   14454:	7e 8b       	std	Y+22, r23	; 0x16
   14456:	8f 8b       	std	Y+23, r24	; 0x17
   14458:	98 8f       	std	Y+24, r25	; 0x18
  bu.value = arg_b;
   1445a:	29 8b       	std	Y+17, r18	; 0x11
   1445c:	3a 8b       	std	Y+18, r19	; 0x12
   1445e:	4b 8b       	std	Y+19, r20	; 0x13
   14460:	5c 8b       	std	Y+20, r21	; 0x14

  unpack_d (&au, &a);
   14462:	be 01       	movw	r22, r28
   14464:	67 5f       	subi	r22, 0xF7	; 247
   14466:	7f 4f       	sbci	r23, 0xFF	; 255
   14468:	ce 01       	movw	r24, r28
   1446a:	45 96       	adiw	r24, 0x15	; 21
   1446c:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>
  unpack_d (&bu, &b);
   14470:	be 01       	movw	r22, r28
   14472:	6f 5f       	subi	r22, 0xFF	; 255
   14474:	7f 4f       	sbci	r23, 0xFF	; 255
   14476:	ce 01       	movw	r24, r28
   14478:	41 96       	adiw	r24, 0x11	; 17
   1447a:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>

  if (isnan (&a) || isnan (&b))
   1447e:	89 85       	ldd	r24, Y+9	; 0x09
   14480:	82 30       	cpi	r24, 0x02	; 2
   14482:	58 f0       	brcs	.+22     	; 0x1449a <__ltsf2+0x54>
   14484:	89 81       	ldd	r24, Y+1	; 0x01
   14486:	82 30       	cpi	r24, 0x02	; 2
   14488:	40 f0       	brcs	.+16     	; 0x1449a <__ltsf2+0x54>
    return 1;			/* false, truth < 0 */

  return __fpcmp_parts (&a, &b);
   1448a:	be 01       	movw	r22, r28
   1448c:	6f 5f       	subi	r22, 0xFF	; 255
   1448e:	7f 4f       	sbci	r23, 0xFF	; 255
   14490:	ce 01       	movw	r24, r28
   14492:	09 96       	adiw	r24, 0x09	; 9
   14494:	0e 94 08 a5 	call	0x14a10	; 0x14a10 <__fpcmp_parts_f>
   14498:	01 c0       	rjmp	.+2      	; 0x1449c <__ltsf2+0x56>

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  if (isnan (&a) || isnan (&b))
    return 1;			/* false, truth < 0 */
   1449a:	81 e0       	ldi	r24, 0x01	; 1

  return __fpcmp_parts (&a, &b);
}
   1449c:	68 96       	adiw	r28, 0x18	; 24
   1449e:	e2 e0       	ldi	r30, 0x02	; 2
   144a0:	0c 94 28 ae 	jmp	0x15c50	; 0x15c50 <__epilogue_restores__+0x20>

000144a4 <__lesf2>:
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   144a4:	a8 e1       	ldi	r26, 0x18	; 24
   144a6:	b0 e0       	ldi	r27, 0x00	; 0
   144a8:	e8 e5       	ldi	r30, 0x58	; 88
   144aa:	f2 ea       	ldi	r31, 0xA2	; 162
   144ac:	0c 94 0c ae 	jmp	0x15c18	; 0x15c18 <__prologue_saves__+0x20>
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   144b0:	6d 8b       	std	Y+21, r22	; 0x15
   144b2:	7e 8b       	std	Y+22, r23	; 0x16
   144b4:	8f 8b       	std	Y+23, r24	; 0x17
   144b6:	98 8f       	std	Y+24, r25	; 0x18
  bu.value = arg_b;
   144b8:	29 8b       	std	Y+17, r18	; 0x11
   144ba:	3a 8b       	std	Y+18, r19	; 0x12
   144bc:	4b 8b       	std	Y+19, r20	; 0x13
   144be:	5c 8b       	std	Y+20, r21	; 0x14

  unpack_d (&au, &a);
   144c0:	be 01       	movw	r22, r28
   144c2:	67 5f       	subi	r22, 0xF7	; 247
   144c4:	7f 4f       	sbci	r23, 0xFF	; 255
   144c6:	ce 01       	movw	r24, r28
   144c8:	45 96       	adiw	r24, 0x15	; 21
   144ca:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>
  unpack_d (&bu, &b);
   144ce:	be 01       	movw	r22, r28
   144d0:	6f 5f       	subi	r22, 0xFF	; 255
   144d2:	7f 4f       	sbci	r23, 0xFF	; 255
   144d4:	ce 01       	movw	r24, r28
   144d6:	41 96       	adiw	r24, 0x11	; 17
   144d8:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>

  if (isnan (&a) || isnan (&b))
   144dc:	89 85       	ldd	r24, Y+9	; 0x09
   144de:	82 30       	cpi	r24, 0x02	; 2
   144e0:	58 f0       	brcs	.+22     	; 0x144f8 <__lesf2+0x54>
   144e2:	89 81       	ldd	r24, Y+1	; 0x01
   144e4:	82 30       	cpi	r24, 0x02	; 2
   144e6:	40 f0       	brcs	.+16     	; 0x144f8 <__lesf2+0x54>
    return 1;			/* false, truth <= 0 */

  return __fpcmp_parts (&a, &b) ;
   144e8:	be 01       	movw	r22, r28
   144ea:	6f 5f       	subi	r22, 0xFF	; 255
   144ec:	7f 4f       	sbci	r23, 0xFF	; 255
   144ee:	ce 01       	movw	r24, r28
   144f0:	09 96       	adiw	r24, 0x09	; 9
   144f2:	0e 94 08 a5 	call	0x14a10	; 0x14a10 <__fpcmp_parts_f>
   144f6:	01 c0       	rjmp	.+2      	; 0x144fa <__lesf2+0x56>

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  if (isnan (&a) || isnan (&b))
    return 1;			/* false, truth <= 0 */
   144f8:	81 e0       	ldi	r24, 0x01	; 1

  return __fpcmp_parts (&a, &b) ;
}
   144fa:	68 96       	adiw	r28, 0x18	; 24
   144fc:	e2 e0       	ldi	r30, 0x02	; 2
   144fe:	0c 94 28 ae 	jmp	0x15c50	; 0x15c50 <__epilogue_restores__+0x20>

00014502 <__unordsf2>:
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   14502:	a8 e1       	ldi	r26, 0x18	; 24
   14504:	b0 e0       	ldi	r27, 0x00	; 0
   14506:	e7 e8       	ldi	r30, 0x87	; 135
   14508:	f2 ea       	ldi	r31, 0xA2	; 162
   1450a:	0c 94 0c ae 	jmp	0x15c18	; 0x15c18 <__prologue_saves__+0x20>
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1450e:	6d 8b       	std	Y+21, r22	; 0x15
   14510:	7e 8b       	std	Y+22, r23	; 0x16
   14512:	8f 8b       	std	Y+23, r24	; 0x17
   14514:	98 8f       	std	Y+24, r25	; 0x18
  bu.value = arg_b;
   14516:	29 8b       	std	Y+17, r18	; 0x11
   14518:	3a 8b       	std	Y+18, r19	; 0x12
   1451a:	4b 8b       	std	Y+19, r20	; 0x13
   1451c:	5c 8b       	std	Y+20, r21	; 0x14

  unpack_d (&au, &a);
   1451e:	be 01       	movw	r22, r28
   14520:	67 5f       	subi	r22, 0xF7	; 247
   14522:	7f 4f       	sbci	r23, 0xFF	; 255
   14524:	ce 01       	movw	r24, r28
   14526:	45 96       	adiw	r24, 0x15	; 21
   14528:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>
  unpack_d (&bu, &b);
   1452c:	be 01       	movw	r22, r28
   1452e:	6f 5f       	subi	r22, 0xFF	; 255
   14530:	7f 4f       	sbci	r23, 0xFF	; 255
   14532:	ce 01       	movw	r24, r28
   14534:	41 96       	adiw	r24, 0x11	; 17
   14536:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>

  return (isnan (&a) || isnan (&b));
   1453a:	89 85       	ldd	r24, Y+9	; 0x09
   1453c:	82 30       	cpi	r24, 0x02	; 2
   1453e:	40 f0       	brcs	.+16     	; 0x14550 <__unordsf2+0x4e>

INLINE
static int
isnan (const fp_number_type *x)
{
  return __builtin_expect (x->class == CLASS_SNAN || x->class == CLASS_QNAN,
   14540:	81 e0       	ldi	r24, 0x01	; 1
   14542:	90 e0       	ldi	r25, 0x00	; 0
   14544:	29 81       	ldd	r18, Y+1	; 0x01
   14546:	22 30       	cpi	r18, 0x02	; 2
   14548:	28 f0       	brcs	.+10     	; 0x14554 <__unordsf2+0x52>
   1454a:	80 e0       	ldi	r24, 0x00	; 0
   1454c:	90 e0       	ldi	r25, 0x00	; 0
   1454e:	02 c0       	rjmp	.+4      	; 0x14554 <__unordsf2+0x52>
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  return (isnan (&a) || isnan (&b));
   14550:	81 e0       	ldi	r24, 0x01	; 1
   14552:	90 e0       	ldi	r25, 0x00	; 0
}
   14554:	68 96       	adiw	r28, 0x18	; 24
   14556:	e2 e0       	ldi	r30, 0x02	; 2
   14558:	0c 94 28 ae 	jmp	0x15c50	; 0x15c50 <__epilogue_restores__+0x20>

0001455c <__floatsisf>:
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1455c:	a8 e0       	ldi	r26, 0x08	; 8
   1455e:	b0 e0       	ldi	r27, 0x00	; 0
   14560:	e4 eb       	ldi	r30, 0xB4	; 180
   14562:	f2 ea       	ldi	r31, 0xA2	; 162
   14564:	0c 94 0a ae 	jmp	0x15c14	; 0x15c14 <__prologue_saves__+0x1c>
  fp_number_type in;

  in.class = CLASS_NUMBER;
   14568:	23 e0       	ldi	r18, 0x03	; 3
   1456a:	29 83       	std	Y+1, r18	; 0x01
  in.sign = arg_a < 0;
   1456c:	8b 01       	movw	r16, r22
   1456e:	9c 01       	movw	r18, r24
   14570:	00 27       	eor	r16, r16
   14572:	37 fd       	sbrc	r19, 7
   14574:	03 95       	inc	r16
   14576:	11 27       	eor	r17, r17
   14578:	22 27       	eor	r18, r18
   1457a:	33 27       	eor	r19, r19
   1457c:	40 2f       	mov	r20, r16
   1457e:	0a 83       	std	Y+2, r16	; 0x02
  if (!arg_a)
   14580:	61 15       	cp	r22, r1
   14582:	71 05       	cpc	r23, r1
   14584:	81 05       	cpc	r24, r1
   14586:	91 05       	cpc	r25, r1
   14588:	19 f4       	brne	.+6      	; 0x14590 <__floatsisf+0x34>
    {
      in.class = CLASS_ZERO;
   1458a:	82 e0       	ldi	r24, 0x02	; 2
   1458c:	89 83       	std	Y+1, r24	; 0x01
   1458e:	35 c0       	rjmp	.+106    	; 0x145fa <__floatsisf+0x9e>
    }
  else
    {
      USItype uarg;
      int shift;
      in.normal_exp = FRACBITS + NGARDS;
   14590:	2e e1       	ldi	r18, 0x1E	; 30
   14592:	30 e0       	ldi	r19, 0x00	; 0
   14594:	3c 83       	std	Y+4, r19	; 0x04
   14596:	2b 83       	std	Y+3, r18	; 0x03
      if (in.sign) 
   14598:	44 23       	and	r20, r20
   1459a:	71 f0       	breq	.+28     	; 0x145b8 <__floatsisf+0x5c>
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
   1459c:	61 15       	cp	r22, r1
   1459e:	71 05       	cpc	r23, r1
   145a0:	81 05       	cpc	r24, r1
   145a2:	20 e8       	ldi	r18, 0x80	; 128
   145a4:	92 07       	cpc	r25, r18
   145a6:	71 f1       	breq	.+92     	; 0x14604 <__floatsisf+0xa8>
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
   145a8:	00 27       	eor	r16, r16
   145aa:	11 27       	eor	r17, r17
   145ac:	98 01       	movw	r18, r16
   145ae:	06 1b       	sub	r16, r22
   145b0:	17 0b       	sbc	r17, r23
   145b2:	28 0b       	sbc	r18, r24
   145b4:	39 0b       	sbc	r19, r25
   145b6:	02 c0       	rjmp	.+4      	; 0x145bc <__floatsisf+0x60>
	}
      else
	uarg = arg_a;
   145b8:	8b 01       	movw	r16, r22
   145ba:	9c 01       	movw	r18, r24
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
  else if (sizeof (USItype) == sizeof (unsigned long))
    return __builtin_clzl (n);
   145bc:	c9 01       	movw	r24, r18
   145be:	b8 01       	movw	r22, r16
   145c0:	0e 94 33 ae 	call	0x15c66	; 0x15c66 <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   145c4:	01 97       	sbiw	r24, 0x01	; 1
      if (shift > 0)
   145c6:	18 16       	cp	r1, r24
   145c8:	19 06       	cpc	r1, r25
   145ca:	2c f0       	brlt	.+10     	; 0x145d6 <__floatsisf+0x7a>
	  uarg = (-arg_a);
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
   145cc:	0d 83       	std	Y+5, r16	; 0x05
   145ce:	1e 83       	std	Y+6, r17	; 0x06
   145d0:	2f 83       	std	Y+7, r18	; 0x07
   145d2:	38 87       	std	Y+8, r19	; 0x08
   145d4:	12 c0       	rjmp	.+36     	; 0x145fa <__floatsisf+0x9e>
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   145d6:	08 2e       	mov	r0, r24
   145d8:	04 c0       	rjmp	.+8      	; 0x145e2 <__floatsisf+0x86>
   145da:	00 0f       	add	r16, r16
   145dc:	11 1f       	adc	r17, r17
   145de:	22 1f       	adc	r18, r18
   145e0:	33 1f       	adc	r19, r19
   145e2:	0a 94       	dec	r0
   145e4:	d2 f7       	brpl	.-12     	; 0x145da <__floatsisf+0x7e>
   145e6:	0d 83       	std	Y+5, r16	; 0x05
   145e8:	1e 83       	std	Y+6, r17	; 0x06
   145ea:	2f 83       	std	Y+7, r18	; 0x07
   145ec:	38 87       	std	Y+8, r19	; 0x08
	  in.normal_exp -= shift;
   145ee:	2e e1       	ldi	r18, 0x1E	; 30
   145f0:	30 e0       	ldi	r19, 0x00	; 0
   145f2:	28 1b       	sub	r18, r24
   145f4:	39 0b       	sbc	r19, r25
   145f6:	3c 83       	std	Y+4, r19	; 0x04
   145f8:	2b 83       	std	Y+3, r18	; 0x03
	}
    }
  return pack_d (&in);
   145fa:	ce 01       	movw	r24, r28
   145fc:	01 96       	adiw	r24, 0x01	; 1
   145fe:	0e 94 cf a3 	call	0x1479e	; 0x1479e <__pack_f>
   14602:	04 c0       	rjmp	.+8      	; 0x1460c <__floatsisf+0xb0>
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
   14604:	60 e0       	ldi	r22, 0x00	; 0
   14606:	70 e0       	ldi	r23, 0x00	; 0
   14608:	80 e0       	ldi	r24, 0x00	; 0
   1460a:	9f ec       	ldi	r25, 0xCF	; 207
	  in.fraction.ll <<= shift;
	  in.normal_exp -= shift;
	}
    }
  return pack_d (&in);
}
   1460c:	28 96       	adiw	r28, 0x08	; 8
   1460e:	e4 e0       	ldi	r30, 0x04	; 4
   14610:	0c 94 26 ae 	jmp	0x15c4c	; 0x15c4c <__epilogue_restores__+0x1c>

00014614 <__fixsfsi>:
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   14614:	ac e0       	ldi	r26, 0x0C	; 12
   14616:	b0 e0       	ldi	r27, 0x00	; 0
   14618:	e0 e1       	ldi	r30, 0x10	; 16
   1461a:	f3 ea       	ldi	r31, 0xA3	; 163
   1461c:	0c 94 0a ae 	jmp	0x15c14	; 0x15c14 <__prologue_saves__+0x1c>
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
   14620:	69 87       	std	Y+9, r22	; 0x09
   14622:	7a 87       	std	Y+10, r23	; 0x0a
   14624:	8b 87       	std	Y+11, r24	; 0x0b
   14626:	9c 87       	std	Y+12, r25	; 0x0c
  unpack_d (&au, &a);
   14628:	be 01       	movw	r22, r28
   1462a:	6f 5f       	subi	r22, 0xFF	; 255
   1462c:	7f 4f       	sbci	r23, 0xFF	; 255
   1462e:	ce 01       	movw	r24, r28
   14630:	09 96       	adiw	r24, 0x09	; 9
   14632:	0e 94 99 a4 	call	0x14932	; 0x14932 <__unpack_f>

  if (iszero (&a))
   14636:	89 81       	ldd	r24, Y+1	; 0x01
   14638:	82 30       	cpi	r24, 0x02	; 2
   1463a:	91 f1       	breq	.+100    	; 0x146a0 <__fixsfsi+0x8c>
    return 0;
  if (isnan (&a))
   1463c:	82 30       	cpi	r24, 0x02	; 2
   1463e:	80 f1       	brcs	.+96     	; 0x146a0 <__fixsfsi+0x8c>
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
   14640:	84 30       	cpi	r24, 0x04	; 4
   14642:	41 f4       	brne	.+16     	; 0x14654 <__fixsfsi+0x40>
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
   14644:	8a 81       	ldd	r24, Y+2	; 0x02
   14646:	88 23       	and	r24, r24
   14648:	31 f1       	breq	.+76     	; 0x14696 <__fixsfsi+0x82>
   1464a:	00 e0       	ldi	r16, 0x00	; 0
   1464c:	10 e0       	ldi	r17, 0x00	; 0
   1464e:	20 e0       	ldi	r18, 0x00	; 0
   14650:	30 e8       	ldi	r19, 0x80	; 128
   14652:	29 c0       	rjmp	.+82     	; 0x146a6 <__fixsfsi+0x92>
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
   14654:	2b 81       	ldd	r18, Y+3	; 0x03
   14656:	3c 81       	ldd	r19, Y+4	; 0x04
   14658:	37 fd       	sbrc	r19, 7
   1465a:	22 c0       	rjmp	.+68     	; 0x146a0 <__fixsfsi+0x8c>
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
   1465c:	2f 31       	cpi	r18, 0x1F	; 31
   1465e:	31 05       	cpc	r19, r1
   14660:	8c f7       	brge	.-30     	; 0x14644 <__fixsfsi+0x30>
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
   14662:	8e e1       	ldi	r24, 0x1E	; 30
   14664:	90 e0       	ldi	r25, 0x00	; 0
   14666:	82 1b       	sub	r24, r18
   14668:	93 0b       	sbc	r25, r19
   1466a:	0d 81       	ldd	r16, Y+5	; 0x05
   1466c:	1e 81       	ldd	r17, Y+6	; 0x06
   1466e:	2f 81       	ldd	r18, Y+7	; 0x07
   14670:	38 85       	ldd	r19, Y+8	; 0x08
   14672:	04 c0       	rjmp	.+8      	; 0x1467c <__fixsfsi+0x68>
   14674:	36 95       	lsr	r19
   14676:	27 95       	ror	r18
   14678:	17 95       	ror	r17
   1467a:	07 95       	ror	r16
   1467c:	8a 95       	dec	r24
   1467e:	d2 f7       	brpl	.-12     	; 0x14674 <__fixsfsi+0x60>
  return a.sign ? (-tmp) : (tmp);
   14680:	8a 81       	ldd	r24, Y+2	; 0x02
   14682:	88 23       	and	r24, r24
   14684:	81 f0       	breq	.+32     	; 0x146a6 <__fixsfsi+0x92>
   14686:	30 95       	com	r19
   14688:	20 95       	com	r18
   1468a:	10 95       	com	r17
   1468c:	01 95       	neg	r16
   1468e:	1f 4f       	sbci	r17, 0xFF	; 255
   14690:	2f 4f       	sbci	r18, 0xFF	; 255
   14692:	3f 4f       	sbci	r19, 0xFF	; 255
   14694:	08 c0       	rjmp	.+16     	; 0x146a6 <__fixsfsi+0x92>
    return 0;
  if (isnan (&a))
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
   14696:	0f ef       	ldi	r16, 0xFF	; 255
   14698:	1f ef       	ldi	r17, 0xFF	; 255
   1469a:	2f ef       	ldi	r18, 0xFF	; 255
   1469c:	3f e7       	ldi	r19, 0x7F	; 127
   1469e:	03 c0       	rjmp	.+6      	; 0x146a6 <__fixsfsi+0x92>

  au.value = arg_a;
  unpack_d (&au, &a);

  if (iszero (&a))
    return 0;
   146a0:	00 e0       	ldi	r16, 0x00	; 0
   146a2:	10 e0       	ldi	r17, 0x00	; 0
   146a4:	98 01       	movw	r18, r16
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   146a6:	b8 01       	movw	r22, r16
   146a8:	c9 01       	movw	r24, r18
   146aa:	2c 96       	adiw	r28, 0x0c	; 12
   146ac:	e4 e0       	ldi	r30, 0x04	; 4
   146ae:	0c 94 26 ae 	jmp	0x15c4c	; 0x15c4c <__epilogue_restores__+0x1c>

000146b2 <__floatunsisf>:
#endif /* L_si_to_sf || L_si_to_df */

#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
FLO_type
usi_to_float (USItype arg_a)
{
   146b2:	a8 e0       	ldi	r26, 0x08	; 8
   146b4:	b0 e0       	ldi	r27, 0x00	; 0
   146b6:	ef e5       	ldi	r30, 0x5F	; 95
   146b8:	f3 ea       	ldi	r31, 0xA3	; 163
   146ba:	0c 94 06 ae 	jmp	0x15c0c	; 0x15c0c <__prologue_saves__+0x14>
   146be:	8b 01       	movw	r16, r22
   146c0:	9c 01       	movw	r18, r24
  fp_number_type in;

  in.sign = 0;
   146c2:	1a 82       	std	Y+2, r1	; 0x02
  if (!arg_a)
   146c4:	61 15       	cp	r22, r1
   146c6:	71 05       	cpc	r23, r1
   146c8:	81 05       	cpc	r24, r1
   146ca:	91 05       	cpc	r25, r1
   146cc:	19 f4       	brne	.+6      	; 0x146d4 <__floatunsisf+0x22>
    {
      in.class = CLASS_ZERO;
   146ce:	82 e0       	ldi	r24, 0x02	; 2
   146d0:	89 83       	std	Y+1, r24	; 0x01
   146d2:	5d c0       	rjmp	.+186    	; 0x1478e <__floatunsisf+0xdc>
    }
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
   146d4:	83 e0       	ldi	r24, 0x03	; 3
   146d6:	89 83       	std	Y+1, r24	; 0x01
      in.normal_exp = FRACBITS + NGARDS;
   146d8:	4e e1       	ldi	r20, 0x1E	; 30
   146da:	50 e0       	ldi	r21, 0x00	; 0
   146dc:	5c 83       	std	Y+4, r21	; 0x04
   146de:	4b 83       	std	Y+3, r20	; 0x03
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
  else if (sizeof (USItype) == sizeof (unsigned long))
    return __builtin_clzl (n);
   146e0:	c9 01       	movw	r24, r18
   146e2:	b8 01       	movw	r22, r16
   146e4:	0e 94 33 ae 	call	0x15c66	; 0x15c66 <__clzsi2>
      int shift;
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;

      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   146e8:	01 97       	sbiw	r24, 0x01	; 1
      if (shift < 0)
   146ea:	97 ff       	sbrs	r25, 7
   146ec:	39 c0       	rjmp	.+114    	; 0x14760 <__floatunsisf+0xae>
	{
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
   146ee:	ee 27       	eor	r30, r30
   146f0:	ff 27       	eor	r31, r31
   146f2:	e8 1b       	sub	r30, r24
   146f4:	f9 0b       	sbc	r31, r25
   146f6:	41 e0       	ldi	r20, 0x01	; 1
   146f8:	50 e0       	ldi	r21, 0x00	; 0
   146fa:	60 e0       	ldi	r22, 0x00	; 0
   146fc:	70 e0       	ldi	r23, 0x00	; 0
   146fe:	0e 2e       	mov	r0, r30
   14700:	04 c0       	rjmp	.+8      	; 0x1470a <__floatunsisf+0x58>
   14702:	44 0f       	add	r20, r20
   14704:	55 1f       	adc	r21, r21
   14706:	66 1f       	adc	r22, r22
   14708:	77 1f       	adc	r23, r23
   1470a:	0a 94       	dec	r0
   1470c:	d2 f7       	brpl	.-12     	; 0x14702 <__floatunsisf+0x50>
   1470e:	41 50       	subi	r20, 0x01	; 1
   14710:	51 09       	sbc	r21, r1
   14712:	61 09       	sbc	r22, r1
   14714:	71 09       	sbc	r23, r1
   14716:	40 23       	and	r20, r16
   14718:	51 23       	and	r21, r17
   1471a:	62 23       	and	r22, r18
   1471c:	73 23       	and	r23, r19
	  in.fraction.ll >>= -shift;
	  in.fraction.ll |= (guard != 0);
   1471e:	c1 2c       	mov	r12, r1
   14720:	d1 2c       	mov	r13, r1
   14722:	76 01       	movw	r14, r12
   14724:	c3 94       	inc	r12
   14726:	45 2b       	or	r20, r21
   14728:	46 2b       	or	r20, r22
   1472a:	47 2b       	or	r20, r23
   1472c:	19 f4       	brne	.+6      	; 0x14734 <__floatunsisf+0x82>
   1472e:	c1 2c       	mov	r12, r1
   14730:	d1 2c       	mov	r13, r1
   14732:	76 01       	movw	r14, r12

      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift < 0)
	{
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
	  in.fraction.ll >>= -shift;
   14734:	04 c0       	rjmp	.+8      	; 0x1473e <__floatunsisf+0x8c>
   14736:	36 95       	lsr	r19
   14738:	27 95       	ror	r18
   1473a:	17 95       	ror	r17
   1473c:	07 95       	ror	r16
   1473e:	ea 95       	dec	r30
   14740:	d2 f7       	brpl	.-12     	; 0x14736 <__floatunsisf+0x84>
	  in.fraction.ll |= (guard != 0);
   14742:	0c 29       	or	r16, r12
   14744:	1d 29       	or	r17, r13
   14746:	2e 29       	or	r18, r14
   14748:	3f 29       	or	r19, r15
   1474a:	0d 83       	std	Y+5, r16	; 0x05
   1474c:	1e 83       	std	Y+6, r17	; 0x06
   1474e:	2f 83       	std	Y+7, r18	; 0x07
   14750:	38 87       	std	Y+8, r19	; 0x08
	  in.normal_exp -= shift;
   14752:	2e e1       	ldi	r18, 0x1E	; 30
   14754:	30 e0       	ldi	r19, 0x00	; 0
   14756:	28 1b       	sub	r18, r24
   14758:	39 0b       	sbc	r19, r25
   1475a:	3c 83       	std	Y+4, r19	; 0x04
   1475c:	2b 83       	std	Y+3, r18	; 0x03
   1475e:	17 c0       	rjmp	.+46     	; 0x1478e <__floatunsisf+0xdc>
	}
      else if (shift > 0)
   14760:	00 97       	sbiw	r24, 0x00	; 0
   14762:	29 f4       	brne	.+10     	; 0x1476e <__floatunsisf+0xbc>
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;
   14764:	0d 83       	std	Y+5, r16	; 0x05
   14766:	1e 83       	std	Y+6, r17	; 0x06
   14768:	2f 83       	std	Y+7, r18	; 0x07
   1476a:	38 87       	std	Y+8, r19	; 0x08
   1476c:	10 c0       	rjmp	.+32     	; 0x1478e <__floatunsisf+0xdc>
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1476e:	08 2e       	mov	r0, r24
   14770:	04 c0       	rjmp	.+8      	; 0x1477a <__floatunsisf+0xc8>
   14772:	00 0f       	add	r16, r16
   14774:	11 1f       	adc	r17, r17
   14776:	22 1f       	adc	r18, r18
   14778:	33 1f       	adc	r19, r19
   1477a:	0a 94       	dec	r0
   1477c:	d2 f7       	brpl	.-12     	; 0x14772 <__floatunsisf+0xc0>
   1477e:	0d 83       	std	Y+5, r16	; 0x05
   14780:	1e 83       	std	Y+6, r17	; 0x06
   14782:	2f 83       	std	Y+7, r18	; 0x07
   14784:	38 87       	std	Y+8, r19	; 0x08
	  in.normal_exp -= shift;
   14786:	48 1b       	sub	r20, r24
   14788:	59 0b       	sbc	r21, r25
   1478a:	5c 83       	std	Y+4, r21	; 0x04
   1478c:	4b 83       	std	Y+3, r20	; 0x03
	}
    }
  return pack_d (&in);
   1478e:	ce 01       	movw	r24, r28
   14790:	01 96       	adiw	r24, 0x01	; 1
   14792:	0e 94 cf a3 	call	0x1479e	; 0x1479e <__pack_f>
}
   14796:	28 96       	adiw	r28, 0x08	; 8
   14798:	e8 e0       	ldi	r30, 0x08	; 8
   1479a:	0c 94 22 ae 	jmp	0x15c44	; 0x15c44 <__epilogue_restores__+0x14>

0001479e <__pack_f>:
extern FLO_type pack_d (const fp_number_type * );

#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
   1479e:	0f 93       	push	r16
   147a0:	1f 93       	push	r17
   147a2:	cf 93       	push	r28
   147a4:	df 93       	push	r29
   147a6:	dc 01       	movw	r26, r24
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
   147a8:	14 96       	adiw	r26, 0x04	; 4
   147aa:	4d 91       	ld	r20, X+
   147ac:	5d 91       	ld	r21, X+
   147ae:	6d 91       	ld	r22, X+
   147b0:	7c 91       	ld	r23, X
   147b2:	17 97       	sbiw	r26, 0x07	; 7
  int sign = src->sign;
   147b4:	11 96       	adiw	r26, 0x01	; 1
   147b6:	ec 91       	ld	r30, X
   147b8:	11 97       	sbiw	r26, 0x01	; 1
  }
#endif
#endif

  return dst.value;
}
   147ba:	8c 91       	ld	r24, X
	 largest possible magnitude, we guarantee that the conversion
	 of infinity is at least as big as any finite number.  */
      exp = EXPMAX;
      fraction = ((fractype) 1 << FRACBITS) - 1;
    }
  else if (isnan (src))
   147bc:	82 30       	cpi	r24, 0x02	; 2
   147be:	20 f4       	brcc	.+8      	; 0x147c8 <__pack_f+0x2a>
      if (src->class == CLASS_QNAN || 1)
	{
#ifdef QUIET_NAN_NEGATED
	  fraction |= QUIET_NAN - 1;
#else
	  fraction |= QUIET_NAN;
   147c0:	60 61       	ori	r22, 0x10	; 16
      exp = EXPMAX;
      fraction = ((fractype) 1 << FRACBITS) - 1;
    }
  else if (isnan (src))
    {
      exp = EXPMAX;
   147c2:	8f ef       	ldi	r24, 0xFF	; 255
   147c4:	90 e0       	ldi	r25, 0x00	; 0
   147c6:	a6 c0       	rjmp	.+332    	; 0x14914 <__pack_f+0x176>
#else
	  fraction |= QUIET_NAN;
#endif
	}
    }
  else if (isinf (src))
   147c8:	84 30       	cpi	r24, 0x04	; 4
   147ca:	09 f4       	brne	.+2      	; 0x147ce <__pack_f+0x30>
   147cc:	9e c0       	rjmp	.+316    	; 0x1490a <__pack_f+0x16c>
    {
      exp = EXPMAX;
      fraction = 0;
    }
  else if (iszero (src))
   147ce:	82 30       	cpi	r24, 0x02	; 2
   147d0:	09 f4       	brne	.+2      	; 0x147d4 <__pack_f+0x36>
   147d2:	95 c0       	rjmp	.+298    	; 0x148fe <__pack_f+0x160>
    {
      exp = 0;
      fraction = 0;
    }
  else if (fraction == 0)
   147d4:	41 15       	cp	r20, r1
   147d6:	51 05       	cpc	r21, r1
   147d8:	61 05       	cpc	r22, r1
   147da:	71 05       	cpc	r23, r1
   147dc:	09 f4       	brne	.+2      	; 0x147e0 <__pack_f+0x42>
   147de:	92 c0       	rjmp	.+292    	; 0x14904 <__pack_f+0x166>
    {
      exp = 0;
    }
  else
    {
      if (__builtin_expect (src->normal_exp < NORMAL_EXPMIN, 0))
   147e0:	12 96       	adiw	r26, 0x02	; 2
   147e2:	2d 91       	ld	r18, X+
   147e4:	3c 91       	ld	r19, X
   147e6:	13 97       	sbiw	r26, 0x03	; 3
   147e8:	22 38       	cpi	r18, 0x82	; 130
   147ea:	8f ef       	ldi	r24, 0xFF	; 255
   147ec:	38 07       	cpc	r19, r24
   147ee:	0c f0       	brlt	.+2      	; 0x147f2 <__pack_f+0x54>
   147f0:	58 c0       	rjmp	.+176    	; 0x148a2 <__pack_f+0x104>
#else /* NO_DENORMALS */
	  /* This number's exponent is too low to fit into the bits
	     available in the number, so we'll store 0 in the exponent and
	     shift the fraction to the right to make up for it.  */

	  int shift = NORMAL_EXPMIN - src->normal_exp;
   147f2:	c2 e8       	ldi	r28, 0x82	; 130
   147f4:	df ef       	ldi	r29, 0xFF	; 255
   147f6:	c2 1b       	sub	r28, r18
   147f8:	d3 0b       	sbc	r29, r19

	  exp = 0;

	  if (shift > FRAC_NBITS - NGARDS)
   147fa:	ca 31       	cpi	r28, 0x1A	; 26
   147fc:	d1 05       	cpc	r29, r1
   147fe:	6c f5       	brge	.+90     	; 0x1485a <__pack_f+0xbc>
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
   14800:	8a 01       	movw	r16, r20
   14802:	9b 01       	movw	r18, r22
   14804:	0c 2e       	mov	r0, r28
   14806:	04 c0       	rjmp	.+8      	; 0x14810 <__pack_f+0x72>
   14808:	36 95       	lsr	r19
   1480a:	27 95       	ror	r18
   1480c:	17 95       	ror	r17
   1480e:	07 95       	ror	r16
   14810:	0a 94       	dec	r0
   14812:	d2 f7       	brpl	.-12     	; 0x14808 <__pack_f+0x6a>
	      /* No point shifting, since it's more that 64 out.  */
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
   14814:	81 e0       	ldi	r24, 0x01	; 1
   14816:	90 e0       	ldi	r25, 0x00	; 0
   14818:	a0 e0       	ldi	r26, 0x00	; 0
   1481a:	b0 e0       	ldi	r27, 0x00	; 0
   1481c:	0c 2e       	mov	r0, r28
   1481e:	04 c0       	rjmp	.+8      	; 0x14828 <__pack_f+0x8a>
   14820:	88 0f       	add	r24, r24
   14822:	99 1f       	adc	r25, r25
   14824:	aa 1f       	adc	r26, r26
   14826:	bb 1f       	adc	r27, r27
   14828:	0a 94       	dec	r0
   1482a:	d2 f7       	brpl	.-12     	; 0x14820 <__pack_f+0x82>
   1482c:	01 97       	sbiw	r24, 0x01	; 1
   1482e:	a1 09       	sbc	r26, r1
   14830:	b1 09       	sbc	r27, r1
   14832:	84 23       	and	r24, r20
   14834:	95 23       	and	r25, r21
   14836:	a6 23       	and	r26, r22
   14838:	b7 23       	and	r27, r23
   1483a:	41 e0       	ldi	r20, 0x01	; 1
   1483c:	50 e0       	ldi	r21, 0x00	; 0
   1483e:	60 e0       	ldi	r22, 0x00	; 0
   14840:	70 e0       	ldi	r23, 0x00	; 0
   14842:	89 2b       	or	r24, r25
   14844:	8a 2b       	or	r24, r26
   14846:	8b 2b       	or	r24, r27
   14848:	19 f4       	brne	.+6      	; 0x14850 <__pack_f+0xb2>
   1484a:	40 e0       	ldi	r20, 0x00	; 0
   1484c:	50 e0       	ldi	r21, 0x00	; 0
   1484e:	ba 01       	movw	r22, r20
	      fraction = (fraction >> shift) | lowbit;
   14850:	40 2b       	or	r20, r16
   14852:	51 2b       	or	r21, r17
   14854:	62 2b       	or	r22, r18
   14856:	73 2b       	or	r23, r19
   14858:	03 c0       	rjmp	.+6      	; 0x14860 <__pack_f+0xc2>
	  exp = 0;

	  if (shift > FRAC_NBITS - NGARDS)
	    {
	      /* No point shifting, since it's more that 64 out.  */
	      fraction = 0;
   1485a:	40 e0       	ldi	r20, 0x00	; 0
   1485c:	50 e0       	ldi	r21, 0x00	; 0
   1485e:	ba 01       	movw	r22, r20
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
	    }
	  if ((fraction & GARDMASK) == GARDMSB)
   14860:	db 01       	movw	r26, r22
   14862:	ca 01       	movw	r24, r20
   14864:	8f 77       	andi	r24, 0x7F	; 127
   14866:	99 27       	eor	r25, r25
   14868:	aa 27       	eor	r26, r26
   1486a:	bb 27       	eor	r27, r27
   1486c:	80 34       	cpi	r24, 0x40	; 64
   1486e:	91 05       	cpc	r25, r1
   14870:	a1 05       	cpc	r26, r1
   14872:	b1 05       	cpc	r27, r1
   14874:	39 f4       	brne	.+14     	; 0x14884 <__pack_f+0xe6>
	    {
	      if ((fraction & (1 << NGARDS)))
   14876:	47 ff       	sbrs	r20, 7
   14878:	09 c0       	rjmp	.+18     	; 0x1488c <__pack_f+0xee>
		fraction += GARDROUND + 1;
   1487a:	40 5c       	subi	r20, 0xC0	; 192
   1487c:	5f 4f       	sbci	r21, 0xFF	; 255
   1487e:	6f 4f       	sbci	r22, 0xFF	; 255
   14880:	7f 4f       	sbci	r23, 0xFF	; 255
   14882:	04 c0       	rjmp	.+8      	; 0x1488c <__pack_f+0xee>
	    }
	  else
	    {
	      /* Add to the guards to round up.  */
	      fraction += GARDROUND;
   14884:	41 5c       	subi	r20, 0xC1	; 193
   14886:	5f 4f       	sbci	r21, 0xFF	; 255
   14888:	6f 4f       	sbci	r22, 0xFF	; 255
   1488a:	7f 4f       	sbci	r23, 0xFF	; 255
	    }
	  /* Perhaps the rounding means we now need to change the
             exponent, because the fraction is no longer denormal.  */
	  if (fraction >= IMPLICIT_1)
   1488c:	81 e0       	ldi	r24, 0x01	; 1
   1488e:	90 e0       	ldi	r25, 0x00	; 0
   14890:	41 15       	cp	r20, r1
   14892:	51 05       	cpc	r21, r1
   14894:	61 05       	cpc	r22, r1
   14896:	20 e4       	ldi	r18, 0x40	; 64
   14898:	72 07       	cpc	r23, r18
   1489a:	48 f5       	brcc	.+82     	; 0x148ee <__pack_f+0x150>
   1489c:	80 e0       	ldi	r24, 0x00	; 0
   1489e:	90 e0       	ldi	r25, 0x00	; 0
   148a0:	26 c0       	rjmp	.+76     	; 0x148ee <__pack_f+0x150>
	      exp += 1;
	    }
	  fraction >>= NGARDS;
#endif /* NO_DENORMALS */
	}
      else if (!LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS)
   148a2:	20 38       	cpi	r18, 0x80	; 128
   148a4:	31 05       	cpc	r19, r1
   148a6:	8c f5       	brge	.+98     	; 0x1490a <__pack_f+0x16c>
	  if (!ROUND_TOWARDS_ZERO)
	    {
	      /* IF the gard bits are the all zero, but the first, then we're
		 half way between two numbers, choose the one which makes the
		 lsb of the answer 0.  */
	      if ((fraction & GARDMASK) == GARDMSB)
   148a8:	db 01       	movw	r26, r22
   148aa:	ca 01       	movw	r24, r20
   148ac:	8f 77       	andi	r24, 0x7F	; 127
   148ae:	99 27       	eor	r25, r25
   148b0:	aa 27       	eor	r26, r26
   148b2:	bb 27       	eor	r27, r27
   148b4:	80 34       	cpi	r24, 0x40	; 64
   148b6:	91 05       	cpc	r25, r1
   148b8:	a1 05       	cpc	r26, r1
   148ba:	b1 05       	cpc	r27, r1
   148bc:	39 f4       	brne	.+14     	; 0x148cc <__pack_f+0x12e>
		{
		  if (fraction & (1 << NGARDS))
   148be:	47 ff       	sbrs	r20, 7
   148c0:	09 c0       	rjmp	.+18     	; 0x148d4 <__pack_f+0x136>
		    fraction += GARDROUND + 1;
   148c2:	40 5c       	subi	r20, 0xC0	; 192
   148c4:	5f 4f       	sbci	r21, 0xFF	; 255
   148c6:	6f 4f       	sbci	r22, 0xFF	; 255
   148c8:	7f 4f       	sbci	r23, 0xFF	; 255
   148ca:	04 c0       	rjmp	.+8      	; 0x148d4 <__pack_f+0x136>
		}
	      else
		{
		  /* Add a one to the guards to round up */
		  fraction += GARDROUND;
   148cc:	41 5c       	subi	r20, 0xC1	; 193
   148ce:	5f 4f       	sbci	r21, 0xFF	; 255
   148d0:	6f 4f       	sbci	r22, 0xFF	; 255
   148d2:	7f 4f       	sbci	r23, 0xFF	; 255
		}
	      if (fraction >= IMPLICIT_2)
   148d4:	77 fd       	sbrc	r23, 7
   148d6:	04 c0       	rjmp	.+8      	; 0x148e0 <__pack_f+0x142>
	  exp = EXPMAX;
	  fraction = 0;
	}
      else
	{
	  exp = src->normal_exp + EXPBIAS;
   148d8:	c9 01       	movw	r24, r18
   148da:	81 58       	subi	r24, 0x81	; 129
   148dc:	9f 4f       	sbci	r25, 0xFF	; 255
   148de:	07 c0       	rjmp	.+14     	; 0x148ee <__pack_f+0x150>
		  /* Add a one to the guards to round up */
		  fraction += GARDROUND;
		}
	      if (fraction >= IMPLICIT_2)
		{
		  fraction >>= 1;
   148e0:	76 95       	lsr	r23
   148e2:	67 95       	ror	r22
   148e4:	57 95       	ror	r21
   148e6:	47 95       	ror	r20
		  exp += 1;
   148e8:	c9 01       	movw	r24, r18
   148ea:	80 58       	subi	r24, 0x80	; 128
   148ec:	9f 4f       	sbci	r25, 0xFF	; 255
		}
	    }
	  fraction >>= NGARDS;
   148ee:	97 e0       	ldi	r25, 0x07	; 7
   148f0:	76 95       	lsr	r23
   148f2:	67 95       	ror	r22
   148f4:	57 95       	ror	r21
   148f6:	47 95       	ror	r20
   148f8:	9a 95       	dec	r25
   148fa:	d1 f7       	brne	.-12     	; 0x148f0 <__pack_f+0x152>
   148fc:	0b c0       	rjmp	.+22     	; 0x14914 <__pack_f+0x176>
      exp = EXPMAX;
      fraction = 0;
    }
  else if (iszero (src))
    {
      exp = 0;
   148fe:	80 e0       	ldi	r24, 0x00	; 0
   14900:	90 e0       	ldi	r25, 0x00	; 0
   14902:	05 c0       	rjmp	.+10     	; 0x1490e <__pack_f+0x170>
   14904:	80 e0       	ldi	r24, 0x00	; 0
   14906:	90 e0       	ldi	r25, 0x00	; 0
   14908:	05 c0       	rjmp	.+10     	; 0x14914 <__pack_f+0x176>
#endif
	}
    }
  else if (isinf (src))
    {
      exp = EXPMAX;
   1490a:	8f ef       	ldi	r24, 0xFF	; 255
   1490c:	90 e0       	ldi	r25, 0x00	; 0
      fraction = 0;
   1490e:	40 e0       	ldi	r20, 0x00	; 0
   14910:	50 e0       	ldi	r21, 0x00	; 0
   14912:	ba 01       	movw	r22, r20
  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
  dst.bits.exp = exp;
   14914:	98 2f       	mov	r25, r24
   14916:	96 95       	lsr	r25
  dst.bits.sign = sign;
   14918:	e0 fb       	bst	r30, 0
   1491a:	97 f9       	bld	r25, 7
  }
#endif
#endif

  return dst.value;
}
   1491c:	36 2f       	mov	r19, r22
   1491e:	80 fb       	bst	r24, 0
   14920:	37 f9       	bld	r19, 7
   14922:	64 2f       	mov	r22, r20
   14924:	75 2f       	mov	r23, r21
   14926:	83 2f       	mov	r24, r19
   14928:	df 91       	pop	r29
   1492a:	cf 91       	pop	r28
   1492c:	1f 91       	pop	r17
   1492e:	0f 91       	pop	r16
   14930:	08 95       	ret

00014932 <__unpack_f>:
#endif

#if defined(L_unpack_df) || defined(L_unpack_sf) || defined(L_unpack_tf)
void
unpack_d (FLO_union_type * src, fp_number_type * dst)
{
   14932:	cf 92       	push	r12
   14934:	df 92       	push	r13
   14936:	ef 92       	push	r14
   14938:	dc 01       	movw	r26, r24
   1493a:	fb 01       	movw	r30, r22
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1493c:	cc 90       	ld	r12, X
   1493e:	11 96       	adiw	r26, 0x01	; 1
   14940:	dc 90       	ld	r13, X
   14942:	11 97       	sbiw	r26, 0x01	; 1
   14944:	12 96       	adiw	r26, 0x02	; 2
   14946:	8c 91       	ld	r24, X
   14948:	12 97       	sbiw	r26, 0x02	; 2
   1494a:	3f e7       	ldi	r19, 0x7F	; 127
   1494c:	e3 2e       	mov	r14, r19
   1494e:	e8 22       	and	r14, r24
   14950:	6e 2d       	mov	r22, r14
   14952:	a6 01       	movw	r20, r12
   14954:	70 e0       	ldi	r23, 0x00	; 0
  exp = src->bits.exp;
   14956:	98 2f       	mov	r25, r24
   14958:	99 1f       	adc	r25, r25
   1495a:	99 27       	eor	r25, r25
   1495c:	99 1f       	adc	r25, r25
   1495e:	13 96       	adiw	r26, 0x03	; 3
   14960:	2c 91       	ld	r18, X
   14962:	82 2f       	mov	r24, r18
   14964:	88 0f       	add	r24, r24
   14966:	89 2b       	or	r24, r25
   14968:	90 e0       	ldi	r25, 0x00	; 0
  sign = src->bits.sign;
   1496a:	27 fb       	bst	r18, 7
   1496c:	22 27       	eor	r18, r18
   1496e:	20 f9       	bld	r18, 0
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   14970:	21 83       	std	Z+1, r18	; 0x01
  if (exp == 0)
   14972:	00 97       	sbiw	r24, 0x00	; 0
   14974:	29 f5       	brne	.+74     	; 0x149c0 <__unpack_f+0x8e>
    {
      /* Hmm.  Looks like 0 */
      if (fraction == 0
   14976:	41 15       	cp	r20, r1
   14978:	51 05       	cpc	r21, r1
   1497a:	61 05       	cpc	r22, r1
   1497c:	71 05       	cpc	r23, r1
   1497e:	11 f4       	brne	.+4      	; 0x14984 <__unpack_f+0x52>
	  || 1
#endif
	  )
	{
	  /* tastes like zero */
	  dst->class = CLASS_ZERO;
   14980:	82 e0       	ldi	r24, 0x02	; 2
   14982:	27 c0       	rjmp	.+78     	; 0x149d2 <__unpack_f+0xa0>
      else
	{
	  /* Zero exponent with nonzero fraction - it's denormalized,
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
   14984:	82 e8       	ldi	r24, 0x82	; 130
   14986:	9f ef       	ldi	r25, 0xFF	; 255
   14988:	93 83       	std	Z+3, r25	; 0x03
   1498a:	82 83       	std	Z+2, r24	; 0x02
	  fraction <<= NGARDS;
   1498c:	27 e0       	ldi	r18, 0x07	; 7
   1498e:	44 0f       	add	r20, r20
   14990:	55 1f       	adc	r21, r21
   14992:	66 1f       	adc	r22, r22
   14994:	77 1f       	adc	r23, r23
   14996:	2a 95       	dec	r18
   14998:	d1 f7       	brne	.-12     	; 0x1498e <__unpack_f+0x5c>

	  dst->class = CLASS_NUMBER;
   1499a:	83 e0       	ldi	r24, 0x03	; 3
   1499c:	80 83       	st	Z, r24
#if 1
	  while (fraction < IMPLICIT_1)
   1499e:	09 c0       	rjmp	.+18     	; 0x149b2 <__unpack_f+0x80>
	    {
	      fraction <<= 1;
   149a0:	44 0f       	add	r20, r20
   149a2:	55 1f       	adc	r21, r21
   149a4:	66 1f       	adc	r22, r22
   149a6:	77 1f       	adc	r23, r23
	      dst->normal_exp--;
   149a8:	82 81       	ldd	r24, Z+2	; 0x02
   149aa:	93 81       	ldd	r25, Z+3	; 0x03
   149ac:	01 97       	sbiw	r24, 0x01	; 1
   149ae:	93 83       	std	Z+3, r25	; 0x03
   149b0:	82 83       	std	Z+2, r24	; 0x02
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;

	  dst->class = CLASS_NUMBER;
#if 1
	  while (fraction < IMPLICIT_1)
   149b2:	41 15       	cp	r20, r1
   149b4:	51 05       	cpc	r21, r1
   149b6:	61 05       	cpc	r22, r1
   149b8:	80 e4       	ldi	r24, 0x40	; 64
   149ba:	78 07       	cpc	r23, r24
   149bc:	88 f3       	brcs	.-30     	; 0x149a0 <__unpack_f+0x6e>
   149be:	20 c0       	rjmp	.+64     	; 0x14a00 <__unpack_f+0xce>
	    }
#endif
	  dst->fraction.ll = fraction;
	}
    }
  else if (!LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS)
   149c0:	8f 3f       	cpi	r24, 0xFF	; 255
   149c2:	91 05       	cpc	r25, r1
   149c4:	79 f4       	brne	.+30     	; 0x149e4 <__unpack_f+0xb2>
	   && __builtin_expect (exp == EXPMAX, 0))
    {
      /* Huge exponent*/
      if (fraction == 0)
   149c6:	41 15       	cp	r20, r1
   149c8:	51 05       	cpc	r21, r1
   149ca:	61 05       	cpc	r22, r1
   149cc:	71 05       	cpc	r23, r1
   149ce:	19 f4       	brne	.+6      	; 0x149d6 <__unpack_f+0xa4>
	{
	  /* Attached to a zero fraction - means infinity */
	  dst->class = CLASS_INFINITY;
   149d0:	84 e0       	ldi	r24, 0x04	; 4
   149d2:	80 83       	st	Z, r24
   149d4:	19 c0       	rjmp	.+50     	; 0x14a08 <__unpack_f+0xd6>
	{
	  /* Nonzero fraction, means nan */
#ifdef QUIET_NAN_NEGATED
	  if ((fraction & QUIET_NAN) == 0)
#else
	  if (fraction & QUIET_NAN)
   149d6:	e4 fe       	sbrs	r14, 4
   149d8:	03 c0       	rjmp	.+6      	; 0x149e0 <__unpack_f+0xae>
#endif
	    {
	      dst->class = CLASS_QNAN;
   149da:	81 e0       	ldi	r24, 0x01	; 1
   149dc:	80 83       	st	Z, r24
   149de:	10 c0       	rjmp	.+32     	; 0x14a00 <__unpack_f+0xce>
	    }
	  else
	    {
	      dst->class = CLASS_SNAN;
   149e0:	10 82       	st	Z, r1
   149e2:	0e c0       	rjmp	.+28     	; 0x14a00 <__unpack_f+0xce>
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   149e4:	8f 57       	subi	r24, 0x7F	; 127
   149e6:	91 09       	sbc	r25, r1
   149e8:	93 83       	std	Z+3, r25	; 0x03
   149ea:	82 83       	std	Z+2, r24	; 0x02
      dst->class = CLASS_NUMBER;
   149ec:	83 e0       	ldi	r24, 0x03	; 3
   149ee:	80 83       	st	Z, r24
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   149f0:	87 e0       	ldi	r24, 0x07	; 7
   149f2:	44 0f       	add	r20, r20
   149f4:	55 1f       	adc	r21, r21
   149f6:	66 1f       	adc	r22, r22
   149f8:	77 1f       	adc	r23, r23
   149fa:	8a 95       	dec	r24
   149fc:	d1 f7       	brne	.-12     	; 0x149f2 <__unpack_f+0xc0>
   149fe:	70 64       	ori	r23, 0x40	; 64
   14a00:	44 83       	std	Z+4, r20	; 0x04
   14a02:	55 83       	std	Z+5, r21	; 0x05
   14a04:	66 83       	std	Z+6, r22	; 0x06
   14a06:	77 83       	std	Z+7, r23	; 0x07
    }
}
   14a08:	ef 90       	pop	r14
   14a0a:	df 90       	pop	r13
   14a0c:	cf 90       	pop	r12
   14a0e:	08 95       	ret

00014a10 <__fpcmp_parts_f>:
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   14a10:	cf 93       	push	r28
   14a12:	fc 01       	movw	r30, r24
   14a14:	db 01       	movw	r26, r22
    {
      return a->sign ? 1 : -1;
    }
  /* after all that, they're equal.  */
  return 0;
}
   14a16:	90 81       	ld	r25, Z
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   14a18:	92 30       	cpi	r25, 0x02	; 2
   14a1a:	08 f4       	brcc	.+2      	; 0x14a1e <__fpcmp_parts_f+0xe>
   14a1c:	52 c0       	rjmp	.+164    	; 0x14ac2 <__fpcmp_parts_f+0xb2>
    {
      return a->sign ? 1 : -1;
    }
  /* after all that, they're equal.  */
  return 0;
}
   14a1e:	8c 91       	ld	r24, X
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   14a20:	82 30       	cpi	r24, 0x02	; 2
   14a22:	08 f4       	brcc	.+2      	; 0x14a26 <__fpcmp_parts_f+0x16>
   14a24:	4e c0       	rjmp	.+156    	; 0x14ac2 <__fpcmp_parts_f+0xb2>
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   14a26:	94 30       	cpi	r25, 0x04	; 4
   14a28:	71 f4       	brne	.+28     	; 0x14a46 <__fpcmp_parts_f+0x36>
   14a2a:	84 30       	cpi	r24, 0x04	; 4
   14a2c:	39 f4       	brne	.+14     	; 0x14a3c <__fpcmp_parts_f+0x2c>
       -------+--------+--------
       -inf(1)| a>b(1) | a==b(0)
       -------+--------+--------
       So since unordered must be nonzero, just line up the columns...
       */
      return b->sign - a->sign;
   14a2e:	11 96       	adiw	r26, 0x01	; 1
   14a30:	2c 91       	ld	r18, X
   14a32:	30 e0       	ldi	r19, 0x00	; 0
   14a34:	81 81       	ldd	r24, Z+1	; 0x01
   14a36:	28 1b       	sub	r18, r24
   14a38:	31 09       	sbc	r19, r1
   14a3a:	48 c0       	rjmp	.+144    	; 0x14acc <__fpcmp_parts_f+0xbc>
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   14a3c:	81 81       	ldd	r24, Z+1	; 0x01
   14a3e:	88 23       	and	r24, r24
   14a40:	09 f4       	brne	.+2      	; 0x14a44 <__fpcmp_parts_f+0x34>
   14a42:	3f c0       	rjmp	.+126    	; 0x14ac2 <__fpcmp_parts_f+0xb2>
   14a44:	3b c0       	rjmp	.+118    	; 0x14abc <__fpcmp_parts_f+0xac>
    }
  if (isinf (b))
   14a46:	84 30       	cpi	r24, 0x04	; 4
   14a48:	29 f4       	brne	.+10     	; 0x14a54 <__fpcmp_parts_f+0x44>
    {
      return b->sign ? 1 : -1;
   14a4a:	11 96       	adiw	r26, 0x01	; 1
   14a4c:	8c 91       	ld	r24, X
   14a4e:	81 11       	cpse	r24, r1
   14a50:	38 c0       	rjmp	.+112    	; 0x14ac2 <__fpcmp_parts_f+0xb2>
   14a52:	34 c0       	rjmp	.+104    	; 0x14abc <__fpcmp_parts_f+0xac>
    }
  if (iszero (a) && iszero (b))
   14a54:	92 30       	cpi	r25, 0x02	; 2
   14a56:	19 f4       	brne	.+6      	; 0x14a5e <__fpcmp_parts_f+0x4e>
   14a58:	82 30       	cpi	r24, 0x02	; 2
   14a5a:	b9 f7       	brne	.-18     	; 0x14a4a <__fpcmp_parts_f+0x3a>
   14a5c:	35 c0       	rjmp	.+106    	; 0x14ac8 <__fpcmp_parts_f+0xb8>
    }
  if (iszero (a))
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (b))
   14a5e:	82 30       	cpi	r24, 0x02	; 2
   14a60:	69 f3       	breq	.-38     	; 0x14a3c <__fpcmp_parts_f+0x2c>
    {
      return a->sign ? -1 : 1;
    }
  /* now both are "normal".  */
  if (a->sign != b->sign)
   14a62:	c1 81       	ldd	r28, Z+1	; 0x01
   14a64:	11 96       	adiw	r26, 0x01	; 1
   14a66:	8c 91       	ld	r24, X
   14a68:	11 97       	sbiw	r26, 0x01	; 1
   14a6a:	c8 13       	cpse	r28, r24
   14a6c:	1d c0       	rjmp	.+58     	; 0x14aa8 <__fpcmp_parts_f+0x98>
    {
      /* opposite signs */
      return a->sign ? -1 : 1;
    }
  /* same sign; exponents? */
  if (a->normal_exp > b->normal_exp)
   14a6e:	22 81       	ldd	r18, Z+2	; 0x02
   14a70:	33 81       	ldd	r19, Z+3	; 0x03
   14a72:	12 96       	adiw	r26, 0x02	; 2
   14a74:	8d 91       	ld	r24, X+
   14a76:	9c 91       	ld	r25, X
   14a78:	13 97       	sbiw	r26, 0x03	; 3
   14a7a:	82 17       	cp	r24, r18
   14a7c:	93 07       	cpc	r25, r19
   14a7e:	0c f4       	brge	.+2      	; 0x14a82 <__fpcmp_parts_f+0x72>
   14a80:	13 c0       	rjmp	.+38     	; 0x14aa8 <__fpcmp_parts_f+0x98>
    {
      return a->sign ? -1 : 1;
    }
  if (a->normal_exp < b->normal_exp)
   14a82:	28 17       	cp	r18, r24
   14a84:	39 07       	cpc	r19, r25
   14a86:	0c f4       	brge	.+2      	; 0x14a8a <__fpcmp_parts_f+0x7a>
   14a88:	17 c0       	rjmp	.+46     	; 0x14ab8 <__fpcmp_parts_f+0xa8>
    {
      return a->sign ? 1 : -1;
    }
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
   14a8a:	44 81       	ldd	r20, Z+4	; 0x04
   14a8c:	55 81       	ldd	r21, Z+5	; 0x05
   14a8e:	66 81       	ldd	r22, Z+6	; 0x06
   14a90:	77 81       	ldd	r23, Z+7	; 0x07
   14a92:	14 96       	adiw	r26, 0x04	; 4
   14a94:	8d 91       	ld	r24, X+
   14a96:	9d 91       	ld	r25, X+
   14a98:	0d 90       	ld	r0, X+
   14a9a:	bc 91       	ld	r27, X
   14a9c:	a0 2d       	mov	r26, r0
   14a9e:	84 17       	cp	r24, r20
   14aa0:	95 07       	cpc	r25, r21
   14aa2:	a6 07       	cpc	r26, r22
   14aa4:	b7 07       	cpc	r27, r23
   14aa6:	18 f4       	brcc	.+6      	; 0x14aae <__fpcmp_parts_f+0x9e>
    {
      return a->sign ? -1 : 1;
   14aa8:	c1 11       	cpse	r28, r1
   14aaa:	08 c0       	rjmp	.+16     	; 0x14abc <__fpcmp_parts_f+0xac>
   14aac:	0a c0       	rjmp	.+20     	; 0x14ac2 <__fpcmp_parts_f+0xb2>
    }
  if (a->fraction.ll < b->fraction.ll)
   14aae:	48 17       	cp	r20, r24
   14ab0:	59 07       	cpc	r21, r25
   14ab2:	6a 07       	cpc	r22, r26
   14ab4:	7b 07       	cpc	r23, r27
   14ab6:	40 f4       	brcc	.+16     	; 0x14ac8 <__fpcmp_parts_f+0xb8>
    {
      return a->sign ? 1 : -1;
   14ab8:	c1 11       	cpse	r28, r1
   14aba:	03 c0       	rjmp	.+6      	; 0x14ac2 <__fpcmp_parts_f+0xb2>
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   14abc:	2f ef       	ldi	r18, 0xFF	; 255
   14abe:	3f ef       	ldi	r19, 0xFF	; 255
   14ac0:	05 c0       	rjmp	.+10     	; 0x14acc <__fpcmp_parts_f+0xbc>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   14ac2:	21 e0       	ldi	r18, 0x01	; 1
   14ac4:	30 e0       	ldi	r19, 0x00	; 0
   14ac6:	02 c0       	rjmp	.+4      	; 0x14acc <__fpcmp_parts_f+0xbc>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
    {
      return 0;
   14ac8:	20 e0       	ldi	r18, 0x00	; 0
   14aca:	30 e0       	ldi	r19, 0x00	; 0
    {
      return a->sign ? 1 : -1;
    }
  /* after all that, they're equal.  */
  return 0;
}
   14acc:	c9 01       	movw	r24, r18
   14ace:	cf 91       	pop	r28
   14ad0:	08 95       	ret

00014ad2 <_ZN5Print13setWriteErrorEi>:
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
   14ad2:	cf 93       	push	r28
   14ad4:	df 93       	push	r29
   14ad6:	00 d0       	rcall	.+0      	; 0x14ad8 <_ZN5Print13setWriteErrorEi+0x6>
   14ad8:	00 d0       	rcall	.+0      	; 0x14ada <_ZN5Print13setWriteErrorEi+0x8>
   14ada:	cd b7       	in	r28, 0x3d	; 61
   14adc:	de b7       	in	r29, 0x3e	; 62
   14ade:	9a 83       	std	Y+2, r25	; 0x02
   14ae0:	89 83       	std	Y+1, r24	; 0x01
   14ae2:	7c 83       	std	Y+4, r23	; 0x04
   14ae4:	6b 83       	std	Y+3, r22	; 0x03
   14ae6:	89 81       	ldd	r24, Y+1	; 0x01
   14ae8:	9a 81       	ldd	r25, Y+2	; 0x02
   14aea:	2b 81       	ldd	r18, Y+3	; 0x03
   14aec:	3c 81       	ldd	r19, Y+4	; 0x04
   14aee:	fc 01       	movw	r30, r24
   14af0:	33 83       	std	Z+3, r19	; 0x03
   14af2:	22 83       	std	Z+2, r18	; 0x02
   14af4:	0f 90       	pop	r0
   14af6:	0f 90       	pop	r0
   14af8:	0f 90       	pop	r0
   14afa:	0f 90       	pop	r0
   14afc:	df 91       	pop	r29
   14afe:	cf 91       	pop	r28
   14b00:	08 95       	ret

00014b02 <_ZN5PrintC1Ev>:
  public:
    Print() : write_error(0) {}
   14b02:	cf 93       	push	r28
   14b04:	df 93       	push	r29
   14b06:	00 d0       	rcall	.+0      	; 0x14b08 <_ZN5PrintC1Ev+0x6>
   14b08:	cd b7       	in	r28, 0x3d	; 61
   14b0a:	de b7       	in	r29, 0x3e	; 62
   14b0c:	9a 83       	std	Y+2, r25	; 0x02
   14b0e:	89 83       	std	Y+1, r24	; 0x01
   14b10:	89 81       	ldd	r24, Y+1	; 0x01
   14b12:	9a 81       	ldd	r25, Y+2	; 0x02
   14b14:	21 ec       	ldi	r18, 0xC1	; 193
   14b16:	35 e0       	ldi	r19, 0x05	; 5
   14b18:	fc 01       	movw	r30, r24
   14b1a:	31 83       	std	Z+1, r19	; 0x01
   14b1c:	20 83       	st	Z, r18
   14b1e:	89 81       	ldd	r24, Y+1	; 0x01
   14b20:	9a 81       	ldd	r25, Y+2	; 0x02
   14b22:	fc 01       	movw	r30, r24
   14b24:	13 82       	std	Z+3, r1	; 0x03
   14b26:	12 82       	std	Z+2, r1	; 0x02
   14b28:	0f 90       	pop	r0
   14b2a:	0f 90       	pop	r0
   14b2c:	df 91       	pop	r29
   14b2e:	cf 91       	pop	r28
   14b30:	08 95       	ret

00014b32 <_ZN6StreamC1Ev>:
   14b32:	cf 93       	push	r28
   14b34:	df 93       	push	r29
   14b36:	00 d0       	rcall	.+0      	; 0x14b38 <_ZN6StreamC1Ev+0x6>
   14b38:	cd b7       	in	r28, 0x3d	; 61
   14b3a:	de b7       	in	r29, 0x3e	; 62
   14b3c:	9a 83       	std	Y+2, r25	; 0x02
   14b3e:	89 83       	std	Y+1, r24	; 0x01
   14b40:	89 81       	ldd	r24, Y+1	; 0x01
   14b42:	9a 81       	ldd	r25, Y+2	; 0x02
   14b44:	0e 94 81 a5 	call	0x14b02	; 0x14b02 <_ZN5PrintC1Ev>
   14b48:	89 81       	ldd	r24, Y+1	; 0x01
   14b4a:	9a 81       	ldd	r25, Y+2	; 0x02
   14b4c:	2b ed       	ldi	r18, 0xDB	; 219
   14b4e:	34 e0       	ldi	r19, 0x04	; 4
   14b50:	fc 01       	movw	r30, r24
   14b52:	31 83       	std	Z+1, r19	; 0x01
   14b54:	20 83       	st	Z, r18
   14b56:	29 81       	ldd	r18, Y+1	; 0x01
   14b58:	3a 81       	ldd	r19, Y+2	; 0x02
   14b5a:	88 ee       	ldi	r24, 0xE8	; 232
   14b5c:	93 e0       	ldi	r25, 0x03	; 3
   14b5e:	a0 e0       	ldi	r26, 0x00	; 0
   14b60:	b0 e0       	ldi	r27, 0x00	; 0
   14b62:	f9 01       	movw	r30, r18
   14b64:	84 83       	std	Z+4, r24	; 0x04
   14b66:	95 83       	std	Z+5, r25	; 0x05
   14b68:	a6 83       	std	Z+6, r26	; 0x06
   14b6a:	b7 83       	std	Z+7, r27	; 0x07
   14b6c:	0f 90       	pop	r0
   14b6e:	0f 90       	pop	r0
   14b70:	df 91       	pop	r29
   14b72:	cf 91       	pop	r28
   14b74:	08 95       	ret

00014b76 <_ZN9IPAddresscvmEv>:
    IPAddress(uint32_t address);
    IPAddress(const uint8_t *address);

    // Overloaded cast operator to allow IPAddress objects to be used where a pointer
    // to a four-byte uint8_t array is expected
    operator uint32_t() { return *((uint32_t*)_address); };
   14b76:	cf 93       	push	r28
   14b78:	df 93       	push	r29
   14b7a:	00 d0       	rcall	.+0      	; 0x14b7c <_ZN9IPAddresscvmEv+0x6>
   14b7c:	cd b7       	in	r28, 0x3d	; 61
   14b7e:	de b7       	in	r29, 0x3e	; 62
   14b80:	9a 83       	std	Y+2, r25	; 0x02
   14b82:	89 83       	std	Y+1, r24	; 0x01
   14b84:	89 81       	ldd	r24, Y+1	; 0x01
   14b86:	9a 81       	ldd	r25, Y+2	; 0x02
   14b88:	02 96       	adiw	r24, 0x02	; 2
   14b8a:	fc 01       	movw	r30, r24
   14b8c:	80 81       	ld	r24, Z
   14b8e:	91 81       	ldd	r25, Z+1	; 0x01
   14b90:	a2 81       	ldd	r26, Z+2	; 0x02
   14b92:	b3 81       	ldd	r27, Z+3	; 0x03
   14b94:	bc 01       	movw	r22, r24
   14b96:	cd 01       	movw	r24, r26
   14b98:	0f 90       	pop	r0
   14b9a:	0f 90       	pop	r0
   14b9c:	df 91       	pop	r29
   14b9e:	cf 91       	pop	r28
   14ba0:	08 95       	ret

00014ba2 <_ZN6ClientC1Ev>:
#define client_h
#include "Print.h"
#include "Stream.h"
#include "IPAddress.h"

class Client : public Stream {
   14ba2:	cf 93       	push	r28
   14ba4:	df 93       	push	r29
   14ba6:	00 d0       	rcall	.+0      	; 0x14ba8 <_ZN6ClientC1Ev+0x6>
   14ba8:	cd b7       	in	r28, 0x3d	; 61
   14baa:	de b7       	in	r29, 0x3e	; 62
   14bac:	9a 83       	std	Y+2, r25	; 0x02
   14bae:	89 83       	std	Y+1, r24	; 0x01
   14bb0:	89 81       	ldd	r24, Y+1	; 0x01
   14bb2:	9a 81       	ldd	r25, Y+2	; 0x02
   14bb4:	0e 94 99 a5 	call	0x14b32	; 0x14b32 <_ZN6StreamC1Ev>
   14bb8:	89 81       	ldd	r24, Y+1	; 0x01
   14bba:	9a 81       	ldd	r25, Y+2	; 0x02
   14bbc:	27 e0       	ldi	r18, 0x07	; 7
   14bbe:	35 e0       	ldi	r19, 0x05	; 5
   14bc0:	fc 01       	movw	r30, r24
   14bc2:	31 83       	std	Z+1, r19	; 0x01
   14bc4:	20 83       	st	Z, r18
   14bc6:	0f 90       	pop	r0
   14bc8:	0f 90       	pop	r0
   14bca:	df 91       	pop	r29
   14bcc:	cf 91       	pop	r28
   14bce:	08 95       	ret

00014bd0 <_ZN9PrintableC1ERKS_>:
    By deriving from Printable and implementing the printTo method, it will then be possible
    for users to print out instances of this class by passing them into the usual
    Print::print and Print::println methods.
*/

class Printable
   14bd0:	cf 93       	push	r28
   14bd2:	df 93       	push	r29
   14bd4:	00 d0       	rcall	.+0      	; 0x14bd6 <_ZN9PrintableC1ERKS_+0x6>
   14bd6:	00 d0       	rcall	.+0      	; 0x14bd8 <_ZN9PrintableC1ERKS_+0x8>
   14bd8:	cd b7       	in	r28, 0x3d	; 61
   14bda:	de b7       	in	r29, 0x3e	; 62
   14bdc:	9a 83       	std	Y+2, r25	; 0x02
   14bde:	89 83       	std	Y+1, r24	; 0x01
   14be0:	7c 83       	std	Y+4, r23	; 0x04
   14be2:	6b 83       	std	Y+3, r22	; 0x03
   14be4:	89 81       	ldd	r24, Y+1	; 0x01
   14be6:	9a 81       	ldd	r25, Y+2	; 0x02
   14be8:	23 e2       	ldi	r18, 0x23	; 35
   14bea:	35 e0       	ldi	r19, 0x05	; 5
   14bec:	fc 01       	movw	r30, r24
   14bee:	31 83       	std	Z+1, r19	; 0x01
   14bf0:	20 83       	st	Z, r18
   14bf2:	0f 90       	pop	r0
   14bf4:	0f 90       	pop	r0
   14bf6:	0f 90       	pop	r0
   14bf8:	0f 90       	pop	r0
   14bfa:	df 91       	pop	r29
   14bfc:	cf 91       	pop	r28
   14bfe:	08 95       	ret

00014c00 <_ZN9IPAddressC1ERKS_>:
   14c00:	cf 93       	push	r28
   14c02:	df 93       	push	r29
   14c04:	00 d0       	rcall	.+0      	; 0x14c06 <_ZN9IPAddressC1ERKS_+0x6>
   14c06:	00 d0       	rcall	.+0      	; 0x14c08 <_ZN9IPAddressC1ERKS_+0x8>
   14c08:	cd b7       	in	r28, 0x3d	; 61
   14c0a:	de b7       	in	r29, 0x3e	; 62
   14c0c:	9a 83       	std	Y+2, r25	; 0x02
   14c0e:	89 83       	std	Y+1, r24	; 0x01
   14c10:	7c 83       	std	Y+4, r23	; 0x04
   14c12:	6b 83       	std	Y+3, r22	; 0x03
   14c14:	2b 81       	ldd	r18, Y+3	; 0x03
   14c16:	3c 81       	ldd	r19, Y+4	; 0x04
   14c18:	89 81       	ldd	r24, Y+1	; 0x01
   14c1a:	9a 81       	ldd	r25, Y+2	; 0x02
   14c1c:	b9 01       	movw	r22, r18
   14c1e:	0e 94 e8 a5 	call	0x14bd0	; 0x14bd0 <_ZN9PrintableC1ERKS_>
   14c22:	89 81       	ldd	r24, Y+1	; 0x01
   14c24:	9a 81       	ldd	r25, Y+2	; 0x02
   14c26:	2b eb       	ldi	r18, 0xBB	; 187
   14c28:	35 e0       	ldi	r19, 0x05	; 5
   14c2a:	fc 01       	movw	r30, r24
   14c2c:	31 83       	std	Z+1, r19	; 0x01
   14c2e:	20 83       	st	Z, r18
   14c30:	29 81       	ldd	r18, Y+1	; 0x01
   14c32:	3a 81       	ldd	r19, Y+2	; 0x02
   14c34:	8b 81       	ldd	r24, Y+3	; 0x03
   14c36:	9c 81       	ldd	r25, Y+4	; 0x04
   14c38:	fc 01       	movw	r30, r24
   14c3a:	82 81       	ldd	r24, Z+2	; 0x02
   14c3c:	93 81       	ldd	r25, Z+3	; 0x03
   14c3e:	a4 81       	ldd	r26, Z+4	; 0x04
   14c40:	b5 81       	ldd	r27, Z+5	; 0x05
   14c42:	f9 01       	movw	r30, r18
   14c44:	82 83       	std	Z+2, r24	; 0x02
   14c46:	93 83       	std	Z+3, r25	; 0x03
   14c48:	a4 83       	std	Z+4, r26	; 0x04
   14c4a:	b5 83       	std	Z+5, r27	; 0x05
   14c4c:	0f 90       	pop	r0
   14c4e:	0f 90       	pop	r0
   14c50:	0f 90       	pop	r0
   14c52:	0f 90       	pop	r0
   14c54:	df 91       	pop	r29
   14c56:	cf 91       	pop	r28
   14c58:	08 95       	ret

00014c5a <_ZN6ServerC1Ev>:
   14c5a:	cf 93       	push	r28
   14c5c:	df 93       	push	r29
   14c5e:	00 d0       	rcall	.+0      	; 0x14c60 <_ZN6ServerC1Ev+0x6>
   14c60:	cd b7       	in	r28, 0x3d	; 61
   14c62:	de b7       	in	r29, 0x3e	; 62
   14c64:	9a 83       	std	Y+2, r25	; 0x02
   14c66:	89 83       	std	Y+1, r24	; 0x01
   14c68:	89 81       	ldd	r24, Y+1	; 0x01
   14c6a:	9a 81       	ldd	r25, Y+2	; 0x02
   14c6c:	0e 94 81 a5 	call	0x14b02	; 0x14b02 <_ZN5PrintC1Ev>
   14c70:	89 81       	ldd	r24, Y+1	; 0x01
   14c72:	9a 81       	ldd	r25, Y+2	; 0x02
   14c74:	23 e3       	ldi	r18, 0x33	; 51
   14c76:	35 e0       	ldi	r19, 0x05	; 5
   14c78:	fc 01       	movw	r30, r24
   14c7a:	31 83       	std	Z+1, r19	; 0x01
   14c7c:	20 83       	st	Z, r18
   14c7e:	0f 90       	pop	r0
   14c80:	0f 90       	pop	r0
   14c82:	df 91       	pop	r29
   14c84:	cf 91       	pop	r28
   14c86:	08 95       	ret

00014c88 <_ZN5PrintC1ERKS_>:
#define DEC 10
#define HEX 16
#define OCT 8
#define BIN 2

class Print
   14c88:	cf 93       	push	r28
   14c8a:	df 93       	push	r29
   14c8c:	00 d0       	rcall	.+0      	; 0x14c8e <_ZN5PrintC1ERKS_+0x6>
   14c8e:	00 d0       	rcall	.+0      	; 0x14c90 <_ZN5PrintC1ERKS_+0x8>
   14c90:	cd b7       	in	r28, 0x3d	; 61
   14c92:	de b7       	in	r29, 0x3e	; 62
   14c94:	9a 83       	std	Y+2, r25	; 0x02
   14c96:	89 83       	std	Y+1, r24	; 0x01
   14c98:	7c 83       	std	Y+4, r23	; 0x04
   14c9a:	6b 83       	std	Y+3, r22	; 0x03
   14c9c:	89 81       	ldd	r24, Y+1	; 0x01
   14c9e:	9a 81       	ldd	r25, Y+2	; 0x02
   14ca0:	21 ec       	ldi	r18, 0xC1	; 193
   14ca2:	35 e0       	ldi	r19, 0x05	; 5
   14ca4:	fc 01       	movw	r30, r24
   14ca6:	31 83       	std	Z+1, r19	; 0x01
   14ca8:	20 83       	st	Z, r18
   14caa:	8b 81       	ldd	r24, Y+3	; 0x03
   14cac:	9c 81       	ldd	r25, Y+4	; 0x04
   14cae:	fc 01       	movw	r30, r24
   14cb0:	22 81       	ldd	r18, Z+2	; 0x02
   14cb2:	33 81       	ldd	r19, Z+3	; 0x03
   14cb4:	89 81       	ldd	r24, Y+1	; 0x01
   14cb6:	9a 81       	ldd	r25, Y+2	; 0x02
   14cb8:	fc 01       	movw	r30, r24
   14cba:	33 83       	std	Z+3, r19	; 0x03
   14cbc:	22 83       	std	Z+2, r18	; 0x02
   14cbe:	0f 90       	pop	r0
   14cc0:	0f 90       	pop	r0
   14cc2:	0f 90       	pop	r0
   14cc4:	0f 90       	pop	r0
   14cc6:	df 91       	pop	r29
   14cc8:	cf 91       	pop	r28
   14cca:	08 95       	ret

00014ccc <_ZN6StreamC1ERKS_>:
#define   getFloat(skipChar)  parseFloat(skipChar)
#define   getString( pre_string, post_string, buffer, length)
readBytesBetween( pre_string, terminator, buffer, length)
*/

class Stream : public Print
   14ccc:	cf 93       	push	r28
   14cce:	df 93       	push	r29
   14cd0:	00 d0       	rcall	.+0      	; 0x14cd2 <_ZN6StreamC1ERKS_+0x6>
   14cd2:	00 d0       	rcall	.+0      	; 0x14cd4 <_ZN6StreamC1ERKS_+0x8>
   14cd4:	cd b7       	in	r28, 0x3d	; 61
   14cd6:	de b7       	in	r29, 0x3e	; 62
   14cd8:	9a 83       	std	Y+2, r25	; 0x02
   14cda:	89 83       	std	Y+1, r24	; 0x01
   14cdc:	7c 83       	std	Y+4, r23	; 0x04
   14cde:	6b 83       	std	Y+3, r22	; 0x03
   14ce0:	2b 81       	ldd	r18, Y+3	; 0x03
   14ce2:	3c 81       	ldd	r19, Y+4	; 0x04
   14ce4:	89 81       	ldd	r24, Y+1	; 0x01
   14ce6:	9a 81       	ldd	r25, Y+2	; 0x02
   14ce8:	b9 01       	movw	r22, r18
   14cea:	0e 94 44 a6 	call	0x14c88	; 0x14c88 <_ZN5PrintC1ERKS_>
   14cee:	89 81       	ldd	r24, Y+1	; 0x01
   14cf0:	9a 81       	ldd	r25, Y+2	; 0x02
   14cf2:	2b ed       	ldi	r18, 0xDB	; 219
   14cf4:	34 e0       	ldi	r19, 0x04	; 4
   14cf6:	fc 01       	movw	r30, r24
   14cf8:	31 83       	std	Z+1, r19	; 0x01
   14cfa:	20 83       	st	Z, r18
   14cfc:	8b 81       	ldd	r24, Y+3	; 0x03
   14cfe:	9c 81       	ldd	r25, Y+4	; 0x04
   14d00:	fc 01       	movw	r30, r24
   14d02:	84 81       	ldd	r24, Z+4	; 0x04
   14d04:	95 81       	ldd	r25, Z+5	; 0x05
   14d06:	a6 81       	ldd	r26, Z+6	; 0x06
   14d08:	b7 81       	ldd	r27, Z+7	; 0x07
   14d0a:	29 81       	ldd	r18, Y+1	; 0x01
   14d0c:	3a 81       	ldd	r19, Y+2	; 0x02
   14d0e:	f9 01       	movw	r30, r18
   14d10:	84 83       	std	Z+4, r24	; 0x04
   14d12:	95 83       	std	Z+5, r25	; 0x05
   14d14:	a6 83       	std	Z+6, r26	; 0x06
   14d16:	b7 83       	std	Z+7, r27	; 0x07
   14d18:	8b 81       	ldd	r24, Y+3	; 0x03
   14d1a:	9c 81       	ldd	r25, Y+4	; 0x04
   14d1c:	fc 01       	movw	r30, r24
   14d1e:	80 85       	ldd	r24, Z+8	; 0x08
   14d20:	91 85       	ldd	r25, Z+9	; 0x09
   14d22:	a2 85       	ldd	r26, Z+10	; 0x0a
   14d24:	b3 85       	ldd	r27, Z+11	; 0x0b
   14d26:	29 81       	ldd	r18, Y+1	; 0x01
   14d28:	3a 81       	ldd	r19, Y+2	; 0x02
   14d2a:	f9 01       	movw	r30, r18
   14d2c:	80 87       	std	Z+8, r24	; 0x08
   14d2e:	91 87       	std	Z+9, r25	; 0x09
   14d30:	a2 87       	std	Z+10, r26	; 0x0a
   14d32:	b3 87       	std	Z+11, r27	; 0x0b
   14d34:	0f 90       	pop	r0
   14d36:	0f 90       	pop	r0
   14d38:	0f 90       	pop	r0
   14d3a:	0f 90       	pop	r0
   14d3c:	df 91       	pop	r29
   14d3e:	cf 91       	pop	r28
   14d40:	08 95       	ret

00014d42 <_ZN6ClientC1ERKS_>:
   14d42:	cf 93       	push	r28
   14d44:	df 93       	push	r29
   14d46:	00 d0       	rcall	.+0      	; 0x14d48 <_ZN6ClientC1ERKS_+0x6>
   14d48:	00 d0       	rcall	.+0      	; 0x14d4a <_ZN6ClientC1ERKS_+0x8>
   14d4a:	cd b7       	in	r28, 0x3d	; 61
   14d4c:	de b7       	in	r29, 0x3e	; 62
   14d4e:	9a 83       	std	Y+2, r25	; 0x02
   14d50:	89 83       	std	Y+1, r24	; 0x01
   14d52:	7c 83       	std	Y+4, r23	; 0x04
   14d54:	6b 83       	std	Y+3, r22	; 0x03
   14d56:	2b 81       	ldd	r18, Y+3	; 0x03
   14d58:	3c 81       	ldd	r19, Y+4	; 0x04
   14d5a:	89 81       	ldd	r24, Y+1	; 0x01
   14d5c:	9a 81       	ldd	r25, Y+2	; 0x02
   14d5e:	b9 01       	movw	r22, r18
   14d60:	0e 94 66 a6 	call	0x14ccc	; 0x14ccc <_ZN6StreamC1ERKS_>
   14d64:	89 81       	ldd	r24, Y+1	; 0x01
   14d66:	9a 81       	ldd	r25, Y+2	; 0x02
   14d68:	27 e0       	ldi	r18, 0x07	; 7
   14d6a:	35 e0       	ldi	r19, 0x05	; 5
   14d6c:	fc 01       	movw	r30, r24
   14d6e:	31 83       	std	Z+1, r19	; 0x01
   14d70:	20 83       	st	Z, r18
   14d72:	0f 90       	pop	r0
   14d74:	0f 90       	pop	r0
   14d76:	0f 90       	pop	r0
   14d78:	0f 90       	pop	r0
   14d7a:	df 91       	pop	r29
   14d7c:	cf 91       	pop	r28
   14d7e:	08 95       	ret

00014d80 <_ZN10WiFiClientC1ERKS_>:
#include "Arduino.h"	
#include "Print.h"
#include "Client.h"
#include "IPAddress.h"

class WiFiClient : public Client {
   14d80:	cf 93       	push	r28
   14d82:	df 93       	push	r29
   14d84:	00 d0       	rcall	.+0      	; 0x14d86 <_ZN10WiFiClientC1ERKS_+0x6>
   14d86:	00 d0       	rcall	.+0      	; 0x14d88 <_ZN10WiFiClientC1ERKS_+0x8>
   14d88:	cd b7       	in	r28, 0x3d	; 61
   14d8a:	de b7       	in	r29, 0x3e	; 62
   14d8c:	9a 83       	std	Y+2, r25	; 0x02
   14d8e:	89 83       	std	Y+1, r24	; 0x01
   14d90:	7c 83       	std	Y+4, r23	; 0x04
   14d92:	6b 83       	std	Y+3, r22	; 0x03
   14d94:	2b 81       	ldd	r18, Y+3	; 0x03
   14d96:	3c 81       	ldd	r19, Y+4	; 0x04
   14d98:	89 81       	ldd	r24, Y+1	; 0x01
   14d9a:	9a 81       	ldd	r25, Y+2	; 0x02
   14d9c:	b9 01       	movw	r22, r18
   14d9e:	0e 94 a1 a6 	call	0x14d42	; 0x14d42 <_ZN6ClientC1ERKS_>
   14da2:	89 81       	ldd	r24, Y+1	; 0x01
   14da4:	9a 81       	ldd	r25, Y+2	; 0x02
   14da6:	2b ee       	ldi	r18, 0xEB	; 235
   14da8:	34 e0       	ldi	r19, 0x04	; 4
   14daa:	fc 01       	movw	r30, r24
   14dac:	31 83       	std	Z+1, r19	; 0x01
   14dae:	20 83       	st	Z, r18
   14db0:	8b 81       	ldd	r24, Y+3	; 0x03
   14db2:	9c 81       	ldd	r25, Y+4	; 0x04
   14db4:	fc 01       	movw	r30, r24
   14db6:	24 85       	ldd	r18, Z+12	; 0x0c
   14db8:	89 81       	ldd	r24, Y+1	; 0x01
   14dba:	9a 81       	ldd	r25, Y+2	; 0x02
   14dbc:	fc 01       	movw	r30, r24
   14dbe:	24 87       	std	Z+12, r18	; 0x0c
   14dc0:	8b 81       	ldd	r24, Y+3	; 0x03
   14dc2:	9c 81       	ldd	r25, Y+4	; 0x04
   14dc4:	fc 01       	movw	r30, r24
   14dc6:	25 85       	ldd	r18, Z+13	; 0x0d
   14dc8:	36 85       	ldd	r19, Z+14	; 0x0e
   14dca:	89 81       	ldd	r24, Y+1	; 0x01
   14dcc:	9a 81       	ldd	r25, Y+2	; 0x02
   14dce:	fc 01       	movw	r30, r24
   14dd0:	36 87       	std	Z+14, r19	; 0x0e
   14dd2:	25 87       	std	Z+13, r18	; 0x0d
   14dd4:	0f 90       	pop	r0
   14dd6:	0f 90       	pop	r0
   14dd8:	0f 90       	pop	r0
   14dda:	0f 90       	pop	r0
   14ddc:	df 91       	pop	r29
   14dde:	cf 91       	pop	r28
   14de0:	08 95       	ret

00014de2 <_ZN5PrintaSERKS_>:
   14de2:	cf 93       	push	r28
   14de4:	df 93       	push	r29
   14de6:	00 d0       	rcall	.+0      	; 0x14de8 <_ZN5PrintaSERKS_+0x6>
   14de8:	00 d0       	rcall	.+0      	; 0x14dea <_ZN5PrintaSERKS_+0x8>
   14dea:	cd b7       	in	r28, 0x3d	; 61
   14dec:	de b7       	in	r29, 0x3e	; 62
   14dee:	9a 83       	std	Y+2, r25	; 0x02
   14df0:	89 83       	std	Y+1, r24	; 0x01
   14df2:	7c 83       	std	Y+4, r23	; 0x04
   14df4:	6b 83       	std	Y+3, r22	; 0x03
   14df6:	8b 81       	ldd	r24, Y+3	; 0x03
   14df8:	9c 81       	ldd	r25, Y+4	; 0x04
   14dfa:	fc 01       	movw	r30, r24
   14dfc:	22 81       	ldd	r18, Z+2	; 0x02
   14dfe:	33 81       	ldd	r19, Z+3	; 0x03
   14e00:	89 81       	ldd	r24, Y+1	; 0x01
   14e02:	9a 81       	ldd	r25, Y+2	; 0x02
   14e04:	fc 01       	movw	r30, r24
   14e06:	33 83       	std	Z+3, r19	; 0x03
   14e08:	22 83       	std	Z+2, r18	; 0x02
   14e0a:	89 81       	ldd	r24, Y+1	; 0x01
   14e0c:	9a 81       	ldd	r25, Y+2	; 0x02
   14e0e:	0f 90       	pop	r0
   14e10:	0f 90       	pop	r0
   14e12:	0f 90       	pop	r0
   14e14:	0f 90       	pop	r0
   14e16:	df 91       	pop	r29
   14e18:	cf 91       	pop	r28
   14e1a:	08 95       	ret

00014e1c <_ZN6StreamaSERKS_>:
   14e1c:	cf 93       	push	r28
   14e1e:	df 93       	push	r29
   14e20:	00 d0       	rcall	.+0      	; 0x14e22 <_ZN6StreamaSERKS_+0x6>
   14e22:	00 d0       	rcall	.+0      	; 0x14e24 <_ZN6StreamaSERKS_+0x8>
   14e24:	cd b7       	in	r28, 0x3d	; 61
   14e26:	de b7       	in	r29, 0x3e	; 62
   14e28:	9a 83       	std	Y+2, r25	; 0x02
   14e2a:	89 83       	std	Y+1, r24	; 0x01
   14e2c:	7c 83       	std	Y+4, r23	; 0x04
   14e2e:	6b 83       	std	Y+3, r22	; 0x03
   14e30:	2b 81       	ldd	r18, Y+3	; 0x03
   14e32:	3c 81       	ldd	r19, Y+4	; 0x04
   14e34:	89 81       	ldd	r24, Y+1	; 0x01
   14e36:	9a 81       	ldd	r25, Y+2	; 0x02
   14e38:	b9 01       	movw	r22, r18
   14e3a:	0e 94 f1 a6 	call	0x14de2	; 0x14de2 <_ZN5PrintaSERKS_>
   14e3e:	8b 81       	ldd	r24, Y+3	; 0x03
   14e40:	9c 81       	ldd	r25, Y+4	; 0x04
   14e42:	fc 01       	movw	r30, r24
   14e44:	84 81       	ldd	r24, Z+4	; 0x04
   14e46:	95 81       	ldd	r25, Z+5	; 0x05
   14e48:	a6 81       	ldd	r26, Z+6	; 0x06
   14e4a:	b7 81       	ldd	r27, Z+7	; 0x07
   14e4c:	29 81       	ldd	r18, Y+1	; 0x01
   14e4e:	3a 81       	ldd	r19, Y+2	; 0x02
   14e50:	f9 01       	movw	r30, r18
   14e52:	84 83       	std	Z+4, r24	; 0x04
   14e54:	95 83       	std	Z+5, r25	; 0x05
   14e56:	a6 83       	std	Z+6, r26	; 0x06
   14e58:	b7 83       	std	Z+7, r27	; 0x07
   14e5a:	8b 81       	ldd	r24, Y+3	; 0x03
   14e5c:	9c 81       	ldd	r25, Y+4	; 0x04
   14e5e:	fc 01       	movw	r30, r24
   14e60:	80 85       	ldd	r24, Z+8	; 0x08
   14e62:	91 85       	ldd	r25, Z+9	; 0x09
   14e64:	a2 85       	ldd	r26, Z+10	; 0x0a
   14e66:	b3 85       	ldd	r27, Z+11	; 0x0b
   14e68:	29 81       	ldd	r18, Y+1	; 0x01
   14e6a:	3a 81       	ldd	r19, Y+2	; 0x02
   14e6c:	f9 01       	movw	r30, r18
   14e6e:	80 87       	std	Z+8, r24	; 0x08
   14e70:	91 87       	std	Z+9, r25	; 0x09
   14e72:	a2 87       	std	Z+10, r26	; 0x0a
   14e74:	b3 87       	std	Z+11, r27	; 0x0b
   14e76:	89 81       	ldd	r24, Y+1	; 0x01
   14e78:	9a 81       	ldd	r25, Y+2	; 0x02
   14e7a:	0f 90       	pop	r0
   14e7c:	0f 90       	pop	r0
   14e7e:	0f 90       	pop	r0
   14e80:	0f 90       	pop	r0
   14e82:	df 91       	pop	r29
   14e84:	cf 91       	pop	r28
   14e86:	08 95       	ret

00014e88 <_ZN10W5100Class9writeSnMREhh>:
  static uint16_t read##name(SOCKET _s, uint8_t *_buff) {    \
    return readSn(_s, address, _buff, size);                 \
  }
  
public:
  __SOCKET_REGISTER8(SnMR,        0x0000)        // Mode
   14e88:	cf 93       	push	r28
   14e8a:	df 93       	push	r29
   14e8c:	00 d0       	rcall	.+0      	; 0x14e8e <_ZN10W5100Class9writeSnMREhh+0x6>
   14e8e:	cd b7       	in	r28, 0x3d	; 61
   14e90:	de b7       	in	r29, 0x3e	; 62
   14e92:	89 83       	std	Y+1, r24	; 0x01
   14e94:	6a 83       	std	Y+2, r22	; 0x02
   14e96:	4a 81       	ldd	r20, Y+2	; 0x02
   14e98:	60 e0       	ldi	r22, 0x00	; 0
   14e9a:	70 e0       	ldi	r23, 0x00	; 0
   14e9c:	89 81       	ldd	r24, Y+1	; 0x01
   14e9e:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   14ea2:	0f 90       	pop	r0
   14ea4:	0f 90       	pop	r0
   14ea6:	df 91       	pop	r29
   14ea8:	cf 91       	pop	r28
   14eaa:	08 95       	ret

00014eac <_ZN10W5100Class8readSnMREh>:
   14eac:	cf 93       	push	r28
   14eae:	df 93       	push	r29
   14eb0:	1f 92       	push	r1
   14eb2:	cd b7       	in	r28, 0x3d	; 61
   14eb4:	de b7       	in	r29, 0x3e	; 62
   14eb6:	89 83       	std	Y+1, r24	; 0x01
   14eb8:	60 e0       	ldi	r22, 0x00	; 0
   14eba:	70 e0       	ldi	r23, 0x00	; 0
   14ebc:	89 81       	ldd	r24, Y+1	; 0x01
   14ebe:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   14ec2:	0f 90       	pop	r0
   14ec4:	df 91       	pop	r29
   14ec6:	cf 91       	pop	r28
   14ec8:	08 95       	ret

00014eca <_ZN10W5100Class9writeSnIREhh>:
  __SOCKET_REGISTER8(SnCR,        0x0001)        // Command
  __SOCKET_REGISTER8(SnIR,        0x0002)        // Interrupt
   14eca:	cf 93       	push	r28
   14ecc:	df 93       	push	r29
   14ece:	00 d0       	rcall	.+0      	; 0x14ed0 <_ZN10W5100Class9writeSnIREhh+0x6>
   14ed0:	cd b7       	in	r28, 0x3d	; 61
   14ed2:	de b7       	in	r29, 0x3e	; 62
   14ed4:	89 83       	std	Y+1, r24	; 0x01
   14ed6:	6a 83       	std	Y+2, r22	; 0x02
   14ed8:	4a 81       	ldd	r20, Y+2	; 0x02
   14eda:	62 e0       	ldi	r22, 0x02	; 2
   14edc:	70 e0       	ldi	r23, 0x00	; 0
   14ede:	89 81       	ldd	r24, Y+1	; 0x01
   14ee0:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   14ee4:	0f 90       	pop	r0
   14ee6:	0f 90       	pop	r0
   14ee8:	df 91       	pop	r29
   14eea:	cf 91       	pop	r28
   14eec:	08 95       	ret

00014eee <_ZN10W5100Class8readSnIREh>:
   14eee:	cf 93       	push	r28
   14ef0:	df 93       	push	r29
   14ef2:	1f 92       	push	r1
   14ef4:	cd b7       	in	r28, 0x3d	; 61
   14ef6:	de b7       	in	r29, 0x3e	; 62
   14ef8:	89 83       	std	Y+1, r24	; 0x01
   14efa:	62 e0       	ldi	r22, 0x02	; 2
   14efc:	70 e0       	ldi	r23, 0x00	; 0
   14efe:	89 81       	ldd	r24, Y+1	; 0x01
   14f00:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   14f04:	0f 90       	pop	r0
   14f06:	df 91       	pop	r29
   14f08:	cf 91       	pop	r28
   14f0a:	08 95       	ret

00014f0c <_ZN10W5100Class8readSnSREh>:
  __SOCKET_REGISTER8(SnSR,        0x0003)        // Status
   14f0c:	cf 93       	push	r28
   14f0e:	df 93       	push	r29
   14f10:	1f 92       	push	r1
   14f12:	cd b7       	in	r28, 0x3d	; 61
   14f14:	de b7       	in	r29, 0x3e	; 62
   14f16:	89 83       	std	Y+1, r24	; 0x01
   14f18:	63 e0       	ldi	r22, 0x03	; 3
   14f1a:	70 e0       	ldi	r23, 0x00	; 0
   14f1c:	89 81       	ldd	r24, Y+1	; 0x01
   14f1e:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   14f22:	0f 90       	pop	r0
   14f24:	df 91       	pop	r29
   14f26:	cf 91       	pop	r28
   14f28:	08 95       	ret

00014f2a <_ZN10W5100Class11writeSnPORTEhj>:
  __SOCKET_REGISTER16(SnPORT,     0x0004)        // Source Port
   14f2a:	cf 93       	push	r28
   14f2c:	df 93       	push	r29
   14f2e:	00 d0       	rcall	.+0      	; 0x14f30 <_ZN10W5100Class11writeSnPORTEhj+0x6>
   14f30:	1f 92       	push	r1
   14f32:	cd b7       	in	r28, 0x3d	; 61
   14f34:	de b7       	in	r29, 0x3e	; 62
   14f36:	89 83       	std	Y+1, r24	; 0x01
   14f38:	7b 83       	std	Y+3, r23	; 0x03
   14f3a:	6a 83       	std	Y+2, r22	; 0x02
   14f3c:	8a 81       	ldd	r24, Y+2	; 0x02
   14f3e:	9b 81       	ldd	r25, Y+3	; 0x03
   14f40:	89 2f       	mov	r24, r25
   14f42:	99 27       	eor	r25, r25
   14f44:	48 2f       	mov	r20, r24
   14f46:	64 e0       	ldi	r22, 0x04	; 4
   14f48:	70 e0       	ldi	r23, 0x00	; 0
   14f4a:	89 81       	ldd	r24, Y+1	; 0x01
   14f4c:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   14f50:	8a 81       	ldd	r24, Y+2	; 0x02
   14f52:	48 2f       	mov	r20, r24
   14f54:	65 e0       	ldi	r22, 0x05	; 5
   14f56:	70 e0       	ldi	r23, 0x00	; 0
   14f58:	89 81       	ldd	r24, Y+1	; 0x01
   14f5a:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   14f5e:	0f 90       	pop	r0
   14f60:	0f 90       	pop	r0
   14f62:	0f 90       	pop	r0
   14f64:	df 91       	pop	r29
   14f66:	cf 91       	pop	r28
   14f68:	08 95       	ret

00014f6a <_ZN10W5100Class11writeSnDIPREhPh>:
  __SOCKET_REGISTER_N(SnDHAR,     0x0006, 6)     // Destination Hardw Addr
  __SOCKET_REGISTER_N(SnDIPR,     0x000C, 4)     // Destination IP Addr
   14f6a:	cf 93       	push	r28
   14f6c:	df 93       	push	r29
   14f6e:	00 d0       	rcall	.+0      	; 0x14f70 <_ZN10W5100Class11writeSnDIPREhPh+0x6>
   14f70:	1f 92       	push	r1
   14f72:	cd b7       	in	r28, 0x3d	; 61
   14f74:	de b7       	in	r29, 0x3e	; 62
   14f76:	89 83       	std	Y+1, r24	; 0x01
   14f78:	7b 83       	std	Y+3, r23	; 0x03
   14f7a:	6a 83       	std	Y+2, r22	; 0x02
   14f7c:	8a 81       	ldd	r24, Y+2	; 0x02
   14f7e:	9b 81       	ldd	r25, Y+3	; 0x03
   14f80:	24 e0       	ldi	r18, 0x04	; 4
   14f82:	30 e0       	ldi	r19, 0x00	; 0
   14f84:	ac 01       	movw	r20, r24
   14f86:	6c e0       	ldi	r22, 0x0C	; 12
   14f88:	70 e0       	ldi	r23, 0x00	; 0
   14f8a:	89 81       	ldd	r24, Y+1	; 0x01
   14f8c:	0e 94 7e a8 	call	0x150fc	; 0x150fc <_ZN10W5100Class7writeSnEhjPhj>
   14f90:	0f 90       	pop	r0
   14f92:	0f 90       	pop	r0
   14f94:	0f 90       	pop	r0
   14f96:	df 91       	pop	r29
   14f98:	cf 91       	pop	r28
   14f9a:	08 95       	ret

00014f9c <_ZN10W5100Class12writeSnDPORTEhj>:
  __SOCKET_REGISTER16(SnDPORT,    0x0010)        // Destination Port
   14f9c:	cf 93       	push	r28
   14f9e:	df 93       	push	r29
   14fa0:	00 d0       	rcall	.+0      	; 0x14fa2 <_ZN10W5100Class12writeSnDPORTEhj+0x6>
   14fa2:	1f 92       	push	r1
   14fa4:	cd b7       	in	r28, 0x3d	; 61
   14fa6:	de b7       	in	r29, 0x3e	; 62
   14fa8:	89 83       	std	Y+1, r24	; 0x01
   14faa:	7b 83       	std	Y+3, r23	; 0x03
   14fac:	6a 83       	std	Y+2, r22	; 0x02
   14fae:	8a 81       	ldd	r24, Y+2	; 0x02
   14fb0:	9b 81       	ldd	r25, Y+3	; 0x03
   14fb2:	89 2f       	mov	r24, r25
   14fb4:	99 27       	eor	r25, r25
   14fb6:	48 2f       	mov	r20, r24
   14fb8:	60 e1       	ldi	r22, 0x10	; 16
   14fba:	70 e0       	ldi	r23, 0x00	; 0
   14fbc:	89 81       	ldd	r24, Y+1	; 0x01
   14fbe:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   14fc2:	8a 81       	ldd	r24, Y+2	; 0x02
   14fc4:	48 2f       	mov	r20, r24
   14fc6:	61 e1       	ldi	r22, 0x11	; 17
   14fc8:	70 e0       	ldi	r23, 0x00	; 0
   14fca:	89 81       	ldd	r24, Y+1	; 0x01
   14fcc:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   14fd0:	0f 90       	pop	r0
   14fd2:	0f 90       	pop	r0
   14fd4:	0f 90       	pop	r0
   14fd6:	df 91       	pop	r29
   14fd8:	cf 91       	pop	r28
   14fda:	08 95       	ret

00014fdc <_ZN10W5100Class12writeSnRX_RDEhj>:
   14fdc:	cf 93       	push	r28
   14fde:	df 93       	push	r29
   14fe0:	00 d0       	rcall	.+0      	; 0x14fe2 <_ZN10W5100Class12writeSnRX_RDEhj+0x6>
   14fe2:	1f 92       	push	r1
   14fe4:	cd b7       	in	r28, 0x3d	; 61
   14fe6:	de b7       	in	r29, 0x3e	; 62
   14fe8:	89 83       	std	Y+1, r24	; 0x01
   14fea:	7b 83       	std	Y+3, r23	; 0x03
   14fec:	6a 83       	std	Y+2, r22	; 0x02
   14fee:	8a 81       	ldd	r24, Y+2	; 0x02
   14ff0:	9b 81       	ldd	r25, Y+3	; 0x03
   14ff2:	89 2f       	mov	r24, r25
   14ff4:	99 27       	eor	r25, r25
   14ff6:	48 2f       	mov	r20, r24
   14ff8:	68 e2       	ldi	r22, 0x28	; 40
   14ffa:	70 e0       	ldi	r23, 0x00	; 0
   14ffc:	89 81       	ldd	r24, Y+1	; 0x01
   14ffe:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   15002:	8a 81       	ldd	r24, Y+2	; 0x02
   15004:	48 2f       	mov	r20, r24
   15006:	69 e2       	ldi	r22, 0x29	; 41
   15008:	70 e0       	ldi	r23, 0x00	; 0
   1500a:	89 81       	ldd	r24, Y+1	; 0x01
   1500c:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   15010:	0f 90       	pop	r0
   15012:	0f 90       	pop	r0
   15014:	0f 90       	pop	r0
   15016:	df 91       	pop	r29
   15018:	cf 91       	pop	r28
   1501a:	08 95       	ret

0001501c <_ZN10W5100Class11readSnRX_RDEh>:
   1501c:	cf 93       	push	r28
   1501e:	df 93       	push	r29
   15020:	00 d0       	rcall	.+0      	; 0x15022 <_ZN10W5100Class11readSnRX_RDEh+0x6>
   15022:	00 d0       	rcall	.+0      	; 0x15024 <_ZN10W5100Class11readSnRX_RDEh+0x8>
   15024:	1f 92       	push	r1
   15026:	cd b7       	in	r28, 0x3d	; 61
   15028:	de b7       	in	r29, 0x3e	; 62
   1502a:	8d 83       	std	Y+5, r24	; 0x05
   1502c:	68 e2       	ldi	r22, 0x28	; 40
   1502e:	70 e0       	ldi	r23, 0x00	; 0
   15030:	8d 81       	ldd	r24, Y+5	; 0x05
   15032:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   15036:	88 2f       	mov	r24, r24
   15038:	90 e0       	ldi	r25, 0x00	; 0
   1503a:	9a 83       	std	Y+2, r25	; 0x02
   1503c:	89 83       	std	Y+1, r24	; 0x01
   1503e:	69 e2       	ldi	r22, 0x29	; 41
   15040:	70 e0       	ldi	r23, 0x00	; 0
   15042:	8d 81       	ldd	r24, Y+5	; 0x05
   15044:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   15048:	88 2f       	mov	r24, r24
   1504a:	90 e0       	ldi	r25, 0x00	; 0
   1504c:	9c 83       	std	Y+4, r25	; 0x04
   1504e:	8b 83       	std	Y+3, r24	; 0x03
   15050:	89 81       	ldd	r24, Y+1	; 0x01
   15052:	9a 81       	ldd	r25, Y+2	; 0x02
   15054:	98 2f       	mov	r25, r24
   15056:	88 27       	eor	r24, r24
   15058:	9a 83       	std	Y+2, r25	; 0x02
   1505a:	89 83       	std	Y+1, r24	; 0x01
   1505c:	8b 81       	ldd	r24, Y+3	; 0x03
   1505e:	9c 81       	ldd	r25, Y+4	; 0x04
   15060:	99 27       	eor	r25, r25
   15062:	9c 83       	std	Y+4, r25	; 0x04
   15064:	8b 83       	std	Y+3, r24	; 0x03
   15066:	29 81       	ldd	r18, Y+1	; 0x01
   15068:	3a 81       	ldd	r19, Y+2	; 0x02
   1506a:	8b 81       	ldd	r24, Y+3	; 0x03
   1506c:	9c 81       	ldd	r25, Y+4	; 0x04
   1506e:	82 2b       	or	r24, r18
   15070:	93 2b       	or	r25, r19
   15072:	9a 83       	std	Y+2, r25	; 0x02
   15074:	89 83       	std	Y+1, r24	; 0x01
   15076:	89 81       	ldd	r24, Y+1	; 0x01
   15078:	9a 81       	ldd	r25, Y+2	; 0x02
   1507a:	0f 90       	pop	r0
   1507c:	0f 90       	pop	r0
   1507e:	0f 90       	pop	r0
   15080:	0f 90       	pop	r0
   15082:	0f 90       	pop	r0
   15084:	df 91       	pop	r29
   15086:	cf 91       	pop	r28
   15088:	08 95       	ret

0001508a <_ZN10W5100Class6readSnEhj>:
   1508a:	cf 93       	push	r28
   1508c:	df 93       	push	r29
   1508e:	00 d0       	rcall	.+0      	; 0x15090 <_ZN10W5100Class6readSnEhj+0x6>
   15090:	1f 92       	push	r1
   15092:	cd b7       	in	r28, 0x3d	; 61
   15094:	de b7       	in	r29, 0x3e	; 62
   15096:	89 83       	std	Y+1, r24	; 0x01
   15098:	7b 83       	std	Y+3, r23	; 0x03
   1509a:	6a 83       	std	Y+2, r22	; 0x02
   1509c:	89 81       	ldd	r24, Y+1	; 0x01
   1509e:	88 2f       	mov	r24, r24
   150a0:	90 e0       	ldi	r25, 0x00	; 0
   150a2:	04 96       	adiw	r24, 0x04	; 4
   150a4:	38 2f       	mov	r19, r24
   150a6:	22 27       	eor	r18, r18
   150a8:	8a 81       	ldd	r24, Y+2	; 0x02
   150aa:	9b 81       	ldd	r25, Y+3	; 0x03
   150ac:	82 0f       	add	r24, r18
   150ae:	93 1f       	adc	r25, r19
   150b0:	0e 94 c2 36 	call	0x6d84	; 0x6d84 <_ZN10W5100Class4readEj>
   150b4:	0f 90       	pop	r0
   150b6:	0f 90       	pop	r0
   150b8:	0f 90       	pop	r0
   150ba:	df 91       	pop	r29
   150bc:	cf 91       	pop	r28
   150be:	08 95       	ret

000150c0 <_ZN10W5100Class7writeSnEhjh>:

uint8_t W5100Class::readSn(SOCKET _s, uint16_t _addr) {
  return read(CH_BASE + _s * CH_SIZE + _addr);
}

uint8_t W5100Class::writeSn(SOCKET _s, uint16_t _addr, uint8_t _data) {
   150c0:	cf 93       	push	r28
   150c2:	df 93       	push	r29
   150c4:	00 d0       	rcall	.+0      	; 0x150c6 <_ZN10W5100Class7writeSnEhjh+0x6>
   150c6:	00 d0       	rcall	.+0      	; 0x150c8 <_ZN10W5100Class7writeSnEhjh+0x8>
   150c8:	cd b7       	in	r28, 0x3d	; 61
   150ca:	de b7       	in	r29, 0x3e	; 62
   150cc:	89 83       	std	Y+1, r24	; 0x01
   150ce:	7b 83       	std	Y+3, r23	; 0x03
   150d0:	6a 83       	std	Y+2, r22	; 0x02
   150d2:	4c 83       	std	Y+4, r20	; 0x04
  return write(CH_BASE + _s * CH_SIZE + _addr, _data);
   150d4:	89 81       	ldd	r24, Y+1	; 0x01
   150d6:	88 2f       	mov	r24, r24
   150d8:	90 e0       	ldi	r25, 0x00	; 0
   150da:	04 96       	adiw	r24, 0x04	; 4
   150dc:	38 2f       	mov	r19, r24
   150de:	22 27       	eor	r18, r18
   150e0:	8a 81       	ldd	r24, Y+2	; 0x02
   150e2:	9b 81       	ldd	r25, Y+3	; 0x03
   150e4:	82 0f       	add	r24, r18
   150e6:	93 1f       	adc	r25, r19
   150e8:	6c 81       	ldd	r22, Y+4	; 0x04
   150ea:	0e 94 52 36 	call	0x6ca4	; 0x6ca4 <_ZN10W5100Class5writeEjh>
}
   150ee:	0f 90       	pop	r0
   150f0:	0f 90       	pop	r0
   150f2:	0f 90       	pop	r0
   150f4:	0f 90       	pop	r0
   150f6:	df 91       	pop	r29
   150f8:	cf 91       	pop	r28
   150fa:	08 95       	ret

000150fc <_ZN10W5100Class7writeSnEhjPhj>:

uint16_t W5100Class::readSn(SOCKET _s, uint16_t _addr, uint8_t *_buf, uint16_t _len) {
  return read(CH_BASE + _s * CH_SIZE + _addr, _buf, _len);
}

uint16_t W5100Class::writeSn(SOCKET _s, uint16_t _addr, uint8_t *_buf, uint16_t _len) {
   150fc:	cf 93       	push	r28
   150fe:	df 93       	push	r29
   15100:	cd b7       	in	r28, 0x3d	; 61
   15102:	de b7       	in	r29, 0x3e	; 62
   15104:	27 97       	sbiw	r28, 0x07	; 7
   15106:	0f b6       	in	r0, 0x3f	; 63
   15108:	f8 94       	cli
   1510a:	de bf       	out	0x3e, r29	; 62
   1510c:	0f be       	out	0x3f, r0	; 63
   1510e:	cd bf       	out	0x3d, r28	; 61
   15110:	89 83       	std	Y+1, r24	; 0x01
   15112:	7b 83       	std	Y+3, r23	; 0x03
   15114:	6a 83       	std	Y+2, r22	; 0x02
   15116:	5d 83       	std	Y+5, r21	; 0x05
   15118:	4c 83       	std	Y+4, r20	; 0x04
   1511a:	3f 83       	std	Y+7, r19	; 0x07
   1511c:	2e 83       	std	Y+6, r18	; 0x06
  return write(CH_BASE + _s * CH_SIZE + _addr, _buf, _len);
   1511e:	89 81       	ldd	r24, Y+1	; 0x01
   15120:	88 2f       	mov	r24, r24
   15122:	90 e0       	ldi	r25, 0x00	; 0
   15124:	04 96       	adiw	r24, 0x04	; 4
   15126:	38 2f       	mov	r19, r24
   15128:	22 27       	eor	r18, r18
   1512a:	8a 81       	ldd	r24, Y+2	; 0x02
   1512c:	9b 81       	ldd	r25, Y+3	; 0x03
   1512e:	82 0f       	add	r24, r18
   15130:	93 1f       	adc	r25, r19
   15132:	4e 81       	ldd	r20, Y+6	; 0x06
   15134:	5f 81       	ldd	r21, Y+7	; 0x07
   15136:	2c 81       	ldd	r18, Y+4	; 0x04
   15138:	3d 81       	ldd	r19, Y+5	; 0x05
   1513a:	b9 01       	movw	r22, r18
   1513c:	0e 94 75 36 	call	0x6cea	; 0x6cea <_ZN10W5100Class5writeEjPKhj>
}
   15140:	27 96       	adiw	r28, 0x07	; 7
   15142:	0f b6       	in	r0, 0x3f	; 63
   15144:	f8 94       	cli
   15146:	de bf       	out	0x3e, r29	; 62
   15148:	0f be       	out	0x3f, r0	; 63
   1514a:	cd bf       	out	0x3d, r28	; 61
   1514c:	df 91       	pop	r29
   1514e:	cf 91       	pop	r28
   15150:	08 95       	ret

00015152 <_ZN8SPIClass8transferEh>:
  static void setClockDivider(uint8_t);
};

extern SPIClass SPI;

byte SPIClass::transfer(byte _data) {
   15152:	cf 93       	push	r28
   15154:	df 93       	push	r29
   15156:	1f 92       	push	r1
   15158:	cd b7       	in	r28, 0x3d	; 61
   1515a:	de b7       	in	r29, 0x3e	; 62
   1515c:	89 83       	std	Y+1, r24	; 0x01
  SPDR = _data;
   1515e:	8e e4       	ldi	r24, 0x4E	; 78
   15160:	90 e0       	ldi	r25, 0x00	; 0
   15162:	29 81       	ldd	r18, Y+1	; 0x01
   15164:	fc 01       	movw	r30, r24
   15166:	20 83       	st	Z, r18
  while (!(SPSR & _BV(SPIF)))
   15168:	00 00       	nop
   1516a:	8d e4       	ldi	r24, 0x4D	; 77
   1516c:	90 e0       	ldi	r25, 0x00	; 0
   1516e:	fc 01       	movw	r30, r24
   15170:	80 81       	ld	r24, Z
   15172:	80 95       	com	r24
   15174:	88 1f       	adc	r24, r24
   15176:	88 27       	eor	r24, r24
   15178:	88 1f       	adc	r24, r24
   1517a:	88 23       	and	r24, r24
   1517c:	b1 f7       	brne	.-20     	; 0x1516a <_ZN8SPIClass8transferEh+0x18>
    ;
  return SPDR;
   1517e:	8e e4       	ldi	r24, 0x4E	; 78
   15180:	90 e0       	ldi	r25, 0x00	; 0
   15182:	fc 01       	movw	r30, r24
   15184:	80 81       	ld	r24, Z
}
   15186:	0f 90       	pop	r0
   15188:	df 91       	pop	r29
   1518a:	cf 91       	pop	r28
   1518c:	08 95       	ret

0001518e <_ZN10W5100Class7writeMREh>:
  static uint16_t read##name(uint8_t *_buff) {    \
    return read(address, _buff, size);            \
  }

public:
  __GP_REGISTER8 (MR,     0x0000);    // Mode
   1518e:	cf 93       	push	r28
   15190:	df 93       	push	r29
   15192:	1f 92       	push	r1
   15194:	cd b7       	in	r28, 0x3d	; 61
   15196:	de b7       	in	r29, 0x3e	; 62
   15198:	89 83       	std	Y+1, r24	; 0x01
   1519a:	69 81       	ldd	r22, Y+1	; 0x01
   1519c:	80 e0       	ldi	r24, 0x00	; 0
   1519e:	90 e0       	ldi	r25, 0x00	; 0
   151a0:	0e 94 52 36 	call	0x6ca4	; 0x6ca4 <_ZN10W5100Class5writeEjh>
   151a4:	0f 90       	pop	r0
   151a6:	df 91       	pop	r29
   151a8:	cf 91       	pop	r28
   151aa:	08 95       	ret

000151ac <_ZN10W5100Class9writeRMSREh>:
  __GP_REGISTER_N(SIPR,   0x000F, 4); // Source IP address
  __GP_REGISTER8 (IR,     0x0015);    // Interrupt
  __GP_REGISTER8 (IMR,    0x0016);    // Interrupt Mask
  __GP_REGISTER16(RTR,    0x0017);    // Timeout address
  __GP_REGISTER8 (RCR,    0x0019);    // Retry count
  __GP_REGISTER8 (RMSR,   0x001A);    // Receive memory size
   151ac:	cf 93       	push	r28
   151ae:	df 93       	push	r29
   151b0:	1f 92       	push	r1
   151b2:	cd b7       	in	r28, 0x3d	; 61
   151b4:	de b7       	in	r29, 0x3e	; 62
   151b6:	89 83       	std	Y+1, r24	; 0x01
   151b8:	69 81       	ldd	r22, Y+1	; 0x01
   151ba:	8a e1       	ldi	r24, 0x1A	; 26
   151bc:	90 e0       	ldi	r25, 0x00	; 0
   151be:	0e 94 52 36 	call	0x6ca4	; 0x6ca4 <_ZN10W5100Class5writeEjh>
   151c2:	0f 90       	pop	r0
   151c4:	df 91       	pop	r29
   151c6:	cf 91       	pop	r28
   151c8:	08 95       	ret

000151ca <_ZN10W5100Class9writeTMSREh>:
  __GP_REGISTER8 (TMSR,   0x001B);    // Transmit memory size
   151ca:	cf 93       	push	r28
   151cc:	df 93       	push	r29
   151ce:	1f 92       	push	r1
   151d0:	cd b7       	in	r28, 0x3d	; 61
   151d2:	de b7       	in	r29, 0x3e	; 62
   151d4:	89 83       	std	Y+1, r24	; 0x01
   151d6:	69 81       	ldd	r22, Y+1	; 0x01
   151d8:	8b e1       	ldi	r24, 0x1B	; 27
   151da:	90 e0       	ldi	r25, 0x00	; 0
   151dc:	0e 94 52 36 	call	0x6ca4	; 0x6ca4 <_ZN10W5100Class5writeEjh>
   151e0:	0f 90       	pop	r0
   151e2:	df 91       	pop	r29
   151e4:	cf 91       	pop	r28
   151e6:	08 95       	ret

000151e8 <_ZN10W5100Class9writeSnCREhh>:
    return readSn(_s, address, _buff, size);                 \
  }
  
public:
  __SOCKET_REGISTER8(SnMR,        0x0000)        // Mode
  __SOCKET_REGISTER8(SnCR,        0x0001)        // Command
   151e8:	cf 93       	push	r28
   151ea:	df 93       	push	r29
   151ec:	00 d0       	rcall	.+0      	; 0x151ee <_ZN10W5100Class9writeSnCREhh+0x6>
   151ee:	cd b7       	in	r28, 0x3d	; 61
   151f0:	de b7       	in	r29, 0x3e	; 62
   151f2:	89 83       	std	Y+1, r24	; 0x01
   151f4:	6a 83       	std	Y+2, r22	; 0x02
   151f6:	4a 81       	ldd	r20, Y+2	; 0x02
   151f8:	61 e0       	ldi	r22, 0x01	; 1
   151fa:	70 e0       	ldi	r23, 0x00	; 0
   151fc:	89 81       	ldd	r24, Y+1	; 0x01
   151fe:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   15202:	0f 90       	pop	r0
   15204:	0f 90       	pop	r0
   15206:	df 91       	pop	r29
   15208:	cf 91       	pop	r28
   1520a:	08 95       	ret

0001520c <_ZN10W5100Class8readSnCREh>:
   1520c:	cf 93       	push	r28
   1520e:	df 93       	push	r29
   15210:	1f 92       	push	r1
   15212:	cd b7       	in	r28, 0x3d	; 61
   15214:	de b7       	in	r29, 0x3e	; 62
   15216:	89 83       	std	Y+1, r24	; 0x01
   15218:	61 e0       	ldi	r22, 0x01	; 1
   1521a:	70 e0       	ldi	r23, 0x00	; 0
   1521c:	89 81       	ldd	r24, Y+1	; 0x01
   1521e:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   15222:	0f 90       	pop	r0
   15224:	df 91       	pop	r29
   15226:	cf 91       	pop	r28
   15228:	08 95       	ret

0001522a <_ZN10W5100Class12readSnTX_FSREh>:
  __SOCKET_REGISTER16(SnDPORT,    0x0010)        // Destination Port
  __SOCKET_REGISTER16(SnMSSR,     0x0012)        // Max Segment Size
  __SOCKET_REGISTER8(SnPROTO,     0x0014)        // Protocol in IP RAW Mode
  __SOCKET_REGISTER8(SnTOS,       0x0015)        // IP TOS
  __SOCKET_REGISTER8(SnTTL,       0x0016)        // IP TTL
  __SOCKET_REGISTER16(SnTX_FSR,   0x0020)        // TX Free Size
   1522a:	cf 93       	push	r28
   1522c:	df 93       	push	r29
   1522e:	00 d0       	rcall	.+0      	; 0x15230 <_ZN10W5100Class12readSnTX_FSREh+0x6>
   15230:	00 d0       	rcall	.+0      	; 0x15232 <_ZN10W5100Class12readSnTX_FSREh+0x8>
   15232:	1f 92       	push	r1
   15234:	cd b7       	in	r28, 0x3d	; 61
   15236:	de b7       	in	r29, 0x3e	; 62
   15238:	8d 83       	std	Y+5, r24	; 0x05
   1523a:	60 e2       	ldi	r22, 0x20	; 32
   1523c:	70 e0       	ldi	r23, 0x00	; 0
   1523e:	8d 81       	ldd	r24, Y+5	; 0x05
   15240:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   15244:	88 2f       	mov	r24, r24
   15246:	90 e0       	ldi	r25, 0x00	; 0
   15248:	9a 83       	std	Y+2, r25	; 0x02
   1524a:	89 83       	std	Y+1, r24	; 0x01
   1524c:	61 e2       	ldi	r22, 0x21	; 33
   1524e:	70 e0       	ldi	r23, 0x00	; 0
   15250:	8d 81       	ldd	r24, Y+5	; 0x05
   15252:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   15256:	88 2f       	mov	r24, r24
   15258:	90 e0       	ldi	r25, 0x00	; 0
   1525a:	9c 83       	std	Y+4, r25	; 0x04
   1525c:	8b 83       	std	Y+3, r24	; 0x03
   1525e:	89 81       	ldd	r24, Y+1	; 0x01
   15260:	9a 81       	ldd	r25, Y+2	; 0x02
   15262:	98 2f       	mov	r25, r24
   15264:	88 27       	eor	r24, r24
   15266:	9a 83       	std	Y+2, r25	; 0x02
   15268:	89 83       	std	Y+1, r24	; 0x01
   1526a:	8b 81       	ldd	r24, Y+3	; 0x03
   1526c:	9c 81       	ldd	r25, Y+4	; 0x04
   1526e:	99 27       	eor	r25, r25
   15270:	9c 83       	std	Y+4, r25	; 0x04
   15272:	8b 83       	std	Y+3, r24	; 0x03
   15274:	29 81       	ldd	r18, Y+1	; 0x01
   15276:	3a 81       	ldd	r19, Y+2	; 0x02
   15278:	8b 81       	ldd	r24, Y+3	; 0x03
   1527a:	9c 81       	ldd	r25, Y+4	; 0x04
   1527c:	82 2b       	or	r24, r18
   1527e:	93 2b       	or	r25, r19
   15280:	9a 83       	std	Y+2, r25	; 0x02
   15282:	89 83       	std	Y+1, r24	; 0x01
   15284:	89 81       	ldd	r24, Y+1	; 0x01
   15286:	9a 81       	ldd	r25, Y+2	; 0x02
   15288:	0f 90       	pop	r0
   1528a:	0f 90       	pop	r0
   1528c:	0f 90       	pop	r0
   1528e:	0f 90       	pop	r0
   15290:	0f 90       	pop	r0
   15292:	df 91       	pop	r29
   15294:	cf 91       	pop	r28
   15296:	08 95       	ret

00015298 <_ZN10W5100Class12writeSnTX_WREhj>:
  __SOCKET_REGISTER16(SnTX_RD,    0x0022)        // TX Read Pointer
  __SOCKET_REGISTER16(SnTX_WR,    0x0024)        // TX Write Pointer
   15298:	cf 93       	push	r28
   1529a:	df 93       	push	r29
   1529c:	00 d0       	rcall	.+0      	; 0x1529e <_ZN10W5100Class12writeSnTX_WREhj+0x6>
   1529e:	1f 92       	push	r1
   152a0:	cd b7       	in	r28, 0x3d	; 61
   152a2:	de b7       	in	r29, 0x3e	; 62
   152a4:	89 83       	std	Y+1, r24	; 0x01
   152a6:	7b 83       	std	Y+3, r23	; 0x03
   152a8:	6a 83       	std	Y+2, r22	; 0x02
   152aa:	8a 81       	ldd	r24, Y+2	; 0x02
   152ac:	9b 81       	ldd	r25, Y+3	; 0x03
   152ae:	89 2f       	mov	r24, r25
   152b0:	99 27       	eor	r25, r25
   152b2:	48 2f       	mov	r20, r24
   152b4:	64 e2       	ldi	r22, 0x24	; 36
   152b6:	70 e0       	ldi	r23, 0x00	; 0
   152b8:	89 81       	ldd	r24, Y+1	; 0x01
   152ba:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   152be:	8a 81       	ldd	r24, Y+2	; 0x02
   152c0:	48 2f       	mov	r20, r24
   152c2:	65 e2       	ldi	r22, 0x25	; 37
   152c4:	70 e0       	ldi	r23, 0x00	; 0
   152c6:	89 81       	ldd	r24, Y+1	; 0x01
   152c8:	0e 94 60 a8 	call	0x150c0	; 0x150c0 <_ZN10W5100Class7writeSnEhjh>
   152cc:	0f 90       	pop	r0
   152ce:	0f 90       	pop	r0
   152d0:	0f 90       	pop	r0
   152d2:	df 91       	pop	r29
   152d4:	cf 91       	pop	r28
   152d6:	08 95       	ret

000152d8 <_ZN10W5100Class11readSnTX_WREh>:
   152d8:	cf 93       	push	r28
   152da:	df 93       	push	r29
   152dc:	00 d0       	rcall	.+0      	; 0x152de <_ZN10W5100Class11readSnTX_WREh+0x6>
   152de:	00 d0       	rcall	.+0      	; 0x152e0 <_ZN10W5100Class11readSnTX_WREh+0x8>
   152e0:	1f 92       	push	r1
   152e2:	cd b7       	in	r28, 0x3d	; 61
   152e4:	de b7       	in	r29, 0x3e	; 62
   152e6:	8d 83       	std	Y+5, r24	; 0x05
   152e8:	64 e2       	ldi	r22, 0x24	; 36
   152ea:	70 e0       	ldi	r23, 0x00	; 0
   152ec:	8d 81       	ldd	r24, Y+5	; 0x05
   152ee:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   152f2:	88 2f       	mov	r24, r24
   152f4:	90 e0       	ldi	r25, 0x00	; 0
   152f6:	9a 83       	std	Y+2, r25	; 0x02
   152f8:	89 83       	std	Y+1, r24	; 0x01
   152fa:	65 e2       	ldi	r22, 0x25	; 37
   152fc:	70 e0       	ldi	r23, 0x00	; 0
   152fe:	8d 81       	ldd	r24, Y+5	; 0x05
   15300:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   15304:	88 2f       	mov	r24, r24
   15306:	90 e0       	ldi	r25, 0x00	; 0
   15308:	9c 83       	std	Y+4, r25	; 0x04
   1530a:	8b 83       	std	Y+3, r24	; 0x03
   1530c:	89 81       	ldd	r24, Y+1	; 0x01
   1530e:	9a 81       	ldd	r25, Y+2	; 0x02
   15310:	98 2f       	mov	r25, r24
   15312:	88 27       	eor	r24, r24
   15314:	9a 83       	std	Y+2, r25	; 0x02
   15316:	89 83       	std	Y+1, r24	; 0x01
   15318:	8b 81       	ldd	r24, Y+3	; 0x03
   1531a:	9c 81       	ldd	r25, Y+4	; 0x04
   1531c:	99 27       	eor	r25, r25
   1531e:	9c 83       	std	Y+4, r25	; 0x04
   15320:	8b 83       	std	Y+3, r24	; 0x03
   15322:	29 81       	ldd	r18, Y+1	; 0x01
   15324:	3a 81       	ldd	r19, Y+2	; 0x02
   15326:	8b 81       	ldd	r24, Y+3	; 0x03
   15328:	9c 81       	ldd	r25, Y+4	; 0x04
   1532a:	82 2b       	or	r24, r18
   1532c:	93 2b       	or	r25, r19
   1532e:	9a 83       	std	Y+2, r25	; 0x02
   15330:	89 83       	std	Y+1, r24	; 0x01
   15332:	89 81       	ldd	r24, Y+1	; 0x01
   15334:	9a 81       	ldd	r25, Y+2	; 0x02
   15336:	0f 90       	pop	r0
   15338:	0f 90       	pop	r0
   1533a:	0f 90       	pop	r0
   1533c:	0f 90       	pop	r0
   1533e:	0f 90       	pop	r0
   15340:	df 91       	pop	r29
   15342:	cf 91       	pop	r28
   15344:	08 95       	ret

00015346 <_ZN10W5100Class12readSnRX_RSREh>:
  __SOCKET_REGISTER16(SnRX_RSR,   0x0026)        // RX Free Size
   15346:	cf 93       	push	r28
   15348:	df 93       	push	r29
   1534a:	00 d0       	rcall	.+0      	; 0x1534c <_ZN10W5100Class12readSnRX_RSREh+0x6>
   1534c:	00 d0       	rcall	.+0      	; 0x1534e <_ZN10W5100Class12readSnRX_RSREh+0x8>
   1534e:	1f 92       	push	r1
   15350:	cd b7       	in	r28, 0x3d	; 61
   15352:	de b7       	in	r29, 0x3e	; 62
   15354:	8d 83       	std	Y+5, r24	; 0x05
   15356:	66 e2       	ldi	r22, 0x26	; 38
   15358:	70 e0       	ldi	r23, 0x00	; 0
   1535a:	8d 81       	ldd	r24, Y+5	; 0x05
   1535c:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   15360:	88 2f       	mov	r24, r24
   15362:	90 e0       	ldi	r25, 0x00	; 0
   15364:	9a 83       	std	Y+2, r25	; 0x02
   15366:	89 83       	std	Y+1, r24	; 0x01
   15368:	67 e2       	ldi	r22, 0x27	; 39
   1536a:	70 e0       	ldi	r23, 0x00	; 0
   1536c:	8d 81       	ldd	r24, Y+5	; 0x05
   1536e:	0e 94 45 a8 	call	0x1508a	; 0x1508a <_ZN10W5100Class6readSnEhj>
   15372:	88 2f       	mov	r24, r24
   15374:	90 e0       	ldi	r25, 0x00	; 0
   15376:	9c 83       	std	Y+4, r25	; 0x04
   15378:	8b 83       	std	Y+3, r24	; 0x03
   1537a:	89 81       	ldd	r24, Y+1	; 0x01
   1537c:	9a 81       	ldd	r25, Y+2	; 0x02
   1537e:	98 2f       	mov	r25, r24
   15380:	88 27       	eor	r24, r24
   15382:	9a 83       	std	Y+2, r25	; 0x02
   15384:	89 83       	std	Y+1, r24	; 0x01
   15386:	8b 81       	ldd	r24, Y+3	; 0x03
   15388:	9c 81       	ldd	r25, Y+4	; 0x04
   1538a:	99 27       	eor	r25, r25
   1538c:	9c 83       	std	Y+4, r25	; 0x04
   1538e:	8b 83       	std	Y+3, r24	; 0x03
   15390:	29 81       	ldd	r18, Y+1	; 0x01
   15392:	3a 81       	ldd	r19, Y+2	; 0x02
   15394:	8b 81       	ldd	r24, Y+3	; 0x03
   15396:	9c 81       	ldd	r25, Y+4	; 0x04
   15398:	82 2b       	or	r24, r18
   1539a:	93 2b       	or	r25, r19
   1539c:	9a 83       	std	Y+2, r25	; 0x02
   1539e:	89 83       	std	Y+1, r24	; 0x01
   153a0:	89 81       	ldd	r24, Y+1	; 0x01
   153a2:	9a 81       	ldd	r25, Y+2	; 0x02
   153a4:	0f 90       	pop	r0
   153a6:	0f 90       	pop	r0
   153a8:	0f 90       	pop	r0
   153aa:	0f 90       	pop	r0
   153ac:	0f 90       	pop	r0
   153ae:	df 91       	pop	r29
   153b0:	cf 91       	pop	r28
   153b2:	08 95       	ret

000153b4 <_ZN10W5100Class6initSSEv>:
#elif defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB162__)
  inline static void initSS()    { DDRB  |=  _BV(0); };
  inline static void setSS()     { PORTB &= ~_BV(0); };
  inline static void resetSS()   { PORTB |=  _BV(0); }; 
#else
  inline static void initSS()    { DDRB  |=  _BV(2); };
   153b4:	cf 93       	push	r28
   153b6:	df 93       	push	r29
   153b8:	cd b7       	in	r28, 0x3d	; 61
   153ba:	de b7       	in	r29, 0x3e	; 62
   153bc:	84 e2       	ldi	r24, 0x24	; 36
   153be:	90 e0       	ldi	r25, 0x00	; 0
   153c0:	24 e2       	ldi	r18, 0x24	; 36
   153c2:	30 e0       	ldi	r19, 0x00	; 0
   153c4:	f9 01       	movw	r30, r18
   153c6:	20 81       	ld	r18, Z
   153c8:	24 60       	ori	r18, 0x04	; 4
   153ca:	fc 01       	movw	r30, r24
   153cc:	20 83       	st	Z, r18
   153ce:	df 91       	pop	r29
   153d0:	cf 91       	pop	r28
   153d2:	08 95       	ret

000153d4 <_ZN10W5100Class5setSSEv>:
  inline static void setSS()     { PORTB &= ~_BV(2); };
   153d4:	cf 93       	push	r28
   153d6:	df 93       	push	r29
   153d8:	cd b7       	in	r28, 0x3d	; 61
   153da:	de b7       	in	r29, 0x3e	; 62
   153dc:	85 e2       	ldi	r24, 0x25	; 37
   153de:	90 e0       	ldi	r25, 0x00	; 0
   153e0:	25 e2       	ldi	r18, 0x25	; 37
   153e2:	30 e0       	ldi	r19, 0x00	; 0
   153e4:	f9 01       	movw	r30, r18
   153e6:	20 81       	ld	r18, Z
   153e8:	2b 7f       	andi	r18, 0xFB	; 251
   153ea:	fc 01       	movw	r30, r24
   153ec:	20 83       	st	Z, r18
   153ee:	df 91       	pop	r29
   153f0:	cf 91       	pop	r28
   153f2:	08 95       	ret

000153f4 <_ZN10W5100Class7resetSSEv>:
  inline static void resetSS()   { PORTB |=  _BV(2); };
   153f4:	cf 93       	push	r28
   153f6:	df 93       	push	r29
   153f8:	cd b7       	in	r28, 0x3d	; 61
   153fa:	de b7       	in	r29, 0x3e	; 62
   153fc:	85 e2       	ldi	r24, 0x25	; 37
   153fe:	90 e0       	ldi	r25, 0x00	; 0
   15400:	25 e2       	ldi	r18, 0x25	; 37
   15402:	30 e0       	ldi	r19, 0x00	; 0
   15404:	f9 01       	movw	r30, r18
   15406:	20 81       	ld	r18, Z
   15408:	24 60       	ori	r18, 0x04	; 4
   1540a:	fc 01       	movw	r30, r24
   1540c:	20 83       	st	Z, r18
   1540e:	df 91       	pop	r29
   15410:	cf 91       	pop	r28
   15412:	08 95       	ret

00015414 <_ZN9IPAddresseqERKS_>:
    bool operator==(const IPAddress& addr) { return (*((uint32_t*)_address)) == (*((uint32_t*)addr._address)); };
   15414:	cf 93       	push	r28
   15416:	df 93       	push	r29
   15418:	00 d0       	rcall	.+0      	; 0x1541a <_ZN9IPAddresseqERKS_+0x6>
   1541a:	00 d0       	rcall	.+0      	; 0x1541c <_ZN9IPAddresseqERKS_+0x8>
   1541c:	cd b7       	in	r28, 0x3d	; 61
   1541e:	de b7       	in	r29, 0x3e	; 62
   15420:	9a 83       	std	Y+2, r25	; 0x02
   15422:	89 83       	std	Y+1, r24	; 0x01
   15424:	7c 83       	std	Y+4, r23	; 0x04
   15426:	6b 83       	std	Y+3, r22	; 0x03
   15428:	89 81       	ldd	r24, Y+1	; 0x01
   1542a:	9a 81       	ldd	r25, Y+2	; 0x02
   1542c:	02 96       	adiw	r24, 0x02	; 2
   1542e:	fc 01       	movw	r30, r24
   15430:	20 81       	ld	r18, Z
   15432:	31 81       	ldd	r19, Z+1	; 0x01
   15434:	42 81       	ldd	r20, Z+2	; 0x02
   15436:	53 81       	ldd	r21, Z+3	; 0x03
   15438:	8b 81       	ldd	r24, Y+3	; 0x03
   1543a:	9c 81       	ldd	r25, Y+4	; 0x04
   1543c:	02 96       	adiw	r24, 0x02	; 2
   1543e:	fc 01       	movw	r30, r24
   15440:	80 81       	ld	r24, Z
   15442:	91 81       	ldd	r25, Z+1	; 0x01
   15444:	a2 81       	ldd	r26, Z+2	; 0x02
   15446:	b3 81       	ldd	r27, Z+3	; 0x03
   15448:	61 e0       	ldi	r22, 0x01	; 1
   1544a:	28 17       	cp	r18, r24
   1544c:	39 07       	cpc	r19, r25
   1544e:	4a 07       	cpc	r20, r26
   15450:	5b 07       	cpc	r21, r27
   15452:	09 f0       	breq	.+2      	; 0x15456 <_ZN9IPAddresseqERKS_+0x42>
   15454:	60 e0       	ldi	r22, 0x00	; 0
   15456:	86 2f       	mov	r24, r22
   15458:	0f 90       	pop	r0
   1545a:	0f 90       	pop	r0
   1545c:	0f 90       	pop	r0
   1545e:	0f 90       	pop	r0
   15460:	df 91       	pop	r29
   15462:	cf 91       	pop	r28
   15464:	08 95       	ret

00015466 <_ZN11EthernetUDP8remoteIPEv>:
  // Return the next byte from the current packet without moving on to the next byte
  virtual int peek();
  virtual void flush();	// Finish reading the current packet

  // Return the IP address of the host who sent the current incoming packet
  virtual IPAddress remoteIP() { return _remoteIP; };
   15466:	cf 93       	push	r28
   15468:	df 93       	push	r29
   1546a:	00 d0       	rcall	.+0      	; 0x1546c <_ZN11EthernetUDP8remoteIPEv+0x6>
   1546c:	00 d0       	rcall	.+0      	; 0x1546e <_ZN11EthernetUDP8remoteIPEv+0x8>
   1546e:	cd b7       	in	r28, 0x3d	; 61
   15470:	de b7       	in	r29, 0x3e	; 62
   15472:	9a 83       	std	Y+2, r25	; 0x02
   15474:	89 83       	std	Y+1, r24	; 0x01
   15476:	7c 83       	std	Y+4, r23	; 0x04
   15478:	6b 83       	std	Y+3, r22	; 0x03
   1547a:	8b 81       	ldd	r24, Y+3	; 0x03
   1547c:	9c 81       	ldd	r25, Y+4	; 0x04
   1547e:	9c 01       	movw	r18, r24
   15480:	21 5f       	subi	r18, 0xF1	; 241
   15482:	3f 4f       	sbci	r19, 0xFF	; 255
   15484:	89 81       	ldd	r24, Y+1	; 0x01
   15486:	9a 81       	ldd	r25, Y+2	; 0x02
   15488:	b9 01       	movw	r22, r18
   1548a:	0e 94 00 a6 	call	0x14c00	; 0x14c00 <_ZN9IPAddressC1ERKS_>
   1548e:	89 81       	ldd	r24, Y+1	; 0x01
   15490:	9a 81       	ldd	r25, Y+2	; 0x02
   15492:	0f 90       	pop	r0
   15494:	0f 90       	pop	r0
   15496:	0f 90       	pop	r0
   15498:	0f 90       	pop	r0
   1549a:	df 91       	pop	r29
   1549c:	cf 91       	pop	r28
   1549e:	08 95       	ret

000154a0 <_ZN11EthernetUDP10remotePortEv>:
  // Return the port of the host who sent the current incoming packet
  virtual uint16_t remotePort() { return _remotePort; };
   154a0:	cf 93       	push	r28
   154a2:	df 93       	push	r29
   154a4:	00 d0       	rcall	.+0      	; 0x154a6 <_ZN11EthernetUDP10remotePortEv+0x6>
   154a6:	cd b7       	in	r28, 0x3d	; 61
   154a8:	de b7       	in	r29, 0x3e	; 62
   154aa:	9a 83       	std	Y+2, r25	; 0x02
   154ac:	89 83       	std	Y+1, r24	; 0x01
   154ae:	89 81       	ldd	r24, Y+1	; 0x01
   154b0:	9a 81       	ldd	r25, Y+2	; 0x02
   154b2:	fc 01       	movw	r30, r24
   154b4:	85 89       	ldd	r24, Z+21	; 0x15
   154b6:	96 89       	ldd	r25, Z+22	; 0x16
   154b8:	0f 90       	pop	r0
   154ba:	0f 90       	pop	r0
   154bc:	df 91       	pop	r29
   154be:	cf 91       	pop	r28
   154c0:	08 95       	ret

000154c2 <_ZN9IPAddress11raw_addressEv>:
   154c2:	cf 93       	push	r28
   154c4:	df 93       	push	r29
   154c6:	00 d0       	rcall	.+0      	; 0x154c8 <_ZN9IPAddress11raw_addressEv+0x6>
   154c8:	cd b7       	in	r28, 0x3d	; 61
   154ca:	de b7       	in	r29, 0x3e	; 62
   154cc:	9a 83       	std	Y+2, r25	; 0x02
   154ce:	89 83       	std	Y+1, r24	; 0x01
   154d0:	89 81       	ldd	r24, Y+1	; 0x01
   154d2:	9a 81       	ldd	r25, Y+2	; 0x02
   154d4:	02 96       	adiw	r24, 0x02	; 2
   154d6:	0f 90       	pop	r0
   154d8:	0f 90       	pop	r0
   154da:	df 91       	pop	r29
   154dc:	cf 91       	pop	r28
   154de:	08 95       	ret

000154e0 <_ZN9IPAddressixEi>:
    bool operator==(const uint8_t* addr);

    // Overloaded index operator to allow getting and setting individual octets of the address
    uint8_t operator[](int index) const { return _address[index]; };
    uint8_t& operator[](int index) { return _address[index]; };
   154e0:	cf 93       	push	r28
   154e2:	df 93       	push	r29
   154e4:	00 d0       	rcall	.+0      	; 0x154e6 <_ZN9IPAddressixEi+0x6>
   154e6:	00 d0       	rcall	.+0      	; 0x154e8 <_ZN9IPAddressixEi+0x8>
   154e8:	cd b7       	in	r28, 0x3d	; 61
   154ea:	de b7       	in	r29, 0x3e	; 62
   154ec:	9a 83       	std	Y+2, r25	; 0x02
   154ee:	89 83       	std	Y+1, r24	; 0x01
   154f0:	7c 83       	std	Y+4, r23	; 0x04
   154f2:	6b 83       	std	Y+3, r22	; 0x03
   154f4:	8b 81       	ldd	r24, Y+3	; 0x03
   154f6:	9c 81       	ldd	r25, Y+4	; 0x04
   154f8:	02 96       	adiw	r24, 0x02	; 2
   154fa:	29 81       	ldd	r18, Y+1	; 0x01
   154fc:	3a 81       	ldd	r19, Y+2	; 0x02
   154fe:	82 0f       	add	r24, r18
   15500:	93 1f       	adc	r25, r19
   15502:	0f 90       	pop	r0
   15504:	0f 90       	pop	r0
   15506:	0f 90       	pop	r0
   15508:	0f 90       	pop	r0
   1550a:	df 91       	pop	r29
   1550c:	cf 91       	pop	r28
   1550e:	08 95       	ret

00015510 <_ZN9PrintableaSERKS_>:
   15510:	cf 93       	push	r28
   15512:	df 93       	push	r29
   15514:	00 d0       	rcall	.+0      	; 0x15516 <_ZN9PrintableaSERKS_+0x6>
   15516:	00 d0       	rcall	.+0      	; 0x15518 <_ZN9PrintableaSERKS_+0x8>
   15518:	cd b7       	in	r28, 0x3d	; 61
   1551a:	de b7       	in	r29, 0x3e	; 62
   1551c:	9a 83       	std	Y+2, r25	; 0x02
   1551e:	89 83       	std	Y+1, r24	; 0x01
   15520:	7c 83       	std	Y+4, r23	; 0x04
   15522:	6b 83       	std	Y+3, r22	; 0x03
   15524:	89 81       	ldd	r24, Y+1	; 0x01
   15526:	9a 81       	ldd	r25, Y+2	; 0x02
   15528:	0f 90       	pop	r0
   1552a:	0f 90       	pop	r0
   1552c:	0f 90       	pop	r0
   1552e:	0f 90       	pop	r0
   15530:	df 91       	pop	r29
   15532:	cf 91       	pop	r28
   15534:	08 95       	ret

00015536 <_ZN9IPAddressaSERKS_>:
   15536:	cf 93       	push	r28
   15538:	df 93       	push	r29
   1553a:	00 d0       	rcall	.+0      	; 0x1553c <_ZN9IPAddressaSERKS_+0x6>
   1553c:	00 d0       	rcall	.+0      	; 0x1553e <_ZN9IPAddressaSERKS_+0x8>
   1553e:	cd b7       	in	r28, 0x3d	; 61
   15540:	de b7       	in	r29, 0x3e	; 62
   15542:	9a 83       	std	Y+2, r25	; 0x02
   15544:	89 83       	std	Y+1, r24	; 0x01
   15546:	7c 83       	std	Y+4, r23	; 0x04
   15548:	6b 83       	std	Y+3, r22	; 0x03
   1554a:	2b 81       	ldd	r18, Y+3	; 0x03
   1554c:	3c 81       	ldd	r19, Y+4	; 0x04
   1554e:	89 81       	ldd	r24, Y+1	; 0x01
   15550:	9a 81       	ldd	r25, Y+2	; 0x02
   15552:	b9 01       	movw	r22, r18
   15554:	0e 94 88 aa 	call	0x15510	; 0x15510 <_ZN9PrintableaSERKS_>
   15558:	29 81       	ldd	r18, Y+1	; 0x01
   1555a:	3a 81       	ldd	r19, Y+2	; 0x02
   1555c:	8b 81       	ldd	r24, Y+3	; 0x03
   1555e:	9c 81       	ldd	r25, Y+4	; 0x04
   15560:	fc 01       	movw	r30, r24
   15562:	82 81       	ldd	r24, Z+2	; 0x02
   15564:	93 81       	ldd	r25, Z+3	; 0x03
   15566:	a4 81       	ldd	r26, Z+4	; 0x04
   15568:	b5 81       	ldd	r27, Z+5	; 0x05
   1556a:	f9 01       	movw	r30, r18
   1556c:	82 83       	std	Z+2, r24	; 0x02
   1556e:	93 83       	std	Z+3, r25	; 0x03
   15570:	a4 83       	std	Z+4, r26	; 0x04
   15572:	b5 83       	std	Z+5, r27	; 0x05
   15574:	89 81       	ldd	r24, Y+1	; 0x01
   15576:	9a 81       	ldd	r25, Y+2	; 0x02
   15578:	0f 90       	pop	r0
   1557a:	0f 90       	pop	r0
   1557c:	0f 90       	pop	r0
   1557e:	0f 90       	pop	r0
   15580:	df 91       	pop	r29
   15582:	cf 91       	pop	r28
   15584:	08 95       	ret

00015586 <_ZN10W5100Class8writeGAREPh>:
    return read(address, _buff, size);            \
  }

public:
  __GP_REGISTER8 (MR,     0x0000);    // Mode
  __GP_REGISTER_N(GAR,    0x0001, 4); // Gateway IP address
   15586:	cf 93       	push	r28
   15588:	df 93       	push	r29
   1558a:	00 d0       	rcall	.+0      	; 0x1558c <_ZN10W5100Class8writeGAREPh+0x6>
   1558c:	cd b7       	in	r28, 0x3d	; 61
   1558e:	de b7       	in	r29, 0x3e	; 62
   15590:	9a 83       	std	Y+2, r25	; 0x02
   15592:	89 83       	std	Y+1, r24	; 0x01
   15594:	89 81       	ldd	r24, Y+1	; 0x01
   15596:	9a 81       	ldd	r25, Y+2	; 0x02
   15598:	44 e0       	ldi	r20, 0x04	; 4
   1559a:	50 e0       	ldi	r21, 0x00	; 0
   1559c:	bc 01       	movw	r22, r24
   1559e:	81 e0       	ldi	r24, 0x01	; 1
   155a0:	90 e0       	ldi	r25, 0x00	; 0
   155a2:	0e 94 75 36 	call	0x6cea	; 0x6cea <_ZN10W5100Class5writeEjPKhj>
   155a6:	0f 90       	pop	r0
   155a8:	0f 90       	pop	r0
   155aa:	df 91       	pop	r29
   155ac:	cf 91       	pop	r28
   155ae:	08 95       	ret

000155b0 <_ZN10W5100Class7readGAREPh>:
   155b0:	cf 93       	push	r28
   155b2:	df 93       	push	r29
   155b4:	00 d0       	rcall	.+0      	; 0x155b6 <_ZN10W5100Class7readGAREPh+0x6>
   155b6:	cd b7       	in	r28, 0x3d	; 61
   155b8:	de b7       	in	r29, 0x3e	; 62
   155ba:	9a 83       	std	Y+2, r25	; 0x02
   155bc:	89 83       	std	Y+1, r24	; 0x01
   155be:	89 81       	ldd	r24, Y+1	; 0x01
   155c0:	9a 81       	ldd	r25, Y+2	; 0x02
   155c2:	44 e0       	ldi	r20, 0x04	; 4
   155c4:	50 e0       	ldi	r21, 0x00	; 0
   155c6:	bc 01       	movw	r22, r24
   155c8:	81 e0       	ldi	r24, 0x01	; 1
   155ca:	90 e0       	ldi	r25, 0x00	; 0
   155cc:	0e 94 e5 36 	call	0x6dca	; 0x6dca <_ZN10W5100Class4readEjPhj>
   155d0:	0f 90       	pop	r0
   155d2:	0f 90       	pop	r0
   155d4:	df 91       	pop	r29
   155d6:	cf 91       	pop	r28
   155d8:	08 95       	ret

000155da <_ZN10W5100Class9writeSUBREPh>:
  __GP_REGISTER_N(SUBR,   0x0005, 4); // Subnet mask address
   155da:	cf 93       	push	r28
   155dc:	df 93       	push	r29
   155de:	00 d0       	rcall	.+0      	; 0x155e0 <_ZN10W5100Class9writeSUBREPh+0x6>
   155e0:	cd b7       	in	r28, 0x3d	; 61
   155e2:	de b7       	in	r29, 0x3e	; 62
   155e4:	9a 83       	std	Y+2, r25	; 0x02
   155e6:	89 83       	std	Y+1, r24	; 0x01
   155e8:	89 81       	ldd	r24, Y+1	; 0x01
   155ea:	9a 81       	ldd	r25, Y+2	; 0x02
   155ec:	44 e0       	ldi	r20, 0x04	; 4
   155ee:	50 e0       	ldi	r21, 0x00	; 0
   155f0:	bc 01       	movw	r22, r24
   155f2:	85 e0       	ldi	r24, 0x05	; 5
   155f4:	90 e0       	ldi	r25, 0x00	; 0
   155f6:	0e 94 75 36 	call	0x6cea	; 0x6cea <_ZN10W5100Class5writeEjPKhj>
   155fa:	0f 90       	pop	r0
   155fc:	0f 90       	pop	r0
   155fe:	df 91       	pop	r29
   15600:	cf 91       	pop	r28
   15602:	08 95       	ret

00015604 <_ZN10W5100Class8readSUBREPh>:
   15604:	cf 93       	push	r28
   15606:	df 93       	push	r29
   15608:	00 d0       	rcall	.+0      	; 0x1560a <_ZN10W5100Class8readSUBREPh+0x6>
   1560a:	cd b7       	in	r28, 0x3d	; 61
   1560c:	de b7       	in	r29, 0x3e	; 62
   1560e:	9a 83       	std	Y+2, r25	; 0x02
   15610:	89 83       	std	Y+1, r24	; 0x01
   15612:	89 81       	ldd	r24, Y+1	; 0x01
   15614:	9a 81       	ldd	r25, Y+2	; 0x02
   15616:	44 e0       	ldi	r20, 0x04	; 4
   15618:	50 e0       	ldi	r21, 0x00	; 0
   1561a:	bc 01       	movw	r22, r24
   1561c:	85 e0       	ldi	r24, 0x05	; 5
   1561e:	90 e0       	ldi	r25, 0x00	; 0
   15620:	0e 94 e5 36 	call	0x6dca	; 0x6dca <_ZN10W5100Class4readEjPhj>
   15624:	0f 90       	pop	r0
   15626:	0f 90       	pop	r0
   15628:	df 91       	pop	r29
   1562a:	cf 91       	pop	r28
   1562c:	08 95       	ret

0001562e <_ZN10W5100Class9writeSHAREPh>:
  __GP_REGISTER_N(SHAR,   0x0009, 6); // Source MAC address
   1562e:	cf 93       	push	r28
   15630:	df 93       	push	r29
   15632:	00 d0       	rcall	.+0      	; 0x15634 <_ZN10W5100Class9writeSHAREPh+0x6>
   15634:	cd b7       	in	r28, 0x3d	; 61
   15636:	de b7       	in	r29, 0x3e	; 62
   15638:	9a 83       	std	Y+2, r25	; 0x02
   1563a:	89 83       	std	Y+1, r24	; 0x01
   1563c:	89 81       	ldd	r24, Y+1	; 0x01
   1563e:	9a 81       	ldd	r25, Y+2	; 0x02
   15640:	46 e0       	ldi	r20, 0x06	; 6
   15642:	50 e0       	ldi	r21, 0x00	; 0
   15644:	bc 01       	movw	r22, r24
   15646:	89 e0       	ldi	r24, 0x09	; 9
   15648:	90 e0       	ldi	r25, 0x00	; 0
   1564a:	0e 94 75 36 	call	0x6cea	; 0x6cea <_ZN10W5100Class5writeEjPKhj>
   1564e:	0f 90       	pop	r0
   15650:	0f 90       	pop	r0
   15652:	df 91       	pop	r29
   15654:	cf 91       	pop	r28
   15656:	08 95       	ret

00015658 <_ZN10W5100Class9writeSIPREPh>:
  __GP_REGISTER_N(SIPR,   0x000F, 4); // Source IP address
   15658:	cf 93       	push	r28
   1565a:	df 93       	push	r29
   1565c:	00 d0       	rcall	.+0      	; 0x1565e <_ZN10W5100Class9writeSIPREPh+0x6>
   1565e:	cd b7       	in	r28, 0x3d	; 61
   15660:	de b7       	in	r29, 0x3e	; 62
   15662:	9a 83       	std	Y+2, r25	; 0x02
   15664:	89 83       	std	Y+1, r24	; 0x01
   15666:	89 81       	ldd	r24, Y+1	; 0x01
   15668:	9a 81       	ldd	r25, Y+2	; 0x02
   1566a:	44 e0       	ldi	r20, 0x04	; 4
   1566c:	50 e0       	ldi	r21, 0x00	; 0
   1566e:	bc 01       	movw	r22, r24
   15670:	8f e0       	ldi	r24, 0x0F	; 15
   15672:	90 e0       	ldi	r25, 0x00	; 0
   15674:	0e 94 75 36 	call	0x6cea	; 0x6cea <_ZN10W5100Class5writeEjPKhj>
   15678:	0f 90       	pop	r0
   1567a:	0f 90       	pop	r0
   1567c:	df 91       	pop	r29
   1567e:	cf 91       	pop	r28
   15680:	08 95       	ret

00015682 <_ZN10W5100Class8readSIPREPh>:
   15682:	cf 93       	push	r28
   15684:	df 93       	push	r29
   15686:	00 d0       	rcall	.+0      	; 0x15688 <_ZN10W5100Class8readSIPREPh+0x6>
   15688:	cd b7       	in	r28, 0x3d	; 61
   1568a:	de b7       	in	r29, 0x3e	; 62
   1568c:	9a 83       	std	Y+2, r25	; 0x02
   1568e:	89 83       	std	Y+1, r24	; 0x01
   15690:	89 81       	ldd	r24, Y+1	; 0x01
   15692:	9a 81       	ldd	r25, Y+2	; 0x02
   15694:	44 e0       	ldi	r20, 0x04	; 4
   15696:	50 e0       	ldi	r21, 0x00	; 0
   15698:	bc 01       	movw	r22, r24
   1569a:	8f e0       	ldi	r24, 0x0F	; 15
   1569c:	90 e0       	ldi	r25, 0x00	; 0
   1569e:	0e 94 e5 36 	call	0x6dca	; 0x6dca <_ZN10W5100Class4readEjPhj>
   156a2:	0f 90       	pop	r0
   156a4:	0f 90       	pop	r0
   156a6:	df 91       	pop	r29
   156a8:	cf 91       	pop	r28
   156aa:	08 95       	ret

000156ac <_ZN10W5100Class12getGatewayIpEPh>:

uint16_t W5100Class::writeSn(SOCKET _s, uint16_t _addr, uint8_t *_buf, uint16_t _len) {
  return write(CH_BASE + _s * CH_SIZE + _addr, _buf, _len);
}

void W5100Class::getGatewayIp(uint8_t *_addr) {
   156ac:	cf 93       	push	r28
   156ae:	df 93       	push	r29
   156b0:	00 d0       	rcall	.+0      	; 0x156b2 <_ZN10W5100Class12getGatewayIpEPh+0x6>
   156b2:	00 d0       	rcall	.+0      	; 0x156b4 <_ZN10W5100Class12getGatewayIpEPh+0x8>
   156b4:	cd b7       	in	r28, 0x3d	; 61
   156b6:	de b7       	in	r29, 0x3e	; 62
   156b8:	9a 83       	std	Y+2, r25	; 0x02
   156ba:	89 83       	std	Y+1, r24	; 0x01
   156bc:	7c 83       	std	Y+4, r23	; 0x04
   156be:	6b 83       	std	Y+3, r22	; 0x03
  readGAR(_addr);
   156c0:	8b 81       	ldd	r24, Y+3	; 0x03
   156c2:	9c 81       	ldd	r25, Y+4	; 0x04
   156c4:	0e 94 d8 aa 	call	0x155b0	; 0x155b0 <_ZN10W5100Class7readGAREPh>
}
   156c8:	0f 90       	pop	r0
   156ca:	0f 90       	pop	r0
   156cc:	0f 90       	pop	r0
   156ce:	0f 90       	pop	r0
   156d0:	df 91       	pop	r29
   156d2:	cf 91       	pop	r28
   156d4:	08 95       	ret

000156d6 <_ZN10W5100Class12setGatewayIpEPh>:

void W5100Class::setGatewayIp(uint8_t *_addr) {
   156d6:	cf 93       	push	r28
   156d8:	df 93       	push	r29
   156da:	00 d0       	rcall	.+0      	; 0x156dc <_ZN10W5100Class12setGatewayIpEPh+0x6>
   156dc:	00 d0       	rcall	.+0      	; 0x156de <_ZN10W5100Class12setGatewayIpEPh+0x8>
   156de:	cd b7       	in	r28, 0x3d	; 61
   156e0:	de b7       	in	r29, 0x3e	; 62
   156e2:	9a 83       	std	Y+2, r25	; 0x02
   156e4:	89 83       	std	Y+1, r24	; 0x01
   156e6:	7c 83       	std	Y+4, r23	; 0x04
   156e8:	6b 83       	std	Y+3, r22	; 0x03
  writeGAR(_addr);
   156ea:	8b 81       	ldd	r24, Y+3	; 0x03
   156ec:	9c 81       	ldd	r25, Y+4	; 0x04
   156ee:	0e 94 c3 aa 	call	0x15586	; 0x15586 <_ZN10W5100Class8writeGAREPh>
}
   156f2:	0f 90       	pop	r0
   156f4:	0f 90       	pop	r0
   156f6:	0f 90       	pop	r0
   156f8:	0f 90       	pop	r0
   156fa:	df 91       	pop	r29
   156fc:	cf 91       	pop	r28
   156fe:	08 95       	ret

00015700 <_ZN10W5100Class13getSubnetMaskEPh>:

void W5100Class::getSubnetMask(uint8_t *_addr) {
   15700:	cf 93       	push	r28
   15702:	df 93       	push	r29
   15704:	00 d0       	rcall	.+0      	; 0x15706 <_ZN10W5100Class13getSubnetMaskEPh+0x6>
   15706:	00 d0       	rcall	.+0      	; 0x15708 <_ZN10W5100Class13getSubnetMaskEPh+0x8>
   15708:	cd b7       	in	r28, 0x3d	; 61
   1570a:	de b7       	in	r29, 0x3e	; 62
   1570c:	9a 83       	std	Y+2, r25	; 0x02
   1570e:	89 83       	std	Y+1, r24	; 0x01
   15710:	7c 83       	std	Y+4, r23	; 0x04
   15712:	6b 83       	std	Y+3, r22	; 0x03
  readSUBR(_addr);
   15714:	8b 81       	ldd	r24, Y+3	; 0x03
   15716:	9c 81       	ldd	r25, Y+4	; 0x04
   15718:	0e 94 02 ab 	call	0x15604	; 0x15604 <_ZN10W5100Class8readSUBREPh>
}
   1571c:	0f 90       	pop	r0
   1571e:	0f 90       	pop	r0
   15720:	0f 90       	pop	r0
   15722:	0f 90       	pop	r0
   15724:	df 91       	pop	r29
   15726:	cf 91       	pop	r28
   15728:	08 95       	ret

0001572a <_ZN10W5100Class13setSubnetMaskEPh>:

void W5100Class::setSubnetMask(uint8_t *_addr) {
   1572a:	cf 93       	push	r28
   1572c:	df 93       	push	r29
   1572e:	00 d0       	rcall	.+0      	; 0x15730 <_ZN10W5100Class13setSubnetMaskEPh+0x6>
   15730:	00 d0       	rcall	.+0      	; 0x15732 <_ZN10W5100Class13setSubnetMaskEPh+0x8>
   15732:	cd b7       	in	r28, 0x3d	; 61
   15734:	de b7       	in	r29, 0x3e	; 62
   15736:	9a 83       	std	Y+2, r25	; 0x02
   15738:	89 83       	std	Y+1, r24	; 0x01
   1573a:	7c 83       	std	Y+4, r23	; 0x04
   1573c:	6b 83       	std	Y+3, r22	; 0x03
  writeSUBR(_addr);
   1573e:	8b 81       	ldd	r24, Y+3	; 0x03
   15740:	9c 81       	ldd	r25, Y+4	; 0x04
   15742:	0e 94 ed aa 	call	0x155da	; 0x155da <_ZN10W5100Class9writeSUBREPh>
}
   15746:	0f 90       	pop	r0
   15748:	0f 90       	pop	r0
   1574a:	0f 90       	pop	r0
   1574c:	0f 90       	pop	r0
   1574e:	df 91       	pop	r29
   15750:	cf 91       	pop	r28
   15752:	08 95       	ret

00015754 <_ZN10W5100Class13setMACAddressEPh>:

void W5100Class::getMACAddress(uint8_t *_addr) {
  readSHAR(_addr);
}

void W5100Class::setMACAddress(uint8_t *_addr) {
   15754:	cf 93       	push	r28
   15756:	df 93       	push	r29
   15758:	00 d0       	rcall	.+0      	; 0x1575a <_ZN10W5100Class13setMACAddressEPh+0x6>
   1575a:	00 d0       	rcall	.+0      	; 0x1575c <_ZN10W5100Class13setMACAddressEPh+0x8>
   1575c:	cd b7       	in	r28, 0x3d	; 61
   1575e:	de b7       	in	r29, 0x3e	; 62
   15760:	9a 83       	std	Y+2, r25	; 0x02
   15762:	89 83       	std	Y+1, r24	; 0x01
   15764:	7c 83       	std	Y+4, r23	; 0x04
   15766:	6b 83       	std	Y+3, r22	; 0x03
  writeSHAR(_addr);
   15768:	8b 81       	ldd	r24, Y+3	; 0x03
   1576a:	9c 81       	ldd	r25, Y+4	; 0x04
   1576c:	0e 94 17 ab 	call	0x1562e	; 0x1562e <_ZN10W5100Class9writeSHAREPh>
}
   15770:	0f 90       	pop	r0
   15772:	0f 90       	pop	r0
   15774:	0f 90       	pop	r0
   15776:	0f 90       	pop	r0
   15778:	df 91       	pop	r29
   1577a:	cf 91       	pop	r28
   1577c:	08 95       	ret

0001577e <_ZN10W5100Class12getIPAddressEPh>:

void W5100Class::getIPAddress(uint8_t *_addr) {
   1577e:	cf 93       	push	r28
   15780:	df 93       	push	r29
   15782:	00 d0       	rcall	.+0      	; 0x15784 <_ZN10W5100Class12getIPAddressEPh+0x6>
   15784:	00 d0       	rcall	.+0      	; 0x15786 <_ZN10W5100Class12getIPAddressEPh+0x8>
   15786:	cd b7       	in	r28, 0x3d	; 61
   15788:	de b7       	in	r29, 0x3e	; 62
   1578a:	9a 83       	std	Y+2, r25	; 0x02
   1578c:	89 83       	std	Y+1, r24	; 0x01
   1578e:	7c 83       	std	Y+4, r23	; 0x04
   15790:	6b 83       	std	Y+3, r22	; 0x03
  readSIPR(_addr);
   15792:	8b 81       	ldd	r24, Y+3	; 0x03
   15794:	9c 81       	ldd	r25, Y+4	; 0x04
   15796:	0e 94 41 ab 	call	0x15682	; 0x15682 <_ZN10W5100Class8readSIPREPh>
}
   1579a:	0f 90       	pop	r0
   1579c:	0f 90       	pop	r0
   1579e:	0f 90       	pop	r0
   157a0:	0f 90       	pop	r0
   157a2:	df 91       	pop	r29
   157a4:	cf 91       	pop	r28
   157a6:	08 95       	ret

000157a8 <_ZN10W5100Class12setIPAddressEPh>:

void W5100Class::setIPAddress(uint8_t *_addr) {
   157a8:	cf 93       	push	r28
   157aa:	df 93       	push	r29
   157ac:	00 d0       	rcall	.+0      	; 0x157ae <_ZN10W5100Class12setIPAddressEPh+0x6>
   157ae:	00 d0       	rcall	.+0      	; 0x157b0 <_ZN10W5100Class12setIPAddressEPh+0x8>
   157b0:	cd b7       	in	r28, 0x3d	; 61
   157b2:	de b7       	in	r29, 0x3e	; 62
   157b4:	9a 83       	std	Y+2, r25	; 0x02
   157b6:	89 83       	std	Y+1, r24	; 0x01
   157b8:	7c 83       	std	Y+4, r23	; 0x04
   157ba:	6b 83       	std	Y+3, r22	; 0x03
  writeSIPR(_addr);
   157bc:	8b 81       	ldd	r24, Y+3	; 0x03
   157be:	9c 81       	ldd	r25, Y+4	; 0x04
   157c0:	0e 94 2c ab 	call	0x15658	; 0x15658 <_ZN10W5100Class9writeSIPREPh>
}
   157c4:	0f 90       	pop	r0
   157c6:	0f 90       	pop	r0
   157c8:	0f 90       	pop	r0
   157ca:	0f 90       	pop	r0
   157cc:	df 91       	pop	r29
   157ce:	cf 91       	pop	r28
   157d0:	08 95       	ret

000157d2 <_ZN9DhcpClassC1Ev>:
	uint8_t  siaddr[4];
	uint8_t  giaddr[4];
	uint8_t  chaddr[6];
}RIP_MSG_FIXED;

class DhcpClass {
   157d2:	cf 93       	push	r28
   157d4:	df 93       	push	r29
   157d6:	00 d0       	rcall	.+0      	; 0x157d8 <_ZN9DhcpClassC1Ev+0x6>
   157d8:	cd b7       	in	r28, 0x3d	; 61
   157da:	de b7       	in	r29, 0x3e	; 62
   157dc:	9a 83       	std	Y+2, r25	; 0x02
   157de:	89 83       	std	Y+1, r24	; 0x01
   157e0:	89 81       	ldd	r24, Y+1	; 0x01
   157e2:	9a 81       	ldd	r25, Y+2	; 0x02
   157e4:	89 5b       	subi	r24, 0xB9	; 185
   157e6:	9f 4f       	sbci	r25, 0xFF	; 255
   157e8:	0e 94 d5 4f 	call	0x9faa	; 0x9faa <_ZN11EthernetUDPC1Ev>
   157ec:	0f 90       	pop	r0
   157ee:	0f 90       	pop	r0
   157f0:	df 91       	pop	r29
   157f2:	cf 91       	pop	r28
   157f4:	08 95       	ret

000157f6 <_ZN13EthernetClassC1Ev>:
#include "EthernetServer.h"
#include "Dhcp.h"

#define MAX_SOCK_NUM 4

class EthernetClass {
   157f6:	cf 93       	push	r28
   157f8:	df 93       	push	r29
   157fa:	00 d0       	rcall	.+0      	; 0x157fc <_ZN13EthernetClassC1Ev+0x6>
   157fc:	cd b7       	in	r28, 0x3d	; 61
   157fe:	de b7       	in	r29, 0x3e	; 62
   15800:	9a 83       	std	Y+2, r25	; 0x02
   15802:	89 83       	std	Y+1, r24	; 0x01
   15804:	89 81       	ldd	r24, Y+1	; 0x01
   15806:	9a 81       	ldd	r25, Y+2	; 0x02
   15808:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>
   1580c:	0f 90       	pop	r0
   1580e:	0f 90       	pop	r0
   15810:	df 91       	pop	r29
   15812:	cf 91       	pop	r28
   15814:	08 95       	ret

00015816 <_ZN6Client12rawIPAddressER9IPAddress>:
  virtual void flush() = 0;
  virtual void stop() = 0;
  virtual uint8_t connected() = 0;
  virtual operator bool() = 0;
protected:
  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
   15816:	cf 93       	push	r28
   15818:	df 93       	push	r29
   1581a:	00 d0       	rcall	.+0      	; 0x1581c <_ZN6Client12rawIPAddressER9IPAddress+0x6>
   1581c:	00 d0       	rcall	.+0      	; 0x1581e <_ZN6Client12rawIPAddressER9IPAddress+0x8>
   1581e:	cd b7       	in	r28, 0x3d	; 61
   15820:	de b7       	in	r29, 0x3e	; 62
   15822:	9a 83       	std	Y+2, r25	; 0x02
   15824:	89 83       	std	Y+1, r24	; 0x01
   15826:	7c 83       	std	Y+4, r23	; 0x04
   15828:	6b 83       	std	Y+3, r22	; 0x03
   1582a:	8b 81       	ldd	r24, Y+3	; 0x03
   1582c:	9c 81       	ldd	r25, Y+4	; 0x04
   1582e:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
   15832:	0f 90       	pop	r0
   15834:	0f 90       	pop	r0
   15836:	0f 90       	pop	r0
   15838:	0f 90       	pop	r0
   1583a:	df 91       	pop	r29
   1583c:	cf 91       	pop	r28
   1583e:	08 95       	ret

00015840 <_ZN9DNSClientC1Ev>:
#include <EthernetUdp.h>
#else
#include <Ethernet/EthernetUdp.h>
#endif

class DNSClient
   15840:	cf 93       	push	r28
   15842:	df 93       	push	r29
   15844:	00 d0       	rcall	.+0      	; 0x15846 <_ZN9DNSClientC1Ev+0x6>
   15846:	cd b7       	in	r28, 0x3d	; 61
   15848:	de b7       	in	r29, 0x3e	; 62
   1584a:	9a 83       	std	Y+2, r25	; 0x02
   1584c:	89 83       	std	Y+1, r24	; 0x01
   1584e:	89 81       	ldd	r24, Y+1	; 0x01
   15850:	9a 81       	ldd	r25, Y+2	; 0x02
   15852:	0e 94 89 59 	call	0xb312	; 0xb312 <_ZN9IPAddressC1Ev>
   15856:	89 81       	ldd	r24, Y+1	; 0x01
   15858:	9a 81       	ldd	r25, Y+2	; 0x02
   1585a:	08 96       	adiw	r24, 0x08	; 8
   1585c:	0e 94 d5 4f 	call	0x9faa	; 0x9faa <_ZN11EthernetUDPC1Ev>
   15860:	0f 90       	pop	r0
   15862:	0f 90       	pop	r0
   15864:	df 91       	pop	r29
   15866:	cf 91       	pop	r28
   15868:	08 95       	ret

0001586a <_ZN14EthernetClientC1ERKS_>:
#include "Arduino.h"	
#include "Print.h"
#include "Client.h"
#include "IPAddress.h"

class EthernetClient : public Client {
   1586a:	cf 93       	push	r28
   1586c:	df 93       	push	r29
   1586e:	00 d0       	rcall	.+0      	; 0x15870 <_ZN14EthernetClientC1ERKS_+0x6>
   15870:	00 d0       	rcall	.+0      	; 0x15872 <_ZN14EthernetClientC1ERKS_+0x8>
   15872:	cd b7       	in	r28, 0x3d	; 61
   15874:	de b7       	in	r29, 0x3e	; 62
   15876:	9a 83       	std	Y+2, r25	; 0x02
   15878:	89 83       	std	Y+1, r24	; 0x01
   1587a:	7c 83       	std	Y+4, r23	; 0x04
   1587c:	6b 83       	std	Y+3, r22	; 0x03
   1587e:	2b 81       	ldd	r18, Y+3	; 0x03
   15880:	3c 81       	ldd	r19, Y+4	; 0x04
   15882:	89 81       	ldd	r24, Y+1	; 0x01
   15884:	9a 81       	ldd	r25, Y+2	; 0x02
   15886:	b9 01       	movw	r22, r18
   15888:	0e 94 a1 a6 	call	0x14d42	; 0x14d42 <_ZN6ClientC1ERKS_>
   1588c:	89 81       	ldd	r24, Y+1	; 0x01
   1588e:	9a 81       	ldd	r25, Y+2	; 0x02
   15890:	2d e3       	ldi	r18, 0x3D	; 61
   15892:	35 e0       	ldi	r19, 0x05	; 5
   15894:	fc 01       	movw	r30, r24
   15896:	31 83       	std	Z+1, r19	; 0x01
   15898:	20 83       	st	Z, r18
   1589a:	8b 81       	ldd	r24, Y+3	; 0x03
   1589c:	9c 81       	ldd	r25, Y+4	; 0x04
   1589e:	fc 01       	movw	r30, r24
   158a0:	24 85       	ldd	r18, Z+12	; 0x0c
   158a2:	89 81       	ldd	r24, Y+1	; 0x01
   158a4:	9a 81       	ldd	r25, Y+2	; 0x02
   158a6:	fc 01       	movw	r30, r24
   158a8:	24 87       	std	Z+12, r18	; 0x0c
   158aa:	0f 90       	pop	r0
   158ac:	0f 90       	pop	r0
   158ae:	0f 90       	pop	r0
   158b0:	0f 90       	pop	r0
   158b2:	df 91       	pop	r29
   158b4:	cf 91       	pop	r28
   158b6:	08 95       	ret

000158b8 <_ZN3UDP12rawIPAddressER9IPAddress>:
  // Return the IP address of the host who sent the current incoming packet
  virtual IPAddress remoteIP() =0;
  // Return the port of the host who sent the current incoming packet
  virtual uint16_t remotePort() =0;
protected:
  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
   158b8:	cf 93       	push	r28
   158ba:	df 93       	push	r29
   158bc:	00 d0       	rcall	.+0      	; 0x158be <_ZN3UDP12rawIPAddressER9IPAddress+0x6>
   158be:	00 d0       	rcall	.+0      	; 0x158c0 <_ZN3UDP12rawIPAddressER9IPAddress+0x8>
   158c0:	cd b7       	in	r28, 0x3d	; 61
   158c2:	de b7       	in	r29, 0x3e	; 62
   158c4:	9a 83       	std	Y+2, r25	; 0x02
   158c6:	89 83       	std	Y+1, r24	; 0x01
   158c8:	7c 83       	std	Y+4, r23	; 0x04
   158ca:	6b 83       	std	Y+3, r22	; 0x03
   158cc:	8b 81       	ldd	r24, Y+3	; 0x03
   158ce:	9c 81       	ldd	r25, Y+4	; 0x04
   158d0:	0e 94 61 aa 	call	0x154c2	; 0x154c2 <_ZN9IPAddress11raw_addressEv>
   158d4:	0f 90       	pop	r0
   158d6:	0f 90       	pop	r0
   158d8:	0f 90       	pop	r0
   158da:	0f 90       	pop	r0
   158dc:	df 91       	pop	r29
   158de:	cf 91       	pop	r28
   158e0:	08 95       	ret

000158e2 <_ZN11EthernetUDP4readEPcj>:
  // Read up to len bytes from the current packet and place them into buffer
  // Returns the number of bytes read, or 0 if none are available
  virtual int read(unsigned char* buffer, size_t len);
  // Read up to len characters from the current packet and place them into buffer
  // Returns the number of characters read, or 0 if none are available
  virtual int read(char* buffer, size_t len) { return read((unsigned char*)buffer, len); };
   158e2:	cf 93       	push	r28
   158e4:	df 93       	push	r29
   158e6:	00 d0       	rcall	.+0      	; 0x158e8 <_ZN11EthernetUDP4readEPcj+0x6>
   158e8:	00 d0       	rcall	.+0      	; 0x158ea <_ZN11EthernetUDP4readEPcj+0x8>
   158ea:	00 d0       	rcall	.+0      	; 0x158ec <_ZN11EthernetUDP4readEPcj+0xa>
   158ec:	cd b7       	in	r28, 0x3d	; 61
   158ee:	de b7       	in	r29, 0x3e	; 62
   158f0:	9a 83       	std	Y+2, r25	; 0x02
   158f2:	89 83       	std	Y+1, r24	; 0x01
   158f4:	7c 83       	std	Y+4, r23	; 0x04
   158f6:	6b 83       	std	Y+3, r22	; 0x03
   158f8:	5e 83       	std	Y+6, r21	; 0x06
   158fa:	4d 83       	std	Y+5, r20	; 0x05
   158fc:	89 81       	ldd	r24, Y+1	; 0x01
   158fe:	9a 81       	ldd	r25, Y+2	; 0x02
   15900:	fc 01       	movw	r30, r24
   15902:	80 81       	ld	r24, Z
   15904:	91 81       	ldd	r25, Z+1	; 0x01
   15906:	48 96       	adiw	r24, 0x18	; 24
   15908:	fc 01       	movw	r30, r24
   1590a:	20 81       	ld	r18, Z
   1590c:	31 81       	ldd	r19, Z+1	; 0x01
   1590e:	4d 81       	ldd	r20, Y+5	; 0x05
   15910:	5e 81       	ldd	r21, Y+6	; 0x06
   15912:	6b 81       	ldd	r22, Y+3	; 0x03
   15914:	7c 81       	ldd	r23, Y+4	; 0x04
   15916:	89 81       	ldd	r24, Y+1	; 0x01
   15918:	9a 81       	ldd	r25, Y+2	; 0x02
   1591a:	f9 01       	movw	r30, r18
   1591c:	09 95       	icall
   1591e:	26 96       	adiw	r28, 0x06	; 6
   15920:	0f b6       	in	r0, 0x3f	; 63
   15922:	f8 94       	cli
   15924:	de bf       	out	0x3e, r29	; 62
   15926:	0f be       	out	0x3f, r0	; 63
   15928:	cd bf       	out	0x3d, r28	; 61
   1592a:	df 91       	pop	r29
   1592c:	cf 91       	pop	r28
   1592e:	08 95       	ret

00015930 <_ZN3UDPC1Ev>:
#define udp_h

#include <Stream.h>
#include <IPAddress.h>

class UDP : public Stream {
   15930:	cf 93       	push	r28
   15932:	df 93       	push	r29
   15934:	00 d0       	rcall	.+0      	; 0x15936 <_ZN3UDPC1Ev+0x6>
   15936:	cd b7       	in	r28, 0x3d	; 61
   15938:	de b7       	in	r29, 0x3e	; 62
   1593a:	9a 83       	std	Y+2, r25	; 0x02
   1593c:	89 83       	std	Y+1, r24	; 0x01
   1593e:	89 81       	ldd	r24, Y+1	; 0x01
   15940:	9a 81       	ldd	r25, Y+2	; 0x02
   15942:	0e 94 99 a5 	call	0x14b32	; 0x14b32 <_ZN6StreamC1Ev>
   15946:	89 81       	ldd	r24, Y+1	; 0x01
   15948:	9a 81       	ldd	r25, Y+2	; 0x02
   1594a:	27 e8       	ldi	r18, 0x87	; 135
   1594c:	35 e0       	ldi	r19, 0x05	; 5
   1594e:	fc 01       	movw	r30, r24
   15950:	31 83       	std	Z+1, r19	; 0x01
   15952:	20 83       	st	Z, r18
   15954:	0f 90       	pop	r0
   15956:	0f 90       	pop	r0
   15958:	df 91       	pop	r29
   1595a:	cf 91       	pop	r28
   1595c:	08 95       	ret

0001595e <_Z10store_charhP11ring_buffer>:
  ring_buffer rx_buffer3  =  { { 0 }, 0, 0 };
  ring_buffer tx_buffer3  =  { { 0 }, 0, 0 };
#endif

inline void store_char(unsigned char c, ring_buffer *buffer)
{
   1595e:	cf 93       	push	r28
   15960:	df 93       	push	r29
   15962:	00 d0       	rcall	.+0      	; 0x15964 <_Z10store_charhP11ring_buffer+0x6>
   15964:	00 d0       	rcall	.+0      	; 0x15966 <_Z10store_charhP11ring_buffer+0x8>
   15966:	1f 92       	push	r1
   15968:	cd b7       	in	r28, 0x3d	; 61
   1596a:	de b7       	in	r29, 0x3e	; 62
   1596c:	8b 83       	std	Y+3, r24	; 0x03
   1596e:	7d 83       	std	Y+5, r23	; 0x05
   15970:	6c 83       	std	Y+4, r22	; 0x04
  int i = (unsigned int)(buffer->head + 1) % SERIAL_BUFFER_SIZE;
   15972:	8c 81       	ldd	r24, Y+4	; 0x04
   15974:	9d 81       	ldd	r25, Y+5	; 0x05
   15976:	80 5c       	subi	r24, 0xC0	; 192
   15978:	9f 4f       	sbci	r25, 0xFF	; 255
   1597a:	fc 01       	movw	r30, r24
   1597c:	80 81       	ld	r24, Z
   1597e:	91 81       	ldd	r25, Z+1	; 0x01
   15980:	01 96       	adiw	r24, 0x01	; 1
   15982:	8f 73       	andi	r24, 0x3F	; 63
   15984:	99 27       	eor	r25, r25
   15986:	9a 83       	std	Y+2, r25	; 0x02
   15988:	89 83       	std	Y+1, r24	; 0x01

  // if we should be storing the received character into the location
  // just before the tail (meaning that the head would advance to the
  // current location of the tail), we're about to overflow the buffer
  // and so we don't write the character or advance the head.
  if (i != buffer->tail) {
   1598a:	29 81       	ldd	r18, Y+1	; 0x01
   1598c:	3a 81       	ldd	r19, Y+2	; 0x02
   1598e:	8c 81       	ldd	r24, Y+4	; 0x04
   15990:	9d 81       	ldd	r25, Y+5	; 0x05
   15992:	8e 5b       	subi	r24, 0xBE	; 190
   15994:	9f 4f       	sbci	r25, 0xFF	; 255
   15996:	fc 01       	movw	r30, r24
   15998:	80 81       	ld	r24, Z
   1599a:	91 81       	ldd	r25, Z+1	; 0x01
   1599c:	41 e0       	ldi	r20, 0x01	; 1
   1599e:	28 17       	cp	r18, r24
   159a0:	39 07       	cpc	r19, r25
   159a2:	09 f4       	brne	.+2      	; 0x159a6 <_Z10store_charhP11ring_buffer+0x48>
   159a4:	40 e0       	ldi	r20, 0x00	; 0
   159a6:	44 23       	and	r20, r20
   159a8:	b9 f0       	breq	.+46     	; 0x159d8 <_Z10store_charhP11ring_buffer+0x7a>
    buffer->buffer[buffer->head] = c;
   159aa:	8c 81       	ldd	r24, Y+4	; 0x04
   159ac:	9d 81       	ldd	r25, Y+5	; 0x05
   159ae:	80 5c       	subi	r24, 0xC0	; 192
   159b0:	9f 4f       	sbci	r25, 0xFF	; 255
   159b2:	fc 01       	movw	r30, r24
   159b4:	80 81       	ld	r24, Z
   159b6:	91 81       	ldd	r25, Z+1	; 0x01
   159b8:	2c 81       	ldd	r18, Y+4	; 0x04
   159ba:	3d 81       	ldd	r19, Y+5	; 0x05
   159bc:	82 0f       	add	r24, r18
   159be:	93 1f       	adc	r25, r19
   159c0:	2b 81       	ldd	r18, Y+3	; 0x03
   159c2:	fc 01       	movw	r30, r24
   159c4:	20 83       	st	Z, r18
    buffer->head = i;
   159c6:	29 81       	ldd	r18, Y+1	; 0x01
   159c8:	3a 81       	ldd	r19, Y+2	; 0x02
   159ca:	8c 81       	ldd	r24, Y+4	; 0x04
   159cc:	9d 81       	ldd	r25, Y+5	; 0x05
   159ce:	80 5c       	subi	r24, 0xC0	; 192
   159d0:	9f 4f       	sbci	r25, 0xFF	; 255
   159d2:	fc 01       	movw	r30, r24
   159d4:	31 83       	std	Z+1, r19	; 0x01
   159d6:	20 83       	st	Z, r18
  }
}
   159d8:	0f 90       	pop	r0
   159da:	0f 90       	pop	r0
   159dc:	0f 90       	pop	r0
   159de:	0f 90       	pop	r0
   159e0:	0f 90       	pop	r0
   159e2:	df 91       	pop	r29
   159e4:	cf 91       	pop	r28
   159e6:	08 95       	ret

000159e8 <_ZN9PrintableC1Ev>:
   159e8:	cf 93       	push	r28
   159ea:	df 93       	push	r29
   159ec:	00 d0       	rcall	.+0      	; 0x159ee <_ZN9PrintableC1Ev+0x6>
   159ee:	cd b7       	in	r28, 0x3d	; 61
   159f0:	de b7       	in	r29, 0x3e	; 62
   159f2:	9a 83       	std	Y+2, r25	; 0x02
   159f4:	89 83       	std	Y+1, r24	; 0x01
   159f6:	89 81       	ldd	r24, Y+1	; 0x01
   159f8:	9a 81       	ldd	r25, Y+2	; 0x02
   159fa:	23 e2       	ldi	r18, 0x23	; 35
   159fc:	35 e0       	ldi	r19, 0x05	; 5
   159fe:	fc 01       	movw	r30, r24
   15a00:	31 83       	std	Z+1, r19	; 0x01
   15a02:	20 83       	st	Z, r18
   15a04:	0f 90       	pop	r0
   15a06:	0f 90       	pop	r0
   15a08:	df 91       	pop	r29
   15a0a:	cf 91       	pop	r28
   15a0c:	08 95       	ret

00015a0e <_ZNK6String6lengthEv>:
	// memory management
	// return true on success, false on failure (in which case, the string
	// is left unchanged).  reserve(0), if successful, will validate an
	// invalid string (i.e., "if (s)" will be true afterwards)
	unsigned char reserve(unsigned int size);
	inline unsigned int length(void) const {return len;}
   15a0e:	cf 93       	push	r28
   15a10:	df 93       	push	r29
   15a12:	00 d0       	rcall	.+0      	; 0x15a14 <_ZNK6String6lengthEv+0x6>
   15a14:	cd b7       	in	r28, 0x3d	; 61
   15a16:	de b7       	in	r29, 0x3e	; 62
   15a18:	9a 83       	std	Y+2, r25	; 0x02
   15a1a:	89 83       	std	Y+1, r24	; 0x01
   15a1c:	89 81       	ldd	r24, Y+1	; 0x01
   15a1e:	9a 81       	ldd	r25, Y+2	; 0x02
   15a20:	fc 01       	movw	r30, r24
   15a22:	84 81       	ldd	r24, Z+4	; 0x04
   15a24:	95 81       	ldd	r25, Z+5	; 0x05
   15a26:	0f 90       	pop	r0
   15a28:	0f 90       	pop	r0
   15a2a:	df 91       	pop	r29
   15a2c:	cf 91       	pop	r28
   15a2e:	08 95       	ret

00015a30 <_ZN5Print5writeEPKc>:
  
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
   15a30:	0f 93       	push	r16
   15a32:	1f 93       	push	r17
   15a34:	cf 93       	push	r28
   15a36:	df 93       	push	r29
   15a38:	00 d0       	rcall	.+0      	; 0x15a3a <_ZN5Print5writeEPKc+0xa>
   15a3a:	00 d0       	rcall	.+0      	; 0x15a3c <_ZN5Print5writeEPKc+0xc>
   15a3c:	cd b7       	in	r28, 0x3d	; 61
   15a3e:	de b7       	in	r29, 0x3e	; 62
   15a40:	9a 83       	std	Y+2, r25	; 0x02
   15a42:	89 83       	std	Y+1, r24	; 0x01
   15a44:	7c 83       	std	Y+4, r23	; 0x04
   15a46:	6b 83       	std	Y+3, r22	; 0x03
      if (str == NULL) return 0;
   15a48:	8b 81       	ldd	r24, Y+3	; 0x03
   15a4a:	9c 81       	ldd	r25, Y+4	; 0x04
   15a4c:	00 97       	sbiw	r24, 0x00	; 0
   15a4e:	19 f4       	brne	.+6      	; 0x15a56 <_ZN5Print5writeEPKc+0x26>
   15a50:	80 e0       	ldi	r24, 0x00	; 0
   15a52:	90 e0       	ldi	r25, 0x00	; 0
   15a54:	15 c0       	rjmp	.+42     	; 0x15a80 <_ZN5Print5writeEPKc+0x50>
      return write((const uint8_t *)str, strlen(str));
   15a56:	89 81       	ldd	r24, Y+1	; 0x01
   15a58:	9a 81       	ldd	r25, Y+2	; 0x02
   15a5a:	fc 01       	movw	r30, r24
   15a5c:	80 81       	ld	r24, Z
   15a5e:	91 81       	ldd	r25, Z+1	; 0x01
   15a60:	02 96       	adiw	r24, 0x02	; 2
   15a62:	fc 01       	movw	r30, r24
   15a64:	00 81       	ld	r16, Z
   15a66:	11 81       	ldd	r17, Z+1	; 0x01
   15a68:	8b 81       	ldd	r24, Y+3	; 0x03
   15a6a:	9c 81       	ldd	r25, Y+4	; 0x04
   15a6c:	0e 94 3b b1 	call	0x16276	; 0x16276 <strlen>
   15a70:	ac 01       	movw	r20, r24
   15a72:	2b 81       	ldd	r18, Y+3	; 0x03
   15a74:	3c 81       	ldd	r19, Y+4	; 0x04
   15a76:	89 81       	ldd	r24, Y+1	; 0x01
   15a78:	9a 81       	ldd	r25, Y+2	; 0x02
   15a7a:	b9 01       	movw	r22, r18
   15a7c:	f8 01       	movw	r30, r16
   15a7e:	09 95       	icall
    }
   15a80:	0f 90       	pop	r0
   15a82:	0f 90       	pop	r0
   15a84:	0f 90       	pop	r0
   15a86:	0f 90       	pop	r0
   15a88:	df 91       	pop	r29
   15a8a:	cf 91       	pop	r28
   15a8c:	1f 91       	pop	r17
   15a8e:	0f 91       	pop	r16
   15a90:	08 95       	ret

00015a92 <_ZN6StringpLEc>:
	
	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
	String & operator += (char c)			{concat(c); return (*this);}
   15a92:	cf 93       	push	r28
   15a94:	df 93       	push	r29
   15a96:	00 d0       	rcall	.+0      	; 0x15a98 <_ZN6StringpLEc+0x6>
   15a98:	1f 92       	push	r1
   15a9a:	cd b7       	in	r28, 0x3d	; 61
   15a9c:	de b7       	in	r29, 0x3e	; 62
   15a9e:	9a 83       	std	Y+2, r25	; 0x02
   15aa0:	89 83       	std	Y+1, r24	; 0x01
   15aa2:	6b 83       	std	Y+3, r22	; 0x03
   15aa4:	89 81       	ldd	r24, Y+1	; 0x01
   15aa6:	9a 81       	ldd	r25, Y+2	; 0x02
   15aa8:	6b 81       	ldd	r22, Y+3	; 0x03
   15aaa:	0e 94 8a 70 	call	0xe114	; 0xe114 <_ZN6String6concatEc>
   15aae:	89 81       	ldd	r24, Y+1	; 0x01
   15ab0:	9a 81       	ldd	r25, Y+2	; 0x02
   15ab2:	0f 90       	pop	r0
   15ab4:	0f 90       	pop	r0
   15ab6:	0f 90       	pop	r0
   15ab8:	df 91       	pop	r29
   15aba:	cf 91       	pop	r28
   15abc:	08 95       	ret

00015abe <_ZN6String4initEv>:
/*********************************************/
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
   15abe:	cf 93       	push	r28
   15ac0:	df 93       	push	r29
   15ac2:	00 d0       	rcall	.+0      	; 0x15ac4 <_ZN6String4initEv+0x6>
   15ac4:	cd b7       	in	r28, 0x3d	; 61
   15ac6:	de b7       	in	r29, 0x3e	; 62
   15ac8:	9a 83       	std	Y+2, r25	; 0x02
   15aca:	89 83       	std	Y+1, r24	; 0x01
	buffer = NULL;
   15acc:	89 81       	ldd	r24, Y+1	; 0x01
   15ace:	9a 81       	ldd	r25, Y+2	; 0x02
   15ad0:	fc 01       	movw	r30, r24
   15ad2:	11 82       	std	Z+1, r1	; 0x01
   15ad4:	10 82       	st	Z, r1
	capacity = 0;
   15ad6:	89 81       	ldd	r24, Y+1	; 0x01
   15ad8:	9a 81       	ldd	r25, Y+2	; 0x02
   15ada:	fc 01       	movw	r30, r24
   15adc:	13 82       	std	Z+3, r1	; 0x03
   15ade:	12 82       	std	Z+2, r1	; 0x02
	len = 0;
   15ae0:	89 81       	ldd	r24, Y+1	; 0x01
   15ae2:	9a 81       	ldd	r25, Y+2	; 0x02
   15ae4:	fc 01       	movw	r30, r24
   15ae6:	15 82       	std	Z+5, r1	; 0x05
   15ae8:	14 82       	std	Z+4, r1	; 0x04
	flags = 0;
   15aea:	89 81       	ldd	r24, Y+1	; 0x01
   15aec:	9a 81       	ldd	r25, Y+2	; 0x02
   15aee:	fc 01       	movw	r30, r24
   15af0:	16 82       	std	Z+6, r1	; 0x06
}
   15af2:	0f 90       	pop	r0
   15af4:	0f 90       	pop	r0
   15af6:	df 91       	pop	r29
   15af8:	cf 91       	pop	r28
   15afa:	08 95       	ret

00015afc <_ZN14HardwareSerial5writeEi>:
    virtual void flush(void);
    virtual size_t write(uint8_t);
    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
   15afc:	cf 93       	push	r28
   15afe:	df 93       	push	r29
   15b00:	00 d0       	rcall	.+0      	; 0x15b02 <_ZN14HardwareSerial5writeEi+0x6>
   15b02:	00 d0       	rcall	.+0      	; 0x15b04 <_ZN14HardwareSerial5writeEi+0x8>
   15b04:	cd b7       	in	r28, 0x3d	; 61
   15b06:	de b7       	in	r29, 0x3e	; 62
   15b08:	9a 83       	std	Y+2, r25	; 0x02
   15b0a:	89 83       	std	Y+1, r24	; 0x01
   15b0c:	7c 83       	std	Y+4, r23	; 0x04
   15b0e:	6b 83       	std	Y+3, r22	; 0x03
   15b10:	89 81       	ldd	r24, Y+1	; 0x01
   15b12:	9a 81       	ldd	r25, Y+2	; 0x02
   15b14:	fc 01       	movw	r30, r24
   15b16:	80 81       	ld	r24, Z
   15b18:	91 81       	ldd	r25, Z+1	; 0x01
   15b1a:	fc 01       	movw	r30, r24
   15b1c:	20 81       	ld	r18, Z
   15b1e:	31 81       	ldd	r19, Z+1	; 0x01
   15b20:	4b 81       	ldd	r20, Y+3	; 0x03
   15b22:	89 81       	ldd	r24, Y+1	; 0x01
   15b24:	9a 81       	ldd	r25, Y+2	; 0x02
   15b26:	64 2f       	mov	r22, r20
   15b28:	f9 01       	movw	r30, r18
   15b2a:	09 95       	icall
   15b2c:	0f 90       	pop	r0
   15b2e:	0f 90       	pop	r0
   15b30:	0f 90       	pop	r0
   15b32:	0f 90       	pop	r0
   15b34:	df 91       	pop	r29
   15b36:	cf 91       	pop	r28
   15b38:	08 95       	ret

00015b3a <__mulsi3>:
   15b3a:	db 01       	movw	r26, r22
   15b3c:	8f 93       	push	r24
   15b3e:	9f 93       	push	r25
   15b40:	0e 94 f1 ad 	call	0x15be2	; 0x15be2 <__muluhisi3>
   15b44:	bf 91       	pop	r27
   15b46:	af 91       	pop	r26
   15b48:	a2 9f       	mul	r26, r18
   15b4a:	80 0d       	add	r24, r0
   15b4c:	91 1d       	adc	r25, r1
   15b4e:	a3 9f       	mul	r26, r19
   15b50:	90 0d       	add	r25, r0
   15b52:	b2 9f       	mul	r27, r18
   15b54:	90 0d       	add	r25, r0
   15b56:	11 24       	eor	r1, r1
   15b58:	08 95       	ret

00015b5a <__udivmodsi4>:
   15b5a:	a1 e2       	ldi	r26, 0x21	; 33
   15b5c:	1a 2e       	mov	r1, r26
   15b5e:	aa 1b       	sub	r26, r26
   15b60:	bb 1b       	sub	r27, r27
   15b62:	fd 01       	movw	r30, r26
   15b64:	0d c0       	rjmp	.+26     	; 0x15b80 <__udivmodsi4_ep>

00015b66 <__udivmodsi4_loop>:
   15b66:	aa 1f       	adc	r26, r26
   15b68:	bb 1f       	adc	r27, r27
   15b6a:	ee 1f       	adc	r30, r30
   15b6c:	ff 1f       	adc	r31, r31
   15b6e:	a2 17       	cp	r26, r18
   15b70:	b3 07       	cpc	r27, r19
   15b72:	e4 07       	cpc	r30, r20
   15b74:	f5 07       	cpc	r31, r21
   15b76:	20 f0       	brcs	.+8      	; 0x15b80 <__udivmodsi4_ep>
   15b78:	a2 1b       	sub	r26, r18
   15b7a:	b3 0b       	sbc	r27, r19
   15b7c:	e4 0b       	sbc	r30, r20
   15b7e:	f5 0b       	sbc	r31, r21

00015b80 <__udivmodsi4_ep>:
   15b80:	66 1f       	adc	r22, r22
   15b82:	77 1f       	adc	r23, r23
   15b84:	88 1f       	adc	r24, r24
   15b86:	99 1f       	adc	r25, r25
   15b88:	1a 94       	dec	r1
   15b8a:	69 f7       	brne	.-38     	; 0x15b66 <__udivmodsi4_loop>
   15b8c:	60 95       	com	r22
   15b8e:	70 95       	com	r23
   15b90:	80 95       	com	r24
   15b92:	90 95       	com	r25
   15b94:	9b 01       	movw	r18, r22
   15b96:	ac 01       	movw	r20, r24
   15b98:	bd 01       	movw	r22, r26
   15b9a:	cf 01       	movw	r24, r30
   15b9c:	08 95       	ret

00015b9e <__divmodsi4>:
   15b9e:	05 2e       	mov	r0, r21
   15ba0:	97 fb       	bst	r25, 7
   15ba2:	16 f4       	brtc	.+4      	; 0x15ba8 <__divmodsi4+0xa>
   15ba4:	00 94       	com	r0
   15ba6:	07 d0       	rcall	.+14     	; 0x15bb6 <__divmodsi4_neg1>
   15ba8:	57 fd       	sbrc	r21, 7
   15baa:	0d d0       	rcall	.+26     	; 0x15bc6 <__divmodsi4_neg2>
   15bac:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
   15bb0:	07 fc       	sbrc	r0, 7
   15bb2:	09 d0       	rcall	.+18     	; 0x15bc6 <__divmodsi4_neg2>
   15bb4:	7e f4       	brtc	.+30     	; 0x15bd4 <__divmodsi4_exit>

00015bb6 <__divmodsi4_neg1>:
   15bb6:	90 95       	com	r25
   15bb8:	80 95       	com	r24
   15bba:	70 95       	com	r23
   15bbc:	61 95       	neg	r22
   15bbe:	7f 4f       	sbci	r23, 0xFF	; 255
   15bc0:	8f 4f       	sbci	r24, 0xFF	; 255
   15bc2:	9f 4f       	sbci	r25, 0xFF	; 255
   15bc4:	08 95       	ret

00015bc6 <__divmodsi4_neg2>:
   15bc6:	50 95       	com	r21
   15bc8:	40 95       	com	r20
   15bca:	30 95       	com	r19
   15bcc:	21 95       	neg	r18
   15bce:	3f 4f       	sbci	r19, 0xFF	; 255
   15bd0:	4f 4f       	sbci	r20, 0xFF	; 255
   15bd2:	5f 4f       	sbci	r21, 0xFF	; 255

00015bd4 <__divmodsi4_exit>:
   15bd4:	08 95       	ret

00015bd6 <__tablejump2__>:
   15bd6:	ee 0f       	add	r30, r30
   15bd8:	ff 1f       	adc	r31, r31

00015bda <__tablejump__>:
   15bda:	05 90       	lpm	r0, Z+
   15bdc:	f4 91       	lpm	r31, Z
   15bde:	e0 2d       	mov	r30, r0
   15be0:	09 94       	ijmp

00015be2 <__muluhisi3>:
   15be2:	0e 94 4e ae 	call	0x15c9c	; 0x15c9c <__umulhisi3>
   15be6:	a5 9f       	mul	r26, r21
   15be8:	90 0d       	add	r25, r0
   15bea:	b4 9f       	mul	r27, r20
   15bec:	90 0d       	add	r25, r0
   15bee:	a4 9f       	mul	r26, r20
   15bf0:	80 0d       	add	r24, r0
   15bf2:	91 1d       	adc	r25, r1
   15bf4:	11 24       	eor	r1, r1
   15bf6:	08 95       	ret

00015bf8 <__prologue_saves__>:
   15bf8:	2f 92       	push	r2
   15bfa:	3f 92       	push	r3
   15bfc:	4f 92       	push	r4
   15bfe:	5f 92       	push	r5
   15c00:	6f 92       	push	r6
   15c02:	7f 92       	push	r7
   15c04:	8f 92       	push	r8
   15c06:	9f 92       	push	r9
   15c08:	af 92       	push	r10
   15c0a:	bf 92       	push	r11
   15c0c:	cf 92       	push	r12
   15c0e:	df 92       	push	r13
   15c10:	ef 92       	push	r14
   15c12:	ff 92       	push	r15
   15c14:	0f 93       	push	r16
   15c16:	1f 93       	push	r17
   15c18:	cf 93       	push	r28
   15c1a:	df 93       	push	r29
   15c1c:	cd b7       	in	r28, 0x3d	; 61
   15c1e:	de b7       	in	r29, 0x3e	; 62
   15c20:	ca 1b       	sub	r28, r26
   15c22:	db 0b       	sbc	r29, r27
   15c24:	0f b6       	in	r0, 0x3f	; 63
   15c26:	f8 94       	cli
   15c28:	de bf       	out	0x3e, r29	; 62
   15c2a:	0f be       	out	0x3f, r0	; 63
   15c2c:	cd bf       	out	0x3d, r28	; 61
   15c2e:	09 94       	ijmp

00015c30 <__epilogue_restores__>:
   15c30:	2a 88       	ldd	r2, Y+18	; 0x12
   15c32:	39 88       	ldd	r3, Y+17	; 0x11
   15c34:	48 88       	ldd	r4, Y+16	; 0x10
   15c36:	5f 84       	ldd	r5, Y+15	; 0x0f
   15c38:	6e 84       	ldd	r6, Y+14	; 0x0e
   15c3a:	7d 84       	ldd	r7, Y+13	; 0x0d
   15c3c:	8c 84       	ldd	r8, Y+12	; 0x0c
   15c3e:	9b 84       	ldd	r9, Y+11	; 0x0b
   15c40:	aa 84       	ldd	r10, Y+10	; 0x0a
   15c42:	b9 84       	ldd	r11, Y+9	; 0x09
   15c44:	c8 84       	ldd	r12, Y+8	; 0x08
   15c46:	df 80       	ldd	r13, Y+7	; 0x07
   15c48:	ee 80       	ldd	r14, Y+6	; 0x06
   15c4a:	fd 80       	ldd	r15, Y+5	; 0x05
   15c4c:	0c 81       	ldd	r16, Y+4	; 0x04
   15c4e:	1b 81       	ldd	r17, Y+3	; 0x03
   15c50:	aa 81       	ldd	r26, Y+2	; 0x02
   15c52:	b9 81       	ldd	r27, Y+1	; 0x01
   15c54:	ce 0f       	add	r28, r30
   15c56:	d1 1d       	adc	r29, r1
   15c58:	0f b6       	in	r0, 0x3f	; 63
   15c5a:	f8 94       	cli
   15c5c:	de bf       	out	0x3e, r29	; 62
   15c5e:	0f be       	out	0x3f, r0	; 63
   15c60:	cd bf       	out	0x3d, r28	; 61
   15c62:	ed 01       	movw	r28, r26
   15c64:	08 95       	ret

00015c66 <__clzsi2>:
   15c66:	0e 94 3c ae 	call	0x15c78	; 0x15c78 <__clzhi2>
   15c6a:	84 ff       	sbrs	r24, 4
   15c6c:	08 95       	ret
   15c6e:	cb 01       	movw	r24, r22
   15c70:	0e 94 3c ae 	call	0x15c78	; 0x15c78 <__clzhi2>
   15c74:	80 5f       	subi	r24, 0xF0	; 240
   15c76:	08 95       	ret

00015c78 <__clzhi2>:
   15c78:	aa 27       	eor	r26, r26
   15c7a:	99 23       	and	r25, r25
   15c7c:	29 f4       	brne	.+10     	; 0x15c88 <__clzhi2+0x10>
   15c7e:	a8 5f       	subi	r26, 0xF8	; 248
   15c80:	98 2b       	or	r25, r24
   15c82:	11 f4       	brne	.+4      	; 0x15c88 <__clzhi2+0x10>
   15c84:	80 e1       	ldi	r24, 0x10	; 16
   15c86:	08 95       	ret
   15c88:	90 31       	cpi	r25, 0x10	; 16
   15c8a:	18 f4       	brcc	.+6      	; 0x15c92 <__clzhi2+0x1a>
   15c8c:	ad 5f       	subi	r26, 0xFD	; 253
   15c8e:	92 95       	swap	r25
   15c90:	a3 95       	inc	r26
   15c92:	99 0f       	add	r25, r25
   15c94:	e8 f7       	brcc	.-6      	; 0x15c90 <__clzhi2+0x18>
   15c96:	8a 2f       	mov	r24, r26
   15c98:	99 27       	eor	r25, r25
   15c9a:	08 95       	ret

00015c9c <__umulhisi3>:
   15c9c:	a2 9f       	mul	r26, r18
   15c9e:	b0 01       	movw	r22, r0
   15ca0:	b3 9f       	mul	r27, r19
   15ca2:	c0 01       	movw	r24, r0
   15ca4:	a3 9f       	mul	r26, r19
   15ca6:	01 d0       	rcall	.+2      	; 0x15caa <__umulhisi3+0xe>
   15ca8:	b2 9f       	mul	r27, r18
   15caa:	70 0d       	add	r23, r0
   15cac:	81 1d       	adc	r24, r1
   15cae:	11 24       	eor	r1, r1
   15cb0:	91 1d       	adc	r25, r1
   15cb2:	08 95       	ret

00015cb4 <malloc>:
   15cb4:	cf 93       	push	r28
   15cb6:	df 93       	push	r29
   15cb8:	ac 01       	movw	r20, r24
   15cba:	82 30       	cpi	r24, 0x02	; 2
   15cbc:	91 05       	cpc	r25, r1
   15cbe:	10 f4       	brcc	.+4      	; 0x15cc4 <malloc+0x10>
   15cc0:	42 e0       	ldi	r20, 0x02	; 2
   15cc2:	50 e0       	ldi	r21, 0x00	; 0
   15cc4:	e0 91 b0 09 	lds	r30, 0x09B0
   15cc8:	f0 91 b1 09 	lds	r31, 0x09B1
   15ccc:	20 e0       	ldi	r18, 0x00	; 0
   15cce:	30 e0       	ldi	r19, 0x00	; 0
   15cd0:	a0 e0       	ldi	r26, 0x00	; 0
   15cd2:	b0 e0       	ldi	r27, 0x00	; 0
   15cd4:	24 c0       	rjmp	.+72     	; 0x15d1e <malloc+0x6a>
   15cd6:	80 81       	ld	r24, Z
   15cd8:	91 81       	ldd	r25, Z+1	; 0x01
   15cda:	84 17       	cp	r24, r20
   15cdc:	95 07       	cpc	r25, r21
   15cde:	d0 f0       	brcs	.+52     	; 0x15d14 <malloc+0x60>
   15ce0:	84 17       	cp	r24, r20
   15ce2:	95 07       	cpc	r25, r21
   15ce4:	71 f4       	brne	.+28     	; 0x15d02 <malloc+0x4e>
   15ce6:	82 81       	ldd	r24, Z+2	; 0x02
   15ce8:	93 81       	ldd	r25, Z+3	; 0x03
   15cea:	10 97       	sbiw	r26, 0x00	; 0
   15cec:	29 f0       	breq	.+10     	; 0x15cf8 <malloc+0x44>
   15cee:	13 96       	adiw	r26, 0x03	; 3
   15cf0:	9c 93       	st	X, r25
   15cf2:	8e 93       	st	-X, r24
   15cf4:	12 97       	sbiw	r26, 0x02	; 2
   15cf6:	2c c0       	rjmp	.+88     	; 0x15d50 <malloc+0x9c>
   15cf8:	90 93 b1 09 	sts	0x09B1, r25
   15cfc:	80 93 b0 09 	sts	0x09B0, r24
   15d00:	27 c0       	rjmp	.+78     	; 0x15d50 <malloc+0x9c>
   15d02:	21 15       	cp	r18, r1
   15d04:	31 05       	cpc	r19, r1
   15d06:	19 f0       	breq	.+6      	; 0x15d0e <malloc+0x5a>
   15d08:	82 17       	cp	r24, r18
   15d0a:	93 07       	cpc	r25, r19
   15d0c:	18 f4       	brcc	.+6      	; 0x15d14 <malloc+0x60>
   15d0e:	9c 01       	movw	r18, r24
   15d10:	bd 01       	movw	r22, r26
   15d12:	ef 01       	movw	r28, r30
   15d14:	92 81       	ldd	r25, Z+2	; 0x02
   15d16:	83 81       	ldd	r24, Z+3	; 0x03
   15d18:	df 01       	movw	r26, r30
   15d1a:	e9 2f       	mov	r30, r25
   15d1c:	f8 2f       	mov	r31, r24
   15d1e:	30 97       	sbiw	r30, 0x00	; 0
   15d20:	d1 f6       	brne	.-76     	; 0x15cd6 <malloc+0x22>
   15d22:	21 15       	cp	r18, r1
   15d24:	31 05       	cpc	r19, r1
   15d26:	f9 f0       	breq	.+62     	; 0x15d66 <malloc+0xb2>
   15d28:	c9 01       	movw	r24, r18
   15d2a:	84 1b       	sub	r24, r20
   15d2c:	95 0b       	sbc	r25, r21
   15d2e:	84 30       	cpi	r24, 0x04	; 4
   15d30:	91 05       	cpc	r25, r1
   15d32:	80 f4       	brcc	.+32     	; 0x15d54 <malloc+0xa0>
   15d34:	8a 81       	ldd	r24, Y+2	; 0x02
   15d36:	9b 81       	ldd	r25, Y+3	; 0x03
   15d38:	61 15       	cp	r22, r1
   15d3a:	71 05       	cpc	r23, r1
   15d3c:	21 f0       	breq	.+8      	; 0x15d46 <malloc+0x92>
   15d3e:	fb 01       	movw	r30, r22
   15d40:	93 83       	std	Z+3, r25	; 0x03
   15d42:	82 83       	std	Z+2, r24	; 0x02
   15d44:	04 c0       	rjmp	.+8      	; 0x15d4e <malloc+0x9a>
   15d46:	90 93 b1 09 	sts	0x09B1, r25
   15d4a:	80 93 b0 09 	sts	0x09B0, r24
   15d4e:	fe 01       	movw	r30, r28
   15d50:	32 96       	adiw	r30, 0x02	; 2
   15d52:	42 c0       	rjmp	.+132    	; 0x15dd8 <malloc+0x124>
   15d54:	fe 01       	movw	r30, r28
   15d56:	e8 0f       	add	r30, r24
   15d58:	f9 1f       	adc	r31, r25
   15d5a:	41 93       	st	Z+, r20
   15d5c:	51 93       	st	Z+, r21
   15d5e:	02 97       	sbiw	r24, 0x02	; 2
   15d60:	99 83       	std	Y+1, r25	; 0x01
   15d62:	88 83       	st	Y, r24
   15d64:	39 c0       	rjmp	.+114    	; 0x15dd8 <malloc+0x124>
   15d66:	80 91 ae 09 	lds	r24, 0x09AE
   15d6a:	90 91 af 09 	lds	r25, 0x09AF
   15d6e:	00 97       	sbiw	r24, 0x00	; 0
   15d70:	41 f4       	brne	.+16     	; 0x15d82 <malloc+0xce>
   15d72:	80 91 4a 02 	lds	r24, 0x024A
   15d76:	90 91 4b 02 	lds	r25, 0x024B
   15d7a:	90 93 af 09 	sts	0x09AF, r25
   15d7e:	80 93 ae 09 	sts	0x09AE, r24
   15d82:	20 91 48 02 	lds	r18, 0x0248
   15d86:	30 91 49 02 	lds	r19, 0x0249
   15d8a:	21 15       	cp	r18, r1
   15d8c:	31 05       	cpc	r19, r1
   15d8e:	41 f4       	brne	.+16     	; 0x15da0 <malloc+0xec>
   15d90:	2d b7       	in	r18, 0x3d	; 61
   15d92:	3e b7       	in	r19, 0x3e	; 62
   15d94:	80 91 4c 02 	lds	r24, 0x024C
   15d98:	90 91 4d 02 	lds	r25, 0x024D
   15d9c:	28 1b       	sub	r18, r24
   15d9e:	39 0b       	sbc	r19, r25
   15da0:	e0 91 ae 09 	lds	r30, 0x09AE
   15da4:	f0 91 af 09 	lds	r31, 0x09AF
   15da8:	e2 17       	cp	r30, r18
   15daa:	f3 07       	cpc	r31, r19
   15dac:	98 f4       	brcc	.+38     	; 0x15dd4 <malloc+0x120>
   15dae:	2e 1b       	sub	r18, r30
   15db0:	3f 0b       	sbc	r19, r31
   15db2:	24 17       	cp	r18, r20
   15db4:	35 07       	cpc	r19, r21
   15db6:	70 f0       	brcs	.+28     	; 0x15dd4 <malloc+0x120>
   15db8:	ca 01       	movw	r24, r20
   15dba:	02 96       	adiw	r24, 0x02	; 2
   15dbc:	28 17       	cp	r18, r24
   15dbe:	39 07       	cpc	r19, r25
   15dc0:	48 f0       	brcs	.+18     	; 0x15dd4 <malloc+0x120>
   15dc2:	8e 0f       	add	r24, r30
   15dc4:	9f 1f       	adc	r25, r31
   15dc6:	90 93 af 09 	sts	0x09AF, r25
   15dca:	80 93 ae 09 	sts	0x09AE, r24
   15dce:	41 93       	st	Z+, r20
   15dd0:	51 93       	st	Z+, r21
   15dd2:	02 c0       	rjmp	.+4      	; 0x15dd8 <malloc+0x124>
   15dd4:	e0 e0       	ldi	r30, 0x00	; 0
   15dd6:	f0 e0       	ldi	r31, 0x00	; 0
   15dd8:	cf 01       	movw	r24, r30
   15dda:	df 91       	pop	r29
   15ddc:	cf 91       	pop	r28
   15dde:	08 95       	ret

00015de0 <free>:
   15de0:	0f 93       	push	r16
   15de2:	1f 93       	push	r17
   15de4:	cf 93       	push	r28
   15de6:	df 93       	push	r29
   15de8:	9c 01       	movw	r18, r24
   15dea:	00 97       	sbiw	r24, 0x00	; 0
   15dec:	09 f4       	brne	.+2      	; 0x15df0 <free+0x10>
   15dee:	8c c0       	rjmp	.+280    	; 0x15f08 <free+0x128>
   15df0:	dc 01       	movw	r26, r24
   15df2:	12 97       	sbiw	r26, 0x02	; 2
   15df4:	13 96       	adiw	r26, 0x03	; 3
   15df6:	1c 92       	st	X, r1
   15df8:	1e 92       	st	-X, r1
   15dfa:	12 97       	sbiw	r26, 0x02	; 2
   15dfc:	60 91 b0 09 	lds	r22, 0x09B0
   15e00:	70 91 b1 09 	lds	r23, 0x09B1
   15e04:	61 15       	cp	r22, r1
   15e06:	71 05       	cpc	r23, r1
   15e08:	89 f4       	brne	.+34     	; 0x15e2c <free+0x4c>
   15e0a:	8d 91       	ld	r24, X+
   15e0c:	9c 91       	ld	r25, X
   15e0e:	11 97       	sbiw	r26, 0x01	; 1
   15e10:	82 0f       	add	r24, r18
   15e12:	93 1f       	adc	r25, r19
   15e14:	20 91 ae 09 	lds	r18, 0x09AE
   15e18:	30 91 af 09 	lds	r19, 0x09AF
   15e1c:	28 17       	cp	r18, r24
   15e1e:	39 07       	cpc	r19, r25
   15e20:	69 f5       	brne	.+90     	; 0x15e7c <free+0x9c>
   15e22:	b0 93 af 09 	sts	0x09AF, r27
   15e26:	a0 93 ae 09 	sts	0x09AE, r26
   15e2a:	6e c0       	rjmp	.+220    	; 0x15f08 <free+0x128>
   15e2c:	fb 01       	movw	r30, r22
   15e2e:	40 e0       	ldi	r20, 0x00	; 0
   15e30:	50 e0       	ldi	r21, 0x00	; 0
   15e32:	01 c0       	rjmp	.+2      	; 0x15e36 <free+0x56>
   15e34:	fc 01       	movw	r30, r24
   15e36:	ea 17       	cp	r30, r26
   15e38:	fb 07       	cpc	r31, r27
   15e3a:	30 f4       	brcc	.+12     	; 0x15e48 <free+0x68>
   15e3c:	82 81       	ldd	r24, Z+2	; 0x02
   15e3e:	93 81       	ldd	r25, Z+3	; 0x03
   15e40:	af 01       	movw	r20, r30
   15e42:	00 97       	sbiw	r24, 0x00	; 0
   15e44:	b9 f7       	brne	.-18     	; 0x15e34 <free+0x54>
   15e46:	1f c0       	rjmp	.+62     	; 0x15e86 <free+0xa6>
   15e48:	e9 01       	movw	r28, r18
   15e4a:	22 97       	sbiw	r28, 0x02	; 2
   15e4c:	fb 83       	std	Y+3, r31	; 0x03
   15e4e:	ea 83       	std	Y+2, r30	; 0x02
   15e50:	08 81       	ld	r16, Y
   15e52:	19 81       	ldd	r17, Y+1	; 0x01
   15e54:	c9 01       	movw	r24, r18
   15e56:	80 0f       	add	r24, r16
   15e58:	91 1f       	adc	r25, r17
   15e5a:	8e 17       	cp	r24, r30
   15e5c:	9f 07       	cpc	r25, r31
   15e5e:	59 f4       	brne	.+22     	; 0x15e76 <free+0x96>
   15e60:	80 81       	ld	r24, Z
   15e62:	91 81       	ldd	r25, Z+1	; 0x01
   15e64:	80 0f       	add	r24, r16
   15e66:	91 1f       	adc	r25, r17
   15e68:	02 96       	adiw	r24, 0x02	; 2
   15e6a:	99 83       	std	Y+1, r25	; 0x01
   15e6c:	88 83       	st	Y, r24
   15e6e:	82 81       	ldd	r24, Z+2	; 0x02
   15e70:	93 81       	ldd	r25, Z+3	; 0x03
   15e72:	9b 83       	std	Y+3, r25	; 0x03
   15e74:	8a 83       	std	Y+2, r24	; 0x02
   15e76:	41 15       	cp	r20, r1
   15e78:	51 05       	cpc	r21, r1
   15e7a:	29 f4       	brne	.+10     	; 0x15e86 <free+0xa6>
   15e7c:	b0 93 b1 09 	sts	0x09B1, r27
   15e80:	a0 93 b0 09 	sts	0x09B0, r26
   15e84:	41 c0       	rjmp	.+130    	; 0x15f08 <free+0x128>
   15e86:	fa 01       	movw	r30, r20
   15e88:	b3 83       	std	Z+3, r27	; 0x03
   15e8a:	a2 83       	std	Z+2, r26	; 0x02
   15e8c:	c1 91       	ld	r28, Z+
   15e8e:	d1 91       	ld	r29, Z+
   15e90:	ec 0f       	add	r30, r28
   15e92:	fd 1f       	adc	r31, r29
   15e94:	ae 17       	cp	r26, r30
   15e96:	bf 07       	cpc	r27, r31
   15e98:	81 f4       	brne	.+32     	; 0x15eba <free+0xda>
   15e9a:	f9 01       	movw	r30, r18
   15e9c:	92 91       	ld	r25, -Z
   15e9e:	82 91       	ld	r24, -Z
   15ea0:	8c 0f       	add	r24, r28
   15ea2:	9d 1f       	adc	r25, r29
   15ea4:	02 96       	adiw	r24, 0x02	; 2
   15ea6:	da 01       	movw	r26, r20
   15ea8:	11 96       	adiw	r26, 0x01	; 1
   15eaa:	9c 93       	st	X, r25
   15eac:	8e 93       	st	-X, r24
   15eae:	82 81       	ldd	r24, Z+2	; 0x02
   15eb0:	93 81       	ldd	r25, Z+3	; 0x03
   15eb2:	13 96       	adiw	r26, 0x03	; 3
   15eb4:	9c 93       	st	X, r25
   15eb6:	8e 93       	st	-X, r24
   15eb8:	12 97       	sbiw	r26, 0x02	; 2
   15eba:	e0 e0       	ldi	r30, 0x00	; 0
   15ebc:	f0 e0       	ldi	r31, 0x00	; 0
   15ebe:	02 c0       	rjmp	.+4      	; 0x15ec4 <free+0xe4>
   15ec0:	fb 01       	movw	r30, r22
   15ec2:	bc 01       	movw	r22, r24
   15ec4:	db 01       	movw	r26, r22
   15ec6:	12 96       	adiw	r26, 0x02	; 2
   15ec8:	8d 91       	ld	r24, X+
   15eca:	9c 91       	ld	r25, X
   15ecc:	13 97       	sbiw	r26, 0x03	; 3
   15ece:	00 97       	sbiw	r24, 0x00	; 0
   15ed0:	b9 f7       	brne	.-18     	; 0x15ec0 <free+0xe0>
   15ed2:	cb 01       	movw	r24, r22
   15ed4:	02 96       	adiw	r24, 0x02	; 2
   15ed6:	2d 91       	ld	r18, X+
   15ed8:	3c 91       	ld	r19, X
   15eda:	11 97       	sbiw	r26, 0x01	; 1
   15edc:	82 0f       	add	r24, r18
   15ede:	93 1f       	adc	r25, r19
   15ee0:	20 91 ae 09 	lds	r18, 0x09AE
   15ee4:	30 91 af 09 	lds	r19, 0x09AF
   15ee8:	28 17       	cp	r18, r24
   15eea:	39 07       	cpc	r19, r25
   15eec:	69 f4       	brne	.+26     	; 0x15f08 <free+0x128>
   15eee:	30 97       	sbiw	r30, 0x00	; 0
   15ef0:	29 f4       	brne	.+10     	; 0x15efc <free+0x11c>
   15ef2:	10 92 b1 09 	sts	0x09B1, r1
   15ef6:	10 92 b0 09 	sts	0x09B0, r1
   15efa:	02 c0       	rjmp	.+4      	; 0x15f00 <free+0x120>
   15efc:	13 82       	std	Z+3, r1	; 0x03
   15efe:	12 82       	std	Z+2, r1	; 0x02
   15f00:	70 93 af 09 	sts	0x09AF, r23
   15f04:	60 93 ae 09 	sts	0x09AE, r22
   15f08:	df 91       	pop	r29
   15f0a:	cf 91       	pop	r28
   15f0c:	1f 91       	pop	r17
   15f0e:	0f 91       	pop	r16
   15f10:	08 95       	ret

00015f12 <do_random>:
   15f12:	a0 e0       	ldi	r26, 0x00	; 0
   15f14:	b0 e0       	ldi	r27, 0x00	; 0
   15f16:	ef e8       	ldi	r30, 0x8F	; 143
   15f18:	ff ea       	ldi	r31, 0xAF	; 175
   15f1a:	0c 94 02 ae 	jmp	0x15c04	; 0x15c04 <__prologue_saves__+0xc>
   15f1e:	ec 01       	movw	r28, r24
   15f20:	88 81       	ld	r24, Y
   15f22:	99 81       	ldd	r25, Y+1	; 0x01
   15f24:	aa 81       	ldd	r26, Y+2	; 0x02
   15f26:	bb 81       	ldd	r27, Y+3	; 0x03
   15f28:	00 97       	sbiw	r24, 0x00	; 0
   15f2a:	a1 05       	cpc	r26, r1
   15f2c:	b1 05       	cpc	r27, r1
   15f2e:	21 f4       	brne	.+8      	; 0x15f38 <do_random+0x26>
   15f30:	84 e2       	ldi	r24, 0x24	; 36
   15f32:	99 ed       	ldi	r25, 0xD9	; 217
   15f34:	ab e5       	ldi	r26, 0x5B	; 91
   15f36:	b7 e0       	ldi	r27, 0x07	; 7
   15f38:	bc 01       	movw	r22, r24
   15f3a:	cd 01       	movw	r24, r26
   15f3c:	2d e1       	ldi	r18, 0x1D	; 29
   15f3e:	33 ef       	ldi	r19, 0xF3	; 243
   15f40:	41 e0       	ldi	r20, 0x01	; 1
   15f42:	50 e0       	ldi	r21, 0x00	; 0
   15f44:	0e 94 cf ad 	call	0x15b9e	; 0x15b9e <__divmodsi4>
   15f48:	49 01       	movw	r8, r18
   15f4a:	5a 01       	movw	r10, r20
   15f4c:	27 ea       	ldi	r18, 0xA7	; 167
   15f4e:	31 e4       	ldi	r19, 0x41	; 65
   15f50:	40 e0       	ldi	r20, 0x00	; 0
   15f52:	50 e0       	ldi	r21, 0x00	; 0
   15f54:	0e 94 9d ad 	call	0x15b3a	; 0x15b3a <__mulsi3>
   15f58:	6b 01       	movw	r12, r22
   15f5a:	7c 01       	movw	r14, r24
   15f5c:	c5 01       	movw	r24, r10
   15f5e:	b4 01       	movw	r22, r8
   15f60:	2c ee       	ldi	r18, 0xEC	; 236
   15f62:	34 ef       	ldi	r19, 0xF4	; 244
   15f64:	4f ef       	ldi	r20, 0xFF	; 255
   15f66:	5f ef       	ldi	r21, 0xFF	; 255
   15f68:	0e 94 9d ad 	call	0x15b3a	; 0x15b3a <__mulsi3>
   15f6c:	dc 01       	movw	r26, r24
   15f6e:	cb 01       	movw	r24, r22
   15f70:	c8 0e       	add	r12, r24
   15f72:	d9 1e       	adc	r13, r25
   15f74:	ea 1e       	adc	r14, r26
   15f76:	fb 1e       	adc	r15, r27
   15f78:	f7 fe       	sbrs	r15, 7
   15f7a:	08 c0       	rjmp	.+16     	; 0x15f8c <do_random+0x7a>
   15f7c:	8f ef       	ldi	r24, 0xFF	; 255
   15f7e:	9f ef       	ldi	r25, 0xFF	; 255
   15f80:	af ef       	ldi	r26, 0xFF	; 255
   15f82:	bf e7       	ldi	r27, 0x7F	; 127
   15f84:	c8 0e       	add	r12, r24
   15f86:	d9 1e       	adc	r13, r25
   15f88:	ea 1e       	adc	r14, r26
   15f8a:	fb 1e       	adc	r15, r27
   15f8c:	c8 82       	st	Y, r12
   15f8e:	d9 82       	std	Y+1, r13	; 0x01
   15f90:	ea 82       	std	Y+2, r14	; 0x02
   15f92:	fb 82       	std	Y+3, r15	; 0x03
   15f94:	97 01       	movw	r18, r14
   15f96:	86 01       	movw	r16, r12
   15f98:	3f 77       	andi	r19, 0x7F	; 127
   15f9a:	b8 01       	movw	r22, r16
   15f9c:	c9 01       	movw	r24, r18
   15f9e:	cd b7       	in	r28, 0x3d	; 61
   15fa0:	de b7       	in	r29, 0x3e	; 62
   15fa2:	ec e0       	ldi	r30, 0x0C	; 12
   15fa4:	0c 94 1e ae 	jmp	0x15c3c	; 0x15c3c <__epilogue_restores__+0xc>

00015fa8 <random_r>:
   15fa8:	0e 94 89 af 	call	0x15f12	; 0x15f12 <do_random>
   15fac:	08 95       	ret

00015fae <random>:
   15fae:	8e e4       	ldi	r24, 0x4E	; 78
   15fb0:	92 e0       	ldi	r25, 0x02	; 2
   15fb2:	0e 94 89 af 	call	0x15f12	; 0x15f12 <do_random>
   15fb6:	08 95       	ret

00015fb8 <srandom>:
   15fb8:	dc 01       	movw	r26, r24
   15fba:	cb 01       	movw	r24, r22
   15fbc:	80 93 4e 02 	sts	0x024E, r24
   15fc0:	90 93 4f 02 	sts	0x024F, r25
   15fc4:	a0 93 50 02 	sts	0x0250, r26
   15fc8:	b0 93 51 02 	sts	0x0251, r27
   15fcc:	08 95       	ret

00015fce <realloc>:
   15fce:	a2 e0       	ldi	r26, 0x02	; 2
   15fd0:	b0 e0       	ldi	r27, 0x00	; 0
   15fd2:	ed ee       	ldi	r30, 0xED	; 237
   15fd4:	ff ea       	ldi	r31, 0xAF	; 175
   15fd6:	0c 94 02 ae 	jmp	0x15c04	; 0x15c04 <__prologue_saves__+0xc>
   15fda:	8c 01       	movw	r16, r24
   15fdc:	00 97       	sbiw	r24, 0x00	; 0
   15fde:	29 f4       	brne	.+10     	; 0x15fea <realloc+0x1c>
   15fe0:	cb 01       	movw	r24, r22
   15fe2:	0e 94 5a ae 	call	0x15cb4	; 0x15cb4 <malloc>
   15fe6:	8c 01       	movw	r16, r24
   15fe8:	b8 c0       	rjmp	.+368    	; 0x1615a <realloc+0x18c>
   15fea:	dc 01       	movw	r26, r24
   15fec:	a6 0f       	add	r26, r22
   15fee:	b7 1f       	adc	r27, r23
   15ff0:	fc 01       	movw	r30, r24
   15ff2:	32 97       	sbiw	r30, 0x02	; 2
   15ff4:	ae 17       	cp	r26, r30
   15ff6:	bf 07       	cpc	r27, r31
   15ff8:	08 f4       	brcc	.+2      	; 0x15ffc <realloc+0x2e>
   15ffa:	ad c0       	rjmp	.+346    	; 0x16156 <realloc+0x188>
   15ffc:	20 81       	ld	r18, Z
   15ffe:	31 81       	ldd	r19, Z+1	; 0x01
   16000:	26 17       	cp	r18, r22
   16002:	37 07       	cpc	r19, r23
   16004:	b0 f0       	brcs	.+44     	; 0x16032 <realloc+0x64>
   16006:	25 30       	cpi	r18, 0x05	; 5
   16008:	31 05       	cpc	r19, r1
   1600a:	08 f4       	brcc	.+2      	; 0x1600e <realloc+0x40>
   1600c:	a6 c0       	rjmp	.+332    	; 0x1615a <realloc+0x18c>
   1600e:	c9 01       	movw	r24, r18
   16010:	04 97       	sbiw	r24, 0x04	; 4
   16012:	86 17       	cp	r24, r22
   16014:	97 07       	cpc	r25, r23
   16016:	08 f4       	brcc	.+2      	; 0x1601a <realloc+0x4c>
   16018:	a0 c0       	rjmp	.+320    	; 0x1615a <realloc+0x18c>
   1601a:	22 50       	subi	r18, 0x02	; 2
   1601c:	30 40       	sbci	r19, 0x00	; 0
   1601e:	26 1b       	sub	r18, r22
   16020:	37 0b       	sbc	r19, r23
   16022:	2d 93       	st	X+, r18
   16024:	3d 93       	st	X+, r19
   16026:	cd 01       	movw	r24, r26
   16028:	71 83       	std	Z+1, r23	; 0x01
   1602a:	60 83       	st	Z, r22
   1602c:	0e 94 f0 ae 	call	0x15de0	; 0x15de0 <free>
   16030:	94 c0       	rjmp	.+296    	; 0x1615a <realloc+0x18c>
   16032:	6b 01       	movw	r12, r22
   16034:	c2 1a       	sub	r12, r18
   16036:	d3 0a       	sbc	r13, r19
   16038:	5c 01       	movw	r10, r24
   1603a:	a2 0e       	add	r10, r18
   1603c:	b3 1e       	adc	r11, r19
   1603e:	e0 91 b0 09 	lds	r30, 0x09B0
   16042:	f0 91 b1 09 	lds	r31, 0x09B1
   16046:	40 e0       	ldi	r20, 0x00	; 0
   16048:	50 e0       	ldi	r21, 0x00	; 0
   1604a:	88 24       	eor	r8, r8
   1604c:	99 24       	eor	r9, r9
   1604e:	49 c0       	rjmp	.+146    	; 0x160e2 <realloc+0x114>
   16050:	ea 15       	cp	r30, r10
   16052:	fb 05       	cpc	r31, r11
   16054:	e1 f5       	brne	.+120    	; 0x160ce <realloc+0x100>
   16056:	e0 80       	ld	r14, Z
   16058:	f1 80       	ldd	r15, Z+1	; 0x01
   1605a:	c7 01       	movw	r24, r14
   1605c:	02 96       	adiw	r24, 0x02	; 2
   1605e:	8c 15       	cp	r24, r12
   16060:	9d 05       	cpc	r25, r13
   16062:	a8 f1       	brcs	.+106    	; 0x160ce <realloc+0x100>
   16064:	a7 01       	movw	r20, r14
   16066:	4c 19       	sub	r20, r12
   16068:	5d 09       	sbc	r21, r13
   1606a:	ca 01       	movw	r24, r20
   1606c:	02 96       	adiw	r24, 0x02	; 2
   1606e:	0f 2e       	mov	r0, r31
   16070:	fe ef       	ldi	r31, 0xFE	; 254
   16072:	cf 2e       	mov	r12, r31
   16074:	ff ef       	ldi	r31, 0xFF	; 255
   16076:	df 2e       	mov	r13, r31
   16078:	f0 2d       	mov	r31, r0
   1607a:	c0 0e       	add	r12, r16
   1607c:	d1 1e       	adc	r13, r17
   1607e:	85 30       	cpi	r24, 0x05	; 5
   16080:	91 05       	cpc	r25, r1
   16082:	78 f0       	brcs	.+30     	; 0x160a2 <realloc+0xd4>
   16084:	82 81       	ldd	r24, Z+2	; 0x02
   16086:	93 81       	ldd	r25, Z+3	; 0x03
   16088:	13 96       	adiw	r26, 0x03	; 3
   1608a:	9c 93       	st	X, r25
   1608c:	8e 93       	st	-X, r24
   1608e:	12 97       	sbiw	r26, 0x02	; 2
   16090:	11 96       	adiw	r26, 0x01	; 1
   16092:	5c 93       	st	X, r21
   16094:	4e 93       	st	-X, r20
   16096:	f6 01       	movw	r30, r12
   16098:	71 83       	std	Z+1, r23	; 0x01
   1609a:	60 83       	st	Z, r22
   1609c:	9a 2f       	mov	r25, r26
   1609e:	8b 2f       	mov	r24, r27
   160a0:	0a c0       	rjmp	.+20     	; 0x160b6 <realloc+0xe8>
   160a2:	c9 01       	movw	r24, r18
   160a4:	02 96       	adiw	r24, 0x02	; 2
   160a6:	8e 0d       	add	r24, r14
   160a8:	9f 1d       	adc	r25, r15
   160aa:	d6 01       	movw	r26, r12
   160ac:	11 96       	adiw	r26, 0x01	; 1
   160ae:	9c 93       	st	X, r25
   160b0:	8e 93       	st	-X, r24
   160b2:	92 81       	ldd	r25, Z+2	; 0x02
   160b4:	83 81       	ldd	r24, Z+3	; 0x03
   160b6:	81 14       	cp	r8, r1
   160b8:	91 04       	cpc	r9, r1
   160ba:	21 f0       	breq	.+8      	; 0x160c4 <realloc+0xf6>
   160bc:	f4 01       	movw	r30, r8
   160be:	92 83       	std	Z+2, r25	; 0x02
   160c0:	83 83       	std	Z+3, r24	; 0x03
   160c2:	4b c0       	rjmp	.+150    	; 0x1615a <realloc+0x18c>
   160c4:	90 93 b0 09 	sts	0x09B0, r25
   160c8:	80 93 b1 09 	sts	0x09B1, r24
   160cc:	46 c0       	rjmp	.+140    	; 0x1615a <realloc+0x18c>
   160ce:	80 81       	ld	r24, Z
   160d0:	91 81       	ldd	r25, Z+1	; 0x01
   160d2:	48 17       	cp	r20, r24
   160d4:	59 07       	cpc	r21, r25
   160d6:	08 f4       	brcc	.+2      	; 0x160da <realloc+0x10c>
   160d8:	ac 01       	movw	r20, r24
   160da:	82 81       	ldd	r24, Z+2	; 0x02
   160dc:	93 81       	ldd	r25, Z+3	; 0x03
   160de:	4f 01       	movw	r8, r30
   160e0:	fc 01       	movw	r30, r24
   160e2:	30 97       	sbiw	r30, 0x00	; 0
   160e4:	09 f0       	breq	.+2      	; 0x160e8 <realloc+0x11a>
   160e6:	b4 cf       	rjmp	.-152    	; 0x16050 <realloc+0x82>
   160e8:	80 91 ae 09 	lds	r24, 0x09AE
   160ec:	90 91 af 09 	lds	r25, 0x09AF
   160f0:	8a 15       	cp	r24, r10
   160f2:	9b 05       	cpc	r25, r11
   160f4:	e9 f4       	brne	.+58     	; 0x16130 <realloc+0x162>
   160f6:	46 17       	cp	r20, r22
   160f8:	57 07       	cpc	r21, r23
   160fa:	d0 f4       	brcc	.+52     	; 0x16130 <realloc+0x162>
   160fc:	80 91 48 02 	lds	r24, 0x0248
   16100:	90 91 49 02 	lds	r25, 0x0249
   16104:	00 97       	sbiw	r24, 0x00	; 0
   16106:	41 f4       	brne	.+16     	; 0x16118 <realloc+0x14a>
   16108:	8d b7       	in	r24, 0x3d	; 61
   1610a:	9e b7       	in	r25, 0x3e	; 62
   1610c:	20 91 4c 02 	lds	r18, 0x024C
   16110:	30 91 4d 02 	lds	r19, 0x024D
   16114:	82 1b       	sub	r24, r18
   16116:	93 0b       	sbc	r25, r19
   16118:	a8 17       	cp	r26, r24
   1611a:	b9 07       	cpc	r27, r25
   1611c:	e0 f4       	brcc	.+56     	; 0x16156 <realloc+0x188>
   1611e:	b0 93 af 09 	sts	0x09AF, r27
   16122:	a0 93 ae 09 	sts	0x09AE, r26
   16126:	f8 01       	movw	r30, r16
   16128:	32 97       	sbiw	r30, 0x02	; 2
   1612a:	71 83       	std	Z+1, r23	; 0x01
   1612c:	60 83       	st	Z, r22
   1612e:	15 c0       	rjmp	.+42     	; 0x1615a <realloc+0x18c>
   16130:	cb 01       	movw	r24, r22
   16132:	29 83       	std	Y+1, r18	; 0x01
   16134:	3a 83       	std	Y+2, r19	; 0x02
   16136:	0e 94 5a ae 	call	0x15cb4	; 0x15cb4 <malloc>
   1613a:	7c 01       	movw	r14, r24
   1613c:	29 81       	ldd	r18, Y+1	; 0x01
   1613e:	3a 81       	ldd	r19, Y+2	; 0x02
   16140:	00 97       	sbiw	r24, 0x00	; 0
   16142:	49 f0       	breq	.+18     	; 0x16156 <realloc+0x188>
   16144:	b8 01       	movw	r22, r16
   16146:	a9 01       	movw	r20, r18
   16148:	0e 94 fe b0 	call	0x161fc	; 0x161fc <memcpy>
   1614c:	c8 01       	movw	r24, r16
   1614e:	0e 94 f0 ae 	call	0x15de0	; 0x15de0 <free>
   16152:	87 01       	movw	r16, r14
   16154:	02 c0       	rjmp	.+4      	; 0x1615a <realloc+0x18c>
   16156:	00 e0       	ldi	r16, 0x00	; 0
   16158:	10 e0       	ldi	r17, 0x00	; 0
   1615a:	c8 01       	movw	r24, r16
   1615c:	22 96       	adiw	r28, 0x02	; 2
   1615e:	ec e0       	ldi	r30, 0x0C	; 12
   16160:	0c 94 1e ae 	jmp	0x15c3c	; 0x15c3c <__epilogue_restores__+0xc>

00016164 <atol>:
   16164:	1f 93       	push	r17
   16166:	fc 01       	movw	r30, r24
   16168:	99 27       	eor	r25, r25
   1616a:	88 27       	eor	r24, r24
   1616c:	bc 01       	movw	r22, r24
   1616e:	e8 94       	clt
   16170:	11 91       	ld	r17, Z+
   16172:	10 32       	cpi	r17, 0x20	; 32
   16174:	e9 f3       	breq	.-6      	; 0x16170 <atol+0xc>
   16176:	19 30       	cpi	r17, 0x09	; 9
   16178:	10 f0       	brcs	.+4      	; 0x1617e <atol+0x1a>
   1617a:	1e 30       	cpi	r17, 0x0E	; 14
   1617c:	c8 f3       	brcs	.-14     	; 0x16170 <atol+0xc>
   1617e:	1b 32       	cpi	r17, 0x2B	; 43
   16180:	51 f0       	breq	.+20     	; 0x16196 <atol+0x32>
   16182:	1d 32       	cpi	r17, 0x2D	; 45
   16184:	49 f4       	brne	.+18     	; 0x16198 <atol+0x34>
   16186:	68 94       	set
   16188:	06 c0       	rjmp	.+12     	; 0x16196 <atol+0x32>
   1618a:	0e 94 db b1 	call	0x163b6	; 0x163b6 <__mulsi_const_10>
   1618e:	61 0f       	add	r22, r17
   16190:	71 1d       	adc	r23, r1
   16192:	81 1d       	adc	r24, r1
   16194:	91 1d       	adc	r25, r1
   16196:	11 91       	ld	r17, Z+
   16198:	10 53       	subi	r17, 0x30	; 48
   1619a:	1a 30       	cpi	r17, 0x0A	; 10
   1619c:	b0 f3       	brcs	.-20     	; 0x1618a <atol+0x26>
   1619e:	3e f4       	brtc	.+14     	; 0x161ae <atol+0x4a>
   161a0:	90 95       	com	r25
   161a2:	80 95       	com	r24
   161a4:	70 95       	com	r23
   161a6:	61 95       	neg	r22
   161a8:	7f 4f       	sbci	r23, 0xFF	; 255
   161aa:	8f 4f       	sbci	r24, 0xFF	; 255
   161ac:	9f 4f       	sbci	r25, 0xFF	; 255
   161ae:	1f 91       	pop	r17
   161b0:	08 95       	ret

000161b2 <isspace>:
   161b2:	91 11       	cpse	r25, r1
   161b4:	66 c1       	rjmp	.+716    	; 0x16482 <__ctype_isfalse>
   161b6:	80 32       	cpi	r24, 0x20	; 32
   161b8:	19 f0       	breq	.+6      	; 0x161c0 <isspace+0xe>
   161ba:	89 50       	subi	r24, 0x09	; 9
   161bc:	85 50       	subi	r24, 0x05	; 5
   161be:	d0 f7       	brcc	.-12     	; 0x161b4 <isspace+0x2>
   161c0:	08 95       	ret

000161c2 <tolower>:
   161c2:	91 11       	cpse	r25, r1
   161c4:	08 95       	ret
   161c6:	81 54       	subi	r24, 0x41	; 65
   161c8:	8a 51       	subi	r24, 0x1A	; 26
   161ca:	08 f4       	brcc	.+2      	; 0x161ce <tolower+0xc>
   161cc:	80 5e       	subi	r24, 0xE0	; 224
   161ce:	85 5a       	subi	r24, 0xA5	; 165
   161d0:	08 95       	ret

000161d2 <toupper>:
   161d2:	91 11       	cpse	r25, r1
   161d4:	08 95       	ret
   161d6:	81 56       	subi	r24, 0x61	; 97
   161d8:	8a 51       	subi	r24, 0x1A	; 26
   161da:	08 f4       	brcc	.+2      	; 0x161de <toupper+0xc>
   161dc:	80 52       	subi	r24, 0x20	; 32
   161de:	85 58       	subi	r24, 0x85	; 133
   161e0:	08 95       	ret

000161e2 <memcmp>:
   161e2:	fb 01       	movw	r30, r22
   161e4:	dc 01       	movw	r26, r24
   161e6:	04 c0       	rjmp	.+8      	; 0x161f0 <memcmp+0xe>
   161e8:	8d 91       	ld	r24, X+
   161ea:	01 90       	ld	r0, Z+
   161ec:	80 19       	sub	r24, r0
   161ee:	21 f4       	brne	.+8      	; 0x161f8 <memcmp+0x16>
   161f0:	41 50       	subi	r20, 0x01	; 1
   161f2:	50 40       	sbci	r21, 0x00	; 0
   161f4:	c8 f7       	brcc	.-14     	; 0x161e8 <memcmp+0x6>
   161f6:	88 1b       	sub	r24, r24
   161f8:	99 0b       	sbc	r25, r25
   161fa:	08 95       	ret

000161fc <memcpy>:
   161fc:	fb 01       	movw	r30, r22
   161fe:	dc 01       	movw	r26, r24
   16200:	02 c0       	rjmp	.+4      	; 0x16206 <memcpy+0xa>
   16202:	01 90       	ld	r0, Z+
   16204:	0d 92       	st	X+, r0
   16206:	41 50       	subi	r20, 0x01	; 1
   16208:	50 40       	sbci	r21, 0x00	; 0
   1620a:	d8 f7       	brcc	.-10     	; 0x16202 <memcpy+0x6>
   1620c:	08 95       	ret

0001620e <memmove>:
   1620e:	68 17       	cp	r22, r24
   16210:	79 07       	cpc	r23, r25
   16212:	68 f4       	brcc	.+26     	; 0x1622e <memmove+0x20>
   16214:	fb 01       	movw	r30, r22
   16216:	dc 01       	movw	r26, r24
   16218:	e4 0f       	add	r30, r20
   1621a:	f5 1f       	adc	r31, r21
   1621c:	a4 0f       	add	r26, r20
   1621e:	b5 1f       	adc	r27, r21
   16220:	02 c0       	rjmp	.+4      	; 0x16226 <memmove+0x18>
   16222:	02 90       	ld	r0, -Z
   16224:	0e 92       	st	-X, r0
   16226:	41 50       	subi	r20, 0x01	; 1
   16228:	50 40       	sbci	r21, 0x00	; 0
   1622a:	d8 f7       	brcc	.-10     	; 0x16222 <memmove+0x14>
   1622c:	08 95       	ret
   1622e:	0c 94 fe b0 	jmp	0x161fc	; 0x161fc <memcpy>

00016232 <memset>:
   16232:	dc 01       	movw	r26, r24
   16234:	01 c0       	rjmp	.+2      	; 0x16238 <memset+0x6>
   16236:	6d 93       	st	X+, r22
   16238:	41 50       	subi	r20, 0x01	; 1
   1623a:	50 40       	sbci	r21, 0x00	; 0
   1623c:	e0 f7       	brcc	.-8      	; 0x16236 <memset+0x4>
   1623e:	08 95       	ret

00016240 <strchr>:
   16240:	fc 01       	movw	r30, r24
   16242:	81 91       	ld	r24, Z+
   16244:	86 17       	cp	r24, r22
   16246:	21 f0       	breq	.+8      	; 0x16250 <strchr+0x10>
   16248:	88 23       	and	r24, r24
   1624a:	d9 f7       	brne	.-10     	; 0x16242 <strchr+0x2>
   1624c:	99 27       	eor	r25, r25
   1624e:	08 95       	ret
   16250:	31 97       	sbiw	r30, 0x01	; 1
   16252:	cf 01       	movw	r24, r30
   16254:	08 95       	ret

00016256 <strcmp>:
   16256:	fb 01       	movw	r30, r22
   16258:	dc 01       	movw	r26, r24
   1625a:	8d 91       	ld	r24, X+
   1625c:	01 90       	ld	r0, Z+
   1625e:	80 19       	sub	r24, r0
   16260:	01 10       	cpse	r0, r1
   16262:	d9 f3       	breq	.-10     	; 0x1625a <strcmp+0x4>
   16264:	99 0b       	sbc	r25, r25
   16266:	08 95       	ret

00016268 <strcpy>:
   16268:	fb 01       	movw	r30, r22
   1626a:	dc 01       	movw	r26, r24
   1626c:	01 90       	ld	r0, Z+
   1626e:	0d 92       	st	X+, r0
   16270:	00 20       	and	r0, r0
   16272:	e1 f7       	brne	.-8      	; 0x1626c <strcpy+0x4>
   16274:	08 95       	ret

00016276 <strlen>:
   16276:	fc 01       	movw	r30, r24
   16278:	01 90       	ld	r0, Z+
   1627a:	00 20       	and	r0, r0
   1627c:	e9 f7       	brne	.-6      	; 0x16278 <strlen+0x2>
   1627e:	80 95       	com	r24
   16280:	90 95       	com	r25
   16282:	8e 0f       	add	r24, r30
   16284:	9f 1f       	adc	r25, r31
   16286:	08 95       	ret

00016288 <strncmp>:
   16288:	fb 01       	movw	r30, r22
   1628a:	dc 01       	movw	r26, r24
   1628c:	41 50       	subi	r20, 0x01	; 1
   1628e:	50 40       	sbci	r21, 0x00	; 0
   16290:	30 f0       	brcs	.+12     	; 0x1629e <strncmp+0x16>
   16292:	8d 91       	ld	r24, X+
   16294:	01 90       	ld	r0, Z+
   16296:	80 19       	sub	r24, r0
   16298:	19 f4       	brne	.+6      	; 0x162a0 <strncmp+0x18>
   1629a:	00 20       	and	r0, r0
   1629c:	b9 f7       	brne	.-18     	; 0x1628c <strncmp+0x4>
   1629e:	88 1b       	sub	r24, r24
   162a0:	99 0b       	sbc	r25, r25
   162a2:	08 95       	ret

000162a4 <strncpy>:
   162a4:	fb 01       	movw	r30, r22
   162a6:	dc 01       	movw	r26, r24
   162a8:	41 50       	subi	r20, 0x01	; 1
   162aa:	50 40       	sbci	r21, 0x00	; 0
   162ac:	48 f0       	brcs	.+18     	; 0x162c0 <strncpy+0x1c>
   162ae:	01 90       	ld	r0, Z+
   162b0:	0d 92       	st	X+, r0
   162b2:	00 20       	and	r0, r0
   162b4:	c9 f7       	brne	.-14     	; 0x162a8 <strncpy+0x4>
   162b6:	01 c0       	rjmp	.+2      	; 0x162ba <strncpy+0x16>
   162b8:	1d 92       	st	X+, r1
   162ba:	41 50       	subi	r20, 0x01	; 1
   162bc:	50 40       	sbci	r21, 0x00	; 0
   162be:	e0 f7       	brcc	.-8      	; 0x162b8 <strncpy+0x14>
   162c0:	08 95       	ret

000162c2 <strrchr>:
   162c2:	fc 01       	movw	r30, r24
   162c4:	81 e0       	ldi	r24, 0x01	; 1
   162c6:	90 e0       	ldi	r25, 0x00	; 0
   162c8:	01 90       	ld	r0, Z+
   162ca:	06 16       	cp	r0, r22
   162cc:	09 f4       	brne	.+2      	; 0x162d0 <strrchr+0xe>
   162ce:	cf 01       	movw	r24, r30
   162d0:	00 20       	and	r0, r0
   162d2:	d1 f7       	brne	.-12     	; 0x162c8 <strrchr+0x6>
   162d4:	01 97       	sbiw	r24, 0x01	; 1
   162d6:	08 95       	ret

000162d8 <strstr>:
   162d8:	fb 01       	movw	r30, r22
   162da:	51 91       	ld	r21, Z+
   162dc:	55 23       	and	r21, r21
   162de:	a9 f0       	breq	.+42     	; 0x1630a <strstr+0x32>
   162e0:	bf 01       	movw	r22, r30
   162e2:	dc 01       	movw	r26, r24
   162e4:	4d 91       	ld	r20, X+
   162e6:	45 17       	cp	r20, r21
   162e8:	41 11       	cpse	r20, r1
   162ea:	e1 f7       	brne	.-8      	; 0x162e4 <strstr+0xc>
   162ec:	59 f4       	brne	.+22     	; 0x16304 <strstr+0x2c>
   162ee:	cd 01       	movw	r24, r26
   162f0:	01 90       	ld	r0, Z+
   162f2:	00 20       	and	r0, r0
   162f4:	49 f0       	breq	.+18     	; 0x16308 <strstr+0x30>
   162f6:	4d 91       	ld	r20, X+
   162f8:	40 15       	cp	r20, r0
   162fa:	41 11       	cpse	r20, r1
   162fc:	c9 f3       	breq	.-14     	; 0x162f0 <strstr+0x18>
   162fe:	fb 01       	movw	r30, r22
   16300:	41 11       	cpse	r20, r1
   16302:	ef cf       	rjmp	.-34     	; 0x162e2 <strstr+0xa>
   16304:	81 e0       	ldi	r24, 0x01	; 1
   16306:	90 e0       	ldi	r25, 0x00	; 0
   16308:	01 97       	sbiw	r24, 0x01	; 1
   1630a:	08 95       	ret

0001630c <itoa>:
   1630c:	fb 01       	movw	r30, r22
   1630e:	9f 01       	movw	r18, r30
   16310:	e8 94       	clt
   16312:	42 30       	cpi	r20, 0x02	; 2
   16314:	c4 f0       	brlt	.+48     	; 0x16346 <itoa+0x3a>
   16316:	45 32       	cpi	r20, 0x25	; 37
   16318:	b4 f4       	brge	.+44     	; 0x16346 <itoa+0x3a>
   1631a:	4a 30       	cpi	r20, 0x0A	; 10
   1631c:	29 f4       	brne	.+10     	; 0x16328 <itoa+0x1c>
   1631e:	97 fb       	bst	r25, 7
   16320:	1e f4       	brtc	.+6      	; 0x16328 <itoa+0x1c>
   16322:	90 95       	com	r25
   16324:	81 95       	neg	r24
   16326:	9f 4f       	sbci	r25, 0xFF	; 255
   16328:	64 2f       	mov	r22, r20
   1632a:	77 27       	eor	r23, r23
   1632c:	0e 94 54 b2 	call	0x164a8	; 0x164a8 <__udivmodhi4>
   16330:	80 5d       	subi	r24, 0xD0	; 208
   16332:	8a 33       	cpi	r24, 0x3A	; 58
   16334:	0c f0       	brlt	.+2      	; 0x16338 <itoa+0x2c>
   16336:	89 5d       	subi	r24, 0xD9	; 217
   16338:	81 93       	st	Z+, r24
   1633a:	cb 01       	movw	r24, r22
   1633c:	00 97       	sbiw	r24, 0x00	; 0
   1633e:	a1 f7       	brne	.-24     	; 0x16328 <itoa+0x1c>
   16340:	16 f4       	brtc	.+4      	; 0x16346 <itoa+0x3a>
   16342:	5d e2       	ldi	r21, 0x2D	; 45
   16344:	51 93       	st	Z+, r21
   16346:	10 82       	st	Z, r1
   16348:	c9 01       	movw	r24, r18
   1634a:	0c 94 44 b2 	jmp	0x16488	; 0x16488 <strrev>

0001634e <ltoa>:
   1634e:	fa 01       	movw	r30, r20
   16350:	cf 93       	push	r28
   16352:	ff 93       	push	r31
   16354:	ef 93       	push	r30
   16356:	22 30       	cpi	r18, 0x02	; 2
   16358:	44 f1       	brlt	.+80     	; 0x163aa <ltoa+0x5c>
   1635a:	25 32       	cpi	r18, 0x25	; 37
   1635c:	34 f5       	brge	.+76     	; 0x163aa <ltoa+0x5c>
   1635e:	c2 2f       	mov	r28, r18
   16360:	e8 94       	clt
   16362:	ca 30       	cpi	r28, 0x0A	; 10
   16364:	49 f4       	brne	.+18     	; 0x16378 <ltoa+0x2a>
   16366:	97 fb       	bst	r25, 7
   16368:	3e f4       	brtc	.+14     	; 0x16378 <ltoa+0x2a>
   1636a:	90 95       	com	r25
   1636c:	80 95       	com	r24
   1636e:	70 95       	com	r23
   16370:	61 95       	neg	r22
   16372:	7f 4f       	sbci	r23, 0xFF	; 255
   16374:	8f 4f       	sbci	r24, 0xFF	; 255
   16376:	9f 4f       	sbci	r25, 0xFF	; 255
   16378:	2c 2f       	mov	r18, r28
   1637a:	33 27       	eor	r19, r19
   1637c:	44 27       	eor	r20, r20
   1637e:	55 27       	eor	r21, r21
   16380:	ff 93       	push	r31
   16382:	ef 93       	push	r30
   16384:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
   16388:	ef 91       	pop	r30
   1638a:	ff 91       	pop	r31
   1638c:	60 5d       	subi	r22, 0xD0	; 208
   1638e:	6a 33       	cpi	r22, 0x3A	; 58
   16390:	0c f0       	brlt	.+2      	; 0x16394 <ltoa+0x46>
   16392:	69 5d       	subi	r22, 0xD9	; 217
   16394:	61 93       	st	Z+, r22
   16396:	b9 01       	movw	r22, r18
   16398:	ca 01       	movw	r24, r20
   1639a:	60 50       	subi	r22, 0x00	; 0
   1639c:	70 40       	sbci	r23, 0x00	; 0
   1639e:	80 40       	sbci	r24, 0x00	; 0
   163a0:	90 40       	sbci	r25, 0x00	; 0
   163a2:	51 f7       	brne	.-44     	; 0x16378 <ltoa+0x2a>
   163a4:	16 f4       	brtc	.+4      	; 0x163aa <ltoa+0x5c>
   163a6:	cd e2       	ldi	r28, 0x2D	; 45
   163a8:	c1 93       	st	Z+, r28
   163aa:	10 82       	st	Z, r1
   163ac:	8f 91       	pop	r24
   163ae:	9f 91       	pop	r25
   163b0:	cf 91       	pop	r28
   163b2:	0c 94 44 b2 	jmp	0x16488	; 0x16488 <strrev>

000163b6 <__mulsi_const_10>:
   163b6:	59 2f       	mov	r21, r25
   163b8:	48 2f       	mov	r20, r24
   163ba:	37 2f       	mov	r19, r23
   163bc:	26 2f       	mov	r18, r22
   163be:	66 0f       	add	r22, r22
   163c0:	77 1f       	adc	r23, r23
   163c2:	88 1f       	adc	r24, r24
   163c4:	99 1f       	adc	r25, r25
   163c6:	66 0f       	add	r22, r22
   163c8:	77 1f       	adc	r23, r23
   163ca:	88 1f       	adc	r24, r24
   163cc:	99 1f       	adc	r25, r25
   163ce:	62 0f       	add	r22, r18
   163d0:	73 1f       	adc	r23, r19
   163d2:	84 1f       	adc	r24, r20
   163d4:	95 1f       	adc	r25, r21
   163d6:	66 0f       	add	r22, r22
   163d8:	77 1f       	adc	r23, r23
   163da:	88 1f       	adc	r24, r24
   163dc:	99 1f       	adc	r25, r25
   163de:	08 95       	ret

000163e0 <ultoa>:
   163e0:	fa 01       	movw	r30, r20
   163e2:	cf 93       	push	r28
   163e4:	ff 93       	push	r31
   163e6:	ef 93       	push	r30
   163e8:	22 30       	cpi	r18, 0x02	; 2
   163ea:	cc f0       	brlt	.+50     	; 0x1641e <ultoa+0x3e>
   163ec:	25 32       	cpi	r18, 0x25	; 37
   163ee:	bc f4       	brge	.+46     	; 0x1641e <ultoa+0x3e>
   163f0:	c2 2f       	mov	r28, r18
   163f2:	2c 2f       	mov	r18, r28
   163f4:	33 27       	eor	r19, r19
   163f6:	44 27       	eor	r20, r20
   163f8:	55 27       	eor	r21, r21
   163fa:	ff 93       	push	r31
   163fc:	ef 93       	push	r30
   163fe:	0e 94 ad ad 	call	0x15b5a	; 0x15b5a <__udivmodsi4>
   16402:	ef 91       	pop	r30
   16404:	ff 91       	pop	r31
   16406:	60 5d       	subi	r22, 0xD0	; 208
   16408:	6a 33       	cpi	r22, 0x3A	; 58
   1640a:	0c f0       	brlt	.+2      	; 0x1640e <ultoa+0x2e>
   1640c:	69 5d       	subi	r22, 0xD9	; 217
   1640e:	61 93       	st	Z+, r22
   16410:	b9 01       	movw	r22, r18
   16412:	ca 01       	movw	r24, r20
   16414:	60 50       	subi	r22, 0x00	; 0
   16416:	70 40       	sbci	r23, 0x00	; 0
   16418:	80 40       	sbci	r24, 0x00	; 0
   1641a:	90 40       	sbci	r25, 0x00	; 0
   1641c:	51 f7       	brne	.-44     	; 0x163f2 <ultoa+0x12>
   1641e:	10 82       	st	Z, r1
   16420:	8f 91       	pop	r24
   16422:	9f 91       	pop	r25
   16424:	cf 91       	pop	r28
   16426:	0c 94 44 b2 	jmp	0x16488	; 0x16488 <strrev>

0001642a <utoa>:
   1642a:	fb 01       	movw	r30, r22
   1642c:	9f 01       	movw	r18, r30
   1642e:	42 30       	cpi	r20, 0x02	; 2
   16430:	74 f0       	brlt	.+28     	; 0x1644e <utoa+0x24>
   16432:	45 32       	cpi	r20, 0x25	; 37
   16434:	64 f4       	brge	.+24     	; 0x1644e <utoa+0x24>
   16436:	64 2f       	mov	r22, r20
   16438:	77 27       	eor	r23, r23
   1643a:	0e 94 54 b2 	call	0x164a8	; 0x164a8 <__udivmodhi4>
   1643e:	80 5d       	subi	r24, 0xD0	; 208
   16440:	8a 33       	cpi	r24, 0x3A	; 58
   16442:	0c f0       	brlt	.+2      	; 0x16446 <utoa+0x1c>
   16444:	89 5d       	subi	r24, 0xD9	; 217
   16446:	81 93       	st	Z+, r24
   16448:	cb 01       	movw	r24, r22
   1644a:	00 97       	sbiw	r24, 0x00	; 0
   1644c:	a1 f7       	brne	.-24     	; 0x16436 <utoa+0xc>
   1644e:	10 82       	st	Z, r1
   16450:	c9 01       	movw	r24, r18
   16452:	0c 94 44 b2 	jmp	0x16488	; 0x16488 <strrev>

00016456 <__eerd_byte_m328p>:
   16456:	f9 99       	sbic	0x1f, 1	; 31
   16458:	fe cf       	rjmp	.-4      	; 0x16456 <__eerd_byte_m328p>
   1645a:	92 bd       	out	0x22, r25	; 34
   1645c:	81 bd       	out	0x21, r24	; 33
   1645e:	f8 9a       	sbi	0x1f, 0	; 31
   16460:	99 27       	eor	r25, r25
   16462:	80 b5       	in	r24, 0x20	; 32
   16464:	08 95       	ret

00016466 <__eewr_byte_m328p>:
   16466:	26 2f       	mov	r18, r22

00016468 <__eewr_r18_m328p>:
   16468:	f9 99       	sbic	0x1f, 1	; 31
   1646a:	fe cf       	rjmp	.-4      	; 0x16468 <__eewr_r18_m328p>
   1646c:	1f ba       	out	0x1f, r1	; 31
   1646e:	92 bd       	out	0x22, r25	; 34
   16470:	81 bd       	out	0x21, r24	; 33
   16472:	20 bd       	out	0x20, r18	; 32
   16474:	0f b6       	in	r0, 0x3f	; 63
   16476:	f8 94       	cli
   16478:	fa 9a       	sbi	0x1f, 2	; 31
   1647a:	f9 9a       	sbi	0x1f, 1	; 31
   1647c:	0f be       	out	0x3f, r0	; 63
   1647e:	01 96       	adiw	r24, 0x01	; 1
   16480:	08 95       	ret

00016482 <__ctype_isfalse>:
   16482:	99 27       	eor	r25, r25
   16484:	88 27       	eor	r24, r24

00016486 <__ctype_istrue>:
   16486:	08 95       	ret

00016488 <strrev>:
   16488:	dc 01       	movw	r26, r24
   1648a:	fc 01       	movw	r30, r24
   1648c:	67 2f       	mov	r22, r23
   1648e:	71 91       	ld	r23, Z+
   16490:	77 23       	and	r23, r23
   16492:	e1 f7       	brne	.-8      	; 0x1648c <strrev+0x4>
   16494:	32 97       	sbiw	r30, 0x02	; 2
   16496:	04 c0       	rjmp	.+8      	; 0x164a0 <strrev+0x18>
   16498:	7c 91       	ld	r23, X
   1649a:	6d 93       	st	X+, r22
   1649c:	70 83       	st	Z, r23
   1649e:	62 91       	ld	r22, -Z
   164a0:	ae 17       	cp	r26, r30
   164a2:	bf 07       	cpc	r27, r31
   164a4:	c8 f3       	brcs	.-14     	; 0x16498 <strrev+0x10>
   164a6:	08 95       	ret

000164a8 <__udivmodhi4>:
   164a8:	aa 1b       	sub	r26, r26
   164aa:	bb 1b       	sub	r27, r27
   164ac:	51 e1       	ldi	r21, 0x11	; 17
   164ae:	07 c0       	rjmp	.+14     	; 0x164be <__udivmodhi4_ep>

000164b0 <__udivmodhi4_loop>:
   164b0:	aa 1f       	adc	r26, r26
   164b2:	bb 1f       	adc	r27, r27
   164b4:	a6 17       	cp	r26, r22
   164b6:	b7 07       	cpc	r27, r23
   164b8:	10 f0       	brcs	.+4      	; 0x164be <__udivmodhi4_ep>
   164ba:	a6 1b       	sub	r26, r22
   164bc:	b7 0b       	sbc	r27, r23

000164be <__udivmodhi4_ep>:
   164be:	88 1f       	adc	r24, r24
   164c0:	99 1f       	adc	r25, r25
   164c2:	5a 95       	dec	r21
   164c4:	a9 f7       	brne	.-22     	; 0x164b0 <__udivmodhi4_loop>
   164c6:	80 95       	com	r24
   164c8:	90 95       	com	r25
   164ca:	bc 01       	movw	r22, r24
   164cc:	cd 01       	movw	r24, r26
   164ce:	08 95       	ret

000164d0 <_exit>:
   164d0:	f8 94       	cli

000164d2 <__stop_program>:
   164d2:	ff cf       	rjmp	.-2      	; 0x164d2 <__stop_program>
