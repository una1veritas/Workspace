%#!jlatex
%
% 知能情報工学実験演習 I (2) C++演習 テキスト
% text02a.tex - 03/10/17 版 - 乃万 司
%
\documentstyle[11pt]{j-article}
\renewcommand{\@}[1]{{\bf #1}}
\title{{\normalsize 知能情報工学実験演習 I -- 2} \\
\bf C++演習}
\author{担当: 下薗真一・乃万　司・山本邦雄・松元隆二
(TA: 山崎健太郎)	\\
E-mail: \footnotesize
{\sf \{sin,noma,kunio,matumoto\}@ai.kyutech.ac.jp},
{\sf k\_yama@pluto.ai.kyutech.ac.jp}}
\date{第一版 \ 2003 年 10 月}
%
% 諸定義
%
\def\linesparpage#1{\baselineskip=\textheight\divide\baselineskip#1}
%%%%% 演習問題の表示 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcounter{execnumber}
\setcounter{execnumber}{0}
\newcommand{\EXERCISE}[1]{
 \medskip
 \refstepcounter{execnumber}
 \begin{center}
  \fbox{
   \begin{minipage}{\textwidth}
    \noindent
    {\bf 演習 \arabic{execnumber}}
    #1
   \end{minipage}
  }
 \end{center}
 \medskip
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ワンポイントの表示 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcounter{pntnumber}
\setcounter{pntnumber}{0}
\newcommand{\POINT}[2]{
 \medskip
 \refstepcounter{pntnumber}
\noindent
■■■■■ {\sf Point \arabic{pntnumber}:} {\bf #1} \hrulefill ■ \\
{\small #2}

\noindent
■ \hrulefill ■■■■■ \\
% \begin{center}
%  \fbox{
%   \begin{minipage}{\textwidth}
%    \noindent
%    {\bf ポイント \arabic{pntnumber} (#1)}
%    #2
%   \end{minipage}
%  }
% \end{center}
 \medskip
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 本文
%
\begin{document}
\linesparpage{40}
\maketitle

\medskip

\begin{quote}
\begin{description}
\item[期間:] 第 2 年次後期, 毎週金曜日午後
\item[機材:] CAD実験室(共通教育研究棟 3 階 S303 室)の Linux PC 端末
\item[注意:] 実験は 3 回に分けて行うが，
実験・演習に割り当てられている時間以外でも，
自由に計算機を使用してかまわない．
研究棟側の端末でも実験は可能である．	\\
\underline{実験は個人単位で行ない，各人別々にプログラムを作成すること}．

\end{description}
\end{quote}

\medskip

この演習では, C 言語および C++ 言語を使うプログラミングをしながら, 役に立
つ実用的なプログラムを作るときに必要なプログラミングスタイル, つまりわか
りやすくミスの生じにくいプログラムの書き方を身につける. 
特に, 構造化プログラミングとその発展形であるオブジェクト指向プログ
ラミングの基礎を理解し使えるようになるのが目標である. 

\section{はじめに}

\subsection{プログラムを作る時にずらずらと変数宣言をするのはやめなさい}

プログラムの書きはじめに，とりあえず必要(そう)な変数を
\verb+int+とか\verb+double+などの単純な既存の型で山のように宣言して使う
人がいる．
もし自分もそうだと思うなら，{\bf 今日からやめなさい}．

プログラムが自分で一度か二度使う程度の簡単なおもちゃプログラムならそれで
もよいだろう. 
しかし「世の中の多くの人の役に立つプログラム」は，ほとんどの場合構造を持
つデータを対象に複雑な計算を行い, プログラムは大勢で共同で作ることも珍し
くない. 
とりあえずで書きはじめると, わかりにくく, ミスの生じやすいプログラムになっ
てしまうか, 後で大幅な書き直しが必要になる. 
そのような習慣は早いうちに捨てなければならない. 



\subsection{プログラムはまずデータ型から作りなさい}

Niklaus Wirth\footnote{プログラミング言語 Pascal, Modula-2 等の設計者で
あり, ACMチューリング賞を受賞した著名な計算機科学者である. }
の名著の一つに「アルゴリズム+データ構造=プログラム」という本がある. 
操作はその対象と常に対応させて考えなければならない. 
この実験演習は，「アルゴリズム+データ型=プログラム」という立場\footnote{
データ型をうまく実現する際にデータ構造を考える必要がある．
Wirth の書名は今でも意味がある．}
から, プログラムを作る際に{\bf まず「適切なデータ型」を作る}ことを習慣づ
けるのを目的としている. 

C++はクラスというメカニズムでデータ構造とその操作をはっきり対応させたプ
ログラムを書くことができる言語である．

\subsection{データ型とはある種のデータを表すモデルと操作の組合せである}

例えば，実験演習に使用中の Linux PC 端末では，
\verb+int+型も\verb+float+型も同じビット列を取ることがある\footnote{
同じ浮動小数点数でも，\verb+double+型は8ビットであるが，
\verb+float+型は\verb+int+型と同じ4ビットなので，
ここでは\verb+float+型を例にしている．}．
例えば，整数\verb+1040187392+と実数\verb+0.125F+はどちらもビット列 
\[
\verb+0011 1110 0000 0000 0000 0000 0000 0000+
\]
(\verb+3E 00 00 00+) になる. 
また，計算機のハードウェア側には，どのアドレスのデータが
\verb+int+型で，どのアドレスのデータが\verb+float+型かといった情報は存在
しない．

我々が，適切に\verb+int+型の計算と\verb+float+型の計算を
使い分けられるのは，
プログラムの中で \verb+int+型のデータには\verb+int+型の操作 (命令) が，
\verb+float+型のデータには\verb+float+型の操作が選ばれることによって，
適切に計算が行なわれるからである\footnote{
実際には\verb+float+型は\verb+double+型に変換されて計算される．}．
例えば，\verb+int+型の計算では，ビット列を\verb+int+型として
解釈して計算し，計算結果も\verb+int+型として解釈できるビット列に
直してレジスタやメモリに格納する．
つまり，{\bf データの意味は操作で決まる}．

データ型の本質は，内部表現の方法ではなく，
{\bf モデル}(例えば数学でいうところの「整数」)と
{\bf 操作}(例えば\verb+int+型の演算)にある．
このことは，たいていの場合，\verb+int+型や\verb+float+型の
内部表現を知らなくても，プログラムを書けることからも
明らかである\footnote{ふつうは
自分が使っている計算機がbig-endianかlittle-endianかすら気にしない．}．
実際，データ型がどんな内部表現だろうと，操作がその内部表現に適応していれ
ば，外部からは内部表現の違いを気にすることなく使える．


\subsection{大域変数はやめなさい}

大域変数は, プログラムのどこででも使える, 関数と関数の間でのデータ受け渡しに
使える大変便利な変数である．
しかし，プログラムが全体を見渡すことができないほど大きくなり, 関数の動作
が複雑になると, どこでどの変数を変更したか, なんのための変数だったかがわ
からなくなり，失敗やムダの原因になる. 
特に, プログラムをオブジェクト指向スタイルに移行していく上で, 大きな障害
になる. 

データを型として組み合わせひとまとまりにするように, プログラムの部分部分
で「使う変数を最少限にひとまとまりにしておく」のがプログラムをうまく作る
コツの一つである．
関数のデータのやり取りも, 関数の動作や操作対象をコンパクトかつ明確にする
ために, 引数と返り値のみで行なうべきである. 


\section{C言語で型を作る}

\subsection{データ型を言語に用意されたもの以外に拡張したものが抽象データ型である}

プログラムで必要となるデータ型には様々なものが考えられるが，
プログラミング言語があらかじめそのすべてを用意することはできない．
そこで{\bf 自分で作る}．これが{\bf 抽象データ型}である．

自分で型を作るには，以下の二つのことが必要である．
\begin{enumerate}

 \item[(1)] 1個のデータを表すために必要な変数 (データ) は，すべて一つに
	    まとめる．	\\
既存の型でも，例えば，
浮動小数点数の符号部と指数部と仮数部は必ず一まとまりにして扱う
(し，普通外部から見えないようにする)．

 \item[(2)] 1個のデータをまとめて操作する．	\\
既存の型でも，例えば，浮動小数点数の演算をすると，
符号部も指数部も仮数部も一緒に計算される．

\end{enumerate}

\subsection{データを一まとまりにするには構造体を使う}

データを一まとまりにするには，
必要なデータ(既存の型も別の抽象データ型も含む)を組み合わせることが多い．
そのためには，C言語では構造体(struct)を使う．

例えば，2次元ベクトルを表すには，
それぞれの成分を例えば \verb+double+ 型で表す必要があるから，
次のような構造体 \verb+vector2+ を作ればよい\footnote{
もちろん，長さ2の配列で表すこともできる．}．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
struct vector2 {
        double x;       /* x値 */
        double y;       /* y値 */
};
\end{verbatim}
\end{quote}

\subsection{データの操作は一まとまりのデータ単位で行なう}

データには，内部表現を気にすることなく一まとまりとして扱えるよう操作を準備する．
例えば浮動小数点数の加算では，指数部や仮数部の計算は表には見えない．
同じように，抽象データ型の操作も，その型のデータそのものを扱うような関数
を準備して使う．
こうすることによって，\underline{内部表現を変更しても操作関数を変更する
だけで済む}. 

例えば，2次元ベクトルの加法演算は，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
struct vector2 addv2(struct vector2 u, struct vector2 v)
{
        struct vector2 ret;

        ret.x = u.x + v.x;
        ret.y = u.y + v.y;

        return ret;
}
\end{verbatim}
\end{quote}
と用意し，プログラムで 2次元ベクトル同士の加算が必要なら，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
vec0 = addv2(vec1, vec2);
\end{verbatim}
\end{quote}
などと書く．
操作関数を作る手間を惜しんで，いちいち
\begin{quote}
\linesparpage{50}
\begin{verbatim}
vec0.x = vec1.x + vec2.x;
vec0.y = vec1.y + vec2.y;
\end{verbatim}
\end{quote}
などと書いていれば，かえって手間がかかるばかりでなく，後で何をしたかった
のかがわかりにくいコードになり，プログラミングを破綻させる原因になる．

\subsection{抽象データ型は関数の作り方の指針でもある}

今までは，関数の作り方は理解していても，
どの部分をまとめて一つの関数にすべきかわからなかったかもしれない．
抽象データ型では，{\bf 型の操作関数は
その型をまとめて操作する (意味のある) 関数を作る}
という立場が明確になり，関数の作り方の指針を与えてくれる．

プログラムを作る際は，組み込みの型から小さな型を，
小さな型から大きな型を作っていく．
こうすることで，
抽象度の高いレベルで処理を簡潔に記述できるようになってゆき，
自然ときれいな ------ つまり読みやすくミスの起きにくい ------
プログラムが書けるのである．

\EXERCISE{
(C言語による)2次元ベクトル型のソースファイルが，
\verb+vector2c.h+および\verb+vector2c.c+として，
またそれを使った簡単な主プログラムが\verb+vec2ex1c.c+として，
それぞれ用意されている．以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] プログラムをコンパイルし，実際に動くことを確かめよ．

\item[(2)] 減算の関数を\verb+vector2c.h+および\verb+vector2c.c+に
追加し，また，\verb+vec2ex1c.c+の主プログラムに減算のテストを追加し，
実際に動くことを確かめよ．

%%% 検討: 内積の関数
%%% 検討: 引数をポインタ型に変える演習

\end{enumerate}

}

\POINT{ソースファイルの構成法とコンパイル}{
C や C++ では，原則として，以下のようにソースファイルを分割する．

\begin{enumerate}

 \item[(a)] {\bf ヘッダファイル}	\\
定数，型の定義(具体的には，構造体(や C++ のクラス)の定義になる)，
関数のプロトタイプ宣言を，名前が\verb+.h+で終るファイルにまとめる．
これを，ヘッダファイルという．
ヘッダファイルは，関連する型(1つの場合もある)ごとにまとめる．

 \item[(b)] {\bf プログラムファイル}	\\
C や C++ の関数の処理を記述するファイルをプログラムファイルという．
プログラムファイル名は，C 言語では \verb+.c+で，
C++ 言語では \verb+.cc+，\verb|.c++|，\verb+.cpp+ などで終るようにする．
プログラムファイルの先頭では {\tt \#include}で必要なヘッダファイルを
インクルードする．

プログラムファイルは，例えば，それぞれの型毎に1つずつにわけ，
特定のアプリケーションの主プログラムなども，型とは別のファイルにする．
このようにすると，例えば上の例では，
2次元ベクトルを用いた主プログラムを変更しても，
2次元ベクトルの加算，減算などの関数のファイルには影響がないことになる．

\end{enumerate}

複数のソースファイルから成るプログラムをコンパイルするには，	\\
\hspace*{10mm}{\tt \% cc vector2c.c vec2ex1c.c}	\\
\hspace*{10mm}{\tt \% c++ vector2p.cc vec2ex1p.cc}	\\
のように，必要なソースファイル名を並べればよい．
また，\\
\hspace*{10mm}{\tt \% cc -c vector2c.c}	\\
\hspace*{10mm}{\tt \% cc -c vec2ex1c.c}	\\
のように，個々のファイル毎にコンパイルしておき，後で，	\\
\hspace*{10mm}{\tt \% cc vector2c.o vec2ex1c.o}	\\
のようにリンクだけ行なうこともできる．
これを{\bf 分割コンパイル}という．
}

\section{C++言語で型を作る}

\subsection{C言語での型作りの弱点}

前節のように，C言語でも抽象データ型を作ることはできるが，
ソースコードがもっと複雑で大規模になった場合,
あるいは複数のプログラマで分担して作業するような場合に，
次のような問題や不都合が生じる．

\begin{enumerate}

 \item[(1)] 構造体\verb+vector2+のメンバ変数に，
どのような状況でも直接アクセスができる．
メンバ変数の値が直接変更されると，どのような影響があるかがわかりにくい．
プログラマの心がけに任せるばかりでなく，
むしろ積極的に，上位のプログラム部分では，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
vec0.x = vec1.x + vec2.x;
vec0.y = vec1.y + vec2.y;
\end{verbatim}
\end{quote}
のようなプログラムは書けないように制限を加えたい．

 \item[(2)] 加算の対象としたいものは，2次元ベクトルばかりでなく，
3次元ベクトルも行列もある．
それらは「加算」という意味では同じである. 
ところが，異なる対象の加算は\verb+addv2+，\verb+addv3+，
\verb+addmatrix+ などそれぞれ別々の関数名を付ける必要があるので，
非常に煩わしい．

\end{enumerate}

\subsection{C++言語ではクラスによって型作りが楽になる}

C++ では，上のような問題を解決するために，
{\bf クラス}という機構が提供されている．
クラスは，(C言語の)構造体が持つ「データを一まとまりにする」機能に，
そのデータにアクセスする関数(操作)を組にしたもの
({\bf データと手続きのカプセル化 encapsulation})である．

2次元ベクトル型を，クラスで表現すると以下のようになる．
(なお C++ では，\verb+//+から行末まではコメントになる. )
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class Vector2 {
// メンバ変数
private:
        double x;       // x値
        double y;       // y値
// メンバ関数
public:
        Vector2(void)   { }
                // デフォルトコンストラクタ(初期値不定)
        Vector2(double x0, double y0);
                // x0, y0 を与えて定数 (x0, y0) を得るコンストラクタ
        Vector2 add(Vector2 u);
                // 自身のベクトルとベクトル u との和を求める
        ....
};
\end{verbatim}
\end{quote}

クラスでは，構造体と同じようにメンバ変数を宣言する．
ただし，アクセス指定子 \verb+private:+ によって，メンバ変数 \verb+x+と
\verb+y+ をこのクラスのメンバ関数 (後述) 以外からは直接アクセスできない
「プライベート (私的) な」変数とすることができる．
これにより，メンバ変数が知らないうちに変更される心配はなくなる．

次に，メンバ関数は，このクラスの変数に直接作用するようによばれる．
例えば，上位のプログラムでは，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
Vector2 v1, v2, v3;
...
v3 = v1.add(v2);
\end{verbatim}
\end{quote}
という形で呼ばれる．
これは，C言語の場合には，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
v3 = addv2(v1, v2);
\end{verbatim}
\end{quote}
と書いていたことに相当する．

メンバ関数は，例えば次のように定義される．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
Vector2 Vector2::add(Vector2 u)
{
        Vector2 ret;

        ret.x = x + u.x;
        ret.y = y + u.y;

        return ret;
}
\end{verbatim}
\end{quote}
ここで，ただの \verb+x+ と \verb+y+ は\footnote{実際には「このデータ (オ
 ブジェクト) へのポインタ」を表す \verb+this+ を使い \verb+this->x+ と \verb+this->y+
 と書くところで, \verb+this->+ が省略されている. }
 \verb+add+ 関数の作用する変数，つ
まり \verb+v1.add(v2)+ では \verb+v1+ のメンバ変数 \verb+v1.x+,
\verb+v1.y+ を指す．

クラス名と同じ関数名のメンバ関数は，{\bf コンストラクタ}と呼ぶ. 
コンストラクタはメンバ変数を初期化するためのものであり, その返り値は，そ
のクラス型のデータ (オブジェクト) と決まっている．
変数の初期化し忘れを防ぐために, コンストラクタは必ず呼び出されることになっ
ている. 
コンストラクタは引数を持つこともできるが，
特に，引数の無いコンストラクタは変数宣言などの際に暗黙のうちに呼び出され
るので, {\bf デフォルトコンストラクタ}と呼ばれる. 

上の例では, メンバ関数はアクセス指定子 \verb+public:+ によって外部から使
うことができる「公開された」関数になっている．
メンバ変数, メンバ関数は, 
それぞれ \verb+private:+ (そのクラス以外からはアクセス不可能), 
あるいは \verb+public:+ (そのクラス以外からもアクセス可能) にできる. 
メンバ変数を \verb+private:+ に，
メンバ関数を \verb+public:+ にするのが典型的である．

\EXERCISE{
(C++言語による) 2次元ベクトル型のソースファイルが，
\verb+vector2p.h+および\verb+vector2p.cc+として，
またそれを使った簡単な主プログラムが\verb+vec2ex1p.cc+として，
それぞれ用意されている．以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] プログラムをコンパイルし，実際に動くことを確かめよ．

\item[(2)] クラス\verb+Vector2+の減算のメンバ関数を
\verb+vector2p.h+および\verb+vector2p.cc+に追加し，
また，\verb+vec2ex1p.c+の主プログラムに減算のテストを追加し，
減算が行われることを確かめよ．

%%% 検討: 内積の関数
%%% 検討: 引数をポインタ型に変える演習

\end{enumerate}

}

\EXERCISE{
2次元ベクトル型を参考にして，2次正方行列型をクラスとして実現せよ．
また，簡単な主プログラムを作成し，実際に動くことを確認せよ．

2次正方行列型は，少なくとも，入力，出力，加算，減算，乗算の
各メンバ関数を持つようにせよ．
なお，クラスの実現には，$2 \times 2$の2次元配列を用いればよい．

}

\section{クラスで集合を表す}

集合は数学の重要な基礎概念であると同時に，
集合の実現は，プログラミングの重要な基礎でもある．
ここでは，トランプのカードを例に，クラスによる集合の実現を扱う．

\subsection{トランプの手は集合である}

まず，カード1枚を表すのデータ型を考える．
トランプのカードには，スペード $\spadesuit$，
ダイヤモンド $\diamondsuit$，ハート $\heartsuit$，
クラブ $\clubsuit$ の 4 つのスート
\footnote{それぞれ剣, コイン, カップ, 木杖のシンボルで, アリストテレスの
四元素説の 風, 土, 水, 火 を表す. }があり, 
それぞれのスートにエース (A)，2 から 10 までの字札，
そして Jack, Queen, King のコートカード (絵札) の
計 13 枚がある. 
ここでは, さらに 1 枚ジョーカー (道化師) Joker を加え, 
計53枚のセットとする．

ここでは，カードのスート (suit) と番号 (number) を別々のメンバ変数として
持つトランプカード型 \verb+Card+ を考える．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class Card {
// メンバ変数
private:
        int suit;       // 組
        int number;     // 番号
// メンバ関数
public:
        ...
};
\end{verbatim}
\end{quote}
なお，\verb+suit+ の値とスペード，ダイアモンド等との具体的な対応は，
\verb+enum+ によってつける. 

次に，一人のプレーヤの「手」の表現方法を考える．
これは，トランプカードの集合であると考えられる．
ここでは集合の実現に配列を用いる\footnote{
いわゆる線形リストのようなヒープを用いた (動的な) 集合の表現は，今回の実験演習では扱わない．}．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class CardSet {
// メンバ変数
// 定義・宣言
public:
        const int maxnumcard = 53;      // カード総数
private:
        int numcard;            // 現在の集合内のカード数
        Card cdat[maxnumcard];  // カードのデータ
// メンバ関数
	...
};
\end{verbatim}
\end{quote}
カードのデータは配列 \verb+cdat+ に入る．
また \verb+numcard+ の値が10であれば，実際にカードのデータが納められてい
るのは配列 \verb+cdat+ の添字が 0 〜 9 までの範囲とする．
ここでは，トランプを1デッキしか使わないことを仮定しているので，
配列は長さ53あれば十分である. 
この 53 という決まった数をプログラムで参照するのに, C 言語では
\verb+#define+ コンパイラ指令を利用して, マクロとして名前をつけていた. 
C++ では, \verb+const+ 指定をして値を変更できない変数, すなわち定数とし
て宣言し, 利用する. 

\EXERCISE{
トランプカード型およびトランプカードの集合型のソースファイルが
\verb+cardset.h+ および \verb+cardset.cc+ として, 
またそれを使った簡単な主プログラムが \verb+cardsetex1.cc+ として, 
それぞれ用意されている. 
以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] プログラムをコンパイルし，実際に動くことを確かめよ．

\item[(2)] クラス \verb+CardSet+ のメンバ関数 \verb+remove()+ (2種類あり)
を実装して \verb+cardset.cc+ に追加し, 
また, \verb+vec2ex1p.c+の主プログラムにカード削除のテストを追加し，
動作を確認せよ. 

\end{enumerate}

}

C++ ではコンストラクタや \verb+CardSet+ クラスの \verb+remove( )+ 関数の
ように, 同じ名前で異なる引数の関数を定義できる. 
このように同じ名前で異なる関数を定義できる機構を {\bf ポリモルフィズム} という. 

\section{クラスをもとにより大きなクラスを作る}

次に, 具体的なトランプゲームをもとに, ゲームの状態を表すクラスを考える. 
ここでは, いわゆる「ババ抜き」\footnote{もとは $\clubsuit$ の Queen
(Argine) を抜いて行う Old maid というゲームで, 
Joker は日本でトランプに追加されたものだという. }
を取り上げる. 
ババ抜きでは, 各プレーヤの持ち手 (持ち札) がゲームの状態を表すと
考えられる. 
この演習では，既にカードの集合型を実現しているので，
それを利用することを考えると，ババ抜きゲームの状態を表す型は以下のように
なる．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class BabaState {
// 定義・宣言
public:
        const int numplayer = 5;        // プレーヤ数
// メンバ変数
private:
        CardSet hand[numplayer];  // 各プレーヤの持ち手
// メンバ関数
        ...
};
\end{verbatim}
\end{quote}

ゲームの状態は，最初に全員にカードが配られた後は，あるプレーヤが別のプレー
ヤのカードを取り，
必要なら番号が一致する2枚のカードを捨てることによってのみ遷移する．
ここでは，前者をコンストラクタまたは関数 \verb+reset()+ で，
後者を関数 \verb+move()+ で実現しよう．

\EXERCISE{
ババ抜きの状態型のソースファイルが，
\verb+babastate.h+および\verb+babastate.cc+として，
またそれを使った簡単なババ抜きプログラムが
\verb+babanuki1.cc+として，それぞれ用意されている．
以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] \verb+BabaState::move()+は実現されていない．
これを実現し，プログラムをコンパイルし，動作を確かめよ．

\end{enumerate}

}

\section{習うより慣れろ}

以下の4つの課題のうち，1つを選んで取り組め．

\EXERCISE{
\verb+babanuki1.cc+の主プログラムでは，
カードは自動的に選ばれるため，現状では人間が関与する場面がない．
自分が他のプレーヤのカードを取るさいは，
例えば (列の中の) 順番を指定する等して，
実際のゲームのように，人間が関与できるように変更し，実行せよ．
}

\EXERCISE{
ここまで，\verb+Card+クラスは，\verb+suit+と\verb+number+という
二つの整数をメンバ変数に用いて実現してきた．
しかし，例えば，0〜12はスペードの1〜13, 13〜25はダイヤモンドの1〜13
などと決めてやれば，一つの整数でも実現できる．

\verb+CardSet+クラスやメインプログラムに影響を与えることなく，
\verb+Card+クラスの実現方法を変更し実行せよ．
}

\EXERCISE{
ババ抜きの状態を表すクラス \verb+BabaState+ を別の実現方法で実現せよ．
例えば，長さ53の配列にそれぞれのカードの持ち主を記録しておく方法でも
状態を表すことはできる．
}

\EXERCISE{
自分の好きなゲームを取り上げ，そのゲームの状態を表すクラスを実現せよ．
また，簡単な主プログラムを作り，そのクラスが適切に作られていることを確認せよ．
}

\section*{◆レポートの形式内容と提出方法}

\begin{enumerate}
 \item A4 のレポート用紙を用い，上部をステープラでとめること．
 \item 表紙には，
演習名 (知能情報工学実験演習 I--2\ C++演習)，
名前，学生番号，実験日，班名，レポート提出日を明記すること．
 \item 以下の内容を明確に示すこと．
 \begin{enumerate}
  \item 演習ごとの
  \begin{enumerate}
   \item (演習9の場合は)取り上げたゲームの説明
   \item プログラムのリスト
(ただし，最初に与えられたファイルそのままの場合
および前の演習と重複する場合は省略可)
   \item (演習6〜9の場合は)(主な)関数の実現の考え方
(工夫した点および不完全な点を含む)
   \item 考察あるいはこの演習で理解した点
  \end{enumerate}
  \item 全体の考察および感想
 \end{enumerate}
%\item 考察では可能であれば次のようなテーマについて考えてみよ．
 \item レポートは，このテーマの実験最終日の翌週の同一曜日の
xx 時 xx 分から xx 時の間に，
研究棟 7 階の山本教官のもとまで提出すること．
なお，提出時に演習の内容について簡単な質問を行なうことがある. 
内容を理解していないと思われる場合は
レポートを受理しないので注意すること．
\end{enumerate}

\end{document}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%###########%%%


\EXERCISE{

1セットのトランプのカード(これをデッキという)でゲームすることを考える．
ここでは，1デッキには1枚のジョーカーを含む53枚のカードがあるとする．

1デッキ内のカードの部分集合を表す型
(これは1人のプレーヤーの手持ちのカードの集合や捨てカードの集合を表す)
を作れ．

}

\begin{enumerate}

 \item[(1)] カード1枚を表すデータ型を作る(作り方いろいろ)．

 \item[(2)] カードの集合(手持ちのカード)を表す型を作る．
(ただし，使用しているカードは1組とする．(同じカードは1枚しかない．)
(下薗先生案をちょっと変更．
実現方法いろいろ: 配列，線形リスト，ビット表現，木...
それぞれどんな長所短所があるかを考えさせる)

\end{enumerate}

\POINT{ポインタとポインタ引数の説明}{}

\POINT{ヒープとスタックの説明}{}

\section{C++言語で型を作る}

\subsection{C言語には抽象データ型を作りにくいところがある}

＃下薗先生の説明

\subsection{演習3}

\begin{enumerate}

 \item[(1)] 演習1の分数の型をクラスを使って書きかえよ．

\end{enumerate}

\subsection{演習4}

\begin{enumerate}

 \item[(1)] 演習2のカードの集合を表す型をクラスにせよ．
主プログラムを作り確認せよ．

 \item[(2)] 演習2のカードの集合を表すクラスの実現を変えよ．
同じ主プログラムで動くか．動かないとしたら何が原因か．

\end{enumerate}

\section{クラスをもとにより大きなクラスを作る}

\subsection{クラスのメンバ変数にクラスを含めればより大きいクラスが作れる}

分数の実数部，仮数部を持つ虚数クラスの実現

\subsection{演習5}

\begin{enumerate}

 \item[(1)] 虚数クラスを完成させなさい．

\end{enumerate}

\subsection{演習6}

\begin{enumerate}

 \item[(1)] 演習4のカードの集合クラスを用いて，
「ババ抜き」の全プレーヤの状態を表すクラスを作りなさい．
(どんな操作が必要か?)

\end{enumerate}

\section{習うより慣れろ}

\subsection{演習6}

\begin{enumerate}

 \item[(1)] 自分の好きな(カード?)ゲームの状態を表すクラスを作りなさい．
適当な主プログラムを作り，(少なくとも)電子ゲーム盤を作りなさい．
余力のある人は，簡単な思考ルーチンを作ってもよい．

\end{enumerate}

\section{ここで扱っていない大事なこと}

\begin{itemize}

 \item 型の間の関係の表し方(1対1, 1対多, 多対多)

 \item クラスの継承

 \item 演算子の再定義

 \item ...

\end{itemize}

\end{document}


・型とは何か

・抽象データ型

・データ構造は型の実現方法である

・問題に対していきなりベタで変数を書くのではない．
問題の規模に応じた(十分大きな，処理が書き易い)型を作るのが先決．

・型を実現するのに必要なことは，(1)一つのデータを一つにまとめる，(2)一つのデータをまとめて操作できること．

・一つのデータを一つにまとめるには，(Cでは)構造体を用いる．

・ヒープとスタック
・ポインタとポインタ引数

Cでの演習 (card)

・まとめて操作させる上で，Cの構造体は不便である

・情報隠蔽とポリモルフィズムの必要性

C++の説明と演習 (card)

・型を組み合わせてより大きな型を作る

・1対1

・1対多

・多対多

・冗長なデータはまとめてポインタで指す

\end{document}

「文書は人のためならず」という．
